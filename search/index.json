[{"content":"创建项目 需要 Node.js 16.0 或更高版本，执行指令\n1 npm init vue@latest 这一指令将会安装并执行 create-vue\nsetup 执行周期 执行时机比 beforeCreate() 还要早，所以也无法使用 this\n1 2 3 4 5 6 7 8 9 10 \u0026lt;script\u0026gt; export default{ setup(){ console.log(\u0026#39;setip\u0026#39;, this) }, beforeCreate(){ console.log(\u0026#39;beforeCreate\u0026#39;) } } \u0026lt;/script\u0026gt; 执行后，先打印 setup undefined 然后才是 beforeCreate\n数据调用 如果想要在 template 中使用 setup() 函数里定义的数据或函数，必须要 return\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;script\u0026gt; export default{ setup(){ // data const msg = \u0026#39;hello vue3\u0026#39; // function const logMsg = () =\u0026gt; { console.log(msg) } // return return{ msg, logMsg } } } \u0026lt;/script\u0026gt; 只有 return 之后，才可以在 template 里使用\n1 2 3 4 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt;{{ msg }}\u0026lt;/div\u0026gt; \u0026lt;button @click=\u0026#34;logMsg\u0026#34;\u0026gt;button\u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; 语法糖 每次都要返回属实麻烦，实际上可以直接通过在 script 标签加上 setup 这样就可以自动返回，上述就可以改为\n1 2 3 4 5 6 \u0026lt;script setup\u0026gt; const msg = \u0026#39;hello vue3\u0026#39; const logMsg = () =\u0026gt; { console.log(msg) } \u0026lt;/script\u0026gt; 当然，实际上还是会 return 的，只是不用写出来了\n响应式数据 reactive reactive() 函数接收一个对象类型的数据，返回一个响应式的对象\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;script setup\u0026gt; import {reactive} from \u0026#39;vue\u0026#39; const state = reactive({ count: 100 }) const addCount = () =\u0026gt; { state.count++ } \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div\u0026gt;{{ state.count }}\u0026lt;/div\u0026gt; \u0026lt;button @click=\u0026#34;addCount\u0026#34;\u0026gt;+1\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; ref ref() 接收简单类型或复杂类型，返回一个响应式对象。其本质是在原有传入数据的基础上，外层包了一个对象，包成了更复杂类型。其实也是再使用 reactive() 实现的响应式\n所以，在 \u0026lt;script\u0026gt; 中访问数据，需要通过 .value 才行。而在 \u0026lt;template\u0026gt; 中访问数据直接用变量就行。上述例子用 ref() 重写如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;script setup\u0026gt; import {ref} from \u0026#39;vue\u0026#39; const c = ref(0) const addC = () =\u0026gt; { c.value++ } \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div\u0026gt;{{ c }}\u0026lt;/div\u0026gt; \u0026lt;button @click=\u0026#34;addC\u0026#34;\u0026gt;+1\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 实际开发只使用 ref() 会比较灵活统一\ncomputed 计算属性 computed() 与 Vue2 类似，只是变成了可以任意调用的函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;script setup\u0026gt; import { computed, ref} from \u0026#39;vue\u0026#39; const list = ref([1, 2, 3, 4, 5, 6, 7, 8]) const computedList = computed(() =\u0026gt; { return list.value.filter(item =\u0026gt; item \u0026gt; 2) }) \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div\u0026gt;{{ list }}\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;{{ computedList }}\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 这样创建出来的属性是只读的，不是可写的，若需要可写，需要显式声明 get() 与 set()，以下摘自官方示例\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;script\u0026gt; const count = ref(1) const plusOne = computed({ get: () =\u0026gt; count.value + 1, set: (val) =\u0026gt; { count.value = val - 1 } }) plusOne.value = 1 console.log(count.value) // 0 \u0026lt;/script\u0026gt; 摘自: https://cn.vuejs.org/api/reactivity-core.html#computed watch watch() 函数同样是侦听一个或多个数据的变化，数据变化时执行回调函数。不过多了两个额外参数 immediate 和 deep\n单个数据 1 2 3 watch(count, (newValue, oldValue) =\u0026gt; { console.log(\u0026#39;count changed\u0026#39;, oldValue, newValue) }) 多个数据 1 2 3 watch([count, name], ([newCount, newName], [oldCount. oldName]) =\u0026gt; { console.log(\u0026#39;count or name has changed\u0026#39;, [newCount, newName], [oldCount. oldName]) }) 示例，这里我用了简化的 pug，不过其实也很好懂啦\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 \u0026lt;script setup\u0026gt; import { ref, watch } from \u0026#39;vue\u0026#39; const count = ref(0) const name = ref(\u0026#39;John\u0026#39;) const addCount = () =\u0026gt; count.value++ const changeName = () =\u0026gt; name.value = \u0026#39;Mike\u0026#39; // 监视单个数据的变化 watch(count, (newValue, oldValue) =\u0026gt;{ console.log(\u0026#39;count changed\u0026#39;, oldValue, newValue) }) // 监听多个数据的变化 watch([count, name], (newArr, oldArr) =\u0026gt; { console.log(\u0026#39;count or name changed\u0026#39;, oldArr, newArr) }) \u0026lt;/script\u0026gt; \u0026lt;template lang=\u0026#34;pug\u0026#34;\u0026gt; div count: {{ count }} button(@click=\u0026#34;addCount\u0026#34;) +1 div name: {{ name }} button(@click=\u0026#34;changeName\u0026#34;) change name \u0026lt;/template\u0026gt; immediate immediate 表示立即执行，即在进入页面后会立马执行一次，此时的 oldValue 是 undefined\n1 2 3 4 5 watch(count, (newValue, oldValue) =\u0026gt;{ console.log(\u0026#39;count changed\u0026#39;, oldValue, newValue) }, { immediate: true }) deep deep 是深度监视，因为默认 watch 进行浅层监视是无法监视到复杂类型的变化的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 \u0026lt;script setup\u0026gt; import { ref, watch } from \u0026#39;vue\u0026#39; const userInfo = ref({ name: \u0026#39;John\u0026#39;, age: 18 }) const changeUserInfo = () =\u0026gt; { userInfo.value.age++ } watch(userInfo, (newValue) =\u0026gt; { console.log(\u0026#39;userInfo changed\u0026#39;, newValue) }, { deep: true }) \u0026lt;/script\u0026gt; \u0026lt;template lang=\u0026#34;pug\u0026#34;\u0026gt; div {{ userInfo }} button(@click=\u0026#34;changeUserInfo\u0026#34;) change userInfo \u0026lt;/template\u0026gt; 复杂类型单个属性侦听 使用 deep 将会对复杂类型所有属性进行侦听，也就是只要任一属性发生变化，都会执行函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 \u0026lt;script setup\u0026gt; import { ref, watch } from \u0026#39;vue\u0026#39; const userInfo = ref({ name: \u0026#39;John\u0026#39;, age: 18 }) const changeAge = () =\u0026gt; { userInfo.value.age++ } const changeName = () =\u0026gt; { userInfo.value.name = \u0026#39;Mike\u0026#39; } watch(() =\u0026gt; userInfo.value.age, (newValue, oldValue) =\u0026gt; { console.log(\u0026#39;age changed\u0026#39;, oldValue, newValue) }) \u0026lt;/script\u0026gt; \u0026lt;template lang=\u0026#34;pug\u0026#34;\u0026gt; div {{ userInfo }} button(@click=\u0026#34;changeAge\u0026#34;) change age button(@click=\u0026#34;changeName\u0026#34;) change name \u0026lt;/template\u0026gt; 这样就只有 age 改变时候才会触发，且返回值是 age 的值\n生命周期函数 Vue3 的生命周期对比\nOption API Composition API beforeCreate/created setup beforeMount onBeforeMount mounted onMounted beforeUpdate onBeforeUpdate updated onUpdated beforeUnmount onBeforeUnmount unmounted onUnmounted 和组合式 API 的不同就是变成了函数调用，且可以调用多次\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;script setup\u0026gt; import { onMounted } from \u0026#39;vue\u0026#39;; // 组合式的 beforeCreate 和 created 直接写 const getList = () =\u0026gt; { console.log(\u0026#39;从后端获取数据\u0026#39;) } // 执行，进入页面便请求 getList() // 生命周期函数可以调用多次，会按顺序执行 onMounted(() =\u0026gt; { console.log(\u0026#39;逻辑一\u0026#39;) }) onMounted(() =\u0026gt; { console.log(\u0026#39;逻辑二\u0026#39;) }) \u0026lt;/script\u0026gt; ","date":"2025-09-14T22:27:27+09:00","permalink":"https://blog.yexca.net/archives/254/","title":"Vue3 组合式 API 学习"},{"content":"引言 每天刷刷视频，玩玩游戏，本觉得应该是很放松的行为，理应在此之后精神恢复来着，但实际上每天如此的生活却很空乏劳累，这让我产生了疑惑，理论上我并没有做什么高消耗的事情，可如此无精打采属实有点不是太正常\n番茄钟里的困惑 仔细回想之前我之前眼部疲劳，为了护眼时候使用番茄钟学习，开始时候我目的明确，每次休息时间都是远处眺望或者躺下休息一会，效果确实不错，但随着我使用增多，我开始有点想要娱乐性质的行为，比如我利用大的休息时间去看视频，听音乐或者玩游戏之类的，慢慢就觉得效率很差，从而渐渐觉得使用番茄钟很麻烦，不仅学习变累 (有时候学到状态很好，但是强制休息了)，而且玩也感觉不放松，一想着只有 20min 时间，便玩得很担心\n娱乐：另一种专注 但再次思考，也许娱乐行为并不算得上是放松，或者说娱乐和学习一样，也是一种需要专注的行为，而番茄钟的设计就是为了控制专注，之后休息放松，那这个休息放松，应该是身心放松，处于一种对专注行为的恢复\n在我尝试了把自己的大脑放空，什么都不想的前提下，去散步，去公园，去逛书店，明显感觉到这些行为比看视频或者玩游戏更有放松的感觉，虽然消耗的是体力，但娱乐与学习消耗的不如说是精神力吧\n重新定义娱乐与放松 基于此，我觉得可以重申一下我对娱乐的定义，这并不是我在学习劳累后让自己恢复的行为，而应该作为一种同样需要付出精神力的行为，在本就精神力缺失的前提下，继续进行消耗精神力的行为，从而丧失了娱乐的意义，本身就导致了类似“电子阳痿”现象吧\n同时，也可以重新定义放松或者休息，这应该是一种把自己的身心全部打开，漂泊的感觉，或者说在精神力匮乏的时候，进行一些低精神消耗，低体力消耗事情也不错，比如整理卫生，四处闲逛，不带目的，不带意识\n学习与娱乐的模糊界限 那么，既然都需要专注力，这两者之间是不是有共通与不同呢\n我觉得，这取决于兴趣吧，无论是需要多少专注力的事情，取决于一个人对此的兴趣，兴趣高那就是娱乐，兴趣低那往往属于学习的范畴\n例如对于一款游戏，以兴趣为前提，那就是什么好玩怎么玩；以“学习”为前提，就变成了要达到什么目标，做到什么才行\n再比如对于一个电影 IP，以兴趣为前提，那多数是先放空自己，尽情享受就行，对于任何事物只是震撼感；而以“学习”为前提，大抵会变成，对于细节的讨论，了解背景，补全来龙去脉\n当然，两者的界限并不清晰，多数还是取决于个人主观感受\n放松：精神力的真正补给 既然有基于目的需要消耗专注力，那么对于部分放松行为其实也是带有一定的目的的，比如去超市补充生活物资，去书店买书，去公园放松\n一旦带上目的，我觉得这个行为就不是真正的放松了，因为并没有真正放空大脑，从而就不会恢复专注力或者精神力\n放松的部分行为可以说，是以体力的消耗，换来精神力的补偿，如果体力也渐弱，那还是选择躺下吧\n或许真正的休息并不是找一件轻松的事做，而是允许自己什么都不做\n总结 学习让人进步，娱乐让人兴奋，而真正的放松，则让人恢复\n生活不该只有追逐与兴奋，也许我们需要的，不是更多的娱乐，而是学会如何停下来\n","date":"2025-08-22T22:17:38+09:00","permalink":"https://blog.yexca.net/archives/253/","title":"放松不是娱乐：一场精神力的再定义"},{"content":"引言：飘零的学习感 因想着是否可以提升一定的英文水平，所以一般不是很重要的东西我尽量使用英文，比如说游戏或者日常使用的应用软件，但是每次使用都是一种没有任何掌握的感觉，或者说有种很飘零的感觉，仿佛我没有经历过这些东西\n我深入思考，这貌似是从翻译到融入的感觉，当有母语的中文介入的时候，这段学习或经历与母语有了链接，但是完全非母语环境下，这段经历是与母语没有链接的，但我平时使用母语思考，也就自然忽视了非母语思考过程\n类比：控制的执行感 不过以我的实际经历来看，在游戏中完全英文的环境下，我有了一种什么都不懂的感觉，哪怕是再简单的词汇，而假如是和朋友一起语言联机游玩，使用母语进行沟通，貌似又切换成翻译的感觉，使我瞬间觉得轻松了不少，从完全不懂的慌乱到有一定的掌握感\n这不禁让我想到我在东京的生活，也是一种明明我用着日语进行对话，但是心里却总是没什么感觉，一直有一种我是在执行什么预定的指令，而不是在活着，甚至因此我都喜欢上了听中文歌，这样在闲逛的时候才能有我还在活着的感觉\n矛盾：理论最优与现实退宿 不过话又说回来了，这不就是一种语言学习公认的完全脱离母语的思考的理想环境吗，当我完全沉溺于英文游戏时候，没有任何母语的干扰，理论上是最优的学习不是吗，毕竟相当于处于类似 \u0026ldquo;Thinking in English\u0026rdquo; 里\n可是这种无法掌握感，却让我在面临一个自己不认识的单词就会产生我感觉自己什么都做不到，什么都不会的感觉，会自然而然产生一种退缩，就这样什么都不做，什么都不管的状态，其实我觉得自己的英文水平完全没任何进步，甚至觉得反而更没自信了\n反思：完美奇点的幻觉 我开始回顾我的学习经历，突然意识到了自己貌似没有在学习的感觉，或者说一直都是靠直觉经验去判断，无论是游戏还是日常生活，可以获取的信息不只语言，还有动作，指引等其他信息，也许我只是在靠着这些信息，来思考我下一步应该干什么，这种方式给我一种我听懂了目标语言，但实际上语言却成为了被忽略的信息，所以其实也就没做到语言学习\n所以我之前是如何学习 (不只语言) 的呢，貌似是一直想着等到一个“完美”的时机再投入，有一种我一定要等到一切都是“完美”的才能开心，不然就主观认为投入是完全没有任何效果的，这可能就类似于“收藏从未停止，学习从未开始”的感觉\n这不仅体现在我自己的心情感受上，还有类似对环境的要求，对学习材料的要求，类似“广度优先算法”几乎每个阶段都要达到“最优”才能真正开始，不然的话就是“完全无意义”，就算强制自己去做也是无果\n生活：理性与感性的错位 这不禁让我想到了生活方式，对于某件不顺心的事物 (事情、物品等) 可能有短期与长期截然不同的心态，短期内因为该事物所扰心，但可能一想到长期下来，貌似都不是特别重要\n这就好比，一件物品从长期来看可能之后有用，但是当下可能是完全没用的，为了未来可能有用而一直让自己处于“不舒适”的状态，但最后的结果可能是这件物品根本没被用上\n还有整理的错位，理性觉得整理下会更好，感性却不想整理，或者寻找一个“完美点”再整理，这可能造就一种在等到“完美点”来临前每次想到都是心烦\n结论：貌似没有“正解” 所以有没有答案去高效学习或生活呢\u0026hellip;\n我想\u0026hellip;应该是没有的，因为生活充满了理性的决策与感性的决策，可能想着我应该或想要在某个时期提升自己某项能力，可是因为未来的不可预料性，因感受的不同而使得每次执行计划的时候可能会有超出预期与低于预期的结果\n但我觉得，倒也不是完全没有一定的小技巧吧，因为信息不同，可能会瞬间推翻自己原先的计划，那也许可以试着从不同角度约束自己，放弃一个维度，但是使用另一个维度弥补。比如固定时间，使用量来弥补，或者设置最少学习量，使用时间来弥补\n引申：目的性与新鲜感 说到这里，其实我突然想引申一下，我倒是觉得，只要一件事情拥有了目的性，那么这件事情在感性上就会变成难以维持的事情，就算是娱乐比如玩游戏也是，感觉自己压力很大，以释放压力的目的去游玩，本身就有一种时刻在想着自己压力有没有释放的感觉，从而无形产生了压力，导致可能越玩越累，进而出现像是“电子阳痿”的感觉\n因此有人提出了“爱好多一点比较好”，这确实是不错的解决方法，因不同的情况而选择不同的释放压力 (感兴趣为前提) 手段应该是可以避免单独依赖的\n或者其实本质是什么呢，因新事物而产生的新奇感吧\n结语：“不可控”的未来 所以这篇文章到底写了什么呢，我也不知道，可能只是在我混乱下的产物吧\n也是一种，接受生活的“不可控”才是正确的吧，我妄图用理性架构一切，但是貌似\u0026hellip;任何理性都无法解释全部\n虽然正如“状态行为理论”一样，只有获取全部变量，才能知道 100% 可能性的结果，不过我们如何获取全部的“变量”呢\n或许无法获取全部变量，本身就是生活的变量吧\n","date":"2025-08-18T18:27:12+09:00","permalink":"https://blog.yexca.net/archives/252/","title":"漂浮的学习，错位的生活"},{"content":"引言 前几天 (2025-08-13) 我做了一个梦，梦里一个系列的第二部电影《幻梦》的署名是我，虽然不知道是作为导演还是编剧，这部电影的名字也只是从类似这个系列的制片厂的两句短语选出来的，第一部也是，但是两部电影毫无关联\n电影的内容在梦里我只看到了从中间开始，画面中出现双星纠缠、三星纠缠、第二宇宙，然后有一个类似奇点的东西，触发宇宙大爆炸，宇宙重启，生命诞生，小草破土而出，之后我醒了\n虽然梦中这部电影说是与《三体》有关，但是就从我看到的片段来看，感觉貌似没什么关联，梦中我去试映场地几乎可以被认出，宣传也是直接打着《三体》的名号，不过我觉得不是太重要，这点就略过吧\n分析 我反复思索这个梦的内容，首先双星/三星纠缠本身就是一种不稳定的结构，代表了矛盾与不稳定，奇点与宇宙大爆炸，代表了矛盾达到不可调解的地步，就进而引发冲突爆发，之后的生命出现与小草破土而出，代表了新生\n所以其实从这一段来看，是一种不稳定的状态，或者不稳定的纠缠，因为能量无法承受，转而在奇点爆发，迎来新生\n思考 首先这个电影的署名是我，但是我却不知道电影的内容，而梦中看电影的时候感觉我又是主演，我倒是觉得这有点像是讲述着我的人生的感觉，或者我经历的某件事情，因为各种东西错综交织，很不稳定，由我推动爆发，迎来毁灭与新生\n其中在三星纠缠的地方，不知道是观众还是弹幕说是“最难的一帧”可能是指在这个事件中其实已经很不稳定了，但是我还是要主动触发，指代这是很难的决定\n新生 我本以为这是一种希望，指代我人生可能有件走到一半的事情迎来了转机，但后来又思考了下，感觉当下人生貌似没什么转机的事情\n经过我多角度思考，想到试着从电影名称《幻梦》入手，貌似想表示我最近的经历是一次“幻梦”，应该是我主动戳破，从而迎来新生\n亦或者是我可能，也必然会把矛盾激化，迎来一次爆发式的毁灭，但是结局或许是完成了自己的蜕变\n感悟 我给自己构建了一个理性的决策系统，觉得自己人生貌似是在做一些预演的选择而已，那段时间我仿佛不是在生活，而是在机械地选择可能怎么做会更好\n随着选择的增多，因为我一直都是从一个广泛的可能性来看待，虽然可能看起来不错，但是正如我之前想的那样，我的人生没有了自己的感觉，也就和《幻梦》一样，导演是我，主角是我，但是我不知道剧情，只是在看着那部电影，看着我的人生\n随着我开始考虑自己的感受后，开始试着增加自己的喜好优先级，虽然刚开始是很不错的，但是之后慢慢沉沦于自己的感受里面后，渐渐丧失了广泛的理性判断，这就是《幻梦》吧，完全沉沦在自己的感性里，虽然可能比较美好，终究只是一场梦\n于是我在缺失了理性的，这种不稳定的背景下，寻找奇点主动结束这一切，来让我自己完成心理蜕变，开启新生\n反思 我觉得这其实是我在经历几乎全理性和全感性的生活后，心灵的蜕变，意识到了极端的思考不可取，生活本就错综复杂，无法以任何一种事物单独判断\n过于理性会导致缺乏细枝末节的感受，而过于感性会使得生活变得较为混乱，这个平衡可能不好把握，不过人生何尝不是一场“幻梦”呢，自己作为导演，自己作为主角，但是不知道后续\n附言 这篇文章本身也很混乱，但这不正说明我正是在混乱中分析、寻找奇点吗？而这次奇点，就是把它写出来、发布出来。于是我的博客也借此打破断更，迎来新生 😂\n","date":"2025-08-17T01:13:32+09:00","permalink":"https://blog.yexca.net/archives/251/","title":"幻梦"},{"content":" 音有所感系列 歌曲名 翻译 链接 僕が死のうと思ったのは 曾经我也想过一了百了 https://blog.yexca.net/archives/214 あくあ色ぱれっと aqua 的调色盘 https://blog.yexca.net/archives/219 恋の押し売り 恋爱推销 https://blog.yexca.net/archives/220 17さいのうた 17 岁的歌 https://blog.yexca.net/archives/224 drop 坠入爱河 https://blog.yexca.net/archives/230 生きるを選んだ私へ 致选择活下去的自己 https://blog.yexca.net/archives/239 rainy lady 雨意未晴 https://blog.yexca.net/archives/249 恋しくなったら手を叩こう 想谈恋爱的话就拍拍手吧 本文 引言 声音和歌曲的感觉好配，简直绝配了，尤其是 \u0026ldquo;せーのっ\u0026rdquo; 开始后，空灵青春感涌现，很清新很甜的歌风\n因为是新歌 (2025.06.04 发布)，我在当天收到推送，听完其实就想着翻译了，也就开始陷入单曲循环了，经过短暂的努力，感觉稍微有点小清新的感觉了吧，尽量照着我觉得不错的对齐的短句翻译的\n当然也因为是新歌，说实话在这个 \u0026ldquo;音有所感\u0026rdquo; 系列下也没啥感觉，不想其他比较久的歌产生的共鸣多，这歌就像是 Honey Lemon Soda 一样，日常的一点甜就够了\n歌曲视频 歌词 ある時の日常が\n日常的某个时刻呀\n寂しくなっちゃって\n会变得有点寂寞呢\n朝が怖くなって\n渐渐害怕早晨到来\n今眠れないのかい\n是现在还睡不着吧\n大人になったらさ\n以为长大以后呢\n治ると思ってた\n应该就能治好吧\n自己肯定感が\n每天都在一点点\n溶けてく毎日かい\n失去自我肯定感\n耳に張り付いた君の涙声\n耳边环绕着你的哭声\nこんなにつらいから\n会有这么痛苦吗\nこの夜だけは2人で歌いましょう\n只此今夜两个人一起歌唱吧\n甘いお砂糖に溶けるように\n像砂糖般甜蜜地融化着\n回る空気にほら舞うように\n在旋转的空气中轻轻舞动着\n君と踊る 君と踊る\n与你共舞，翩翩起舞\nウォーアイニー\n我爱你\n最後までさ\n一直到最后\n浮かず空色付くまでに\n在天空开始浮现蓝色前\nその言葉が灰になる前に\n在那些语言化为灰烬前\n君と歌う\n和你歌唱\nそれもそれでいいな\n就那样也不错呐\nせーのっ\n预备~\n恋しくなったら手を叩こう\n想要恋爱的话就拍拍手\n明日の前笑顔で手を叩こう\n明天来临前笑着拍拍手\n幸せの意味も知らんけど\n虽然也不知幸福的含义\n今日だけは笑顔で叩こう\n只此时刻来笑着拍拍手\n少しだけ深呼吸して\n稍微深呼吸一下\n君はまだ君で居られる\n你依然可以做你自己\n生きてゆく意味も知らんけど\n虽然我也不知道活着的意义\n恋しくなったら手を叩こう\n但想恋爱了就拍拍手吧\nココロの空調が\n心灵的空调呀\n整えらんなくて\n还没调整好呢\n頬を伝う音に\n划过脸颊的声音\nふと戸惑っちゃったのかい\n一下子就迷茫了吧\nなんにも知らないよ\n我什么也不知道哟\nこの世の定理とか\n这个世界的道理什么的\n誰か偉い人が\n要是有哪位厉害的人\n教えてくれたらね\n告诉我的话就好了呢\n震えるつま先\n震颤的脚尖\n明日の前でさ\n在明天到来前\nなんとか踏ん張って\n还是咬牙撑着吧\nこのまま夜を2人で歌いましょう\n就这样夜里两个人一起歌唱吧\n甘いお砂糖に溶けるように\n像砂糖般甜蜜地融化着\n回る空気にほら舞うように\n在旋转的空气中轻轻舞动着\n君と踊る 君と踊る\n与你共舞，翩翩起舞\nウォーアイニー\n我爱你\n最後までさ\n一直到最后\n浮かぶ空色付くまでに\n在天空开始浮现蓝色前\nその言葉が灰になる前に\n在那些语言化为灰烬前\n君と歌う\n和你歌唱\nそれもそれでいいな\n就那样也不错呐\nせーのっ\n预备~\n恋しくなったら手を叩こう\n想要恋爱的话就拍拍手\n明日の前笑顔で叩こう\n明天来临前笑着拍拍手\n幸せの意味も知らんけど\n虽然也不知幸福的含义\n今日だけは笑顔で叩こう\n只此时刻来笑着拍拍手\n少しだけ深呼吸して\n稍微深呼吸一下\n君はまだ君で居られる\n你依然可以做你自己\n生きてゆく意味も知らんけど\n虽然我也不知道活着的意义\n恋しくなったら手を叩こう\n但想恋爱了就拍拍手吧\n","date":"2025-06-07T01:09:19+09:00","permalink":"https://blog.yexca.net/archives/250/","title":"音有所感 - 《恋しくなったら手を叩こう》"},{"content":" 考虑到此系列文章貌似并不会对他人 \u0026ldquo;日语学习\u0026rdquo; 提供任何帮助，又是可以被检索到的文章，特更改系列名称符合文章系列现状\n怎么说呢，也就是多数是我个人的音乐感想吧，歌词翻译也按照我自己理解 (自己听到的时候的感受) 不一定和原文相符\n音有所感系列 歌曲名 翻译 链接 僕が死のうと思ったのは 曾经我也想过一了百了 https://blog.yexca.net/archives/214 あくあ色ぱれっと aqua 的调色盘 https://blog.yexca.net/archives/219 恋の押し売り 恋爱推销 https://blog.yexca.net/archives/220 17さいのうた 17 岁的歌 https://blog.yexca.net/archives/224 drop 坠入爱河 https://blog.yexca.net/archives/230 生きるを選んだ私へ 致选择活下去的自己 https://blog.yexca.net/archives/239 rainy lady 雨意未晴 本文 恋しくなったら手を叩こう 想谈恋爱的话就拍拍手吧 https://blog.yexca.net/archives/250 引言 这首歌的感受……怎么说呢，其实遇到它的来历，已经在之前那篇文章也写过了: https://blog.yexca.net/archives/243/ 。当时第一次听到这首歌的时候，特别是开头那一段，就有种和我当时心境完全重合的感觉\n当然，我指的是开头那几句。后面的部分，以我当时的日语水平其实听不太明白 (说实话翻译也不是很明白)，整体给人的感觉就是一种无力感，也可能是那种 \u0026ldquo;自己好渺小\u0026rdquo; 的感受吧，像是这个世界上厉害的人太多了，都闪闪发光，真是既羡慕又觉得自己有点可悲\n或许是因为我平时很喜欢听电音（没有人声的音乐） 吧，所以现在听歌时更多是靠主观赋予感情。当我在现实中看到可爱的女孩子，或者遇到很厉害的人时，经常就会想起这首歌的开头。那是一种夹杂着欣赏、憧憬，又有些对自己无力感到惋惜的复杂情绪\n后来仔细看了歌词，怎么说呢，抛开 \u0026ldquo;恋爱\u0026rdquo; 的元素，其实也能读出一种对未来的迷茫感。虽然不能完全撇开吧，我也不知道这段在写什么了，就是一种 \u0026ldquo;想做喜欢的事，却又不敢开口\u0026rdquo; 的心情……也许不只是恋爱中的事情吧\n2025.05.26 唱了这首歌，除了开头，后面都跟不上，也不熟悉调子，图一乐吧，以后听听就好\n不过看到《粛聖!!ロリ神レクイエム☆》有原视频好奇唱了下，还真别说，唱起来还挺爽 doge\n歌曲视频 歌词 は～ぁ可愛いいなぁ\n啊~啊，真可爱呢\nめっちゃキラキラしててすごいなぁ\n非常闪耀真厉害呢\n素直でいいなぁ\n这么坦率真迷人啊\n人気者ってホントすごいなぁ\n那么受欢迎真的很棒呢\n面白くっていいなぁ\n这么有趣好好呢\n友達沢山いるしすごいなぁ\n朋友那么多，真让人羡慕啊\n勝手に目が追っちゃうなぁ\n总是吸引着我的目光呢\n君色に染まちゃってるみたいな\n仿佛要染上你的颜色了呢\nちょうどいい距離にいるのかな\n我和你之前的距离刚刚好吗？\n居心地が良すぎて眠たいわ\n太舒适了想要睡觉呢\n散々してたシミュレーション\n反复在脑海里模拟过\nリハーサル通りいかないものね\n还是不能和预期一样呢\nいつも曖昧なままのふたりの温度\n总是模糊不清的两人之间的温度\n答えなんて何も聞きたくないわ\n答案什么的我一点也不想知道\nどうかしてるかな\n我是不是哪里不对劲了呢\n今日も rainy lady\n今天也是雨季少女\nまだ まだ まだ まだ 雨模様みたい\n还在下\u0026hellip;还在下\u0026hellip;就像心情依旧阴雨绵绵\n切ない距離と 気まずいシチュエーション\n令人心痛的距离和微妙的情境\n期待なんてほんの1ミリくらい\n离期望只有一毫米吧\nあぁついてないなぁ 大きな雨粒\n啊~ 真倒霉呢，落下了大雨滴\nあぁ流れていく\n啊~ 流走吧\nあっ 突然バッタリ会ったり\n啊？偶然又撞见了你\n脳内 君ばっかりだったり\n脑海里只有你了\n笑ったり怒ったり泣いちゃったりも\n笑呀、生气呀、哭也有\nちゃっかりしちゃったり?\n偷偷得逞了？\n本来ドンマイ sorry もー無理\n原来是“别在意啦”，现在连道歉都无力了\nしっかりもうコリゴリ\n真的已经受够了\n一回グッバイさっぱり\n干脆说声再见，说不定会好点\nバイバイした方がいいのかな\n还是拜拜的话比较好吧\nどんな言葉が どんな魔法なら\n要用什么样的语言，什么样的魔法\nどんな恋なら君にまで届くかな\n什么样的恋爱才会传达到你那呢\nヒトリゴトが捗る雨フリの日々に\n一个人自言自语的下雨日子里\n明るい話題もまるでウワノソラ\n就连开心的话题也听的心不在焉\nどうかしてるよね\n我是不是哪里不对劲了呢\nいつも rainy lady\n总是是雨季女士\nてるてるぼうずも悲しそうにしてる\n就连扫晴娘也看起来很伤心\n途切れ途切れに降り続く雨から\n断断续续的降雨\n想定外の贈り物なんて\n意想不到的礼物什么的\nそっと傘の中 また降り出した\n悄悄的，在伞下，又开始下雨了\nAh\n啊\n空の合間に見えた淡い晴れ模様\n在云隙之间，隐约看到转晴的天空\n答えてほしいけど聞きたくなくて\n虽然想听到答案，却又不敢问出口\nなんて意気地なし\n之类的好没出息\nいつだろう sunny day\n什么时候会来呢？晴天\n悲しいくらい天気雨\n很伤心似的下雨天气\nそっと集めつづけた沢山の思いが\n悄悄积攒下来的满满思念呀\n無意識に淡々と溢れてきちゃう\n没意识到已经慢慢溢出来了\n何でもないよ 君がいるなら\n只要你在，其他的都无所谓哟\n雨女でいいや\n雨女也可以啦\n君がいるから oh\n只要你在的话 哦~\nOh, sunny boy\n哦~ 晴天男孩\nRainy lady\n雨天少女\n","date":"2025-05-20T23:44:07+09:00","permalink":"https://blog.yexca.net/archives/249/","title":"音有所感 - 《rainy lady》"},{"content":"本来想着随便写个小东西来着，用个两天就忘记 (以往大多数都是这样)，但在不出错运行的情况下节省了我好多时间，越用越顺手\n慢慢就激发了自己之前的那个 “为什么不用 SQLite 呢” 的想法，确实，每次都开个 MySQL 着实有点过于麻烦了，于是这一版应运而生了，终于不用每次都开数据库服务了 (也终于是人类能用的了)\n使用方法 项目地址: https://github.com/yexca/PixivDownloader-SQLite GUI 与上一代类似，可访问 https://blog.yexca.net/archives/211/ 了解\n配置说明 使用前需要先配置\nrefresh token (Pixiv 登录验证，参考: Pixiv OAuth Flow ) 下载地址 (默认 D:\\Downloads) 下载说明 之后使用只需要输入\n画师 ID，或者 作品 ID (如果两个都填，只会用画师 ID) 点击下载即可下载所有作品并记录到数据库 (对于无数据记录的画师是全部作品，对于有记录的画师只会下载未下载的作品)\n错误处理 关于程序错误，只做了爬取错误处理，如果出现错误弹窗，可能有以下问题\n未配置 refresh token 或已失效 画师账号不存在 作品不存在 我未作具体错误信息提示，出错请检查这三项\n对于其他错误 (直接软件退出的那种)，可以将 程序根目录/logs/app_*-*-*.log 最新的文件发给我并说明问题\n联系方式: PixivDownloader#yexca.net (替换 @)\n新特性: 从 MySQL 到 SQLite 最大修改就是不用自己整个 MySQL 了，采用了轻量的 SQLite\n然后就去除了不需要的数据库配置，将设置与 Pixiv 的认证 Token 放一起了\n加了个 icon (随便找 ChatGPT 画了个)，部分 UI 样式调整，改变不大\n代码初步架构化，虽然写到最后又乱了 不过说不定哪天我就又重新看看了呢\n从旧版 MySQL 数据库迁移方法 虽然我觉得上一个没人会用，不过我还是要说明一下，因为数据库结构问题，最好的方式是查询导出直接用，查询语句\n1 2 3 SELECT ID, name, downloadedDate, lastDownloadID, url FROM pic WHERE platform = \u0026#39;pixiv\u0026#39;; 将结果导出为 SQL 语言 INSERT 格式 (我使用 Dataflare 支持该功能)\n然后整一个 Python 文件，编入以下内容\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 import sqlite3 conn = sqlite3.connect(\u0026#34;pixiv.db\u0026#34;) cursor = conn.cursor() cursor.execute(\u0026#39;\u0026#39;\u0026#39; Create Table If Not Exists pic ( ID TEXT PRIMARY KEY, name TEXT, downloadedDate TEXT, lastDownloadID TEXT, url TEXT ) \u0026#39;\u0026#39;\u0026#39;) conn.commit() cursor.execute(\u0026#34;\u0026#34;\u0026#34; INSERT INTO `pic` (`ID`, `name`, `downloadedDate`, `lastDownloadID`, `url`) VALUES (\u0026#39;123\u0026#39;, \u0026#39;name1\u0026#39;, \u0026#39;2024-06-08 00:00:00\u0026#39;, \u0026#39;1234\u0026#39;, \u0026#39;https://www.pixiv.net/users/123\u0026#39;), (\u0026#39;234\u0026#39;, \u0026#39;name2\u0026#39;, \u0026#39;2025-02-12 00:05:36\u0026#39;, \u0026#39;2345\u0026#39;, \u0026#39;https://www.pixiv.net/users/234\u0026#39;), (\u0026#39;345\u0026#39;, \u0026#39;name3\u0026#39;, \u0026#39;2025-01-11 17:26:17\u0026#39;, \u0026#39;3456\u0026#39;, \u0026#39;https://www.pixiv.net/users/345\u0026#39;); \u0026#34;\u0026#34;\u0026#34; ) conn.commit() cursor.execute(\u0026#34;\u0026#34;\u0026#34; Select * from pic \u0026#34;\u0026#34;\u0026#34; ) rows = cursor.fetchall() for row in rows: print(row) conn.close() 其中 cursor.execute 的内容换成您数据库的备份，这里我留了三条数据作为例子\n然后将生成的数据库文件 pixiv.db 放到 程序根目录/resources 就行\n一点开发感想: 从 \u0026ldquo;乱写\u0026rdquo; 到 \u0026ldquo;理解混乱\u0026rdquo; 说起来这次开发实际上还想着上次写的很乱，觉得必须要整改一下，结果改着改着我就知道为什么当时写的那么乱了😂\n不如说这次改的反而更乱了，写到一半就是想着不重构了，直接复制过来吧，就造成了现在的驼峰命名和下划线命名混在一起，咱也不想动了，唉\n大抵还是个可以运行的半成品，不过能用就行了吧~\n","date":"2025-05-18T16:20:33+09:00","permalink":"https://blog.yexca.net/archives/248/","title":"Pixiv 下载器重构记：从乱写到理解混乱"},{"content":"引言 最近在想着自己要继续做什么或者学什么的时候，老是看到 “DevOps” 这个词。起初我随手一搜，发现上面列的技术栈自己差不多都有所了解，还以为是类似“全栈”那样多掌握点工具 (虽然事实上好像也是) 不过因为没什么兴趣道也就耽搁了 (其实是没开发热情了)\n直到最近躺了快四个月感觉自己应该挣扎一下，于是又想到了这个词。再次了解了一下，怎么说呢\u0026hellip;\u0026hellip;这是卷到极致了是吧，前后端分离人不分离就罢了，这整得开发运维分离人不分离了属于是\n不过话又说回来，看到自动流有 Github Action 的时候不由得让我想起了之前用 Jekyll 博客时候是可以直接自动部署的，但因为我是从其他博客系统迁移的子文件夹分类的习惯还是继续保留着，那个部署不支持子文件夹所以我也就没深入了解了。那么，这次既然都想着整点东西，就看看现在的 Hugo 博客能不能自动部署吧 毕竟每次从容器里下回来再上传还挺麻烦的\n工作流 创建一个工作流是在 Git 仓库根目录的 .github/workflows/ 目录下的 yaml 文件定义的，文件名可以随意，我这次是部署，所以用 deploy.yml\n文件结构大体分为名称、触发器以及工作\n名称 这个就无所谓，起个名字呗\n1 name: Build and Deploy Hugo Blog 触发器 Action Workflow 有多种触发方式，我这里是每次推送触发就行，毕竟基本也就是更新文章，然后就构建\n另外再加一个手动触发，以防有时候是 Github 配置错误还得再下次推送才能启动 Action Workflow\n1 2 3 4 5 on: push: # Git Push 时候触发 branches: - main # 监听源仓库主分支的更新 workflow_dispatch: # 手动触发 工作 我这里只有一个工作，jobs 是可以有多个的，它们并行执行\n首先命名工作的名称\n1 2 jobs: build-deploy: 然后定义运行的内核，在工作名称的下一级，我选择了 ubuntu\n1 2 3 jobs: build-deploy: runs-on: ubuntu-latest 然后定义执行的步骤，第一步克隆仓库\n1 2 3 4 5 6 7 jobs: build-deploy: runs-on: ubuntu-latest steps: - name: Checkout source uses: actions/checkout@v4 然后是安装 Hugo\n1 2 3 4 5 6 steps: - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#39;0.140.1\u0026#39; # 这里是我本地的版本，兼容性应该高点 extended: true # 因为我的主题使用了 SCSS 所以必须使用 extended 版本 接着是构建指令\n1 2 3 steps: - name: Build Hugo Site run: hugo --minify 推送到我部署 Github Page 的仓库\n1 2 3 4 5 6 7 8 steps: - name: Deploy to BlogWeb repo uses: peaceiris/actions-gh-pages@v3 with: external_repository: yexca/Blog-Web-Hugo publish_branch: main # 推送到目标仓库 yexca/Blog-Web-Hugo 的 main 分支 publish_dir: ./public # 推送的当前仓库的文件夹，Hugo 默认是生成到这个文件夹 personal_token: ${{ secrets.PERSONAL_TOKEN }} 所以合起来就是这样\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 name: Build and Deploy Hugo Blog on: push: branches: - main workflow_dispatch: jobs: build-deploy: runs-on: ubuntu-latest steps: - name: Checkout source uses: actions/checkout@v4 - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#39;0.140.1\u0026#39; extended: true - name: Build Hugo site run: hugo --minify - name: Deploy to blogWeb repo uses: peaceiris/actions-gh-pages@v3 with: external_repository: yexca/Blog-Web-Hugo publish_branch: main publish_dir: ./public personal_token: ${{ secrets.PERSONAL_TOKEN }} 配置 Token 因为访问其他仓库是需要 Token 的，所以需要去生成一个\n在自己的 Settings -\u0026gt; Developer Settings -\u0026gt; Personal access tokens -\u0026gt; Fine-grained tokens 生成一个对指定仓库有读写权限的 Token 就可以\n然后到源仓库配置，我的是 yexca/Blog-Source-Hugo 仓库，进入仓库的 Settings -\u0026gt; Secrets and variables -\u0026gt; Actions 的 Repository secrets 添加刚生成的 Token，其中名字就是刚才配置写的 PERSONAL_TOKEN\n处理域名问题 因为 Github Page 使用自己的域名的话是会有一个文件名为 CNAME 填入自定义的域名的，而 Github Action Workflow 推送实际上是直接把原来的全部内容删除再推送过去，所以 CNAME 文件也会被删除，就需要在推送前加上这个文件以自定义域名，有两种方法\n一个是在工作流新建文件\n1 2 3 steps: - name: Add CNAME run: echo \u0026#39;blog.yexca.net\u0026#39; \u0026gt; public/CNAME 或者直接在 Hugo 的 static 文件夹放一个 CNAME 文件，因为该文件夹内容会被直接放到生成的内容根目录\n主题模块问题 因为我的原主题是使用 Git SubModule 加上的，所以推送上去后是直接链接到对应 Github repo 的，可是我已经进行较多修改，这些并不会上传到 Github，因此需要断开链接\n备份主题文件 在此之前先备份，复制到其他文件夹\n1 cp -r themes/Hugo-Theme-Stack tmp/Hugo-Theme-Stack-Backup 移除子模块配置 先初始化子模块\n1 git submodule deinit -f themes/Hugo-Theme-Stack 从 Git 移除\n1 git rm -f themes/Hugo-Theme-Stack 移除文件\n1 rm -rf .git/modules/themes/Hugo-Theme-Stack 再把根目录的 .gitmodules 文件也删除\n1 rm .gitmodules 恢复主题 再把备份的文件送回来\n1 cp -r tmp/Hugo-Theme-Stack-Backup themes/Hugo-Theme-Stack 删除备份文件 (可以先测试后再删)\n1 rm -rf tmp 修复 JS 规范错误 因为自己之前搞的博客运行时间使用了较为古老的八进制数写法，而我采用了命令 hugo -minify 压缩构建的方式，导致产生了错误\n解决仿佛也很简单，原先代码是\n1 Date.UTC(2021, 10, 06, 14, 15, 19) 改成\n1 Date.UTC(2021, 10, 6, 14, 15, 19) 结语 这下总算是脱离编译了，从我开始使用 Docker 开始就慢慢习惯了让开发环境和本地系统隔离，这样更换系统更换服务器什么的只要转移容器就行，所以开发向来都是与实机隔离的，也渐渐培养出了环境洁癖了\n现在好了，构建部署都不在本地了，以前是隔离到容器，现在是隔离到云端了，彻底治好环境洁癖了属于是\n不过再次来看 DevOps，我感觉这何尝不是现在越来越卷，技术发展越来越便捷带来的产物呢 从早年机器适配、汇编到高级语言的出现，再到容器化部署打破环境障碍，技术每一次迭代带来效率提高门槛降低的同时都在悄悄拔高”起步线“\n虽然为编程生活带来了更大的快捷性，可也顺手提升了行业入门门槛，从而使我更快被下岗了属于是\n不过工作是工作生活是生活，技术迭代是快，可世界的系统迭代、行业迭代不至于这么快，多少还是会给人来点喘息的时间吧\n","date":"2025-05-16T18:14:06+09:00","permalink":"https://blog.yexca.net/archives/247/","title":"拥抱 DevOps：把我的博客构造部署工作甩给 GitHub"},{"content":"引言 又一次的自我介绍时，我不由得又想到了我的博客\n过去我总是直接打开 Google 搜索 yexca 点开第一个结果，进入我的博客\n但自从更换域名以来，无数次搜索 yexca ，我的博客却始终消失在搜索之外\n起初我并没有太在意，以为可能有一些惩罚机制吧，毕竟 Google 建议更换域名后最好做一年的 301 重定向，而我当时只做了半年就到原域名过期时间了\n但，已经两年了吧，再怎么说，也该恢复了吧？\n而且更离谱的是，排名靠前的反倒是一些早就不再维护的网站\n而我，每天更新、调优、折腾着的这个博客，却仿佛被世界遗忘了一样\n于是，我开始寻找原因 打开我的博客，查看 \u0026lt;head\u0026gt; 部分\n嗯？\u0026lt;meta name='description'\u0026gt; 怎么是页面左边那句标语？\n啊这，配置的时候也只是说会出现在那里，我以为和 Argon 的配置类似呢，那么也就是说，这个站点的描述根本意义不明啊\n不过，这句话几乎陪伴了我整个博客生涯，我不想轻易放弃它\n既然如此，就让 JSON-LD 来承担结构化描述的任务吧！\n于是我在主题自定义 \u0026lt;head\u0026gt; 部分，加入\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;script type=\u0026#34;application/ld+json\u0026#34;\u0026gt; { \u0026#34;@context\u0026#34;: \u0026#34;https://schema.org\u0026#34;, \u0026#34;@type\u0026#34;: \u0026#34;Blog\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;yexca\u0026#39;Blog\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;{{ .Site.BaseURL }}\u0026#34;, \u0026#34;inLanguage\u0026#34;: \u0026#34;{{ .Site.Language.Lang }}\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;{{ .Site.Params.description }}\u0026#34;, \u0026#34;author\u0026#34;: { \u0026#34;@type\u0026#34;: \u0026#34;Person\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;yexca\u0026#34; } } \u0026lt;/script\u0026gt; 嗯，同时考虑到是多语言网站，部分内容当然要使用变量适配比较好\n在语言的迷宫中探索 说到多语言网站，那么我换个语言环境搜索的话如何呢？\n于是我在 google.com.hk 、 google.com.tw 、 google.com.jp 搜索 yexca\n结果日文环境是可以搜到我的博客的，但是中文环境是搜不到的，对于英文环境，因为英文也没几个文章，也无所谓吧\n那就很奇怪了，也就是 Google 应该是可以标识到 https://blog.yexca.net 就是 yexca 吧，但其他语言版本怎么那么惨捏\n继续排查下去，我意识到可能还缺少 hreflang 配置，于是我加上了\n1 2 3 4 5 \u0026lt;link rel=\u0026#34;alternate\u0026#34; hreflang=\u0026#34;x-default\u0026#34; href=\u0026#34;https://blog.yexca.net/\u0026#34; /\u0026gt; \u0026lt;link rel=\u0026#34;alternate\u0026#34; hreflang=\u0026#34;zh-CN\u0026#34; href=\u0026#34;https://blog.yexca.net/\u0026#34; /\u0026gt; \u0026lt;link rel=\u0026#34;alternate\u0026#34; hreflang=\u0026#34;zh-TW\u0026#34; href=\u0026#34;https://blog.yexca.net/zh-tw/\u0026#34; /\u0026gt; \u0026lt;link rel=\u0026#34;alternate\u0026#34; hreflang=\u0026#34;ja\u0026#34; href=\u0026#34;https://blog.yexca.net/ja/\u0026#34; /\u0026gt; \u0026lt;link rel=\u0026#34;alternate\u0026#34; hreflang=\u0026#34;en\u0026#34; href=\u0026#34;https://blog.yexca.net/en/\u0026#34; /\u0026gt; 明确告诉搜索引擎，不同语言的用户可以访问不同语言版本，这都是同一个网站\n顺便，这段 \u0026lt;link\u0026gt; 也会出现在文章页面，因为没有做判断，但我的博客并不是所有文章都有全部语言版本，所以这并不需要改变，Google 也会自动理解的\n一点点地补上遗漏 但是我随意打开一个文章，哎呀，上面还是 JSON-LD 的站点介绍，这多少有点奇怪\n于是，我又做了个判断逻辑\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 {{ if .IsHome }} \u0026lt;!-- 首页 JSON-LD --\u0026gt; \u0026lt;script type=\u0026#34;application/ld+json\u0026#34;\u0026gt; { \u0026#34;@context\u0026#34;: \u0026#34;https://schema.org\u0026#34;, \u0026#34;@type\u0026#34;: \u0026#34;Blog\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;yexca\u0026#39;Blog\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;{{ .Site.BaseURL }}\u0026#34;, \u0026#34;inLanguage\u0026#34;: \u0026#34;{{ .Site.Language.Lang }}\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;{{ .Site.Params.description }}\u0026#34;, \u0026#34;author\u0026#34;: { \u0026#34;@type\u0026#34;: \u0026#34;Person\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;yexca\u0026#34; } } \u0026lt;/script\u0026gt; {{ else if .IsPage }} \u0026lt;!-- 文章页 JSON-LD --\u0026gt; \u0026lt;script type=\u0026#34;application/ld+json\u0026#34;\u0026gt; { \u0026#34;@context\u0026#34;: \u0026#34;https://schema.org\u0026#34;, \u0026#34;@type\u0026#34;: \u0026#34;BlogPosting\u0026#34;, \u0026#34;mainEntityOfPage\u0026#34;: { \u0026#34;@type\u0026#34;: \u0026#34;WebPage\u0026#34;, \u0026#34;@id\u0026#34;: \u0026#34;{{ .Permalink }}\u0026#34; }, \u0026#34;headline\u0026#34;: \u0026#34;{{ .Title }}\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;yexca\u0026#39;Blog\u0026#34;, \u0026#34;author\u0026#34;: { \u0026#34;@type\u0026#34;: \u0026#34;Person\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;yexca\u0026#34; }, \u0026#34;publisher\u0026#34;: { \u0026#34;@type\u0026#34;: \u0026#34;Person\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;yexca\u0026#39;Blog\u0026#34; }, \u0026#34;datePublished\u0026#34;: \u0026#34;{{ .Date.Format \u0026#34;2006-01-02\u0026#34; }}\u0026#34;, \u0026#34;dateModified\u0026#34;: \u0026#34;{{ .Lastmod.Format \u0026#34;2006-01-02\u0026#34; }}\u0026#34;, \u0026#34;inLanguage\u0026#34;: \u0026#34;{{ .Site.Language.Lang }}\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;{{ .Params.description | default .Site.Params.description }}\u0026#34; } \u0026lt;/script\u0026gt; {{ end }} 这样首页和文章都会有不同的 JSON-LD，不仅语义更准确，也更符合 Google 的结构化数据推荐规范\n小小的期盼 现在，一切终于完善了\n虽然效果不会立刻显现，但我知道，信号，已经发出去了\n现在唯一需要做的，就是等待，等待 Google 再一次理解我的存在\n我希望，下次在介绍我博客的时候\n可以直接打开 Google，搜索 yexca\n","date":"2025-04-27T17:38:16+09:00","permalink":"https://blog.yexca.net/archives/246/","title":"为了能搜到自己的名字：一次小站 SEO 排查实践"},{"content":" 不是所有刷卡的都是羊毛党，不是所有设计系统的都是程序员。有些人，卡刷得像设计师，系统写得像生活家\n1. 引子：卡粉是什么？ 说起这不得不提到之前看到的卡友七大爱好：\n想办法在国内花外汇 想办法在国外花人民币 想办法把人民币带出境 想办法把外汇带进来 办一些国内没啥用的卡 办一些国外更没啥用的卡 想办法让那些没有密码位数多的资金，在一堆几乎没有实际用途的卡之间周转 这听起来像玩金融游戏，乍一看就是办各种银行卡、追求返现、省手续费、换汇划算……似乎是一种“不值钱的小聪明”\n但对真正的卡粉来说：\n卡粉，不是为了省几块钱，而是在寻找一个多通道、多节点、多限制下的资金最优路径设计\n他们不是在薅羊毛，而是在探索这个世界的架构，做生活系统的架构优化\n2. 系统架构设计做的是什么？ 为了考取系统架构师资格，往往需要了解许多相关术语，比如模块解耦、性能优化、接口规范等等。但抛开这些术语，其实系统架构师做的事情非常明确：\n面对复杂的限制条件，合理分配资源、规划路径、连接各个系统，最终搭建出一个既稳又灵活的整体\n所以系统架构师考虑的不是某一行代码写得漂不漂亮，也不只是画设计图，而是整个系统能不能在复杂现实中顺利运行。比如：\n系统之间如何分工？ 服务之间怎么调用？ 接口应该如何定义，才能适配将来扩展？ 故障发生时怎么定位问题、如何隔离影响？ 在预算有限的情况下，怎样控制性能与成本的平衡？ 系统架构师的角色，有点像在搭积木、也像在修路，还像在打补丁。他们不是在一开始就有完美蓝图，而是在一个有点混乱甚至残破的现实中，一点点规划路线、加固桥梁、替换结构、优化流通\n说白了，就是在现实限制下，把系统设计得跑得稳、改得动、用得起。不是为了炫技，不追求“完美系统”，只在乎“现实中能跑得通”，只为了让系统能长时间活着，而且出了问题也不至于崩盘。这就是系统架构师的美学\n虽然我是为了考试了解到这些，但备考过程中不知不觉中又重拾了玩卡热情\n3. 卡粉世界的「架构问题」 卡粉不是无意义的“省点小钱”，系统架构师也不是在搞“高大上的工程设计”。虽然他们活动的场景完全不同，但本质上，他们都在面对同一种问题：\n在规则复杂、成本有限、目标不明的情况下，寻找最优的通路与结构\n卡粉不是单纯在办卡，而是在设计资金流动路径；\n系统架构师也不是单纯在写代码，而是在规划信息流与控制流。\n卡粉常常在思考“怎么少交手续费、不被风控、还能顺利流转”；\n而架构师则关注“怎么减少故障、提升拓展性、让系统跑得稳”\n虽然我是为了考试才了解到架构师的思维方式，但回头一看，这不就是我玩卡时考虑的事吗？\n卡粉世界 系统架构世界 内核逻辑 手续费 延迟 / 性能开销 成本管理 通道限制 API调用限制 协议兼容 卡组织规则 模块规范 合规性 境内外汇差 跨平台兼容损耗 多环境适配 卡种多样性 技术栈多样性 多模块集成 银行风控 系统安全策略 风险控制 多卡流转路径 数据流向控制 路由与架构设计 卡粉做的不是套利，而是在玩一场关于资金流转结构的设计游戏\n他们不是在“做事”，而是在“做结构”：不只是找哪张卡返现最多，而是设计一个路径，让资金在卡与卡之间以最小代价、最大效率地完成任务\n他们关注的不是“能不能跑”，而是“跑得是不是优雅”；不是“能不能转出来”，而是“这个流转过程是否精巧、顺滑”\n卡粉在找最优卡路径，其实就像是在解一个“多约束下的最短路径问题”；而系统架构师设计服务拓扑，则是在权衡“模块间耦合度 + SLA（服务等级协议）限制”的最优组合\n这两者之间，只是应用领域不同\n4. 探索路径的系统实践 别人是薅羊毛，我是研究生态\n每个卡粉的路径都是独一无二的，因为我们面对的条件都不同：银行不同、账户不同、币种不同、生活方式也不同\n所以卡粉真正的乐趣，不在于照搬别人的攻略，而是运用别人的经验在不断试错中找到属于自己的最优解\n我记得最开始只是想省一点手续费，结果查了一堆资料，发现不同银行之间的转账手续费基于条件和时间各不相同。有的上午转免手续费，有的快但只支持特定币种，有的甚至会莫名其妙被拦截。我就像是在玩一张地图初始全黑的游戏，一点点探索路径、开通通路、标记节点\n一次次的小额尝试让我逐渐搭建起对自己来说成本可控的资金路径，随着进一步探索，我不断刷新手续费的下限，规避掉所有高成本节点，甚至还可以利用币种之间的汇率浮动多换出一点余额\n有些起初看上去“根本做不到”的事，也在一次次试探中逐渐被打通。比如通过虚拟货币交易所实现入金、在现实中直接使用虚拟货币、法币自动兑换为稳定币、以及使用专门的送金服务将钱汇往某些地区……这些方式绕过了传统银行体系，最终达成了原本不可达成的目标\n这个过程，从“无解”变为“打通”，就像一次系统级网络架构的重建。我不是在转账，我是在重新定义一条信息与价值的通路\n听起来复杂？但这不就是一个典型的系统流程设计题吗：\n多个系统之间如何建立连接，完成数据传递？ 不同格式（币种）之间如何转换才能顺利识别？ 哪些节点是可靠的？哪些通路延迟低、失败率小？ 如何将“数据包”（资金）通过合适的协议（出入金方式）传递到最终节点（目标账户）？ 整个过程能不能做到用户（我）视角下的顺滑无感？ 说到底，这就是系统架构的感觉：你不是在堆功能，而是在设计一个清晰、稳定、可持续演进的结构网络\n每一张卡，是一个节点；每一个接口，是一个协议；每一次路线试探与调整，都是一次小规模的架构优化\n这背后就是：路径规划 + 接口适配 + 用户体验，不正是架构师该干的事？\n卡粉玩的，从来不是省钱本身，而是通过对现实金融网络的解构与重组，掌握系统级控制的乐趣与力量\n5. 从卡粉中淬炼出的架构素养 在一次次路径选择、失败尝试、成本权衡与风控试探中，卡粉其实也在锤炼一种架构思维。虽然没有服务器、没有代码，但那种“为了结构稳定与效率美感而不断打磨路径”的过程，本质上就是一种系统设计能力的实践\n这些实践，不知不觉转化成了以下这几类架构素养：\n能力 表现方式 核心精神 熟悉规则 银行细则、限额通道 文档阅读能力 整合能力 多卡联动 系统集成思维 成本意识 手续费优化 性能/预算权衡 模型构建 规划卡间流转路径 架构建模 风控意识 多账号、多备份 高可用设计 审美追求 钱也要走得优雅 工程美感 卡粉其实是用现实世界，在模拟训练一个系统架构师的思维模型\n6. 我的感悟 手续费是敌人，通道是信仰，路径是艺术\n我不是因为热爱刷卡才成为卡粉，而是因为在一次次探索中感受到了“结构之美”。也许我们不是在写代码、不是在跑服务器，但每一次资金的流动、路径的设计，本质上就是在设计一个属于自己的系统架构\n从系统架构师考试备考，到日常生活的卡粉路径搭建，我逐渐意识到：\n我喜欢的不只是把事情做成，而是把路径设计得好看\n别人眼里的小聪明，自己心里的系统美学；\n别人眼里的羊毛党，自己心中的生活架构师。\n卡粉不是单纯为了省钱，更像是在现实世界里训练“系统设计”的能力：可视化问题、逐步迭代、结构合理、美感自洽\n这不是荒谬的浪费时间，而是一个真实可触的“个人系统建构实践”\n卡粉不是省钱，是练手；架构不是发明，是选择\n无论是架构设计，还是卡粉优化，重要的都不是\u0026rsquo;省了多少钱\u0026rsquo;或\u0026rsquo;写了多少代码\u0026rsquo;，而是那个过程里，对世界运行逻辑的掌握与认知\n而我，就是那个站在 ATM 前发呆 10 分钟，只为算清路径的人。也许没有服务器，却一样在架构\n结语：生活就是最大的架构 我们每天刷卡、转账、判断路径、做组合决策，其实就是在进行一场“无形的架构设计实践”\n系统架构不只是服务器与接口的事，它也可能藏在我们钱包、银行卡与支付方式之间\n卡粉的尽头，也许就是一位生活中的系统架构师。\n附录：我的常用资金流转 这段代码是一种对我现实资金流路径的建模尝试。它不是可执行程序，而是我用系统思维重新描绘生活流动结构的方式\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func RouteCNYtoJPY(CNY float64) JPY float64 { HKD := BOCExchange(CNY, to=\u0026#34;HKD\u0026#34;) log.Printf(\u0026#34;Exchanged %.2f CNY to %.2f HKD\u0026#34;, CNY, HKD) Transfer(HKD, from=\u0026#34;BOC\u0026#34;, to=\u0026#34;BOCHK\u0026#34;, by=\u0026#34;pbservice\u0026#34;) log.Println(\u0026#34;Transferred via pbservice → BOCHK\u0026#34;) Transfer(HKD, from=\u0026#34;BOCHK\u0026#34;, to=\u0026#34;Wise\u0026#34;, by=\u0026#34;fpservice\u0026#34;) log.Println(\u0026#34;Transferred via fps → Wise\u0026#34;) JPY := WiseConvert(HKD, to=\u0026#34;JPY\u0026#34;) log.Printf(\u0026#34;Converted %.2f HKD to %.2f JPY via Wise\u0026#34;, HKD, JPY) Deposit(JPY, to=\u0026#34;Revolut\u0026#34;, with=\u0026#34;ApplePay\u0026#34;) return JPY } 另注：本文仅为个人经验分享与娱乐用途，不构成任何财务或法律建议，请理性参考～\n","date":"2025-04-22T00:35:15+09:00","image":"https://github.com/yexca/picx-images-hosting/raw/master/2025/04-FromCardEnthusiastToArchitect/250422.3nrtfm915a.webp","permalink":"https://blog.yexca.net/archives/245/","title":"从卡粉到架构师：生活中的系统设计哲学"},{"content":" 2023 年 04 月，我开始记账。2025 年 04 月，我停止了记账。\n最后一笔记录：¥0\n起点：为了省钱与掌控 起因很简单——控制消费，提升金钱意识。刚开始的确非常有效，帮我遏制了一些不好的消费习惯\n过程：一步步走向最优解与卡粉世界 但慢慢地，为了「更优」的消费，我开始对比、开始寻找最优解。最开始只是商品之间的对比，后来，是付款方式、支付工具，最后，进入了银行优惠和开卡的世界\n为了优惠而去开卡，为了便利而去开卡，但这玩意有点上头，可以说我一步一步走向了卡粉的世界\n一开始是为了省钱，后来是为了方便，最后——是为了集卡\n反噬：记账成为了负担 于是，记账本身，逐渐成了负担。账户越来越多，场景越来越复杂，记账的时间成本、心理成本，早已超过了实际收益\n我常常为了可能只有几块钱的优惠，研究半天。刚开始当然开心，但多了之后，找到最优解不再让我兴奋，反而是一阵空虚取代了最初的喜悦\n转变：从最优解到舒服就好 也许是我变了，消费的心态也变了 从「按需按惠」，到「差不多就行，自己舒服就行」\n我也发现，自己早就突破了原先设定的限额，却没有因此失控。反而越来越明白，比起省钱，时间和心情更重要\n反思：我到底为什么记账？ 当我因为记账，而开始：\n因为账户多而不断翻找 因为货币转换而频繁在记账软件创建新账号 因为商品该不该买而计较半天 因为和朋友出去游玩消费而破坏心情 我不得不开始反思——我记账，到底是为了什么？ 这其中的收益，真的值得吗？\n决定：放下，归零，重新出发 于是我尝试着放下，尝试着不去管细节，只问自己：「我快乐吗？」 结果是——真的很快乐。而支出，也没有想象中那么高 或许，是习惯让我潜移默化地比过价。或许，情绪的价值，本来就无法用优惠来衡量\n所以，我想，是时候放手了\n记账，已经完成了它的使命 它不再是工具，而是成为了束缚\n行为习惯是为了更好的生活，当它无法再靠热情消解，当它反而阻碍了生活，那就该学会告别\n尾声：谢谢自己，继续生活 虽然放弃了自己坚持了两年的习惯，确实有些不舍 但这大概也是人生的一部分吧。没有什么可以陪伴一辈子，但只要在一起的那段时光是美好的，这，就足够了\n可以说我少了一个象征性的「我很省」的工具 但，我更希望未来的自己，不再是靠数字和记录来获得安全感，而是靠真正的从容和自在\n从可以掌控，到流入未知 希望自己能早点适应 希望能把省下来的时间，花在更有意义、更值得快乐的事情上\n所以，\n最后一笔，¥0 附上一段小短文 谢谢这两年认真记录的自己 未来，希望把省下来的时间，花在更有意义、更快乐的事情上\n就这样，Archive 了这段经历\n记录是结束，而生活才刚刚开始\n","date":"2025-04-14T16:23:48+09:00","permalink":"https://blog.yexca.net/archives/244/","title":"从省钱，到生活，再到告别"},{"content":"自从我在博客上开始发一些较为专业性的学习内容后，它慢慢变得过于枯燥与乏味，甚至于我打开博客只会想到去学东西，这种心理暗示导致我慢慢得开始对写博客文章有了抵触心理，也早早想到了写点其他的文章但迟迟不知从何下手。正好借着最近的经历，尝试写一篇非技术文章试试吧\n「まだ雨はやまない」 2025-03-23 我买了第一张实体专辑，是 しぐれうい 的 「まだ雨はやまない」，像相册一般的外观简直是太可爱啦！\n不过说到购买经历确是一段较为曲折的心路历程，因为买过太多可能只是第一眼觉得好看的东西，但实际上并不理想的东西过多，再加上经济限制，使得我每次购买非生活必需品的时候总是要做抉择，所以买一个我并不熟悉歌手的专辑无疑是一项比较冒险的决定 (毕竟确实比较贵 doge)\n我在今年 (2025) 一月份的时候在实体店第一次看到这张专辑，感慨下真可爱，埋下了想要购买的种子，顺便认识下 しぐれうい ，3 月 22 日在冲绳在 VRChat 上举行的展览上看到了此次初音的形象设计是 しぐれうい 顿感熟悉 (顺便看了下 23 日的直播)\n初音ミクのライブを見た、可愛かった！\nI watched Hatsune Miku\u0026#39;s live concert, so cute!\n也是看上初音未来的直播了 pic.twitter.com/r1JeMpQ9UA\n\u0026mdash; yexca (@yexcano) March 24, 2025 然后让我想到了这张专辑，当天搜了搜她的歌曲听了几首感觉还行。但当我 23 日想买，并且到了店里后我又退缩了，实际拿到商品后，我开始了解下这张专辑 (实际上我很犹豫了，因为我一般买东西都是既然要买就不了解，亲自体验惊喜，既然了解了就不买)，但应该是还有想买的期望吧，只是看了看有什么歌，因为只有一首熟悉的，我便去旁边漫画店顺手买了个漫画便回去了。在去地铁的路上，习惯性的打开音乐软件听音乐，突然有一首歌特别好听，我下意识点开收藏，不过看到歌名，顿感熟悉，这就是那张专辑里的歌曲！于是我立马掉头，跑到店里去把专辑拿下 (rainy lady 太好听啦)\n提取音乐 不过本身是没有听实体专的需求的，于是引出了写本文的主要目的，那就是把歌曲从专辑提取，主要参考了 https://www.bilibili.com/opus/925630344961458181 本来应该和往常一样，我写一篇自己的经历的，但出现了新的想写进来的内容，便放个超链接吧\n「アルストロメリア」 昨天 (25 日) 我因为本来约定一起打游戏的朋友想出去逛逛而延迟，那我便也出去逛逛吧。这一逛，直接给我看到了 鹿乃 的专辑！！！\n我直接当场拿下，兴奋的心情溢于言表，以我浅薄的文学水平并不知道如何表达内心的愉悦，因为我对 鹿乃 太熟悉了，这里的歌曲并不需要翻录，怀揣着激动的心情打开专辑，看到最后的笑容，内心都被完全治愈了，多么美好的体验。果然购买自己喜爱的事物，多是一件美事啊！\n此时此刻，只让我想起那句：「このような幸せ、あるでしょうか」(世间还有如此美妙的事情吗)\n结语 实际上手写起来还是可以明显感觉到自身内容的匮乏，以及表达的不足，罢了，严格的要求不就和写严谨的技术文章一样了吗，偶尔放松下吧，胡乱写写毫无厘头的也不错\n","date":"2025-03-26T18:18:31+09:00","permalink":"https://blog.yexca.net/archives/243/","title":"收藏我的音乐，珍藏我的心情"},{"content":"应该和之前的笔记编写时间相差不多，因为文件创建时间已经超过考试时间，可能某次移动文件是创造写吧\n操作系统的地位 计算机系统由硬件和软件两部分组成。通常把未配置软件的计算机称为裸机。直接使用裸机不仅不方便，而且将严重降低工作效率和机器的利用率。操作系统 (Operating System) 目的是为了填补人与机器之间的鸿沟，即建立用户与计算机之间的接口，而为裸机配置的一种系统软件\n操作系统在计算机系统中的地位如下图所示\n从图中可见，操作系统是裸机上的第一层软件，是对硬件系统功能的首次扩充。它在计算机系统中占据重要而特殊的地位，所有其他软件，如编辑程序、汇编程序、编译程序、数据库管理系统等系统软件，以及大量的应用软件都是建立在操作系统基础上的，并得到它的支持和取得它的服务\n从用户角度看，当计算机配置了操作系统后，用户不再直接使用计算机系统硬件，而是利用操作系统所提供的命令和服务去操纵计算机，操作系统已成为现代计算机系统中必不可少的最重要的系统软件，因此把操作系统看作是用户与计算机之间的接口\n进程管理 进程管理也称为处理机管理。在多道程序批处理系统和分时系统中有多个并发执行的程序，为了描述系统中程序执行时动态变化的过程引入了进程。进程是资源分配和独立运行的基本单位。进程管理重点需要研究诸进程之间的并发特性，以及进程之间相互合作与资源竞争产生的问题\n程序顺序执行的特征 前趋图是一个有向无循环图，由结点和有向边组成，结点代表各程序段的操作，而结点间的有向边表示两个程序段操作之间存在的前趋关系。程序段 Pi 和 Pj 的前趋关系表示成 Pi→Pj，其中，Pi 是 Pj 的前趋，Pj 是 Pi 的后继，其含义是 Pi 执行结束后 Pj 才能执行\n下图为 3 个结点的前趋图，输入是计算的前趋，输入结束才能进行计算；计算是输出的前趋，计算结束才能输出\n程序顺序执行时的主要特征包括顺序性、封闭性和可再现性\n程序并发执行的特征 若在计算机系统中采用多道程序设计技术，则主存中的多道程序可处于并发执行状态。对于上述有 3 个程序段的作业类，虽然每个作业有前趋关系的各程序段不能在 CPU 和输入/输出各部件并行执行，但是同一个作业内没有前趋关系的程序段或不同作业的程序段可以分别在 CPU 和各输入/输出部件上并行执行。例如，某系统中有一个 CPU 、一台输入设备和一台输出设备，前驱图如下\n程序并发执行时的特征如下\n失去了程序的封闭性 程序和机器的执行程序的活动不再一一对应 并发程序间的相互制约性 进程的状态及其状态间的切换 三态模型 在多道程序系统中，进程在处理器上交替运行，状态也不断地发生变化，因此进程一般有 3 种基本状态：运行、就绪和阻塞\n运行。当一个程序在处理机上运行时，则称该进程处于运行状态。显然，对于单处理机系统，处于运行状态的进程只有一个 就绪。一个进程获得了除处理机外的一切所需资源，一旦得到处理机即可运行，则称此进程处于就绪状态 阻塞。阻塞也称等待或睡眠状态，一个进程正在等待某一事件发生 (例如请求 I/O 等待 I/O 完成等) 而暂时停止运行，这时即使把处理机分配给进程也无法运行，故称该进程处于阻塞状态 进程状态 CPU 资源 运行 √ √ 就绪 × √ 阻塞 × × 五态模型 事实上，对于一个实际的系统，进程的状态及其转换更复杂。例如，引入新建态和终止态构成了进程的五态模型\n进程间的通信 在多道程序环境的系统中存在多个可以并发执行的进程，故进程间必然存在资源共享和相互合作的问题。进程通信是指各个进程交换信息的过程\n同步与互斥：同步是合作进程间的直接制约问题，互斥是申请临界资源进程间的间接制约问题\n进程间的同步 在计算机系统中，多个进程可以并发执行，每个进程都以各自独立的、不可预知的速度向前推进，但是需要在某些确定点上协调相互合作进程间的工作。例如，进程 A 向缓冲区送数据的操作，否则进程 B 必须停下来等待进程 A 的操作结束\n可见，所谓进程间的同步是指在系统中一些需要相互合作，协同工作的进程，这样的相互联系称为进程的同步\n进程间的互斥 进程的互斥是指系统中多个进程因争用临界资源而互斥执行。在多道程序系统环境中，各进程可以共享各类资源，但有些资源一次只能供一个进程使用，称为临界资源 (Critical Resource, CR) ，如打印机、共享变量和表格等\n临界区管理的原则 临界区 (Critical Section, CS) 是进程中对临界资源实施操作的那段程序。对互斥临界区管理的 4 条原则如下\n有空即进。当无进程处于临界区时，允许进程进入临界区，并且只能在临界区运行有限的时间 无空等待。当有一个进程在临界区时，其他欲进入临界区的进程必须等待，以保证进程互斥地访问临界资源 有限等待。对于要求访问临界资源的进程，应保证进程能在有限的时间进入临界区，以免陷入 \u0026ldquo;饥饿\u0026rdquo; 状态 让权等待。当进程不能进入自己的临界区时，应立即释放处理机 (CPU) ，以免进程陷入忙等状态 信号量机制 荷兰学者 Dijkstra 于 1965 年提出的信号量机制是一种有效的进程同步与互斥工具。目前，信号量机制有了很大的发展，主要有整型信号量、记录型信号量和信号量集机制\n整型信号量与 PV 操作 信号量是一个整型变量，根据控制对象的不同被赋予不同的值。信号量分为如下两类\n公用信号量。实现进程间的互斥，初值为 1 或资源的数目 私用信号量。实现进程间的同步，初值为 0 或某个正整数 信号量 S 的物理意义：S ≥ 0 表示某资源的可用数，若 S ＜ 0 则其绝对值表示阻塞队列中等待该资源的进程数\n对于系统中的每个进程，其工作的正确与否不仅取决于它自身的正确性，而且与它在执行中能否与其他相关进程正确地实施同步互斥有关。PV 操作是实现进程同步与互斥的常用方法。P 操作和 V 操作是低级通信原语，在执行期间不可分割。其中 P 操作表示申请一个资源，V 操作表示释放一个资源\nP 操作的定义 S := S - 1 ，若 S ≥ 0 ，则执行 P 操作的进程继续执行；反之，则置该进程为阻塞状态 (因为无可用资源) ，并将其插入阻塞队列\nP 操作可用如下过程表示，其中 Semaphore 表示所定义的变量是信号量\n1 2 3 4 5 Procedure P(Var S:Semaphore); Begain S := S - 1; If S \u0026lt; 0 then W(S) {执行P操作的进程插入等待队列} End; V 操作定义 S := S - 1 ，若 S ＞ 0 则执行 V 操作的进程继续执行；反之，则从阻塞状态唤醒一个进程，并将其插入就绪队列，然后执行 V 操作的进程继续\nV 操作可用如下进程表示\n1 2 3 4 5 Procedure V(Var S:Semaphore); Begain S := S + 1; If S \u0026lt;= 0 then R(S) {从阻塞队列中唤醒一个进程} End; 利用 PV 操作实现进程的互斥 例如以下俩进程可能会导致 COUNT 的值改变不当\n1 2 3 4 5 6 7 8 9 # 1 if 有车通过 then COUNT := COUNT + 1; GOTO L1; # 2 PRINT COUNT; COUNT := 0; GOTO L2; 令信号量互斥 (mutex) 的初值为 1，在进入临界区之前执行 P 操作锁定资源，离开临界区后执行 V 操作，代码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 1 if 有车通过 then begin P(mutex) COUNT := COUNT + 1; V(mutex) end GOTO L1; # 2 begin P(mutex) PRINT COUNT; COUNT := 0; V(mutex) end GOTO L2; 建议观看： 【操作系统】进程间通信—互斥 利用 PV 操作实现进程的同步 进程的同步是由于进程间合作引起的相互制约的问题，要实现进程的同步可用一个信号量与消息联系起来，当信号量的值为 0 时表示希望的消息未产生，当信号量的值为非 0 时表示希望的消息已经存在。假定用信号量 S 表示某条信息，进程可以通过调用 P 操作测试消息是否到达，调用 V 操作通知消息已准备好。最典型的同步问题是单缓冲区的生产者和消费者的同步问题\n建议观看： 【操作系统】进程间通信—同步 同类资源分配不当引起死锁 若系统中有 m 个资源被 n 个进程共享，当每个进程都要求 k 个资源，而 m ＜ nk 时，即资源数小于进程所要求的总数时，可能会引起死锁\n例如，m＝5，n=3，k=3，若系统采用的分配策略是轮流地为每个进程分配，则第一轮系统先为每个进程分配一台，还剩下两台；第二轮系统再为两个进程各分配一台，此时，系统中已无可供分配的资源，使得各个进程都处于等待状态导致系统发生死锁\n事实上，当 m ≥ n × (k - 1) 时不会发生死锁\n死锁的处理 死锁的处理策略主要有四种：鸵鸟策略 (即不理睬策略) 、预防策略、避免策略和检测与解除死锁\n死锁预防 死锁预防是采用某种策略限制并发进程对资源的请求，破坏死锁产生的 4 个必要条件之一，使系统在任何时刻都不满足死锁的必要条件。预防死锁的两种策略如下：\n预先静态分配法。破坏了 \u0026ldquo;不可剥夺条件\u0026rdquo;，预先分配所需资源，保证不等待资源。该方法的问题是降低了对资源的利用率，降低进程的并发程度；有时可能无法预先知道所需资源 资源有序分配法。破坏了 \u0026ldquo;环路条件\u0026rdquo;，把资源分类按顺序排列，保证不形成环路。该方法存在的问题是限制进程对资源的请求；由于资源的排序占用系统开销 死锁避免 死锁避免是设法破坏产生死锁的 4 个必要条件之一，严格防止死锁的产生。死锁避免则不那么严格地限制产生死锁的必要条件。最著名的死锁避免算法是 Dijkstra 提出的银行家算法，死锁避免算法需要很大的系统开销\n建议观看： 银行家算法 线程 传统的进程有两个基本属性：可拥有资源的独立单位；可独立调度和分配的基本单位。引入线程的原因是进程在创建、撤销和切换中，系统必须为之付出较大的时空开销，故在系统中设置的进程数目不宜过多，进程切换的频率不宜太高，这就限制了并发程度的提高\n引入线程后，将传统进程的两个基本属性分开，线程作为调度和分配的基本单位，进程作为独立分配资源的单位。用户可以通过创建线程来完成任务，以减少程序并发执行时付出的时空开销\n这样，对于拥有资源的基本单位，不用频繁地切换，进一步提高了系统中各程序的并发程度。需要说明的是，线程是进程中的一个实体，是被系统独立分配和调度的基本单位。线程基本上不拥有资源，只拥有一点运行中必不可少的资源 (如程序计数器、一组寄存器和栈)，它可与同属一个进程的其他线程共享进程所拥有的全部资源\n","date":"2025-03-16T19:35:38+09:00","permalink":"https://blog.yexca.net/archives/242/","title":"软件设计师 - 操作系统部分笔记"},{"content":"文章写于 2024-04-29，之后改了一次来着，本来以为写完了，但今天看居然没写完，但是相关东西我早就删了来着，唉，就这样吧\n部署 webase 直接部署 fisco bcos\nDocker 部署 CentOS 系统下用 Docker 安装\n环境 首先安装 yum-utils 以使用 yum-config-manager\n1 yum install -y yum-utils 配置源\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 官方源 yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo # 阿里云 yum-config-manager \\ --add-repo \\ https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo # 清华大学 yum-config-manager \\ --add-repo \\ https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/centos/docker-ce.repo 安装\n1 yum install docker-ce docker-ce-cli containerd.io docker-compose-plugin 配置 docker 镜像源\n1 vim /etc/docker/daemon 内容如下 (中科大镜像源)\n1 2 3 { \u0026#34;registry-mirrors\u0026#34;: [\u0026#34;https://docker.mirrors.ustc.edu.cn\u0026#34;] } 启动 docker\n1 systemctl start docker 或者修改配置文件需要，重新加载配置文件，重启 docker 服务\n1 2 systemctl daemon-reload systemctl restart docker.service 安装 python\n1 yum install -y python36 epel-release python36-pip 下载 docker-compose\n1 curl -L \u0026#34;https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)\u0026#34; -o /usr/local/bin/docker-compose 修改执行权限\n1 chmod +x /usr/local/bin/docker-compose 安装 PyMySQL\n1 pip3 install PyMySQL 部署区块链 拉取部署脚本\n1 wget https://osp-1257653870.cos.ap-guangzhou.myqcloud.com/WeBASE/releases/download/v1.5.5/webase-deploy.zip 解压安装包\n1 unzip webase-deploy.zip 进入目录\n1 cd webase-deploy 修改配置文件\n1 vim common.properties 拉取镜像\n1 python3 deploy.py pullDockerAll 拉取镜像时会提示输入超时时间，输入 30/60/120 任意一个即可\n若拉取识别，可手动拉取相关镜像，例如 fiscoorg/fiscobcos:v2.9.1\n1 docker pull fiscoorg/fiscobcos:v2.9.1 部署\n1 python3 deploy.py installDockerAll 看到 deploy has completed 即为部署成功\n常用命令\n1 2 3 4 5 6 7 8 9 10 # 一键部署 部署并启动所有服务 python3 deploy.py installDockerAll 停止一键部署的所有服务 python3 deploy.py stopDockerAll 启动一键部署的所有服务 python3 deploy.py startDockerAll # 节点的启停 启动所有FISCO-BCOS节点: python3 deploy.py startNode 停止所有FISCO-BCOS节点: python3 deploy.py stopNode # WeBASE服务的启停 启动所有WeBASE服务: python3 deploy.py dockerStart 停止所有WeBASE服务: python3 deploy.py dockerStop java 环境部署 不使用 docker 需要 java 环境，CentOS 需要用 Oracle JDK，从其 官网下载 JDK8 后解压，假设文件名为 jdk-8u411-linux-x64.tar.gz\n1 tar -zxvf jdk-8u411-linux-x64.tar.gz 解压后重命名\n1 mv jdk1.8.0_411 jdk-8u411 配置环境变量，修改文件 vim /etc/profile\n1 2 3 export JAVA_HOME=/home/yexca/software/jdk-8u411 export PATH=$JAVA_HOME/bin:$PATH export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOMR/lib/tools.jar 生效\n1 source /etc/profile 查询\n1 java -version 数据库 不使用 docker 需要数据库，安装 MariaDB，首先创建 repo 文件\n1 vim /etc/yum.repos.d/mariadb.repo 文件内容如下，使用阿里云镜像源\n1 2 3 4 5 6 7 8 9 10 11 # MariaDB 11.2 CentOS repository list - created 2024-04-30 03:16 UTC # https://mariadb.org/download/ [mariadb] name = MariaDB # rpm.mariadb.org is a dynamic mirror if your preferred mirror goes offline. See https://mariadb.org/mirrorbits/ for details. # baseurl = https://rpm.mariadb.org/11.2/centos/$releasever/$basearch baseurl = https://mirrors.aliyun.com/mariadb/yum/11.2/centos/$releasever/$basearch module_hotfixes = 1 # gpgkey = https://rpm.mariadb.org/RPM-GPG-KEY-MariaDB gpgkey = https://mirrors.aliyun.com/mariadb/yum/RPM-GPG-KEY-MariaDB gpgcheck = 1 清除缓存\n1 2 yum clean all yum makecache all 安装\n1 yum install -y MariaDB-server MariaDB-client 启动服务\n1 systemctl start mariadb.service 配置\n1 mariadb-secure-installation 部署区块链 拉取安装包\n1 wget https://osp-1257653870.cos.ap-guangzhou.myqcloud.com/WeBASE/releases/download/v1.5.5/webase-deploy.zip 解压\n1 unzip webase-deploy.zip 进入目录\n1 cd webase-deploy 修改配置文件\n1 vim common.properties 部署\n1 python3 deploy.py installAll 启停操作\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # 一键部署 部署并启动所有服务 python3 deploy.py installAll 停止一键部署的所有服务 python3 deploy.py stopAll 启动一键部署的所有服务 python3 deploy.py startAll # 各子服务启停 启动FISCO-BCOS节点: python3 deploy.py startNode 停止FISCO-BCOS节点: python3 deploy.py stopNode 启动WeBASE-Web: python3 deploy.py startWeb 停止WeBASE-Web: python3 deploy.py stopWeb 启动WeBASE-Node-Manager: python3 deploy.py startManager 停止WeBASE-Node-Manager: python3 deploy.py stopManager 启动WeBASE-Sign: python3 deploy.py startSign 停止WeBASE-Sign: python3 deploy.py stopSign 启动WeBASE-Front: python3 deploy.py startFront 停止WeBASE-Front: python3 deploy.py stopFront # 可视化部署 部署并启动可视化部署的所有服务 python3 deploy.py installWeBASE 停止可视化部署的所有服务 python3 deploy.py stopWeBASE 启动可视化部署的所有服务 python3 deploy.py startWeBASE 访问 根据配置项 web.port=5000 确定访问端口 (默认为 5000) 访问管理后台\n防火墙\n1 2 3 4 5 6 7 8 # 查询开放的端口 firewall-cmd --zone=public --list-ports # 开放端口 --permanent为永久开放 firewall-cmd --zone=public --add-port=5000/tcp --permanent # 重启防火墙 firewall-cmd --reload # 查询是否开放 firewall-cmd --zone=public --query-port=5000/tcp 智能合约 2025-03-13: 我也不知道这边写的是啥了\nwebase 后台的合约管理的合约 IDE 创建合约\n编译后新建用户，在私钥管理处\n通过发交易测试是否成功\n参考文章 WeBASE 文档 https://www.runoob.com/docker/centos-docker-install.html https://mariadb.org/download/?t=repo-config\u0026d=CentOS+7\u0026v=11.2\u0026r_m=aliyun https://blog.csdn.net/default7/article/details/122672341 https://www.cnblogs.com/potato-chip/p/13973780.html ","date":"2025-03-13T01:08:02+09:00","permalink":"https://blog.yexca.net/archives/241/","title":"使用 WeBASE 部署 FISCO BCOS 区块链"},{"content":"引言 在国际化后因为也不怎么关注其他语言的文章，直到我之前冲浪的时候，看到了不错的日文字体，这不得给它抄了，然后就发现我这其他语言的字体真是一言难尽啊\n寻找位置 在审查元素发现字体是通过变量控制的，于是我打开了主题里的 scss 文件，查找变量位置，顺利找到\n添加字体 按照原命名方式添加了其他语言的字体变量\n1 2 3 4 5 6 7 8 9 10 11 12 13 /** * Global font family */ :root { --sys-font-family: -apple-system, BlinkMacSystemFont, \u0026#34;Segoe UI\u0026#34;, \u0026#34;Droid Sans\u0026#34;, \u0026#34;Helvetica Neue\u0026#34;; --zh-font-family: \u0026#34;Noto Sans SC\u0026#34;, \u0026#34;PingFang SC\u0026#34;, \u0026#34;Microsoft YaHei\u0026#34;; --zh-TW-font-family: \u0026#34;Noto Sans TC\u0026#34;, \u0026#34;PingFang TC\u0026#34;, \u0026#34;Microsoft JhengHei\u0026#34;; --ja-font-family: \u0026#34;Hiragino Kaku Gothic ProN\u0026#34;, \u0026#34;Hiragino Sans\u0026#34;, \u0026#34;BIZ UDPGothic\u0026#34;, Meiryo; --en-font-family: \u0026#34;Pacifico\u0026#34;, \u0026#34;Dancing Script\u0026#34;, \u0026#34;Lobster\u0026#34;, cursive; --base-font-family: \u0026#34;Lato\u0026#34;, var(--sys-font-family), var(--en-font-family), var(--zh-font-family), var(--zh-TW-font-family), var(--ja-font-family), sans-serif; --code-font-family: Menlo, Monaco, Consolas, \u0026#34;Courier New\u0026#34;, var(--en-font-family), var(--zh-font-family), var(--zh-TW-font-family), var(--ja-font-family), monospace; } 保存、编译，然后没啥用\n设置替换 事实上可以使用 lang 选择器来替换字体，也就检测用网页根标签 \u0026lt;html\u0026gt; 的 lang 属性从而动态替换字体\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 /* 针对中文（简体） */ :lang(zh), :lang(zh-CN) { font-family: var(--zh-font-family); } /* 针对中文（繁体） */ :lang(zh-TW) { font-family: var(--zh-TW-font-family); } /* 针对英语 */ :lang(en) { font-family: var(--en-font-family); } /* 针对日文 */ :lang(ja) { font-family: var(--ja-font-family); } 这样编译以后就好看多啦\n","date":"2025-03-10T23:56:56+09:00","permalink":"https://blog.yexca.net/archives/240/","title":"国际化适配字体"},{"content":" 音有所感系列 歌曲名 翻译 链接 僕が死のうと思ったのは 曾经我也想过一了百了 https://blog.yexca.net/archives/214 あくあ色ぱれっと aqua 的调色盘 https://blog.yexca.net/archives/219 恋の押し売り 恋爱推销 https://blog.yexca.net/archives/220 17さいのうた 17 岁的歌 https://blog.yexca.net/archives/224 drop 坠入爱河 https://blog.yexca.net/archives/230 生きるを選んだ私へ 致选择活下去的自己 本文 rainy lady 雨意未晴 https://blog.yexca.net/archives/249 恋しくなったら手を叩こう 想谈恋爱的话就拍拍手吧 https://blog.yexca.net/archives/250 引言 初看歌曲题目就大概猜到这首歌的大概意思，同时也唤起了我之前对于生命的思考。之前对于为什么活着我始终找不到答案，但是反过来思考为什么不去自杀呢，我尝试过思考自杀的方式以及这些方式会造成的后果，了解到自己对于自杀是恐惧的，因为害怕自杀，所以我选择了活下去。这正好和这歌对应上了\n话说回来，之前我就听过不少 こはならむ 的作品，但是当时都是哭着唱一些歌，一度让我有点看不下去了，有点担心她是否可以好好活下去。直到 Youtube Music 给我推了新歌都是欢乐风格的，当时甚至为她走出悲伤而高兴 (虽然我都没走出来)\n深入了解这首歌后 (把歌词整明白) 才发现这歌真的很不错，要是早点遇到就好了。同时觉得我写这系列文章真不错，让我从自己之前只是会部分的歌曲中学到了很多，我觉得这已经不是从歌曲学日语了，这是从歌曲学人生了，自己之前听的歌的另一面发现的感觉，真的很奇妙，更喜欢了 (其实这里想到了亚斯娜对桐人的质问发现另一面会怎么样，真的会更喜欢啊)\n同时，按照这个系列惯例，翻译并不完全按照原文意思，部分语句玩梗，不适合用梗的后面删了\n2025.05.26 唱了这首歌，词汇有点难，不过喊出来 \u0026ldquo;透明なまま終わっていきなよ、私はもうきっと大丈夫\u0026rdquo; 时候真的很解放，释放情绪的感觉超棒 (然后被不认识的词语打败了)\n歌曲视频 歌词 なつかしい音 なつかしい匂い なつかしい景色\n怀念的声音，怀念的气味，怀念的景色\n蘇よみがえるトラウマ 見たくない顔 聞きたくない声\n再现的 PTSD，不想看见的脸，不想听到的声音\n許せない人たち もう行けなくなっちゃった、あの駅\n无法原谅的人们，已经无法去的，那个车站\n暗い「人目が怖いの」\n消极地“世人的眼光很恐怖”\nそんな記憶 あいして生きる\n那样的记忆也要怀着爱活下去\n透明なまま終わっていきなよ\n别就这样放弃啊\n私はもうきっと大丈夫\n我肯定可以的\n嫌い泣きたいも今振り返れば\n如今再看那些讨厌、想哭的事情\n泡と消える刹那せつな\n也如同泡沫一样转瞬即逝\n私見て下を見た気でいなよ そのまま\n不要小看我啊\n消えてしまいたいと願ったような夜に\n就算是曾经想要消失的夜晚\n笑ってられてるよ 永遠に消えないんだよ\n也能够笑着面对了，永远不会消失\n狭い世界で くだらない談だんに怯おびえてる私\n狭小的世界内，对无意义的话语受伤的我 (这个世界可能指代社交圈小或者说见识少)\n霞かすんで歪ゆがんだ脳 明白めいはくな病\n头脑模糊扭曲，多少有点病\n傷跡きずあとは消えないまま 責任の所在は？\n伤痕无法消失，责任在谁呢\nあの日の子供が泣くのだ 今でも\n那天哭泣的孩子，现在也。。\n今日ものうのう生きている 永世えいせい罪人ざいにん共に問う\n我想问问那些毫无愧疚地活着的永世罪人\n替えの効かないもの 戻らないものに手を出した自じ覚かくはある？\n是否意识到自己伸手染指了那些无可替代，无法挽回的东西？\n許せぬ過去を睨にらんでも仕方ない、って\n说什么就算盯着那些无法原谅的过去也无济于事\n言葉は理解するが 時に解決を促うながさせる\n我懂得这些道理啊，可是。。有时却被迫接受所谓的解决\n卑ひ劣れつさに 愚ぐ劣れつさに\n那份卑鄙，那份愚蠢\n反吐へどが出る 反吐へどが出る\n好恶心啊，恶心地想吐🤮\n「忘れろ」も言葉のナイフだ\n“忘记吧”也是多么伤人的话语\n私は今日も立っている 私は今日も歌っている\n今天，我依然站着，我依然歌唱\n透明なまま終わっていきなよ\n别就这样放弃啊\n私はもう大丈夫\n我已经没问题了\n嫌い泣きたいも今振り返れば\n如今再看那些讨厌、想哭的事情\n私を生かすのは私なのだ\n真正控制我的是我自己啊\n透明なまま終わっていきなよ\n别就这样放弃啊\n私はもう、もう大丈夫\n我肯定，已经没问题了\n嫌い泣きたいも今振り返れば\n如今再看那些讨厌、想哭的事情\n決して消えぬ「愛」か\n一定不会消失的爱吗\n私見て下を見た気でいなよ そのまま\n不要小看我啊\n消えてしまいたいと願ったような夜に\n就算是曾经想要消失的夜晚\n笑っているんだよ 笑っているんだよ 笑っているんだよ\n笑着面对着，欢笑着面对着，已经不在意了\n","date":"2025-03-07T01:26:31+09:00","permalink":"https://blog.yexca.net/archives/239/","title":"音有所感 - 《生きるを選んだ私へ》"},{"content":"同 计算机网络的笔记 的编写时间，毕竟考试这俩部分在一起，都是同时学的\n防火墙技术 防火墙 (Firewall) 是建立在内外网络边界上的过滤封锁机制，它认为内部网络是安全和可信赖的，而外部网络是不安全和不可信赖的\n防火墙的作用是防止不希望的、未经授权地进出被保护的内部网络，通过边界控制强化内部网络的安全策略\n防火墙作为网络安全体系的基础和核心控制措施，贯穿于受控网络通信主干线，对通过受控干线的任何通信行为进行安全处理，如控制、审计、报警和反应等，同时也承担着繁重的通信任务。由于其自身处于网络系统中的敏感位置，自身还要面对各种安全威胁，因此，选用一个安全、稳定和可靠的防火墙产品，其重要性不言而喻\n防火墙技术经历了包过滤、应用代理网关和状态检测技术三个发展阶段\n包过滤防火墙 包过滤防火墙一般有一个包检查块 (通常称为包过滤器) ，数据包过滤可以根据数据包头中的各项信息来控制站点与站点、站点与网络、网络与网络之间的相互访问，但无法控制传输数据的内容，因为内容是应用层数据，而包过滤器处在网络层和数据链路层 (即 TCP 和 IP 层) 之间。通过检查模块，防火墙能够拦截和检查所有出站和进站的数据，它首先打开包，取出包头，根据包头的信息确定该包是否符合包过滤规则，并进行记录。对于不符合规则的包，应进行报警并丢弃该包\n过滤型的防火墙通常直接转发报文，它对用户完全透明，速度较快。其优点是防火墙对每条传入和传出网络的包实行低水平控制；每个 IP 包的字段都被检查，例如源地址、目的地址、协议和端口等；防火墙可以识别和丢弃带欺骗性源 IP 地址的包；包过滤防火墙是两个网络之间访问的唯一来源；包过滤通常被包含在路由器数据包中，所以不需要额外的系统来处理这个特征。缺点是不能防范黑客攻击，因为网管不可能区分出可信网络与不可信网络的界限；不支持应用层协议，因为它不识别数据包中的应用层协议，访问控制粒度太粗糙；不能处理新的安全威胁\n应用代理网关防火墙 应用代理网关防火墙彻底隔断内网与外网的直接通信，内网用户对外网的访问变成防火墙对外网的访问，然后再由防火墙转发给内网用户。所有通信都必须经应用层代理软件转发，访问者任何时候都不能与服务器建立直接的 TCP 连接，应用层的协议会话过程必须符合代理的安全策略要求\n应用代理网关的优点是可以检查应用层、传输层和网络层的协议特征，对数据包的检测能力比较强。缺点是难以配置；处理速度非常慢\n状态检测技术防火墙 状态检测防火墙结合了代理防火墙的安全性和包过滤防火墙的高速度等优点，在不损失安全性的基础上，提高了代理防火墙的性能\n病毒 计算机病毒的特征包括：传播性、隐蔽性、感染性、潜伏性、触发性、破坏性等\nWorm 表示蠕虫病毒、Trojan 表示特洛伊木马、Backdoor 表示后门病毒、Macro 表示宏病毒\n宏病毒感染的对象主要是文本文档、电子表格等\n木马软件：冰河\n蠕虫病毒：欢乐时光、熊猫烧香、红色代码、爱虫病毒、震网\n网络攻击 拒绝服务攻击 (DOS 攻击)：目的是使计算机或网络无法提供正常的服务\n拒绝服务攻击是不断向计算机发起请求来实现的\n重放攻击：攻击者发送一个目的主机己经接受过的报文来达到攻击目的\n攻击者利用网络监听或者其他方式盜取认证凭证，之后再重新发送给认证服务器\n主要用于身份认证过程，目的是破坏认证的正确性\n口令入侵攻击：使用某些合法用户的账号和口令登录到目的主机，然后再实施攻击活动\n特洛伊木马：被伪装成程序或游戏，当用户下载了带有木马的软件或附件吋，这个程序就会向黑客发起连接请求，建立连接后黑客就实施攻击活动\n端口欺骗攻击：采用端口扫描找到系统漏洞从而实施攻击\n网络监听：攻击者可以接收某一网段在同一条物理通道上传输的所有信息，使用网络监听可以轻松截取包括账号和口令在内的信息资料\nIP欺骗攻击：产生的 IP 数据包为伪造的源 IP 地址，以便冒充其他系统成发件人的身份\nSql 注入攻击：是黑客对数据库进行攻击的常用手段之一\n没有对用户输入数据的合法性进行判断，使应用程序存在安全隐患\n攻击者可以提交一段数据库角查询代码，根据程序返回的结果，获得某些他想得知的数据，首先获取数据库的权限，就可获取用户账号和口令信息，以及对某些数据修改等\n入侵检测技术：专家系统、模型检测、简单匹配\n网络安全 SSL (Secure Socket Layer, 安全套接层) 是 Netscape 于 1994 年开发的传输层安全协议，用于实现 Web 安全通信，1996 年发布的 SSL 3.0 协议草案己经成为一个事实上的 Web 安全标准\nTLS (Transport Layer Security, 传输层安全协议) 是 IETF 制定的协议，它建立在 SSL 3.0 协议规范之上，是 SSL 3.0 的后续版本\n终端设备与远程站点之间安全连接的协议是 SSH。SSH 为 Secure Shell 的缩写，是由 IETF 制定的建立在应用层和传输层基础上的安全协议。SSH 是专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题，SSH 最初是 UNIX 上的程序，后来又迅速扩展到其他操作平台\nHTTPS (Hyper Text Transfer Protocol over Secure Socket Layer)，是以安全为目标的 HTTP 通道，即使用 SSL 加密算法的 HTTP\nMIME (Multipurpose Internet Mail Extensions, 多用途互联网邮件扩展类型) 是—个互联网标准，扩展了电子邮件标准，使其能够支持：非 ASCII 字符文本，非文本格式附件 (二进制、声音、图像等) ，由多部分 (multiple parts) 组成的消息体，包含非 ASCII 字符的头信息 (Header information)\nPGP (Petty Good Privacy, 优良保密协议) 是一个基于 RSA 公匙加密休系的邮件加密软件。可以用它对邮件保密以防止非授权者阅读，还能对邮件加上数字签名从而使收信人可以确认邮件的发送方\n","date":"2025-03-04T18:38:28+09:00","permalink":"https://blog.yexca.net/archives/238/","title":"软件设计师 - 信息安全部分笔记"},{"content":"引言 最近下载 Onedrive 分享的东西发现不能被 IDM 自动捕捉，而浏览器下载不稳定老是下载失败，于是我便想着看看有没有办法获取下载直链\n扩展问题 刚开始看到不支持了以为是要重新安装呢，结果删除后去 chrome 扩展商店显示无法安装，啊这，删早了\n不过 IDM 作为付费软件，居然没有跟进更新\n从 简悦项目问题 知道只是按钮整了个 disabled 属性禁用可还行，去掉属性就能正常安装\n获取直链 但，IDM 还是无法捕捉，那只能寻找直链了\n进入分享页面，预览某个文件，右上角 Share - Copy link 可以获取文件分享链接，类似于\n1 https://xxx-my.sharepoint.com/:u:/r/personal/xxx/Documents/xxx/xxx.rar?csf=1\u0026amp;web=1\u0026amp;e=OTZZbx 将其中的 web 替换为 download，类似于\n1 https://xxx-my.sharepoint.com/:u:/r/personal/xxx/Documents/xxx/xxx.rar?csf=1\u0026amp;download=1\u0026amp;e=OTZZbx 复制到 IDM 的 Add URL 下载即可\n参考文章: https://techcommunity.microsoft.com/discussions/onedriveforbusiness/onedrive-direct-download-link/4226744 ","date":"2025-03-02T12:58:57+09:00","permalink":"https://blog.yexca.net/archives/237/","title":"获取 Onedrive 下载直链"},{"content":"从图片链接就能直到这是 2023-04 的笔记了，一直没发是因为几乎就只是知识点而已，不是一种文章的样式，不过毕竟也是笔记，偶尔想查阅的时候还是直接看博客方便啊\n1. 网络设备 层 设备 隔离广播域 隔离冲突域 物理层 中继器 / 集线器 × × 数据链路层 网桥 / 交换机 × √ 网络层 路由器 √ √ 物理层的互连设备 物理层的互连设备有中继器 (Repeater) 和集线器 (Hub)\n中继器 ​ 它是在物理层上实现局域网网段互连的，用于扩展局域网网段的长度\n集线器 ​ 集线器可以看成是一种特殊的多路中继器 (多端口中继器) ，也具有信号放大功能\n数据链路层的互连设备 数据链路层的互连设备有网桥 (Bridge) 和交换机 (Switch)\n网桥 ​ 网桥用于连接两个局域网网段\n交换机 ​ 交换机是多端口的网桥\n网络层的互连设备 路由器 (Router) 是网络层互连设备，用于连接多个逻辑上分开的网络\n应用层的互连设备 网关 (Gateway) 是应用层的互连设备。当连接不同类型且协议差别较大的网络时，则要选用网关设备\n2. 协议簇 计算网络的 TCP/IP 协议簇\n3. TCP 和 UDP 网际层协议 IP 网际层 (网络层) 是整个 TCP/IP 协议簇的重点，在网际层定义的协议除了 IP 外，还有 ICMP、ARP 和 RARP 等几个重要的协议\nIP 所提供的服务通常被认为是无连接的 (Connectionless) 和不可靠的 (Unreliable)。事实上，在网络性能良好的情况下，IP 传送的数据能够完好无损地到达目的地\n所谓无连接的传输，是指没有确定目标系统在已做好接收数据准备之前就发送数据。与此相对应的就是面型连接的 (Connection Oriented) 传输 (如 TCP) ，在该类传输中，源系统与目的系统在应用层数据传送之前需要进行三次握手\n至于不可靠的服务，是指目的系统不对成功接收的分组进行确认，IP 只是尽可能地使数据传输成功。但是只要需要，上层协议必须实现用于保证分组成功提供地附加服务\n由于 IP 只提供无连接、不可靠的服务，所以把差错检测和流量控制之类的服务授权给了其他的各层协议，这正是 TCP/IP 能够高效工作的一个重要保证\n传输层协议 TCP TCP (Transmission Control Protocol, 传输控制协议) 是整个 TCP/IP 协议簇中最重要的协议之一。它在 IP 提供的不可靠数据服务的基础上为应用程序提供了一个可靠的、面向连接的、全双工的数据传输服务\n可靠传输、连接管理、差错检验和重传、流量控制、拥塞控制、端口寻址\n其中流量控制采用的是：可变大小的滑动窗口协议\n利用 TCP 在源主机和目的主机之间建立和关闭连接操作时，均需要通过三次握手来确认建立和关闭是否成功\n传输层协议 UDP 用户数据报协议 (User Datagram Protocol, UDP) 是一种不可靠的、无连接的协议，可以保证应用程序进程间的通信。与同样处在传输层的面向连接的 TCP 相比，UDP 是一种无连接的协议，它的错误检测功能要弱得多。可以这样说，TCP 有助于提供可靠性；而 UDP 有助于提高传输的高速率性。例如，必须支持交互式会话的应用程序 (如 FTP 等) 往往使用 TCP；而自己进行错误检测或不需要错误检测的应用程序 (如 DNS、SNMP 等) 往往使用 UDP\nUDP 协议软件的主要作用是将 UDP 消息展示给应用层，它并不负责重新发送丢失的或出错的数据消息，不对接收到的无序 IP 数据报重新排序，不消除重复的 IP 数据报，不对已收到的数据报进行确认，也不负责建立或终止连接。这些问题是由使用 UDP 进行通信的应用程序负责处理的\nTCP 虽然提供了一个可靠的数据传输服务，但它是以牺牲通信量来实现的。也就是说，为了完成同样一个任务，TCP 需要更多的时间和通信量。这在网络不可靠的时候通过牺牲一些时间换来达到网络的可靠性是可行的，但在网络十分可靠的情况下，则可以采用 UDP，通信量的浪费就会很小\n4. SMTP 和 POP3 电子邮件 (E-mail) 就是利用计算机进行信息交换的电子媒体信件。它是随着计算机网络而出现的，并依靠网络的通信手段实现普通邮件信息的传输。它是最广泛的一种服务\nE-mail 系统基于客户端/服务器模式。E-mail 服务器主要采用 SMTP (简单邮件传输协议) ，本协议描述了电子邮件的信息格式及其传递处理方法，保证被传送的电子邮件能够正确的寻址和可靠的传输，它是面向文本的网络协议，其缺点是不能用来传送非 ASCII 码文本和非文字附件，在日益发展的多媒体环境中以及人们关注的邮件私密性方面更显出它的局限性\n后来的一些协议，包括多用途 Internet 邮件扩充协议 (MIME) 及增强私密邮件保护协议 (PEM) ，弥补了 SMTP 的缺点。SMTP 用在大型多用户、多任务的操作系统中，将它用在 PC 上收信是十分困难的，所以在 TCP/IP 网络上的大多数邮件管理程序使用 SMTP 来发信，且采用 POP (Post Office Protocol, 常用的是 POP3) 来保管用户未能及时取走的邮件\nPOP 协议有两个版本：POP2 和 POP3 。目前使用的 POP3 既能与 STMP 共同使用，也可以单独使用，以传送和接收电子邮件。POP 协议是一种简单的纯文本协议，每次传输以整个 E-mail 为单位，不能提供部分传输\n简单邮件传送协议和用于接收邮件的 POP3 均是利用 TCP 端口。SMTP 所用的端口号是 25，POP3 所用的端口号是 110\n5. ARP 和 RARP 和 DHCP ARP 和 RARP 地址解析协议 (Address Resolution Protocol, ARP) 及反地址解析协议 (RARP) 是驻留在网际层 (网络层) 中的另一个重要协议。ARP 的作用是将 IP 地址转换为物理地址，RARP 的作用是将物理地址转换为 IP 地址\n网络中的任何设备，主机、路由器和交换机等均有唯一的物理地址，该地址通过网卡给出，每个网卡出厂后都有不同的编号，这意味着用户所购买的网卡有着唯一的物理地址。另一方面，为了屏蔽底层协议及物理地址上的差异，IP 协议又使用了 IP 地址，因此，在数据传输过程中，必须对 IP 地址与物理地址进行相互转换\n用 ARP 进行 IP 地址到物理地址转换的过程为：当计算机需要与任何其他的计算机进行通信时，首先需要查询 ARP 高速缓存，如果 ARP 高速缓存中这个 IP 地址存在，便使用与它对应的物理地址直接将数据报发给所需的物理网卡；如果 ARP 告诉缓存中没有该 IP 地址，那么 ARP 便在局域网上以广播方式发送一个 ARP 请求包\n如果局域网上 IP 地址与某台计算机中的 IP 地址相一致，那么该计算机便生成一个 ARP 应答信息，信息中包含对应的物理地址。ARP 协议软件将 IP 地址与物理地址的组合添加到它的高速缓存中，这时即可开始数据通信\nDHCP DHCP (动态主机配置协议) 的功能是：集中的管理、分配 IP 地址、使网络环境中的主机动态的获得 IP 地址、Gateway 地址、DNS 服务器地址等信息，并能提升地址的使用率\nDHCP 客户端可以从 DHCP 服务器获得本机 IP 地址、DNS 服务器地址、DHCP 服务器地址和默认网关的地址等\nWindows 无效地址：169.254.x.x\nLinux 无效地址：0.0.0.0\n168.254.x.x 是 WIndows 系统在 DHCP 信息租用失败时自动给客户机分配的 IP 地址\n6. IP 地址和子网掩码 IP 地址 Internet 地址是按名字来描述的，这种地址表示方式易于理解和记忆。实际上，Internet 中的主机地址是用 IP 地址来唯一标识的。这是因为 Internet 中所使用的网络协议是 TCP/IP 协议，故每个主机必须用 IP 地址来标识\n每个 IP 地址都由 4 个小于 256 的数字组成，数字之间用 . 分开。Internet 的 IP 地址共有 32 位，4 个字节。它有两种表示格式；二进制格式和十进制格式。二进制格式是计算机所认识的格式，十进制格式是由二进制格式 \u0026ldquo;翻译\u0026rdquo; 过去的，主要是为了便于使用和掌握。例如，十进制 IP 地址 129.102.4.11 与二进制的 10000001 01100110 00000100 00001011 相同，显然表示成带点的十进制格式方便得多\n域名和 IP 地址是一一对应的，域名易于记忆、便于使用，因此得到比较普遍的使用。当用户和 Internet 上的某台计算机交换信息时，只需要使用域名，网络会自动地将其转换成 IP 地址找到该台计算机\nInternet 中的地址可分为 5 类：A 类、B 类、C 类、D 类和 E 类。在 IP 地址中，全 0 代表的是网络，全 1 代表的是广播\nA 类网络地址占有 1 个字节 (8 位) ，定义最高位为 0 来标识此类地址，余下 7 位为真正的网络地址，支持 1~126 个网络。后面的 3 个字节 (24 位) 为主机地址，共提供 $2^24-2$ 个端点的寻址\nA 类网络地址第一个字节的十进制值为 000~127\nB 类网络地址占有两个字节，使用最高两位为 10 来标识此类地址，其余 14 位为真正的网络地址，主机地址占后面的两个字节 (16 位) ，所以 B 类全部的地址有 ($2^14-2$)($2^16-2$) = 16382×65534 个\nB 类网络地址第一个字节的十进制值为 128~191\nC 类网络地址占有 3 个字节，它是最通用的 Internet 地址。使用最高三位为 110 来标识此类地址，其余 21 位为真正的网络地址，因此 C 类地址支持 $2^21-2$ 个网络。主机地址占最后 1 个字节，每个网络可多达 $2^8-2$ 个主机\nC 类网络地址第一个字节的十进制值为 192~223\nD 类地址是相当新的。它的标识头是 1110 ，用于组播，例如用于路由器的修改\nD 类网络地址第一个字节的十进制值为 224~239\nE 类地址为实验保留，其识别头是 1111\nE 类网络地址第一个字节的十进制值为 240~255\n网络软件和路由器使用子网掩码 (Subnet Mask) 来识别报文是仅存放在网络内部还是被路由转发到其他地方。在一个字段内，1 的出现表明一个字段包含所有或部分网络地址，0 表明主机地址位置。例如，最常用的 C 类地址使用前 3 个字节来识别网络，最后一个字节 (8 位) 识别主机。因此，子网掩码是 255.255.255.0\nIPv6 简介 IPv6 具有长达 128 位的地址空间，可以彻底解决 IPv4 地址不足的问题。除此之外，IPv6 还采用分级地址模式、高效 IP 包首部、服务质量、主机地址自动配置、认证和加密等许多技术\n7. Windows 命令 ipconfig/release：DHCP 客户端手工释放 IP 地址\nipconfig/flushdns：清除本地 DNS 缓存内容\nipconfig/displaydns：显示本地 DNS 内容\nipconfig/registerdns：DNS 客户端手工向服务器进行注册\nipconfig：显示所有网络适配器的 IP 地址、子网掩码和缺省网关值\nipconfig/all：显示所有网络适配器的完整 TCP/IP 配置信息，包括 DHCP 服务是否已启动\nipconfig/renew：DHCP 客户端手工向服务器刷新请求 (重新申请 IP 地址)\n8. 路由 Windows Server 2003 的路由类型有 5 种。当 Windows 服务器收到一个 IP 数据包时，先查找主机路由，再查找网络路由 (直连网络和远程网络) ，这些路由查找失败时，最后才查找默认路由\n各种路由来源的管理距离如下\n如果路由器收到了由多个路由协议转发的、关于某个目标的多条路由，则比较各个路由的管理距离，并采用管理距离小的路由来源提供的路由信息\n","date":"2025-03-01T23:28:30+09:00","permalink":"https://blog.yexca.net/archives/236/","title":"软件设计师 - 计算机网络部分笔记"},{"content":" Elasticsearch 系列\n内容 链接 Elasticsearch 基础操作 https://blog.yexca.net/archives/226 Elasticsearch 查询操作 https://blog.yexca.net/archives/227 RestClient 基础操作 https://blog.yexca.net/archives/228 RestClient 查询操作 https://blog.yexca.net/archives/229 Elasticsearch 数据聚合 https://blog.yexca.net/archives/231 Elasticsearch 自动补全 https://blog.yexca.net/archives/232 Elasticsearch 数据同步 https://blog.yexca.net/archives/234 Elasticsearch 集群 本文 单机的 es 做数据存储必然面临两个问题：海量数据存储与单点故障问题\n海量数据存储问题：将索引库从逻辑上拆分为 N 个分片 (shard)，存储到多个节点 单点故障问题：将分片数据在不同节点备份 (replica) ES 集群相关概念\n集群 (cluster)：一组拥有共同的 cluster name 的节点 节点 (node)：集群中的一个 ES 实例 分片 (shard)：索引可以被拆分为不同的部分进行存储，称为分片。在集群环境下，一个索引的不同分片可以拆分到不同的节点中 解决问题：数据量太大，单点存储量有限的问题\n分片类似 Hadoop 的 HDFS 的数据分成多份备份\n主分片 (Primary shard)：相对于副本分片的定义 副本分片 (Replica shard)：每个主分片可以有一个或者多个副本，数据和主分片一样 搭建 ES 集群 可以通过 docker-compose 来完成\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 version: \u0026#39;2.2\u0026#39; services: es01: image: elasticsearch:7.12.1 container_name: es01 environment: - node.name=es01 - cluster.name=es-docker-cluster - discovery.seed_hosts=es02,es03 - cluster.initial_master_nodes=es01,es02,es03 - \u0026#34;ES_JAVA_OPTS=-Xms512m -Xmx512m\u0026#34; volumes: - data01:/usr/share/elasticsearch/data ports: - 9200:9200 networks: - elastic es02: image: elasticsearch:7.12.1 container_name: es02 environment: - node.name=es02 - cluster.name=es-docker-cluster - discovery.seed_hosts=es01,es03 - cluster.initial_master_nodes=es01,es02,es03 - \u0026#34;ES_JAVA_OPTS=-Xms512m -Xmx512m\u0026#34; volumes: - data02:/usr/share/elasticsearch/data ports: - 9201:9200 networks: - elastic es03: image: elasticsearch:7.12.1 container_name: es03 environment: - node.name=es03 - cluster.name=es-docker-cluster - discovery.seed_hosts=es01,es02 - cluster.initial_master_nodes=es01,es02,es03 - \u0026#34;ES_JAVA_OPTS=-Xms512m -Xmx512m\u0026#34; volumes: - data03:/usr/share/elasticsearch/data networks: - elastic ports: - 9202:9200 volumes: data01: driver: local data02: driver: local data03: driver: local networks: elastic: driver: bridge es 运行需要修改一些 linux 系统权限，修改 /etc/sysctl.conf 文件\n1 vi /etc/sysctl.conf 添加下面的内容：\n1 vm.max_map_count=262144 然后执行命令，让配置生效：\n1 sysctl -p 通过docker-compose启动集群：\n1 docker-compose up -d 监控集群状态 kibana 可以监控 es 集群，不过需要依赖 es 的 x-pack 功能，配置比较复杂\n可以使用 cerebro 来监控 es 集群，Github： https://github.com/lmenezes/cerebro 运行 bin/cerebro.bat 后访问 http://localhost:9000 即可进入管理界面\n使用 cerebro 可以可视化创建索引库，以下是 DSL 语句创建\n1 2 3 4 5 6 7 8 9 10 11 12 PUT /indexName { \u0026#34;settings\u0026#34;: { \u0026#34;number_of_shards\u0026#34;: 3, // 分片数量 \u0026#34;number_of_replicas\u0026#34;: 1 // 副本数量 }, \u0026#34;mappings\u0026#34;: { \u0026#34;properties\u0026#34;: { // mapping映射定义 ... } } } 集群职责划分 ES 中集群节点有不同的职责划分\n节点类型 配置参数 默认值 节点职责 master eligible node.master true 备选主节点：主节点可以管理和记录集群状态、决定分片在哪个节点、处理创建和删除索引库的请求 data node.data true 数据节点：存储数据、搜索、聚合、CRUD ingest node.ingest true 数据存储之前的预处理 coordinating 上面 3 个参数都为 false 则为 coordinating 节点 无 路由请求到其它节点，合并其它节点处理的结果，返回给用户 默认情况下，集群的任何一个节点都同时具备上述四种角色\n但真实的集群一定要将集群职责分离\nmaster 节点：对 CPU 要求高，但是内存要求低 data 节点：对 CPU 和内存要求都高 coordinating 节点：对网络带宽、CPU 要求高 职责分离可以让我们根据不同节点的需求分配不同的硬件去部署。而且避免业务之间的相互干扰\n集群脑裂问题 脑裂是因为集群中的节点失联导致的\n假设有三个节点，现在主节点 (node1) 与其他节点失联 (网络阻塞)，node2 和 node3 会认为 node1 宕机，就会重新选主。假设 node3 当选，集群会继续对外提供服务，node2 和 node3 自成集群，node1 自成集群，俩集群数据不同步，出现数据差异\n当网络阻塞恢复正常，因为集群中有两个 master 节点，集群状态不一致，出现脑裂的情况\n解决方案：要求选票超过 (eligible 节点数量 + 1) / 2 才能当选为 master 节点，因此 eligible 节点数量最好是奇数。对应的配置项为 discovery.zen.minimum_master_nodes，在 es7.0 以后，已经成为默认配置，因此一般不会发送脑裂问题\n例如上述 3 个节点形成的集群，选票必须超过 (3+1)/2 = 2 票。node3 得到 node2 和 node3 的选票，当选为主，而 node1 只有自己的一票，没有当选。集群中依然只有 1 个主节点，没有出现脑裂\n集群分布式存储 当新增文档时，应该保存到不同分片，保证数据均衡，那么 coordinating node 如何确定数据该存储到哪个分片呢\nes 会通过 hash 算法来计算文档应该存储到哪个分片\n公式：shard = hash(_routing) % number_of_shards\n说明：\n_routing 默认是文档的 id 算法与分片数量有关，因此索引库一旦创建，分片数量不能修改 新增文档流程：\n流程：\n新增一个 id = 1 的文档 对 id 做 hash 运算，假如得到的是 2，则对应存储到 shard-2 shard-2 的主分片在 node3 节点，将数据路由到 node3 保存文档 同步给 shard-2 的副本 replica-2，在 node2 节点 返回结果给 coordinating-node 节点 集群分布式查询 es 的查询分为两个阶段：\nscatter phase：分散阶段，coordinating node 会把请求分发到每一个分片 gather phase：聚集阶段，coordinating node 汇总 data node 的搜索结果，并处理为最终结果集返回给用户 集群故障转移 集群的 master 节点会监控集群中的节点状态，如果发现有节点宕机，会立即将宕机节点的分片数据迁移到其它节点，确保数据安全，这个叫做故障转移\n假设一个集群三个节点，node1 是主节点\nnode1 发生了宕机 需要重新选主，假设选中了 node2 node2 成为主节点后，会检测集群状态，发现 node1 的分片没有副本节点，需要将 node1 上的数据迁移到 node2、node3 ","date":"2025-02-15T17:17:08+09:00","permalink":"https://blog.yexca.net/archives/235/","title":"Elasticsearch 集群"},{"content":" Elasticsearch 系列\n内容 链接 Elasticsearch 基础操作 https://blog.yexca.net/archives/226 Elasticsearch 查询操作 https://blog.yexca.net/archives/227 RestClient 基础操作 https://blog.yexca.net/archives/228 RestClient 查询操作 https://blog.yexca.net/archives/229 Elasticsearch 数据聚合 https://blog.yexca.net/archives/231 Elasticsearch 自动补全 https://blog.yexca.net/archives/232 Elasticsearch 数据同步 本文 Elasticsearch 集群 https://blog.yexca.net/archives/235 es 的数据来自 MySQL 数据库，因此 MySQL 数据发送改变时，es 也必须跟着改变，此为 es 与 MySQL 之间的数据同步\n常见的数据同步方案有三种：\n同步调用 异步通知 监听 binlog 同步调用 步骤：\nhotel-demo 对外提供接口，用于修改 es 中的数据 后台管理系统 (hotel-admin) 在完成数据库操作后，之间调用 hotel-demo 提供的接口 异步通知 步骤：\nhotel-admin 对 mysql 数据完成 CRUD 后发送 MQ 消息 hotel-demo 监听 MQ，接收消息后完成对 es 数据修改 监听 binlog 流程：\n开启 MySQL 的 binlog 功能 MySQL 完成 CRUD 操作都会记录在 binlog 中 hotel-demo 基于 canal 监听 binlog 变化，实时更新 es 中的内容 方案对比 方式一：同步调用\n优点：实现简单，粗暴 缺点：业务耦合度高 方式二：异步通知\n优点：低耦合，实现难度一般 缺点：依赖 mq 的可靠性 方式三：监听binlog\n优点：完全解除服务间耦合 缺点：开启 binlog 增加数据库负担、实现复杂度高 数据同步实现 说明：使用 MQ 异步通知，在 hotel-admin 实现对 MySQL 的 CRUD 操作\n在 hotel-admin、hotel-demo 引入 rabbitmq 依赖\n1 2 3 4 5 \u0026lt;!--amqp--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-amqp\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 声明队列、交换机名称\n1 2 3 4 5 6 7 8 9 10 11 12 public class MqConstants { // 交换机 public final static String HOTEL_EXCHANGE = \u0026#34;hotel.topic\u0026#34;; // 监听新增和修改队列 public final static String HOTEL_INSERT_QUEUE = \u0026#34;hotel.insert.queue\u0026#34;; // 监听删除的队列 public final static String HOTEL_DELETE_QUEUE = \u0026#34;hotel.delete.queue\u0026#34;; // 新增或修改的RoutingKey public final static String HOTEL_INSERT_KEY = \u0026#34;hotel.insert\u0026#34;; // 删除的RoutingKey public final static String HOTEL_DELETE_KEY = \u0026#34;hotel.delete\u0026#34;; } 在 hotel-demo 声明交换机配置\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 @Configuration public class MqConfig { @Bean public TopicExchange topicExchange(){ return new TopicExchange(MqConstants.HOTEL_EXCHANGE,true,false); } @Bean public Queue insertQueue(){ return new Queue(MqConstants.HOTEL_INSERT_QUEUE,true); } @Bean public Queue deleteQueue(){ return new Queue(MqConstants.HOTEL_DELETE_QUEUE, true); } @Bean public Binding insertQueueBinding(){ return BindingBuilder.bind(insertQueue()).to(topicExchange()).with(MqConstants.HOTEL_INSERT_KEY); } @Bean public Binding deleteQueueBinding(){ return BindingBuilder.bind(deleteQueue()).to(topicExchange()).with(MqConstants.HOTEL_DELETE_KEY); } } 在 hotel-admin 发送 MQ 消息\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public class HotelController { @Autowired private RabbitTemplate rabbitTemplate; @PostMapping public void saveHotel(@RequestBody Hotel hotel){ hotelService.save(hotel); rabbitTemplate.convertAndSend(MqConstants.HOTEL_EXCHANGE, MqConstants.HOTEL_INSERT_KEY, hotel.getId()); } @PutMapping() public void updateById(@RequestBody Hotel hotel){ if (hotel.getId() == null) { throw new InvalidParameterException(\u0026#34;id不能为空\u0026#34;); } hotelService.updateById(hotel); rabbitTemplate.convertAndSend(MqConstants.HOTEL_EXCHANGE, MqConstants.HOTEL_INSERT_KEY,hotel.getId()); } @DeleteMapping(\u0026#34;/{id}\u0026#34;) public void deleteById(@PathVariable(\u0026#34;id\u0026#34;) Long id) { hotelService.removeById(id); rabbitTemplate.convertAndSend(MqConstants.HOTEL_EXCHANGE, MqConstants.HOTEL_DELETE_KEY, id); } } 在 hotel-demo 接收 MQ 消息，业务逻辑：\n新增消息：根据传递的 hotel.id 查询信息，然后新增一条数据到索引库 删除消息：根据传递的 hotel.id 删除索引库中的一条数据 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 @Override public void deleteById(Long id) { try { // 准备request DeleteRequest request = new DeleteRequest(\u0026#34;hotel\u0026#34;, id.toString()); // 发送请求 client.delete(request, RequestOptions.DEFAULT); } catch (IOException e) { throw new RuntimeException(e); } } @Override public void insertById(Long id) { try { // 根据id查询数据 Hotel hotel = getById(id); // 转换文档类型 HotelDoc hotelDoc = new HotelDoc(hotel); // 准备request IndexRequest request = new IndexRequest(\u0026#34;hotel\u0026#34;).id(id.toString()); // 准备json request.source(JSON.toJSONString(hotelDoc), XContentType.JSON); // 发送请求 client.index(request, RequestOptions.DEFAULT); } catch (IOException e) { throw new RuntimeException(e); } } 在 hotel-demo 编写监听器\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 @Component public class HotelLinster { @Autowired private IHotelService hotelService; /** * 监听修改或新增 * @param id */ @RabbitListener(queues = MqConstants.HOTEL_INSERT_QUEUE) public void listenHotelInsertOrUpdate(Long id){ hotelService.insertById(id); } /** * 监听删除 * @param id */ @RabbitListener(queues = MqConstants.HOTEL_DELETE_QUEUE) public void listenHotelDelete(Long id){ hotelService.deleteById(id); } } ","date":"2025-02-14T20:36:55+09:00","permalink":"https://blog.yexca.net/archives/234/","title":"Elasticsearch 数据同步"},{"content":"这篇文章文件创建到最后修改时间是 2022.10.31 - 2024.09.15，记录了这段时期内我尝过的茶叶以及个人感受\n不过到了较为后期的时候，事实上我已经不是很喜欢这个爱好了，记录就很敷衍，但总归是自己做过的爱好，再加上文章编号到了 233，那就放一个可能有点意思的文章吧 (老早就以为自己发过了，拖到了现在)\n红茶 名称 口味 妃子笑 初喝有种很闷腻的口感多次冲泡之后一股红薯的味道大概 12 泡 水蜜桃 初次冲泡比妃子笑略苦，不腻晚上呼吸难受，便出血，不知是否茶的原因 昔归红 初喝甜而不腻，苦而不涩，甚好 祁门红茶 初喝和 昔归红 差不多，不甜，但貌似更醇厚但茶叶较碎细 金骏眉 过于醇厚，甚至略有苦涩，但第三杯喝后口有留香与甜蜜茶叶较细碎，而且泡的次数不多 醉红 就是红茶那个味泡数还行，但不能闷，碎渣较多 烟熏小种 确实一股烟熏味\n入口苦，但余味回甜 老丛红茶 好喝 黑茶 名称 口味 金奖六类 好似八宝粥的味道 参香六堡 有种药的苦味 天尖 初尝震撼于好喝（可能由于喝了上述俩茶\n味苦涩，但有回甘\n喝多次过于苦涩 金花茯砖 淡的“金奖六类”+淡的“参香六堡” 老青砖 旧木头味，茶渣太多 老熟普 不是很好喝的亚子 老生普 很难泡开，苦 古树熟普 相对上面两个，可以 普洱生茶 初入口略苦涩，而后口有回甘\n放置两天后顶端有发霉，冲泡后苦涩味明显 普洱熟茶 八宝粥味 白茶 名称 口味 荒野贡眉 入口有鲜嫩农作物略苦涩感，甘甜绵软 昔归白 块状茶叶，散开后品尝，入口蜜甜，口有留香\n冲泡次数很多 \u0026gt;10 野小白 喝时苦涩，喝后口有余甘 白毫银针 茶色很淡，第一泡略茶草味，之后稍有蜜甜，口有余甘 冰糖甜 第一、二泡茶草味，之后正常白茶味 老白茶 经典白茶味，够甜 高寿 第一口茶草味，之后正常白茶味 乌龙茶 名称 口味 大红袍 量多，可以，微甜 铁观音 茶香但苦涩 兰底水仙 苦涩 鸭屎香单丛 前两泡淡淡乌龙茶香，后面淡味 蜜兰香单丛 入口无味，后有留香，后续很苦 梨山乌龙 淡淡木头味，泡开后正常乌龙味 流香肉桂 入口木头味，后有回甘 白牡丹 初闻油茶味，入口木头味 清香铁观音 感觉差不多味，淡香 漳平水仙 感觉差不多味，淡香 古法铁观音 味道相对于上方不错 岩茶 名称 口味 大红袍 苦 杏桃香 怪、苦 佛国岩肉桂 入口微苦，后口有留香 佛手雪梨 好像只有苦味，过后一段时间有留香 留香肉桂 同上，岩茶的感觉 籣底水仙 名字超好听，不过味道还是那种岩茶的感觉，甜度倒是高 奇丹 印刷的名字是上立下可，但不知道这个字是啥，手写也没\n味道相对较轻，保留了岩茶回甘，体验相当不错 不知 名称 口味 小青柑 黑茶，不好，略酸\n体验极差，第三天出现馊味 安吉白 好看，很香，板栗味，略腻 蒙顶黄芽 与上个类似，略好一些 茉莉雪芽 茶叶飘香，茶汤清香，喝后口有余香\n乌龙茶？ ","date":"2025-02-12T23:58:53+09:00","permalink":"https://blog.yexca.net/archives/233/","title":"个人品茶史"},{"content":" Elasticsearch 系列\n内容 链接 Elasticsearch 基础操作 https://blog.yexca.net/archives/226 Elasticsearch 查询操作 https://blog.yexca.net/archives/227 RestClient 基础操作 https://blog.yexca.net/archives/228 RestClient 查询操作 https://blog.yexca.net/archives/229 Elasticsearch 数据聚合 https://blog.yexca.net/archives/231 Elasticsearch 自动补全 本文 Elasticsearch 数据同步 https://blog.yexca.net/archives/234 Elasticsearch 集群 https://blog.yexca.net/archives/235 当用户在搜索框输入字符时，应提示与该字符有关的搜索项，根据输入的字母提供完整词条功能，就是自动补全\n拼音分词 要实现根据字母做补全，就必须对文档按照拼音分词\n项目地址： https://github.com/medcl/elasticsearch-analysis-pinyin 安装方式同 IK 分词器，以下为在线安装方式，首先进入容器\n1 docker exec -it es /bin/bash 执行命令\n1 ./bin/elasticsearch-plugin install https://github.com/infinilabs/analysis-pinyin/releases/download/v7.12.1/elasticsearch-analysis-pinyin-7.12.1.zip 然后退出重启\n1 2 3 4 # 退出 exit # 重启 docker restart es 测试\n1 2 3 4 5 6 # 测试拼音分词 POST /_analyze { \u0026#34;text\u0026#34;: \u0026#34;世界第一可爱\u0026#34;, \u0026#34;analyzer\u0026#34;: \u0026#34;pinyin\u0026#34; } 自定义分词器 默认的拼音分词器会将每个汉字单独分为拼音，而我们希望的是每个词条形成一组拼音，需要对拼音分词器做个性化定制，形成自定义分词器\nes 中分词器 (analyzer) 的组成分为三部分：\ncharacter filters：在 tokenizer 之前对文本进行处理。例如删除字符、替换字符 tokenizer：将文本按照一定的规则切割成词条 (term)。例如 keyword，就是不分词；还有 ik_smart tokenizer filter：将 tokenizer 输出的词条做进一步处理。例如大小写转换、同义词处理、拼音处理等 声明自定义分词器的语法如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 # 自定义分词器 PUT /test { \u0026#34;settings\u0026#34;: { \u0026#34;analysis\u0026#34;: { \u0026#34;analyzer\u0026#34;: { // 自定义分词器 \u0026#34;my_analyzer\u0026#34;: { // 分词器名称 \u0026#34;tokenizer\u0026#34;: \u0026#34;ik_max_word\u0026#34;, \u0026#34;filter\u0026#34;: \u0026#34;py\u0026#34; } }, \u0026#34;filter\u0026#34;: { // 自定义tokenizer filter \u0026#34;py\u0026#34;: { // 过滤器名称 \u0026#34;type\u0026#34;: \u0026#34;pinyin\u0026#34;, // 过滤器类型 // 配置项在Github有说明 \u0026#34;keep_full_piny\u0026#34;: false, \u0026#34;keep_joined_full_pinyin\u0026#34;: true, \u0026#34;keep_original\u0026#34;: true, \u0026#34;limit_first_letter_length\u0026#34;: 16, \u0026#34;remove_duplicated_term\u0026#34;: true, \u0026#34;none_chinese_pinyin_tokenize\u0026#34;: false } } } }, \u0026#34;mappings\u0026#34;: { \u0026#34;properties\u0026#34;: { \u0026#34;name\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;text\u0026#34;, \u0026#34;analyzer\u0026#34;: \u0026#34;my_analyzer\u0026#34;, \u0026#34;search_analyzer\u0026#34;: \u0026#34;ik_smart\u0026#34; } } } } 测试\n1 2 3 4 5 6 # 测试自定义分词器 POST /test/_analyze { \u0026#34;text\u0026#34;: \u0026#34;世界第一可爱\u0026#34;, \u0026#34;analyzer\u0026#34;: \u0026#34;my_analyzer\u0026#34; } 自动补全查询 es 提供了 Completion Suggester 查询来实现自动补全功能。这个查询会匹配以用户输入内容开头的词条并返回。为了提高补全查询的效率，对于文档中字段的类型有一些约束：\n参与补全查询的字段必须是 completion 类型 字段的内容一般是用来补全的多个词条形成的数组 创建测试索引库\n1 2 3 4 5 6 7 8 9 10 PUT /test { \u0026#34;mappings\u0026#34;: { \u0026#34;properties\u0026#34;: { \u0026#34;title\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;completion\u0026#34; } } } } 插入测试数据\n1 2 3 4 5 6 7 8 9 10 11 12 13 # 示例数据 POST /test/_doc { \u0026#34;title\u0026#34;: [\u0026#34;Sony\u0026#34;, \u0026#34;WH-1000XM3\u0026#34;] } POST /test/_doc { \u0026#34;title\u0026#34;: [\u0026#34;SK-II\u0026#34;, \u0026#34;PITERA\u0026#34;] } POST /test/_doc { \u0026#34;title\u0026#34;: [\u0026#34;Nintendo\u0026#34;, \u0026#34;switch\u0026#34;] } 查询\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 自动补全查询 GET /test/_search { \u0026#34;suggest\u0026#34;: { \u0026#34;title_suggest\u0026#34;: { \u0026#34;text\u0026#34;: \u0026#34;s\u0026#34;, // 关键字 \u0026#34;completion\u0026#34;: { \u0026#34;field\u0026#34;: \u0026#34;title\u0026#34;, // 自动补全查询的字段 \u0026#34;skip_duplicates\u0026#34;: true, // 跳过重复 \u0026#34;size\u0026#34;: 10 // 获取前10条数据 } } } } 自动补全 Java 上述 DSL 的 Java 请求\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @Test public void testAutoIn(){ SearchRequest request = new SearchRequest(\u0026#34;hotel\u0026#34;); // 请求参数 request.source() .suggest(new SuggestBuilder().addSuggestion( \u0026#34;title_suggest\u0026#34;, // 查询名称 SuggestBuilders .completionSuggestion(\u0026#34;title\u0026#34;) // 自动补全查询的字段 .prefix(\u0026#34;s\u0026#34;) // 关键字 .skipDuplicates(true) // 跳过重复 .size(10) // 获取前10条数据 )); // 发送请求 SearchResponse response = client.search(request, RequestOptions.DEFAULT); } 响应处理：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 @Test public void testAutoIn(){ SearchRequest request = new SearchRequest(\u0026#34;hotel\u0026#34;); // 请求参数 request.source() .suggest(new SuggestBuilder().addSuggestion( \u0026#34;mySuggestion\u0026#34;, SuggestBuilders .completionSuggestion(\u0026#34;suggestion\u0026#34;) .prefix(\u0026#34;h\u0026#34;) .skipDuplicates(true) .size(10) )); // 发送请求 try { SearchResponse response = client.search(request, RequestOptions.DEFAULT); // 处理响应 Suggest suggest = response.getSuggest(); // 根据名称获取补全结果 CompletionSuggestion mySuggestion = suggest.getSuggestion(\u0026#34;mySuggestion\u0026#34;); // 获取options并遍历 for (CompletionSuggestion.Entry.Option option : mySuggestion.getOptions()) { String text = option.getText().string(); System.out.println(text); } } catch (IOException e) { throw new RuntimeException(e); } } 酒店搜索自动补全 之前的 hotel 索引库没设置拼音分词器，但索引库无法修改，所以需要删除重建\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 # 删除重建 DELETE /hotel PUT /hotel { \u0026#34;settings\u0026#34;: { \u0026#34;analysis\u0026#34;: { \u0026#34;analyzer\u0026#34;: { \u0026#34;text_analyzer\u0026#34;: { \u0026#34;tokenizer\u0026#34;: \u0026#34;ik_max_word\u0026#34;, \u0026#34;filter\u0026#34;: \u0026#34;py\u0026#34; }, \u0026#34;completion_analyzer\u0026#34;: { \u0026#34;tokenizer\u0026#34;: \u0026#34;keyword\u0026#34;, \u0026#34;filter\u0026#34;: \u0026#34;py\u0026#34; } }, \u0026#34;filter\u0026#34;: { \u0026#34;py\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;pinyin\u0026#34;, \u0026#34;keep_full_pinyin\u0026#34;: false, \u0026#34;keep_joined_full_pinyin\u0026#34;: true, \u0026#34;keep_original\u0026#34;: true, \u0026#34;limit_first_letter_length\u0026#34;: 16, \u0026#34;remove_duplicated_term\u0026#34;: true, \u0026#34;none_chinese_pinyin_tokenize\u0026#34;: false } } } }, \u0026#34;mappings\u0026#34;: { \u0026#34;properties\u0026#34;: { \u0026#34;id\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;keyword\u0026#34; }, \u0026#34;name\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;text\u0026#34;, \u0026#34;analyzer\u0026#34;: \u0026#34;text_analyzer\u0026#34;, \u0026#34;search_analyzer\u0026#34;: \u0026#34;ik_smart\u0026#34;, \u0026#34;copy_to\u0026#34;: \u0026#34;all\u0026#34; }, \u0026#34;address\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;keyword\u0026#34;, \u0026#34;index\u0026#34;: false }, \u0026#34;price\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;integer\u0026#34; }, \u0026#34;score\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;integer\u0026#34; }, \u0026#34;brand\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;keyword\u0026#34;, \u0026#34;copy_to\u0026#34;: \u0026#34;all\u0026#34; }, \u0026#34;city\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;keyword\u0026#34; }, \u0026#34;starName\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;keyword\u0026#34; }, \u0026#34;business\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;keyword\u0026#34;, \u0026#34;copy_to\u0026#34;: \u0026#34;all\u0026#34; }, \u0026#34;location\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;geo_point\u0026#34; }, \u0026#34;pic\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;keyword\u0026#34;, \u0026#34;index\u0026#34;: false }, \u0026#34;all\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;text\u0026#34;, \u0026#34;analyzer\u0026#34;: \u0026#34;text_analyzer\u0026#34;, \u0026#34;search_analyzer\u0026#34;: \u0026#34;ik_smart\u0026#34; }, \u0026#34;suggestion\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;completion\u0026#34;, \u0026#34;analyzer\u0026#34;: \u0026#34;completion_analyzer\u0026#34; } } } } 修改 HotelDoc 实体类，添加 suggestion 字段\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 @Data @NoArgsConstructor public class HotelDoc { private Long id; private String name; private String address; private Integer price; private Integer score; private String brand; private String city; private String starName; private String business; private String location; private String pic; private Object distance; // 广告 private Boolean isAD; // 自动补全 private List\u0026lt;String\u0026gt; suggestion; public HotelDoc(Hotel hotel) { this.id = hotel.getId(); this.name = hotel.getName(); this.address = hotel.getAddress(); this.price = hotel.getPrice(); this.score = hotel.getScore(); this.brand = hotel.getBrand(); this.city = hotel.getCity(); this.starName = hotel.getStarName(); this.business = hotel.getBusiness(); this.location = hotel.getLatitude() + \u0026#34;, \u0026#34; + hotel.getLongitude(); this.pic = hotel.getPic(); // 组装suggestion if(this.business.contains(\u0026#34;/\u0026#34;)){ // bussiness有多个值，需要切割 String[] arr = this.business.split(\u0026#34;/\u0026#34;); // 添加元素 this.suggestion = new ArrayList\u0026lt;\u0026gt;(); this.suggestion.add(this.brand); Collections.addAll(this.suggestion, arr); }else { this.suggestion = Arrays.asList(this.brand, this.business); } } } 重新导入数据\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 @Test public void testBulk() throws IOException { // 批量查询数据 List\u0026lt;Hotel\u0026gt; hotelList = hotelService.list(); // 创建bulk请求 BulkRequest request = new BulkRequest(); // 添加批量请求 for (Hotel hotel : hotelList) { // 转换文档类型 HotelDoc hotelDoc = new HotelDoc(hotel); // 创建新增文档request对象 request.add(new IndexRequest(\u0026#34;hotel\u0026#34;) .id(hotelDoc.getId().toString()) .source(JSON.toJSONString(hotelDoc), XContentType.JSON) ); } // 发起bulk请求 client.bulk(request, RequestOptions.DEFAULT); } 查询测试\n1 2 3 4 5 6 GET /hotel/_search { \u0026#34;query\u0026#34;: { \u0026#34;match_all\u0026#34;: {} } } 可以看到查询结果 suggestion 字段，然后编写业务代码\nController\n1 2 3 4 @GetMapping(\u0026#34;/suggestion\u0026#34;) public List\u0026lt;String\u0026gt; getSuggestion(@RequestParam(\u0026#34;key\u0026#34;) String prefix){ return hotelService.getSuggestion(prefix); } Service\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 public List\u0026lt;String\u0026gt; getSuggestion(String prefix) { SearchRequest request = new SearchRequest(\u0026#34;hotel\u0026#34;); request.source().suggest( new SuggestBuilder().addSuggestion( \u0026#34;mySuggestion\u0026#34;, SuggestBuilders .completionSuggestion(\u0026#34;suggestion\u0026#34;) .prefix(prefix) .size(10) .skipDuplicates(true) ) ); try { SearchResponse response = client.search(request, RequestOptions.DEFAULT); Suggest suggestions = response.getSuggest(); CompletionSuggestion mySuggestion = suggestions.getSuggestion(\u0026#34;mySuggestion\u0026#34;); List\u0026lt;CompletionSuggestion.Entry.Option\u0026gt; options = mySuggestion.getOptions(); ArrayList\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(options.size()); for (CompletionSuggestion.Entry.Option option : options) { String text = option.getText().string(); list.add(text); } return list; } catch (IOException e) { throw new RuntimeException(e); } } ","date":"2025-02-09T17:29:28+09:00","permalink":"https://blog.yexca.net/archives/232/","title":"Elasticsearch 自动补全"},{"content":" Elasticsearch 系列\n内容 链接 Elasticsearch 基础操作 https://blog.yexca.net/archives/226 Elasticsearch 查询操作 https://blog.yexca.net/archives/227 RestClient 基础操作 https://blog.yexca.net/archives/228 RestClient 查询操作 https://blog.yexca.net/archives/229 Elasticsearch 数据聚合 本文 Elasticsearch 自动补全 https://blog.yexca.net/archives/232 Elasticsearch 数据同步 https://blog.yexca.net/archives/234 Elasticsearch 集群 https://blog.yexca.net/archives/235 聚合 (aggregations) 可以让我们极其方便地实现对数据的统计、分析、运算。例如：\n什么品牌的手机最受欢迎？ 这些手机的平均价格、最高价格、最低价格？ 这些手机每月的销售情况如何？ 聚合的种类 常见的有三类：\n桶 (bucket) 聚合：用来对文档做分组 TermAggregation：按照文档字段值分组，例如按照品牌、国家分组 Date Histogram：按照日期阶梯分组，例如一周或一月为一组 度量 (metric) 聚合：用以计算一些最大值、最小值、平均值等 Avg：平均值 Max：最大值 Min：最小值 Stats：同时求 max、min、avg、sum 等 管道 (pipeline) 聚合：其他聚合的结果为基础做聚合 参加聚合的字段必须是 keyword、日期、数值、布尔类型\nDSL 聚合语句 bucket 统计所有数据中酒店的品牌有几种，即按品牌对数据分组\n1 2 3 4 5 6 7 8 9 10 11 12 13 # bucket term GET /hotel/_search { \u0026#34;size\u0026#34;: 0, // 设置size为0，结果中不包含文档，只包含聚合结果 \u0026#34;aggs\u0026#34;: { \u0026#34;brandAgg\u0026#34;: { // 聚合名称 \u0026#34;terms\u0026#34;: { // 聚合类型 \u0026#34;field\u0026#34;: \u0026#34;brand\u0026#34;, // 参与聚合字段 \u0026#34;size\u0026#34;: 20 // 获取的聚合结果数量 } } } } 聚合结果排序 默认情况下，bucket 聚合会统计 bucket 内的文档数量，记为 count，并且按 count 降序排序。通过指定 order 属性，自定义聚合的排序方式\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 GET /hotel/_search { \u0026#34;size\u0026#34;: 0, \u0026#34;aggs\u0026#34;: { \u0026#34;brandAgg\u0026#34;: { \u0026#34;terms\u0026#34;: { \u0026#34;field\u0026#34;: \u0026#34;brand\u0026#34;, \u0026#34;size\u0026#34;: 20, \u0026#34;order\u0026#34;: { // 排序 \u0026#34;_count\u0026#34;: \u0026#34;asc\u0026#34; } } } } } 限定聚合范围 默认情况下会对索引库所有文档聚合，但实际使用时，用户会输入搜索条件，因此聚合必须是对搜索结果的聚合，聚合就必须要添加限定条件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # bucket query GET /hotel/_search { \u0026#34;query\u0026#34;: { \u0026#34;range\u0026#34;: { \u0026#34;price\u0026#34;: { \u0026#34;lte\u0026#34;: 200 // 只对价格小于200的文档聚合 } } }, \u0026#34;size\u0026#34;: 0, \u0026#34;aggs\u0026#34;: { \u0026#34;brandAggQuery\u0026#34;: { \u0026#34;terms\u0026#34;: { \u0026#34;field\u0026#34;: \u0026#34;brand\u0026#34;, \u0026#34;size\u0026#34;: 20 } } } } Metric 上述 bucket 聚合按品牌分组，现在要获取每个品牌用户评分的 min、max、avg\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # metric GET /hotel/_search { \u0026#34;size\u0026#34;: 0, \u0026#34;aggs\u0026#34;: { \u0026#34;brandAgg\u0026#34;: { \u0026#34;terms\u0026#34;: { \u0026#34;field\u0026#34;: \u0026#34;brand\u0026#34;, \u0026#34;size\u0026#34;: 20 }, \u0026#34;aggs\u0026#34;: { // bucket的子聚合，对分组后每个组运算 \u0026#34;scoreStats\u0026#34;: { // 聚合名称 \u0026#34;stats\u0026#34;: { // 聚合类型 \u0026#34;field\u0026#34;: \u0026#34;score\u0026#34; // 聚合字段 } } } } } } 根据平均值排序\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 GET /hotel/_search { \u0026#34;size\u0026#34;: 0, \u0026#34;aggs\u0026#34;: { \u0026#34;brandAgg\u0026#34;: { \u0026#34;terms\u0026#34;: { \u0026#34;field\u0026#34;: \u0026#34;brand\u0026#34;, \u0026#34;size\u0026#34;: 20, \u0026#34;order\u0026#34;: { \u0026#34;scoreStats.avg\u0026#34;: \u0026#34;desc\u0026#34; // 平均值降序 } }, \u0026#34;aggs\u0026#34;: { \u0026#34;scoreStats\u0026#34;: { \u0026#34;stats\u0026#34;: { \u0026#34;field\u0026#34;: \u0026#34;score\u0026#34; } } } } } } RestAPI 聚合 语法 聚合条件与 query 同级，因此使用 request.source() 指定聚合条件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 @Test public void testAggTerm() throws IOException { SearchRequest request = new SearchRequest(\u0026#34;hotel\u0026#34;); request.source().size(0); request.source().aggregation( AggregationBuilders .terms(\u0026#34;brandAgg\u0026#34;) .field(\u0026#34;brand\u0026#34;) .size(20) ); SearchResponse response = client.search(request, RequestOptions.DEFAULT); } 响应处理\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 @Test public void testAggTerm() throws IOException { SearchRequest request = new SearchRequest(\u0026#34;hotel\u0026#34;); request.source().size(0); request.source().aggregation( AggregationBuilders .terms(\u0026#34;brandAgg\u0026#34;) .field(\u0026#34;brand\u0026#34;) .size(20) ); SearchResponse response = client.search(request, RequestOptions.DEFAULT); // 解析聚合结果 Aggregations aggregations = response.getAggregations(); // 按名称获取聚合结果 Terms term = aggregations.get(\u0026#34;brandAgg\u0026#34;); // 获取bucket List\u0026lt;? extends Terms.Bucket\u0026gt; buckets = term.getBuckets(); // 遍历 for (Terms.Bucket bucket : buckets) { // 获取key String name = bucket.getKeyAsString(); System.out.println(name); } } 实例需求 前端页面的城市、星级、品牌都是固定供选择的，不会随着搜索输入而改变\n但是假如搜索 \u0026ldquo;东方明珠\u0026rdquo;，那城市只能是上海，不应该显示其他城市\n也就是可供选择的城市等应该随着搜索输入的内容改变，为此，前端需要根据内容请求可选城市，假设接口如下：\n请求方式：POST 请求路径：/hotel/filters 请求参数：RequestParams，与搜索文档的参数一致 返回值类型：Map\u0026lt;String, List\u0026lt;String\u0026gt;\u0026gt; Controller\n1 2 3 4 @PostMapping(\u0026#34;/filters\u0026#34;) public Map\u0026lt;String, List\u0026lt;String\u0026gt;\u0026gt; getFilters(@RequestBody RequestParams params){ return hotelService.getFilters(params); } Service\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 public Map\u0026lt;String, List\u0026lt;String\u0026gt;\u0026gt; getFilters(RequestParams params) { // request SearchRequest request = new SearchRequest(\u0026#34;hotel\u0026#34;); // DSL basicQuery(params, request); // 设置size request.source().size(0); // 聚合 request.source().aggregation( AggregationBuilders .terms(\u0026#34;brandAgg\u0026#34;) .field(\u0026#34;brand\u0026#34;) .size(100) ); request.source().aggregation( AggregationBuilders .terms(\u0026#34;cityAgg\u0026#34;) .field(\u0026#34;city\u0026#34;) .size(100) ); request.source().aggregation( AggregationBuilders .terms(\u0026#34;starAgg\u0026#34;) .field(\u0026#34;starName\u0026#34;) .size(100) ); // 请求 try { SearchResponse response = client.search(request, RequestOptions.DEFAULT); // 解析响应 Map\u0026lt;String, List\u0026lt;String\u0026gt;\u0026gt; result = new HashMap\u0026lt;\u0026gt;(); Aggregations aggregations = response.getAggregations(); // 品牌 List\u0026lt;String\u0026gt; brandList = getAggName(aggregations, \u0026#34;brandAgg\u0026#34;); result.put(\u0026#34;品牌\u0026#34;, brandList); // 城市 List\u0026lt;String\u0026gt; cityList = getAggName(aggregations, \u0026#34;cityAgg\u0026#34;); result.put(\u0026#34;城市\u0026#34;, cityList); // 星级 List\u0026lt;String\u0026gt; starList = getAggName(aggregations, \u0026#34;starAgg\u0026#34;); result.put(\u0026#34;星级\u0026#34;, starList); return result; } catch (IOException e) { throw new RuntimeException(e); } } private static List\u0026lt;String\u0026gt; getAggName(Aggregations aggregations, String name) { // 获取品牌 Terms brand = aggregations.get(name); // 获取bucket List\u0026lt;? extends Terms.Bucket\u0026gt; buckets = brand.getBuckets(); // 遍历 List\u0026lt;String\u0026gt; brandList = new ArrayList\u0026lt;\u0026gt;(); for (Terms.Bucket bucket : buckets) { // 获取key String key = bucket.getKeyAsString(); brandList.add(key); } return brandList; } ","date":"2025-02-08T14:56:36+09:00","permalink":"https://blog.yexca.net/archives/231/","title":"Elasticsearch 数据聚合"},{"content":" 音有所感系列 歌曲名 翻译 链接 僕が死のうと思ったのは 曾经我也想过一了百了 https://blog.yexca.net/archives/214 あくあ色ぱれっと aqua 的调色盘 https://blog.yexca.net/archives/219 恋の押し売り 恋爱推销 https://blog.yexca.net/archives/220 17さいのうた 17 岁的歌 https://blog.yexca.net/archives/224 drop 坠入爱河 本文 生きるを選んだ私へ 致选择活下去的自己 https://blog.yexca.net/archives/239 rainy lady 雨意未晴 https://blog.yexca.net/archives/249 恋しくなったら手を叩こう 想谈恋爱的话就拍拍手吧 https://blog.yexca.net/archives/250 引言 今天尝试做了 2019 年 12 月的 N1 试卷，居然一不小心合格了，突然就激发了我想写一个学日语的文章，就是这个系列啦\n选歌的时候有点烦，因为最近我都在听音乐 (我一般把有人声的叫歌曲，无人声的叫音乐)，这玩意也写不了啊\n试着找了 YouTube Music 的每个季节最常听的歌曲，但都不怎么适合单曲循环 (单听可以，没有喜欢到循环的地步)，翻看记录发现了这首歌\n说到这歌，可能是我第一首没看歌词听懂的最多的歌了 (有点矛盾，但这不重要)，曾经也多次循环过，可以说是直接让我以此为契机去了解 潤羽るしあ 了 (虽然已经终止活动了)，怎么会有这么甜的歌呢，太爱啦！\n歌曲视频 歌词 夢の中で君と過ごしても\n即使在梦中和你共度时光\nまた覚めるたび君が離れないの\n每次醒来你还是在我心里\n退屈なベッドで1人きり\n孤身一人躺在无聊的床上\nあぁ 迎えに来てよ王子様\n啊~，快来接我吧，王子大人\n君を知りたい 気持ちもどかしい\n想要了解你，心情也焦急不安\nいっそシャボン玉になって弾けたい\n想化作泡沫，在一瞬间绽放\nあぁ 君が好き なんて言えない\n啊~，好喜欢你，但说不出口\nたまに冷たい 君がわかんない\n偶尔冷漠的你真的不了解\n君の場所びゅーんと飛んでって\n一下子飞到你的地理位置\nアニメみたいに2人恋に落ちて\n像动画那样两个人坠入爱河\nくすぐったいくらいに君のこと\n想到你时，连心都痒痒的\n考える1人の夜がいいの\n独自一人想你的夜晚也不错\nふわふわと浮かぶ甘い心\n软软地轻飘飘的甜甜的心\n頭離れない君は悪い男？\n无法移开视线的你其实是坏男人？\nわからないことにもやもやして\n不知道的事情也不用管啦\n夢でも君のことを考えて\n梦中也要和你一起度过\nあぁ いじけちゃって嫌になっても 考えちゃう\n啊~，即使闷闷不乐，烦的不行，还是忍不住去想你\nねぇ 優しかったり冷たくなったり 迷路みたい\n呐，你时而温柔时而冷漠，真是搞不懂\nあぁ 攻略サイトも見当たらないから やり直しばかり\n啊~，就连攻略网站也找不到方法，只能一遍遍尝试了\nもー知らないもんって強がり\n只好逞强地说“才不想理你”\nでも嫌いになんてなれるわけもない\n但是也不是讨厌你的意思啦\nそう思うほど胸も痛くなる愛\n越想越觉得心疼\n私の恋のキュービットは\n我的恋爱丘比特\nいつになったら現れるの\n到底什么时候来啊\n夢の中で君と過ごしても\n即使在梦中和你共度时光\nまた覚めるたび君が離れないの\n每次醒来你还是在我心里\n退屈なベッドで1人きり\n孤身一人躺在无聊的床上\nあぁ 迎えに来てよ王子様\n啊~，快来接我吧，王子大人\n君を知りたい 気持ちもどかしい\n想要了解你，心情也焦急不安\nいっそシャボン玉になって弾けたい\n想化作泡沫，在一瞬间绽放\nあぁ 君が好き なんて言えない\n啊~，好喜欢你，但说不出口\nたまに冷たい 君がわかんない\n偶尔冷漠的你真的不了解\nひいふうみいよ 数えて\n一、二、三、四，数着\n君につぎ 会える日を楽しみに眠るの\n期待着和你再相见而入睡\nいつでも会えるよう\n为了每次见面都让你心动\n昨日よりもかわいくなるために生きるよ\n我要变得比昨天更可爱而努力生活\n気付いてくれるかな\n有没有注意到我啊\n君の好きなメイクにしてみたとか (どうかな？)\n试试你喜欢的装扮怎么样 (怎么样呐)\n少し重すぎかな\n稍微有点重了吗\n優柔不断で何も決まんないや (もう)\n犹豫不决得什么都没决定\n可愛くなれるかな\n可以变得更可爱吗\n君の前だとチークはいらないか (ねえ ねえ)\n和你在一起就不用画腮红了 (呐，呐)\n私と同じかな\n和我一样吗\nこの気持ち君も同じだといいな\n和我一样互相喜欢得话多好啊\n夢の中で君と過ごしても\n即使在梦中和你共度时光\nまた覚めるたび君が離れないの\n每次醒来你还是在我心里\n退屈なベッドで1人きり\n孤身一人躺在无聊的床上\nあぁ 迎えに来てよ王子様\n啊~，快来接我吧，王子大人\n君を知りたい 気持ちもどかしい\n想要了解你，心情也焦急不安\nいっそシャボン玉になって弾けたい\n想化作泡沫，在一瞬间绽放\nあぁ 君が好き なんて言えない\n啊~，好喜欢你，但说不出口\nたまに冷たい 君がわかんない\n偶尔冷漠的你真的不了解\nふわふわな気持ちを隠しても\n就算想遮掩自己轻飘飘的心情\n君の眼を見るとまた零こぼれるちゃうよ\n看向你的眼睛的时候也会被忍不住\n味のないケーキも君となら\n就算是没有味道的蛋糕，只要是和你在一起\n大好きな時間に変わってく\n也会变成我最喜欢的时间\n君を知りたい もっと知りたい\n想要了解你，更多地了解你\n好きの2文字が口から出せない\n喜欢这两个字却说不出来\nあぁ 君が好き を隠した日々\n啊~，好喜欢你，每天藏着这份心情\nたまに冷たい 君も愛いとおしい\n偶尔冷漠的你也很迷人\n","date":"2025-02-06T22:06:10+09:00","permalink":"https://blog.yexca.net/archives/230/","title":"音有所感 - 《drop》"},{"content":" Elasticsearch 系列\n内容 链接 Elasticsearch 基础操作 https://blog.yexca.net/archives/226 Elasticsearch 查询操作 https://blog.yexca.net/archives/227 RestClient 基础操作 https://blog.yexca.net/archives/228 RestClient 查询操作 本文 Elasticsearch 数据聚合 https://blog.yexca.net/archives/231 Elasticsearch 自动补全 https://blog.yexca.net/archives/232 Elasticsearch 数据同步 https://blog.yexca.net/archives/234 Elasticsearch 集群 https://blog.yexca.net/archives/235 文档的查询同样使用 RestHighLevelClient 对象\nmatch_all 发起请求如下\n1 2 3 4 5 6 7 8 9 10 11 @Test public void testMatchAll() throws IOException { // 准备request SearchRequest request = new SearchRequest(\u0026#34;hotel\u0026#34;); // 组织DSL参数 request.source().query(QueryBuilders.matchAllQuery()); // 发送请求 SearchResponse response = client.search(request, RequestOptions.DEFAULT); System.out.println(response); } 解析响应\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 @Test public void testMatchAll() throws IOException { // 准备request SearchRequest request = new SearchRequest(\u0026#34;hotel\u0026#34;); // 组织DSL参数 request.source().query(QueryBuilders.matchAllQuery()); // 发送请求 SearchResponse response = client.search(request, RequestOptions.DEFAULT); // 解析结果 SearchHits searchHits = response.getHits(); // 查询的总条数 long total = searchHits.getTotalHits().value; // 查询的结果数组 SearchHit[] hits = searchHits.getHits(); for (SearchHit hit : hits) { String json = hit.getSourceAsString(); System.out.println(json); } } es 返回的结果是一个 JSON 字符串，包含：\nhits：命中结果 total：总条数，其中 value 是具体的总条数值 max_score：所有结果中得分最高的文档相关性算分 hits：搜索结果的文档数组，其中的每个文档都是一个 JSON 对象 source：文档中的原始数据，也是 JSON 对象 因此，解析响应结果，就是逐层解析JSON字符串，流程如下：\nSearchHits：通过 response.getHits() 获取，就是 JSON 中的最外层的 hits，代表命中的结果 SearchHits.getTotalHits().value：获取总条数信息 SearchHits.getHits()：获取 SearchHit 数组，也就是文档数组 SearchHit.getSourceAsString()：获取文档结果中的 _source，也就是原始的 json 文档数据 match 与 multi_match 与 match_all 类似，差别是查询条件\nmatch 代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Test public void testMatch() throws IOException { SearchRequest request = new SearchRequest(\u0026#34;hotel\u0026#34;); request.source().query(QueryBuilders.matchQuery(\u0026#34;all\u0026#34;, \u0026#34;如家\u0026#34;)); SearchResponse response = client.search(request, RequestOptions.DEFAULT); SearchHits searchHits = response.getHits(); long total = searchHits.getTotalHits().value; System.out.println(total); SearchHit[] hits = searchHits.getHits(); for (SearchHit hit : hits) { String json = hit.getSourceAsString(); System.out.println(json); } } multi_match 代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Test public void testMultiMatch() throws IOException { SearchRequest request = new SearchRequest(\u0026#34;hotel\u0026#34;); request.source().query(QueryBuilders.multiMatchQuery(\u0026#34;如家\u0026#34;, \u0026#34;brand\u0026#34;, \u0026#34;name\u0026#34;)); SearchResponse response = client.search(request, RequestOptions.DEFAULT); SearchHits searchHits = response.getHits(); long total = searchHits.getTotalHits().value; System.out.println(total); SearchHit[] hits = searchHits.getHits(); for (SearchHit hit : hits) { String json = hit.getSourceAsString(); System.out.println(json); } } 可以看到代码重复部分较多，使用 Ctrl+Alt+M 进行代码抽取，term 代码展示了抽取\n精准查询 term 词条精确匹配查询\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 @Test public void testTerm() throws IOException { SearchRequest request = new SearchRequest(\u0026#34;hotel\u0026#34;); request.source().query(QueryBuilders.termQuery(\u0026#34;city\u0026#34;, \u0026#34;上海\u0026#34;)); SearchResponse response = client.search(request, RequestOptions.DEFAULT); responseHandle(response); } // 响应处理代码抽取 private static void responseHandle(SearchResponse response) { SearchHits searchHits = response.getHits(); long total = searchHits.getTotalHits().value; System.out.println(total); SearchHit[] hits = searchHits.getHits(); for (SearchHit hit : hits) { String json = hit.getSourceAsString(); System.out.println(json); } } range 范围查询\n1 2 3 4 5 6 7 8 9 10 11 @Test public void testRange() throws IOException { SearchRequest request = new SearchRequest(\u0026#34;hotel\u0026#34;); request.source().query(QueryBuilders .rangeQuery(\u0026#34;price\u0026#34;) .gte(100) .lte(400)); SearchResponse response = client.search(request, RequestOptions.DEFAULT); responseHandle(response); } 布尔查询 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @Test public void testBool() throws IOException { SearchRequest request = new SearchRequest(\u0026#34;hotel\u0026#34;); // 构建bool查询 BoolQueryBuilder booledQuery = QueryBuilders.boolQuery(); // 添加must条件 booledQuery.must(QueryBuilders.termQuery(\u0026#34;city\u0026#34;, \u0026#34;上海\u0026#34;)); // 添加filter组件 booledQuery.filter(QueryBuilders.rangeQuery(\u0026#34;price\u0026#34;).lte(300)); request.source().query(booledQuery); SearchResponse response = client.search(request, RequestOptions.DEFAULT); responseHandle(response); } 排序与分页 1 2 3 4 5 6 7 8 9 10 @Test public void testSort() throws IOException { SearchRequest request = new SearchRequest(\u0026#34;hotel\u0026#34;); request.source().query(QueryBuilders.matchAllQuery()); request.source().from(10).size(10); request.source().sort(\u0026#34;price\u0026#34;, SortOrder.ASC); SearchResponse response = client.search(request, RequestOptions.DEFAULT); responseHandle(response); } 高亮 高亮与上述代码差异较大，请求构建\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @Test public void testHigh() throws IOException { SearchRequest request = new SearchRequest(\u0026#34;hotel\u0026#34;); // DSL request.source().query(QueryBuilders.matchQuery(\u0026#34;all\u0026#34;, \u0026#34;汉庭\u0026#34;)); // 高亮 request.source().highlighter( new HighlightBuilder() .field(\u0026#34;name\u0026#34;) .requireFieldMatch(false) ); // 发送请求 SearchResponse response = client.search(request, RequestOptions.DEFAULT); // 解析 responseHandle(response); } 因为查询文档结果与高亮分离，结果解析要额外处理\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 @Test public void testHigh() throws IOException { SearchRequest request = new SearchRequest(\u0026#34;hotel\u0026#34;); // DSL request.source().query(QueryBuilders.matchQuery(\u0026#34;all\u0026#34;, \u0026#34;汉庭\u0026#34;)); // 高亮 request.source().highlighter( new HighlightBuilder() .field(\u0026#34;name\u0026#34;) .requireFieldMatch(false) ); // 发送请求 SearchResponse response = client.search(request, RequestOptions.DEFAULT); // 解析 SearchHits searchHits = response.getHits(); // 总条数 long total = searchHits.getTotalHits().value; System.out.println(total); // 文档数组 SearchHit[] hits = searchHits.getHits(); for (SearchHit hit : hits) { String json = hit.getSourceAsString(); // 反序列化 HotelDoc hotelDoc = JSON.parseObject(json, HotelDoc.class); // 获取高亮结果 Map\u0026lt;String, HighlightField\u0026gt; highlightFields = hit.getHighlightFields(); if(!CollectionUtils.isEmpty(highlightFields)){ // 获取高亮结果 HighlightField highlightField = highlightFields.get(\u0026#34;name\u0026#34;); if (highlightField != null){ String name = highlightField.getFragments()[0].toString(); // 覆盖非高亮 hotelDoc.setName(name); } } System.out.println(hotelDoc); } } 酒店查询案例 实现四部分功能：\n酒店搜索和分页 酒店结果过滤 我周边的酒店 酒店竞价排名 搜索和分页 搜索请求：\n请求方式：POST 请求路径：/hotel/list 请求参数：JSON对象，包含4个字段： key：搜索关键字 page：页码 size：每页大小 sortBy：排序，目前暂不实现 返回值：分页查询，需要返回分页结果PageResult，包含两个属性： total：总条数 List\u0026lt;HotelDoc\u0026gt;：当前页的数据 首先定义实体类，接收参数\n1 2 3 4 5 6 7 @Data public class RequestParams { private String key; private Integer page; private Integer size; private String sortBy; } 定义返回类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 @Data public class PageResult { private Long total; private List\u0026lt;HotelDoc\u0026gt; hotels; public PageResult(){ } public PageResult(Long total, List\u0026lt;HotelDoc\u0026gt; hotels) { this.total = total; this.hotels = hotels; } } 定义 Controller\n1 2 3 4 5 6 7 8 9 10 11 @RestController @RequestMapping(\u0026#34;/hotel\u0026#34;) public class HotelController { @Autowired private IHotelService hotelService; @PostMapping(\u0026#34;/list\u0026#34;) public PageResult search(@RequestBody RequestParams params){ return hotelService.search(params); } } 实现搜索业务，首先注册一个 Bean 对象\n1 2 3 4 5 6 @Bean public RestHighLevelClient client(){ return new RestHighLevelClient(RestClient .builder(HttpHost.create(\u0026#34;http://ip:9200\u0026#34;) )); } 编写逻辑\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 public PageResult search(RequestParams params) { // request SearchRequest request = new SearchRequest(\u0026#34;hotel\u0026#34;); BoolQueryBuilder boolQuery = QueryBuilders.boolQuery(); // DSL String key = params.getKey(); if (key == null || \u0026#34;\u0026#34;.equals(key)){ boolQuery.must(QueryBuilders.matchAllQuery()); }else { boolQuery.must(QueryBuilders.matchQuery(\u0026#34;all\u0026#34;, key)); } // 分页 int page = params.getPage(); int size = params.getSize(); request.source().from((page - 1) * size).size(size); // 查询 request.source().query(boolQuery); // 发送请求 try { SearchResponse response = client.search(request, RequestOptions.DEFAULT); // 响应解析 SearchHits searchHits = response.getHits(); // 总数 long total = searchHits.getTotalHits().value; // 文档 SearchHit[] hits = searchHits.getHits(); // 遍历 List\u0026lt;HotelDoc\u0026gt; hotels = new ArrayList\u0026lt;\u0026gt;(); for (SearchHit hit : hits) { String json = hit.getSourceAsString(); HotelDoc hotelDoc = JSON.parseObject(json, HotelDoc.class); hotels.add(hotelDoc); } return new PageResult(total, hotels); } catch (IOException e) { throw new RuntimeException(e); } } 结果过滤 包含的过滤条件：\nbrand：品牌值 city：城市 minPrice~maxPrice：价格范围 starName：星级 修改实体类\n1 2 3 4 5 6 7 8 9 10 11 12 13 @Data public class RequestParams { private String key; private Integer page; private Integer size; private String sortBy; // 下面是新增的过滤条件参数 private String city; private String brand; private String starName; private Integer minPrice; private Integer maxPrice; } 修改查询条件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 @Override public PageResult search(RequestParams params) { // request SearchRequest request = new SearchRequest(\u0026#34;hotel\u0026#34;); basicQuery(params, request); // 分页 int page = params.getPage(); int size = params.getSize(); request.source().from((page - 1) * size).size(size); // 发送请求 try { SearchResponse response = client.search(request, RequestOptions.DEFAULT); // 响应解析 SearchHits searchHits = response.getHits(); // 总数 long total = searchHits.getTotalHits().value; // 文档 SearchHit[] hits = searchHits.getHits(); // 遍历 List\u0026lt;HotelDoc\u0026gt; hotels = new ArrayList\u0026lt;\u0026gt;(); for (SearchHit hit : hits) { String json = hit.getSourceAsString(); HotelDoc hotelDoc = JSON.parseObject(json, HotelDoc.class); hotels.add(hotelDoc); } return new PageResult(total, hotels); } catch (IOException e) { throw new RuntimeException(e); } } private static void basicQuery(RequestParams params, SearchRequest request) { BoolQueryBuilder boolQuery = QueryBuilders.boolQuery(); // 输入内容 String key = params.getKey(); if (key == null || \u0026#34;\u0026#34;.equals(key)){ boolQuery.must(QueryBuilders.matchAllQuery()); }else { boolQuery.must(QueryBuilders.matchQuery(\u0026#34;all\u0026#34;, key)); } // brand if (params.getBrand() != null \u0026amp;\u0026amp; !params.getBrand().equals(\u0026#34;\u0026#34;)){ boolQuery.filter(QueryBuilders.termQuery(\u0026#34;brand\u0026#34;, params.getBrand())); } // starName if (params.getStarName() != null \u0026amp;\u0026amp; !params.getStarName().equals(\u0026#34;\u0026#34;)){ boolQuery.filter(QueryBuilders.termQuery(\u0026#34;starName\u0026#34;, params.getStarName())); } // city if (params.getCity() != null \u0026amp;\u0026amp; !params.getStarName().equals(\u0026#34;\u0026#34;)){ boolQuery.filter(QueryBuilders.termQuery(\u0026#34;city\u0026#34;, params.getCity())); } // price if (params.getMinPrice() != null \u0026amp;\u0026amp; params.getMaxPrice() != null){ boolQuery.filter(QueryBuilders.rangeQuery(\u0026#34;price\u0026#34;).gte(params.getMinPrice()).lte(params.getMaxPrice())); } // 查询 request.source().query(boolQuery); } 附近的酒店 基于 location 坐标，按距离对周围的酒店排序\n修改实体类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 @Data public class RequestParams { private String key; private Integer page; private Integer size; private String sortBy; private String city; private String brand; private String starName; private Integer minPrice; private Integer maxPrice; // 我当前的地理坐标 private String location; } 添加距离排序\n1 2 3 4 5 6 7 8 if (params.getLocation() != null) { // 距离排序 request.source().sort(SortBuilders .geoDistanceSort(\u0026#34;location\u0026#34;, new GeoPoint(params.getLocation())) .order(SortOrder.ASC) .unit(DistanceUnit.KILOMETERS) ); } 距离显示 修改 HotelDoc，添加距离\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 @Data @NoArgsConstructor public class HotelDoc { private Long id; private String name; private String address; private Integer price; private Integer score; private String brand; private String city; private String starName; private String business; private String location; private String pic; // 距离 private Object distance; public HotelDoc(Hotel hotel) { this.id = hotel.getId(); this.name = hotel.getName(); this.address = hotel.getAddress(); this.price = hotel.getPrice(); this.score = hotel.getScore(); this.brand = hotel.getBrand(); this.city = hotel.getCity(); this.starName = hotel.getStarName(); this.business = hotel.getBusiness(); this.location = hotel.getLatitude() + \u0026#34;, \u0026#34; + hotel.getLongitude(); this.pic = hotel.getPic(); } } 修改响应处理\n1 2 3 4 5 6 7 8 9 10 for (SearchHit hit : hits) { String json = hit.getSourceAsString(); HotelDoc hotelDoc = JSON.parseObject(json, HotelDoc.class); Object[] sortValues = hit.getSortValues(); if (sortValues.length \u0026gt; 0){ Object sortValue = sortValues[0]; hotelDoc.setDistance(sortValue); } hotels.add(hotelDoc); } 添加广告酒店 需求：让指定的酒店在搜索结果中排名置顶\n给指定酒店添加标记，在过滤条件中根据此标记判断是否提高 function_score\n在 HotelDoc 添加广告标记字段\n1 private Boolean isAD; 用 DSL 给一些酒店添加标记\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 # 添加广告 POST /hotel/_update/607915 { \u0026#34;doc\u0026#34;: { \u0026#34;isAD\u0026#34;: true } } POST /hotel/_update/728461 { \u0026#34;doc\u0026#34;: { \u0026#34;isAD\u0026#34;: true } } POST /hotel/_update/7094829 { \u0026#34;doc\u0026#34;: { \u0026#34;isAD\u0026#34;: true } } POST /hotel/_update/198323591 { \u0026#34;doc\u0026#34;: { \u0026#34;isAD\u0026#34;: true } } 添加算分函数查询，修改 basicQuery() 方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 private static void basicQuery(RequestParams params, SearchRequest request) { BoolQueryBuilder boolQuery = QueryBuilders.boolQuery(); // 输入内容 String key = params.getKey(); if (key == null || \u0026#34;\u0026#34;.equals(key)){ boolQuery.must(QueryBuilders.matchAllQuery()); }else { boolQuery.must(QueryBuilders.matchQuery(\u0026#34;all\u0026#34;, key)); } // brand if (params.getBrand() != null \u0026amp;\u0026amp; !params.getBrand().equals(\u0026#34;\u0026#34;)){ boolQuery.filter(QueryBuilders.termQuery(\u0026#34;brand\u0026#34;, params.getBrand())); } // starName if (params.getStarName() != null \u0026amp;\u0026amp; !params.getStarName().equals(\u0026#34;\u0026#34;)){ boolQuery.filter(QueryBuilders.termQuery(\u0026#34;starName\u0026#34;, params.getStarName())); } // city if (params.getCity() != null \u0026amp;\u0026amp; !params.getStarName().equals(\u0026#34;\u0026#34;)){ boolQuery.filter(QueryBuilders.termQuery(\u0026#34;city\u0026#34;, params.getCity())); } // price if (params.getMinPrice() != null \u0026amp;\u0026amp; params.getMaxPrice() != null){ boolQuery.filter(QueryBuilders .rangeQuery(\u0026#34;price\u0026#34;) .gte(params.getMinPrice()) .lte(params.getMaxPrice()) ); } // 算分 function_score FunctionScoreQueryBuilder functionScoreQuery = QueryBuilders.functionScoreQuery( // 原始查询 boolQuery, // 数组 new FunctionScoreQueryBuilder.FilterFunctionBuilder[]{ // 其中一个 function score 元素 new FunctionScoreQueryBuilder.FilterFunctionBuilder( // 过滤条件 QueryBuilders.termQuery(\u0026#34;isAD\u0026#34;, true), // 算分函数 ScoreFunctionBuilders.weightFactorFunction(10) ) } ); // 查询 request.source().query(functionScoreQuery); } ","date":"2025-02-05T15:50:26+09:00","permalink":"https://blog.yexca.net/archives/229/","title":"Elasticsearch RestClient 查询"},{"content":" Elasticsearch 系列\n内容 链接 Elasticsearch 基础操作 https://blog.yexca.net/archives/226 Elasticsearch 查询操作 https://blog.yexca.net/archives/227 RestClient 基础操作 本文 RestClient 查询操作 https://blog.yexca.net/archives/229 Elasticsearch 数据聚合 https://blog.yexca.net/archives/231 Elasticsearch 自动补全 https://blog.yexca.net/archives/232 Elasticsearch 数据同步 https://blog.yexca.net/archives/234 Elasticsearch 集群 https://blog.yexca.net/archives/235 ES 官方提供了各种不同语言的客户端，用来操作 ES，这些客户端的本质就是组装 DSL 语句，通过 HTTP 请求发送给 ES\n官方文档： https://www.elastic.co/guide/en/elasticsearch/client/index.html 以下使用 Java HighLevel Rest Client 客户端 API\n创建索引库 数据库表结构如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 `id` bigint(20) NOT NULL COMMENT \u0026#39;酒店id\u0026#39;, `name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT \u0026#39;酒店名称\u0026#39;, `address` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT \u0026#39;酒店地址\u0026#39;, `price` int(10) NOT NULL COMMENT \u0026#39;酒店价格\u0026#39;, `score` int(2) NOT NULL COMMENT \u0026#39;酒店评分\u0026#39;, `brand` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT \u0026#39;酒店品牌\u0026#39;, `city` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT \u0026#39;所在城市\u0026#39;, `star_name` varchar(16) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT \u0026#39;酒店星级，1星到5星，1钻到5钻\u0026#39;, `business` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT \u0026#39;商圈\u0026#39;, `latitude` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT \u0026#39;纬度\u0026#39;, `longitude` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT \u0026#39;经度\u0026#39;, `pic` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT \u0026#39;酒店图片\u0026#39;, PRIMARY KEY (`id`) USING BTREE 创建索引库最关键的是 mapping 映射，需要考虑\n字段名、字段数据类型 (参考数据库表结构的名称与类型) 是否参与搜索 (根据业务判断，例如图片地址不需要参与搜索) 是否需要分词 (看内容，例如城市无需分词) 分词器是什么 (可以统一 ik_max_word) 上表示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 # 创建索引库 PUT /hotel { \u0026#34;mappings\u0026#34;: { \u0026#34;properties\u0026#34;: { \u0026#34;id\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;keyword\u0026#34; }, \u0026#34;name\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;text\u0026#34;, \u0026#34;analyzer\u0026#34;: \u0026#34;ik_max_word\u0026#34;, \u0026#34;copy_to\u0026#34;: \u0026#34;all\u0026#34; /* 将当前字段拷贝到指定字段 all */ }, \u0026#34;address\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;keyword\u0026#34;, \u0026#34;index\u0026#34;: false }, \u0026#34;price\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;integer\u0026#34; }, \u0026#34;score\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;integer\u0026#34; }, \u0026#34;brand\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;keyword\u0026#34;, \u0026#34;copy_to\u0026#34;: \u0026#34;all\u0026#34; }, \u0026#34;city\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;keyword\u0026#34;, \u0026#34;copy_to\u0026#34;: \u0026#34;all\u0026#34; }, \u0026#34;starName\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;keyword\u0026#34; }, \u0026#34;business\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;keyword\u0026#34; }, \u0026#34;location\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;geo_point\u0026#34; /* ES 支持两种地理坐标数据类型 */ }, \u0026#34;pic\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;keyword\u0026#34;, \u0026#34;index\u0026#34;: false }, \u0026#34;all\u0026#34;: { /* 组合字段，不会在查询结果显示，但可用于查询 */ \u0026#34;type\u0026#34;: \u0026#34;text\u0026#34;, \u0026#34;analyzer\u0026#34;: \u0026#34;ik_max_word\u0026#34; } } } } 地理坐标数据类型：\ngeo_point：由纬度 (latitude) 和经度 (longitude) 确定的一个点。例如 \u0026quot;32.84 120.25\u0026quot; geo_shape：由多个 geo_point 组成的复杂几何图形。例如一条直线 \u0026quot;LINESTRING(-77.03 38.29, +77.00 38.88)\u0026quot; 初始化 RestClient 与 elasticsearch 一切交互都封装在一个名为 RestHighLevelClient 的类中\n首先引入 es 的 RestHighLevelClient 依赖\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.elasticsearch.client\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;elasticsearch-rest-high-level-client\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 因为 SpringBoot 默认的 ES 版本为 7.6.2，需要覆盖默认 ES 版本\n1 2 3 4 \u0026lt;properties\u0026gt; \u0026lt;java.version\u0026gt;1.8\u0026lt;/java.version\u0026gt; \u0026lt;elasticsearch.version\u0026gt;7.12.1\u0026lt;/elasticsearch.version\u0026gt; \u0026lt;/properties\u0026gt; 初始化 RestHighLevelClient 代码如下\n1 2 3 RestHighLevelClient client = new RestHighLevelClient(RestClient.builder( HttpHost.create(\u0026#34;http://IP:9200\u0026#34;) )); 不过为了测试方便，初始化代码放在 @BeforeEach\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class HotelIndexTest { private RestHighLevelClient client; @BeforeEach void setUp() { client = new RestHighLevelClient(RestClient.builder( HttpHost.create(\u0026#34;http://127.0.0.1:9200\u0026#34;))); } @AfterEach void tearDown() throws IOException { this.client.close(); } } 定义索引库需要 DSL 语句的 JSON 部分，可以单独抽出\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 public class HotelContants { public static final String MAPPING_TEMPLATE = \u0026#34;{\\n\u0026#34; + \u0026#34; \\\u0026#34;mappings\\\u0026#34;: {\\n\u0026#34; + \u0026#34; \\\u0026#34;properties\\\u0026#34;: {\\n\u0026#34; + \u0026#34; \\\u0026#34;id\\\u0026#34;: {\\n\u0026#34; + \u0026#34; \\\u0026#34;type\\\u0026#34;: \\\u0026#34;keyword\\\u0026#34;\\n\u0026#34; + \u0026#34; },\\n\u0026#34; + \u0026#34; \\\u0026#34;name\\\u0026#34;: {\\n\u0026#34; + \u0026#34; \\\u0026#34;type\\\u0026#34;: \\\u0026#34;text\\\u0026#34;,\\n\u0026#34; + \u0026#34; \\\u0026#34;analyzer\\\u0026#34;: \\\u0026#34;ik_max_word\\\u0026#34;,\\n\u0026#34; + \u0026#34; \\\u0026#34;copy_to\\\u0026#34;: \\\u0026#34;all\\\u0026#34;\\n\u0026#34; + \u0026#34; },\\n\u0026#34; + \u0026#34; \\\u0026#34;address\\\u0026#34;: {\\n\u0026#34; + \u0026#34; \\\u0026#34;type\\\u0026#34;: \\\u0026#34;keyword\\\u0026#34;,\\n\u0026#34; + \u0026#34; \\\u0026#34;index\\\u0026#34;: false\\n\u0026#34; + \u0026#34; },\\n\u0026#34; + \u0026#34; \\\u0026#34;price\\\u0026#34;: {\\n\u0026#34; + \u0026#34; \\\u0026#34;type\\\u0026#34;: \\\u0026#34;integer\\\u0026#34;\\n\u0026#34; + \u0026#34; },\\n\u0026#34; + \u0026#34; \\\u0026#34;score\\\u0026#34;: {\\n\u0026#34; + \u0026#34; \\\u0026#34;type\\\u0026#34;: \\\u0026#34;integer\\\u0026#34;\\n\u0026#34; + \u0026#34; },\\n\u0026#34; + \u0026#34; \\\u0026#34;brand\\\u0026#34;: {\\n\u0026#34; + \u0026#34; \\\u0026#34;type\\\u0026#34;: \\\u0026#34;keyword\\\u0026#34;,\\n\u0026#34; + \u0026#34; \\\u0026#34;copy_to\\\u0026#34;: \\\u0026#34;all\\\u0026#34;\\n\u0026#34; + \u0026#34; },\\n\u0026#34; + \u0026#34; \\\u0026#34;city\\\u0026#34;: {\\n\u0026#34; + \u0026#34; \\\u0026#34;type\\\u0026#34;: \\\u0026#34;keyword\\\u0026#34;,\\n\u0026#34; + \u0026#34; \\\u0026#34;copy_to\\\u0026#34;: \\\u0026#34;all\\\u0026#34;\\n\u0026#34; + \u0026#34; },\\n\u0026#34; + \u0026#34; \\\u0026#34;starName\\\u0026#34;: {\\n\u0026#34; + \u0026#34; \\\u0026#34;type\\\u0026#34;: \\\u0026#34;keyword\\\u0026#34;\\n\u0026#34; + \u0026#34; },\\n\u0026#34; + \u0026#34; \\\u0026#34;business\\\u0026#34;: {\\n\u0026#34; + \u0026#34; \\\u0026#34;type\\\u0026#34;: \\\u0026#34;keyword\\\u0026#34;\\n\u0026#34; + \u0026#34; },\\n\u0026#34; + \u0026#34; \\\u0026#34;location\\\u0026#34;: {\\n\u0026#34; + \u0026#34; \\\u0026#34;type\\\u0026#34;: \\\u0026#34;geo_point\\\u0026#34;\\n\u0026#34; + \u0026#34; },\\n\u0026#34; + \u0026#34; \\\u0026#34;pic\\\u0026#34;: {\\n\u0026#34; + \u0026#34; \\\u0026#34;type\\\u0026#34;: \\\u0026#34;keyword\\\u0026#34;,\\n\u0026#34; + \u0026#34; \\\u0026#34;index\\\u0026#34;: false\\n\u0026#34; + \u0026#34; },\\n\u0026#34; + \u0026#34; \\\u0026#34;all\\\u0026#34;: {\\n\u0026#34; + \u0026#34; \\\u0026#34;type\\\u0026#34;: \\\u0026#34;text\\\u0026#34;,\\n\u0026#34; + \u0026#34; \\\u0026#34;analyzer\\\u0026#34;: \\\u0026#34;ik_max_word\\\u0026#34;\\n\u0026#34; + \u0026#34; }\\n\u0026#34; + \u0026#34; }\\n\u0026#34; + \u0026#34; }\\n\u0026#34; + \u0026#34;}\u0026#34;; } 创建索引代码\n1 2 3 4 5 6 7 8 9 10 11 12 // 注意CreateIndexRequest的包 import org.elasticsearch.client.indices.CreateIndexRequest; @Test void testCreateHotelIndex() throws IOException { // 创建Request对象 CreateIndexRequest request = new CreateIndexRequest(\u0026#34;hotel\u0026#34;); // 请求参数 request.source(MAPPING_TEMPLATE, XContentType.JSON); // 发起请求 client.indices().create(request, RequestOptions.DEFAULT); } 删除索引库 DSL 语句\n1 DELETE /hotel 与创建的代码差异仅在 Request 对象上，并且无参数\n1 2 3 4 5 6 7 @Test void testDeleteHotelIndex() throws IOException { // 创建请求 DeleteIndexRequest request = new DeleteIndexRequest(\u0026#34;hotel\u0026#34;); // 发起请求 client.indices().delete(request, RequestOptions.DEFAULT); } 判断索引库是否存在 DSL 语句\n1 GET /hotel 差异依旧为 Request 对象\n1 2 3 4 5 6 7 8 9 @Test void testExistsHotelIndex() throws IOException { // 创建请求 GetIndexRequest request = new GetIndexRequest(\u0026#34;hotel\u0026#34;); // 发请求 boolean exists = client.indices().exists(request, RequestOptions.DEFAULT); // 输出 System.out.println(exists); } 总结\nJavaRestClient 操作 ES 的流程基本类似，使用 client.indices() 方法获取索引库的操作对象\nRestClient 一般数据在数据库通过查询数据库对索引库 CRUD\n初始化 RestHighLevelClient\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 @SpringBootTest public class HotelDocumentTest { // 注入服务 @Autowired private IHotelService hotelService; private RestHighLevelClient client; @BeforeEach void setUp() { // 构造 RestClient this.client = new RestHighLevelClient( RestClient.builder( HttpHost.create(\u0026#34;http://127.0.0.1:9200\u0026#34;))); } @AfterEach void tearDown() throws IOException { this.client.close(); } } 新增文档 将数据库的数据查询出来，写入 ES 中\n结构调整 数据库查询后的结果是一个 Hotel 类型的对象\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @Data @TableName(\u0026#34;tb_hotel\u0026#34;) public class Hotel { @TableId(type = IdType.INPUT) private Long id; private String name; private String address; private Integer price; private Integer score; private String brand; private String city; private String starName; private String business; private String longitude; private String latitude; private String pic; } 与索引库结构存在差异，需要定义一个新的类型，与索引库结构相同\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 @Data @NoArgsConstructor public class HotelDoc { private Long id; private String name; private String address; private Integer price; private Integer score; private String brand; private String city; private String starName; private String business; private String location; private String pic; public HotelDoc(Hotel hotel) { this.id = hotel.getId(); this.name = hotel.getName(); this.address = hotel.getAddress(); this.price = hotel.getPrice(); this.score = hotel.getScore(); this.brand = hotel.getBrand(); this.city = hotel.getCity(); this.starName = hotel.getStarName(); this.business = hotel.getBusiness(); this.location = hotel.getLatitude() + \u0026#34;, \u0026#34; + hotel.getLongitude(); this.pic = hotel.getPic(); } } 新增语法 DSL 的语法为\n1 2 3 4 5 POST /{indexName}/_doc/{id} { \u0026#34;name\u0026#34;: \u0026#34;Jack\u0026#34;, \u0026#34;age\u0026#34;: 21 } 对应的 Java\n1 2 3 4 5 6 7 8 9 10 11 12 @Test public void HotelCreateTest() throws IOException { // 准备request对象 IndexRequest request = new IndexRequest(\u0026#34;indexName\u0026#34;).id(\u0026#34;1\u0026#34;); // 准备JSON对象 request.source(\u0026#34;{\\n\u0026#34; + \u0026#34; \\\u0026#34;name\\\u0026#34;: \\\u0026#34;Jack\\\u0026#34;,\\n\u0026#34; + \u0026#34; \\\u0026#34;age\\\u0026#34;: 21\\n\u0026#34; + \u0026#34;}\u0026#34;, XContentType.JSON); // 发送请求 client.index(request, RequestOptions.DEFAULT); } 新增文档实例代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @Test public void HotelCreateTest() throws IOException { // 查询酒店数据 Hotel hotel = hotelService.getById(61083L); // 转换文档类型 HotelDoc hotelDoc = new HotelDoc(hotel); // 转为JSON String json = JSON.toJSONString(hotelDoc); // 准备request对象 IndexRequest request = new IndexRequest(\u0026#34;hotel\u0026#34;).id(hotelDoc.getId().toString()); // 准备JSON对象 request.source(json, XContentType.JSON); // 发送请求 client.index(request, RequestOptions.DEFAULT); } 查询文档 查询语法 DSL 语句\n1 GET /{indexName}/_doc/{id} Java 语句\n1 2 3 4 5 6 7 8 9 10 11 @Test public void HotelGetTest() throws IOException { // 准备request GetRequest request = new GetRequest(\u0026#34;indexName\u0026#34;, \u0026#34;id\u0026#34;); // 发送请求 GetResponse response = client.get(request, RequestOptions.DEFAULT); // 解析结果 String json = response.getSourceAsString(); System.out.println(json); } 查询文档实例代码 1 2 3 4 5 6 7 8 9 10 11 12 @Test public void HotelGetTest() throws IOException { // 准备request GetRequest request = new GetRequest(\u0026#34;hotel\u0026#34;, \u0026#34;61083\u0026#34;); // 发送请求 GetResponse response = client.get(request, RequestOptions.DEFAULT); // 解析结果 String json = response.getSourceAsString(); // 反序列化为Java对象 HotelDoc hotelDoc = JSON.parseObject(json, HotelDoc.class); System.out.println(hotelDoc); } 删除文档 删除语法 DSL 语句\n1 DELETE /{indexName}/_doc/{id} Java 语句\n1 2 3 4 5 6 7 @Test public void HotelDeleteTest() throws IOException { // 准备request DeleteRequest request = new DeleteRequest(\u0026#34;indexName\u0026#34;, \u0026#34;id\u0026#34;); // 发送请求 client.delete(request, RequestOptions.DEFAULT); } 删除文档实例代码 1 2 3 4 5 6 7 @Test public void HotelDeleteTest() throws IOException { // 准备request DeleteRequest request = new DeleteRequest(\u0026#34;hotel\u0026#34;, \u0026#34;61083\u0026#34;); // 发送请求 client.delete(request, RequestOptions.DEFAULT); } 修改文档 修改语法 修改有全量修改与增量修改，在 RestClient 的 API 中，两种方式的 API 完全一致，判断依据是 ID，新增时：\nID 存在，修改 ID 不存在，新增 这里主要关注增量修改，DSL 语句\n1 2 3 4 5 POST /{indexName}/_update/{id} { \u0026#34;doc\u0026#34;: \u0026#34;Rose\u0026#34;, \u0026#34;age\u0026#34;: 18 } Java 语句\n1 2 3 4 5 6 7 8 9 10 11 12 @Test public void HotelUpdateTest() throws IOException { // 创建request对象 UpdateRequest request = new UpdateRequest(\u0026#34;indexName\u0026#34;, \u0026#34;id\u0026#34;); // 准备参数 request.doc( \u0026#34;name\u0026#34;, \u0026#34;Rose\u0026#34;, \u0026#34;age\u0026#34;, 18 ); // 更新文档 client.update(request, RequestOptions.DEFAULT); } 修改文档实例代码 1 2 3 4 5 6 7 8 9 10 11 12 @Test public void HotelUpdateTest() throws IOException { // 创建request对象 UpdateRequest request = new UpdateRequest(\u0026#34;hotel\u0026#34;, \u0026#34;61083\u0026#34;); // 准备参数 request.doc( \u0026#34;price\u0026#34;, 950, \u0026#34;starName\u0026#34;, \u0026#34;四钻\u0026#34; ); // 更新文档 client.update(request, RequestOptions.DEFAULT); } 批量导入文档 利用 BulkRequest 批量将数据库数据导入到索引库中。本质是将多个普通的 CRUD 请求组合在一起发送，示例\n1 2 3 4 5 6 7 8 9 10 @Test public void testBulk() throws IOException { // 创建bulk请求 BulkRequest request = new BulkRequest(); // 添加批量请求 request.add(new IndexRequest(\u0026#34;indexName\u0026#34;).id(\u0026#34;id1\u0026#34;).source(\u0026#34;json1\u0026#34;, XContentType.JSON)); request.add(new IndexRequest(\u0026#34;indexName\u0026#34;).id(\u0026#34;id2\u0026#34;).source(\u0026#34;json2\u0026#34;, XContentType.JSON)); // 发起bulk请求 client.bulk(request, RequestOptions.DEFAULT); } 批量导入文档实例代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 @Test public void testBulk() throws IOException { // 批量查询数据 List\u0026lt;Hotel\u0026gt; hotelList = hotelService.list(); // 创建bulk请求 BulkRequest request = new BulkRequest(); // 添加批量请求 for (Hotel hotel : hotelList) { // 转换文档类型 HotelDoc hotelDoc = new HotelDoc(hotel); // 创建新增文档request对象 request.add(new IndexRequest(\u0026#34;hotel\u0026#34;) .id(hotelDoc.getId().toString()) .source(JSON.toJSONString(hotelDoc), XContentType.JSON) ); } // 发起bulk请求 client.bulk(request, RequestOptions.DEFAULT); } ","date":"2025-02-03T22:30:00+09:00","permalink":"https://blog.yexca.net/archives/228/","title":"Elasticsearch RestClient 入门"},{"content":" Elasticsearch 系列\n内容 链接 Elasticsearch 基础操作 https://blog.yexca.net/archives/226 Elasticsearch 查询操作 本文 RestClient 基础操作 https://blog.yexca.net/archives/228 RestClient 查询操作 https://blog.yexca.net/archives/229 Elasticsearch 数据聚合 https://blog.yexca.net/archives/231 Elasticsearch 自动补全 https://blog.yexca.net/archives/232 Elasticsearch 数据同步 https://blog.yexca.net/archives/234 Elasticsearch 集群 https://blog.yexca.net/archives/235 上篇文章主要为 es 的数据存储功能，但 es 最擅长的还是搜索和数据分析\nes 的查询依然是基于 JSON 风格的 DSL 来实现的\n查询分类 常见的查询类型包括：\n查询所有：查询出所有数据，一般测试用。例 match_all 全文检索 (full text) 查询：利用分词器对用户输入内容分词，然后去倒排索引库中匹配，例： match_query multi_match_query 精确查询：根据精确词条值查找数据，一般是查找 keyword、数值、日期、boolean 等类型字段。例： ids range term 地理 (geo) 查询：根据经纬度查询。例： geo_distance geo_bounding_box 复合 (compound) 查询：将上述简单查询条件组合起来，合并查询条件。例： bool function_score 查询的语法基本一致：\n1 2 3 4 5 6 7 8 GET /indexName/_search { \u0026#34;query\u0026#34;: { \u0026#34;查询类型\u0026#34;: { \u0026#34;查询条件\u0026#34;: \u0026#34;条件值\u0026#34; } } } 查询所有 查询类型为 match_all 没有查询条件\n1 2 3 4 5 6 7 // 查询所有 GET /indexName/_search { \u0026#34;query\u0026#34;: { \u0026#34;match_all\u0026#34;: {} } } 全文检索查询 会对用户输入内容分词，常用于搜索框搜索。因为是拿着词条去匹配，因此参与搜索的字段也必须是可分词的 text 类型的字段\n常见的：\nmatch：单字段查询 multi_match：多字段查询，任意一个字段符合条件就算符合查询条件 match 查询语法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # match GET /indexName/_search { \u0026#34;query\u0026#34;: { \u0026#34;match\u0026#34;: { \u0026#34;FIELD\u0026#34;: \u0026#34;TEXT\u0026#34; } } } # 例子 GET /hotel/_search { \u0026#34;query\u0026#34;: { \u0026#34;match\u0026#34;: { \u0026#34;all\u0026#34;: \u0026#34;外滩如家\u0026#34; } } } multi_match 语法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # multi_match GET /indexName/_search { \u0026#34;query\u0026#34;: { \u0026#34;multi_match\u0026#34;: { \u0026#34;query\u0026#34;: \u0026#34;TEXT\u0026#34;, \u0026#34;fields\u0026#34;: [\u0026#34;FIELD1\u0026#34;, \u0026#34;FIELD2\u0026#34;] } } } # 例子 GET /hotel/_search { \u0026#34;query\u0026#34;: { \u0026#34;multi_match\u0026#34;: { \u0026#34;query\u0026#34;: \u0026#34;外滩如家\u0026#34;, \u0026#34;fields\u0026#34;: [\u0026#34;brand\u0026#34;, \u0026#34;name\u0026#34;, \u0026#34;business\u0026#34;] } } } 由于之前创索引表时将 brand、name、business 值利用 copy_to 复制到了 all 字段，上述两种查询结果一样\n但搜索字段越多对性能影响越大，建议使用 copy_to，然后单字段查询\n精准查询 精准查询不会对搜索条件分词，常见的有：\nterm：根据词条精确值查询 range：根据值的范围查询 term 查询 查询条件必须是不分词的词条，输入与值完全匹配才符合条件\n语法：\n1 2 3 4 5 6 7 8 9 10 11 # term GET /indexName/_search { \u0026#34;query\u0026#34;: { \u0026#34;term\u0026#34;: { \u0026#34;FIELD\u0026#34;: { \u0026#34;value\u0026#34;: \u0026#34;VALUE\u0026#34; } } } } 示例\n1 2 3 4 5 6 7 8 9 10 GET /hotel/_search { \u0026#34;query\u0026#34;: { \u0026#34;term\u0026#34;: { \u0026#34;city\u0026#34;: { \u0026#34;value\u0026#34;: \u0026#34;上海\u0026#34; } } } } range 查询 范围查询，一般应用在对数值类型做范围过滤的时候。比如做价格、日期范围过滤\n语法：\n1 2 3 4 5 6 7 8 9 10 11 12 # range GET /hotel/_search { \u0026#34;query\u0026#34;: { \u0026#34;range\u0026#34;: { \u0026#34;FIELD\u0026#34;: { \u0026#34;gte\u0026#34;: 10, // 这里的gte代表大于等于，gt则代表大于 \u0026#34;lte\u0026#34;: 20 // lte代表小于等于，lt则代表小于 } } } } 示例\n1 2 3 4 5 6 7 8 9 10 11 GET /hotel/_search { \u0026#34;query\u0026#34;: { \u0026#34;range\u0026#34;: { \u0026#34;price\u0026#34;: { \u0026#34;gte\u0026#34;: 1000, \u0026#34;lte\u0026#34;: 2000 } } } } 地理坐标查询 其实就是根据经纬度检索，官方文档： https://www.elastic.co/guide/en/elasticsearch/reference/current/geo-queries.html 常用场景：搜索附近酒店、出租车、人、美食\n矩形范围查询 geo_bounding_box 查询，查询坐标落在某个矩形范围内的所有文档\n需要指定左上、右下两个点的坐标\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # geo_bounding_box GET /indexName/_search { \u0026#34;query\u0026#34;: { \u0026#34;geo_bounding_box\u0026#34;: { \u0026#34;FIELD\u0026#34;: { \u0026#34;top_left\u0026#34;: { // 左上点 \u0026#34;lat\u0026#34;: 30, \u0026#34;lon\u0026#34;: 20 }, \u0026#34;bottom_right\u0026#34;: { // 右下点 \u0026#34;lat\u0026#34;: 31, \u0026#34;lon\u0026#34;: 21 } } } } } 附近查询 也叫距离查询 (geo_distance)：查询到指定中心点小于某个距离值的所有文档\n1 2 3 4 5 6 7 8 9 10 # geo_distance GET /indexName/_search { \u0026#34;query\u0026#34;: { \u0026#34;geo_distance\u0026#34;: { \u0026#34;distance\u0026#34;: \u0026#34;15km\u0026#34;, // 半径 \u0026#34;FIELD\u0026#34;: \u0026#34;31, 21\u0026#34; // 圆心 } } } 示例：搜索附近 (31.21, 121.5) 15km 内的酒店\n1 2 3 4 5 6 7 8 9 GET /hotel/_search { \u0026#34;query\u0026#34;: { \u0026#34;geo_distance\u0026#34;: { \u0026#34;distance\u0026#34;: \u0026#34;15km\u0026#34;, \u0026#34;location\u0026#34;: \u0026#34;31.21, 121.5\u0026#34; } } } 复合查询 将其他简单查询组合，实现更复杂的搜索逻辑，常见有两种：\nfunction score：算分函数查询，可以控制文档相关性算分，控制文档排名 bool query：布尔查询，利用逻辑关系组合多个其他查询，实现复杂搜索 相关性算分 当使用 match 查询时，文档结果会根据与搜索词条的关联度打分 (_score)，返回结果时按照分值降序排列，如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 [ { \u0026#34;_score\u0026#34; : 17.850193, \u0026#34;_source\u0026#34; : { \u0026#34;name\u0026#34; : \u0026#34;虹桥如家酒店真不错\u0026#34;, } }, { \u0026#34;_score\u0026#34; : 12.259849, \u0026#34;_source\u0026#34; : { \u0026#34;name\u0026#34; : \u0026#34;外滩如家酒店真不错\u0026#34;, } }, { \u0026#34;_score\u0026#34; : 11.91091, \u0026#34;_source\u0026#34; : { \u0026#34;name\u0026#34; : \u0026#34;迪士尼如家酒店真不错\u0026#34;, } } ] 在 es 中，早期使用的打分算法是 TF-IDF 算法\nTF-IDF 算法有缺陷，就是词条频率越高，文档得分也会越高，单个词条对文档影响较大。在 5.1 版本之后，算法改为 BM25 算法，会让单个词条的算分有一个上限\n算分函数查询 算分函数虽然比较合理，但不一定是产品所需要的。要想控制相关性算分，就需要利用 es 的 function score 查询，修改文档的相关性算分，根据新得到的算分排序\n结构：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # function score GET /indexName/_search { \u0026#34;query\u0026#34;: { \u0026#34;function_score\u0026#34;: { \u0026#34;query\u0026#34;: {}, // 原始查询 \u0026#34;functions\u0026#34;: [ { \u0026#34;filter\u0026#34;: {}, // 过滤条件 \u0026#34;weight\u0026#34;: 1 // 算分函数 } ], \u0026#34;boost_mode\u0026#34;: \u0026#34;multiply\u0026#34; // 运算模式 } } } 原始查询：基于这个条件搜索文档，并基于 BM25 算法给文档打分，原始算分 (query score)\n过滤条件：复合该条件的文档才会重新算分\n算分函数：复合 filter 条件的文档要根据此函数做运算，得到函数算分，有四种函数：\nweight：函数结果是常量 field_value_factor：以文档中的某个字段值作为函数结果 random_score：以随机数作为函数结果 script_score：自定义算分函数算法 运算模式：算分函数的结果、原始查询的相关性算分，两者之间的运算方式，包括：\nmultiply：相乘 replace：用 function score 替换 query score 其他，如：sum、avg、max、min 示例：给 \u0026ldquo;如家\u0026rdquo; 这个品牌的酒店排名靠前一些\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 GET /hotel/_search { \u0026#34;query\u0026#34;: { // 原始查询条件为任意，此处为能运行添加条件 \u0026#34;function_score\u0026#34;: { \u0026#34;query\u0026#34;: {\u0026#34;term\u0026#34;: { \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34; }}, \u0026#34;functions\u0026#34;: [ { \u0026#34;filter\u0026#34;: {\u0026#34;term\u0026#34;: { \u0026#34;brand\u0026#34;: \u0026#34;如家\u0026#34; }}, \u0026#34;weight\u0026#34;: 10 } ], \u0026#34;boost_mode\u0026#34;: \u0026#34;multiply\u0026#34; } } } 布尔查询 布尔查询是一个或多个查询子句的组合，每一个子句就是一个子查询，组合方式有：\nmust：必须匹配每个子查询，类似 \u0026ldquo;与\u0026rdquo; should：选择性匹配子查询，类似 \u0026ldquo;或\u0026rdquo; must_not：必须不匹配，不参与算分，类似 \u0026ldquo;非\u0026rdquo; filter：必须匹配，不参与算分 比如在搜索酒店时，可以选择地区、品牌、价格等字段做过滤，每一个不同的字段，其查询条件、方式不一样，必须是多个不同的查询，组合这些查询就要用 bool 查询了\n参与打分的字段，查询性能越差。多条件查询时，建议：\n搜索框的关键字搜索是全文检索，使用 must 查询，参与算分\n其他过滤条件，采用 filter 查询，不参与算分\n语法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # bool GET /hotel/_search { \u0026#34;query\u0026#34;: { \u0026#34;bool\u0026#34;: { \u0026#34;must\u0026#34;: [ {} ], \u0026#34;should\u0026#34;: [ {} ], \u0026#34;must_not\u0026#34;: [ {} ], \u0026#34;filter\u0026#34;: [ {} ] } } } 示例：搜索名字包含 \u0026ldquo;如家\u0026rdquo;，价格不高于 400，在坐标 31.21，121.5 周围 10km 范围内的酒店\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 GET /hotel/_search { \u0026#34;query\u0026#34;: { \u0026#34;bool\u0026#34;: { \u0026#34;must\u0026#34;: [ {\u0026#34;match\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;如家\u0026#34; }} ], \u0026#34;must_not\u0026#34;: [ {\u0026#34;range\u0026#34;: { \u0026#34;price\u0026#34;: { \u0026#34;gt\u0026#34;: 400 } }} ], \u0026#34;filter\u0026#34;: [ {\u0026#34;geo_distance\u0026#34;: { \u0026#34;distance\u0026#34;: \u0026#34;10km\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 31.21, \u0026#34;lon\u0026#34;: 121.5 } }} ] } } } 搜索结果处理 搜索得到的结果可以排序、分页与高亮\n排序 es 默认是按照相关度算分来排序，但是也支持自定义方式对搜索结果排序，可以排序字段类型有：keyword 类型、数值类型、地理坐标类型、日期类型等\n普通字段排序 keyword、数值、日期类型排序的语法基本一致\n语法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 # sort_normal GET /indexName/_search { \u0026#34;query\u0026#34;: { }, \u0026#34;sort\u0026#34;: [ { \u0026#34;FIELD\u0026#34;: { \u0026#34;order\u0026#34;: \u0026#34;desc\u0026#34; // 排序字段，ASC、DESC } } ] } 排序条件是一个数组，可以写多个排序条件，按照声明的顺序，当第一个条件相等时，再按第二个条件，以此类推\n示例：酒店数据按照用户评价降序，评价相同按价格升序\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 GET /hotel/_search { \u0026#34;query\u0026#34;: { \u0026#34;match\u0026#34;: { \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34; } }, \u0026#34;sort\u0026#34;: [ { \u0026#34;score\u0026#34;: { \u0026#34;order\u0026#34;: \u0026#34;desc\u0026#34; } }, { \u0026#34;price\u0026#34;: { \u0026#34;order\u0026#34;: \u0026#34;asc\u0026#34; } } ] } // 或者 GET /hotel/_search { \u0026#34;query\u0026#34;: { \u0026#34;match\u0026#34;: { \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34; } }, \u0026#34;sort\u0026#34;: [ { \u0026#34;score\u0026#34;: \u0026#34;desc\u0026#34; }, { \u0026#34;price\u0026#34;: \u0026#34;asc\u0026#34; } ] } 地理坐标排序 语法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # sort_geo GET /indexName/_search { \u0026#34;query\u0026#34;: { }, \u0026#34;sort\u0026#34;: [ { \u0026#34;_geo_distance\u0026#34;: { \u0026#34;FIELD\u0026#34;: { \u0026#34;lat\u0026#34;: 40, \u0026#34;lon\u0026#34;: -70 }, \u0026#34;order\u0026#34;: \u0026#34;asc\u0026#34;, // 排序方式 \u0026#34;unit\u0026#34;: \u0026#34;km\u0026#34; // 排序单位 } } ] } 示例：按酒店距离排序 (假设位置为 31.034661，121.612282)\n高德获取经纬度： https://lbs.amap.com/demo/jsapi-v2/example/map/click-to-get-lnglat/ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 GET /hotel/_search { \u0026#34;query\u0026#34;: { \u0026#34;match_all\u0026#34;: {} }, \u0026#34;sort\u0026#34;: [ { \u0026#34;_geo_distance\u0026#34;: { \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 31.034661, \u0026#34;lon\u0026#34;: 121.612282 }, \u0026#34;order\u0026#34;: \u0026#34;asc\u0026#34;, \u0026#34;unit\u0026#34;: \u0026#34;km\u0026#34; } } ] } 分页 es 默认只返回 top10 数据，如果要查询更多数据就需要修改分页参数，es 通过修改 from、size 参数来控制要返回的分页结果：\nfrom：从第几个文档开始 size：总共查询几个文档 类似于 MySQL 中的 limit ?,?\n基本分页 基本语法如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # 基本分页 GET /indexName/_search { \u0026#34;query\u0026#34;: { }, \u0026#34;from\u0026#34;: 0, \u0026#34;size\u0026#34;: 10, \u0026#34;sort\u0026#34;: [ { \u0026#34;FIELD\u0026#34;: { \u0026#34;order\u0026#34;: \u0026#34;desc\u0026#34; } } ] } 深度分页问题 如果要查询第 990-1000 数据，语句如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 GET /hotel/_search { \u0026#34;query\u0026#34;: { \u0026#34;match_all\u0026#34;: {} }, \u0026#34;from\u0026#34;: 990, \u0026#34;size\u0026#34;: 10, \u0026#34;sort\u0026#34;: [ { \u0026#34;price\u0026#34;: { \u0026#34;order\u0026#34;: \u0026#34;asc\u0026#34; } } ] } 但由于 es 的机制，分页时必须先查询 0-1000 条，然后截取 990-1000 展示\n如果 es 是单点模式，并无太大影响，但集群部署时查询 1000 条并不是每个节点查 200 条，因为 A 节点的 200 条可能在 B 节点排到 1000 名外\n为了获取前 1000，需要每个节点都查询 Top1000，然后汇总重新排名截取\n若要查询 Top10000 甚至更多会对内存和 CPU 产生非常大的压力，因此 es 禁止 from+size 超过 10000 的请求\n而针对深度分页，es 提供了两种解决方案： https://www.elastic.co/guide/en/elasticsearch/reference/current/paginate-search-results.html search after：分页时需要排序，原理是从上一次的排序值开始，查询下一页数据。官方推荐使用的方式 scroll：原理将排序后的文档 id 形成快照，保存在内存。官方已经不推荐使用 分页总结 from + size：\n优点：支持随机翻页 缺点：深度分页问题，默认查询上限（from + size）是 10000 场景：百度、京东、谷歌、淘宝这样的随机翻页搜索 after search：\n优点：没有查询上限（单次查询的 size 不超过10000） 缺点：只能向后逐页查询，不支持随机翻页 场景：没有随机翻页需求的搜索，例如手机向下滚动翻页 scroll：\n优点：没有查询上限（单次查询的size不超过 10000） 缺点：会有额外内存消耗，并且搜索结果是非实时的 场景：海量数据的获取和迁移。从 ES7.1 开始不推荐，建议用 after search方案 高亮 使用搜索引擎搜索内容时，关键字会变为红色，较为醒目，为高亮显示，一般是给文档所有关键字添加一个标签 (\u0026lt;em\u0026gt;)，给该标签编写 CSS 样式\n语法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # 高亮 GET /indexName/_search { \u0026#34;query\u0026#34;: { }, \u0026#34;highlight\u0026#34;: { \u0026#34;fields\u0026#34;: { // 指定要高亮的字段 \u0026#34;FIELD\u0026#34;: { \u0026#34;pre_tags\u0026#34;: \u0026#34;\u0026lt;em\u0026gt;\u0026#34;, // 用来标记高亮字段的前置标签 \u0026#34;post_tags\u0026#34;: \u0026#34;\u0026lt;/em\u0026gt;\u0026#34; // 用来标记高亮字段的后置标签 } } } } 注意：\n高亮是对关键字高亮，所以搜索条件必须有关键字，不能是范围查询 默认情况下，高亮的字段，必须与搜素指定的字段一致，否则无法高亮 对非搜索字段高亮，需要添加属性：required_field_match=false 示例：搜索，名字部分高亮\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 GET /hotel/_search { \u0026#34;query\u0026#34;: { \u0026#34;match\u0026#34;: { \u0026#34;all\u0026#34;: \u0026#34;如家\u0026#34; } }, \u0026#34;highlight\u0026#34;: { \u0026#34;fields\u0026#34;: { \u0026#34;name\u0026#34;: { \u0026#34;require_field_match\u0026#34;: \u0026#34;false\u0026#34;, \u0026#34;pre_tags\u0026#34;: \u0026#34;\u0026lt;em\u0026gt;\u0026#34;, \u0026#34;post_tags\u0026#34;: \u0026#34;\u0026lt;/em\u0026gt;\u0026#34; } } } } // 截取结果 \u0026#34;hits\u0026#34; : [ { \u0026#34;_index\u0026#34; : \u0026#34;hotel\u0026#34;, \u0026#34;_type\u0026#34; : \u0026#34;_doc\u0026#34;, \u0026#34;_id\u0026#34; : \u0026#34;339952837\u0026#34;, \u0026#34;_score\u0026#34; : 2.7875905, \u0026#34;_source\u0026#34; : { \u0026#34;address\u0026#34; : \u0026#34;良乡西路7号\u0026#34;, \u0026#34;brand\u0026#34; : \u0026#34;如家\u0026#34;, \u0026#34;business\u0026#34; : \u0026#34;房山风景区\u0026#34;, \u0026#34;city\u0026#34; : \u0026#34;北京\u0026#34;, \u0026#34;id\u0026#34; : 339952837, \u0026#34;location\u0026#34; : \u0026#34;39.73167, 116.132482\u0026#34;, \u0026#34;name\u0026#34; : \u0026#34;如家酒店(北京良乡西路店)\u0026#34;, \u0026#34;pic\u0026#34; : \u0026#34;https://m.tuniucdn.com/fb3/s1/2n9c/3Dpgf5RTTzrxpeN5y3RLnRVtxMEA_w200_h200_c1_t0.jpg\u0026#34;, \u0026#34;price\u0026#34; : 159, \u0026#34;score\u0026#34; : 46, \u0026#34;starName\u0026#34; : \u0026#34;二钻\u0026#34; }, \u0026#34;highlight\u0026#34; : { \u0026#34;name\u0026#34; : [ \u0026#34;\u0026lt;em\u0026gt;如家\u0026lt;/em\u0026gt;酒店(北京良乡西路店)\u0026#34; ] } } ] 结果的 highlight 部分展示了添加标签后的结果\n搜索结果处理总结 DSL 查询是一个大 JSON 对象，包含\nquery：查询 from、size：分页条件 sort：排序条件 highlight：高亮条件 综合示例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 # 查询综合 GET /hotel/_search { \u0026#34;query\u0026#34;: { // 查询 \u0026#34;match\u0026#34;: { \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34; } }, \u0026#34;from\u0026#34;: 10, // 分页起始 \u0026#34;size\u0026#34;: 10, // 分页尺寸 \u0026#34;sort\u0026#34;: [ { // 普通排序 \u0026#34;price\u0026#34;: { \u0026#34;order\u0026#34;: \u0026#34;asc\u0026#34; } }, { // 距离排序 \u0026#34;_geo_distance\u0026#34;: { \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 31, \u0026#34;lon\u0026#34;: 121 }, \u0026#34;order\u0026#34;: \u0026#34;asc\u0026#34;, \u0026#34;unit\u0026#34;: \u0026#34;km\u0026#34; } } ], \u0026#34;highlight\u0026#34;: { // 高亮字段 \u0026#34;fields\u0026#34;: { \u0026#34;name\u0026#34;: { \u0026#34;require_field_match\u0026#34;: \u0026#34;false\u0026#34;, \u0026#34;pre_tags\u0026#34;: \u0026#34;\u0026lt;em\u0026gt;\u0026#34;, \u0026#34;post_tags\u0026#34;: \u0026#34;\u0026lt;/em\u0026gt;\u0026#34; } } } } ","date":"2025-02-01T15:16:28+09:00","permalink":"https://blog.yexca.net/archives/227/","title":"Elasticsearch 查询"},{"content":" Elasticsearch 系列\n内容 链接 Elasticsearch 基础操作 本文 Elasticsearch 查询操作 https://blog.yexca.net/archives/227 RestClient 基础操作 https://blog.yexca.net/archives/228 RestClient 查询操作 https://blog.yexca.net/archives/229 Elasticsearch 数据聚合 https://blog.yexca.net/archives/231 Elasticsearch 自动补全 https://blog.yexca.net/archives/232 Elasticsearch 数据同步 https://blog.yexca.net/archives/234 Elasticsearch 集群 https://blog.yexca.net/archives/235 Elasticsearch 是一款非常强大的开源搜索引擎，可以帮助我们从海量数据中快速找到需要的内容。结合 kibana、Logstash、Beats，也就是 elastic stack (ELK)。被广泛应用在日志数据分析、实时监控等领域\n而 Elasticsearch 是 Elastic Stack 的核心，负责存储、搜索、分析数据\nElasticsearch 底层基于 Lucene 实现，Lucene 为 Java 的一个搜索引擎类库\n正向索引 传统数据库 (例如 MySQL) 采用正向索引，例如下表\nid title price 1 小米手机 3499 2 华为手机 4999 3 华为小米充电器 49 4 小米手环 239 如果基于 id 精准查询，直接走索引会很快\n但若基于 title 做模糊查询，只能逐行扫描数据，流程：\n用户搜索 手机，数据库条件 %手机% 逐行获取数据，如 id 为 1 的数据 判断数据中的 title 是否符合条件 符合则放入，不符合则舍弃，下一行 随着数据量的增加，逐行扫描的效率越来越低\n倒排索引 倒排索引的概念是基于 MySQL 这样的正向索引而言的\nElasticsearch 采用倒排索引，概念：\n文档 (document)：每条数据就是一个文档 词条 (term)：文档按照语义分成的词语 创建倒排索引是对正向索引的一种特殊处理，流程：\n将每一个文档的数据利用算法分词，得到一个个词条 创建表，每行包括词条、词条所在文档 id、位置等信息 因为词条的唯一性，可以给词条创建索引，例如 hash 表结构索引 例如上例的表可以创建如下倒排索引\n词条 文档 id 小米 1，3，4 手机 1，2 华为 2，3 充电器 3 手环 4 倒排索引搜索流程：\n用户搜索 小米手机 对搜索内容分词，得到 小米、手机 使用词条在倒排索引查找，得到包含词条的文档 id：1、2、3、4 使用文档 id 到正向索引中查找具体文档 文档 Elasticsearch 是面向文档存储的，可以是数据库中的一条商品数据，一个订单信息。文档数据会被序列化为 json 格式后存储在 Elasticsearch 中\n上述正向索引表的 json 如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 { \u0026#34;id\u0026#34;: 1, \u0026#34;title\u0026#34;: \u0026#34;小米手机\u0026#34;, \u0026#34;price\u0026#34;: 3499 } { \u0026#34;id\u0026#34;: 2, \u0026#34;title\u0026#34;: \u0026#34;华为手机\u0026#34;, \u0026#34;price\u0026#34;: 4999 } { \u0026#34;id\u0026#34;: 3, \u0026#34;title\u0026#34;: \u0026#34;华为小米充电器\u0026#34;, \u0026#34;price\u0026#34;: 49 } { \u0026#34;id\u0026#34;: 4, \u0026#34;title\u0026#34;: \u0026#34;小米手环\u0026#34;, \u0026#34;price\u0026#34;: 299 } 在 Json 文档中包含很多字段，类似于数据库中的列\n索引与映射 索引 (index) 为相同类型的文档的集合\n映射 (mapping) 为索引中文档的字段约束信息，类似表的结构约束\n可以把索引当做是数据库中的表，数据库的表会有约束信息，用来定义表的结构、字段的名称、类型等信息。因此，索引库中就有映射，是索引中文档的字段约束信息，类似表的结构约束\nMySQL 与 Elasticsearch MySQL Elasticsearch 说明 Table Index 索引 (index)，就是文档的集合，类似数据库的表 (table) Row Document 文档 (Document)，就是一条条的数据，类似数据库中的行 (Row)，文档都是 JSON 格式 Column Field 字段 (Field)，就是 JSON 文档中的字段，类似数据库中的列 (Column) Schema Mapping Mapping (映射) 是索引中文档的约束，例如字段类型约束。类似数据库的表结构 (Schema) SQL DSL DSL 是 elasticsearch 提供的 JSON 风格的请求语句，用来操作 elasticsearch，实现 CRUD 在企业中，往往是两者结合使用：\n对安全性要求较高的写操作，使用 mysql 实现 对查询性能要求较高的搜索需求，使用 elasticsearch 实现 两者再基于某种方式，实现数据的同步，保证一致性 优缺点 正向索引：\n优点： 可以给多个字段创建索引 根据索引字段搜索、排序速度非常快 缺点： 根据非索引字段，或者索引字段中的部分词条查找时，只能全表扫描 倒排索引：\n优点： 根据词条搜索、模糊搜索时，速度非常快 缺点： 只能给词条创建索引，而不是字段 无法根据字段做排序 安装 一般只用 Elasticsearch 即可，使用 kibana 可以提供一个 elasticsearch 的可视化界面，方便学习书写 DSL 语句\nElasticsearch 为了使 Elasticsearch 与 kibana 容器互联，可以先创建一个网络\n1 docker network create es-net 有多种方式可以实现互联，如 docker-compose、172.17.0.1\n拉取 Elasticsearch\n1 docker pull elasticsearch:7.12.1 单点部署\n1 2 3 4 5 6 7 8 9 10 11 docker run -d \\ --name es \\ -e \u0026#34;ES_JAVA_OPTS=-Xms512m -Xmx512m\u0026#34; \\ -e \u0026#34;discovery.type=single-node\u0026#34; \\ -v es-data:/usr/share/elasticsearch/data \\ -v es-plugins:/usr/share/elasticsearch/plugins \\ --privileged \\ --network es-net \\ -p 9200:9200 \\ -p 9300:9300 \\ elasticsearch:7.12.1 注意修改映射目录，上述使用数据卷，部分解释\n-e \u0026quot;cluster.name=es-docker-cluster\u0026quot;：设置集群名称 -e \u0026quot;http.host=0.0.0.0\u0026quot;：监听的地址，可以外网访问 -e \u0026quot;ES_JAVA_OPTS=-Xms512m -Xmx512m\u0026quot;：内存大小 -e \u0026quot;discovery.type=single-node\u0026quot;：非集群模式 -v es-data:/usr/share/elasticsearch/data：挂载逻辑卷，绑定es的数据目录 -v es-logs:/usr/share/elasticsearch/logs：挂载逻辑卷，绑定es的日志目录 -v es-plugins:/usr/share/elasticsearch/plugins：挂载逻辑卷，绑定es的插件目录 --privileged：授予逻辑卷访问权 --network es-net ：加入一个名为es-net的网络中 访问 localhost:9200 查看返回类似下述即启动成功\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 { \u0026#34;name\u0026#34; : \u0026#34;6747e3f712ba\u0026#34;, \u0026#34;cluster_name\u0026#34; : \u0026#34;docker-cluster\u0026#34;, \u0026#34;cluster_uuid\u0026#34; : \u0026#34;GSLtjxiMSlyRRRW-pSzvWQ\u0026#34;, \u0026#34;version\u0026#34; : { \u0026#34;number\u0026#34; : \u0026#34;7.12.1\u0026#34;, \u0026#34;build_flavor\u0026#34; : \u0026#34;default\u0026#34;, \u0026#34;build_type\u0026#34; : \u0026#34;docker\u0026#34;, \u0026#34;build_hash\u0026#34; : \u0026#34;3186837139b9c6b6d23c3200870651f10d3343b7\u0026#34;, \u0026#34;build_date\u0026#34; : \u0026#34;2021-04-20T20:56:39.040728659Z\u0026#34;, \u0026#34;build_snapshot\u0026#34; : false, \u0026#34;lucene_version\u0026#34; : \u0026#34;8.8.0\u0026#34;, \u0026#34;minimum_wire_compatibility_version\u0026#34; : \u0026#34;6.8.0\u0026#34;, \u0026#34;minimum_index_compatibility_version\u0026#34; : \u0026#34;6.0.0-beta1\u0026#34; }, \u0026#34;tagline\u0026#34; : \u0026#34;You Know, for Search\u0026#34; } kibana 拉取同版本镜像\n1 docker pull kibana:7.12.1 运行\n1 2 3 4 5 6 docker run -d \\ --name kibana \\ -e ELASTICSEARCH_HOSTS=http://es:9200 \\ --network=es-net \\ -p 5601:5601 \\ kibana:7.12.1 其中 -e ELASTICSEARCH_HOSTS=http://es:9200\u0026quot;：设置 elasticsearch 的地址，因为 kibana 已经与 elasticsearch 在一个网络，因此可以用容器名直接访问 elasticsearch\nkibana 启动一般比较慢，需要多等一会，可以查看日志，若出现端口号则启动成功\n1 docker logs -f kibana 访问 localhost:5601 查看结果\nIK 分词器 es 在创建倒排索引时需要对文档分词；在搜索时，需要对用户输入内容分词。但默认的分词规则对中文处理并不友好，例如测试\n1 2 3 4 5 6 # 测试分词 POST /_analyze { \u0026#34;analyzer\u0026#34;: \u0026#34;standard\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;初次使用 Elasticsearch\u0026#34; } 语法说明\nPOST：请求方式 /_analyze：请求路径。这里省略了 http://localhost:9200 ，由 kibana 补充 请求参数使用 JSON analyzer：分词器类型，默认为 standard text：需要分词的内容 结果为\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 { \u0026#34;tokens\u0026#34; : [ { \u0026#34;token\u0026#34; : \u0026#34;初\u0026#34;, \u0026#34;start_offset\u0026#34; : 0, \u0026#34;end_offset\u0026#34; : 1, \u0026#34;type\u0026#34; : \u0026#34;\u0026lt;IDEOGRAPHIC\u0026gt;\u0026#34;, \u0026#34;position\u0026#34; : 0 }, { \u0026#34;token\u0026#34; : \u0026#34;次\u0026#34;, \u0026#34;start_offset\u0026#34; : 1, \u0026#34;end_offset\u0026#34; : 2, \u0026#34;type\u0026#34; : \u0026#34;\u0026lt;IDEOGRAPHIC\u0026gt;\u0026#34;, \u0026#34;position\u0026#34; : 1 }, { \u0026#34;token\u0026#34; : \u0026#34;使\u0026#34;, \u0026#34;start_offset\u0026#34; : 2, \u0026#34;end_offset\u0026#34; : 3, \u0026#34;type\u0026#34; : \u0026#34;\u0026lt;IDEOGRAPHIC\u0026gt;\u0026#34;, \u0026#34;position\u0026#34; : 2 }, { \u0026#34;token\u0026#34; : \u0026#34;用\u0026#34;, \u0026#34;start_offset\u0026#34; : 3, \u0026#34;end_offset\u0026#34; : 4, \u0026#34;type\u0026#34; : \u0026#34;\u0026lt;IDEOGRAPHIC\u0026gt;\u0026#34;, \u0026#34;position\u0026#34; : 3 }, { \u0026#34;token\u0026#34; : \u0026#34;elasticsearch\u0026#34;, \u0026#34;start_offset\u0026#34; : 5, \u0026#34;end_offset\u0026#34; : 18, \u0026#34;type\u0026#34; : \u0026#34;\u0026lt;ALPHANUM\u0026gt;\u0026#34;, \u0026#34;position\u0026#34; : 4 } ] } 可以看到分词效果非常不好，处理中文分词，一般会使用IK分词器\nIK 分词器 Github： https://github.com/medcl/elasticsearch-analysis-ik 在线安装 注意安装版本与 es 对应\n1 2 3 4 5 6 7 8 9 10 # 进入容器内部 docker exec -it elasticsearch /bin/bash # 在线下载并安装 ./bin/elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.12.1/elasticsearch-analysis-ik-7.12.1.zip #退出 exit #重启容器 docker restart elasticsearch 离线安装 安装插件需要知道 elasticsearch 的 plugins 目录位置，上述使用数据卷挂载到本地，可使用下面命令查看\n1 docker volume inspect es-plugins 输出的 JSON 的 Mountpoint 即为目录\n将从 Github 下载的压缩包解压后文件夹重命名为 ik，放到 plugins 目录下\n重启容器\n1 docker restart es 测试效果 IK 分词器有两种模式\nik_smart：最少切分 ik_max_word：最细切分 还是上例\n1 2 3 4 5 6 # 测试IK分词 POST /_analyze { \u0026#34;analyzer\u0026#34;: \u0026#34;ik_smart\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;初次使用 Elasticsearch\u0026#34; } 结果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 { \u0026#34;tokens\u0026#34; : [ { \u0026#34;token\u0026#34; : \u0026#34;初次\u0026#34;, \u0026#34;start_offset\u0026#34; : 0, \u0026#34;end_offset\u0026#34; : 2, \u0026#34;type\u0026#34; : \u0026#34;CN_WORD\u0026#34;, \u0026#34;position\u0026#34; : 0 }, { \u0026#34;token\u0026#34; : \u0026#34;使用\u0026#34;, \u0026#34;start_offset\u0026#34; : 2, \u0026#34;end_offset\u0026#34; : 4, \u0026#34;type\u0026#34; : \u0026#34;CN_WORD\u0026#34;, \u0026#34;position\u0026#34; : 1 }, { \u0026#34;token\u0026#34; : \u0026#34;elasticsearch\u0026#34;, \u0026#34;start_offset\u0026#34; : 5, \u0026#34;end_offset\u0026#34; : 18, \u0026#34;type\u0026#34; : \u0026#34;ENGLISH\u0026#34;, \u0026#34;position\u0026#34; : 2 } ] } 该例两种分词模式结果相同，可使用其他更长语句测试结果\n拓展词库 随着互联网发展，会不断涌现新词语，在原有的词汇列表中并不存在，所以词汇列表也需要不断更新。若拓展 IK 词库，只需要修改 ik 目录 config 目录中的 IKAnalyzer.cfg.xml 文件即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE properties SYSTEM \u0026#34;http://java.sun.com/dtd/properties.dtd\u0026#34;\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;comment\u0026gt;IK Analyzer 扩展配置\u0026lt;/comment\u0026gt; \u0026lt;!--用户可以在这里配置自己的扩展字典 --\u0026gt; \u0026lt;entry key=\u0026#34;ext_dict\u0026#34;\u0026gt;ext.dic\u0026lt;/entry\u0026gt; \u0026lt;!--用户可以在这里配置自己的扩展停止词字典--\u0026gt; \u0026lt;entry key=\u0026#34;ext_stopwords\u0026#34;\u0026gt;stopwords.dic\u0026lt;/entry\u0026gt; \u0026lt;!--用户可以在这里配置远程扩展字典 --\u0026gt; \u0026lt;!-- \u0026lt;entry key=\u0026#34;remote_ext_dict\u0026#34;\u0026gt;words_location\u0026lt;/entry\u0026gt; --\u0026gt; \u0026lt;!--用户可以在这里配置远程扩展停止词字典--\u0026gt; \u0026lt;!-- \u0026lt;entry key=\u0026#34;remote_ext_stopwords\u0026#34;\u0026gt;words_location\u0026lt;/entry\u0026gt; --\u0026gt; \u0026lt;/properties\u0026gt; 如上将拓展词放在 ./ext.dic，禁止词放在 ./stopwords.dic\n禁止词可以放一些无意义的词，如 的、啊 等\n配置好后重启 es\nDSL 索引库操作 索引库就类似数据库表，要向 es 中存储数据，必须先创建“库”和“表”\nmapping 映射属性 mapping 是对索引库中文档的约束，常见的 mapping 属性包括：\ntype：字段数据类型，常见的简单类型有： 字符串：text（可分词的文本）、keyword（精确值，例如：品牌、国家、ip地址） 数值：long、integer、short、byte、double、float、 布尔：boolean 日期：date 对象：object index：是否创建索引，默认为true analyzer：使用哪种分词器 properties：该字段的子字段 创建索引库 请求方式：PUT 请求路径：/索引库名，可以自定义 请求参数：mapping 映射 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 PUT /索引库名称 { \u0026#34;mappings\u0026#34;: { \u0026#34;properties\u0026#34;: { \u0026#34;字段名\u0026#34;:{ \u0026#34;type\u0026#34;: \u0026#34;text\u0026#34;, \u0026#34;analyzer\u0026#34;: \u0026#34;ik_smart\u0026#34; }, \u0026#34;字段名2\u0026#34;:{ \u0026#34;type\u0026#34;: \u0026#34;keyword\u0026#34;, \u0026#34;index\u0026#34;: \u0026#34;false\u0026#34; }, \u0026#34;字段名3\u0026#34;:{ \u0026#34;properties\u0026#34;: { \u0026#34;子字段\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;keyword\u0026#34; } } }, // code } } } 例如\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 # 创建索引库 PUT /hello { \u0026#34;mappings\u0026#34;: { \u0026#34;properties\u0026#34;: { \u0026#34;info\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;text\u0026#34;, \u0026#34;analyzer\u0026#34;: \u0026#34;ik_smart\u0026#34; }, \u0026#34;email\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;keyword\u0026#34;, \u0026#34;index\u0026#34;: false }, \u0026#34;name\u0026#34;: { \u0026#34;properties\u0026#34;: { \u0026#34;firstName\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;keyword\u0026#34; }, \u0026#34;lastName\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;keyword\u0026#34; } } } } } } 运行后返回类似即成功\n1 2 3 4 5 { \u0026#34;acknowledged\u0026#34; : true, \u0026#34;shards_acknowledged\u0026#34; : true, \u0026#34;index\u0026#34; : \u0026#34;hello\u0026#34; } 查询索引库 请求方式：GET\n请求路径：/索引库名\n请求参数：无\n格式\n1 GET /索引库名 例如\n1 2 # 查看索引库 GET /hello 结果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 { \u0026#34;hello\u0026#34; : { \u0026#34;aliases\u0026#34; : { }, \u0026#34;mappings\u0026#34; : { \u0026#34;properties\u0026#34; : { \u0026#34;email\u0026#34; : { \u0026#34;type\u0026#34; : \u0026#34;keyword\u0026#34;, \u0026#34;index\u0026#34; : false }, \u0026#34;info\u0026#34; : { \u0026#34;type\u0026#34; : \u0026#34;text\u0026#34;, \u0026#34;analyzer\u0026#34; : \u0026#34;ik_smart\u0026#34; }, \u0026#34;name\u0026#34; : { \u0026#34;properties\u0026#34; : { \u0026#34;firstName\u0026#34; : { \u0026#34;type\u0026#34; : \u0026#34;keyword\u0026#34; }, \u0026#34;lastName\u0026#34; : { \u0026#34;type\u0026#34; : \u0026#34;keyword\u0026#34; } } } } }, \u0026#34;settings\u0026#34; : { \u0026#34;index\u0026#34; : { \u0026#34;routing\u0026#34; : { \u0026#34;allocation\u0026#34; : { \u0026#34;include\u0026#34; : { \u0026#34;_tier_preference\u0026#34; : \u0026#34;data_content\u0026#34; } } }, \u0026#34;number_of_shards\u0026#34; : \u0026#34;1\u0026#34;, \u0026#34;blocks\u0026#34; : { \u0026#34;read_only_allow_delete\u0026#34; : \u0026#34;true\u0026#34; }, \u0026#34;provided_name\u0026#34; : \u0026#34;hello\u0026#34;, \u0026#34;creation_date\u0026#34; : \u0026#34;1703683379263\u0026#34;, \u0026#34;number_of_replicas\u0026#34; : \u0026#34;1\u0026#34;, \u0026#34;uuid\u0026#34; : \u0026#34;zn-kPdsETZeFcB0nXK79hg\u0026#34;, \u0026#34;version\u0026#34; : { \u0026#34;created\u0026#34; : \u0026#34;7120199\u0026#34; } } } } } 修改索引库 索引库和 mapping 一旦创建，不允许修改，但可以添加字段\n1 2 3 4 5 6 7 8 PUT /索引库名/_mapping { \u0026#34;properties\u0026#34;: { \u0026#34;新字段名\u0026#34;:{ \u0026#34;type\u0026#34;: \u0026#34;integer\u0026#34; } } } 例如\n1 2 3 4 5 6 7 8 9 10 # 新加字段 PUT /hello/_mapping { \u0026#34;properties\u0026#34;: { \u0026#34;age\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;integer\u0026#34;, \u0026#34;index\u0026#34;: false } } } 如果遇到 read-only-allow-delete 类似错误，产生原因为磁盘剩余空间不足 5%，可用以下请求解决\n1 2 3 4 5 6 7 8 PUT _settings { \u0026#34;index\u0026#34;: { \u0026#34;blocks\u0026#34;: { \u0026#34;read_only_allow_delete\u0026#34;: \u0026#34;false\u0026#34; } } } 删除索引库 请求方式：DELETE\n请求路径：/索引库名\n请求参数：无\n格式\n1 DELETE /索引库名 例如\n1 DELETE /hello 结果\n1 2 3 { \u0026#34;acknowledged\u0026#34; : true } 索引库操作总结 创建索引库：PUT /索引库名 查询索引库：GET /索引库名 删除索引库：DELETE /索引库名 添加字段：PUT /索引库名/_mapping DSL 文档操作 新增文档 1 2 3 4 5 6 7 8 9 10 POST /索引库名/_doc/文档id { \u0026#34;字段1\u0026#34;: \u0026#34;值1\u0026#34;, \u0026#34;字段2\u0026#34;: \u0026#34;值2\u0026#34;, \u0026#34;字段3\u0026#34;: { \u0026#34;子属性1\u0026#34;: \u0026#34;值3\u0026#34;, \u0026#34;子属性2\u0026#34;: \u0026#34;值4\u0026#34; }, // code } 例子\n1 2 3 4 5 6 7 8 9 10 # 添加文档 PUT /hello/_doc/1 { \u0026#34;info\u0026#34;: \u0026#34;hello es\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;blog@yexca.net\u0026#34;, \u0026#34;name\u0026#34;: { \u0026#34;firstName\u0026#34;: \u0026#34;yexca\u0026#34;, \u0026#34;lastName\u0026#34;: \u0026#34;Dale\u0026#34; } } 结果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 { \u0026#34;_index\u0026#34; : \u0026#34;hello\u0026#34;, \u0026#34;_type\u0026#34; : \u0026#34;_doc\u0026#34;, \u0026#34;_id\u0026#34; : \u0026#34;1\u0026#34;, \u0026#34;_version\u0026#34; : 1, \u0026#34;result\u0026#34; : \u0026#34;created\u0026#34;, \u0026#34;_shards\u0026#34; : { \u0026#34;total\u0026#34; : 2, \u0026#34;successful\u0026#34; : 1, \u0026#34;failed\u0026#34; : 0 }, \u0026#34;_seq_no\u0026#34; : 0, \u0026#34;_primary_term\u0026#34; : 1 } 查询文档 1 GET /{索引库名称}/_doc/{id} 例子\n1 2 # 查询文档 GEt /hello/_doc/1 结果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 { \u0026#34;_index\u0026#34; : \u0026#34;hello\u0026#34;, \u0026#34;_type\u0026#34; : \u0026#34;_doc\u0026#34;, \u0026#34;_id\u0026#34; : \u0026#34;1\u0026#34;, \u0026#34;_version\u0026#34; : 1, \u0026#34;_seq_no\u0026#34; : 0, \u0026#34;_primary_term\u0026#34; : 1, \u0026#34;found\u0026#34; : true, \u0026#34;_source\u0026#34; : { \u0026#34;info\u0026#34; : \u0026#34;hello es\u0026#34;, \u0026#34;email\u0026#34; : \u0026#34;blog@yexca.net\u0026#34;, \u0026#34;name\u0026#34; : { \u0026#34;firstName\u0026#34; : \u0026#34;yexca\u0026#34;, \u0026#34;lastName\u0026#34; : \u0026#34;Dale\u0026#34; } } } 修改文档 修改有两种方式，全量修改与增量修改\n全量修改 全量修改是覆盖原来的文档，其本质是：\n根据指定的 id 删除文档 新增一个相同 id 的文档 如果 id 不存在，也会执行第二步，也就从修改变成新增了 (覆盖写)\n1 2 3 4 5 6 PUT /{索引库名}/_doc/文档id { \u0026#34;字段1\u0026#34;: \u0026#34;值1\u0026#34;, \u0026#34;字段2\u0026#34;: \u0026#34;值2\u0026#34;, // code } 例如\n1 2 3 4 5 6 7 8 9 10 # 修改-全量修改 PUT /hello/_doc/1 { \u0026#34;info\u0026#34;: \u0026#34;hello es\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;es@yexca.net\u0026#34;, \u0026#34;name\u0026#34;: { \u0026#34;firstName\u0026#34;: \u0026#34;yexca\u0026#34;, \u0026#34;lastName\u0026#34;: \u0026#34;Dale\u0026#34; } } 结果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 { \u0026#34;_index\u0026#34; : \u0026#34;hello\u0026#34;, \u0026#34;_type\u0026#34; : \u0026#34;_doc\u0026#34;, \u0026#34;_id\u0026#34; : \u0026#34;1\u0026#34;, \u0026#34;_version\u0026#34; : 2, \u0026#34;result\u0026#34; : \u0026#34;updated\u0026#34;, \u0026#34;_shards\u0026#34; : { \u0026#34;total\u0026#34; : 2, \u0026#34;successful\u0026#34; : 1, \u0026#34;failed\u0026#34; : 0 }, \u0026#34;_seq_no\u0026#34; : 1, \u0026#34;_primary_term\u0026#34; : 1 } 查询可发现邮箱已经修改\n增量修改 增量修改是只修改指定 id 匹配的文档中的部分字段\n1 2 3 4 5 6 POST /{索引库名}/_update/文档id { \u0026#34;doc\u0026#34;: { \u0026#34;字段名\u0026#34;: \u0026#34;新的值\u0026#34;, } } 例如\n1 2 3 4 5 6 7 # 修改-增量修改 POST /hello/_update/1 { \u0026#34;doc\u0026#34;: { \u0026#34;email\u0026#34;: \u0026#34;blog@yexca.net\u0026#34; } } 结果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 { \u0026#34;_index\u0026#34; : \u0026#34;hello\u0026#34;, \u0026#34;_type\u0026#34; : \u0026#34;_doc\u0026#34;, \u0026#34;_id\u0026#34; : \u0026#34;1\u0026#34;, \u0026#34;_version\u0026#34; : 3, \u0026#34;result\u0026#34; : \u0026#34;updated\u0026#34;, \u0026#34;_shards\u0026#34; : { \u0026#34;total\u0026#34; : 2, \u0026#34;successful\u0026#34; : 1, \u0026#34;failed\u0026#34; : 0 }, \u0026#34;_seq_no\u0026#34; : 2, \u0026#34;_primary_term\u0026#34; : 1 } 查询可发现邮箱已经修改\n删除文档 1 DELETE /{索引库名}/_doc/id值 例如\n1 2 # 删除文档 DELETE /hello/_doc/1 结果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 { \u0026#34;_index\u0026#34; : \u0026#34;hello\u0026#34;, \u0026#34;_type\u0026#34; : \u0026#34;_doc\u0026#34;, \u0026#34;_id\u0026#34; : \u0026#34;1\u0026#34;, // 因为中间我修改了其他的，版本号变高了 \u0026#34;_version\u0026#34; : 8, \u0026#34;result\u0026#34; : \u0026#34;deleted\u0026#34;, \u0026#34;_shards\u0026#34; : { \u0026#34;total\u0026#34; : 2, \u0026#34;successful\u0026#34; : 1, \u0026#34;failed\u0026#34; : 0 }, \u0026#34;_seq_no\u0026#34; : 7, \u0026#34;_primary_term\u0026#34; : 1 } 文档操作总结 创建文档：POST /{索引库名}/_doc/文档id { json文档 } 查询文档：GET /{索引库名}/_doc/文档id 删除文档：DELETE /{索引库名}/_doc/文档id 修改文档： 全量修改：PUT /{索引库名}/_doc/文档id { json文档 } 增量修改：POST /{索引库名}/_update/文档id { \u0026ldquo;doc\u0026rdquo;: {字段}} ","date":"2025-01-29T23:38:51+09:00","permalink":"https://blog.yexca.net/archives/226/","title":"Elasticsearch 入门"},{"content":" Redis 基础: https://blog.yexca.net/archives/157/ Redis 分布式缓存: 本文\n引言 所以这俩文章同时写的但却过了一年才发是吧\n其实是我当时有三个要写的来着，但每次想起来看的时候都忘了要写啥，就过了快一年。。。\n问题 单机 Redis 存在\n数据丢失问题：实现 Redis 数据持久化 并发能力问题：搭建主从集群，实现读写分离 存储能力问题：搭建分片集群，利用插槽机制实现动态扩容 故障恢复问题：利用 Redis 哨兵，实现健康检测和自动恢复 Redis 持久化 Redis 持久化有两种方案：RDB 与 AOF\nRDB 持久化 RDB 全称 Redis Database Backup file (Redis 数据备份文件)，也叫做 Redis 数据快照。简单来说就是把内存中所有数据都记录到磁盘中。当 Redis 实例故障重启后，从磁盘读取快照文件，恢复数据。快照文件成为 RDB 文件，默认保存在运行目录\nRDB 会在以下四种情况下执行：\n执行 save 命令：立即执行，会导致主进程执行 RDB，其他所有命令被阻塞。仅在数据迁移时可能用到 执行 bgsave 命令：异步执行，开启独立进程完成 RDB，主进程可以持续处理用户请求，不受影响 Redis 停机时：停机时会执行一次 save 命令 触发 RDB 条件时：配置文件配置，如下 1 2 3 4 # 900秒内，如果至少有1个key被修改，则执行bgsave ， 如果是save \u0026#34;\u0026#34; 则表示禁用RDB save 900 1 save 300 10 save 60 10000 其他配置\n1 2 3 4 5 6 7 8 # 是否压缩 ,建议不开启，压缩也会消耗cpu，磁盘的话不值钱 rdbcompression yes # RDB文件名称 dbfilename dump.rdb # 文件保存的路径目录 dir ./ RDB 原理 bgsave 开始时会 fork 主进程得到子进程，子进程共享主进程的内存数据。完成 fork 后读取内存数据并写入 RDB 文件\nfork采用的是 copy-on-write 技术：\n当主进程执行读操作时，访问共享内存 当主进程执行写操作时，则会拷贝一份数据，执行写操作 RDB 的缺点：\n执行间隔时间长，两次 RDB 之间写入数据有丢失的风险 fork 子进程、压缩、写出 RDB 文件都比较耗时 AOF 持久化 AOF 全称 Append Only File (追加文件)，Redis 处理的每一个写命令都会记录在 AOF 文件，可以看作命令日志文件\nAOF 默认是关闭的，修改配置文件开启\n1 2 3 4 # 是否开启AOF功能，默认是no appendonly yes # AOF文件的名称 appendfilename \u0026#34;appendonly.aof\u0026#34; 记录频率也可以通过 redis.conf 配置\n1 2 3 4 5 6 # 表示每执行一次写命令，立即记录到AOF文件 appendfsync always # 写命令执行完先放入AOF缓冲区，然后表示每隔1秒将缓冲区数据写到AOF文件，是默认方案 appendfsync everysec # 写命令执行完先放入AOF缓冲区，由操作系统决定何时将缓冲区内容写回磁盘 appendfsync no 配置项对比：\n配置项 刷盘时机 优点 缺点 always 同步刷盘 可靠性高，几乎不丢数据 性能影响大 everysec 每秒刷盘 性能适中 最多丢失 1 秒数据 no 操作系统控制 性能最好 可靠性差，可能丢失大量数据 文件重写 因为是记录命令，AOF 文件会比 RDB 大很多，而且 AOF 会记录对同一个 key 的多次写操作，但只有最后一次写操作才有意义。通过执行 bgrewriteaof 命令，可以让 AOF 文件执行重写功能，用最少的命令达到相同效果\n假设原先命令为：\n1 2 3 set num 123 set name jack set num 666 重写后：\n1 mset name jack num 666 Redis 也会在触发阈值时自动重写 AOF 文件，在配置文件配置\n1 2 3 4 # AOF文件比上次文件 增长超过多少百分比则触发重写 auto-aof-rewrite-percentage 100 # AOF文件体积最小多大以上才触发重写 auto-aof-rewrite-min-size 64mb RDB 与 AOF 对比 RDB 与 AOF 各有自己的优缺点，如果对数据安全性要求过高，在实际开发中往往会结合两者来使用\nRDB AOF 持久化方式 定时对整个内存做快照 记录每一次执行的命令 数据完整性 不完整，两次备份之间会丢失 相对完整，取决于刷盘策略 文件大小 会有压缩，文件体积小 记录命令，文件体积很大 宕机恢复优先级 很快 慢 数据恢复优先级 低，因为数据完整性不如 AOF 高，因为数据完整性更高 系统资源占用 高，大量 CPU 和内存消耗 低，主要是磁盘 I0 资源\n但 AOF 重写时会占用大量 CPU 和内存资源 使用场景 可以容忍数分钟的数据丢失，追求更快的启动速度 对数据安全性要求较高常见 Redis 主从架构 单节点 Redis 的并发能力是有上限的，要进一步提高 Redis 的并发能力，就需要搭建主从集群，实现读写分离\n按照集群 基于 CentOS7\n参考上图一共三个节点，部署在同一个机子，端口为 7001(master)、7002、7003\n首先创建目录\n1 2 cd /tmp mkdir 7001 7002 7003 如更改配置，需恢复默认的 RDB 模式\n1 2 3 4 5 6 7 8 # 开启RDB # save \u0026#34;\u0026#34; save 3600 1 save 300 100 save 60 10000 # 关闭AOF appendonly no 拷贝配置文件到每个实例目录\n1 2 3 4 5 6 7 # 方式一 cp redis-6.2.4/redis.conf 7001 cp redis-6.2.4/redis.conf 7002 cp redis-6.2.4/redis.conf 7003 # 方式二 echo 7001 7002 7003 | xargs -t -n 1 cp redis-6.2.4/redis.conf 修改每个实例的端口，工作目录（端口修改，rdb 文件保存位置修改）\n1 2 3 sed -i -e \u0026#39;s/6379/7001/g\u0026#39; -e \u0026#39;s/dir .\\//dir \\/tmp\\/7001\\//g\u0026#39; 7001/redis.conf sed -i -e \u0026#39;s/6379/7002/g\u0026#39; -e \u0026#39;s/dir .\\//dir \\/tmp\\/7002\\//g\u0026#39; 7002/redis.conf sed -i -e \u0026#39;s/6379/7003/g\u0026#39; -e \u0026#39;s/dir .\\//dir \\/tmp\\/7003\\//g\u0026#39; 7003/redis.conf 修改 IP，每个目录都要改 (替换 ip_address)\n1 2 3 4 5 6 7 # 逐一执行 sed -i \u0026#39;1a replica-announce-ip ip_address\u0026#39; 7001/redis.conf sed -i \u0026#39;1a replica-announce-ip ip_address\u0026#39; 7002/redis.conf sed -i \u0026#39;1a replica-announce-ip ip_address\u0026#39; 7003/redis.conf # 或者一键修改 printf \u0026#39;%s\\n\u0026#39; 7001 7002 7003 | xargs -I{} -t sed -i \u0026#39;1a replica-announce-ip ip_address\u0026#39; {}/redis.conf 启动\n1 2 3 4 5 6 # 第1个 redis-server 7001/redis.conf # 第2个 redis-server 7002/redis.conf # 第3个 redis-server 7003/redis.conf 停止\n1 printf \u0026#39;%s\\n\u0026#39; 7001 7002 7003 | xargs -I{} -t redis-cli -p {} shutdown ","date":"2025-01-28T21:47:19+09:00","permalink":"https://blog.yexca.net/archives/225/","title":"Redis 分布式缓存"},{"content":" 音有所感系列 歌曲名 翻译 链接 僕が死のうと思ったのは 曾经我也想过一了百了 https://blog.yexca.net/archives/214 あくあ色ぱれっと aqua 的调色盘 https://blog.yexca.net/archives/219 恋の押し売り 恋爱推销 https://blog.yexca.net/archives/220 17さいのうた 17 岁的歌 本文 drop 坠入爱河 https://blog.yexca.net/archives/230 生きるを選んだ私へ 致选择活下去的自己 https://blog.yexca.net/archives/239 rainy lady 雨意未晴 https://blog.yexca.net/archives/249 恋しくなったら手を叩こう 想谈恋爱的话就拍拍手吧 https://blog.yexca.net/archives/250 引言 本来只是可以听懂对自己的信的部分，觉得挺符合第一次听到的我，于是一直听着来着\n开始去尝试翻译这首歌的时候，再加上最近的经历，我感觉我现在貌似和 ユイカ 当时状态很像啊，我现在的样子就和这首歌一样，只有迷茫，成为什么样的人呢，未来是什么样子呢，我该走向何方呢\n正能量一点，向歌词那样，尝试接受自己吧，离开自己的迷茫，随便找一个感觉喜欢的事情做吧\n最后也感谢鼓励着我的人，以及嘴上不鼓励，行动上支持我的人\n2025.01.27 唱了这首歌，但是没拍照，因为不是原视频，拍照没意义感觉\n因为和自己心态类似，所以唱的时候很有那种对于未来迷茫的感觉，说出来，或者说唱出来使得心情很复杂，不过是很棒的体验\n2025.05.26 又唱了。不过随便拍了张，联想到自身成长，确实很奇妙的歌\n歌曲视频 歌词 こんな私の未み熟じゅくなうたを　聴いてくれてどうも有難うね\n感谢你来听我还很青涩的歌\nもう少しで私は未熟な大人に　なるみたいです\n再过不久，我好像也要变成不成熟的大人了\nなんか笑っちゃうね\n总觉得有点好笑呢\n本当はね\n其实啊\nもっと前を向けるようなうたを　書くつもりだったけど\n本打算写更加让人积极的歌\n書けなくて\n却怎么也写不出来\n私はまだ　他の誰かを支えられるほど\n我还没有达到可以支撑别人的存在\n強くなかったみたい　ごめんね\n看起来并不怎么要强真是抱歉呐\n拝啓　未来の私へ　今そこで\n敬启，未来的我啊，现在在那里\nどんなことをして　生きていますか\n正做着什么样的事情，过着什么样的生活呢\n拝啓　今の私へ　今ここで\n敬启，现在的我啊，现在在此刻\nどんなことをしたら　生きていけるんでしょうか\n我该做些什么，才可以继续活下去呢\n\u0026ldquo;好きだからかっこいい\u0026quot;とか　\u0026ldquo;そばにいる\u0026quot;とか\n曾经写过 “因为喜欢才觉得帅”、“想要待在身边”\n\u0026ldquo;勝手に盗んだ\u0026quot;とか　書いてた\n还有 “随便就偷走你的心” 之类的\nどうせだったらもうちょっと　貴方みたいに\n这样的话，不如再向你\nやさしいうたを書けばよかったね\n写首温暖的歌就好了呢\n本当はね　好きなことだけして生きたいの\n其实啊，我只想做喜欢的事情呐\nでもそれは上手な生き方とは言えないから\n但那称不上成熟的活法\n無駄になっても　意味がなくても\n即使显得徒劳，毫无意义\n今はここから　離れなきゃいけないの　ごめんね\n现在还是不得不离开了，抱歉呐\n拝啓　未来の私へ　今そこで\n敬启，向未来的我，现在在那里\nどんな大人になって　生きていますか\n变成了什么样的大人，过着什么样的生活呢\n拝啓　今の私へ　今ここで\n敬启，向现在的我，此刻在这里\nどんな大人になりたいと　言えばいいんでしょうか\n说出 “想要成为什么样的大人” 可以吗\n「さよなら」は悲しくなるからさ\n“再见” 听起来太悲伤了\n「またね」って言わせて\n请让我说 “下次见” 吧\nいつか私が　今みたいな　うたを書けなくなっても\n就算未来哪天我写不出来这样的歌了\n怒らないでね\n也请不要怪我\n拝啓　過去の私へ　今の私は\n敬启，向过去的我，现在的我啊\nずっと夢見ていたこと叶えてるよ\n实现了一直以来的梦想哟\n拝啓　今の私へ\n敬启，向现在的我\nこんな情なさけない　うただって歌えばいいよ\n唱出这么软弱的歌也可以哟\nそれが私だから\n因为那就是我\n拝啓　未来の私へ　今そこは\n敬启，未来的我啊，现在在那里\nどんな綺麗な世界が　広がっていますか\n展开着怎样绚丽多彩的世界呢\n拝啓　今の私へ　今ここが\n敬启，现在的我啊，现在的时刻\nどんな世界よりも　幸せでした\n比任何世界都要幸福呀\nこんな私の未熟なうたを　聴いてくれてどうも有難うね\n感谢你来听我还很青涩的歌\nこれから私は未熟な大人に　なる準備をします\n接下来我也要为成为不够成熟的大人，而好好准备\n「じゃあ またね」\n“那么，下次见”\n","date":"2025-01-25T16:57:49+09:00","permalink":"https://blog.yexca.net/archives/224/","title":"音有所感 - 《17さいのうた》"},{"content":"配置 yaml、yml、properties 文件都可以配置，还可以通过 Java 系统属性和命令行参数\n优先级：命令行参数 \u0026gt; Java 系统属性 \u0026gt; properties \u0026gt; yml \u0026gt; yaml\n命令行使用，需要首先运行 Maven 的打包指令，然后在命令行运行\n1 2 3 4 5 java -jar path_to_jar.jar # Java 系统属性，端口为例 java -Dserver.port=9000 -jar path_to_jar.jar # 命令行参数，端口为例 java -jar path_to_jar.jar --server.port=9000 SpringBoot 项目打包时需要引入插件 spring-boot-maven-plugin (基于官网骨架创建项目，会自动添加该插件)\nBean 管理 获取 bean 对于默认的单例非延迟加载的 bean 而言，Spring 项目启动时，会把 bean 都创建好放在 IOC 容器中 (如加上 @Lazy 注解将会在第一次被使用时实例化)\n如果想主动获取这些 bean，可以通过如下方式\n根据 name 获取 1 Object getBean(String name) 根据类型获取 1 \u0026lt;T\u0026gt; T getBean(Class\u0026lt;T\u0026gt; requiredType) 根据 name 和类型获取 (类型转换) 1 \u0026lt;T\u0026gt; T getBean(String name, Class\u0026lt;T\u0026gt; requiredType) 为了使用该方法，需要先获取 IOC 容器对象\n1 2 3 4 5 6 7 8 9 10 11 12 13 @Autowired private ApplicationContext applicationContext; //IOC容器对象 public void testGetBean(){ // 根据bean的名称获取 DeptController beanl = (DeptController) applicationContext.getBean(\u0026#34;deptController\u0026#34;); // 根据bean的类型获取 DeptController bean2 = applicationContext.getBean(DeptController.class); // 根据bean的名称及类型获取 DeptController bean3 = applicationContext.getBean(\u0026#34;deptController\u0026#34;, DeptController.class); } bean 作用域 Spring 支持五种作用域，后三种在 web 环境才生效\n作用域 描述 singleton 容器内同名称的 bean 只有一个实例 (单例) prototype 每次使用该 bean 时会创建新的实例 (非单例) request 每个请求范围内会创建新的实例 session 每个会话范围内会创建新的实例 application 每个应用范围内会创建新的实例 使用注解 @Scope 设置作用域\n1 2 3 4 5 6 // 设置非单例 @Scope(\u0026#34;prototype\u0026#34;) @RestController public class xxxController{ } 实际开发当中，绝大部分的 Bean 是单例的，也就是说绝大部分 Bean 不需要配置 scope 属性\n第三方 Bean 如果要管理的 bean 对象来自于第三方 (不是自定义的)，是无法用 @Component 及衍生注解声明 bean 的，就需要用到 @Bean 注解。例如解析 XML 文件的 dom4j\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.dom4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;dom4j\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.1.3\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 依赖如上\n1 2 3 4 5 6 7 @SpringBootApplication public class xxxApplication{ @Bean // 将方法返回值交给IOC容器管理,成为IOC容器的bean对象 public SAXReader saxReader(){ return new SAXReader; } } 不过若要管理的第三方 bean 对象，建议对这些 bean 进行集中分类配置，可以通过 @Configuration 注解声明一个配置类\n1 2 3 4 5 6 7 @Configuration public class CommonConfig { @Bean public SAXReader saxReader(){ return new SAXReader; } } 通过 @Bean 注解的 name 或 value 属性可以声明 bean 的名称，如果不指定，默认 bean 的名称就是方法名。如果第三方 bean 需要依赖其它 bean 对象，直接在 bean 定义方法中设置形参即可，容器会根据类型自动装配\n1 2 3 4 5 6 7 @Configuration public class CommonConfig { @Bean public SAXReader saxReader(XxService xxService){ return new SAXReader; } } 起步依赖 在开发中若直接使用 Spring 需要引入相关依赖，并且保证版本匹配，而使用 SpringBoot 则只需要引入起步依赖依赖即可。原理是 Maven 的传递依赖，其他的依赖都会自动的通过 Maven 的依赖传递进来\n自动配置 SpringBoot 的自动配置就是当 Spring 容器启动后，一些配置类、bean 对象就自动存入到了 IOC 容器中，不需要我们手动去声明，从而简化了开发，省去了繁琐的配置操作\n配置类 @Configuration 的底层是 @Component，也是容器中一个 bean 对象\n在引入依赖之后是如何将依赖 jar 包当中所定义的配置类以及 bean 加载到 SpringIOC 容器中的\n@ComponentScan 使用 @ComponentScan 可以指定要扫描的包，例如依赖导入了 com.example 包\n1 2 @SpringBootApplication @ComponentScan({\u0026#34;net.yexca\u0026#34;,\u0026#34;com.example\u0026#34;}) 不过当需要引入大量的第三方的依赖，上方要配置大量的包，而大面积的扫描性能也比较低\n@Import 可以导入普通类、配置类以及 ImportSelector 接口实现类\n普通类 1 2 @Import(TokenParser.class) //导入普通类 @SpringBootApplication 配置类 配置类内容\n1 2 3 4 5 6 7 8 9 10 11 12 @Configuration public class HeaderConfig { @Bean public HeaderParser headerParser(){ return new HeaderParser(); } @Bean public HeaderGenerator headerGenerator(){ return new HeaderGenerator(); } } 启动类\n1 2 @Import(HeaderConfig.class) //导入配置类 @SpringBootApplication ImportSelector 接口实现类 ImportSelector 接口实现类内容\n1 2 3 4 5 6 public class MyImportSelector implements ImportSelector { public String[] selectImports(AnnotationMetadata importingClassMetadata) { //返回值字符串数组（数组中封装了全限定名称的类） return new String[]{\u0026#34;com.example.HeaderConfig\u0026#34;}; } } 启动类\n1 2 @Import(MyImportSelector.class) //导入ImportSelector接口实现类 @SpringBootApplication @EnableXxxxx 上述 @Import 需要首先知道第三方依赖中有哪些配置类或 bean 才可，而第三方依赖可以提供 @EnableXxxxx 注解，封装 @Import 注解提供一些常用 bean，使用时只需要 @EnableXxxxx 注解即可\n如上述 @Import 的配置类，封装一个 @EnableHeaderConfig 注解\n1 2 3 4 5 @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.TYPE) @Import(MyImportSelector.class)//指定要导入哪些bean对象或配置类 public @interface EnableHeaderConfig { } 然后只需要在启动类加上 @EnableHeaderConfig 注解即可导入相应 bean\n1 2 @EnableHeaderConfig //使用第三方依赖提供的Enable开头的注解 @SpringBootApplication 此方法也是 SpringBoot 所采用的方式\nSpringBoot 的自动配置 在 @SpringBootApplication 注解里有 @EnableAutoConfiguration，其中 @Import({AutoConfigurationImportSelector.class}) 导入了 ImportSelector 接口的实现类 AutoConfigurationImportSelector.class\n在该实现类中重写了 selectImports() 方法\n1 2 3 4 5 6 7 8 9 public String[] selectImports(AnnotationMetadata annotationMetadata) { if (!this.isEnabled(annotationMetadata)) { return NO_IMPORTS; } else { // 获取自动配置的配置类信息集合 AutoConfigurationEntry autoConfigurationEntry = this.getAutoConfigurationEntry(annotationMetadata); return StringUtils.toStringArray(autoConfigurationEntry.getConfigurations()); } } 调用 getAutoConfigurationEntry() 方法获取了自动配置的配置类信息集合\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 protected AutoConfigurationEntry getAutoConfigurationEntry(AnnotationMetadata annotationMetadata) { if (!this.isEnabled(annotationMetadata)) { return EMPTY_ENTRY; } else { AnnotationAttributes attributes = this.getAttributes(annotationMetadata); // 获取在配置文件中配置的所有自动配置类的集合 List\u0026lt;String\u0026gt; configurations = this.getCandidateConfigurations(annotationMetadata, attributes); configurations = this.removeDuplicates(configurations); Set\u0026lt;String\u0026gt; exclusions = this.getExclusions(annotationMetadata, attributes); this.checkExcludedClasses(configurations, exclusions); configurations.removeAll(exclusions); configurations = this.getConfigurationClassFilter().filter(configurations); this.fireAutoConfigurationImportEvents(configurations, exclusions); return new AutoConfigurationEntry(configurations, exclusions); } } 其中 getCandidateConfigurations(annotationMetadata, attributes) 方法获取在配置文件中配置的所有自动配置类的集合\n1 2 3 4 5 6 protected List\u0026lt;String\u0026gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) { List\u0026lt;String\u0026gt; configurations = new ArrayList(SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader())); ImportCandidates.load(AutoConfiguration.class, this.getBeanClassLoader()).forEach(configurations::add); Assert.notEmpty(configurations, \u0026#34;No auto configuration classes found in META-INF/spring.factories nor in META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports. If you are using a custom packaging, make sure that file is correct.\u0026#34;); return configurations; } 可以看到是获取 META-INF/spring.factories 和 META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports 文件中配置类的集合\n上述俩文件通常在引入的起步依赖中\n也就是说当 SpringBoot 程序启动时，就会加载配置文件当中所定义的配置类，并将这些配置类信息 (类的全限定名) 封装到 String 类型的数组中，最终通过 @Import 注解将这些配置类全部加载到 Spring 的 IOC 容器中，交给 IOC 容器管理\n@Conditional 可文件中的配置类那么多，每个 bean 都会注册到 IOC 容器中吗。并不是，使用 @Conditional 注解可以使得 bean 对象按照条件进行装配\n@Conditional 是一个父注解，有许多子注解\n@ConditionalOnClass 判断环境中有对应字节码文件，才注册 bean 到 IOC 容器\n1 2 3 4 5 6 7 8 9 10 11 @Configuration public class HeaderConfig { @Bean //环境中存在指定的这个类，才会将该bean加入IOC容器 @ConditionalOnClass(name=\u0026#34;io.jsonwebtoken.Jwts\u0026#34;) public HeaderParser headerParser(){ return new HeaderParser(); } } 上述 bean 需要引入 jwt 令牌的依赖才会注入到 IOC 容器中\n1 2 3 4 5 6 \u0026lt;!--JWT令牌--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.jsonwebtoken\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jjwt\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.9.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 测试\n1 2 3 4 5 6 7 8 9 10 11 @SpringBootTest public class AutoConfigurationTests { @Autowired private ApplicationContext applicationContext; @Test public void testHeaderParser(){ System.out.println(applicationContext.getBean(HeaderParser.class)); } } @ConditionalOnMissingBean 判断环境中没有对应的 bean (类型或名称)，才注册 bean 到 IOC 容器\n1 2 3 4 5 6 7 8 9 10 @Configuration public class HeaderConfig { @Bean @ConditionalOnMissingBean //不存在该类型的bean，才会将该bean加入IOC容器 public HeaderParser headerParser(){ return new HeaderParser(); } } 上述当 IOC 中没有 HeaderConfig 类型的 bean 才会创建\n也可以在注解中指定其他 bean 名字\n1 2 3 4 5 6 7 8 9 10 11 @Configuration public class HeaderConfig { @Bean //不存在指定名称的bean，才会将该bean加入IOC容器 @ConditionalOnMissingBean(name=\u0026#34;deptController2\u0026#34;) public HeaderParser headerParser(){ return new HeaderParser(); } } 上例在不存在名字为 deptController2 的 bean 对象才会创建 HeaderConfig 对象注册到 IOC\n还可以指定类型\n1 2 3 4 5 6 7 8 9 10 11 @Configuration public class HeaderConfig { @Bean //不存在指定类型的bean，才会将bean加入IOC容器 @ConditionalOnMissingBean(HeaderConfig.class) public HeaderParser headerParser(){ return new HeaderParser(); } } 上例运行调用该 bean 会引发异常 NoSuchBeanDefinitionException，在 @Configuration 中有 @Component，所以会自动创建 HeaderConfig 的 bean，所以不会创建 HeaderParser 的 bean\n@ConditionalOnProperty 判断配置文件中有对应属性和值，才注册 bean 到 IOC 容器\n配置文件\n1 name: header 配置类\n1 2 3 4 5 6 7 8 9 10 11 @Configuration public class HeaderConfig { @Bean //配置文件中存在指定属性名与值，才会将bean加入IOC容器 @ConditionalOnProperty(name =\u0026#34;name\u0026#34;,havingValue = \u0026#34;header\u0026#34;) public HeaderParser headerParser(){ return new HeaderParser(); } } 自定义起步依赖 例如自定义一个阿里云 OSS 的起步依赖\n首先是命名，SpringBoot 官方 starter 命名为 spring-boot-starter-xxx，而第三方组织提供的为 xxx-spring-boot-starter\n然后是模块，需要按规范定义两个模块\nstarter 模块，进行依赖管理，把程序开发所需要的依赖都定义在 starter 起步依赖中 autoconfigure 模块，用于自动配置 定义好这俩模块后，其他项目只需要引入起步依赖即可，自动配置模块会依赖传递\n模块 pom 文件 aliyun-oss-spring-boot-starter 模块\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.7.5\u0026lt;/version\u0026gt; \u0026lt;relativePath/\u0026gt; \u0026lt;!-- lookup parent from repository --\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;groupId\u0026gt;com.aliyun.oss\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;aliyun-oss-spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;java.version\u0026gt;11\u0026lt;/java.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!--引入autoconfigure模块--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.aliyun.oss\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;aliyun-oss-spring-boot-autoconfigure\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/project\u0026gt; aliyun-oss-spring-boot-autoconfigure 模块\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.7.5\u0026lt;/version\u0026gt; \u0026lt;relativePath/\u0026gt; \u0026lt;!-- lookup parent from repository --\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;groupId\u0026gt;com.aliyun.oss\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;aliyun-oss-spring-boot-autoconfigure\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;java.version\u0026gt;11\u0026lt;/java.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--引入web起步依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--Lombok--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--阿里云OSS--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.aliyun.oss\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;aliyun-sdk-oss\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.15.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.xml.bind\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jaxb-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.3.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.activation\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;activation\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.1.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- no more than 2.3.3--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.glassfish.jaxb\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jaxb-runtime\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.3.3\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/project\u0026gt; 自动配置 AliOSSAutoConfiguration 类\n1 2 3 4 5 6 7 8 9 10 11 12 13 @Configuration //导入AliOSSProperties类，并交给SpringIOC管理 @EnableConfigurationProperties(AliOSSProperties.class) public class AliOSSAutoConfiguration { //创建AliOSSUtils对象，并交给SpringIOC容器 @Bean public AliOSSUtils aliOSSUtils(AliOSSProperties aliOSSProperties){ AliOSSUtils aliOSSUtils = new AliOSSUtils(); aliOSSUtils.setAliOSSProperties(aliOSSProperties); return aliOSSUtils; } } AliOSSProperties 类\n1 2 3 4 5 6 7 8 9 10 11 12 13 /*阿里云OSS相关配置*/ @Data @ConfigurationProperties(prefix = \u0026#34;aliyun.oss\u0026#34;) public class AliOSSProperties { //区域 private String endpoint; //身份ID private String accessKeyId ; //身份密钥 private String accessKeySecret ; //存储空间 private String bucketName; } AliOSSUtils 类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 @Data public class AliOSSUtils { private AliOSSProperties aliOSSProperties; /** * 实现上传图片到OSS */ public String upload(MultipartFile multipartFile) throws IOException { // 获取上传的文件的输入流 InputStream inputStream = multipartFile.getInputStream(); // 避免文件覆盖 String originalFilename = multipartFile.getOriginalFilename(); String fileName = UUID.randomUUID().toString() + originalFilename.substring(originalFilename.lastIndexOf(\u0026#34;.\u0026#34;)); //上传文件到 OSS OSS ossClient = new OSSClientBuilder().build(aliOSSProperties.getEndpoint(), aliOSSProperties.getAccessKeyId(), aliOSSProperties.getAccessKeySecret()); ossClient.putObject(aliOSSProperties.getBucketName(), fileName, inputStream); //文件访问路径 String url =aliOSSProperties.getEndpoint().split(\u0026#34;//\u0026#34;)[0] + \u0026#34;//\u0026#34; + aliOSSProperties.getBucketName() + \u0026#34;.\u0026#34; + aliOSSProperties.getEndpoint().split(\u0026#34;//\u0026#34;)[1] + \u0026#34;/\u0026#34; + fileName; // 关闭ossClient ossClient.shutdown(); return url;// 把上传到oss的路径返回 } } 新建自动配置文件 META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports\n1 com.aliyun.oss.AliOSSAutoConfiguration 使用 引入依赖\n1 2 3 4 5 6 \u0026lt;!--引入阿里云OSS起步依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.aliyun.oss\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;aliyun-oss-spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 上例阿里云OSS相关配置需要从配置文件读取\n1 2 3 4 5 6 7 #配置阿里云OSS参数 aliyun: oss: endpoint: your_oss_region accessKeyId: your_key_id accessKeySecret: your_key_secret bucketName: your_bucker_name 测试\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 @RestController public class UploadController { @Autowired private AliOSSUtils aliOSSUtils; @PostMapping(\u0026#34;/upload\u0026#34;) public String upload(MultipartFile image) throws Exception { //上传文件到阿里云 OSS String url = aliOSSUtils.upload(image); return url; } } ","date":"2025-01-23T15:06:36+09:00","permalink":"https://blog.yexca.net/archives/223/","title":"Spring 自动配置与起步依赖"},{"content":"事务 事务是一组操作的集合，它是一个不可分割的工作单位，这些操作要么同时成功，要么同时失败\n操作：\n开启事务 (一组操作开始前，开启事务)：start transaction / begin 提交事务 (这组操作全部成功后，提交事务)：commit 回滚事务 (中间任何一个操作出现异常，回滚事务)：rollback 假设删除部门后要继续删除该部门员工\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @Service public class DeptServiceImpl implements DeptService{ @Autowired private DeptMapper deptMapper; @Autowired private EmpMapper empMapper; @Override public void delete(Integer id）{ //1．删除部门 deptMapper.delete(id); // 假如这里出现错误，只删除了部门，没删除员工 //2.根据部门id，删除部门下的员工信息 empMapper.deleteByDetId(id); } } 如上所示，将会留下不存在部门的员工，造成了数据的不一致\nSpring 事务管理 注解：@Transactional，位置：Service 层方法、类、接口上\n作用：将当前方法交给 Spring 进行事务管理，方法执行前开启事务；成功执行完毕提交事务；出现异常回滚事务\n上述方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @Service public class DeptServiceImpl implements DeptService{ @Autowired private DeptMapper deptMapper; @Autowired private EmpMapper empMapper; @Transactional // 交给Spring进行事务管理 @Override public void delete(Integer id）{ //1．删除部门 deptMapper.delete(id); //2.根据部门id，删除部门下的员工信息 empMapper.deleteByDetId(id); } } 同时可以开启事务管理日志\n1 2 3 4 #spring事务管理日志 logging: level: org.springframework.jdbc.support.JdbcTransactionManager: debug 事务属性 - 回滚 默认情况下，只有出现运行时异常 (RuntimeException) 才回滚异常，通过 rollbackFor 属性可以控制出现何种异常类型时，回滚事务\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @Service public class DeptServiceImpl implements DeptService{ @Autowired private DeptMapper deptMapper; @Autowired private EmpMapper empMapper; // 所有异常都回滚 @Transactional(rollbackFor = Exception.class) @Override public void delete(Integer id）{ //1．删除部门 deptMapper.delete(id); //2.根据部门id，删除部门下的员工信息 empMapper.deleteByDetId(id); } } 事务属性 - 传播行为 事务传播行为是指当一个事务方法被另一个事务方法调用时，这个事务方法应该如何进行事务\n1 2 3 4 5 6 7 8 9 10 11 @Transactional public void a(){ // code userServices.b(); // code } @Transactional public void b(){ // code } 上述 a 调用了 b，b 该如何进行事务，加入 a 的事务或者单独开一个事务\n可以通过属性 propagation 进行控制\n属性值 描述 REQUIRED (默认值) 需要事务，有则加入，无则创建新事务 REQUIRES_NEW 需要事务，无论有无都创建新事务 SUPPORTS 支持事务，有则加入，无则在无事务状态运行 NOT_SUPPORTS 不支持事务，有事务则挂起，在无事务下运行 MANDATORY 必须有事务，否则抛出异常 NEVER 必须无事务，否则抛出异常 使用示例\n1 2 3 4 5 6 7 8 9 10 11 @Transactional public void a(){ // code userServices.b(); // code } @Transactional(propagation = Propagation.REQUIRES_NEW) public void b(){ // code } ","date":"2025-01-22T13:30:38+09:00","permalink":"https://blog.yexca.net/archives/222/","title":"Spring 事务管理"},{"content":"Aspect Oriented Programming (面向切面编程、面向方面编程) 是面向特定方法编程\n动态代理是面向切面编程最主流的实现。而 SpringAOP 是 Spring 框架的高级技术，旨在管理 bean 对象的过程中，主要通过底层的动态代理机制，对特定的方法进行编程\n统计方法运行时间 导入依赖\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-aop\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 编写 AOP 程序，针对特定方法根据业务需要进行编程\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Slf4j @Component @Aspect // AOP类 public class TimeAspect { // 切入点表达式 @Around(\u0026#34;execution(* net.yexca.service.*.*(..))\u0026#34;) public Object recordTime(ProceedingJoinPoint proceedingJoinPoint) throws Throwable { long begin = System.currentTimeMillis(); // 调用原方法 Object object = proceedingJoinPoint.proceed(); long end = System.currentTimeMillis(); log.info(proceedingJoinPoint.getSignature() + \u0026#34;方法执行时间：{}ms\u0026#34;, end-begin); return object; } } AOP 的应用场景有记录操作日志、权限控制、事务管理等\n核心概念 连接点：JoinPoint，可以被AOP控制的方法 (暗含方法执行时的相关信息)\n通知：Advice，指哪些重复的逻辑，也就是共性功能 (最终体现为一个方法)\n切入点：PointCut，匹配连接点的条件，通知仅会在切入点方法执行时被应用\n切面：Aspect，描述通知与切入点的对应关系 (通知+切入点)\n目标对象：Target，通知所应用的对象\n上例中，没写出来的 Service 的所有方法都是连接点，被切入点表达式选中的方法都是切入点，而 AOP 类的 recordTime 方法为通知，注解 @Around 与通知共同为切面，而 TimeAspect 类称为切面类\n通知 通知类型 @Around：环绕通知，此注解标注的通知方法在目标方法前、后都被执行\n@Before：前置通知，此注解标注的通知方法在目标方法前被执行\n@After：后置通知，此注解标注的通知方法在目标方法后被执行，无论是否有异常都会执行\n@AfterReturning：返回后通知，此注解标注的通知方法在目标方法后被执行，有异常不会执行\n@AfterThrowing：异常后通知，此注解标注的通知方法发生异常后执行\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 @Component @Aspect public class MyAspect { @Before(\u0026#34;execution(* net.yexca.service.impl.*(..))\u0026#34;) public void before(){ System.out.println(\u0026#34;Before\u0026#34;); } @Around(\u0026#34;execution(* net.yexca.service.impl.*(..))\u0026#34;) public Object around(ProceedingJoinPoint proceedingJoinPoint) throws Throwable { System.out.println(\u0026#34;Around before\u0026#34;); Object result = proceedingJoinPoint.proceed(); System.out.println(\u0026#34;Around after\u0026#34;); return result; } @After(\u0026#34;execution(* net.yexca.service.impl.*(..))\u0026#34;) public void after(){ System.out.println(\u0026#34;After\u0026#34;); } @AfterReturning(\u0026#34;execution(* net.yexca.service.impl.*(..))\u0026#34;) public void afterRetruning(){ System.out.println(\u0026#34;AfterReturning\u0026#34;); } @AfterThrowing(\u0026#34;execution(* net.yexca.service.impl.*(..))\u0026#34;) public void afterThrowing(){ System.out.println(\u0026#34;AfterThrowing\u0026#34;); } } @Around 环绕通知需要自己调用 ProceedingJoinPoint.proceed() 来让原始方法执行，其他通知不需要考虑目标方法执行\n@Around 环绕通知方法的返回值，必须指定为 Object，来接收原始方法的返回值\n上述的 5 个注解的切点表达式都相同，可以提取，如下所示\n1 2 3 4 5 6 7 8 9 10 public class MyAspect { @Pointcut(\u0026#34;execution(* net.yexca.service.impl.*(..))\u0026#34;) public void pt(){} @Before(\u0026#34;pt()\u0026#34;) public void before(){ System.out.println(\u0026#34;Before\u0026#34;); } } 方法 pt() 若是 public 权限符，则可以在其他的类中引用\n通知顺序 当有多个切面的切入点都匹配到了目标方法，目标方法运行时，多个通知方法都会被执行\n1 2 3 4 5 6 net: yexca: aop: - MyAspect1 - MyAspect2 - MyAspect3 假设三个 AOP 类都选中了同一个方法，不同切面类中，默认是按照切面类名字母排序\n目标方法前的通知方法：字母排名靠前的先执行 目标方法后的通知方法：字母排名靠后的先执行 假设三个 AOP 类都有 @Before 和 @After，执行顺序为\n1 2 3 4 5 6 MyAspect1 before MyAspect2 before MyAspect3 before MyAspect3 after MyAspect2 after MyAspect1 after 可以使用 @Order(num) 注解加在切面类上来控制顺序，num 越小越先执行，@Before 和 @After 执行同上\n切入点表达式 描述切入点方法的一种表达式，主要用来决定项目中的哪些方法需要加入通知\n常见形式有 execution(...) 根据方法的签名匹配和 annotation 根据注解匹配\nexecution 主要根据方法的返回值、包名、类名、方法名、方法参数等信息来匹配，语法为\n1 execution(访问修饰符 返回值 包名.类名.方法名(方法参数) throws 异常) 其中访问修饰符、包名.类名、throws 异常可以省略，不过不建议省略包名.类名\n也可以使用通配符描述切入点\n*：单个独立的任意符号，可以通配任意返回值、包名、类名、方法名、任意类型的一个参数，也可以通配包、类、方法名的一部分 1 execution(* com.*.service.*.update*(*)) ..：多个连续的任意符号，可以通配任意层级的包，或任意类型、任意个数的参数 1 execution(* com.yexca..service.*(..)) 还可以使用 \u0026amp;\u0026amp;, ||, ! 来组合比较复杂的切入点表达式\n书写建议\n所有业务方法名在命名时尽量规范，方便切入点表达式快速匹配 描述切入点方法通常基于接口描述，而非实现类，增强拓展性 在满足业务需要的前提下，尽量缩小切入点的匹配范围 @annotation @annotation 切入点表达式，用于匹配标识有特定注解的方法，使用需先自定义注解\n1 2 3 4 @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.METHOD) public @interface MyLog { } 然后在方法上加入该注解，在 AOP 类方法上\n1 @Before(\u0026#34;@annotation(net.yexca.aop.MyLog)\u0026#34;) 连接点 在 Spring 中用 JoinPoint 抽象了连接点，用它可以获得方法执行时的相关信息\n对于 @Around 通知，获取连接点信息只能使用 ProceedingJoinPoint 对于其他四种通知，获取连接点信息只能使用 JoinPoint，它是 ProceedingJoinPoint 的父类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public Object recordTime(ProceedingJoinPoint proceedingJoinPoint) throws Throwable { // 获取目标对象的类名 String className = proceedingJoinPoint.getTarget().getClass().getName(); // 获取目标方法的方法名 String methodNAme = proceedingJoinPoint.getSignature().getName(); // 获取目标方法运行时传入的参数 Object[] args = proceedingJoinPoint.getArgs(); // 调用原方法 Object object = proceedingJoinPoint.proceed(); return object; } ","date":"2025-01-21T16:05:57+09:00","permalink":"https://blog.yexca.net/archives/221/","title":"Spring AOP(面向切面编程)"},{"content":" 音有所感系列 歌曲名 翻译 链接 僕が死のうと思ったのは 曾经我也想过一了百了 https://blog.yexca.net/archives/214 あくあ色ぱれっと aqua 的调色盘 https://blog.yexca.net/archives/219 恋の押し売り 恋爱推销 本文 17さいのうた 17 岁的歌 https://blog.yexca.net/archives/224 drop 坠入爱河 https://blog.yexca.net/archives/230 生きるを選んだ私へ 致选择活下去的自己 https://blog.yexca.net/archives/239 rainy lady 雨意未晴 https://blog.yexca.net/archives/249 恋しくなったら手を叩こう 想谈恋爱的话就拍拍手吧 https://blog.yexca.net/archives/250 引言 实际上早就翻译了捏~(￣▽￣)~*\n这首歌除了可爱之外另一个影响很深的地方就是它是我的 Youtube Music 2024 年度歌曲，打开的时候画面的文字是 \u0026ldquo;今年もお届けします。2024 年のハイライト！\u0026quot;，然后自动播放这首歌 \u0026ldquo;ハートマーク作って、届け届け届け！\u0026quot;， 这波体验感直接拉满好吧\n2025.01.27 唱了这首歌，简直太可爱啦！！！\n歌曲视频 由于 bilibili 的嵌入式体验不好，改为 Youtube 的，星川サラ 有官方账户，本歌曲视频: BV1dk4y1a7RX\n歌词 ハートマーク作って\n画个爱心的记号\n届け届け届け\n快一点、传达到、你心里\nきっと恋の押し売り\n这大概是恋爱的推销\n好きで好きでごめん\n喜欢你，超喜欢，抱歉呐\n出会っちゃった！\n和你相遇了！\nときめいちゃった？\n心跳加速了吗？\n私だけ？ドキドキしてるの\n还是只有我？在砰砰心跳呢\nちゃんと気にかけて\n多多在意我啦\n私だけ！甘やかして\n只对我！好好宠爱吧\n(Ah)　君と話す理由欲しくて探している\n（啊）不断寻找和你聊天的理由\n(なんで？)　強がっていても恋に負けちゃうんだね\n（为什么？）就算装作坚强，还是败给了恋爱呀\nハートマーク作って\n画个爱心的记号\n届け届け届け\n快一点、传达到、你心里\nきっと恋の押し売り\n这大概是恋爱的推销\n好きで好きでごめん\n好喜欢，太喜欢，抱歉呐\nハートのレスください\n请回复我的心意\n早く早く早くー！\n快一点、再快点、马上做~！\nこれは恋の押し売り\n这可是恋爱的强制推销\n返品なんてダメよ\n想退货？不可以！\n取られたくないんだよ…\n不想被抢走啊\u0026hellip;\n誰よりも可愛くなりたい\n想要变得比谁都可爱\n完全勝利して\n想完全胜利\n私だけって言わせてやる！\n让你说出“只有我”！\n(Ah)　君の胸を狙う私の恋の銃口\n（啊）我的恋爱枪，瞄准着你的胸口\n(なんで？)　震えちゃうんだろう\n（为什么？）会不由自主地颤抖呢\nいつか撃うち抜ぬけるまで\n直到贯穿为止\nせーっの！BANG\n一、二、砰！\n期待させてよ\n让我更加期待吧\nもっともっともっと\n多点、再多、更多\n私浮うわついちゃって\n我有点飘飘然了\nバカだバカだごめん\n傻乎乎，真的是，抱歉呐\nハートは忙しくて\n心里稍微有点忙\nあっちこっちどっちー？\n那里？这里？哪里？\n今はまだまだプロローグ\n现在还只是序幕呢\n押して押して押すの\n按下去、快一点、去推进\n私、君に出会えて変わったの！\n我，和你遇见之后改变了！\nそりゃあ悩んじゃう事もあるけど…\n虽然也有会烦恼的时候。。。\nもっともっと可愛くなりたいって思うし\n但想要变得更加更加可爱\n何より君に好きって言ってもらいたい！\n没有什么比得上你对我说喜欢！\n笑顔の私(可愛い)\n笑着的我（可爱捏）\n泣いちゃう私(可愛い)\n哭着的我（可爱捏）\n怒った私(可愛い)\n生气的我（可爱捏）\n恋する私…\n恋爱中的我。。。\n甘えさせてよ\n让我撒娇嘛\nずっとずっとずっと\n始终、一直、永远\nきっと後悔させない\n一定不会让你后悔的\nお願い　好きになって\n拜托了，喜欢我吧\nハートマーク作って\n画一个爱心记号\n届け届け届け\n快一点、传达到、你心里\nきっと恋の押し売り\n大概是恋爱的小强推\n好きで好きでごめん\n喜欢你，超喜欢，抱歉呐\nハートのレスください\n请回复我的心意\n早く早く早くー！\n快一点、再快点、马上要！\nこれは恋の押し売り\n这可是恋爱的强制推销\n返品なんてダメよ\n不可以、退货哦\n","date":"2025-01-20T16:24:43+09:00","permalink":"https://blog.yexca.net/archives/220/","title":"音有所感 - 《恋の押し売り》"},{"content":" 音有所感系列 歌曲名 翻译 链接 僕が死のうと思ったのは 曾经我也想过一了百了 https://blog.yexca.net/archives/214 あくあ色ぱれっと aqua 的调色盘 本文 恋の押し売り 恋爱推销 https://blog.yexca.net/archives/220 17さいのうた 17 岁的歌 https://blog.yexca.net/archives/224 drop 坠入爱河 https://blog.yexca.net/archives/230 生きるを選んだ私へ 致选择活下去的自己 https://blog.yexca.net/archives/239 rainy lady 雨意未晴 https://blog.yexca.net/archives/249 恋しくなったら手を叩こう 想谈恋爱的话就拍拍手吧 https://blog.yexca.net/archives/250 引言 第二首本来想选我的 2024 年度歌曲的，不过不经意间听到了 aqua 的歌，便想到了这首，之前听的时候只是中间的有一段和我的人生经历有点类似，所以一直在听，全曲认真翻译后才知道染上 aqua 颜色的梗从这来的啊 (在 C105 听到“想染上 aqua 的颜色的话”，还以为是来自《君色に染まる》)\n想着第四首歌写啥的时候发现这首是 2023 年的年度歌曲，也没差，就当用 Youtube 的历史开始吧，第一个年度歌曲\n虽然经历类似让我开始慢慢听上 aqua 且慢慢喜欢上，但事实上我的 “キミがいるから私　いつでも頑張れるんだ” 是 warma 捏，写到这突然就意识到了一直在影响着我的到底是什么了，以及如今是为何这样，不过正如因这首歌的改变，当前的困惑也一定有契机可以化解\n我很克制得没写下去，毕竟是一首欢乐的歌，可以说对于偶像路线简直是太绝了这首歌，同时用词倒也不是太难 (相对于外国人)，是我都可以听懂的程度 (doge)\n因为我是去年 (2024) 接触到 aqua 的嘛，因为经常听到这首歌 (3D 直播)，还以为是经历了一些沉淀，然后出了这么厉害的歌 (因为一直在收听榜第一)，没想到是出道即巅峰啊 (《For the Win》是 bilibili 企划的，暂且不记上)，同时之后的歌曲，怎么说呢，偶像类的都很好，可以说是直接让我开始喜欢一些偶像风了，以此为契机，倒是喜欢上了偶像演唱会 (虽然随着 aqua 的毕业也不怎么感兴趣了)\n同时，对比其他翻译可能有出入，我的翻译多数是有自己的感情吧，所以部分并不是歌词本身的意思 （事实上 上一首 也是），这个在可能下一个 2024 年度歌曲的翻译中表现更明显。我觉得如果只是照抄一个标准的翻译多少没啥意义，因为是真正热爱的事物，多少想留存自己的特色 (染上我的色彩)\n最后捏，我也想染上 aqua 的色彩捏，毕竟是我最爱的三个人之一 （C105 没买到立牌真可惜了，结城的也没买到（悲\n2025.01.27 唱了这首歌，唱的时候就想到了 aqua 翻唱的 誇り高きアイドル ，体验还是很奇妙的\n2025.05.26 又唱了一遍 (虽然在此之前也在 VRChat 唱了一遍来着)，果然还是喜欢 \u0026ldquo;キミがいるから　歩いてこれた、キミがいなくちゃ　前も見れない\u0026rdquo; 啊，哪天心情低落时候遇到一个可以激励自己的人或者想达成的事情真的很有能量呢\n歌曲视频 由于 bilibili 的嵌入式体验不好，改为 Youtube 的，可访问搬运组账户，本歌曲视频: BV1AV411Y7mZ\n歌词 何をしても不器用で　何かとミスしてばっか\n什么也做不到，做什么都出错\nダメダメな私だって\n一无是处的我\nできる事があるの\n也有可以做到的事哦\n凹凹へこんで悲しくたって　笑顔にしてあげるんだ\n就算陷入低落，我也会让你笑起来哦\nここにいるから　早く　私を見つけてね\n因为就在这里，快一点，找到我吧\nLove You Love You, I love you\n爱你爱你，我爱你\nLove You Love You, Ah,I love you so much\n爱你爱你，我非常爱你\nLove You Love You, I love you\n爱你爱你，我爱你\nLove You Love You\n爱你爱你\n（あぁ　愛してもっと）\n(啊~更加爱我吧)\nいつでも隣にいるし、いつでも一緒に笑える\n一直都陪在身边，一直都一起欢笑\n私をたくさん知って　たくさん好きって言って\n多多了解我，多多对我说“喜欢”\nワガママで朝も苦手　ドジだし　ダメダメだけど\n任性也赖床，笨手笨脚还一无是处\nそれでも私の事を　見ててね\n就算那样也请专注于我\n描く夢の未来へ続く\n向着描绘未来的路\n道をキミと歩けますように\n希望能和你一起走下去\nねぇもっと！好きになってもらいたいの！\n呐，想让你多多喜欢我！\n頭の中は君ばっか！\n我的脑海里只有你\nってゆーかそっぽなんて向いてないで！\n话说，别把头转开呀！\nあぁもう！ヤキモキしちゃうわ　Ah\n啊啊，真是的！急死人了\nずっとずっと好きがいいの\n一直一直喜欢下去吧\n心の奥もトキメイちゃうくらい\n内心深处都怦然心动的程度\nこっち向いててよね　ダーリン？\n看看我嘛，亲爱的？\nあぁもう離さないから、絶対に！\n啊~，再也不会放开你，绝对不会！\nLove You Love You, I love you\n爱你爱你，我爱你\nLove You Love You\n爱你爱你\n（あぁ　愛してもっと）\n(啊~，多多爱我吧)\nキミがいるから私　いつでも頑張れるんだ\n正因为有你在身边，我才能努力下去\n落ち込んで悲しくたって　キミがいるから\u0026hellip;\n就算低落悲伤，因为有你在身边。。。\nキミがいるから　歩いてこれた\n正因为有你在，我才能走到今天\nキミがいなくちゃ　前も見れない\n如果没有你，我连前方也看不清\n嫌な事とか辛い事とかあったって\n即使有讨厌的，痛苦的事\nキミの力でここまで笑ってこれたんだ\n有你的力量就可以笑着走到现在\n今度はもっと私がぐっとひっぱって　連れて行くんだ\n这次我会更加努力拉着你，一起走下去\nキミがいるから私がいるの\n因为有你在，我才能到这\nこんな私を　愛してくれる？\n你愿意爱上这样的我吗？\nねぇもっと　ねぇもっと\n呐，多一点，再多点\nまだもっと　受け止めてよね！ねぇいい？\n更多地接受我吧！可以吗？\nさぁ声を上げて！\n那么，大声地说出来吧！\nねぇもっと　ねぇもっと\n呐，多一点，再多点\n好きになってもらいたいの\n想让你喜欢上我\nいつでも　そう私ばっか みたいにそっぽなんて向かせないわ\n无论何时，我都不允许你把目光移开，只让我在你心里\nね、ほら夢中にしちゃうわ　Ah\n呐，看到了吧，已经沉迷了呢~\nずっとずっと好きがいいの！心も体も染まっちゃうくらいに\n一直一直喜欢下去吧，直到你的身心都染上我的色彩\nこっち向いててよねダーリン?\n看向这边呀，亲爱的？\nあぁもう離さないから、絶対に　絶体ね　絶体よ　約束だよ\n啊~，我不会放开你，一定不会、肯定不会、绝对不会，约好了哟\n（あぁ 愛してもっと）\n(啊~，更多地爱我吧)\n","date":"2025-01-20T00:16:48+09:00","permalink":"https://blog.yexca.net/archives/219/","title":"音有所感 - 《あくあ色ぱれっと》"},{"content":"会话技术 会话：用户打开浏览器，访问 web 服务器的资源，会话建立，直到有一方断开连接，会话结束。在一次会话中可以包含多次请求和响应\n会话跟踪：一种维护浏览器状态的方法，服务器需要识别多次请求是否来自于同一浏览器，以便在同一次会话的多次请求间共享数据\n会话跟踪方案：\n客户端会话跟踪技术：Cookie 服务端会话跟踪技术：Session 令牌技术 Cookie Cookie 是 HTTP 协议支持的技术，在浏览器第一次访问时，服务端请求头中设置 Cookie Set-Cookie: your_cookie，浏览器会自动把 Cookie 存在本地，并在下次访问时自动在请求头中加上 Cookie Cookie: your_cookie\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 @RestController public class SessionController { // 设置Cookie @GetMapping(\u0026#34;/c1\u0026#34;) public Result cookie1(HttpServletResponse response){ response.addCookie(new Cookie(\u0026#34;login_name\u0026#34;, \u0026#34;yexca\u0026#34;)); return Result.success(); } // 获取Cookie @GetMapping(\u0026#34;/c2\u0026#34;) public Result cookie2(HttpServletRequest request){ Cookie[] cookies = request.getCookies(); for (Cookie c : cookies){ if(c.getName().equals(\u0026#34;login_name\u0026#34;)){ System.out.println(\u0026#34;login_name:\u0026#34;+c.getValue()); } } return Result.success(); } } 不过移动端不能使用 Cookie，并且 Cookie 无法跨域\n相同域：同协议、IP/域名、端口\nSession 基于 Cookie 实现，在浏览器第一次请求时生成一个 Session，然后在响应头返回 Session 的 ID Set-Cookie: JSESSIONID=session_id，然后浏览器在下次请求时自动带上该 ID\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 @RestController public class SessionController { // 往HttpSession中存储值 @GetMapping(\u0026#34;/s1\u0026#34;) public Result session1(HttpSession session){ log.info(\u0026#34;HttpSession_set:{}\u0026#34;, session.hashCode()); session.setAttribute(\u0026#34;login_user\u0026#34;,\u0026#34;yexca\u0026#34;); return Result.success(); } // 从HttpSession中获取值 @GetMapping(\u0026#34;/s2\u0026#34;) public Result session2(HttpServletRequest request){ HttpSession session = request.getSession(); log.info(\u0026#34;HttpSession_get:{}\u0026#34;, session.hashCode()); Object loginUser = session.getAttribute(\u0026#34;login_user\u0026#34;); log.info(\u0026#34;loginUser:{}\u0026#34;, loginUser); return Result.success(); } } 而 Session 的问题在于若服务端使用负载均衡，即有多台服务端，若第一次响应的为服务器一，而第二次响应为服务器二，由于服务器二里没有 Session，所以无法使用\nJWT 令牌 令牌技术支持 PC 端、移动端，可以解决集群环境下的认证问题，减轻服务器端存储压力，但需要自己实现\nJWT 全称 JSON Web Token，官网： https://jwt.io/ ，定义了一种简洁的、自包含的格式，用于在通信双方以 JSON 数据格式安全的传输信息。由于数字签名的存在，这些信息是可靠的\n组成：\n第一部分：Header，记录令牌类型、签名算法等 第二部分：Payload (有效载荷)，记录一些自定义信息、默认信息等 第三部分：Signature (签名)，防止 Token 被篡改、确保安全性。将 Header、Payload 和指定密钥，通过指定签名算法计算而来 引入依赖\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.jsonwebtoken\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jjwt\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.9.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 生成与解析\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class WebApplicationTests { // JWT生成 @Test public void jwtGenTest(){ Map\u0026lt;String,Object\u0026gt; claims = new HashMap\u0026lt;\u0026gt;(); claims.put(\u0026#34;id\u0026#34;, \u0026#34;233\u0026#34;); claims.put(\u0026#34;user\u0026#34;, \u0026#34;yexca\u0026#34;); String jwt = Jwts.builder() .signWith(SignatureAlgorithm.HS256, \u0026#34;yexca\u0026#34;) // 签名算法 .setClaims(claims) //自定义内容(载荷) .setExpiration(new Date(System.currentTimeMillis() + 3600 * 1000)) // 有效期为1h .compact(); System.out.println(jwt); } // 输出 // eyJhbGciOiJIUzI1NiJ9.eyJpZCI6IjIzMyIsImV4cCI6MTcwMjc5NzA4OCwidXNlciI6InlleGNhIn0.BqZDxEddGN4g4GyyfvkOtKYv7DVlIF6cWY9PGW2RbUU // JWT解析 @Test public void jwtParseTest(){ Claims claims = Jwts.parser() .setSigningKey(\u0026#34;yexca\u0026#34;) // 密钥 .parseClaimsJws(\u0026#34;eyJhbGciOiJIUzI1NiJ9.eyJpZCI6IjIzMyIsImV4cCI6MTcwMjc5NzA4OCwidXNlciI6InlleGNhIn0.BqZDxEddGN4g4GyyfvkOtKYv7DVlIF6cWY9PGW2RbUU\u0026#34;) .getBody(); // 获得第二部分 System.out.println(claims); } // 输出 // {id=233, exp=1702797088, user=yexca} } 登录校验 过滤器 (Filter) Filter 是早期 JavaWeb 三大组件 (Servlet, Filter, Listener) 之一。过滤器可以把对资源的请求拦截下来，从而实现一些特殊的功能，如登录校验、统一编码处理、敏感字符处理等\n快速入门 创建 Filter 类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 @WebFilter(urlPatterns = \u0026#34;/*\u0026#34;) // 拦截路径 public class DemoFilter implements Filter { @Override public void init(FilterConfig filterConfig) throws ServletException { // Filter.super.init(filterConfig); System.out.println(\u0026#34;Filter 初始化\u0026#34;); } @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { System.out.println(\u0026#34;Filter 拦截\u0026#34;); // 放行 filterChain.doFilter(servletRequest, servletResponse); } @Override public void destroy() { // Filter.super.destroy(); System.out.println(\u0026#34;Filter 销毁\u0026#34;); } } 在 Application 加上注解\n1 2 @ServletComponentScan // 开启了对servlet组件的支持 @SpringBootApplication 拦截路径 可以根据需求调整，以下为示例\n拦截类型 urlPatterns 含义 拦截具体路径 /login 只有访问 /login 才会被拦截 目录拦截 /emps/* 访问 /emps 下所有资源都会被拦截，/emps 也会拦截 拦截所有 /* 访问所有资源都会被拦截 单个过滤器执行逻辑 浏览器发送请求 -\u0026gt; 请求被拦截 -\u0026gt; 执行放行前逻辑 -\u0026gt; 放行 -\u0026gt; 执行放行后逻辑 -\u0026gt; 浏览器收到响应\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 @WebFilter(urlPatterns = \u0026#34;/*\u0026#34;) // 拦截路径 public class DemoFilter implements Filter { @Override public void init(FilterConfig filterConfig) throws ServletException { // Filter.super.init(filterConfig); System.out.println(\u0026#34;Filter 初始化\u0026#34;); } @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { System.out.println(\u0026#34;Filter 拦截，放行前逻辑\u0026#34;); // 放行 filterChain.doFilter(servletRequest, servletResponse); System.out.println(\u0026#34;Filter 拦截，放行后逻辑\u0026#34;); } @Override public void destroy() { // Filter.super.destroy(); System.out.println(\u0026#34;Filter 销毁\u0026#34;); } } 过滤器链 一个 Web 应用中，可以配置多个过滤器，这多个过滤器就形成了一个过滤器链\n顺序：注解配置的 Filter 优先级是通过过滤器类名的自然排序\n逻辑：浏览器发送请求 -\u0026gt; 请求被 A 拦截 -\u0026gt; 执行 A 放行前逻辑 -\u0026gt; A 放行 -\u0026gt; 请求被 B 拦截 -\u0026gt; 执行 B 放行前逻辑 -\u0026gt; B 放行 -\u0026gt; 执行 B 放行后逻辑 -\u0026gt; 执行 A 放行后逻辑 -\u0026gt; 浏览器收到响应\n登录校验 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 @Slf4j @WebFilter(urlPatterns = \u0026#34;/*\u0026#34;) public class LoginCheckFilter implements Filter { @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { HttpServletRequest request = (HttpServletRequest) servletRequest; HttpServletResponse response = (HttpServletResponse) servletResponse; // 获取请求url String requestURI = request.getRequestURI(); log.info(\u0026#34;请求URL：{}\u0026#34;,requestURI); // 判断是否有login if(requestURI.contains(\u0026#34;login\u0026#34;)){ log.info(\u0026#34;登录操作，放行\u0026#34;); filterChain.doFilter(servletRequest, servletResponse); return; // 因为登录操作不需要以下逻辑 } // 非登录，获取令牌 String jwt = request.getHeader(\u0026#34;token\u0026#34;); // 判断令牌是否有效 if(!StringUtils.hasLength(jwt)){ log.info(\u0026#34;请求头token为空\u0026#34;); // 将对象转换为JSON Result error = Result.error(\u0026#34;NOT_LOGIN\u0026#34;); String notLogin = JSONObject.toJSONString(error); response.getWriter().write(notLogin); return; } // 校验令牌 try { JwtUtils.parseJWT(jwt); }catch (Exception e){ e.printStackTrace(); log.info(\u0026#34;解析令牌失败\u0026#34;); // 将对象转换为JSON Result error = Result.error(\u0026#34;NOT_LOGIN\u0026#34;); String notLogin = JSONObject.toJSONString(error); response.getWriter().write(notLogin); return; } // 放行 log.info(\u0026#34;令牌合法，放行\u0026#34;); filterChain.doFilter(servletRequest,servletResponse); } } 拦截器 (Interceptor) 快速入门 创建拦截器\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 @Component public class LoginCheckInterceptor implements HandlerInterceptor { @Override // 目标方法运行前运行，返回ture放行，false不放行 public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { // return HandlerInterceptor.super.preHandle(request, response, handler); System.out.println(\u0026#34;preHandle\u0026#34;); return true; } @Override // 目标方法运行后运行 public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { // HandlerInterceptor.super.postHandle(request, response, handler, modelAndView); System.out.println(\u0026#34;postHandle\u0026#34;); } @Override // 视图渲染完成后运行，最后运行 public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { // HandlerInterceptor.super.afterCompletion(request, response, handler, ex); System.out.println(\u0026#34;afterCompletion\u0026#34;); } } 创建配置\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 @Configuration // 配置类 public class WebConfig implements WebMvcConfigurer { @Autowired private LoginCheckInterceptor loginCheckInterceptor; @Override public void addInterceptors(InterceptorRegistry registry) { // WebMvcConfigurer.super.addInterceptors(registry); registry.addInterceptor(loginCheckInterceptor).addPathPatterns(\u0026#34;/**\u0026#34;).excludePathPatterns(\u0026#34;/login\u0026#34;); } } 拦截路径 路径 含义 例子 /* 一级路径 /emps, /login 不能匹配 /emps/1 /** 任意级路径 /emps, /emps/1, /emps/1/2 /emps/* /emps 下的一级路径 /emps/1 不能匹配 /emps, /emps/1/2 /emps/** /emps 下的任意级路径 /emps, /emps/1, /emps/1/2 拦截流程 如果同时存在过滤器和拦截器\n浏览器访问 -\u0026gt; filter 放行前逻辑 -\u0026gt; filter 放行 -\u0026gt; DispatcherServlet -\u0026gt; Interceptor preHandle -\u0026gt; Controller -\u0026gt; postHandle -\u0026gt; afterCompletion -\u0026gt; DispatcherServlet -\u0026gt; filter 放行后逻辑 -\u0026gt; 响应浏览器\nFilter 会拦截所有的请求，而 Interceptor 只会拦截 Spring 环境中的资源\n登录校验 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 @Slf4j @Component public class LoginCheckInterceptor implements HandlerInterceptor { @Override // 目标方法运行前运行，返回ture放行，false不放行 public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { // return HandlerInterceptor.super.preHandle(request, response, handler); System.out.println(\u0026#34;preHandle\u0026#34;); // 获取请求url String requestURI = request.getRequestURI(); log.info(\u0026#34;请求URL：{}\u0026#34;,requestURI); // 判断是否有login if(requestURI.contains(\u0026#34;login\u0026#34;)){ log.info(\u0026#34;登录操作，放行\u0026#34;); return true; } // 非登录，获取令牌 String jwt = request.getHeader(\u0026#34;token\u0026#34;); // 判断令牌是否有效 if(!StringUtils.hasLength(jwt)){ log.info(\u0026#34;请求头token为空\u0026#34;); // 将对象转换为JSON Result error = Result.error(\u0026#34;NOT_LOGIN\u0026#34;); String notLogin = JSONObject.toJSONString(error); response.getWriter().write(notLogin); return false; } // 校验令牌 try { JwtUtils.parseJWT(jwt); }catch (Exception e){ e.printStackTrace(); log.info(\u0026#34;解析令牌失败\u0026#34;); // 将对象转换为JSON Result error = Result.error(\u0026#34;NOT_LOGIN\u0026#34;); String notLogin = JSONObject.toJSONString(error); response.getWriter().write(notLogin); return false; } // 放行 log.info(\u0026#34;令牌合法，放行\u0026#34;); return true; } @Override // 目标方法运行后运行 public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { // HandlerInterceptor.super.postHandle(request, response, handler, modelAndView); System.out.println(\u0026#34;postHandle\u0026#34;); } @Override // 视图渲染完成后运行，最后运行 public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { // HandlerInterceptor.super.afterCompletion(request, response, handler, ex); System.out.println(\u0026#34;afterCompletion\u0026#34;); } } ","date":"2025-01-16T23:06:20+09:00","permalink":"https://blog.yexca.net/archives/218/","title":"JWT 登录校验"},{"content":"初识 MQ 同步调用 微服务间基于 Feign 的调用属于同步方式，存在一些问题\n例如要开发一个支付服务，需要加入订单服务和仓储服务的代码，后期若要加入短信服务、积分服务等都需要修改支付代码，违反了 开放-封闭原则 ，并且在请求返回前无法做其他事情也会造成性能的浪费\n问题：耦合度高、性能下降、资源浪费、级联失败 (若提供者出现问题，所有调用方也会跟着出问题，如同多米诺骨牌，迅速导致整个微服务群故障)\n异步调用方案 异步调用常见实现就是事件驱动模式\n用户支付请求 -\u0026gt; 支付服务 -\u0026gt; Broker，之后支付服务完成并响应，然后由 Broker 通知订单服务、仓储服务和短信服务\n优点：服务解耦、性能提升，吞吐量提高、服务没有强依赖，故障隔离、流量削峰\n缺点：依赖于 Broker 的可靠性、安全性、吞吐能力，架构复杂了，业务没有明显的流程线，不好追踪管理\nMQ MessageQueue，消息队列，字面意思为存放消息的队列，也就是事件驱动架构中的 Broker\nRabbitMQ ActiveMQ RocketMQ Kafka 公司/社区 Rabbit Apache 阿里 Apache 开发语言 Erlang Java Java Scala\u0026amp;Java 协议支持 AMQP，XMPP，SMTP，STOMP OpenWire,STOMP，REST,XMPP,AMQP 自定义协议 自定义协议 可用性 高 一般 高 高 单机吞吐量 一般 差 高 非常高 消息延迟 微秒级 毫秒级 毫秒级 毫秒以内 消息可靠性 高 一般 高 一般 追求可用性：Kafka、 RocketMQ 、RabbitMQ\n追求可靠性：RabbitMQ、RocketMQ\n追求吞吐能力：RocketMQ、Kafka\n追求消息低延迟：RabbitMQ、Kafka\n安装 RabbitMQ 可以从 官网 看到多种安装方式，我使用 Docker 在线拉取\n1 docker pull rabbitmq:3-management 运行命令\n1 2 3 4 5 6 7 8 9 docker run \\ -e RABBITMQ_DEFAULT_USER=admin \\ -e RABBITMQ_DEFAULT_PASS=admin \\ --name mq \\ --hostname mq1 \\ -p 15672:15672 \\ -p 5672:5672 \\ -d \\ rabbitmq:3-management 访问 localhost:15672 即可打开管理，RabbitMQ 中的一些概念：\nchannel：操作 MQ 的工具 exchange：交换机，路由消息到队列中 queue：队列，存储消息 virtualHost：虚拟主机，是对 queue、exchange 等资源的逻辑分组 消息模型 在 官网提供了多种 Demo ，对应了不同的消息模型\n基本消息队列 (BasicQueue)： \u0026ldquo;Hello World!\u0026rdquo; 工作消息队列 (WorkQueue)： Work Queues 发布订阅模型 Fanout Exchange：广播 Publish/Subscribe Direct Exchange：路由 Routing Topic Exchange：主题 Topics Hello World Publisher -\u0026gt; Queue -\u0026gt; Consumer\npublisher：消息发布者，将消息发送到队列 queue queue：消息队列，负责接受并缓存消息 consumer：订阅队列，处理队列中的消息 发布者\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 public class PublisherTest { @Test public void testSendMessage() throws IOException, TimeoutException { // 1.建立连接 ConnectionFactory factory = new ConnectionFactory(); // 1.1.设置连接参数，分别是：主机名、端口号、vhost、用户名、密码 factory.setHost(\u0026#34;localhost\u0026#34;); factory.setPort(5672); factory.setVirtualHost(\u0026#34;/\u0026#34;); factory.setUsername(\u0026#34;admin\u0026#34;); factory.setPassword(\u0026#34;admin\u0026#34;); // 1.2.建立连接 Connection connection = factory.newConnection(); // 2.创建通道Channel Channel channel = connection.createChannel(); // 3.创建队列 String queueName = \u0026#34;hello.queue\u0026#34;; channel.queueDeclare(queueName, false, false, false, null); // 4.发送消息 String message = \u0026#34;hello, rabbitmq!\u0026#34;; channel.basicPublish(\u0026#34;\u0026#34;, queueName, null, message.getBytes()); System.out.println(\u0026#34;发送消息成功：【\u0026#34; + message + \u0026#34;】\u0026#34;); // 5.关闭通道和连接 channel.close(); connection.close(); } } 接收者\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 public class ConsumerTest { public static void main(String[] args) throws IOException, TimeoutException { // 1.建立连接 ConnectionFactory factory = new ConnectionFactory(); // 1.1.设置连接参数，分别是：主机名、端口号、vhost、用户名、密码 factory.setHost(\u0026#34;localhost\u0026#34;); factory.setPort(5672); factory.setVirtualHost(\u0026#34;/\u0026#34;); factory.setUsername(\u0026#34;admin\u0026#34;); factory.setPassword(\u0026#34;admin\u0026#34;); // 1.2.建立连接 Connection connection = factory.newConnection(); // 2.创建通道Channel Channel channel = connection.createChannel(); // 3.创建队列 String queueName = \u0026#34;hello.queue\u0026#34;; channel.queueDeclare(queueName, false, false, false, null); // 4.订阅消息 channel.basicConsume(queueName, true, new DefaultConsumer(channel){ @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException { // 5.处理消息 String message = new String(body); System.out.println(\u0026#34;接收到消息：【\u0026#34; + message + \u0026#34;】\u0026#34;); } }); System.out.println(\u0026#34;等待接收消息。。。。\u0026#34;); } } 控制台输出：\n1 2 等待接收消息。。。。 接收到消息：【hello, rabbitmq!】 显然这种方式略显繁琐\nSpringAMQP SpringAMQP 是基于 RabbitMQ 封装的一套模板，并且还利用 SpringBoot 对其实现了自动装配，使用起来非常方便\nAMQP Advanced Message Queuing Protocol，是用于在应用程序之间传递业务消息的开放标准。该协议与语言和平台无关，更符合微服务中独立性的要求\nSpring AMQP Spring AMQP 是基于 AMQP 协议定义的一套 API 规范，提供了模板来发送和接收消息。包含两部分，其中 spring-amqp 是基础抽象，spring-rabbit 是底层的默认实现\n它可以自动声明队列、交换机及其绑定关系，基于注解的监听器模式，异步接收消息\nBasic Queue 简单队列模型 首先在父工程中引入依赖\n1 2 3 4 5 \u0026lt;!--AMQP依赖，包含RabbitMQ--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-amqp\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; publisher 消息发送 配置 application.yml\n1 2 3 4 5 6 7 spring: rabbitmq: host: localhost # 主机名 port: 5672 # 端口 virtual-host: / # 虚拟主机 username: admin # 用户名 password: admin # 密码 利用 RabbitTemplate 实现消息发送\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @RunWith(SpringRunner.class) @SpringBootTest public class SpringamqpTest { @Autowired private RabbitTemplate rabbitTemplate; @Test public void testSimpleQueue(){ // 队列名 String queueName = \u0026#34;hello.queue\u0026#34;; // 消息 String msg = \u0026#34;Hello Spring ampq\u0026#34;; // 发送 rabbitTemplate.convertAndSend(queueName,msg); } } consumer 消息接收 配置 application.yml 同上\n1 2 3 4 5 6 7 spring: rabbitmq: host: localhost # 主机名 port: 5672 # 端口 virtual-host: / # 虚拟主机 username: admin # 用户名 password: admin # 密码 创建一个新类 SpringRabbitListener\n1 2 3 4 5 6 7 @Component public class SpringRabbitListener { @RabbitListener(queues = \u0026#34;hello.queue\u0026#34;) public void listenSimpleQueue(String msg){ System.out.println(\u0026#34;接收的消息为：\u0026#34; + msg); } } WorkQueue 工作消息队列 也称 TaskQueue，任务模型，可以提高消息处理速度，避免队列消息堆积\npublisher -\u0026gt; queue -\u0026gt; consumer1 and consumer2 and \u0026hellip;\npublisher 消息发送 定义一个方法，每秒发送 50 条消息\n1 2 3 4 5 6 7 8 9 10 11 12 public class SpringamqpTest { @Test public void testWorkQueue() throws InterruptedException { String queueName = \u0026#34;hello.queue\u0026#34;; String msg = \u0026#34;Hello Spring ampq...\u0026#34;; for (int i = 0; i \u0026lt; 50; i++) { rabbitTemplate.convertAndSend(queueName, msg + i); // 睡眠20毫秒，1秒发50条消息 Thread.sleep(20); } } } consumer 消息接收 创建两个消费者绑定同一队列\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @Component public class SpringRabbitListener { @RabbitListener(queues = \u0026#34;hello.queue\u0026#34;) public void listenSimpleQueue1(String msg) throws InterruptedException { System.out.println(\u0026#34;1接收的消息为：\u0026#34; + msg); // 每秒处理40条消息 Thread.sleep(25); } @RabbitListener(queues = \u0026#34;hello.queue\u0026#34;) public void listenSimpleQueue2(String msg) throws InterruptedException { // 使用err输出红色消息 System.err.println(\u0026#34;2接收的消息为：\u0026#34; + msg); // 每秒处理5条消息 Thread.sleep(200); } } 测试 先运行接收者，而后运行发送者发送消息\n从输出结果可以看到，俩接收者各接收一半的消息，也就是说消息是平均分配给每个消费者，并没有考虑到消费者的处理能力。这样显然是有问题的\nprefetch 修改 application.yml 文件，设置 prefetch 这个值，可以控制预取消息的上限 (默认无限)\n1 2 3 4 5 6 7 8 9 10 11 spring: rabbitmq: host: localhost # 主机名 port: 5672 # 端口 virtual-host: / # 虚拟主机 username: admin # 用户名 password: admin # 密码 listener: simple: # 每次只能获取一条消息，处理完成才能获取下一个消息 prefetch: 1 再次测试可以发现执行效率提高\n发布订阅模型 发布订阅模式加入了交换机，允许将同一个消息发送给全部接收者\npublisher -\u0026gt; exchange -\u0026gt; queue1 and queue2 queue1 -\u0026gt; consumer1 and consumer2 queue2 -\u0026gt; consumer3\n常见的 exchange 有\nFanout：广播 Direct：路由 Topic：话题 exchange 负责路由，并不存储，一旦路由失败则消息丢失\nFanout(扇出) 广播 Fanout exchange 会将接收到的消息广播到每一个和其绑定的 queue\n在接收者创建一个配置类，声明队列与交换机\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 @Configuration public class FanoutConfig { /** * 声明交换机 * @return */ @Bean public FanoutExchange fanoutExchange(){ return new FanoutExchange(\u0026#34;hello.fanout\u0026#34;); } /** * 第一个队列 * @return */ @Bean public Queue fanoutQueue1(){ return new Queue(\u0026#34;fanout.queue1\u0026#34;); } /** * 绑定第一个队列与交换机 * @param fanoutQueue1 * @param fanoutExchange * @return */ @Bean public Binding bindingQueue1(Queue fanoutQueue1, FanoutExchange fanoutExchange){ return BindingBuilder.bind(fanoutQueue1).to(fanoutExchange); } /** * 第二个队列 * @return */ @Bean public Queue fanoutQueue2(){ return new Queue(\u0026#34;fanout.queue2\u0026#34;); } /** * 绑定第二个队列与交换机 * @param fanoutQueue2 * @param fanoutExchange * @return */ @Bean public Binding bindingQueue2(Queue fanoutQueue2, FanoutExchange fanoutExchange){ return BindingBuilder.bind(fanoutQueue2).to(fanoutExchange); } } 消息发送\n1 2 3 4 5 6 7 8 9 10 public class SpringamqpTest { @Test public void testFanoutExchange(){ // 交换机 String exchangeName = \u0026#34;hello.fanout\u0026#34;; // 消息 String msg = \u0026#34;hello, everyone\u0026#34;; rabbitTemplate.convertAndSend(exchangeName,\u0026#34;\u0026#34;,msg); } } 其中中间空着的 routingkey 在下两个模型使用\n消息的接收\n1 2 3 4 5 6 7 8 9 10 11 @Component public class SpringRabbitListener { @RabbitListener(queues = \u0026#34;fanout.queue1\u0026#34;) public void listenFanoutQueue1(String msg){ System.out.println(\u0026#34;Fanout1 接收消息：\u0026#34; + msg); } @RabbitListener(queues = \u0026#34;fanout.queue2\u0026#34;) public void listenFanoutQueue2(String msg){ System.out.println(\u0026#34;Fanout2 接收消息：\u0026#34; + msg); } } Direct 路由 Direct Exchange 会将接收到的消息根据规则路由到指定的 Queue，因此称为路由模式\n队列与交换机的绑定要指定一个 Routingkey，发送方发消息时也必须指定消息的 Routingkey，只有队列的 Routingkey 和消息的 Routingkey 完全一致，才会接收到消息\n在此使用基于注解声明队列和交换机，不需要配置类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 @Component public class SpringRabbitListener { @RabbitListener(bindings = @QueueBinding( value = @Queue(name = \u0026#34;direct.queue1\u0026#34;), // exchange = @Exchange(name = \u0026#34;hello.direct\u0026#34;, type = ExchangeTypes.DIRECT), // 因为默认为Direct类型，可以不用指定 exchange = @Exchange(name = \u0026#34;hello.direct\u0026#34;), key = {\u0026#34;red\u0026#34;,\u0026#34;warma\u0026#34;} )) public void listenDirectQueue1(String msg){ System.out.println(\u0026#34;1 接收消息：\u0026#34; + msg); } @RabbitListener(bindings = @QueueBinding( value = @Queue(name = \u0026#34;direct.queue2\u0026#34;), exchange = @Exchange(name = \u0026#34;hello.direct\u0026#34;), key = {\u0026#34;red\u0026#34;,\u0026#34;aqua\u0026#34;} )) public void listenDirectQueue2(String msg){ System.out.println(\u0026#34;2 接收消息：\u0026#34; + msg); } } 发送者\n1 2 3 4 5 6 7 8 9 10 public class SpringamqpTest { @Test public void testDirectExchange(){ // 交换机 String exchangeName = \u0026#34;hello.direct\u0026#34;; // 消息 String msg = \u0026#34;hello, aqua\u0026#34;; rabbitTemplate.convertAndSend(exchangeName,\u0026#34;aqua\u0026#34;,msg); } } 上例只有接收者 2 可以接收到消息，若 routingkey 为 red 则两个都能接收到消息\nTopic 话题 TopicExchange 与 DirectExchange 类似，区别在于 routingKey 必须是多个单词的列表，并且以 . 分割。\nQueue 与Exchange 指定 BindingKey 时可以使用通配符\n#：匹配一个或多个单词 *：只匹配一个单词 接收者\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @Component public class SpringRabbitListener { @RabbitListener(bindings = @QueueBinding( value = @Queue(\u0026#34;topic.queue1\u0026#34;), exchange = @Exchange(name = \u0026#34;hello.topic\u0026#34;, type = ExchangeTypes.TOPIC), key = \u0026#34;#.news\u0026#34; )) public void listenTopicQueue1(String msg){ System.out.println(\u0026#34;1 接受消息：\u0026#34; + msg); } @RabbitListener(bindings = @QueueBinding( value = @Queue(\u0026#34;topic.queue2\u0026#34;), exchange = @Exchange(name = \u0026#34;hello.topic\u0026#34;, type = ExchangeTypes.TOPIC), key = \u0026#34;china.#\u0026#34; )) public void listenTopicQueue2(String msg){ System.out.println(\u0026#34;2 接受消息：\u0026#34; + msg); } } 消息发送\n1 2 3 4 5 6 7 8 9 10 public class SpringamqpTest { @Test public void testTopicExchange(){ // 交换机 String exchangeName = \u0026#34;hello.topic\u0026#34;; // 消息 String msg = \u0026#34;news for China\u0026#34;; rabbitTemplate.convertAndSend(exchangeName,\u0026#34;china.news\u0026#34;,msg); } } 上例 1 和 2 都可以接收\n1 2 3 4 5 6 7 8 9 10 public class SpringamqpTest { @Test public void testTopicExchange(){ // 交换机 String exchangeName = \u0026#34;hello.topic\u0026#34;; // 消息 String msg = \u0026#34;news for Japan\u0026#34;; rabbitTemplate.convertAndSend(exchangeName,\u0026#34;japan.news\u0026#34;,msg); } } 只有 1 可以接收\n消息转换器 Spring 会把发送的消息序列化为字节发送给 MQ，接收消息时，把字节反序列化为 Java 对象，只不过默认情况下 Spring 采用的序列化方式是 JDK 序列化，其数据体积过大、有安全漏洞、可读性差\n可以使用 JSON 方式来做序列化和反序列化\n首先在父工程引入依赖\n1 2 3 4 5 6 \u0026lt;!-- JSON转换器 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.fasterxml.jackson.dataformat\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jackson-dataformat-xml\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.9.10\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 在消费者与接收者声明一个 bean 即可\n1 2 3 4 @Bean public MessageConverter jsonMessageConverter(){ return new Jackson2JsonMessageConverter(); } ","date":"2025-01-15T17:03:32+09:00","permalink":"https://blog.yexca.net/archives/217/","title":"SpringAMQP"},{"content":" MyBatis 系列\nMyBatis 安装与入门: https://blog.yexca.net/archives/215 MyBatis 使用: 本文\n删除 使用 #{} 为占位符，内部为参数名\n1 2 3 4 5 6 @Mapper public interface EmpMapper { // 删除 @Delete(\u0026#34;delete from mybatis.emp where id = #{id}\u0026#34;) public void delete(Integer id); } 测试\n1 2 3 4 5 6 7 8 9 @SpringBootTest class Mybatis02ApplicationTests { @Autowired private EmpMapper empMapper; @Test void contextLoads() { empMapper.delete(17); } } 一般不需要返回值，返回值为此次操作影响的行数\n1 2 3 4 5 6 @Mapper public interface EmpMapper { // 删除 @Delete(\u0026#34;delete from mybatis.emp where id = #{id}\u0026#34;) public int delete(Integer id); } 占位符 参数占位符有 #{} 和 ${}\n占位符 #{} ${} 形式 预编译 拼接 使用时机 参数传递、登录等 对表名、列表动态设置 优劣 安全，性能高 存在 SQL 注入问题 插入 (新增) 同样使用占位符，不过若传递的参数过多可以使用对象封装，形式参数名为对象的参数名\n1 2 3 4 5 6 7 @Mapper public interface EmpMapper { // 增加 @Insert(\u0026#34;insert into mybatis.emp(username, name, gender, image, job, entrydate, dept_id, create_time, update_time) \u0026#34;+ \u0026#34;values (#{username},#{name},#{gender},#{image},#{job},#{entrydate},#{deptId},#{createTime},#{updateTime});\u0026#34;) public void insert(Emp emp); } 测试\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 @SpringBootTest class Mybatis02ApplicationTests { @Autowired private EmpMapper empMapper; @Test public void testInsert(){ Emp emp = new Emp(); emp.setUsername(\u0026#34;Tom\u0026#34;); emp.setName(\u0026#34;汤姆\u0026#34;); emp.setGender((short) 1); emp.setImage(\u0026#34;tom.jpg\u0026#34;); emp.setJob((short) 1); emp.setEntrydate(LocalDate.of(2000,1,1)); emp.setDeptId(1); emp.setCreateTime(LocalDateTime.now()); emp.setUpdateTime(LocalDateTime.now()); empMapper.insert(emp); } } 获取主键值 某些情况下在数据添加成功后，需要获取插入数据库数据的主键\n1 2 3 4 5 6 7 8 9 @Mapper public interface EmpMapper { // 获取主键，第一个属性定义主键赋值在emp对象的id属性，第二个属性代表需要获取返回主键值 @Options(keyProperty = \u0026#34;id\u0026#34;, useGeneratedKeys = true) // 增加 @Insert(\u0026#34;insert into mybatis.emp(username, name, gender, image, job, entrydate, dept_id, create_time, update_time) \u0026#34;+ \u0026#34;values (#{username},#{name},#{gender},#{image},#{job},#{entrydate},#{deptId},#{createTime},#{updateTime});\u0026#34;) public void insert(Emp emp); } 更新 (修改) 与增加类似，可以封装到一个对象里\n1 2 3 4 5 6 7 @Mapper public interface EmpMapper { // 修改 @Update(\u0026#34;update mybatis.emp set username = #{username}, name = #{name}, gender = #{gender}, image = #{image}, job = #{job}, \u0026#34;+ \u0026#34;entrydate = #{entrydate}, dept_id = #{deptId}, update_time = #{updateTime} where id = #{id};\u0026#34;) public void update(Emp emp); } 测试\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 @SpringBootTest class Mybatis02ApplicationTests { @Autowired private EmpMapper empMapper; @Test public void testUpdate(){ Emp emp = new Emp(); emp.setUsername(\u0026#34;Tom2\u0026#34;); emp.setName(\u0026#34;汤姆2\u0026#34;); emp.setGender((short) 1); emp.setImage(\u0026#34;tom.jpg\u0026#34;); emp.setJob((short) 1); emp.setEntrydate(LocalDate.of(2000,1,1)); emp.setDeptId(1); emp.setUpdateTime(LocalDateTime.now()); emp.setId(19); empMapper.update(emp); } } 查询 查询有两种，根据 id 查询全部属性，根据条件查询\n根据 ID 查询 接口\n1 2 3 4 5 6 @Mapper public interface EmpMapper { // 根据ID查询 @Select(\u0026#34;select * from mybatis.emp where id = #{id}\u0026#34;) public Emp idSelect(Integer id); } 测试\n1 2 3 4 5 6 7 8 9 10 11 12 @SpringBootTest class Mybatis02ApplicationTests { @Autowired private EmpMapper empMapper; @Test public void testIdSelect(){ Emp emp = empMapper.idSelect(19); System.out.println(emp); } } 结果\n1 Emp(id=19, username=Tom2, password=123456, name=汤姆2, gender=1, image=tom.jpg, job=1, entrydate=2000-01-01, deptId=null, createTime=null, updateTime=null) 这样查询出来的因为类 Emp 与数据库的部分字段名字不同，从而结果为 null\n有三种方法解决\n使用别名 1 2 3 4 5 6 7 @Mapper public interface EmpMapper { // 方法一：别名 @Select(\u0026#34;select id, username, password, name, gender, image, job, entrydate, dept_id deptId, create_time createTime, update_time updateTime\u0026#34; + \u0026#34; from mybatis.emp where id = #{id}\u0026#34;) public Emp idSelect(Integer id); } 使用 @Results 注解 1 2 3 4 5 6 7 8 9 10 11 @Mapper public interface EmpMapper { // 方法二：@Results @Result 注解 @Results({ @Result(column = \u0026#34;dept_id\u0026#34;, property = \u0026#34;deptId\u0026#34;), @Result(column = \u0026#34;create_time\u0026#34;, property = \u0026#34;createTime\u0026#34;), @Result(column = \u0026#34;update_time\u0026#34;, property = \u0026#34;updateTime\u0026#34;) }) @Select(\u0026#34;select * from mybatis.emp where id = #{id}\u0026#34;) public Emp idSelect(Integer id); } 使用自动封装 如果字段名与属性名符合驼峰命名规则，可以开启驼峰命名自动封装，Mybatis 会自动通过驼峰命名规则映射，具体为数据库是下划线 a_column 映射到 Java 属性 aColumn\n开启驼峰命名需在 application.properties 加入\n1 mybatis.configuration.map-underscore-to-camel-case=true 然后直接使用最初的代码\n1 2 3 4 5 6 @Mapper public interface EmpMapper { // 根据ID查询 @Select(\u0026#34;select * from mybatis.emp where id = #{id}\u0026#34;) public Emp idSelect(Integer id); } 为了方便使用，可以在 IDEA 中安装 MyBatisX 插件\n根据条件查询 需求：根据员工姓名 (模糊匹配)、性别 (精准匹配)、入职时间 (范围) 搜索满足条件的员工信息\n1 2 3 4 5 6 7 8 @Mapper public interface EmpMapper { // 根据条件查询 // 注意此处name like \u0026#39;%${name}%\u0026#39; 使用的${}，可以在\u0026#39;\u0026#39;内使用 @Select(\u0026#34;select * from mybatis.emp where name like \u0026#39;%${name}%\u0026#39; and gender = #{gender} and \u0026#34; + \u0026#34;entrydate between #{begin} and #{end} order by update_time desc\u0026#34;) public List\u0026lt;Emp\u0026gt; conditionSelect(String name, short gender, LocalDate begin, LocalDate end); } 因为使用了插值，进行字符串拼接，所以此方法不安全\n1 2 3 4 5 6 7 @Mapper public interface EmpMapper { // 更安全的条件查询 @Select(\u0026#34;select * from mybatis.emp where name like concat(\u0026#39;%\u0026#39;,#{name},\u0026#39;%\u0026#39;) and gender = #{gender} and \u0026#34; + \u0026#34;entrydate between #{begin} and #{end} order by update_time desc\u0026#34;) public List\u0026lt;Emp\u0026gt; conditionSelect(String name, short gender, LocalDate begin, LocalDate end); } 使用了 concat 函数拼接字符串。测试\n1 2 3 4 5 6 7 8 9 10 11 12 @SpringBootTest class Mybatis02ApplicationTests { @Autowired private EmpMapper empMapper; @Test public void testConditionSelect(){ List\u0026lt;Emp\u0026gt; empList = empMapper.conditionSelect(\u0026#34;张\u0026#34;, (short) 1, LocalDate.of(2010, 1, 1), LocalDate.of(2020, 1, 1)); System.out.println(empList); } } 参数名说明 在 SQL 中使用的 #{} 中的变量名在 SpringBoot 2.x 以后的版本会被自动识别，但在 1.x 版本或者单独使用 MyBatis 时方法定义的变量名需要使用注解指定才可被识别\n1 2 3 4 5 6 7 8 9 10 11 @Mapper public interface EmpMapper { // 更安全的条件查询 @Select(\u0026#34;select * from mybatis.emp where name like concat(\u0026#39;%\u0026#39;,#{name},\u0026#39;%\u0026#39;) and gender = #{gender} and \u0026#34; + \u0026#34;entrydate between #{begin} and #{end} order by update_time desc\u0026#34;) public List\u0026lt;Emp\u0026gt; conditionSelect(String name, short gender, LocalDate begin, LocalDate end); } // 上述代码在1.x或单独使用MyBatis时不生效，函数要添加注解 public List\u0026lt;Emp\u0026gt; conditionSelect(@Param(\u0026#34;name\u0026#34;) String name, @Param(\u0026#34;gender\u0026#34;) short gender, @Param(\u0026#34;begin\u0026#34;) LocalDate begin, @Param(\u0026#34;end\u0026#34;) LocalDate end); 使用 XML 映射文件 如果 SQL 代码比较简短使用注解很方便，但若是 SQL 较长或复杂则会显得稍乱，为此可以使用 XML 映射文件。以下为规范\nXML 映射文件的名称与 Mapper 接口名称一致，并且将 XML 映射文件和 Mapper 接口放在相同包下 (同包同名) XML 中 namespace 属性为 Mapper 接口全限定名一致 XML 中 SQL 语句的 id 属性与 Mapper 接口中方法名一致，并且返回类型一致 XML 在 Maven 工程，非 Java 文件放在 src/main/resources 下，在此目录下创建与 Mapper 接口一致的目录\n如接口为 net.yexca.mapper.EmpMapper.java ，则 XML 文件在 net.yexca.mapper.EmpMapper.xml\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;https://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;!-- 上方头文件到官方网站寻找 --\u0026gt; \u0026lt;!-- namespace属性为接口 --\u0026gt; \u0026lt;mapper namespace=\u0026#34;net.yexca.mapper.EmpMapper\u0026#34;\u0026gt; \u0026lt;!-- id属性为方法名 --\u0026gt; \u0026lt;!-- resultType为单条记录所封装的类型 --\u0026gt; \u0026lt;select id=\u0026#34;conditionSelect\u0026#34; resultType=\u0026#34;net.yexca.pojo.Emp\u0026#34;\u0026gt; select * from mybatis.emp where name like concat(\u0026#39;%\u0026#39;,#{name},\u0026#39;%\u0026#39;) and gender = #{gender} and entrydate between #{begin} and #{end} order by update_time desc \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt; 接口类 1 2 3 4 @Mapper public interface EmpMapper { public List\u0026lt;Emp\u0026gt; conditionSelect(String name, short gender, LocalDate begin, LocalDate end); } 动态 SQL 动态 SQL 为随着用户的输入或外部条件的变化而变化的 SQL 语句\n例如上述最后一个条件查询，必须输入全部三个条件才能查询，可实际使用或许可以仅指定其中一两个或不指定 (查询全部)，如果按照上述指令执行将返回空结果\nwhere if 用于判断条件是否成立，使用 test 属性进行条件判断，如果条件为 true，则拼接 SQL\n例如，当姓名不为空时，拼接条件通过姓名查询\n1 2 3 \u0026lt;if test=\u0026#34;name!=null\u0026#34;\u0026gt; name like contact(\u0026#39;%\u0026#39;,#{name},\u0026#39;%\u0026#39;) \u0026lt;/if\u0026gt; 而 where 标签则管理是否生成 where 关键字并自动去除 and 和 or 关键字\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;select id=\u0026#34;conditionSelect\u0026#34; resultType=\u0026#34;net.yexca.pojo.Emp\u0026#34;\u0026gt; select * from mybatis.emp \u0026lt;where\u0026gt; \u0026lt;if test=\u0026#34;name!=null\u0026#34;\u0026gt; name like concat(\u0026#39;%\u0026#39;,#{name},\u0026#39;%\u0026#39;) \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;gender!=null\u0026#34;\u0026gt; and gender = #{gender} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;begin!=null and end!=null\u0026#34;\u0026gt; and entrydate between #{begin} and #{end} \u0026lt;/if\u0026gt; \u0026lt;/where\u0026gt; order by update_time desc \u0026lt;/select\u0026gt; set 替换 SQL 中 set 关键字，并自动去除多余的逗号，用于 UPDATE 语句中\n例如以下 SQL 语句修改为动态 SQL\n1 2 3 4 5 6 7 8 9 10 update mybatis.emp set username = #{username}, name = #{name}, gender = #{gender}, image = #{image}, job = #{job}, entrydate = #{entrydate}, dept_id = #{deptId}, update_time = #{updateTime} where id = #{id}; XML\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;update id=\u0026#34;update2\u0026#34;\u0026gt; update mybatis.emp \u0026lt;set\u0026gt; \u0026lt;if test=\u0026#34;username != null\u0026#34;\u0026gt;username = #{username},\u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;name != null\u0026#34;\u0026gt;name = #{name},\u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;gender != null\u0026#34;\u0026gt;gender = #{gender},\u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;image != null\u0026#34;\u0026gt;image = #{image},\u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;job != null\u0026#34;\u0026gt;job = #{job},\u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;entrydate != null\u0026#34;\u0026gt;entrydate = #{entrydate},\u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;deptId != null\u0026#34;\u0026gt;dept_id = #{deptId},\u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;updateTime != null\u0026#34;\u0026gt;update_time = #{updateTime}\u0026lt;/if\u0026gt; \u0026lt;/set\u0026gt; where id = #{id}; \u0026lt;/update\u0026gt; foreach foreach 标签用于遍历\n1 2 3 4 \u0026lt;!--遍历的集合 遍历出来的元素 分隔符 开始前后拼接的SQL片段--\u0026gt; \u0026lt;foreach collection=\u0026#34;ids\u0026#34; item=\u0026#34;id\u0026#34; separator=\u0026#34;,\u0026#34; open=\u0026#34;(\u0026#34; close=\u0026#34;)\u0026#34;\u0026gt; #{id} \u0026lt;/foreach\u0026gt; 假如 ids 为 [13, 14, 15]，以上将生成 (13,14,15)\n需求，遍历删除 id 为 1，2，3。SQL 语句为\n1 delete from emp where id in(1,2,3) 接口方法\n1 public void deleteByIds(List\u0026lt;Integer\u0026gt; ids); XML\n1 2 3 4 5 6 \u0026lt;delete id=\u0026#34;deleteByIds\u0026#34;\u0026gt; delete from mybatis.emp where id in \u0026lt;foreach collection=\u0026#34;ids\u0026#34; item=\u0026#34;id\u0026#34; separator=\u0026#34;,\u0026#34; open=\u0026#34;(\u0026#34; close=\u0026#34;)\u0026#34;\u0026gt; #{id} \u0026lt;/foreach\u0026gt; \u0026lt;/delete\u0026gt; 测试\n1 2 3 4 5 @Test public void testDeleteByIds(){ List\u0026lt;Integer\u0026gt; ids = Arrays.asList(13,14,15); empMapper.deleteByIds(ids); } sql 与 include 在开发过程中可能会出现大量重复的 SQL 语句，可以同 sql 标签定义可重用的 SQL 片段，再通过 include 标签重用\n1 2 3 4 5 6 7 \u0026lt;!-- 通过id属性唯一标识语句 --\u0026gt; \u0026lt;sql id = \u0026#34;commonCode\u0026#34;\u0026gt; \u0026lt;!-- SQL语句 --\u0026gt; \u0026lt;/sql\u0026gt; \u0026lt;!-- 通过refid属性指定引用的语句 --\u0026gt; \u0026lt;include refid = \u0026#34;commonCode\u0026#34; /\u0026gt; ","date":"2025-01-13T21:06:03+09:00","permalink":"https://blog.yexca.net/archives/216/","title":"MyBatis 使用"},{"content":" MyBatis 系列\nMyBatis 安装与入门: 本文\nMyBatis 使用: https://blog.yexca.net/archives/216 MyBatis 是一款优秀的持久层框架，用于简化 JDBC 的开发\nMySQL 安装 Windows 下载： https://dev.mysql.com/downloads/mysql/ 下载 ZIP Archive\n解压，环境变量配置 MYSQL_HOME PATH 路径 %MYSQL_HOME%\\bin\n以管理员权限打开 cmd，输入 mysql 检测是否配置成功\n初始化 MySQL 输入命令\n1 mysqld --initialize-insecure 等待一会，会在 MySQL 目录生成 data 文件夹\n注册 MySQL 服务 命令\n1 mysqld -install 启动 MySQL 服务 命令\n1 2 3 4 # 启动mysql服务 net start mysql # 停止mysql服务 net stop mysql 修改 root 密码 命令\n1 mysqladmin -u root password 1234 登录参数\n1 2 3 4 mysql -u 用户名 -p 密码 -h 要连接的 mysql 服务器的 ip 地址 (默认127.0.0.1) -P 端口号 (默认 3306) # 例如 mysql -u root -p # 执行后会提示输入密码 入门实例 首先创建 SpringBoot 工程，勾选 MyBatis Framework 与 MySQL Driver 依赖\n数据库 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 create database mybatis; use mybatis; create table user( id int unsigned primary key auto_increment comment \u0026#39;ID\u0026#39;, name varchar(100) comment \u0026#39;姓名\u0026#39;, age tinyint unsigned comment \u0026#39;年龄\u0026#39;, gender tinyint unsigned comment \u0026#39;性别, 1:男, 2:女\u0026#39;, phone varchar(11) comment \u0026#39;手机号\u0026#39; ) comment \u0026#39;用户表\u0026#39;; insert into user(id, name, age, gender, phone) VALUES (null,\u0026#39;白眉鹰王\u0026#39;,55,\u0026#39;1\u0026#39;,\u0026#39;18800000000\u0026#39;); insert into user(id, name, age, gender, phone) VALUES (null,\u0026#39;金毛狮王\u0026#39;,45,\u0026#39;1\u0026#39;,\u0026#39;18800000001\u0026#39;); insert into user(id, name, age, gender, phone) VALUES (null,\u0026#39;青翼蝠王\u0026#39;,38,\u0026#39;1\u0026#39;,\u0026#39;18800000002\u0026#39;); insert into user(id, name, age, gender, phone) VALUES (null,\u0026#39;紫衫龙王\u0026#39;,42,\u0026#39;2\u0026#39;,\u0026#39;18800000003\u0026#39;); insert into user(id, name, age, gender, phone) VALUES (null,\u0026#39;光明左使\u0026#39;,37,\u0026#39;1\u0026#39;,\u0026#39;18800000004\u0026#39;); insert into user(id, name, age, gender, phone) VALUES (null,\u0026#39;光明右使\u0026#39;,48,\u0026#39;1\u0026#39;,\u0026#39;18800000005\u0026#39;); application.properties 1 2 3 4 5 6 7 8 9 10 # 配置数据库连接信息 # 驱动类名称 spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver # 数据库连接的url spring.datasource.url=jdbc:mysql://localhost:3306/mybatis # 连接数据库的用户名 spring.datasource.username=root # 连接数据库的密码 spring.datasource.password=1234 User 类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 public class User { private Integer id; private String name; private short age; private short gender; private String phone; public User() { } public User(Integer id, String name, short age, short gender, String phone) { this.id = id; this.name = name; this.age = age; this.gender = gender; this.phone = phone; } public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public short getAge() { return age; } public void setAge(short age) { this.age = age; } public short getGender() { return gender; } public void setGender(short gender) { this.gender = gender; } public String getPhone() { return phone; } public void setPhone(String phone) { this.phone = phone; } @Override public String toString() { return \u0026#34;User{\u0026#34; + \u0026#34;id=\u0026#34; + id + \u0026#34;, name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, age=\u0026#34; + age + \u0026#34;, gender=\u0026#34; + gender + \u0026#34;, phone=\u0026#39;\u0026#34; + phone + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#39;}\u0026#39;; } } UserMapper 接口 1 2 3 4 5 6 @Mapper // 在运行时，会自动生成该接口的实现类对象(代理对象)，并且将该对象交给IOC容器管理 public interface UserMapper { // 此处采用注解编写SQL语句 @Select(\u0026#34;select * from user\u0026#34;) public List\u0026lt;User\u0026gt; list(); } 测试类 1 2 3 4 5 6 7 8 9 10 11 12 @SpringBootTest class MybatisStartApplicationTests { @Autowired private UserMapper userMapper; @Test void contextLoads() { List\u0026lt;User\u0026gt; list = userMapper.list(); list.forEach(System.out::println); } } 数据库连接池 数据库连接池是一个容器，负责分配、管理数据库连接 (Connection)\n它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个\n释放空闲时间超过最大空闲时间的连接，来避免因为没有释放连接而引起的数据库连接遗漏\n优势：资源复用、提升系统响应速度\n官方提供标准接口：DataSource\n常见产品：Hikari (SpringBoot 默认) 、Druid\nLombok 在上例中 User 类虽然只定义了几个属性，但需要很多方法从而使得代码臃肿，为此可以使用 Lombok\nLombok 是一个实用的 Java 类库，能通过注解的形式自动生成构造器、getter/setter、equals、hashcode、toString 等方法，并可以自动化生成日志变量，简化 java 开发、提高效率\n注解 作用 @Getter/@Setter 为所有的属性提供 get/set 方法 @ToString 会给类自动生成易阅读的 toString 方法 @EqualsAndHashCode 根据类所拥有的非静态字段自动重写 equals 方法和 hashCode 方法 @Data 提供了更综合的生成代码功能 (@Getter+@Setter+@ToString +@EqualsAndHashCode) @NoArgsConstructor 为实体类生成无参的构造器方法 @AllArgsConstructor 为实体类生成除了 static 修饰的字段之外带有各参数的构造器方法 引入 Lombok 引入依赖，不需要版本号，已经被 SpringBoot 设定\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; User 类 1 2 3 4 5 6 7 8 9 10 @Data @NoArgsConstructor @AllArgsConstructor public class User { private Integer id; private String name; private short age; private short gender; private String phone; } Lombok 会在编译时，自动生成对应的 Java 代码，使用 Lombok 需要安装一个插件，不过 IDEA 默认已安装\n","date":"2025-01-12T23:59:48+09:00","permalink":"https://blog.yexca.net/archives/215/","title":"MyBatis 安装与入门"},{"content":" 音有所感系列 歌曲名 翻译 链接 僕が死のうと思ったのは 曾经我也想过一了百了 本文 あくあ色ぱれっと aqua 的调色盘 https://blog.yexca.net/archives/219 恋の押し売り 恋爱推销 https://blog.yexca.net/archives/220 17さいのうた 17 岁的歌 https://blog.yexca.net/archives/224 drop 坠入爱河 https://blog.yexca.net/archives/230 生きるを選んだ私へ 致选择活下去的自己 https://blog.yexca.net/archives/239 rainy lady 雨意未晴 https://blog.yexca.net/archives/249 恋しくなったら手を叩こう 想谈恋爱的话就拍拍手吧 https://blog.yexca.net/archives/250 引言 有没有一种听力材料，可以让人不是处于学习的状态，可以反复听，并可以尝试影子跟读的呢。这不就是歌曲吗！\n考虑到我听歌时候只是部分能听懂，如果深入分析了解歌词的话，说不定真的可以当成对语言的练习了\n第一首就从一个虽然有点沉重，但可以说陪伴了我大部分时间，我可以百听不厌的歌曲开始吧\n2025.05.26 唱了这首歌，虽然是原唱 中岛美嘉 的版本，虽然自己睡觉心里哼唱无数次，实际唱出来的时候还是感觉不一样啊 (未防止人像有版权而打马赛克，因为不是原版就随便拍了一张)\n2025.06.06 和别人提起到这首歌，晚上不小心想到了就搜了下，结果看到了 浑元 的唢呐 \u0026ldquo;翻唱\u0026rdquo;，好奇心驱使点了进去，第一条评论我真的当时就泪目了\n我曾经也想过一了百了\n可是我了不起\n哈哈，这句幽默感真的了不起啊，えらいね，虽然我现在已经没这么极端的情绪了，但还是被暖到了，尤其是日文翻译的 \u0026ldquo;えらい、えらい\u0026rdquo;，关键词联想了属于是\n歌曲视频 由于 bilibili 的嵌入式体验不好，改为 Youtube 的，鹿乃 有官方账户，本歌曲视频: BV1zr4y1n7sM\n歌词 僕ぼくが死しのうと思おもったのは　ウミネコが桟さん橋ばしで鳴ないたから\n我之所以想过一了百了，是因为黑尾鸥在码头啼鸣\n波なみの随意ずいいに浮うかんで消きえる　過去かこも啄ついばんで飛とんでいけ\n随波浮沉又消逝，连过去也一并啄起飞向远方\n僕ぼくが死しのうと思おもったのは　誕生日たんじょうびに杏あんずの花はなが咲さいたから\n我之所以想过一了百了，是因为生日时杏花开了\nその木こ漏もれ日びでうたた寝ねしたら　虫むしの死し骸がいと土つちになれるかな\n在那洒落的日影下小憩，是否能化作虫的遗骸与黄土呢\n薄荷はっか飴あめ　漁港ぎょこうの灯台とうだい　錆さびたアーチ橋ばし　捨すてた自転車じてんしゃ\n薄荷糖、渔港的灯塔、生锈的拱桥、被抛弃的自行车\n木造もくぞうの駅えきのストーブの前まえで　どこにも旅たび立だてない心こころ\n木造车站炉火前，踏不出旅途的心\n今日きょうはまるで昨日きのうみたいだ　明日あすを変かえるなら今日きょうを変かえなきゃ\n今天就好像昨天一样，想改变明天的话要从今天开始\n分かってる　分かってる　けれど\n我知道啊，我明白啊，可是。。。\n僕ぼくが死しのうと思おもったのは　心こころが空からっぽになったから\n我之所以想过一了百了，是因为内心已经空寂了\n満みたされないと泣ないているのは　きっと満みたされたいと願ねがうから\n因空虚而哭泣，无非是渴望被填满\n僕ぼくが死しのうと思おもったのは　靴紐くつひもが解ほどけたから\n我之所以想过一了百了，是因为鞋带松开了\n結むすびなおすのは苦手にがてなんだよ　人ひととの繋つながりもまた然しかり\n重新系上很麻烦，人际关系也同样如此\n僕ぼくが死しのうと思おもったのは　少年しょうねんが僕ぼくを見みつめていたから\n我之所以想过一了百了，是因为少年注视着我\nベッドの上うえで土下座どげざしてるよ　あの日ひの僕ぼくにごめんなさいと\n在床上向我土下座，对那天的自己说抱歉\nパソコンの薄うす明あかり　上階じょうかいの部屋へやの生活音せいかつおん\n电脑屏幕的微光，上层房间的生活声\nインターフォンのチャイムの音おと　耳みみを塞ふせぐ鳥とりかごの少年しょうねん\n门铃的声音，捂住耳朵的笼中少年\n見みえない敵てきと戦たたかってる　六畳ろくじょう一間ひとまのドンキホーテ\n在六畳房间的堂吉诃德，与无形之敌在战斗着\nゴールはどうせ醜みにくいものさ\n终点反正是丑陋的\n僕ぼくが死しのうと思おもったのは　冷つめたい人ひとと言いわれたから\n我之所以想过一了百了，是因为被人说成冷漠无情\n愛あいされたいと泣ないているのは　人ひとの温ぬくもりを知しってしまったから\n因渴望被爱而哭泣着，是因为已尝过人间冷暖\n僕ぼくが死しのうと思おもったのは　あなたが奇麗きれいに笑わらうから\n我之所以想过一了百了，是因为你的笑容如此温暖\n死しぬことばかり考かんがえてしまうのは　きっと生いきる事ことに真面目まじめすぎるから\n总想着死亡，一定是活得太较真了吧\n僕ぼくが死しのうと思おもったのは　まだあなたに出会であってなかったから\n我之所以想过一了百了，是因为未曾遇见你\nあなたのような人ひとが生うまれた　世界せかいを少すこし好すきになったよ\n正因为有你这样的人会诞生，才会有点喜欢这个世界\nあなたのような人ひとが生いきてる　世界せかいに少すこし期待きたいするよ\n正因为有你这样得人存在着，才会对世界有些许期待\n","date":"2025-01-11T01:10:51+09:00","permalink":"https://blog.yexca.net/archives/214/","title":"音有所感 - 《僕が死のうと思ったのは》"},{"content":"Python 打包是根据当前系统环境的，Windows 下是打包出 exe 可执行程序，Linux 下打包出 ELF 格式的二进制文件，不支持跨平台打包\n安装 通过 pip 安装\n1 pip install pyinstaller 打包为单文件 使用参数 --onefile\n1 pyinstaller --onefile main.py 常用参数 对于 Windows 程序的打包，常用参数有\n--windowed: 不显示终端窗口 (如果是自己实现 GUI 的话) --icon=icon.ico: 为程序添加图标 --hidden-import: 显示指定需要的依赖包 (避免自动分析遗漏) --add-data: 添加额外的资源文件到打包中 --debug: 启用调试信息 打包为多文件 打包为多文件时，使用 --onedir 参数\n1 pyinstaller --onedir main.dy 依赖文件会放在 _internal 文件夹下，非常不友好\n仅 pyinstaller 6.1.0 以上版本可以使用该参数\n1 pyinstaller --contents-directory . .\\main.py 这样打包的依赖和入口就在一个目录\n打包配置项 假设现在工程的配置放在 project/conf/settings.json\n打包时想把这个文件也包含，首先打包为多文件\n1 pyinstaller --name my_program --contents-directory . .\\main.py 会在当前目录生成 my_program.spec 文件，修改 a 的 data，以元组的方式将想打包的文件输入，如\n1 datas=[(\u0026#39;conf/settings.json\u0026#39;, \u0026#39;conf/\u0026#39;)], 然后删除 dist/ 文件夹下所有文件后运行命令 (不删除也行，后面问题同意即可)\n1 pyinstaller my_program.spec 项目 通过这种方法，把 https://blog.yexca.net/archives/211 的软件现在已经打包为可执行程序了 (虽然还是没做错误处理)\n参考文章 https://www.cnblogs.com/yqbaowo/p/17863429.html ","date":"2025-01-07T17:26:09+09:00","permalink":"https://blog.yexca.net/archives/213/","title":"Python pyinstaller 打包"},{"content":"引言 今天想对最近设计的半透明、毛玻璃和圆角进行总结来着，突然想到 2023-12-01 貌似做过一个什么东西，这便顺便也重整一下得了\n页面背景 现代的 (二次元) 网页要有一个背景\n1 2 3 4 5 6 7 8 body{ background-image: url(\u0026#39;../img/77194247_p0.jpg\u0026#39;); background-size: cover; background-attachment: fixed; /* 固定 */ background-repeat: no-repeat; /* 不重复 */ padding: 0; margin: 0; } 半透明与毛玻璃 然后在背景上加一个蒙版，实现半透明与毛玻璃效果\n1 2 3 4 5 6 7 8 9 10 11 .layout { /* display: flex; */ margin: 0; padding: 0; display: flex; width: 100vw; height: 100vh; backdrop-filter: blur(2px); /* 背景模糊效果 */ -webkit-backdrop-filter: blur(2px); /* Safari 支持 */ background: rgba(0, 0, 0, 0.4); /* 半透明黑色背景 */ } 网页的重构 说起来写文章还是很烦恼的，做的时候写会打扰，做完写又会很累不想写，所以我折中下，随便写写就好\n项目地址: https://github.com/yexca/MusicPlayer-Twinkle 顺便更新了下之前的文章 https://blog.yexca.net/archives/116/ 用此方法加了个示例: https://twinkle.yexca.net 2025-02-26: 我翻到当时是参考哪里啦: https://blog.csdn.net/Wang_x_y_/article/details/123693127 卡片效果 这也属于现代的设计\n1 2 3 4 5 6 7 8 9 10 .card { width: 300px; padding: 20px; background-color: rgba(255, 255, 255, 0.5); /* 半透明白色背景 */ border-radius: 15px; /* 圆角 */ box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); /* 阴影 */ backdrop-filter: blur(10px); /* 背景模糊效果 */ border: 1px solid rgba(255, 255, 255, 0.3); /* 边框 */ color: pink; /* 前景文字颜色 */ } 嗯，之后有时间以卡片为设计完善此项目 (又开新坑)\nTwinkle 另外项目的内容为 Twinkle 的音乐，具体介绍可见\nhttps://twinkle130527.wixsite.com/twinkle https://www.dojin-music.info/circle/1255 SoundCloud\nhttps://soundcloud.com/twintwinkles ","date":"2025-01-05T16:19:36+09:00","permalink":"https://blog.yexca.net/archives/212/","title":"毛玻璃效果"},{"content":" 2025-05-18 更新\n我写了个 SQLite 版的，不用配置数据库了，详情访问: https://blog.yexca.net/archives/248 耗时三天写出来了个大概能用的版本，不过没有做错误处理 遇到错误直接重启吧\n项目地址: https://github.com/yexca/PixivDownloader-MySQL 引言 这要从 数据库记录已下载画师作品 开始说起了，当时我整了个数据库记录我下载过的作品，时间久了之后，觉得这玩意是在做重复作业啊，说到重复作业那必然是计算机来做啊，正好最近不经意间产生了做程序的想法，也正好对其不满意: https://github.com/yexca/yasumiProject ，同时又是过年比较空闲，这就开写\n说明 虽说我是写出来了，不过没有错误处理之类的，只能说勉强能用吧。同时代码很乱 (第一次开发比较大的 GUI 软件啦)，乱到我不想去整理和做国际化支持了\n并且开发过程中突然想到都写程序了为什么不用 SQLite 呢，这还要开一个 MySQL 多麻烦，不过都做了，就做到最后吧\n最后本来想打包的，因为使用配置文件，打包好麻烦 (刚开始不知道打包出来被 Windows 当病毒了来着)，我实在懒得折腾了，就这样吧\n界面 背景图: https://www.pixiv.net/artworks/83273073 首页 设置 配置 因为基于我现有数据库开发，所以几乎没有自定义程度，数据库建表语句为\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 CREATE TABLE pic ( ID varchar(99), # 唯一标识 name varchar(255), # 画师昵称 downloadedDate datetime, # 下载/更新时间 lastDownloadID varchar(255), # 最新作品ID platform varchar(50), # 平台 url varchar(255), # 链接 PRIMARY KEY(ID) )ENGINE=InnoDB DEFAULT CHARSET=utf8mb4; 然后因为 API 的使用需要登陆并且不可以用账号密码登录，根据 https://gist.github.com/ZipFile/c9ebedb224406f4f11845ab700124362 获取 Auth Token 后使用\n背景图片我并没有上传到 git 仓库，路径为 app\\resources\\images\\background.png\n然后是需要安装 Python，安装依赖\n1 pip install -r requirements.txt 使用 运行程序\n1 python main.py 在 Pixiv 验证界面 和 设置 界面完成相关配置后返回首页\n填入画师 ID 或者 某一作品的 ID 就会自动爬取该画师全部作品了\n结尾 我其实都觉得自己都不去使用它，这算是我开发经历的一小步吧\n","date":"2025-01-03T20:05:44+09:00","permalink":"https://blog.yexca.net/archives/211/","title":"Pixiv 下载器"},{"content":"引言 此文写给我自己看，说是 2024 总结，但也是记录近年的生活感悟与心路历程。文笔不是很好，想表达的东西还有很多，但是不知道怎么整合在一起，就这样吧\n从 2020 到 2024 的经历 从 2020 年开始，慢慢地总是觉得时间过得好快，哪怕是经历了很多事情，也不会找到 2020 以前的那种可能是认真过每一天或者会觉得时间漫长的感觉。但是当我以客观的角度来分析时，事实上每一年我都经历了许多的事情，也做过不少的事，尤其是今年我经历的也可谓是相当之多\n2020 这年高考，之后我开始了第一次远离家乡的生活，大学生活时加入了社团，参加不少活动来着 2021 上半年参加不少社团活动，下半年我更换了手机进入苹果生态、转专业、建立本博客 2022 我在 Switch OLED 刚出时溢价购买并玩得不亦乐乎，同年购入 Quest2 开启 VR 旅途，并编写了一些 VRChat 教程，同时还在年末去了南京市游玩 2023 这一年换校区了，开始参加一些二次元活动，如原神和必胜客、喜茶的联动，后期学校放开也是逛了逛周边地区，参加了软考和日语能力考试，购买了 Google Pixel6 以及开始迷上办卡 2024 这应该是我最精彩的一年，年初开始去深圳实习，在此期间逛 Costco 在深圳的新店、第一次看海、认识到了许多很好的人、逛了华强北、去了香港、逛了澳门、第一次坐船等，我的思想也逐渐转变，回学校、毕业回家后对于他人的态度也有转变，开始和我的家人交流，和家人去了徐州游玩，开始尝试做饭，自己 DIY 物品，考取驾照等，这之后还去了日本，第一次坐飞机，第一次穿二次元衣服出门、第一次参加漫展 (C105) 等等 可以说我经历的事情是逐年增多，但我的主观感受还是“时间过得很快，我并没有做过什么事情”，这不免使我产生困惑\n对于生活的理论解释 注意：提及理论纯个人想象，并没有经过验证分析，谨慎相信\n事实上，在 2023 后半年的时候本来应该备考考研的我却眼睛很痛，每天睁眼的时间几乎不能超过 4 小时，因此那段时间我几乎是天天躺在床上在半睡半醒中产生了一种解释生活的理论，于是我开始沉迷于解释生活\n状态行为理论 我甚至为这些理论进行了命名，最开始产生的是状态行为理论，我把可以影响人的行为的各种影响因素当成可以被量化的变量 (如情绪的喜怒哀乐、信息的掌握程度、经历的事情、当下周围的影响因子等)，这些变量有不同的权重，掌握大部分变量可以较高准确率预测一个人的行为，之后对其进行推论到如果知道每一个人的变量值，那么每个人的人生其实是确定的\n当然该理论不是直接演变成这样的，刚开始的三四天只是畅想，某一天突然意识貌似我想的东西和 Unity 的 State Behaviors 重合，以此命名。之后对一些事情进行分析后演变成大概这个样子\n圈理论 同时为了帮助确定一定的影响因素，我想出了圈理论来表示一个人受到他人的影响。这本身也是我对于互联网的思考，源于当我从对单个东西的深度探索变成了对各种东西的广度探索时，我发现一个很奇怪的现象，网络的人群可以根据对于什么的喜好或者关注而划分为一个有一个圈，每个圈里貌似有一种自圆其说的理论，同时可能会有相较于普通来说很震惊但圈内很平常，相较于普通来说很平常，但圈内很震惊的事情，并且存在对立的圈子，也就是其自圆其说出这里很好，其余很不好，尽管在另一边是相反的。当然并不可能所有的圈子都是孤立的，部分可以进行同类化到一个集合，一般可以直接以集合的行为代表其下方的行为\n虽然不是一个东西，但可以类比信息茧房下，人们更多的见到自己想见到的东西，又因为世界上人很多，总可以找到类似的观点的人，然后在这个茧房里不断加深自己的理解，从而形成自圆其说的解释\n当然这可能只是基础结论，要想解释这个复杂的世界不能每次都使用基础结论，应该使用一定的推论或者辅助结论\n名句的解释 比如为什么会觉得名人名言很有道理。基于状态行为理论或者可能推广到对万物的解释，也就是世界的东西有一个根父类，其演变出很多子类，以此类推到子抽象类，可能他们经历了一定的事情实际上是某抽象类的实现，以此总结抽象出一句话，然后我们的某些经历可能是这个抽象类的另一种实现，就会觉得这个名言好有道理\n稍微严谨来说，这基于因为人类历史的记载太多了，几乎任何选择都有人做过 (不一定是那件事，而是抽象成那件事)，于是无论对于任何事情都可以给出正面支持和反面教训，因此我并不认为世界上有绝对正确或绝对错误的事情，只是在某些状态或场合下相对正确或错误\n信任解释理论 再比如最近喜欢的信任解释理论。我觉得世界是基于信任运行的，比如在过马路的时候信任司机不会突然开车撞向我、走在路上迎面而来的人不会掏出到来刺伤我等等，这可能是比较平常或者习惯的事情基于普遍的信任\n当然，这将近一年半的时间里还考虑过很多其他理论解释，但不是太记得了\n理论与实践的割裂 偶尔我也会想，如果能像孩子一样随心所欲地做自己喜欢的事，会不会感到更多的自由？但转念一想，这个孩子或许早已被我埋葬在规则的泥土之下\n虽然很多的生活问题都可以解释了，但是这还是没有帮助我走出这种经历，甚至慢慢开始产生了负面效果\n随着解释的增多，我也不是突然意识到，应该是慢慢感受到我可能就是太沉浸于解释了，而忘了生活往往是结果，我却一直想着哪种选择产生哪种结果，虽然事前把所有可能性想好固然经历会更美好，但是正因为把所有的可能都分析了，实际在经历的时候就和玩游戏跳过 NPC 对话似的，只等别人说出自己提前想到的某可能的话，然后选择一种可能性回复，慢慢地对于生活就会厌倦\n于是我开始去尝试娱乐，散步、购物、跑步、旅行、玩游戏等，明明拥有选择的自由，却总觉得自己被附加了某种无形的锁链。哪怕是娱乐，也像完成任务一般，更多是为了达成心理上的‘数值平衡’，而非真正的放松与快乐。我的生活仿佛变成了一场模拟游戏，面对压力时，我会按照既定规则寻找降低压力的方式，比如“安排娱乐”。我对自己的生活可能也进行了量化，觉得某件事情产生了多少压力，我需要做些什么降低压力，但这些娱乐活动却不是真正为我带来快乐的事，而是执行一种被普遍认为有效的“压力缓解”方案。这让我想起被安排娱乐的孩子，乍看他们在玩游戏或参加活动，却未必是发自内心的热爱。我现在的状态似乎和他们没有区别，只不过安排的人和被安排的人都是我自己\n我是自己生活的设计者，同时也是执行者，仿佛自己安排的剧本，只是为了完成任务，却失去了内在的情感联结\n我开始慢慢觉得自己身上有附加的锁链，我做任何事情都要在一个特定的规则下，只要是做了除开这件事以外的东西就是不好，或者不行。亦或者我在寻求一个认可，只要我这样做了就会被认可，那样做了一定不被认可\n这是否也是陷入了一个圈理论的圈中呢，解释出这些的我其实也是另一种解释一部分，就好比我认为世界的理论是一个一个数轴上的点，然后我把这些穿起来解释出了数轴，但是我本身也被二维坐标系所解释着\n由于 bilibili 的嵌入式体验不好，改为 Youtube 的，鹿乃 有官方账户，本歌曲视频: BV1zr4y1n7sM\n我怀疑过自己应该是抑郁症了，甚至规划过如何自杀，写到这里突然想到《僕が死のうと思ったのは (曾经我也想过一了百了)》这首歌的一句歌词“死ぬことばかり考えてしまうのは (只考虑这自杀的事情的话)　きっと生きる事に真面目すぎるから (一定是对于活着的事情太认真了吧)”，是啊，正如歌词所写，我是否是对于生活过于认真了呢\n同时这首歌的其他地方也让我有所联想，比如 \u0026ldquo;今日はまるで昨日みたいだ (今天就好像昨天一样)\u0026quot;，是啊，尽管每天都经历不一样的事情，但是在思想上我觉得这就是理论产生的结果，理论并没有改变，生活也没有改变\n“見えない敵と戦ってる (一直和看不见的敌人在战斗)” ，我在和谁战斗呢，仿佛就是我创造出来的规则的负面，也是我内心的不确定感和对悲伤的固执\n“明日を変えるなら今日を変えなきゃ (要想改变明天的话就要从今天开始改变)　分かってる (我知道啊)　分かってる (我明白啊)　けれど (可是。。)”，可是我可以改变什么呢，基于理论的印象，就算向他人诉说，他人给出了见解，哪怕是说动了我，我也还是会一成不变得按照自己悲伤的观点度日\n“僕が死のうと思ったのは (我之所以想一了百了是因为)　冷たい人と言われたから (被说是冷漠的人)”，但是我明明是按照应该会很有趣的人的样子做出的回应啊\n“愛されたいと泣いているのは (因为想要被爱而哭泣)　人の温もりを知ってしまったから (因为我开始懂得人情世故)”，他们的关心都是基于对他人的尊重或者礼仪如此，并不是真的关心我，我也只是礼貌机械的回复，没有任何情感\n“僕が死のうと思ったのは (我之所以想一了百了是因为)　まだあなたに出会ってなかったから (还没有和你遇到)　あなたのような人が生まれた (正因为你这样的人会出生)　世界を少し好きになったよ (我才会变得喜欢这个世界啊)　あなたのような人が生きてる (正因为你这样的人存在着)　世界に少し期待するよ (我才对世界有些许期待哟)”，但是我把自己寻求帮助、他人的见解也运用理论去解释，那是一种必然产生的结果，仿佛我去调用一个接口，输入一定内容就会返回我什么内容，只要我这样做就会获得什么，太确定了\n但生活往往是不确定的，我慢慢也会对不确定的事情进行恐惧，同样的，为了消除恐惧，我开始完善之前对于生活的理论，慢慢地增加子理论去解释，这也暂时缓解了我一定地恐惧，但是人是不可能绝对理性的，第一反应本能地还是会出于感性，我的理论也会有这一点存在，理性控制着我这只是暂时的，从结果来看，时间会把伤口抚平\n从解释到行动的转变 时间像流水，不断流逝，而我却仿佛在岸边计算水量，却忘了去触摸水的温度\n我为自己打造了一套看似理性的框架，却逐渐成为它的囚徒。即使有完全的自由选择权，也总是带着无形的束缚感，这个理论的最大问题在于，它过于强调逻辑与规则，忽略了情感和体验的部分。我仿佛是一个算法，为自己设定了行动规则，却在执行过程中发现，我应该表达自己的感受。这是一个漫长的转变过程，不过对于我来说是解释可以立马转变，但是思想或者行动却很难转变，在理论的思维固化下，我很难去转变从事物本源解释的角度看待问题\n我首先意识到自己对理论的依赖开始有负面效果，虽然当我产生这个想法的时候也是可以被自己的理论所解释，因为我会用它解释一切，包括它自己。但同时人是可以转变的，因为受到的变量的影响，多个变量的累计，权重不断加大，开始促使我转变\n首先应该是我接触的人变多了，固步自封，自我封闭虽然不会受到人际关系的伤害，但也使得自己接触面变得局限。其实也正感谢我的理论，它让我先拥有迈出去的第一步，因为可能在内向的心里和别人交流很麻烦，但理论的思维是不违法不违规，我可以有这种选择，我只是做了一个和别人交流的选择而已。从遇到的第一个性格很好的人开始，逐步认识更多的人，我慢慢地产生了性格的转变\n因为接触面变广，可以对世界进行更深层次的思考，从而完善了理论，这种完善的理论使得我可以产生更多选择的可能性 (虽然有负面的比如更多的恐惧)，但正如高风险高收益一样，事物伴随着一定的代价\n这之后就是慢慢尝试变多后，我可以说是去验证了理论吧，从空想到验证的调整，使得我可以更清楚知道某项选择后果的个人感受程度，正因为这种对感受的重视，把我从量化拉回\n当然这远远不够，因为感受也是可以量化的，上个月我练习听力的时候听到一个对话\nA: 这两个哪个更好\nB: 甲挺不错\nA: 乙不会更好吗(并解释了理由)\nB: 明明已经有了结论还来问我干什么\n尽管只是比较日常的对话，但它多次在我脑中回想，确实，多数时候我可能知道大概怎么做，并且有一定的决定，但是我不去行动，只是反复确认可能性，力图找出所有分支，让我活在确定中，甚至不是找最优解。这段对话事实上是对于我一种确定的回复产生一种不确定的可能 (我知道这话很怪，只是我不会表达这种感受)，亦或者唤起了选择的意义是获得自己想要的结果\n再或者说，可能只是我并没有什么目标，没有根据自己的情感、需求确定的目标，只是根据一定的可能性创造出来的目标，创造出来的我并不喜欢的目标\n我开始尝试增加自己感受的变量，我要把自己喜欢的事物的权重拉高，理论是解释生活，帮助人类理解世界的，它不是支配者，我不应该被支配，我应给是使用它以达到我喜欢的目标，我喜爱的生活！\n现状 我可以自由表达，我可以自由行动 (不违反法律规则的话)，这篇文章的出现也表达了我在慢慢冲破枷锁，因为我之前觉得这是一件很丢人的事情，不去记录我的理论，所以事实上部分子理论也就忘了\n我意识到活着是一个过程，这是一个无法改变的事实，正如我之前对朋友说过的一句话“既然无法改变，只能去适应”，生活中会遇到各种各样的人，美好的也有，不幸的也有，往往当我们陷入悲伤的时候，那是不幸的东西累计太多，或许冲昏了头脑，而忘记了自己所拥有的美好事物\n正如 关于页面 写道，“无论何时都要盛装登场，每段经历都是全心投入”，对于世界来说，我只是一个个体，一个数字，但对于我来说，我就是整个世界！\n“ 万物皆浮云，只要好心情 ”，激活自己的 Atopes ，做自己热爱的事吧，买自己喜欢的东西吧，去自己想去的地方吧。不用考虑太多，大胆表达自己吧\n我现在就想到了 https://github.com/RimoChan 的头像，真正去热爱自己的生活，快乐也是活一天，痛苦也是活一天，没必要内耗啦\n结尾 明年会怎么样呢，我觉得可以以我博客的介绍结尾\n把这个不美好的世界，编程我所期望的样子吧！\n","date":"2024-12-31T17:40:09+09:00","permalink":"https://blog.yexca.net/archives/210/","title":"2024 年度总结"},{"content":"引言 随着对于信息的浏览增多，往往会有对于其他语言的文章书写需求 (同时现代的作品几乎都是多语言支持)，同时又因为好像自从毕设当时加了个多语言支持，之后做的东西或者设计的东西往往都会想要去进行国际化支持，就 最近写的一个相当于练手的东西 也整了多语言支持捏 (不过这并不是我想要的效果，太古老了，想做一个现代点的，另外 在做啦 ，希望可以坚持做完)\n回过头来看看我的博客，这个陪伴我最久的作品，它还没有国际化，虽然也有一般都是写简体中文文章的原因啦， 之前的博客 界面部分中文部分英文实际上整的多少有点混乱了，虽然我个人可以看懂，但对于非相关人士可能就会感到疑惑\n但原先的 Jekyll 我折腾半天愣是没成功多语言，转向原生支持国际化的 Hugo 啦。不过每个主题都有其特色，这个主题对于分类与标签和上个主题区别很大，之后慢慢修改适应才行\n这篇文章写的很潦草吧，主要它的配置貌似很依赖主题，我也几乎都是根据主题的示例改的，所以也没什么好写的我觉得 (因为官方文档也很丰富)\n环境 使用 Docker 有 Hugo 的容器，所以环境问题没怎么折腾 (使用的东西可以看 这里 呢)\n创建博客 创建新博客\n1 hugo new site blogName 进入目录\n1 cd blogName 初始化仓库\n1 git init 安装主题，这里使用 hugo-theme-stack 主题，其他同理\n1 git submodule add https://github.com/CaiJimmy/hugo-theme-stack/ themes/hugo-theme-stack 配置 hugo.toml 选择主题\n1 theme = \u0026#39;hugo-theme-stack\u0026#39; 预览\n1 hugo server 包含草稿 (draft) 的预览\n1 hugo server -D 部分修改可能需要清除缓存才能生效 (比如配置项、页面的修改)\n1 hugo --cleanDestinationDir 构造网站，默认构造文件在 public 下\n1 hugo 多语言支持 在站点配置文件 (我使用 yml 配置) 配置默认语言\n1 2 defaultContentLanguage: \u0026#39;zh-cn\u0026#39; # 默认语言代码 defaultContentLanguageInSubdir: false # 默认语言路径是否带语言代码 然后配置具体语言项目\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 languages: zh-cn: contentDir: \u0026#39;content/zh-cn\u0026#39; # 文章在哪个目录 disabled: false languageCode: \u0026#39;zh-cn\u0026#39; languageDirection: \u0026#39;ltr\u0026#39; # 文章从左到右 (ltr) 还是从右到左 (rtl) languageName: \u0026#39;简体中文\u0026#39; title: \u0026#34;yexca\u0026#39;Blog\u0026#34; weight: 1 zh-tw: contentDir: \u0026#39;content/zh-tw\u0026#39; disabled: false languageCode: \u0026#39;zh-tw\u0026#39; languageDirection: \u0026#39;ltr\u0026#39; languageName: \u0026#39;繁體中文\u0026#39; title: \u0026#34;yexca\u0026#39;Blog\u0026#34; weight: 2 字体国际化: https://blog.yexca.net/archives/240 文章撰写 不同于 Jekyll，Hugo 的文章撰写稍微有点复杂，同时加上国际化支持，使得文章更加复杂 (复杂的好处是自定义程度高)，这点可能根据不同主题不一样，我说下我用的，首先上方语言项目配置指定了文章的目录，需要在 content 创建相应目录，然后该语言的文章就在该目录下写作\n同时，指定文章是在哪个目录下，stack 主题配置文件中可以指定\n1 2 3 params: mainSections: - posts 这就表明我简体中文的文章应该放在 content/zh-cn/posts 里，然后还有一些目录是主题指定的，可以看对应主题示例\n现在要写创建一个简体中文的新文章可以使用\n1 TZ=\u0026#34;Asia/Tokyo\u0026#34; hugo new content/zh-cn/posts/test.md 不指定时区的话默认使用 UTC 时间 (虽然可以自己改，但习惯了 Jekyll 自动创建的我觉得自己写时间很麻烦)\n文章默认创建模板在 blogName/archetypes 下，可以改为 yml 格式\n参考文章 Hugo - Quick start https://stack.jimmycai.com/guide/ Hugo - Multilingual mode ","date":"2024-12-27T23:11:45+09:00","permalink":"https://blog.yexca.net/archives/209/","title":"用 Hugo 进行博客国际化支持"},{"content":"简单 (非技术框架) 实现的 Go 后端\n~~众所周知，~~后端的开发一般是面向接口的开发，也可以说是 CRUD 工程师，本文章将使用 Go 描述从数据库读出数据，然后返回 JSON 数据\n数据库 例子为从 MySQL 数据库的分类表，读出分类的名称与 ID，数据库的结构如下\n1 2 3 4 5 6 DROP TABLE IF EXISTS categories ; CREATE TABLE categories ( id INT AUTO_INCREMENT PRIMARY KEY, name VARCHAR(255) NOT NULL, description VARCHAR(255) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4; 项目结构 本例子的项目结构如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 project/ ├── database/ // 数据库包 │ └── database.go // 数据库连接 ├── handler/ // 处理器包 │ └── category.go // 分类相关接口 ├── model/ // 数据模型包 │ ├── category.go // 分类表模型 │ └── response.go // 响应数据模型 ├── router/ // 路由包 │ └── router.go // 路由配置 ├── utils // 工具包 │ └── response.go // 统一响应 ├── main.go // 程序入口 接下来将分目录说明\ndatabase 该包是管理与数据库的连接\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 // database.go package database import ( \u0026#34;database/sql\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; _ \u0026#34;github.com/go-sql-driver/mysql\u0026#34; ) var DB *sql.DB func InitDB() { var err error dsn := \u0026#34;username:password@tcp(address:3306)/name?charset=utf8\u0026#34; DB, err = sql.Open(\u0026#34;mysql\u0026#34;, dsn) if err != nil { log.Fatalf(\u0026#34;Failed to open database: %v\u0026#34;, err) } // Test Connect err = DB.Ping() if err != nil { log.Fatalf(\u0026#34;Failed to ping database: %v\u0026#34;, err) } fmt.Println(\u0026#34;Successfully connected Database!\u0026#34;) } handler 这个包是对于特定处理的逻辑 (类似于三层架构的 service)，其中数据库处理还可以分层 (类似于 Mapper)，但这只是一个简单的示例，就酱子啦~\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 // category.go package handler import ( \u0026#34;net/http\u0026#34; \u0026#34;project/database\u0026#34; \u0026#34;project/model\u0026#34; \u0026#34;project/utils\u0026#34; ) func GetCategories(w http.ResponseWriter, r *http.Request) { // Select Database rows, err := database.DB.Query(\u0026#34;select id,name from categories\u0026#34;) if err != nil { http.Error(w, \u0026#34;Failed to query Categories\u0026#34;, http.StatusInternalServerError) return } defer rows.Close() // analyze data var categories []model.Category for rows.Next() { var category model.Category err = rows.Scan(\u0026amp;category.Id, \u0026amp;category.Name) if err != nil { utils.JSONResponse(w, http.StatusInternalServerError, \u0026#34;Failed to analyze Categories\u0026#34;, nil) //http.Error(w, \u0026#34;Failed to analyze Categories\u0026#34;, http.StatusInternalServerError) return } categories = append(categories, category) } // return JSON //w.Header().Set(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;) //json.NewEncoder(w).Encode(categories) utils.JSONResponse(w, http.StatusOK, \u0026#34;\u0026#34;, categories) } 注释掉的内容为不适用统一响应接口，直接返回 JSON 的情况\nmodel 这里的数据模型一般可以分为三个，从前端接收到的、数据库的以及返回给前端的，由于这只是一个简单的示例，所以我并没有细分\n1 2 3 4 5 6 7 8 // category.go package model type Category struct { Id int `json:\u0026#34;id\u0026#34;` Name string `json:\u0026#34;name\u0026#34;` Description string `json:\u0026#34;description\u0026#34;` } 响应的数据模型为\n1 2 3 4 5 6 7 package model type Response struct { Code int `json:\u0026#34;code\u0026#34;` Msg string `json:\u0026#34;msf\u0026#34;` Data interface{} `json:\u0026#34;data\u0026#34;` } router 该包管理路由，即访问了什么路径要指定相应的处理逻辑 (类似于三层架构的 controller)\n1 2 3 4 5 6 7 8 9 10 11 12 13 // router.go package router import ( \u0026#34;github.com/gorilla/mux\u0026#34; \u0026#34;project/handler\u0026#34; ) func InitRouter() *mux.Router { router := mux.NewRouter() router.HandleFunc(\u0026#34;/categories\u0026#34;, handler.GetCategories).Methods(\u0026#34;GET\u0026#34;) return router } utils 该包为工具类，用于定义可以通用的工具\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // response.go package utils import ( \u0026#34;encoding/json\u0026#34; \u0026#34;log\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;project/model\u0026#34; ) func JSONResponse(w http.ResponseWriter, code int, message string, data interface{}) { w.Header().Set(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json; charset=utf-8\u0026#34;) w.WriteHeader(http.StatusOK) err := json.NewEncoder(w).Encode(model.Response{Code: code, Msg: message, Data: data}) if err != nil { log.Fatal(err) return } } main 程序的入口\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // main.go package main import ( \u0026#34;log\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;project/database\u0026#34; \u0026#34;project/router\u0026#34; ) func main() { // init Database database.InitDB() // Init Router r := router.InitRouter() // start log.Println(\u0026#34;Starting server on port 8848\u0026#34;) log.Fatal(http.ListenAndServe(\u0026#34;:8848\u0026#34;, r)) } 运行 go run main.go，程序将监听 8848 端口\n","date":"2024-12-22T22:07:15+08:00","permalink":"https://blog.yexca.net/archives/208/","title":"GoLang 后端入门"},{"content":" Golang Series\nHello GoLang: https://blog.yexca.net/archives/154 GoLang (var and const) 变量与常量: https://blog.yexca.net/archives/155 GoLang (func) 函数: https://blog.yexca.net/archives/156 GoLang (slice and map) 切片: https://blog.yexca.net/archives/160 GoLang (OOP) 面向对象: https://blog.yexca.net/archives/162 GoLang (reflect) 反射: https://blog.yexca.net/archives/204 GoLang (struct tag) 结构体标签: https://blog.yexca.net/archives/205 GoLang (goroutine) go 程: https://blog.yexca.net/archives/206 GoLang (channel) 通道: 本文\nGo 程 (goroutine) 可以通过 channel 进行传递数据，引用类型 channel 可用于多个 goroutine 通讯，其内部实现了同步，确保并发安全\n有点类似 RabbitMQ (仅个人为方便学习所类比，实则为不同东西)\n定义变量 channel 为引用类型，复制或函数调用时将引用同一个 channel 对象，零值为 nil\n通过 make() 函数创建，例如\n1 2 3 c := make(chan int) // 添加容量为3 c := make(chan int, 3) 当容量为 0 时，channel 是无缓冲阻塞读写的，大于 0 时有缓存是非阻塞的，直至写满才阻塞\n通过 \u0026lt;- 来接收和发送数据\n1 2 3 4 5 6 7 8 // 发送数据到 channel channel \u0026lt;- 3 // 接收并丢弃 \u0026lt;-channel // 注意无空格 // 接收并赋值给变量 x := \u0026lt;-channel // 接收并赋值给变量，并判断是否接收成功(channel 是否为空) data, flag := \u0026lt;-channel 无缓冲 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package main import \u0026#34;fmt\u0026#34; func main() { c := make(chan int) go func() { defer fmt.Println(\u0026#34;A.defer\u0026#34;) c \u0026lt;- 6 fmt.Println(\u0026#34;A running\u0026#34;) }() num := \u0026lt;-c fmt.Println(\u0026#34;num =\u0026#34;, num) fmt.Println(\u0026#34;main over\u0026#34;) } 有缓冲 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { c := make(chan int, 3) go func() { defer fmt.Println(\u0026#34;A over\u0026#34;) for i := 0; i \u0026lt; 3; i++ { c \u0026lt;- i fmt.Println(\u0026#34;A goroutine, i =\u0026#34;, i, \u0026#34;len =\u0026#34;, len(c), \u0026#34;cap =\u0026#34;, cap(c)) } }() time.Sleep(2 * time.Second) for i := 0; i \u0026lt; 3; i++ { num := \u0026lt;-c fmt.Println(\u0026#34;main, num =\u0026#34;, num) } fmt.Println(\u0026#34;main over\u0026#34;) } 关闭 channel 通过 close() 关闭\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package main import \u0026#34;fmt\u0026#34; func main() { c := make(chan int, 5) go func() { for i := 0; i \u0026lt; 5; i++ { c \u0026lt;- i } // 关闭 close(c) }() for { if data, ok := \u0026lt;-c; ok { fmt.Println(data) } else { break } } fmt.Println(\u0026#34;Main Finished\u0026#34;) } 使用 range 上述 main 的 for 循环可以简写使用 range\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package main import \u0026#34;fmt\u0026#34; func main() { c := make(chan int, 5) go func() { for i := 0; i \u0026lt; 5; i++ { c \u0026lt;- i } close(c) }() //for { // if data, ok := \u0026lt;-c; ok { // fmt.Println(data) // } else { // break // } //} for data := range c { fmt.Println(data) } fmt.Println(\u0026#34;Main Finished\u0026#34;) } 单向 channel 默认情况下 channel 是双向的，即可读可写，也可以指定通道方向，只读或只写\n1 2 3 4 5 var c chan int // 声明正常双向 channel // c1 只可写 var c1 chan\u0026lt;- int // c2 只可读 var c2 \u0026lt;-chan int 可以把双向 channel 转为单向，反之不可。也就是可以定义函数形参为单向，但传递双向\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // chan\u0026lt;- // 只写 func counter(out chan\u0026lt;- int) { defer close(out) for i := 0; i \u0026lt; 5; i++ { out \u0026lt;- i // 如果对方不读 会阻塞 } } // \u0026lt;-chan // 只读 func printer(in \u0026lt;-chan int) { for num := range in { fmt.Println(num) } } func main() { c := make(chan int) // 双向 go counter(c) // 生产者 printer(c) // 消费者 fmt.Println(\u0026#34;done\u0026#34;) } select select 可以监听多个 channel 上的数据流动，语法与 switch 类似，但每个 case 语句里必须是一个 IO 操作\n一般放到 for{} 语句块中\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 package main import \u0026#34;fmt\u0026#34; func main() { c := make(chan int) quit := make(chan int) go func() { for i := 0; i \u0026lt; 10; i++ { fmt.Println(\u0026lt;-c) } quit \u0026lt;- 0 }() // main x, y := 1, 1 for { select { case c \u0026lt;- x: tmp := x x = y y = tmp + y case \u0026lt;-quit: fmt.Println(\u0026#34;quit\u0026#34;) return // 可以有 default，此例不需要 } } } ","date":"2024-12-21T14:52:55+08:00","permalink":"https://blog.yexca.net/archives/207/","title":"GoLang 通道"},{"content":" Golang Series\nHello GoLang: https://blog.yexca.net/archives/154 GoLang (var and const) 变量与常量: https://blog.yexca.net/archives/155 GoLang (func) 函数: https://blog.yexca.net/archives/156 GoLang (slice and map) 切片: https://blog.yexca.net/archives/160 GoLang (OOP) 面向对象: https://blog.yexca.net/archives/162 GoLang (reflect) 反射: https://blog.yexca.net/archives/204 GoLang (struct tag) 结构体标签: https://blog.yexca.net/archives/205 GoLang (goroutine) go 程: 本文\nGoLang (channel) 通道: https://blog.yexca.net/archives/207 进程 -\u0026gt; 线程 -\u0026gt; 协程\n协程 (coroutine) 也叫轻量级线程，可以轻松创建上万个而不会导致系统资源衰竭，多个协程共享该线程分配到的计算机资源\nGo 语言原生支持协程，叫 goroutine，Go 的并发通过 goroutine 和 channel 实现\n创建 goroutine 通过 go 关键字开启一个 goroutine\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func newTask() { i := 0 for { fmt.Println(\u0026#34;newTask goroutine i =\u0026#34;, i) i++ time.Sleep(1 * time.Second) } } func main() { go newTask() i := 0 for { fmt.Println(\u0026#34;main goroutine i =\u0026#34;, i) i++ time.Sleep(1 * time.Second) } } 使用匿名函数 当然也可以使用匿名函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { go func() { defer fmt.Println(\u0026#34;A.defer\u0026#34;) func() { defer fmt.Println(\u0026#34;B.defer\u0026#34;) fmt.Println(\u0026#34;B\u0026#34;) }() // 表示执行该匿名函数 fmt.Println(\u0026#34;A\u0026#34;) }() time.Sleep(2 * time.Second) } 匿名函数也可以有形参与返回值，不过 goroutine 返回值需要通过 channel 传输，下例仅演示有形参\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { go func(a, b int) { fmt.Println(\u0026#34;a =\u0026#34;, a, \u0026#34;b =\u0026#34;, b) }(10, 20) time.Sleep(2 * time.Second) } 退出 主 goroutine 退出后，其他的工作 goroutine 也会自动退出\n不过也可使用 runtime.Goexit() 立即终止当前 goroutine 执行 (defer 会执行)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;runtime\u0026#34; \u0026#34;time\u0026#34; ) func main() { go func() { defer fmt.Println(\u0026#34;A.defer\u0026#34;) func() { defer fmt.Println(\u0026#34;B.defer\u0026#34;) runtime.Goexit() // 退出 goroutine fmt.Println(\u0026#34;B\u0026#34;) }() // 表示执行该匿名函数 fmt.Println(\u0026#34;A\u0026#34;) }() time.Sleep(2 * time.Second) } /* * 输出 * B.defer * A.defer */ ","date":"2024-12-17T21:16:31+08:00","permalink":"https://blog.yexca.net/archives/206/","title":"GoLang go 程"},{"content":" Golang Series\nHello GoLang: https://blog.yexca.net/archives/154 GoLang (var and const) 变量与常量: https://blog.yexca.net/archives/155 GoLang (func) 函数: https://blog.yexca.net/archives/156 GoLang (slice and map) 切片: https://blog.yexca.net/archives/160 GoLang (OOP) 面向对象: https://blog.yexca.net/archives/162 GoLang (reflect) 反射: https://blog.yexca.net/archives/204 GoLang (struct tag) 结构体标签: 本文\nGoLang (goroutine) go 程: https://blog.yexca.net/archives/206 GoLang (channel) 通道: https://blog.yexca.net/archives/207 通过结构体标签可以描述该类在某包的作用\n获取标签值 通过 ` 来定义 tag (markdown 代码块的键)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) type User struct { // 多个tag用空格隔离 name string `doc:\u0026#34;name\u0026#34; info:\u0026#34;nameOfUser\u0026#34;` age int `info:\u0026#34;ageOfUser\u0026#34;` } func main() { user := User{\u0026#34;zhangSan\u0026#34;, 18} findTag(\u0026amp;user) } func findTag(input interface{}) { t := reflect.TypeOf(input).Elem() for i := 0; i \u0026lt; t.NumField(); i++ { tagInfo := t.Field(i).Tag.Get(\u0026#34;info\u0026#34;) tagDoc := t.Field(i).Tag.Get(\u0026#34;doc\u0026#34;) fmt.Println(\u0026#34;info:\u0026#34;, tagInfo, \u0026#34;doc:\u0026#34;, tagDoc) } } JSON 转换 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 package main import ( \u0026#34;encoding/json\u0026#34; \u0026#34;fmt\u0026#34; ) type User struct { // 注意要是公有属性才可转换json Name string `json:\u0026#34;name\u0026#34;` Age int `json:\u0026#34;age\u0026#34;` } func main() { user := User{\u0026#34;zhangSan\u0026#34;, 18} // struct --\u0026gt; json jsonStr, err := json.Marshal(user) if err != nil { fmt.Println(\u0026#34;error\u0026#34;, err) } else { fmt.Printf(\u0026#34;jsonStr : %s\\n\u0026#34;, jsonStr) } // json --\u0026gt; struct var user2 User err = json.Unmarshal(jsonStr, \u0026amp;user2) if err != nil { fmt.Println(\u0026#34;error\u0026#34;, err) } else { fmt.Println(user2) } } ","date":"2024-12-11T18:31:18+08:00","permalink":"https://blog.yexca.net/archives/205/","title":"GoLang 结构体标签"},{"content":" Golang Series\nHello GoLang: https://blog.yexca.net/archives/154 GoLang (var and const) 变量与常量: https://blog.yexca.net/archives/155 GoLang (func) 函数: https://blog.yexca.net/archives/156 GoLang (slice and map) 切片: https://blog.yexca.net/archives/160 GoLang (OOP) 面向对象: https://blog.yexca.net/archives/162 GoLang (reflect) 反射: 本文\nGoLang (struct tag) 结构体标签: https://blog.yexca.net/archives/205 GoLang (goroutine) go 程: https://blog.yexca.net/archives/206 GoLang (channel) 通道: https://blog.yexca.net/archives/207 反射指一类应用，它们能够自描述和自控制\npair Go 语言变量包括 type 和 value 部分，组成 pair\nstatic type 是在编码时程序员看见的类型，concrete type 是在 runtime 系统看见的类型\n类型断言能否成功，取决于变量的 concrete type，而不是 static type。因此一个 read 变量如果 concrete type 也实现了 write 方法的话，也可以被类型断言为 write\n反射建立于类型之上，静态类型以及固定，因此反射主要与 interface 类型相关 (它是 concrete type)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 package main import \u0026#34;fmt\u0026#34; type ReadBook interface { Read() } type WriteBook interface { Write() } type Book struct { } func (this *Book) Read() { fmt.Println(\u0026#34;read Book\u0026#34;) } func (this *Book) Write() { fmt.Println(\u0026#34;write Book\u0026#34;) } func main() { // b: pair\u0026lt;type:Book, value:book{}地址\u0026gt; b := \u0026amp;Book{} // r: pair\u0026lt;type:, value:\u0026gt; var r ReadBook // r: pair\u0026lt;type:Book, value:book{}地址\u0026gt; r = b r.Read() var w WriteBook w = r.(WriteBook) // 因为r的type是Book，所以 w.Write() } TypeOf 和 ValueOf reflect.TypeOf() 是获取 pair 中的 type，reflect.ValueOf() 获取 pair 中的 value\n1 2 3 4 5 6 7 8 9 10 11 12 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) func main() { a := 3.14 fmt.Println(\u0026#34;type of a:\u0026#34;, reflect.TypeOf(a)) // float64 fmt.Println(\u0026#34;value of a:\u0026#34;, reflect.ValueOf(a)) // 3.14 } 类型转换 执行 reflect.ValueOf() 后得到类型为 reflect.Value 变量\n已知原数据类型 已知原数据类型可以直接强制转换\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) func main() { a := 3.14 fmt.Println(\u0026#34;type of a:\u0026#34;, reflect.TypeOf(a)) fmt.Println(\u0026#34;value of a:\u0026#34;, reflect.ValueOf(a)) value := reflect.ValueOf(a) fmt.Printf(\u0026#34;type of value:%T\\n\u0026#34;, value) // reflect.Value newA := value.Interface().(float64) fmt.Printf(\u0026#34;type of newA:%T\\n\u0026#34;, newA) // float64 } 需要注意类型转换需要完全一致，否则将会 panic，如指针\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) func main() { a := 3.14 fmt.Println(\u0026#34;type of a:\u0026#34;, reflect.TypeOf(a)) fmt.Println(\u0026#34;value of a:\u0026#34;, reflect.ValueOf(a)) // 传输地址 point := reflect.ValueOf(\u0026amp;a) fmt.Printf(\u0026#34;type of value:%T\\n\u0026#34;, point) // reflect.Value // 转换类型为指针 newA := point.Interface().(*float64) fmt.Printf(\u0026#34;type of newA:%T\\n\u0026#34;, newA) // *float64 } 也就是说反射可以将 \u0026ldquo;反射类型对象\u0026rdquo; 再重新转换为 \u0026ldquo;接口类型变量\u0026rdquo;\n未知原数据类型 通过遍历探寻 Field 获得\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) type Person struct { // 一行为一个 field Name string Age int Rank float64 } // 注意方法为公有，若私有则无法访问 func (person Person) Sleep() { fmt.Println(\u0026#34;person sleep\u0026#34;) } func main() { p := Person{\u0026#34;zhangSan\u0026#34;, 18, 5.2} getFieldAndMethod(p) } func getFieldAndMethod(input interface{}) { getType := reflect.TypeOf(input) fmt.Println(\u0026#34;type:\u0026#34;, getType.Name()) getValue := reflect.ValueOf(input) fmt.Println(\u0026#34;value/AllField:\u0026#34;, getValue) // 获取属性 numField := getValue.NumField() for i := 0; i \u0026lt; numField; i++ { fieldType := getType.Field(i) fieldValue := getValue.Field(i).Interface() fmt.Printf(\u0026#34;%s: %v = %v\\n\u0026#34;, fieldType.Name, fieldType.Type, fieldValue) } // 获取方法 numMethod := getType.NumMethod() for i := 0; i \u0026lt; numMethod; i++ { method := getType.Method(i) fmt.Printf(\u0026#34;%s: %v\\n\u0026#34;, method.Name, method.Type) } } 通过 reflect.Value 赋值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) func main() { a := 3.14 // 只有是指针时才可赋值 pointer := reflect.ValueOf(\u0026amp;a) // 设置指向该地址，获取原始值 newValue := pointer.Elem() // 判断是否可以设置值 fmt.Println(\u0026#34;value canSet:\u0026#34;, newValue.CanSet()) if newValue.CanSet() { // 如果可以设置 newValue.SetFloat(9.96) // 显示变量值 fmt.Println(\u0026#34;value of a:\u0026#34;, a) // 9.96 } else { fmt.Println(\u0026#34;error\u0026#34;) } } 通过 reflect.Value 调用方法 通过函数名称调用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) type User struct { name string age int } func (user User) MethodHasArgs(a string, b int) { fmt.Println(\u0026#34;User MethodHasArgs\u0026#34;) } func (user User) MethonNotArgs() { fmt.Println(\u0026#34;User MethodNotArgs\u0026#34;) } func main() { user := User{\u0026#34;zhangSan\u0026#34;, 18} value := reflect.ValueOf(user) // 通过函数名调用 method1 := value.MethodByName(\u0026#34;MethodHasArgs\u0026#34;) // 构建参数 args1 := []reflect.Value{reflect.ValueOf(\u0026#34;string\u0026#34;), reflect.ValueOf(18)} // 调用函数 method1.Call(args1) // 无参调用 method2 := value.MethodByName(\u0026#34;MethonNotArgs\u0026#34;) args2 := make([]reflect.Value, 0) method2.Call(args2) } 反射的基本原理 ","date":"2024-12-03T14:07:18+08:00","permalink":"https://blog.yexca.net/archives/204/","title":"GoLang 反射"},{"content":"問題一： https://blog.yexca.net/archives/198 問題二： https://blog.yexca.net/archives/201 問題三： https://blog.yexca.net/archives/200 問題四： https://blog.yexca.net/archives/202 問題五：この文章\n引言 应该快两周了吧终于把这张试卷看完了，效率不是一般的低啊。整体来看怎么说呢，虽然整体难度是要比中国 408 难度低一点，但考试的风格与侧重点并不相同，具体还是不太好比较。希望下次我的效率可以高点啊\n碎碎念 话说最近没怎么写碎碎念了，这其实还是因为当我想着去发一篇文章的时候往往都是很累的状态了，已经没有精力去写了。说到这里就想到以前对于一样东西从来都只是考虑要不要去学，现在不得不把时间、精力等算上了，最近看到的一个梗\n你就不能一手抓考公，一手抓选调，一手抓国考，一手抓省考，一手抓教资，一手抓留学，一手抓实习, 一手抓面试，一手抓转正，一手抓秋招，一手抓毕设，一手抓恋爱。但你还得留一手，因为中国人讲究凡事留一手\n让我感受颇深，人的精力是有限的，获得一定收获的同时必定会丧失一定的所得，包括时间、精力、热情等，这些其实都是可以被量化的变量，只是以前这些变量的上限大于甚至远大于我的活动并没被发掘而已 (当然也可能是透支之类的其他转换，出于严谨加个说明)，随着年龄的增长也可以说经历或看的事情的增加，慢慢越来越多的变量必须被考虑，从而导致我每天都很疲惫与效率低下吧\n有时候活着很累，可能是我太唯物了，多一点唯心，世界还是较为美好的 (我已经不敢对任何事物进行肯定性描述了，我害怕不确定，但生活往往没有确定的，虽然这归于对于变量的不掌握，不展开了，不然又得一大段)\n背景 図５.１のように構成された、$ck$ を入力とし $z_2,z_1,z_0$ を出力とする論理回路Xを考える。ここで $R_0,R_1,R_2$ はポジティブエッジトリガ型（前縁トリガ型）Dフリップフロップであり、初期化時の出力は０とする。またF は $x_2,x_1,x_0$ を入力とし $y_2,y_1,y_0$ を出力とする論理回路であり、図５.２のように構成されている。AおよびBは図5.3に示されている2入力ゲートのいずれかとする。回路Xの入力 $ck$ に1単位時間を周期とするクロックパルスを与える。以下 $n$ を正整数、$t$ を時刻とする。時刻 $t=0$ において $R_0,R_1,R_2$ は初期化されており、時刻0以降 $n$ 個目のクロックパルスの立ち上がりによる出力が時刻 $t=n$ において $z_2,z_1,z_0$ に安定して得られるとする。この様子を図5.4に示す。以降、回路の構成要素（ゲート、フリップフロップおよび配線）による遅延はクロックパルスの周期と比較して十分小さく無視できるとする。\n図5.1：論理回路X 図5.2：論理回路F 図5.3：2入力ゲート 図5.4：回路Xの動作 1 以下の問い a~f に答えよ。\na）回路Fの出力 $y_2,y_1,y_0$ は入力 $x_2,x_1,x_0$ の値のみで決まる。このような動作を行う回路の名称として最も適切なものを以下の選択肢から一つ選べ。\nア　非同期回路\nイ　組み合わせ回路\nウ　順序回路\nエ　非線形回路\nb）時刻 $t=n$ における回路Xの出力 $z_2,z_1,z_0$ は、時刻 $t=$ アにおける $y_2,y_1,y_0$ の値それぞれと等しい。アを $n$ の式として表せ。\nc）回路Xが図5.4に示すような動作をするための、回路Fの動作を表す真理値表を図5.5に示す表形式で完成させよ。\n図5.5：回路Fの動作 d）図5.4のような動作を行う回路の名称として最も適切なものを以下の選択肢から一つ選び記号①～④で答えよ。\n①デコーダ ②マルチプレクサ ③カウンタ ④シフトレジスタ\ne）回路Ｘを図5.4のように動作させるためには図5.2のＡおよびＢにはそれぞれ何が入るか。図5.3から選び記号①～⑥で答えよ。同一のゲートを複数回用いてもよい。\nf）論理変数 $x$ と $y$ の論理積（AND）を $xy$、論理和（OR）を $x+y$、$x$ の否定（NOT）を $\\bar{x}$ と表記する。回路Fの出力 $y_2$ を\n1-解答 1-a 非同期回路はクロック信号を使わず、各部分が独立して動作する回路を指します。 組み合わせ回路は、出力が入力の現在の値だけで決まる回路です。 順序回路は、出力が現在の入力だけでなく、内部の状態（フリップフロップの出力など）にも依存します。 非線形回路は、入力と出力の関係が線形でない特性を持つ回路を指します。 这题显然是属于 “組み合わせ回路”\n1-b 因为 D 触发器会先接收一个输入，仅在时钟上升沿触发将其放到输出，由于状态更新的同步性，D 触发器会引入一个周期的延迟，所以 ア: $n-1$\n1-c x_2 x_1 x_0 y_2 y_1 y_0 0 0 0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 1 0 1 1 1 0 0 1 0 0 1 0 1 1 0 1 1 1 0 1 1 0 1 1 1 1 1 1 0 0 0 1-d デコーダ（Decoder）：解码器是一种将少量的输入信号解码为较多输出信号的组合逻辑电路。它根据输入的二进制编码，激活对应的输出线。 マルチプレクサ（Multiplexer）：多路复用器是一种从多个输入信号中选择一个信号输出的组合逻辑电路。它利用选择信号（Select Lines）来决定哪个输入信号通过到输出端。 カウンタ（Counter）：计数器是一种时序逻辑电路，用于对脉冲信号进行计数。根据脉冲信号的个数，计数器的输出值以特定的方式变化。 シフトレジスタ（Shift Register）：移位寄存器是一种存储数据并能够按照一定方向移动数据的时序逻辑电路。它由一系列触发器组成。 这题显然是属于 “シフトレジスタ（Shift Register）“\n1-e A: ② (OR) B: ① (AND)\n通过真值表及其电路进行分析，因为有多个输出，可以一个输出一个输出来看，由于 $y_0$ 的电路已经决定，首先看 $y_1$ 输出为 1 时的输入\n$x_2$ $x_1$ $x_0$ 0 0 1 0 1 0 1 0 1 1 1 0 分析电路，可以暂时忽略输入 $x_2$ (从电路或者下一问可以知道，化简后无 $x_2$)\n然后代入为 1 的输入进行试验，得到 A 是 OR 门，B 是 AND 门\n分析 $y_2$ 输出为 1 时的输入验算，结果正确\n1-f $$ \\begin{align} y_2\u0026amp;=\\bar{x_2}\\bar{x_1}x_0+\\bar{x_2}x_1\\bar{x_0}+x_2\\bar{x_1}x_0+x_2x_1\\bar{x_0} \\ \u0026amp;= \\bar{x_2}(\\bar{x_1}x_0+x_1\\bar{x_0})+x_2(\\bar{x_1}x_0+x_1\\bar{x_0}) \\ \u0026amp;= \\bar{x_1}x_0+x_1\\bar{x_0} \\end{align} $$\n2 図5.6に示すGは $x_2,x_1,x_0$ を入力とし $y_2,y_1,y_0$ を出力とする論理回路である。Gを用いて、$ck$ を入力とし $z_2,z_1,z_0$ を出力とする論理回路Yを図5.7のように構成する。さらにYを用いて図5.8に示す論理回路 $X\u0026rsquo;$ を構成する。図5.8のCおよびDは図5.3に示されている2入力ゲートのいずれかである。以下の問い a~e に答えよ。\n図5.6：論理回路G\n図5.7：論理回路Y\n図5.8：論理回路 $X'$\n図5.9：回路Yの動作\na）回路Gでは出力 $y_0$ を得るためにゲートを5個用いている。図5.3に挙げたゲート2個以下を用いてGにおける $y_0$ と同じ出力を得ることができる回路を一つ記せ。\nb）回路Yの入力 $ck$ に1単位時間を周期とするクロックパルスを与える。時刻 $t=0$ において $R_0,R_1,R_2$ は初期化されているとし、時刻0以降のｎ個目のクロックパルスの立ち上がりによる出力が時刻 $t=n$ において $z_2,z_1,z_0$ に安定して得られるとする。時刻 $t=1,4,7,12$ における回路Ｙの出力 $z_2,z_1,z_0$ を図5.9に示す表形式で完成させよ。\nc）ｍを非負整数とする。上記ｂ）で示した条件下での時刻 $t=m$ における回路Ｙの出力の組 $(z_2,z_1,z_0)$ をベクトルとみなし $z(m)$ と表記する。$z(m)$ と $z(m+1)$ のハミング距離の最大値を答えよ。\nd）図5.8の回路X’と図5.1の回路Xは同等のふるまいを示す。このとき図5.8のCおよびDに入るゲートを図5.3から選び、記号①～⑥で答えよ。同一のゲートを複数回用いてもよい。ここで同等のふるまいとは以下のことという。X’とXそれぞれの入力 $ck$ に図5.10のように同一のパルス発生源Ｐから1単位時間を周期とするクロックパルスを与える。時刻 $t=0$ においてX’およびX内のDクロックパルスの立ち上がりによる出力が時刻 $t=n$ において $w_2,w_1,w_0$ および $z_2,z_1,z_0$ それぞれに安定して得られているとき、 $w_2=z_2$ かつ $w_1=z_1$ かつ $w_0=z_0$ である。\n図5.10 e）図5.11のような論理回路を考える。時刻 $t=t_0$ において入力ｘとｙが0から1に同時に変化したとする。このとき出力ｚは0のまま変化しないことが期待されるが、NOT ゲートにおける遅延が原因で図5.12に示すようなパルスが生じることがある。この現象はグリッチ（あるいはハザード）と呼ばれ、接続される回路によっては誤動作の原因となり得る。図5.8の回路Ｘ’において、ゲートＣ、Ｄにおける遅延が無視できない場合に出力 $w_0$ においてグリッチが発生し得るか否かを述べ、発生し得るなら対策方法を、発生しないならその理由を100文字以内で記せ。ただし回路Ｙの構成要素（ゲート、フリップフロップおよび配線）による遅延は無視できるものとし、$R_0,R_1,R_2$ それぞれの出力は同時に変化するものとする。\n図5.11：グリッチを生じ得る論理回路の例\n図5.12：グリッチの例\n2-解答 2-a 分析电路可知 $y_0=x_1x_2+\\bar{x_1}\\bar{x_2}$，等价于 $x_1\\ \\text{XNOR}\\ x_2$ 所以可以直接使用一个 XNOR 门简化电路\n⑥だけ使用することができる。\n2-b t $x_0$ $x_1$ $x_2$ $y_0$ $y_1$ $y_2$ 0 0 0 0 1 0 0 1 1 0 0 1 1 0 2 1 1 0 0 1 0 3 0 1 0 0 1 1 4 0 1 1 1 1 1 5 1 1 1 1 0 1 6 1 0 1 0 0 1 7 0 0 1 0 0 0 8 0 0 0 1 0 0 9 1 0 0 1 1 0 10 1 1 0 0 1 0 11 0 1 0 0 1 1 12 0 1 1 1 1 1 可以看到从 $t=7$ 开始循环\n2-c 汉明距离表示两个相同长度的二进制向量中，不同位的个数\n从上问真值表来看，最大为 1\n2-d C: ③ (XOR) D: ③ (XOR)\n分析俩电路的时刻表，可以得到真值表\n$z_0$ $z_1$ $z_2$ $w_0$ $w_1$ $w_2$ 1 0 0 1 0 0 1 1 0 0 1 0 0 1 0 1 1 0 0 1 1 0 0 1 1 1 1 1 0 1 1 0 1 0 1 1 0 0 1 1 1 1 0 0 0 0 0 0 分析电路，可以先看 $w_1$，寻找使 $w_1$ 为 1 的输入\n$z_0$ $z_1$ $z_2$ 1 1 0 0 1 0 1 0 1 0 0 1 从电路可知可以忽略 $z_0$，剩下的 $z_1$ 和 $z_2$ 呈现出不同输出为 1，也就是异或门的形式，即 D 为异或门\n分析 $w_0$ 为 1 的输入\n$z_0$ $z_1$ $z_2$ $z_1 \\oplus z_2$ 1 0 0 0 0 1 0 1 1 1 1 0 0 0 1 1 从电路可以，可以直接观察 $z_0$ 和 $z_1 \\oplus z_2$，呈现出不同输出为 1，也就是异或门的形式，即 C 为异或门\n2-e $w_0$ にグリッチが発生する可能性があります。対策としては、出力にバッファを追加するか、または同期フリップフロップを追加するか、あるいは回路設計を見直すことです。\n参考文章 逻辑代数的化简（公式法和卡诺图法） ","date":"2024-12-01T18:15:28+08:00","permalink":"https://blog.yexca.net/archives/203/","title":"东京科学大学大学院情报理工学院 2020 问题五 / 科学大院理工学 2020 問題五"},{"content":"問題一： https://blog.yexca.net/archives/198 問題二： https://blog.yexca.net/archives/201 問題三： https://blog.yexca.net/archives/200 問題四：この文章\n問題五： https://blog.yexca.net/archives/203 引言 一整题都是考拉普拉斯变换的，同时最后一题是应用。如果不知道拉普拉斯变换是比较难快速解题，虽然速度快的话可以做出前两大题以及第三题的前三问 (其实也很多了)，对于最后两问倒是属于不知道相关原理便不会做了 (我在最后一问倒是写了不知道相关情况如何解题，但考场那种情况下真的可以反应过来吗？)\n题目版权属于东京科学大学所有，仅为了方便观看而引用，无盈利行为\n背景 実数 $t(\\ge0)$ を変数とする2回微分可能な実関数 $f(t)$ のラプラス変換 $F(S)=\\mathcal{L}[f(t)]$ を次式で定義する。\n$$ F(s)=\\mathcal{L}[f(t)]=\\int_0^\\infty f(t)e^{-st}dt \\tag{4.1} $$\nここで、ｓは複素変数で、かつ実部が正であるとする。以下の問いに答えよ。なお、解答にあたって、次のラプラス変換に関する関係式を用いてもよい。\n$$ \\mathcal{L}[e^{-\\alpha t}f(t)] = F(s+\\alpha) \\tag{4.2} $$\n$$ \\mathcal{L}[\\frac{\\mathrm{d}}{\\mathrm{d}t}f(t)] = sF(s) - f(0) \\tag{4.3} $$\n$$ \\mathcal{L}[\\frac{\\mathrm{d}^2}{\\mathrm{d}t^2}f(t)] = s^2F(s)-sf(0)-f\u0026rsquo;(0) \\tag{4.4} $$\nただし、$\\alpha$ は実定数とし、$f\u0026rsquo;(t)=\\frac{\\mathrm{d}}{\\mathrm{d}t}f(t)$ とする。\n这一段描述了拉普拉斯变换的定义以及三条性质\n1 以下の a~c の式が成り立つことを示せ。ただし、$\\alpha$ は実定数、$\\beta$ は０ではない実定数とする。\na）$\\mathcal{L}[\\cos(\\beta t)]=\\dfrac{s}{s^2+\\beta^2}$\nb）$\\mathcal{L}[e^{-\\alpha t}\\cos(\\beta t)] = \\dfrac{s+\\alpha}{(s+a)^2+\\beta^2}$\nc）$\\mathcal{L}[e^{-\\alpha t}\\sin(\\beta t)]=\\dfrac{\\beta}{(s+a)^2+\\beta^2}$\n解答 a 代入定义\n$$ \\mathcal{L}[\\cos(\\beta t)] = \\int_0^\\infty \\cos(\\beta t)e^{-3t}\\mathrm{d}t $$\n这里使用欧拉公式\n$$ e^{i\\theta}=\\cos\\theta + i\\sin\\theta $$\n的推论\n$$ \\cos\\theta=\\frac{e^{i\\theta}+e^{-i\\theta}}{2} $$\n证明很简单，直接代入\n$$ \\begin{align} \\cos\\theta \u0026amp;= \\frac{e^{i\\theta}+e^{-i\\theta}}{2} \\ \u0026amp;= \\frac{(\\cos\\theta + i\\sin\\theta)+(\\cos(-\\theta) + i\\sin(-\\theta))}{2} \\ \u0026amp;= \\frac{(\\cos\\theta + i\\sin\\theta)+(\\cos\\theta - i\\sin\\theta)}{2} \\ \u0026amp;= \\frac{2\\cos\\theta }{2} \\ \u0026amp;= \\cos\\theta \\end{align} $$\n代入原式，得\n$$ \\begin{align} \\mathcal{L}[\\cos(\\beta t)] \u0026amp;=\\int_0^\\infty\\frac{e^{i\\beta t}+e^{-i\\beta t}}{2}e^{-st}\\mathrm{d}t \\ \u0026amp;= \\frac{1}{2}(\\int_0^\\infty e^{i\\beta t} \\cdot e^{-st}\\mathrm{d}t+\\int_0^\\infty e^{-i\\beta t} \\cdot e^{-st}\\mathrm{d}t) \\ \u0026amp;= \\frac{1}{2}(\\int_0^\\infty e^{-(i\\beta t + st)}\\mathrm{d}t + \\frac{1}{2}(\\int_0^\\infty e^{-(i\\beta t + st)}\\mathrm{d}t) \\end{align} $$\n求积分得\n$$ \\begin{align} \\mathcal{L}[\\cos(\\beta t)] \u0026amp;= \\frac{1}{2}(\\frac{1}{s-i\\beta}+\\frac{1}{s+i\\beta}) \\end{align} $$\n此处积分过程\n$$ \\begin{align} \\int_0^\\infty e^{-at}\\mathrm{d}t \u0026amp;= \\frac{1}{-a}e^{-at}\\mid_0^\\infty \\ \u0026amp;= 0-\\frac{1}{-a} \\ \u0026amp;= \\frac{1}{a} \\end{align} $$\n通分简化，得\n$$ \\begin{align} \\mathcal{L}[\\cos(\\beta t)] \u0026amp;= \\frac{1}{2} \\cdot \\frac{s+i\\beta+s-i\\beta}{(s-i\\beta)(s+i\\beta)} \\ \u0026amp;= \\dfrac{s}{s^2+\\beta^2} \\end{align} $$\n原命题得证\nb 由 $(4.2)$ 知\n$$ \\mathcal{L}[e^{-\\alpha t}f(t)] = F(s+\\alpha) $$\n又由第一问知\n$$ \\mathcal{L}[\\cos(\\beta t)]=\\dfrac{s}{s^2+\\beta^2} $$\n所以\n$$ \\mathcal{L}[e^{-\\alpha t}\\cos(\\beta t)] = \\dfrac{s+\\alpha}{(s+a)^2+\\beta^2} $$\n原命题得证\nc 因为\n$$ \\frac{\\mathrm{d}}{\\mathrm{d}t}\\sin(\\beta t) = \\beta \\cos(\\beta t) $$\n两边同时取拉普拉斯变换\n$$ \\mathcal{L}[\\frac{\\mathrm{d}}{\\mathrm{d}t}\\sin(\\beta t)] = \\mathcal{L}[\\beta \\cos(\\beta t)] $$\n由 $(4.3)$ 知\n$$ \\mathcal{L}[\\frac{\\mathrm{d}}{\\mathrm{d}t}f(t)] = sF(s) - f(0) $$\n所以\n$$ \\mathcal{L}[\\frac{\\mathrm{d}}{\\mathrm{d}t}\\sin(\\beta t)] = sF(s)-\\sin(0)=sF(s) $$\n即\n$$ sF(s) = \\mathcal{L}[\\beta \\cos(\\beta t)] = \\beta \\mathcal{L}[\\cos(\\beta t)] $$\n由第一问，知\n$$ \\mathcal{L}[\\cos(\\beta t)]=\\dfrac{s}{s^2+\\beta^2} $$\n代入，得\n$$ sF(s) = \\beta \\dfrac{s}{s^2+\\beta^2} $$\n解得\n$$ F(s) = \\dfrac{\\beta}{s^2+\\beta^2} $$\n所以\n$$ \\mathcal{L}[\\sin(\\beta t)] = \\dfrac{\\beta}{s^2+\\beta^2} $$\n写完回想的时候，最初我用的一个简单的方法是可以用的，只是我想错了，这个比较简单点，但是上面的感觉看起来很帅，所以保留了。接下来简单描述下\n$$ \\begin{align} \\mathcal{L}[\\frac{\\mathrm{d}}{\\mathrm{d}t}\\cos(\\beta t)] \u0026amp;= \\mathcal{L}[-\\beta\\sin(\\beta t)]\\ \u0026amp;= -\\beta \\mathcal{L}[\\sin(\\beta t)]\\ \u0026amp;= sF(s) - \\cos(0) \\ \u0026amp;= \\dfrac{s^2}{s^2+\\beta^2} - 1 \\ \u0026amp;= \\dfrac{-\\beta^2}{s^2+\\beta^2} \\end{align} $$\n即\n$$ \\mathcal{L}[\\sin(\\beta t)] = \\dfrac{\\beta}{s^2+\\beta^2} $$\n几乎相当于三种方法解出来 (还有一种和 a 题一样直接算)，做出来的时候太爽了\n由 $(4.2)$ 知\n$$ \\mathcal{L}[e^{-\\alpha t}f(t)] = F(s+\\alpha) $$\n所以\n$$ \\mathcal{L}[e^{-\\alpha t}\\sin(\\beta t)]=\\dfrac{\\beta}{(s+a)^2+\\beta^2} $$\n2 次の微分方程式について、以下の a~d に答えよ。\n$$ \\frac{\\mathrm{d}^2}{\\mathrm{d}t^2}f(t) + \\eta \\frac{\\mathrm{d}}{\\mathrm{d}t}f(t) + 2f(t) = 2 \\tag{4.5} $$\nここで、$\\eta$ は実定数、$f(t)$ は実数 $t(\\ge 0)$ を変数とする2回微分可能な実関数とし、初期条件を $f(0)=1, f\u0026rsquo;(0)=1$ とする。ただし、$f\u0026rsquo;(t)=\\frac{\\mathrm{d}}{\\mathrm{d}t}f(t), F(s)=\\mathcal{L}[f(t)]$ とする。\na）微分方程式 $(4.5)$ の両辺をラプラス変換し、$F(s)$ を $s$ の関数として表せ。\nb）$\\eta=0$ のとき、ラプラス変換を用いて微分方程式 $(4.5)$ を解き、$f(t)$ を $t$ の関数として表せ。\nc）$\\eta=2$ のとき、ラプラス変換を用いて微分方程式 $(4.5)$ を解き、$f(t)$ を $t$ の関数として表せ。\nd）$\\eta=2$ のとき、$\\lim_{t \\to \\infty}f(x)$ の値を求め、$f(t)$ のグラフの概形を描け。\n解答 a 根据 $(4.3), (4.4)$ 两边取拉普拉斯变换，得\n$$ s^2F(s)-sf(0)-f\u0026rsquo;(0)+\\eta(sF(s)-f(0))+2F(s)=\\frac{2}{s} $$\n整理，得\n$$ (s^2+\\eta s+2)F(s) = \\frac{2}{s}+s+\\eta+1 $$\n所以\n$$ F(s)=\\frac{\\frac{2}{s}+s+\\eta+1}{s^2+\\eta s +2} $$\nb 将 $\\eta=0$ 代入，得\n$$ \\begin{align} F(s)\u0026amp;=\\frac{\\frac{2}{s}+s+1}{s^2+2} \\ \u0026amp;=\\frac{s^2+s+2}{s(s^2+2)} \\end{align} $$\n设\n$$ \\frac{s^2+s+2}{s(s^2+2)} = \\frac{A}{s} + \\frac{Bs+C}{s^2+2} = \\frac{A(s^2+2)+s(Bs+C)}{s(s^2+2)} $$\n得\n$$ \\left { \\begin{align} A+B = 1 \\ C = 1 \\ 2A = 2 \\end{align} \\right . $$\n解得 $A=1, B=0, C=1$，代入得\n$$ F(s) = \\frac{1}{s} + \\frac{1}{s^2+2} $$\n逆拉普拉斯变化得\n$$ f(t) = 1 + \\frac{1}{\\sqrt{2}}\\sin(\\sqrt{2}t) $$\nc 将 $\\eta=2$ 代入，得\n$$ F(s)=\\frac{\\frac{2}{s}+s+3}{s^2+2s +2} = \\frac{2+s^2+3s}{s(s^2+2s +2)} $$\n设\n$$ \\frac{2+s^2+3s}{s(s^2+2s +2)} = \\frac{A}{s} + \\frac{Bs+C}{s^2+2s +2} = \\frac{A(s^2+2s+2)+s(Bs+C)}{s(s^2+2s +2)} $$\n得\n$$ \\left { \\begin{align} A+B = 1 \\ 2A+C = 3 \\ 2A = 2 \\end{align} \\right . $$\n解得 $A=1, B=0, C=1$，所以\n$$ F(s) = \\frac{1}{s} + \\frac{1}{s^2+2s+2} = \\frac{1}{s} + \\frac{1}{(s+1)^2+1} $$\n逆拉普拉斯变化得\n$$ f(t) = 1 + e^{-t}\\sin t $$\nd 由 c 可知，$\\eta=2$ 时\n$$ f(t) = 1 + e^{-t}\\sin t $$\n即\n$$ \\lim_{t \\to \\infty} f(t) = \\lim_{t \\to \\infty} (1 + e^{-t}\\sin t) = 1 $$\n因为\n$$ f(0) = 1+e^0\\sin0 = 1 $$\n所以 $f(t)$ 的图形大概为从 1 开始，振荡衰减并最终稳定在 1 的趋势\n振動しながら $t \\to \\infty$ において1に収束します。（これは減衰振動の典型的な形状です）\n具体图像如下\n代码如下 (因为使用 Linux 无 GUI 环境，多了几行保存图片的代码)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 import matplotlib as mpl # 显现图像 import numpy as np import matplotlib.pyplot as plt mpl.use(\u0026#39;Agg\u0026#39;) # 显现图像 # 定义函数 f(t) = 1 + e^(-t) * sin(t) t = np.linspace(0, 10, 1000) # 时间范围 [0, 10] f_t = 1 + np.exp(-t) * np.sin(t) # 绘制图形 plt.figure(figsize=(8, 5)) plt.plot(t, f_t, label=r\u0026#34;$f(t) = 1 + e^{-t}\\sin(t)$\u0026#34;, color=\u0026#39;b\u0026#39;) plt.axhline(y=1, color=\u0026#39;r\u0026#39;, linestyle=\u0026#39;--\u0026#39;, label=r\u0026#34;$f(t) \\to 1$ (limit value)\u0026#34;) # 图形美化 plt.title(r\u0026#34;Function $f(t) = 1 + e^{-t}\\sin(t)$\u0026#34;, fontsize=14) plt.xlabel(\u0026#34;$t$\u0026#34;, fontsize=12) plt.ylabel(\u0026#34;$f(t)$\u0026#34;, fontsize=12) plt.legend(fontsize=10) plt.grid(alpha=0.3) plt.tight_layout() # 显示图形 plt.show() # 下载图像 plt.savefig(\u0026#34;./1.png\u0026#34;) 3 図４.１に示した1自由度のバネ-質量-ダンパ系の微分方程式は次式で表せる。\n$$ m\\frac{\\mathrm{d}^2}{\\mathrm{d}t^2}x(t)+\\mu \\frac{\\mathrm{d}}{\\mathrm{d}t}x(t)+kx(t)=p(t) \\tag{4.6} $$\nただし、位置 $x(t)$ および外力 $p(t)$ は時刻 $t(\\ge 2)$ の2回微分可能な実関数である。位置 $x(t)$ の原点はバネの自然長の位置とし、位置 $x(t)$ と外力 $p(t)$ の正の方向はバネガ伸びる方向とする。質量 $m$、バネ定数 $k$、ダンバの粘性減衰係数 $\\mu$ は正の定数とする。以下では、式 $(4.6)$ の係数の書き換えによって得られた次式を用いて考える。\n$$ \\frac{\\mathrm{d}^2}{\\mathrm{d}t^2}x(t)+2\\gamma\\omega_0\\frac{\\mathrm{d}}{\\mathrm{d}t}x(t)+w_0^2x(t)=q(t) \\tag{4.7} $$\nただし、$\\omega_0=\\sqrt{k/m}, \\gamma=\\mu/(2\\sqrt{mk}),q(t)=p(t)/m$ と定義した。また、$X(s)=\\mathcal{L}[x(t)], Q(s)=\\mathcal{L}[q(t)]$ とする。初期条件を $x(0)=0, x\u0026rsquo;(0)=0$ とする。$x\u0026rsquo;(t)=\\frac{\\mathrm{d}}{\\mathrm{d}t}x(t)$ である。このとき、以下の a~e に答えよ。\n図４.１：1自由度のバネ-質量-ダンパ系 a）式 $(4.7)$ の両辺をラプラス変換して、伝達関数 $H(s)=X(s)/Q(s)$ を計算し、$H(s)$ を $\\gamma, \\omega_0$ を用いて $s$ の関数として表せ。\nb）伝達関数 $H(s)$ において、$s$ を $i\\omega$ に置き換えることにより、$Y(\\omega)=20\\log_{10}\\mid H(i\\omega)\\mid$ を計算し、$Y(\\omega)$ を $\\omega$ の実関数として表せ。ただし、$\\omega$ は正の実数、$i$ は虚数単位とする。\nc）$Y(\\omega)$ が最大となるときの $\\omega$ の値を $\\hat{\\omega}$ とする。$\\hat{\\omega}$ を $\\gamma, \\omega_0$ を用いて表せ\nd）$Y(\\omega)$ が $\\omega=\\hat{\\omega}$ で最大になるという現象は何と呼ばれるか、答えよ。\ne）d の現象が起こる $\\gamma$ の範囲を答えよ。\n解答 a 两边同时进行拉普拉斯变换\n$$ \\mathcal{L}[\\frac{\\mathrm{d}^2}{\\mathrm{d}t^2}x(t)]+2\\gamma\\omega_0\\mathcal{L}[\\frac{\\mathrm{d}}{\\mathrm{d}t}x(t)]+w_0^2\\mathcal{L}[x(t)]=\\mathcal{L}[q(t)] $$\n由 $(4.3),(4.4)$ 即题意，得\n$$ s^2X(s) + 2\\gamma\\omega_0sX(s) + \\omega_0^2X(s) = Q(s) $$\n两边同时除以 $Q(S)$，得\n$$ s^2H(s) + 2\\gamma\\omega_0sH(s) + \\omega_0^2H(s) = 1 $$\n所以\n$$ H(s) = \\frac{1}{s^2+2\\gamma\\omega_0s+\\omega_0^2} $$\nb 将 $i\\omega$ 代入 $H(s)$ 得\n$$ \\begin{align} H(i\\omega) \u0026amp;= \\frac{1}{-\\omega^2+2i\\gamma\\omega_0\\omega + \\omega_0^2} \\ \u0026amp;= \\frac{1}{\\omega_0^2-\\omega^2+2i\\gamma\\omega_0\\omega} \\end{align} $$\n所以\n$$ \\mid H(i\\omega) \\mid = \\frac{1}{\\sqrt{(\\omega_0^2-\\omega^2)^2+(2\\gamma\\omega_0\\omega)^2}} $$\n由此可得\n$$ \\begin{align} Y(\\omega) \u0026amp;= 20\\log_{10}\\mid H(i\\omega) \\mid \\ \u0026amp;= 20\\log_{10} \\frac{1}{\\sqrt{(\\omega_0^2-\\omega^2)^2+(2\\gamma\\omega_0\\omega)^2}} \\ \u0026amp;= 20(\\log_{10}1-\\log_{10}\\sqrt{(\\omega_0^2-\\omega^2)^2+(2\\gamma\\omega_0\\omega)^2}) \\ \u0026amp;= -20\\log_{10}\\sqrt{(\\omega_0^2-\\omega^2)^2+(2\\gamma\\omega_0\\omega)^2} \\ \u0026amp;= -10\\log_{10}[(\\omega_0^2-\\omega^2)^2+(2\\gamma\\omega_0\\omega)^2] \\end{align} $$\nc $Y(\\omega)$ 最大的时候 $(\\omega_0^2-\\omega^2)^2+(2\\gamma\\omega_0\\omega)^2$ 最小，对其求导\n$$ \\begin{align} (\\omega_0^2-\\omega^2)^2+(2\\gamma\\omega_0\\omega)^2 \u0026amp;= 2(\\omega_0^2-\\omega^2)\\times(-2\\omega) + 2(2\\gamma\\omega_0\\omega)\\times(2\\gamma\\omega_0) \\ \u0026amp;= 4\\omega(\\omega^2-\\omega_0^2) + 4(2\\gamma^2\\omega_0^2w) \\ \u0026amp;= 4\\omega(\\omega^2-\\omega_0^2+\\gamma^2\\omega_0^2) \\end{align} $$\n令其为 $0$，得\n$$ 4w = 0 $$\n或\n$$ \\omega^2-\\omega_0^2+\\gamma^2\\omega_0^2 = 0 $$\n即\n$$ w^2=\\omega_0^2-2\\gamma^2\\omega_0^2 $$\n又因为 $\\omega$ 为正实数，所以\n$$ \\hat{\\omega} = \\omega_0\\sqrt{1-2\\gamma^2} $$\nd 共振現象です\n共振现象指的是当系统受到的外力频率接近系统的自然频率时，系统的响应幅度达到最大的一种现象\ne 由 $\\hat{\\omega}$ 是正实数，得\n$$ 1-2\\gamma^2 \\gt 0 $$\n即\n$$ -\\frac{1}{\\sqrt{2}} \\lt \\gamma \\lt \\frac{1}{\\sqrt{2}} $$\n又因为 $\\mu \\gt 0$，得\n$$ 0 \\lt \\gamma \\lt \\frac{1}{\\sqrt{2}} $$\nReference 欧拉公式 latex 中的拉普拉斯变换符号代码 https://blog.csdn.net/ydyang1126/article/details/77247654 拉普拉斯变换与拉普拉斯逆变换的常用结论与经典公式 ","date":"2024-11-28T15:51:16+08:00","permalink":"https://blog.yexca.net/archives/202/","title":"东京科学大学大学院情报理工学院 2020 问题四 / 科学大院理工学 2020 問題四"},{"content":"问题一： https://blog.yexca.net/archives/198 问题二：本文\n问题三： https://blog.yexca.net/archives/200 问题四： https://blog.yexca.net/archives/202 问题五： https://blog.yexca.net/archives/203 引言 这一大题刚看的时候还以为属于形式语言 (与自动机理论) 呢，实际上手做题发现是数理的内容 (俩都没学过，也都一样)\n总体的难度不是特别难 (因为做过东大试卷吧，看这个的题目都不太难) 但还是需要掌握较多的理论基础才可解出\n题目版权属于东京科学大学所有，仅为了方便观看而引用，无盈利行为\n1 命題論理について考える。命題 $\\varphi$ を $(\\neg p_0 \\to \\neg p_1) \\wedge (\\neg p_1 \\to p_0)$ とする。ただし、$p_0, p_1$ は命題記号である。\na）以下の表が $\\varphi$ の真理値表になるように（ア）～（エ）にあてはまる値を答えよ。ただし、1は真を表し、0は偽を表す。\n$p_0$ $p_1$ $\\varphi$ 0 0 （ア） 0 1 （イ） 1 0 （ウ） 1 1 （エ） b）命題 $\\varphi$ が恒真（トートロジー）であるか否か答えよ。\nc）命題 $\\varphi$ が充足可能であるか否か答えよ。\n1-a 先ずは、命題 $\\varphi$ を整理する\n$$ \\begin{align} \\varphi \u0026amp;= (\\neg p_0 \\to \\neg p_1) \\wedge (\\neg p_1 \\to p_0) \\ \u0026amp;= (p_0 \\vee \\neg p_1) \\wedge (p_1 \\vee p_0) \\end{align} $$\nこれより\n$p_0$ $p_1$ $\\varphi$ 0 0 0 0 1 0 1 0 1 1 1 1 ゆえに、ア：0、イ：0、ウ：1、エ：1\n1-b $\\varphi=0$ の場合が存在するため、恒真命題ではない\n1-c $\\varphi=1$ の場合が存在するため、充足可能である\n2 命題論理の自然演繹について考える。$p_1, p_2, p_3$ は命題記号であり、$\\wedge I$ は連言の導入規則、$\\wedge E_L$ は連言の除去規則（左）、$\\wedge E_R$ は連言の除去規則（右）、$\\to E$ は含意の除去規則である。\na）$(p_1 \\wedge p_2) \\wedge p_3$ を仮定とし、$p_1 \\wedge (p_2 \\wedge p_3)$ を結論とする以下の自然演繹の導出（証明図）を完成させたい。（ア）～（オ）にあてはめる命題を答えよ。\n$$ \\cfrac{ \\cfrac{ \\cfrac{(p_1 \\wedge p_2)\\wedge p_3}{(ア)}\\wedge E_L }{p_1}\\wedge E_L \\quad \\cfrac{ \\cfrac{ \\cfrac{(p_1 \\wedge p_2) \\wedge p_3}{(イ)}\\wedge E_L }{(ウ)}\\wedge E_R \\quad \\cfrac{(p_1 \\wedge p_2) \\wedge p_3}{(エ)}\\wedge E_R }{(オ)}\\wedge I }{p_1 \\wedge (p_2 \\wedge p_3)}\\wedge I $$\nb）$p_1 \\wedge p_2$ と $p_1 \\to (p_2 \\to p_3)$ を仮定とし、$p_3$ を結論とする以下の自然演繹の導出（証明図）を完成させたい。（ア）～（エ）にあてはめる命題を答えよ。\n$$ \\cfrac{ \\cfrac{(ア)}{p_2}\\wedge E_R \\quad \\cfrac{ \\cfrac{(イ)}{p_1}\\wedge E_L \\quad (ウ) }{(エ)}\\to E }{p_3}\\to E $$\nc）命題の集合 ${ \\neg p_0 \\to \\neg p_1, \\neg p_1 \\to p_0 }$ が矛盾するか無矛盾であるかを答え、その理由を述べよ。\n2-解答 题目给出的几个符号如果能够了解的话，这题还是比较容易做出来前两问的\n$\\wedge I$ 是交集的导入规则，即将 $A$ 和 $B$ 变成 $A \\wedge B$\n$\\wedge E_L$ 是交集去除规则，留左侧，即将 $A \\wedge B$ 变成 $A$\n$\\wedge E_R$ 是交集去除规则，留右侧，即将 $A \\wedge B$ 变成 $B$\n$\\to E$ 是蕴含去除规则，即将 $A$ 和 $A \\to B$ 变成 $A$\n2-a ア: $p_1 \\wedge p_2$ イ: $p_1 \\wedge p_2$ ウ: $p_2$ エ: $p_3$ オ: $p_2 \\wedge p_3$ $$ \\cfrac{ \\cfrac{ \\cfrac{(p_1 \\wedge p_2)\\wedge p_3}{p_1 \\wedge p_2}\\wedge E_L }{p_1}\\wedge E_L \\quad \\cfrac{ \\cfrac{ \\cfrac{(p_1 \\wedge p_2) \\wedge p_3}{p_1 \\wedge p_2}\\wedge E_L }{p_2}\\wedge E_R \\quad \\cfrac{(p_1 \\wedge p_2) \\wedge p_3}{p_3}\\wedge E_R }{p_2 \\wedge p_3}\\wedge I }{p_1 \\wedge (p_2 \\wedge p_3)}\\wedge I $$\n2-b ア: $p_1 \\wedge p_2$ イ: $p_1 \\wedge p_2$ ウ: $p_1 \\to (p_2 \\to p_3)$ エ: $p_2 \\to p_3$ $$ \\cfrac{ \\cfrac{p_1 \\wedge p_2}{p_2}\\wedge E_R \\quad \\cfrac{ \\cfrac{p_1 \\wedge p_2}{p_1}\\wedge E_L \\quad p_1 \\to (p_2 \\to p_3) }{p_2 \\to p_3}\\to E }{p_3}\\to E $$\n2-c 無矛盾である。命題を整理する\n$$ \\neg p_0 \\to \\neg p_1 \\equiv p_0 \\vee \\neg p_1 \\ \\neg p_1 \\to p_0 \\equiv p_1 \\vee p_0 $$\n真理値表を作る\n$p_0$ $p_1$ $\\neg p_0 \\to \\neg p_1$ $\\neg p_1 \\to p_0$ 0 0 1 0 0 1 0 1 1 0 1 1 1 1 1 1 $p_0=1, p_1=0$ または $p_0=1, p_1=1$ の場合は、両方の命題が成り立つ\n少なくとも一つの真理値割り当てで命題集合が成り立つため、命題の集合 ${ \\neg p_0 \\to \\neg p_1, \\neg p_1 \\to p_0 }$ は無矛盾である\n3 一階述語論理について考える。\na）以下の論理式のモデルは存在するか。存在するならば、モデルのユニバースの濃度の最小値を答えよ。存在しないならば、その理由を述べよ。\n$$ \\exists x \\exists y \\exists z \\space \\neg(x=y) \\wedge \\neg(y=z) \\wedge \\neg(z=x) $$\nb）以下の論理式のモデルは存在するか。存在するならば、そのモデルを1つ挙げよ。存在しなければ、その理由を述べよ。\n$$ \\exists x \\forall y(x=y) $$\n3-a この論理式のモデルは存在する。モデルのユニバースの濃度の最小値は3である。\n3-b この論理式のモデルは存在する。例えば、ユニバース $U={a}$ を設定する。この場合、$U$ のすべての要素が $x$ と等しいため、論理式が成り立つ。\n4 一階述語論理の自然演繹について考える。以下が成り立つか否か答え、その理由を述べよ。ただし、$P$ はアリティ2の述語記号とする。\n$$ \\vdash (\\forall x \\exists y P(x,y)) \\to \\exists x \\forall y P(x,y) $$\n4-解答 これは成り立たない。反例は以下のように構成する。\nユニバースを ${ m,n,a,b }$ と定義する。このとき、述語 $P(x,y)$ の解釈を以下のように与える\n$$ P(m,a) = 真 \\quad P(a,m) = 偽 \\ P(n,b) = 真 \\quad P(b,n) = 偽 $$\nこれより、$\\forall x \\exists y P(x,y)$ が成り立つ。しかし、$\\exists x \\forall y P(x,y)$ は成り立たない。\nReference 自然演繹 命題論理 演繹定理 充足可能性問題 ","date":"2024-11-24T22:42:18+08:00","permalink":"https://blog.yexca.net/archives/201/","title":"东京科学大学大学院情报理工学院 2020 问题二"},{"content":"問題一： https://blog.yexca.net/archives/198 問題二： https://blog.yexca.net/archives/201 問題三：この文章\n問題四： https://blog.yexca.net/archives/202 問題五： https://blog.yexca.net/archives/203 引言 这个答题是算法题，初看有种要放弃治疗的感觉，但是在做了一遍后可以感觉到难度不是太大，但是需要较高的对于已有算法的理解力。之所以说难度不是太大可能跟我的心里预期有关吧，因为我觉得会不会要设计一个什么算法来着 (我想表达的意思是我并不觉得这个题目简单)\n题目版权属于东京科学大学所有，仅为了方便观看而引用，无盈利行为\n1 ｎ個の要素からなる整数の配列aを昇順に整列させる処理を、二つの異なるアルゴリズムに基づきＣ言語で実装した。プログラム3.1、3.2のキャプションＡ、Ｂを埋めるのに最も適切なアルゴリズムの名称を選択肢から選び、その記号を答えよ。\n「選択肢」\nア　選択ソート\nイ　バブルソート\nウ　クイックソート\nエ　挿入ソート\nプログラム3.1：A 1 2 3 4 5 6 7 8 9 10 11 12 13 void sort_a(int a[], int n) { int i, j, tmp; for(i=0; i\u0026lt;n-1; ++i){ for(j=n-1; i\u0026lt;j; --j){ if(a[j]\u0026lt;a[j-1]){ tmp=a[j]; a[j]=a[j-1]; a[j-1]=tmp; } } } } プログラム3.2：B 1 2 3 4 5 6 7 8 9 10 11 12 13 void sort_b(int a[], int n) { int i, j, tmp; for(j=1; j\u0026lt;n; ++j){ tmp=a[j]; i=j-1; while(0\u0026lt;=i \u0026amp;\u0026amp; tmp\u0026lt;a[i]){ a[i+1]=a[i]; --i; } a[i+1]=tmp; } } 解答\n这个题目就是对两个排序算法的代码，判断使用了什么排序方法。A 是冒泡排序 (イ　バブルソート)，B 是插入排序 (エ　挿入ソート)\n2 ヒープソートに関して、次の問いに答えよ。ただし、ｎは正の整数とする。\na）二分ヒープにおいて、根以外の任意の節点の値が満たすべき条件を説明せよ（maxヒープ条件とminヒープ条件のどちらでもよい）\nb）二分ヒープがｎ個の要素を格納しているとき、その木の高さをｎの式で表せ。なお、木の高さは、根と葉を結ぶ路の長さの最大値として定義される\nc）ヒープソートでｎ個の要素を整列させるとき、その平均時間計算量と最悪時間計算量の漸近的評価として、最も適切なものを以下の選択肢からそれぞれ答えよ\nア　$O(1)$\nイ　$O(\\log n)$\nウ　$O(n)$\nエ　$O(n\\log n)$\nオ　$O(n^2)$\n这题考堆排序，第一问写出除了根节点以外的任意节点的值需要满足什么条件 (二叉树大顶堆或者小顶堆选一个)；第二问是写出构成的堆的二叉树的高度；第三问就是选择平均时间复杂度和最坏情况复杂度\n解答\na\n最大ヒープ条件：根以外の任意の節点の値は、その親の値以下である必要がある。 最小ヒープ条件：根以外の任意の節点の値は、その親の値以上である必要がある。 b\n$$ \\left \\lfloor \\log_2n \\right \\rfloor $$\nc\n平均時間計算量と最悪時間計算量: エ　$O(n\\log n)$\n3 $A={ A[0], A[1], \\cdots, A[n-1] }$ をｎ個の相異なる整数の配列とする。ｎ未満の非負整数 $i,j$ に対し、$i\\lt j$ かつ $A[i]\\gt A[j]$ のとき、対 $(i,j)$ をAの反転と呼ぶ、Aの反転の数をAの反転数と呼ぶ。例えば、配列 ${ 5,7,4,6 }$ の反転は $(0,2),(1,2),(1,3)$ であり、反転数は3である。次の問いに答えよ。\na）配列 ${ 1,0,4,3,2, }$ の反転数を求めよ。\nb）集合 ${ 1,2,\\cdots,n }$ の要素をすべて並べた配列（要素数はｎ個）の中で、反転数が最大となるものを示せ。また、その反転数をｎの式で表せ。\nc）集合 ${ 1,2,\\cdots,n }$ の要素をすべて並べた任意の配列B（要素数はｎ個）をバブルソートで昇順に整列させる。このとき、「バブルソートにおけるＸと配列Ｂの反転数は等しい」という関係が成り立つ。Ｘを埋めるのに適切な語句と、その関係が成り立つ理由を簡潔に答えよ。\n这题首先引入了“逆序”的概念 ( 宋浩老师的线性代数课程 有讲)，问题一求逆序；问题二求最大逆序；问题三写出冒泡排序的什么和逆序数是相等的，并给出理由\n解答\na 逆序数为 4，分别为 (1,0), (4,3), (4,2), (3,2)\nb 最大的逆序数是当排列为\n$$ { n, n-1, n-2, \\cdots, 2, 1 } $$\n对于 n 有 n-1 个，对于 n-1 有 n-2 个，以此类推。逆序数为其之和\n$$ (n-1)+(n-2)+\\cdots+2+1+0=\\frac{n(n-1)}{2} $$\nc X：交換回数\n理由：スワップが反転を1つ解消する操作であるため\n冒泡排序是将每两个比较，将顺序不对的进行交换，一次操作也就是将逆序消除一个\n4 プログラム3.3は、整数の配列を昇順に整列させる処理を、マージソートのアルゴリズムに基づき、C言語で実装したものである、次の問いに答えよ。\nプログラム3.3：マージソート 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 int mergesort(int a[], int begin, int end, int w[]){ int mid = (begin+end)/2; int i = begin, j = mid+1, k, c=0; printf(\u0026#34;(%d, %d)\\n\u0026#34;, begin, end); if(begin\u0026lt;end){ mergesort(a, begin, mid, w); mergesort(a, mid+1, end, w); for(k=begin; k\u0026lt;=end; ++k){ if(mid\u0026lt;1){ A }else if(end\u0026lt;j){ B }else{ /* ++c */ if(a[i]\u0026lt;a[j]){ C }else{ D } } } for(k=begin; k\u0026lt;=end; ++k){ E } } return 0; } a）空欄A、B、C、D、Eを埋めるのに適切なコードを、選択肢から選び、プログラムを完成させよ。ただし、整列させたい配列をa整列時の作業領域に用いる配列をｗとし、mergesort 関数を以下の2行のコードで呼び出すこととする。\n1 2 int a[5] = {3, 5, 1, 4, 2}, w[5]; mergesort(a, 0, 4, w); 選択肢 $$ \\begin{matrix} ア. a[k]=w[i] \u0026amp; イ. a[k]=w[i++] \u0026amp; ウ. a[k]=w[++i] \\ エ. a[k]=w[j] \u0026amp; オ. a[k]=w[j++] \u0026amp; カ. a[k]=w[++j] \\ キ. a[k]=w[k] \u0026amp; ク. a[k]=w[k++] \u0026amp; ケ. a[k]=w[++k] \\ コ. w[k]=a[i] \u0026amp; サ. w[k]=a[i++] \u0026amp; シ. w[k]=a[++i] \\ ス. w[k]=a[j] \u0026amp; セ. w[k]=a[j++] \u0026amp; ソ. w[k]=a[++j] \\ タ. w[k]=a[k] \u0026amp; チ. w[k]=a[k++] \u0026amp; ツ. w[k]=a[++k] \\end{matrix} $$\nb）a）に示したコードで mergesort 関数を呼び出したとき、標準出力の1行目に $(0,4)$ が書き出される。3行目、5行目、7行目に書き出される内容をそれぞれ答えよ。\nc）mergesort 関数が引数で指定された範囲の配列の要素を整列させるまでにプログラム3.3の18行目を実行した回数の総数（要素の比較回数）を求めたい。そこで、17行目を（コメントアウトを外して）++c; に変更したが、これだけでは不十分である。以下の2行のコードで比較回数を変数 count に格納するには、プログラム3.3をどうのように変更すればよいか答えよ。\n1 2 int a[5] = {3, 5, 1, 4, 2}, w[5]; int count = mergesort(a, 0, 4, w); ただし、大域変数や静的変数を使っていけない。また、17行目の変更に加えて行うプログラムの変更は3回までの行の差し替えに限定する。行の差し替えとは、ある行のコードを60文字以内（空白文字は数えない）の別のコードに置き換えることを指す。解答の際は、以下の「答案の書き方（例）」のように、変更する行の番号と差し替え後のコードを記すこと。17行目のコメントは外してあることとし、それ以外に必要な変更を記述すること。\n「答案の書き方（例）」 6行目：printf(\u0026quot;hello\\n\u0026quot;);\n30行目：c= end - begin + 1;\n解答\na\nA: w[k] = a[j++]; 即 セ B: w[k] = a[i++]; 即 サ C: w[k] = a[i++]; 即 サ D: w[k] = a[j++]; 即 セ E: a[k] = w[k]; 即 キ b\n3 行目: (0,1)\n5 行目: (1,1)\n7 行目: (3,4)\nc\n8 行目: c += mergesort(a, begin, mid, w);\n9 行目: c += mergesort(a, mid + 1, end, w);\n31 行目: return c;\n这题乍一看是挺唬人的，但仔细阅读后发现考的内容倒是还行，理解了归并排序后倒是可以比较容易解出来。顺便因为我已经快忘完了算法，又之前都是看动画理解 (比较直观)，解题时得幸发现了 不错的动画算法网站 ","date":"2024-11-23T20:35:28+08:00","permalink":"https://blog.yexca.net/archives/200/","title":"东京科学大学大学院情报理工学院 2020 问题三 / 科学大院理工学 2020 問題三"},{"content":"以前写的小文章，系统创建时间 2023.12.01\n现在看着之前写的小文章都不大想发布，但也舍不得删，思来想去还是发布吧，也是自己写的\nngrok OneClick 到 官网 注册账号并验证邮箱后会获得 Authtoken\n下载程序： ngrok - download 添加 Token\n1 ngrok config add-authtoken YourToken 运行 1 ngrok http [Port] 替换 [Port] 为要监听的本地端口\n自搭建 ngrok 参考： ngrok内网穿透 学海无涯-回头是岸 学海无涯，回头是岸 frp 参考： frp 内网穿透 ","date":"2024-11-22T22:05:34+08:00","permalink":"https://blog.yexca.net/archives/199/","title":"内网穿透"},{"content":"问题一：本文\n问题二： https://blog.yexca.net/archives/201 问题三： https://blog.yexca.net/archives/200 问题四： https://blog.yexca.net/archives/202 问题五： https://blog.yexca.net/archives/203 まえがき 本文是首次使用非母语写的文章，又因为 比较懒 没有参考其他文章，存在用词出错的可能性。\nこの文章は初めて母国語じゃない言語で書いて、他の文章を参考しないので、言葉遣いがてきせつではないかも。それで、参考の答えはなくて、文章の答えが自分でできたので、正しくないかも。\n科学大とは東京工業大学の新しい名前で、略称が何か知らなくてこれを使った。\n問題の著作権は東京科学大学に帰属します。閲覧の便宜のためにのみ引用されており、営利を目的とするものではありません。\n1 以下の極限を求めよ。\na) $\\lim_{x\\to\\infty}{ \\log_e(2x+3)-\\log_e(x) }$\nb) $\\lim_{x\\to 0}\\frac{1-\\cos x}{x\\sin x}$\nc) $\\lim_{x\\to 0}\\frac{e^{3x}-\\cos x}{x}$\n回答\na\n$$ a=\\lim_{x \\to \\infty}\\log_e\\frac{2x+3}{x}=\\lim_{x\\to \\infty}\\log_e(2+\\frac{3}{x})=\\log_e2 $$\nb\n$$ \\because when \\space x \\to 0 ,\\space 1-\\cos x \\sim \\frac{1}{2}x^2 \\space and \\space sinx \\sim x \\ \\therefore \\lim_{x\\to 0}\\frac{1-\\cos x}{x\\sin x}=\\lim_{x\\to 0}\\frac{\\frac{1}{2}x^2}{x^2}=\\frac{1}{2} $$\nc ロピタルの定理を用いて\n$$ \\lim_{x\\to 0}\\frac{e^{3x}-\\cos x}{x}=\\lim_{x\\to 0}\\frac{3e^{3x}+sinx}{1}=3 $$\n2 以下の実行列の積の行列式を計算せよ。\n$$ \\begin{pmatrix} 1 \u0026amp; 0 \u0026amp; 0 \\ x \u0026amp; 2 \u0026amp; 1 \\ x^2 \u0026amp; 3 \u0026amp; 2 \\end{pmatrix} \\begin{pmatrix} 31 \u0026amp; 23 \u0026amp; 17 \\ 0 \u0026amp; 11 \u0026amp; 11 \\ 0 \u0026amp; 4 \u0026amp; 5 \\end{pmatrix} $$\nThe determinant of the product of two matrices is the product of their determinants\nFor A\n$$ A=\\begin{pmatrix} 1 \u0026amp; 0 \u0026amp; 0 \\ x \u0026amp; 2 \u0026amp; 1 \\ x^2 \u0026amp; 3 \u0026amp; 2 \\end{pmatrix} $$\nThe determinant of A\n$$ \\det(A)=(-1)^{1+1} \\times 1 \\times \\begin{vmatrix} 2 \u0026amp; 1 \\ 3 \u0026amp; 2 \\end{vmatrix} -0+0 =1 $$\nFor B\n$$ B=\\begin{pmatrix} 31 \u0026amp; 23 \u0026amp; 17 \\ 0 \u0026amp; 11 \u0026amp; 11 \\ 0 \u0026amp; 4 \u0026amp; 5 \\end{pmatrix} $$\nThe determinant of B\n$$ \\det(B)=(-1)^{1+1} \\times 31 \\times \\begin{vmatrix} 11 \u0026amp; 11 \\ 4 \u0026amp; 5 \\end{vmatrix} -0+0 = 341 $$\nso\n$$ \\det=\\det(A) \\times \\det(B)=1 \\times 341 = 341 $$\n3 以下の確率密度関数 $f_X(x)$ に従う連続型確率変数 $X$ の分散 $V(X)$ 、累積分布関数 $F_X(x)$ を各々求めよ。ただし、$\\lim_{x \\to +0}x^n\\log_e(x)=0$ ($n$ は 1 以上の整数) とする。\n$$ F_X(x)=\\left { \\begin{matrix} -4x\\log_e(x) \u0026amp; 0 \\lt x \\le 1 \\ 0 \u0026amp; x \\le 0 \\space または \\space x \\gt 1 \\end{matrix} \\right . $$\nまずは、累積分布関数を考えて\n$x \\le 0$ $$ F_X(x) = 0 $$\n$x\\gt 1$ $$ F_X(x) = 1 $$\n$0 \\lt x \\le 1$ $$ \\begin{align} F_X(x) \u0026amp;= \\int_0^x(-4t\\log_e(t))dt \\ \\end{align} $$\n部分積分を用いて\n$$ \\begin{matrix} u = \\ln t \u0026amp; dv=4tdt \\ du = \\frac{1}{t}dt \u0026amp; v=2t^2 \\end{matrix} $$\nしたがって\n$$ \\begin{align} F_X(x) \u0026amp;=-( [2t^2\\ln t]_0^x - \\int_0^x 2t^2\\frac{1}{t}dt ) \\ \u0026amp;=-( 2x^2\\ln x - \\int_0^x 2t dt ) \\ \u0026amp;=-( 2x^2\\ln x - t^2\\mid_0^x ) \\ \u0026amp;=x^2 - 2x^2\\ln x \\end{align} $$\nこれより\n$$ F_X(x)= \\left { \\begin{matrix} 0 \u0026amp; x \\le 0 \\ x^2-2x^2\\ln x \u0026amp; 0 \\lt x \\le 1 \\ 1 \u0026amp; x \\gt 1 \\end{matrix} \\right . $$\n次に、分散を求める。分散の定義は\n$$ V(X)=E[X^2] - (E[X])^2 $$\n期待値 $E[X]$ を計算する\n$$ \\begin{align} E[X] \u0026amp;= \\int_{-\\infty}^{\\infty}xf_X(x)dx \\ \u0026amp;= \\int_0^1x(-4x\\ln x)dx \\ \u0026amp;= -\\int_0^1 4x^2\\ln xdx \\end{align} $$\n部分積分を用いて\n$$ \\begin{matrix} u=\\ln x \u0026amp; dv=4x^2dx \\ du=\\frac{1}{x} \u0026amp; v=\\frac{4}{3}x^3 \\end{matrix} $$\nしたがって\n$$ \\begin{align} E[X] \u0026amp;= -([\\frac{4}{3}x^3\\ln x]_0^1-\\int_0^1\\frac{4}{3}x^3\\frac{1}{x}dx) \\ \u0026amp;= -(-\\frac{4}{9}x^3\\mid_0^1) \\ \u0026amp;= \\frac{4}{9} \\end{align} $$\n$E[X^2]$ の計算\n$$ \\begin{align} E[X^2] \u0026amp;= \\int_{-\\infty}^{\\infty}x^2f_X(x)dx \\ \u0026amp;= \\int_0^1x^2(-4x\\ln x)dx \\ \u0026amp;= -4\\int_0^1x^3\\ln xdx \\end{align} $$\n部分積分を用いて\n$$ \\begin{matrix} u=\\ln x \u0026amp; dv=x^3dx \\ du=\\frac{1}{x} \u0026amp; v=\\frac{1}{4}x^4 \\end{matrix} $$\nしたがって\n$$ \\begin{align} E[X^2] \u0026amp;= -4 \\times ([\\frac{1}{4}x^4\\ln x]_0^1-\\int_0^1\\frac{1}{4}x^3dx) \\ \u0026amp;= -4 \\times (-\\frac{1}{16}x^4\\mid_0^1) \\ \u0026amp;= \\frac{1}{4} \\end{align} $$\nだから\n$$ \\begin{align} V(X) \u0026amp;= E[X^2] - (E[X])^2 \\ \u0026amp;= \\frac{1}{4} - (\\frac{4}{9})^2 \\ \u0026amp;= \\frac{17}{342} \\end{align} $$\n4 ある製造ラインで生産された製品は1/1000の確率で不良品である。不良品を99/100の確率で正しく不良品と判定し、かつ、不良品でないものを4/5の確率で正しく不良品ではないと判定する検査手法がある。この製造ラインにおいて、この手法が不良品と判定した製品が、不良品である確率を求めよ。\n不良品である確率：$P(A)=\\frac{1}{1000}$、不良品と判定する確率：$P(B)$\nこれより\n$$ \\begin{matrix} p(\\bar{A})=\\frac{999}{1000} \u0026amp; P(B\\mid A)=\\frac{99}{100} \u0026amp; P(B\\mid \\bar{A})=\\frac{1}{5} \\end{matrix} $$\nしたがって\n$$ P(B)=P(A)P(B\\mid A)+P(\\bar{A})P(B\\mid \\bar{A})=\\frac{20079}{100000} $$\nベイズの定理を用いると\n$$ P(A\\mid B)=\\frac{P(AB)}{P(B)}=\\frac{P(A)P(B\\mid A)}{P(B)}=\\frac{99}{20079} $$\n以上より、不良品である確率は $\\frac{99}{20079}$\n5 あるカジノで、4個のパケットA,B,C,Dに区切られたルーレットがある。カジノの説明ではそれぞれのパケットにボールが入る確率は同じであるとされている。そのルーレットを5回試行したところ、ボールはパケットAに4回入った。カジノの説明とは異なる「このルーレットはボールがポケットAにより入りやすい」という仮設を、有意水準5％で検定せよ。解答には帰無仮説 $H_0$ 、対立仮説 $H_1$ を明記すること。\n$H_0$：ポケットAにボールが入る確率は他のポケットと同じである。すなわち\n$$ P(A)=\\frac{1}{4} $$\n$H_1$ ：ポケットAにボールが入る確率は他のポケットより高い。すなわち\n$$ P(A)\\gt \\frac{1}{4} $$\nボールはポケットAに4回入る確率は\n$$ P(X=4)=(_4^5) (\\frac{1}{4})^4 \\times \\frac{3}{4}=\\frac{15}{1024} $$\nボールはポケットAに5回入る確率は\n$$ P(X=5)=(_5^5) (\\frac{1}{4})^5=\\frac{1}{1024} $$\nこれより\n$$ P(X\\ge 4)=\\frac{15}{1024}+\\frac{1}{1024}=\\frac{1}{64} $$\nこの確率は有意水準より小さいため、帰無仮説を棄却する。ゆえに、「このルーレットはボールがポケットAにより入りやすい」という仮設は統計的に有意であると言えます。\n","date":"2024-11-21T15:42:18+08:00","permalink":"https://blog.yexca.net/archives/198/","title":"东京科学大学大学院情报理工学院 2020 问题一"},{"content":"引言 Sometimes it\u0026rsquo;s the people who no one imagines anything of who do the things that no one can imagine\n最近从 毕导视频 弹幕中得知关于图灵的记录片 The Imitation Game(模拟游戏)，顺便看了一下，对于片中出现的该句话感触颇深，以此当作形式语言与自动机文章的开篇题引\n当您开始有点抑郁的时候，也请看看 Amy 关于此句的感悟 吧\n基本概念 字母表：符号 (字符) 的非空又穷集\n$$ {\\textstyle \\sum_1} = {0, 1} $$\n字符串：由某字母表中符号组成的有穷序列\n$$ 若 \\space {\\textstyle \\sum_1} = {0, 1}，那么 \\space 0，1，00，101011 \\space 为 \\space {\\textstyle \\sum_1} \\space 上的字符串 $$\n空串：记为 $\\varepsilon$ ，有 0 个字符的串。对任意字母表 $\\sum$ 都有 $\\varepsilon \\notin \\sum$\n符号的使用约定\n字母表：$\\sum, \\Gamma, \\cdots$\n字符：$a, b, c, \\cdots$\n字符串：$\\cdots,w,x,y,z$\n集合：$A,B,C,\\cdots$\n字符串的长度：字符串中符号所占位置的个数\n$$ 对于 \\space {\\textstyle \\sum_1} = {0, 1}，|0010|=4 $$\n字符串 $x$ 和 $y$ 的连接：将首尾相接得到新字符串的运算，记为 $x \\cdot y$ 或 $xy$\n$$ x=01, y=ab, 则 \\space xy=01ab $$\n字符串 $x$ 的 $n$ 次幂 ($n \\ge 0$) ，递归定义为\n$$ x^n= \\left { \\begin{matrix} \\varepsilon \u0026amp; n=0 \\ x^{n-1}x \u0026amp; n \\gt 0 \\end{matrix} \\right . $$\n$对于 \\space {\\textstyle \\sum_1} = {a, b} (ba)^2=baba, ba^2=baa$\n集合 $A$ 和 $B$ 的连接，记为 $A\\cdot B$ 或 $AB$ ，定义为\n$$ A \\cdot B = { w |w=x \\cdot y, x \\in A \\space and \\space y \\in B } $$\n若 $\\space A = {0, 11} \\space B = {ab, ba} $\n$AB = { 0ab, 0ba, 11ab, 11ba }, BA= { ab0, ab11, ba0, ba11 }$\n集合 $A$ 的 $n$ 次幂 ($n \\ge 0$) ，递归定义为\n$$ A^n= \\left { \\begin{matrix} { \\varepsilon } \u0026amp; n=0\\ A^{n-1}A \u0026amp; n \\ge 1 \\end{matrix} \\right . $$\n$对于 \\space {\\textstyle \\sum_1} = {0, 1} $，有 ${\\textstyle \\sum^0}={\\varepsilon}, {\\textstyle \\sum^1}={0,1}, {\\textstyle \\sum^2}={00,01,10,11}, \\cdots$\n克林闭包 (Kleene Closure) : 将某字母表的所有幂 (包含零次) 去并集得到\n$$ {\\textstyle \\sum^*} = \\bigcup_{i=0}^{\\infty}{\\textstyle \\sum^i} $$\n正闭包 (Positive Closure) : 将某字母表的所有幂 (不包含零次) 去并集得到\n$$ {\\textstyle \\sum^+} = \\bigcup_{i=1}^{\\infty}{\\textstyle \\sum^i} $$\n显然\n$$ {\\textstyle \\sum^*} = {\\textstyle \\sum^+} \\cup { \\varepsilon } $$\n语言 定义：若 $\\sum$ 为字母表且 $\\forall L \\subseteq \\sum^*$ ，则 $L$ 称为字母表 $\\sum$ 上的语言\n自然语言、程序设计语言等 $ \\{ 0^n 1^n \\mid n \\ge 0 \\} $ The set of strings of 0\u0026rsquo;s and 1\u0026rsquo;s with an equal number of each $\\emptyset$ ，${ \\varepsilon }$ 和 $\\sum^*$ 分别都是任意字母表 $\\sum$ 上的语言，但 $\\emptyset \\ne { \\varepsilon }$ 语言唯一的约束就是所有字母表都是有穷的\n","date":"2024-11-19T22:18:42+08:00","permalink":"https://blog.yexca.net/archives/197/","title":"形式语言与自动机 - 基本概念"},{"content":"Vue 指令 Vue 会根据不同的指令，针对标签实现不同的功能，指令为带有 v- 前缀的特殊标签属性\nv-html 用于设置元素的 innerHTML\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;v-html\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;div v-html=\u0026#34;link\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const app = new Vue({ el: \u0026#39;#app\u0026#39;, data: { link:\u0026#39;\u0026lt;a href=\u0026#34;https://yexca.net/\u0026#34;\u0026gt;yexca\u0026lt;/a\u0026gt;\u0026#39; } }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; v-show 与 v-if \\ v-show v-if 作用 控制元素显示隐藏 控制元素显示隐藏 (条件渲染) 语法 v-show=\u0026ldquo;表达式\u0026rdquo; v-if=\u0026ldquo;表达式\u0026rdquo; 表达式值 ture 显示，false 隐藏 ture 显示，false 隐藏 隐藏说明 通过控制属性 style=\u0026quot;display:none;\u0026quot; 直接删除或创建元素 场景 频繁切换 不频繁切换 v-else 与 v-else-if 用于辅助 v-if 进行渲染，需要紧挨着 v-if 一起使用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;v-else and v-else-if\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;p v-if=\u0026#34;gender === 1\u0026#34;\u0026gt;性别：男\u0026lt;/p\u0026gt; \u0026lt;p v-else\u0026gt;性别：女\u0026lt;/p\u0026gt; \u0026lt;hr /\u0026gt; \u0026lt;p v-if=\u0026#34;score \u0026gt;= 90\u0026#34;\u0026gt;成绩判定 A\u0026lt;/p\u0026gt; \u0026lt;p v-else-if=\u0026#34;score \u0026gt;= 70\u0026#34;\u0026gt;成绩判定 B\u0026lt;/p\u0026gt; \u0026lt;p v-else-if=\u0026#34;score \u0026gt;= 60\u0026#34;\u0026gt;成绩判定 C\u0026lt;/p\u0026gt; \u0026lt;p v-else\u0026gt;成绩判定 D\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const app = new Vue({ el: \u0026#39;#app\u0026#39;, data: { gender: 1, score: 89 } }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; v-on 用于注册事件 = 添加监听 + 提供处理逻辑\n语法一 v-on:事件名=\u0026ldquo;内联语句\u0026rdquo;\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;v-on 1\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;button v-on:click=\u0026#34;count1--\u0026#34;\u0026gt;-\u0026lt;/button\u0026gt; \u0026lt;span\u0026gt;{{count1}} \u0026lt;/span\u0026gt; \u0026lt;!-- v-on: 可以替换为 @ --\u0026gt; \u0026lt;button @click=\u0026#34;count1++\u0026#34;\u0026gt;+\u0026lt;/button\u0026gt; \u0026lt;hr /\u0026gt; \u0026lt;button v-on:mouseenter=\u0026#34;count2--\u0026#34;\u0026gt;-\u0026lt;/button\u0026gt; \u0026lt;span\u0026gt;{{count2}}\u0026lt;/span\u0026gt; \u0026lt;button v-on:mouseenter=\u0026#34;count2++\u0026#34;\u0026gt;+\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const app = new Vue({ el: \u0026#39;#app\u0026#39;, data: { count1: 1, count2: 2 } }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 语法二 v-on:事件名=\u0026ldquo;methods中的函数名\u0026rdquo;\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;v-on 2\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;button @click=\u0026#34;fun\u0026#34;\u0026gt;切换显示隐藏\u0026lt;/button\u0026gt; \u0026lt;p v-show=\u0026#34;isShow\u0026#34;\u0026gt;hello yexca\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const app = new Vue({ el: \u0026#34;#app\u0026#34;, data: { isShow: true }, methods: { fun(){ // this 始终指向当前实例 this.isShow = !this.isShow } } }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 调用传参 直接上案例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;v-on 3\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; .box{ border-style: solid; border-color: aqua; padding: 10px; margin: 10px; width: 200px; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;自动售货机\u0026lt;/h3\u0026gt; \u0026lt;button @click=\u0026#34;fun(5)\u0026#34;\u0026gt;可乐5元\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;fun(10)\u0026#34;\u0026gt;咖啡10元\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div style=\u0026#34;padding-left: 20px;\u0026#34;\u0026gt;余额：{{balance}}\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;../js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const app = new Vue({ el: \u0026#34;#app\u0026#34;, data: { balance: 900 }, methods: { fun(a){ this.balance -= a } } }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; v-bind 用于动态的设置 html 的标签属性，如 src、url、title 等\n语法：v-bind:属性名=\u0026ldquo;表达式\u0026rdquo;\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;v-bind\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; img{ width: 400px; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;!-- v-bind 可以省略 --\u0026gt; \u0026lt;img v-bind:src=\u0026#34;imgURL\u0026#34; :title=\u0026#34;imgTitle\u0026#34; :alt=\u0026#34;imgAlt\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;../js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const app = new Vue({ el: \u0026#39;#app\u0026#39;, data: { imgURL: \u0026#39;../img/01.jpg\u0026#39;, imgTitle: \u0026#39;warma\u0026#39;, imgAlt: \u0026#39;warma\u0026#39; } }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; v-for 基于数据循环，多次渲染整个元素\n语法：v-for=\u0026quot;(item, index) in 数组\u0026quot;\nitem：每一项，index：下标\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;v-for\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;fruit shop\u0026lt;/h3\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;!-- 当 index 不需要时可以省略 --\u0026gt; \u0026lt;li v-for=\u0026#34;item in list\u0026#34;\u0026gt;{{ item }}\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;(item,index) in list\u0026#34;\u0026gt;{{ index }}\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;../js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const app = new Vue({ el: \u0026#39;#app\u0026#39;, data: { list: [\u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;watermelon\u0026#39;] } }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 为便于 Vue 进行列表项的正确排序复用，需要给元素添加唯一标识，即 key 属性\nkey 的值只能是字符串或数字类型，且必须具有唯一性\n1 \u0026lt;li v-for=\u0026#34;(item, index) in list\u0026#34; :key=\u0026#34;item.id\u0026#34;\u0026gt;\u0026lt;/li\u0026gt; 推荐使用 id 作为 key，不推荐使用 index 作为 key (会变化，不对应)\nv-model 给表单元素使用，实现双向数据绑定，以可以快速获取或设置表单元素内容\n双向数据绑定即视图变化，数据自动更新\n语法：v-model=\u0026lsquo;变量\u0026rsquo;\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;v-model\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; username: \u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;username\u0026#34;/\u0026gt;\u0026lt;br /\u0026gt;\u0026lt;br /\u0026gt; password: \u0026lt;input type=\u0026#34;password\u0026#34; v-model=\u0026#34;password\u0026#34; /\u0026gt;\u0026lt;br /\u0026gt;\u0026lt;br /\u0026gt; \u0026lt;button @click=\u0026#34;login\u0026#34;\u0026gt;登录\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;reset\u0026#34;\u0026gt;重置\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;../js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const app = new Vue({ el: \u0026#39;#app\u0026#39;, data: { username: \u0026#39;\u0026#39;, password: \u0026#39;\u0026#39; }, methods: { login(){ console.log(this.username, this.password) }, reset(){ this.username = \u0026#39;\u0026#39; this.password = \u0026#39;\u0026#39; } } }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 指令修饰符 通过 . 指明一些指令后缀，不同后缀封装了不同的处理操作\n按键修饰符\n@keyup.enter 键盘回车监听\nv-model 修饰符\nv-model.trim 去除首尾空格\nv-model.number 转数字\n事件修饰符\n@事件名.stop 阻止冒泡\n@事件名.prevent 阻止默认行为\n计算属性 基于现有的数据，计算出来的新属性。依赖的数据变化，自动重新计算\nVue 生命周期 生命周期指一个对象从创建到销毁的整个过程\nVue 生命周期有 8 个阶段，每触发一个生命周期事件，会自动执行一个生命周期方法 (钩子)\n状态 阶段周期 beforeCreate 创建前 created 创建后 beforeMount 载入前 mounted 挂载完成 beforeUpdate 更新前 updated 更新后 beforeDestroy 销毁前 destroyed 销毁后 其中 mounted 较为常用，指 Vue 初始化成功，HTML 渲染成功。(发送请求到服务端，加载数据)\n1 2 3 4 5 6 7 8 9 10 11 12 new Vue(){ el: \u0026#34;#app\u0026#34;, data: { }, mounted(){ console.log(\u0026#34;Vue 挂载完成，发送请求获取数据\u0026#34;); }, methods: { } } ","date":"2024-11-15T20:48:29+08:00","permalink":"https://blog.yexca.net/archives/196/","title":"Vue 学习"},{"content":"引言 HTML 学习一 - 基础: https://blog.yexca.net/archives/146 HTML 学习二 - 列表、表格与表单: https://blog.yexca.net/archives/150 HTML 学习三 - 网页布局: https://blog.yexca.net/archives/195 标准流也叫文档流，指的是标签在页面中默认的排布规则，例如：块元素独占一行，行内元素可以一行显示多个\n若不按标准流布局可使用浮动或 Flex 布局\n浮动 作用：使块元素水平排列，属性名 float，属性值有两个：left 和 right\n加了浮动的盒子将脱离标准流\n清除浮动影响 因为浮动元素会脱离标准流，如果父级没有高度，自己将无法撑开父级高度，可能导致页面布局错乱\n清除浮动常用四种方法\n额外标签法 在父元素的最后添加一个块级元素，设置 CSS 属性 clear:both\n1 2 3 4 5 6 7 8 9 10 \u0026lt;style\u0026gt; .clearfix { clear: both; } \u0026lt;/style\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;clearfix\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 单伪元素法 原理同上\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;style\u0026gt; .clearfix::after { content: \u0026#34;\u0026#34;; display: block; clear: both; } \u0026lt;/style\u0026gt; \u0026lt;div class=\u0026#34;clearfix\u0026#34;\u0026gt; \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 双伪元素法 此方法可同时解决塌陷问题与浮动影响\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;style\u0026gt; .clearfix::before, /* 解决塌陷问题 */ .clearfix::after { content: \u0026#34;\u0026#34;; display: table; } .clearfix::after { /* 解决浮动问题 */ clear: both; } \u0026lt;/style\u0026gt; \u0026lt;div class=\u0026#34;clearfix\u0026#34;\u0026gt; \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; overflow 在父元素添加 CSS 属性 overflow: hidden;\nFlex Felx 布局也叫弹性布局，是浏览器提倡的布局模型，非常适合结构化布局，提供了强大的空间分布和对齐能力\n而且 Flex 模型不会产生浮动布局中的脱离标准流现象，布局网页更简单、更灵活\n组成 Flex 有四个组成部分\n弹性容器 弹性盒子 主轴：默认在水平方向 侧轴/交叉轴：默认在垂直方向 给父元素设置 display: flex; 将变成弹性容器，子元素变为弹性盒子，可以自动挤压或拉伸\nFlex 布局 描述 属性 主轴对齐方式 justify-content 侧轴对齐方式 align-items 某个弹性盒子\n侧轴对齐方式 align-self 修改主轴方向 flex-direction 弹性伸缩化 flex 弹性盒子换行 flex-wrap 行对齐方式 align-content 主轴对齐方式 属性名：justify-content\n属性值 效果 flex-start 默认值，弹性盒子从起点开始依次排列 flex-end 弹性盒子从终点开始依次排列 center 弹性盒子沿主轴居中排列 space-between 弹性盒子沿主轴均匀排列，空白间距均分在弹性盒子之间 space-around 弹性盒子沿主轴均匀排列，空白间距均分在弹性盒子两侧 space-evenly 弹性盒子沿主轴均匀排列，弹性盒子与容器之间间距相等 侧轴对齐方式 属性名\nalign-items: 当前弹性容器内所有弹性盒子的侧轴对齐方式 (给弹性容器设置) align-self: 单独控制某个弹性盒子的侧轴对齐方式 (给弹性盒子设置) 属性值 效果 stretch 弹性盒子沿着侧轴线被拉伸至铺满容器 (弹性盒子没有设置侧轴方向尺寸则默认拉伸) center 弹性盒子沿侧轴居中排列 flex-start 弹性盒子从起点开始依次排列 flex-end 弹性盒子从终点开始依次排列 修改主轴方向 主轴默认在水平方向，侧轴默认在垂直方向\n属性名：flex-direction\n属性值 效果 row 水平方向，从左向右 (默认) column 垂直方向，从上向下 row-reverse 水平方向，从右向左 column-reverse 垂直方向，从下向上 弹性伸缩比 作用：控制弹性盒子的主轴方向的尺寸。属性名：flex，在子级 (弹性盒子) 添加\n属性值：整数数字，表示占用父级剩余尺寸的份数\n弹性盒子换行 弹性盒子可以自动挤压或拉伸，默认情况下，所有弹性盒子都在一行显示。属性名：flex-wrap，在父级 (弹性容器) 添加\n属性值有 wrap (换行) 和 nowrap (不换行，默认)\n行对齐方式 属性名：align-content\n属性值与主轴对齐方式相同，只对多行弹性盒子生效\n","date":"2024-11-10T21:36:51+08:00","permalink":"https://blog.yexca.net/archives/195/","title":"HTML 学习三 - 网页布局"},{"content":"引言 2022 SA am2\n01-08: http://127.0.0.1:4000/archives/191 09-15: http://127.0.0.1:4000/archives/192 16-20: http://127.0.0.1:4000/archives/193 21-25: http://127.0.0.1:4000/archives/194 这五题的难度还好，本来解完充满自信来着，不小心看了下下午论述题，我瞬间没自信了 :cry:\n碎碎念 思考人生这种事情也确实是空闲的人会思考的，忙起来后也就没时间去胡思乱想了 但忙过头了说不定也会想呢\n我如今应该是意识到自己之前的两点不足了。首先是总觉得随时都能复习；其次是“学无止境”这个观念的误用。\n应该先从学无止境开始吧。“学无止境”本身是正确的，但是我对这个概念的理解有些偏颇。我一直认为知识是无限的，总觉得自己不可能完全掌握任何东西，也因此产生了“什么都不会”的心态。实际上，虽然知识的确无穷无尽，但并不意味着每个领域都必须完全精通才能实际应用。有时，掌握其中一部分内容已经足够应对工作和任务了\n例如我常常在通过一门考试之后，依然会觉得自己一无所知，仍然无法胜任相关工作。然而，客观来说，只要掌握了必要的部分内容，就已经具备了完成相关任务的能力。这个心态可能和我过去受到的教育有关，常常听到类似“世界很大”“所学远远不够”“真正的高手有多厉害”等话语。这种观念在一定程度上鼓励了学习，却也让我过于关注自身的不足，逐渐失去了原本的信心\n像是现在我听到的多数学生也是会“我什么都做不到”之类的话语，可能有部分原因是这种观念带来的副作用\n然后就是随时都能复习的想法。倒也不是复习，更像是一种“随时可以查阅”的依赖心理。我之前备考日语 N2 时候读到一篇文章，讲述了没有文字的人如何学习之类的，因为没有文字的记载，对于知识的获取如上课可能是此生只有一次机会听到该内容，所以必须全部努力记下来才行；文章还提到了我们因为网络很便利而不去记忆一些东西，并且认为网络能检索到的东西都是自己的知识，但假如网络不能用的话事实上是不知道那些内容的，所以真正属于自己的知识是那些已经内化到记忆中的东西。\n回到我的情况，我也是因为觉得可以随时看，比如某条 Linux 命令啦或某段算法代码之类的而不去记忆，造成一种我以为我会，但用的时候并不能写出来，实际上应该属于不会的范畴。这样反复的经历也加深了前面提到的“什么都不会”的感觉。\n总结一下，首先应当意识到未被记忆的东西应该属于不会，并且胜任某件作业或者可以成为某种角色所需掌握的知识是有边界的，不用去尝试完全精通\n感觉写出来和想表达的意思还是有点偏差，文笔不好还使用了 ChatGPT，就这样吧\n21 容量が a M バイトでアクセス時間がｘナノ秒の命令カッシュと、容量が b M バイトでアクセス時間がｙナノ秒の主記憶をもつシステムにおいて、CPUからみた、主記憶と命令キャッシュとを合わせた平均アクセス時間を表す式はどれか。ここで、読み込みたい命令コードが命令キャッシュに存在しない確率をｒし、キャッシュ管理に関するオーバヘッドは無視できるものとする。\n$$ \\begin{align} ア　\u0026amp;\\frac{(1-r)\\cdot a}{a+b} \\cdot x +\\frac{r \\cdot b}{a+b} \\cdot y \\ イ　\u0026amp;(1-r) \\cdot x + r \\cdot y \\ ウ　\u0026amp;\\frac{r \\cdot a}{a+b} \\cdot x + \\frac{(1-r) \\cdot b}{a+b} \\cdot y \\ エ　\u0026amp;r \\cdot x + (1-r) \\cdot y \\end{align} $$\n题目翻译：容量为 a MB、访问时间为 x 纳秒的指令缓存和容量为 b MB、访问时间为 y 纳秒的主存储器构成的系统中，从 CPU 的角度来看，主存储器和指令缓存的平均访问时间的表达式是哪一个？其中，所需的指令代码不存在于指令缓存中的概率为 r，可以忽略与缓存管理相关的开销\n命中缓存时间是 $(1-r) \\times x$ 未命中缓存，读取主存时间为 $r \\times y$ 所以答案选 イ\n22 データベースサーバのクラスタリング技術の特徴のうち、シェアードエブリシングはどれか。\nア　クラスタリング構成にして可用性を高めることによって、故障発生時に担当していた範囲のデータを待機系のサーバに引き継ぐことができる。\nイ　サーバごとに管理する対象データが決まっているので、1台のサーバに故障が発生すると故障したサーバが管理する対象データを処理できなくなり、システム全体の可用性が低下する。\nウ　データを複数の磁気ディスクに分割配置し、更にサーバと磁気ディスクが1対1に対応しているので、複数サーバを用いた並列処理ができる。\nエ　負荷を分散し、全てのサーバのリソースを有効活用できることに加えて、データを共有することによって1台のサーバに故障が発生したときでも処理を継続することができる。\n题目翻译：在数据库服务器的集群技术 (clustering) 特性中，以下哪一项描述了 Shared Everything 的特点\nア　通过集群配置提高可用性，故障发生时可以将负责的范围内数据转交给备用服务器\nイ　每个服务器负责管理特定数据，因此如果某个服务器发生故障，则无法处理该服务器负责的数据，系统的整体可用性会下降\nウ　数据被分割并放置在多个磁盘上，服务器和磁盘之间是一对一的对应关系，因此可以利用多个服务器进行并行处理\nエ　在负载分散的同时可以有效利用所有服务器资源，并且通过共享数据，即使某一台服务器发生故障，也能继续处理\nShared Everything 是一种数据库集群架构，在该架构中，所有服务器共享相同的数据存储。这样一来，任何一台服务器的资源都可以访问和处理数据库中的所有数据，从而提高系统的冗余性和容错能力。如果一台服务器出现故障，其他服务器可以接管该服务器的任务，不会导致系统整体不可用。所以答案选 エ\n选项 ア 描述的是主备架构；选项 イ 描述的是 Shared Nothing 架构；选项 エ 描述的是 Shared Disk 架构 (最后俩架构看看就好 doge)\n23 幾つかのサブシステムから成るシステムの信頼性に関する記述のうち、適切なものはどれか。\nア　あるサブシステムで発生したフォールトの影響が他のサブシステムに波及することを防ぐフォールトマスグは、システムのMTBFは変化させないが、MTTRの短縮につながる。\nイ　サブシステムにフォールトが検出されたとき、再試行すると正しい結果が得られる場合もあるので、再試行はシステムのMTBFの向上とMTTRの短縮につながる。\nウ　サブシステムの稼働中に行われるフォールトの検出は、システムを停止せず行われるので、システムのMTTRは変化させないが、MTBFの向上につながる。\nエ　フォールトが発生したあるサブシステムを切り離して、待機系のサブシステムに自動で切り替えるフェールオーバーは、システムのMTBFは変化させないが、MTTRの短縮につながる。\n题目翻译：以下关于由多个子系统组成的系统的可靠性的描述中，哪一项是正确的\nア　故障隔离 (Fault Masking) 防止某个子系统中发生的故障影响到其他子系统，虽然不改变系统的平均无故障时间 (MTBF) ，但可以缩短平均修复时间 (MTTR)\nイ　当检测到子系统中有故障时，重试可能会得到正确的结果，因此重试会提升系统的 MTBF，并缩短 MTTR\nウ　在子系统运行过程中进行的故障检测不会停止系统，因此不会改变系统的 MTTR，但可以提升 MTBF\nエ　发生故障的子系统会被隔离，并自动切换到备用子系统的故障转移 (Failover) 机制不会改变系统的 MTBF，但可以缩短 MTTR\n对于多子系统组成的系统来说，可靠性通常取决于 MTBF 和 MTTR。MTBF is Mean Time Between Failures. MTTR is Mean Time To Repair (Recovery).\nFault Masking (故障隔离) 确保故障不会蔓延至其他子系统。故障隔离的确减少了受故障影响的子系统数量，帮助快速修复，但不会直接影响系统的 MTBF，因为它只是隔离了故障，而不是防止故障的发生\n重试在系统中可以用于处理偶发的错误。但它属于容错机制，并不能提高系统整体的 MTBF 。因为系统的根本故障没有减少，这一机制只是避免了某些操作失败\n故障检测能在运行过程中提升系统的 MTBF，但与 MTTR 无关\nFailover (故障转移) 将故障系统切换至备用系统，提升系统恢复能力。这种方式通过快速替换故障系统，确实有效地缩短了 MTTR，但不会影响 MTBF，因为它只是缩短了恢复时间\n总之 ア 和 エ 我是没明白，答案选 エ。可能故障隔离不是直接恢复被故障影响的功能或组件，而故障切换在缩短恢复时间方面更加直接有效吧\n24 $t_{1} \\sim t_{10}$ の時刻でスケジュールされたトランザクション $T_1 \\sim T_4$ がある。時刻 $t_{10}$ で $T_1$ が commit を発行する直前の、トランザクションの待ちグラフを作成した。a に当てはまるトランザクションはどれか。ここで、select(X) は共有ロックを掛けて資源 X を参照することを表し、update(X) は専有ロックを掛けて資源 X を更新することを表す。これらのロックは、commit された時にアンロックされるものとする。また、トランザクションの待ちグラフの矢印は、$T_i \\rightarrow T_j$ としたとき、$T_j$ がロックしている資源のアンロックを、$T_i$ を待つことを表す。\n（トランザクションのスケジュール$t_1$）\n時刻 $T_1$ $T_2$ $T_3$ $T_4$ $t_1$ select(A) $t_2$ select(B) $t_3$ select(B) $t_4$ select(A) $t_5$ update(B) $t_6$ select(C) $t_7$ select(C) $t_8$ update(C) $t_9$ update(A) $t_{10}$ commit （トランザクションの待ちグラフ）\nア　$T_1$\nイ　$T_2$\nウ　$T_3$\nエ　$T_4$\n题目翻译：在时刻 $t_{1} \\sim t_{10}$ 之间，调度了事务 $T_1 \\sim T_4$ 。在时刻 $t_{10}$ 时，事务 $T_1$ 在 commit 前，构建了事务的等待图。请问在图中位置 a 所指的事务是哪一个？这里，select(X) 表示对资源加共享锁并读取，update(X) 表示对资源加排他锁并修改。所有的锁会在事务提交时解锁。并且在等待图中，箭头 $T_i \\rightarrow T_j$ 表示事务 $T_i$ 正在等待事务 $T_j$ 解锁其持有的资源\n关于数据库的并发控制 (X 锁和 S 锁) 可以参见: https://blog.yexca.net/archives/92 这里首先共享锁 (S 锁) 是可以被其他事务读取的，所以并不会发生阻塞，也就是一直到 $t_5$ 时刻 $T_4$ 的 update(B) 想对资源 B 加排他锁 (X 锁) ，但资源 B 此事被 $T_2$ 和 $T_3$ 加共享锁而阻塞，图中受到两个阻塞的有 b 和 c 。也就是 $T_4$ 可能是 b 或者 c\n然后 $t_8$ 时刻 $T_2$ 想对 C 加排他锁，此时资源 C 被 $T_1$ 和 $T_2$ 阻塞，所以 $T_1$ 阻塞 $T_2$ 。图中只有一个阻塞的是 a 。基本可以断定其就是 $T_2$\n最后 $t_9$ 想对 A 施加排他锁，此时 A 被 $T_1$ 和 $T_4$ 施加共享锁，所以被其阻塞，符合条件的有 b 和 c 。\n之后就是提交释放锁了，未被阻塞的只有 $T_1$ 所以是 d，根据上述分析可以知道 a 是 $T_2$ 、b 是 $T_4$ 、c 是 $T_3$ 。所以答案选 イ\n25 図は、既存の電話機とPBXを使用した企業内の内線網を、IPネットワークに統合する場合の接続構成を示している。図中の $a \\sim c$ に該当する装置の適切な組合せはどれか。\n- a b c ア PBX VoIPゲートウェイ ルータ イ PBX ルータ VoIPゲートウェイ ウ VoIPゲートウェイ PBX ルータ エ VoIPゲートウェイ ルータ PBX 题目翻译：图中展示了一个企业内部的内线网络在整合到 IP 网络时的连接构成。请问图中 $a \\sim c$ 所对应的设备正确组合是哪一项\n- a b c ア PBX VoIP 网关 路由器 イ PBX 路由器 VoIP 网关 ウ VoIP 网关 PBX 路由器 エ VoIP 网关 路由器 PBX 为了将传统电话系统整合进 IP 网络结构，需要一些设备：\nPBX (Private Branch Exchange，专用分支交换机)：这是传统电话系统的核心设备，负责管理和控制企业内部电话的交换与连接 VoIP 网关：充当传统电话系统与 IP 网络之间的桥梁，将模拟信号转换为 IP 数据包，以便在 IP 网络上传输 路由器：负责在 IP 网络上管理和转发数据包，确保数据包能够到达目的地 所以答案选 ア\n","date":"2024-11-08T18:29:54+08:00","permalink":"https://blog.yexca.net/archives/194/","title":"2022 SA am2 -21-25"},{"content":"引言 2022 SA am2\n01-08: http://127.0.0.1:4000/archives/191 09-15: http://127.0.0.1:4000/archives/192 16-20: http://127.0.0.1:4000/archives/193 21-25: http://127.0.0.1:4000/archives/194 渐渐不会起来了呢，不过还是可控的 (doge\n16 e シールの説明はどれか。\nア　インターネット上のゲーム内に限定されたキャラクターのイメージデータの作成者を証明する仕組みの一つである。\nイ　個人の意思表示をしている個人の本人確認が必要な電子文書データについて、その電子文書データの作成者の証明と改ざん防止のために、個人が行う電子署名である。\nウ　電子文書データの作成者の証明と改ざん防止のために、重要文書を扱う国や地方自治体などの公共機関だけに使用が許されている電子署名である。\nエ　法人が作成した電子文書データについて、その電子文書データの作成者が間違いなくその法人であり、かつその電子文書データは作成後に改ざんされていないことを証明するものである。\n题目翻译：e シール 的说明是哪一项\nア　这是在互联网上证明游戏角色形象数据的创建者的一种机制，限定于游戏内使用。\nイ　这是个人对电子文件数据进行的电子签名，用于证明该电子文件的创建者身份并防止篡改。\nウ　为了证明电子文档数据的创建者身份并防止篡改，仅限国家和地方政府等公共机构使用的电子签名。\nエ　针对法人创建的电子文件数据，证明该文件的创建者确实是该法人，并确保该文件在创建后未被篡改。\ne シール 通常用于法人或机构对电子文档的认证，确保文件的创建者是法人并且没有被篡改。因此正确答案为选项 エ\n17 マルチベクトル型 DDoS 攻撃に該当するものはどれか。\nア　攻撃対象のWebサーバ1台に対して、多数のPCから一斉にリクエストを送ってサーバのリソースを枯渇させる攻撃と、大量のDNS通信によってネットワークの帯域を消費する攻撃を同時に行う。\nイ　攻撃対象のWebサイトのログインパスワードを解読するために、ブルートフォースによるログイン試行を、多数のスマートフォン、IoT機器などから成るボットネットを踏み台にして一斉に行う。\nウ　攻撃対象のサーバに大量のレスポンスが同時に送り付けられるようにするために、多数のオープンリゾルバに対して、送信元IPアドレスを攻撃対象のサーバのIPアドレスに偽装した名前解決のリクエストを一斉に送信する。\nエ　攻撃対象の組織内の多数の端末をマルウェアに感染させ、当該マルウェアを遠隔操作することによってデータの改ざんやファイルの消去を一斉に行う。\n题目翻译：以下哪项属于多向量型 DDoS 攻击\nア　对目标的 1 台 Web 服务器，从大量 PC 同时发送请求使服务器资源枯竭，同时进行大量的 DNS 通信消耗网络带宽。\nイ　为了破解目标网站的登录密码，使用暴力破解登录尝试，同时利用大量智能手机和 IoT 设备构成的僵尸网络进行一齐攻击。\nウ　为了向目标服务器发送大量响应数据，通过多个开放的 DNS 解析器，将请求的发送源伪装成目标服务器 IP 地址，批量发送域名解析请求。\nエ　通过感染目标组织内部的大量终端设备，使这些设备感染恶意软件，通过远程操作进行数据篡改或文件删除的攻击。\n多向量型 DDoS 攻击通常会同时使用不同的攻击手法。选项 ア 使用了消耗服务器资源和消耗网络带宽的两种方式，因此是一个多向量攻击；而选项 ウ 仅使用 DNS 放大攻击 (Amplification Attack)，不属于多向量攻击。 イ 主要攻击目标是登录密码破解，而非多种资源的消耗或网络带宽的多重占用；エ 通过恶意软件感染的入侵攻击，不是 DDoS 类型的网络带宽或资源消耗攻击。所以答案为选项 ア\n18 暗号方式に関する記述のうち、適切なものはどれか。\nア　AESは公開鍵暗号方式、RSAは共通鍵暗号方式の一種である。\nイ　共通鍵暗号方式では、暗号化及び複合に同一の鍵を使用する。\nウ　公開鍵暗号方式を通信内容の秘匿に使用する場合は、暗号化に使用する鍵を秘密にして、複合に使用する鍵を公開する。\nエ　デジタル署名に公開鍵暗号方式が使用されることはなく、共通鍵暗号方式が使用される。\n题目翻译：关于加密方式的描述，以下哪项是正确的\nア　AES 是一种公钥加密方式，RSA 是一种对称密钥加密方式\nイ　在对称密钥加密方式中，加密和解密使用相同的密钥\nウ　在公钥加密方式用于通信内容保密时，加密所用的密钥应保密，解密所用的密钥应公开\nエ　数字签名不会使用公钥加密方式，而是使用对称密钥加密方式\n这题属于加密了，答案是选择 イ。AES 是对称加密算法，其他选项可以参考我不知道啥时候收藏的一篇文章： 一文详解 RSA 非对称加密算法 19 CRYPTREC の役割として、適切なものはどれか。\nア　外国為替及び外国貿易法で規制されている暗号装置の輸出許可申請を審査、承認する。\nイ　政府調達においてIT関連製品のセキュリティ機能の適切性を評価、認証する。\nウ　電子政府での利用を推奨する暗号技術の安全性を評価、監視する。\nエ　民間企業のサーバに対するセキュリティ攻撃を監視、検知する。\n题目翻译：关于 CRYPTREC 的作用，以下哪项描述是正确的\nア　根据《外汇及外国贸易法》审查和批准受限制的加密设备的出口许可申请\nイ　在政府采购中，对 IT 相关产品的安全功能进行适当性评价和认证\nウ　对电子政府中推荐使用的加密技术的安全性进行评估和监控\nエ　监控并检测针对私营企业服务器的安全攻击\nCRYPTREC (Cryptography Research and Evaluation Committees，密码技术研究和评估委员会) 是日本一个专注于密码技术的政府项目。其主要职责包括对密码算法的研究、评估、推荐和监视，以确保这些算法的安全性和可靠性，特别是在政府和公共部门的应用中。其核心功能有推荐加密技术、监控和评估安全性和支持政策制定。其主要目标是确保密码技术在公共领域的安全应用，防止信息泄漏和数据篡改等安全事件的发生。所以答案选 ウ\n20 インターネットとの接続において、ファイアウォールのNAPT機能によるセキュリティ上の効果はどれか。\nア　DMZ上にある公開Webサイトの脆弱性を悪用する攻撃を防御できる。\nイ　インターネットから内部ネットワークへの侵入を検知し、検知後の通信を遮断できる。\nウ　インターネット上の特定のWebサービスを利用するHTTP通信を検知し、遮断できる。\nエ　内部ネットワークからインターネットにアクセスする利用者PCについて、インターネットからの不正アクセスを困難にすることができる。\n题目翻译：在连接到互联网时，使用防火墙的 NAPT 功能的安全效果是什么\nア　能够防御利用位于 DMZ 上的公开网站漏洞的攻击\nイ　能够检测从互联网到内部网络的入侵，并在检测到后阻断通信\nウ　能够检测并阻止利用特定 Web 服务的 HTTP 通信\nエ　可以使从内部网络访问互联网的用户 PC 更难受到来自互联网的不正当访问\nNAPT (Network Address Port Translation，网络地址端口转换) 是一种动态地将内部 IP 地址和端口映射到外部 IP 地址和端口的技术。其主要作用是在共享一个公网 IP 地址时隐藏内部网络的 IP 地址，防止外部设备直接访问内部网络设备，从而提升安全性。所以答案选 エ\n","date":"2024-11-06T22:05:18+08:00","permalink":"https://blog.yexca.net/archives/193/","title":"2022 SA am2 -16-20"},{"content":"引言 2022 SA am2\n01-08: http://127.0.0.1:4000/archives/191 09-15: http://127.0.0.1:4000/archives/192 16-20: http://127.0.0.1:4000/archives/193 21-25: http://127.0.0.1:4000/archives/194 从中间的题目开始，难度开始上来了，几乎都是没有学过的了，可以收回之前说的我觉得可以过的言论了，不过要是真不学什么东西直接过道还不如不去考呢，就算考不过，但学到的知识可以影响自己 (怎么又有要开始的迹象了)\n碎碎念 因为写的太多了，不用引言了，改成碎碎念得了 (本来是放前面的，但觉得还是文章相关放前面比较好，所以衔接可能有点怪)\n最近每个文章是不是都得来个感悟啊 doge (不知道人的脑洞是有极限的嘛)\n事实上这些感悟或者思考的出现是从去年，我的眼睛开始非常的疼痛，然后我经常就只是躺在床上听音乐 (不仅是屏幕，就算是看自然的景色也会疼痛)，就是在躺着的时间里我可能是梦也可能是胡思乱想 (我已经不知道躺着时候我是在梦境还是现实了，眼睛疼痛，同时有时候身体还会难受) 使我想到了可以说对我影响比较深的两个理论，我将其命名为「状态行为理论」与「圈理论」，从我将它们大体想出来后，我常常在梦或者对某件事情进行思考的时候想到这两个理论，对其进行细节的修正，然后再度思考，当然还有一些其他的思考啦，就像最近文章出现的那样。本来那时候想着把两个理论写出来的，但一拖再拖，那股劲没了就会觉得有点害羞去发表，因为并没有经过任何的查重验证之类的发布一个自以为是的理论什么的，还是有点不大好。当然还有着我平常觉得 blog 只是讨论技术吧，但现在倒是想开了，学技术第一想法是去寻找相关课程，我写的东西也没啥人看，想怎么造就怎么造。(莫名想到 warma 介绍爆炸电台的样子)\n写到这我去找了下 warma 视频，简略看了下并没有找到，可能在消失的第二期吧。但第九期开头有提到“大家有没有这种感觉，就是当你去做一件事情，然后你写好了一个精妙的计划，这个计划非常完美，但是你实行起来之后，从第一步开始，就不想照着计划走了，就感觉我凭什么要照着计划来”。这让我想到了之前我的矛盾，在人生没有计划或者被安排时候觉得没有目标，不知如何行动之类的；但是有计划或者按照安排来又会觉得自己的人生不自由。然后就导致着自己在这种制作计划、推翻计划、再次制作、再次推翻的循环中，最终一事无成。事实上我倒是处于这个状态，想要什么但不会去接近它，害怕失去，一次小小的接近失败都有可能放弃去接近，当然，这在我昨天晚上想到的信任想法中有所体现，太长了不赘述。但是听到 warma 说出来我当时会瞬间有将此种状态打破的感觉 (这也与之前想法有所关联) ，特定的人说出的话总是会对人生有所影响，这使得我暂时性的拥有可能对部分事情的顾忌。\n不知不觉打了挺多字，虽然还有一些想说的，还是打住比较好吧。说到这突然就理解之前看到的博客可能会出一些自己的个人总结之类的了 (最近看的也就是 翠翠 的了)\n预览看了下怎么快比正文长了\n9 ソフトウェアのテスト工程において、バグ管理図を用いて、テストの進捗状況とソフトウェアの品質を判断したい。このときの考え方のうち、最も適切なものはどれか。\nア　テスト工程の前半で予想以上にバグが摘出され、スケジュールが遅れたので、スケジュールの見直しを行い、五日遅れでテストが終了すると判断した。\nイ　テスト項目がスケジュールどおりに消化され、かつ、バグ摘出の累積件数が増加しなければ、ソフトウェアの品質は高いと判断できる。\nウ　テスト項目消化の累積件数、バグ摘出の累積件数及び未解決バグの件数の全てが変化しなくなった場合は、解決困難なバグに直面しているかどうかを確認する必要がある。\nエ　バグ摘出の累積件数の推移とテスト項目の未消化件数の推移から、テスト終了の時期をほぼ正確に予測できる。\n题目翻译：在软件的测试阶段，想通过使用缺陷管理图来判断测试进度和软件质量。下列关于这种方法的描述中，最合适的是哪一个\nア　由于测试阶段的前半部分发现的缺陷超过预期，导致进度延迟，因此重新审视了进度计划，判断测试将延迟五天完成。\nイ　如果测试项目按计划完成，且缺陷的累计发现数量没有增加，可以认为软件质量较高。\nウ　当测试项目的累计完成数量、缺陷累计发现数量和未解决缺陷数量都不再变化时，有必要确认是否遇到难以解决的缺陷。\nエ　通过缺陷累计发现数量的变化趋势和测试项目未完成数量的变化趋势，可以较准确地预测测试结束时间。\n在测试进度和质量管理中，缺陷管理图用于可视化缺陷的累积趋势和测试的完成情况，通过分析这些趋势，开发团队可以更好地了解测试的进展和质量状况。这题 ア 与缺陷管理图无关，イ 本身错误。剩下的两个选项描述都是正确的，参考答案是 ウ。可能题目是想判断软件的进展与品质，这个选项比较符合吧 (我也不是很理解)\n10 故障の予防を目的とした解析手法であるFMEAの説明はどれか。\nア　個々のシステム構成要素に起こり得る潜在的な故障モードを特定し、それらの影響度を評価する。\nイ　故障を、発生した工程や箇所などで分類して分析し、改善すべき工程や箇所を特定する。\nウ　発生した故障について、故障の原因に関係するデータ、事象などを収集し、”なぜ”を繰り返して原因を掘り下げ、根本的な原因を追究する。\nエ　発生した故障について、その引き金となる原因を列挙し、それらの関係を木構造で表現する。\n题目翻译：以下哪项是为了预防故障而进行的 FMEA (故障模式及影响分析) 方法的说明\nア　识别系统各个组成要素中可能发生的潜在故障模式，并评估它们的影响程度。\nイ　对故障按照发生的工序或位置等进行分类分析，并确定需要改进的工序或位置。\nウ　针对发生的故障，收集与故障原因相关的数据和事件，并不断追问“为什么”，以深入探讨根本原因。\nエ　针对发生的故障，列举其诱发原因，并将这些关系以树状结构表示出来。\nFMEA (Failure Mode and Effects Analysis，故障模式及影响分析) 是一种系统化的方法，旨在识别系统或组件中的潜在故障模式、评估其影响，并采取措施预防潜在故障的发生。它主要应用于预防性维护和设计改进。因此答案是 ア\nイ 是故障分类分析方法；ウ 是 RCA (根本原因分析)；エ 是 FTA (故障树分析)\n11 JIS X 0160:2021 (ソフトウェアライフサイクルプロセス) によれば、廃棄プロセスのタスクのうち、アクティビティ“廃棄を確実化する”において実施すべきタスクはどれか。\nア　選定されたソフトウェアシステム要素を再利用、再生利用、再調整、分解修理、保管又は破壊する。\nイ　ソフトウェアシステムの廃棄戦略を定義する。\nウ　ソフトウェアシステム又は要素を不活化して取り除くための準備する。\nエ　廃棄後の、人の健康、安全性、セキュリティ及び環境への有害な状況が識別されて対処されていることを確認する。\n题目翻译：根据 JIS X 0160:2021 (软件生命周期过程) ，在废弃过程的任务中，应执行“确保废弃”的活动中的哪项任务\nア　对选定的软件系统元素进行再利用、回收、重新调整、拆解修复、保管或销毁。\nイ　定义软件系统的废弃策略。\nウ　为停用并移除软件系统或其组件做好准备。\nエ　确认废弃后不会对人类健康、安全、信息安全及环境造成有害影响。\nア 在描述的是具体的废弃操作方式，属于废弃过程的具体任务；イ 是制定废弃策略的过程，属于废弃活动的计划和策略制定阶段；ウ 是在废弃前的工作；エ 确保了不会产生负面影响，符合题意。因此答案是 エ\n12 JIS X 0160:2021 (ソフトウェアライフサイクルプロセス) によれば、ライフサイクルモデルの目的及び成果を達成するために、ライフサイクルプロセスを修正するか、又は新しいライフサイクルプロセスを定義することを何というか。\nア　シミュレーション\nイ　修整（Tailoring）\nウ　統治（Governance）\nエ　ベンチマーキング\n题目翻译：根据 JIS X 0160:2021 (软件生命周期过程) ，为了实现生命周期模型的目的和成果，对生命周期过程进行修改或定义新的生命周期过程的行为称为什么\nア　Simulation (模拟)\nイ　Tailoring (修整)\nウ　Governance (统治)\nエ　Benchmarking (检测)\nSimulation (模拟) 指通过模型来模拟系统的行为；Tailoring (修整) 指根据特定需求对现有的生命周期过程进行调整或定义新的过程，以适应项目的目标和成果；Governance (统治) 指对组织、项目的管理和监督；Benchmarking (检测) 指对比最佳实践或行业标准，以改进性能。因此答案是 イ\n13 IT 投資に対する評価指標の設定に際し、バランススコアカードの手法を用いてKPIを設定する場合に、内部ビジネスプロセスの視点に立ったKPIの例はどれか。\nア　ITリテラシ向上のための研修会の受講率を100％とする。\nイ　売上高営業利益率を前年同期比5％アップとする。\nウ　顧客クレーム件数を1か月当たり20件以内とする。\nエ　注文受付から製品出荷までの日数を3日短縮とする。\n题目翻译：在设定 IT 投资的评价指标时，如果使用平衡计分卡的方法设定 KPI，那么从内部业务流程的视角来看，以下哪项是 KPI 的示例\nア　将 IT 素养提高的培训出席率设为100%\nイ　将营业利润率比去年同期提高 5%\nウ　将客户投诉数量控制在每月 20 件以内\nエ　将从订单接受到产品出货的天数缩短 3 天\n平衡计分卡 (Balanced Scorecard，简称BSC) 是一种战略管理和绩效衡量工具，用于帮助组织从多维度评价和提升其整体绩效。它通过将传统的财务指标与非财务指标相结合，提供了一种平衡的管理方式，使企业能够从更全面的角度来设定和评估战略目标，确保长期战略与日常运营的有机结合。主要从四个方面设定：\n财务视角：关注财务表现和目标，比如收入增长、成本控制、利润率等。传统财务指标如 ROI (投资回报率) 也属于这一视角 客户视角：关注客户的满意度和市场份额，指标可能包括客户满意度、投诉数量、客户保持率等，用以衡量客户的体验和忠诚度 内部业务流程视角：关注组织内部的运营流程效率，指标可能包括生产周期、订单处理时间、质量控制等，这个视角旨在优化企业内部的关键流程和效率 学习与成长视角：关注员工发展和组织创新，指标可能包括培训参加率、员工技能提升、员工满意度等，确保企业拥有持久发展的动力和创新能力 因此答案是 エ\n14 組込みシステム開発において、製品に搭載するLSIを新規に開発する。LSI設計を自社で行い、LSI製造を外部に委託する場合の委託先として、適切なものはどれか。\nア　IPプロバイダ\nイ　デザインハウス\nウ　ファウンドリ\nエ　ファブレスメータ\n题目翻译：在嵌入式系统开发中，计划新开发搭载在产品上的 LSI (大规模集成电路) 。若 LSI 的设计由本公司负责，而 LSI 的制造外包，作为外包方适当的是哪个\nア　IP Provider\nイ　Design House\nウ　Foundry\nエ　Fabless Manufacturer\nIP Provider 指提供 LSI 设计中所需的知识产权 (IP) 模块的公司，主要提供各种半导体设计所用的预制IP模块，但不负责实际的芯片生产制造；Design House 指帮助其他公司完成 LSI 设计的公司；Foundry 指专门负责生产 LSI 等半导体芯片的公司，为没有生产能力的公司提供制造服务；Fabless Manufacturer 指无工厂的半导体公司，通常负责芯片设计，而把生产外包给 Foundry 公司进行。因此答案选 ウ\n15 ラボ契約の特徴はどれか。\nア　依頼元がベンダ企業側の作業担当者を指名して直接指揮命令を行う契約であり、ベンダ企業はこれを前提に要員を割り当てる。\nイ　依頼元は、契約に基づきスキルや人数などの準備を満たすように要員を確保することをベンダ企業に求めるかわりに一定以上の発注を約束する。\nウ　開発したシステムによって依頼元が将来獲得する売上や利益をベンダ企業にも分配することを条件に、開発時のベンダ企業への発注金額を抑える。\nエ　ベンダ企業が契約で定めた最低発注工数を下回って作業を完了した場合には、実稼働工数に基づいて請求することが求められる。\n题目翻译：实验室合同的特点是什么\nア　委托方指名供应商企业的工作人员并直接指挥命令的合同，供应商企业根据此要求分配人员。\nイ　委托方根据合同要求供应商企业确保符合技能、人数等准备条件，委托方则承诺至少达到一定数量的订单。\nウ　以将来由所开发的系统获得的销售额或利润分配给供应商企业为条件，从而压低开发时对供应商企业的发包金额。\nエ　如果供应商企业完成的实际工作工时低于合同中规定的最低发包工时，则要求根据实际工作工时进行结算。\nLab Contract 指的是一种常见于 IT 行业的长期人力资源外包形式。在该合同下，供应商根据委托方的需求 (例如技能或人数) ，分配专门的人员团队并派驻在委托方处，委托方直接指挥这些人员。此类合同通常不针对具体项目，而是将供应商的人员资源作为长期外包资源。因此答案选 イ。另外 ウ 是收益共享型合同\n","date":"2024-11-04T23:29:15+08:00","permalink":"https://blog.yexca.net/archives/192/","title":"2022 SA am2 -09-15"},{"content":"引言 2022 SA am2\n01-08: http://127.0.0.1:4000/archives/191 09-15: http://127.0.0.1:4000/archives/192 16-20: http://127.0.0.1:4000/archives/193 21-25: http://127.0.0.1:4000/archives/194 这专门试卷难度倒是还行，不过还是会有我学过的东西，相必经过一定的学习后我应该可以通过客观题，希望早点做完后看看下午题，这才是我合格的关键\n说到这里，我觉得共通一我的做法很有问题，完全看不懂的情况进行做题完全没有意义，还是慢慢一题一题做比较好，之前我做完后在写文章解析的时候倒是想着快点完成，从而使得那一张试卷几乎相当于白做，毕竟只是刚开始一题一题做也没关系\n碎碎念 最近突然觉得学习仿佛是一种连接，灵感来源于语言的学习就是一种将事物与语言的连接，而学习的东西是一种抽象的连接，针对于某种输入，产生某种输出，通过不断地重复加深这种链接。比较直观的就是知识点的关联，从某一点推出另一点，仿佛就是两个知识之间的连接，以见过或者自己推出这个连接后将这种连接加深，这就类似事物与语言词汇的连接，从而让人掌握了这个事物，或者说这种连接后，也就掌握了此知识。(当然只是随便一想而已，无相应证明。事实上我听到的多数观点或论据也可能是基于不大严谨的证明，自己的一段经历推出的。人基于自己的经历来形成自己的观点，没有见过的事物是无法想象的。不过有一个例外，可能就是梦吧，梦确实可能是自己到了某个世界游历，当然并不严谨，这还是最近我看到一个小说是进入某世界随机出现在那个世界的某处，然后经历一番后如有完成特殊条件可以保留那个世界的部分记忆有所收获，对于自己做的梦倒也是如此从而让我有了这个推断。但事后仔细回想后，倒是可能因为睡着后大脑可以专注于想象，此时想象力达到顶峰，从而完成自己醒着时候无法想象到的。比如 DNA 双螺旋结构的发现人也是从梦中得到的灵感)\n1 アジャイル開発の初期段階において、プロジェクトの目的、スコープなどに対する共通認識を得るために、あらかじめ設定されている設問と課題について関係者が集まって確認し合い、その成果を共有する手法はどれか。\nア　アジャイルモデリング\nイ　インセプションデッキ\nウ　プランニングポーカ\nエ　ユーザストーリマッピング\n题目翻译：在敏捷开发的初期阶段，为了在项目的目的、范围等方面达成共识，相关人员会聚集在一起确认预先设定的问题和课题，并共享成果。这种方法是哪一种\nア agile modeling\nイ Inception Deck\nウ planning poker\nエ user story mapping\nInception Deck 是一种重要的方法，尤其在项目的初始阶段使用，以确保团队对项目的目的和范围形成共识。团队会事先确定并探讨一些关键性的问题 (如项目的目标、潜在风险、成功标准等)，这能够帮助所有团队成员对项目的整体方向和边界有清晰的理解并达成一致。因此，正确答案是 イ\n2 ソフトウェアパターンのうち、GoFのデザインパターンの説明はどれか。\nア　Javaのパターンとして、引数オブジェクト、オブジェクトの可変性などで構成される。\nイ　オブジェクト指向開発のためのパターンであって、生成、構造、振る舞いの三つのカテゴリに分類される。\nウ　構造、分散システム、対話型システム及び適合型システムの四つのカテゴリに分類される。\nエ　抽象度が異なる要素を分割して階層化するためのLayers、コンポーネント分割のためのBrokerなどで構成される。\n题目翻译：在软件模式中，GoF (Gang of Four) 设计模式的描述是哪一个\nア Java 模式，由参数对象和对象的可变性等构成。\nイ 面向对象开发的模式，分为创建、结构和行为三类。\nウ 分为结构、分布式系统、交互式系统及适应性系统四类。\nエ 为了将不同抽象层次的元素分离并层次化，包含 Layers、Broker 等。\nGoF 的设计模式是由四位软件工程师提出的经典设计模式，专门用于面向对象编程。它将设计模式分为三大类：生成 (创建) 、结构、行为，用于解决常见的面向对象设计问题。因此，正确答案是 イ\n我去搜了下 相关介绍 ，貌似就是 我之前写的设计模式 的由来吧\n3 Pattern-Oriented Software Architecture (POSA) のアーキテクチャパターンのうち、ソフトウェアをメタレベルとベースレベルの二つのレベルに分割し、ソフトウェアの構造と振る舞いとを動的に変更できる仕組みを提供しているものはどれか。\nア　Broker\nイ　Microkernel\nウ　Model-View-Controller\nエ　Reflection\n题目翻译：在面向模式的软件架构 (POSA) 中的架构模式中，将软件分为元层和基础层两个层级，并提供一种能够动态改变软件结构和行为的机制的是哪一种\nア　代理\nイ　微内核\nウ　模型-视图-控制器\nエ　反射\nBroker 模式是一种分布式系统架构模式，旨在将系统的不同组件（如客户端和服务器）解耦合，通过 Broker 进行通信。Broker 充当中介的角色，负责传递消息并管理远程服务的调用。\nMicrokernel 模式通常用于操作系统设计，将核心功能 (如内存管理、进程管理) 保留在微内核中，而将其他可选功能作为独立模块来实现，能够动态加载或卸载。\nModel-View-Controller (MVC) 模式是一种常见的交互式系统架构模式，用于分离应用程序的业务逻辑 (Model) 、用户界面 (View) 和用户输入控制 (Controller) 。MVC 主要目的是解耦显示逻辑和业务逻辑，并没有提供动态改变软件结构和行为的机制。\nReflection 模式是一种将软件分为“元层”和“基础层”两层的架构模式，元层包含描述系统结构和行为的元数据，而基础层负责执行实际的业务逻辑。通过反射模式，软件可以动态修改其结构和行为，以适应不同的需求和场景。这种模式常用于需要高扩展性和灵活性的系统。因此，正确答案是 エ\n4 組込みシステムでDBMSを用いるときには、通信のオーバヘッド、通信負荷の発生を防ぐこと、必要なメモリ容量をリソース制限内に抑えることなどを目的として、インプロセスデータベースを用いることがある。このインプロセスデータベースの説明として、適切なものはどれか。\nア　クライアントサーバ形式のクライアントとなるアプリケーションプログラムとソケットを介して通信し、SQLを用いて処理を記述する。\nイ　データベースエンジンはライブラリ形式で提供され、アプリケーションプログラムとリンクされて同一メモリ空間で動作する。\nウ　データベースの全体をメモリ上に配置して、データベース処理を高速化する。\nエ　一つのテーブルを一つのファイルで管理し、アプリケーションプログラムからはファイル入出力のAPIで操作する。\n题目翻译：在嵌入式系统中使用DBMS时，常常为了防止通信开销、通信负荷的产生，并将必要的内存容量控制在资源限制范围内，使用进程内数据库。关于这种进程内数据库的描述，正确的是哪一个\nア 通过套接字与作为客户端的应用程序进行通信，并使用 SQL 进行处理。\nイ 数据库引擎以库的形式提供，与应用程序链接，在同一内存空间中运行。\nウ 将整个数据库加载到内存中，以加快数据库处理速度。\nエ 将一个表管理为一个文件，并通过文件 I/O API 从应用程序进行操作。\n进程内数据库 (インプロセスデータベース) 是指数据库引擎作为库文件与应用程序链接，共享同一内存空间。这种设计避免了客户端-服务器模式带来的通信开销和负载，适合资源受限的嵌入式系统。\nア 选项描述了客户端-服务器架构的数据库，通常通过网络套接字通信；ウ 选项描述了“内存数据库”，即将数据库全部加载至内存以提高性能；エ 选项描述了一种基于文件的数据库管理方法，通常用于文件数据库。因此，正确答案是 イ\n5 デザインパターンのなかのストラテジパターンを用いて、帳票出力のクラス図のとおりに設計した。適切な説明はどれか。\nア　クライアントは、使用したいフォーマットに対応する、帳票出力ストラテジクラスのサブクラスを意識せずに利用できる。\nイ　新規フォーマット用のアルゴリズムの追加が容易である。\nウ　帳票出力ストラテジクラスの中で、どのフォーマットで帳票を出力するかの振り分けを行っている。\nエ　帳票出力のアルゴリズムは、コンテキストクラスの中に記述する。\n题目翻译：使用策略模式设计了账单输出的类图。下列哪项描述是正确的\nア 客户端可以在不关注具体策略子类的情况下使用相应的账单输出格式。\nイ 可以轻松添加用于新格式的算法。\nウ 账单输出策略类负责选择使用哪种格式输出账单。\nエ 账单输出的算法应写在上下文类中。\n题目是使用策略模式实现了一个多格式账单的分发。策略模式的设计原则是将算法的实现和使用分离，使得可以在不修改客户端代码的情况下切换或增加不同的算法。同时我写过策略模式的文章来着: https://blog.yexca.net/archives/137 策略模式的设计使得新算法的增加非常方便，只需实现新的具体策略类并与现有结构集成即可。因此，正确答案是 イ\n6 モジュール間のデータの受渡し方法のうち、最も低いモジュール結合度となるものはどれか。\nア　単一のデータ項目を大域的データで受け渡す。\nイ　単一のデータ項目を引数で受け渡す。\nウ　データ構造を大域的データで受け渡す。\nエ　データ構造を引数で受け渡す。\n题目翻译：以下关于模块之间的数据传递方法，哪一种方式的模块耦合度最低\nア 使用全局数据传递单个数据项。\nイ 使用参数传递单个数据项。\nウ 使用全局数据传递数据结构。\nエ 使用参数传递数据结构。\n这题就是讲程序的耦合度的，我也写过一个文章来着: https://blog.yexca.net/archives/145#%E8%80%A6%E5%90%88 传递单个数据值为数据耦合，传递数据结构为标记耦合，全局参数应该属于公共耦合，其中数据耦合的耦合度最低。因此，正确答案是 イ\n7 既存システムを基に、新システムのモデル化を行う場合のDFD作成の手順として、適切なものはどれか。\nア　現物理モデル -\u0026gt; 現論理モデル -\u0026gt; 新物理モデル -\u0026gt; 新論理モデル\nイ　現物理モデル -\u0026gt; 現論理モデル -\u0026gt; 新論理モデル -\u0026gt; 新物理モデル\nウ　現論理モデル -\u0026gt; 現物理モデル -\u0026gt; 新物理モデル -\u0026gt; 新論理モデル\nエ　現論理モデル -\u0026gt; 現物理モデル -\u0026gt; 新論理モデル -\u0026gt; 新物理モデル\n题目翻译：基于现有系统进行新系统建模时，创建数据流图（DFD）的步骤顺序应如何\nア 现物理模型 -\u0026gt; 现逻辑模型 -\u0026gt; 新物理模型 -\u0026gt; 新逻辑模型\nイ 现物理模型 -\u0026gt; 现逻辑模型 -\u0026gt; 新逻辑模型 -\u0026gt; 新物理模型\nウ 现逻辑模型 -\u0026gt; 现物理模型 -\u0026gt; 新物理模型 -\u0026gt; 新逻辑模型\nエ 现逻辑模型 -\u0026gt; 现物理模型 -\u0026gt; 新逻辑模型 -\u0026gt; 新物理模型\n这题盲猜选 イ。一般创造数据流图需要从现有系统的具体实现抽象出业务需求，然后再基于现有业务需求改进出逻辑模型，最后实现新的逻辑需求\n8 ある購買システムの開発において、開発者が行った探索的テストの例として、適切なものはどれか。\nア　過去に購買システムを開発した経験に基づいて、入力項目間の関連チェックの不備を検出できそうなデータパターンを推測し、テストケースを事前に作成してテストした。\nイ　数量の範囲に応じて適用する商品価格が正しいかどうかを確認するために、各範囲の数量の中央の値を用いたテストケースを作成してテストした。\nウ　組織変更の前後で組織名が正しく印刷されるかどうかを確認するために、新組織の有効開始日とその前日とを発注日とするテストケースを事前に作成してテストした。\nエ　入力値の組合せが無効なときは伝票を作成しないことを確認するために、幾つかの代表的な入力値の組合せをテストし、その結果に基づいて次のテストケースを作成してテストしを繰り返した。\n题目翻译：在一个采购系统的开发中，作为开发者进行的探索性测试的合适例子是哪一个\nア 根据过去开发采购系统的经验，推测出可能检测到输入项之间关系不完善的测试数据模式，预先创建测试用例并进行了测试。\nイ 为了确认根据数量范围应用的商品价格是否正确，使用每个范围中间值的测试用例并进行了测试。\nウ 为了确认组织变更前后的组织名称是否正确打印，预先创建了使用新组织有效开始日和前一日作为下单日的测试用例并进行了测试。\nエ 为了确认当输入值组合无效时不生成单据，测试了几个具有代表性的输入值组合，并根据结果反复创建新的测试用例进行测试。\n探索性测试是一种在测试过程中动态设计和执行测试的方式，不依赖事先确定的测试用例，而是基于对系统的理解和观察结果实时调整测试方案。探索性测试的特点在于测试用例并非完全预设，而是根据测试结果不断调整和补充。\nア、イ、ウ 选项中测试用例都是事先创建好的，符合传统的事前设计测试，不符合探索性测试的特点。所以正确答案是 エ\n","date":"2024-11-03T23:11:52+08:00","permalink":"https://blog.yexca.net/archives/191/","title":"2022 SA am2 -01-08"},{"content":"引言 2022 SA am1\n01-02: https://blog.yexca.net/archives/184 03-05: https://blog.yexca.net/archives/185 06-10: https://blog.yexca.net/archives/186 11-15: https://blog.yexca.net/archives/189 16-30: https://blog.yexca.net/archives/190 整张试卷做下来大部分是软件设计师的感觉，估计有些共通的科目对软件开发要求较低吧，专门的试卷估计会难一点。大部分题目专有名词看不懂，但是翻译过来后是可以会做的，专有名词的记忆很重要嘛\n第 16 问 次の流れ図において、判定条件網羅（分岐網羅）を満たす最小のテストケースの組みはどれか。\nア　(1) A=0, B=0 (2) A=1, B=1\nイ　(1) A=1, B=0 (2) A=1, B=1\nウ　(1) A=0, B=0 (2) A=1, B=1 (3) A=1, B=0\nエ　(1) A=0, B=0 (2) A=0, B=1 (3) A=1, B=0\n这题是最少需要多少个测试用例才能把每个分支都测试到，就不解析了，答案是选项 イ\n第 17 问 問題が発生していないが、プログラムの仕様書と現状のソースコードとの不整合を解消するために、リバースエンジニアリングの手法を使って仕様書を作成し直す。これはソフトウェア保守のどの分類に該当するか。\nア　完全化保守\nイ　是正保守\nウ　適応保守\nエ　予防保守\n题目翻译：问题尚未发生，但为了消除程序的规格说明书和当前源代码之间的不一致，使用逆向工程的方法重新编写规格说明书。这属于软件维护的哪种分类\nア　完善性维护\nイ　纠正性维护\nウ　适应性维护\nエ　预防性维护\n死去的记忆开始攻击我，学过但忘完了。完善性维护指改进软件功能、性能、或其他质量属性以符合新的标准或要求，即在原本功能基础上进行增强和完善；纠正性维护指修复软件中的缺陷，纠正软件异常或错误；适应性维护指使软件适应运行环境的变化，比如兼容新的操作系统或硬件；预防性维护指在未发生问题的情况下，进行维护以预防潜在问题的产生。所以答案为选项 エ\n第 18 问 ある組織では、プロジェクトのスケジュールとコストの管理にアーンドバリューマネジメントを用いている。期間10日間のプロジェクトの、5日目の終了時点の状況は表のとおりである。この時点でのコスト効率が今後も続くとしたとき、完成時総コスト見積り（EAC）は何万円か。\n管理項目 金額（万円） 完成時総予算（BAC） 100 プランドバリュー（PV） 50 アーンドバリュー（EV） 40 実コスト（AC） 60 ア　110\nイ　120\nウ　135\nエ　150\n题目翻译：某组织使用挣值管理 (earned value management) 来管理项目的进度和成本。在一个为期 10 天的项目中，5 天结束时的情况如下表所示。如果此时的成本效率在今后继续保持，那么完成时的总成本估算 (EAC) 是多少万日元\n管理项目 金额 (万日元) 完成时总预算 (BAC) 100 计划价值 (PV) 50 挣值 (EV) 40 实际成本 (AC) 60 这题是没学过的东西呢。完成时的总成本估算 (EAC) 计算方法为\n$$ EAC=\\frac{BAC}{CPI} $$\n其中 CPI (成本绩效指数) 为\n$$ CPI=\\frac{EV}{AC} $$\n带入数值计算\n$$ \\begin{align} CPI\u0026amp;=\\frac{40}{60}=\\frac{2}{3} \\ EAC\u0026amp;=\\frac{100}{\\frac{2}{3}}=150 \\end{align} $$\n所以答案为选项 エ\n第 19 问 ソフトウェア開発プロジェクトにおいて、表の全ての作業を完了させるために必要な期間は最短で何日間か。\n作業 作業の開始条件 所要日数（日） 要件定義 なし 30 設計 要件定義の完了 20 製造 設計の完了 25 テスト 製造の完了 15 利用者マニュアル作成 設計の完了 20 利用者教育 テストの完了及び利用者マニュアル作成の完了 10 ア　80\nイ　95\nウ　100\nエ　120\n题目翻译：在软件开发项目中，为完成表中所有工作所需的最短时间是多少天\n工作 前提条件 所需天数 需求定义 无 30 设计 需求定义完成 20 制造 设计完成 25 测试 制造完成 15 用户手册编写 设计完成 20 用户培训 测试和用户手册编写完成 10 这题画出那个图就行了，挺简单的一个图。答案为选项 ウ\n第 20 问 ITIL 2011 edition では、可用性管理における重要業績評価指標（KPI）の例として、”保守性を表す指標値”の短縮を挙げている。保守性を表す指標に該当するものはどれか。\nア　一定時間内での中断の数\nイ　平均故障間隔\nウ　平均サービス・インシデント間隔\nエ　平均サービス回復時間\n题目翻译：在 ITIL 2011 版中，可用性管理的关键绩效指标 (KPI) 中包括了“表示维护性的指标值”的缩写。下列选项中，属于表示维护性的指标是哪个\nア：一定时间内的中断次数\nイ：平均故障间隔\nウ：平均服务事件间隔\nエ：平均服务恢复时间\n在 ITIL 可用性管理中，维护性通常表示系统在发生故障后恢复或修复的能力，而非故障的频率或间隔。而平均服务恢复时间 (MTTR, Mean Time to Restore Service) 用于描述故障后的恢复速度，表示一旦发生故障，系统平均需要花多少时间恢复。所以答案为选项 エ\n第 21 问 基幹業務システムの構築及び運用において、データ管理者（DA）とデータベース管理者（DBA）を別々に任命した場合のDAの役割として、適切なものはどれか。\nア　業務データ量の増加傾向を把握し、ディスク装置の増設などの計画して実施する。\nイ　システム開発の設計工程では、主に論理データベース設計を行い、データ項目を管理して標準化する。\nウ　システム開発のテスト工程では、主にパフォーマンスチューニングを担当する。\nエ　システム障害が発生した場合には、データの復旧や整合性のチェックなどを行う。\n题目翻译：在构建和运营核心业务系统时，如果分别指派了数据管理者 (DA) 和数据库管理员 (DBA) ，那么 DA 的适当职责是什么\nア：掌握业务数据量的增长趋势，计划并实施增加磁盘设备等措施。\nイ：在系统开发的设计阶段，主要进行逻辑数据库设计，并管理和标准化数据项。\nウ：在系统开发的测试阶段，主要负责性能优化。\nエ：在系统故障发生时，进行数据恢复和一致性检查。\n数据管理者 (DA) 主要负责逻辑数据管理，包括制定数据标准、定义数据项以及逻辑数据库设计。DA 的职责是确保数据一致性和标准化，而数据库管理员(DBA) 则通常负责硬件资源管理、性能优化和数据恢复等任务。所以答案为选项 イ\n第 22 问 監査証拠の入手と評価に関する記述のうち、システム監査基準（平成30年）に照らして、適切でないものはどれか。\nア　アジャイル手法を用いたシステム開発プロジェクトにおいては、管理用ドキュメントとしての体裁が整っているものだけが監査証拠として利用できる。\nイ　外部委託業務実施拠点に対する監査において、システム監査人が委託先から入手した第三者の保証報告書に依拠できると判断すれば、現地調査を省略できる。\nウ　十分かつ適切な監査証拠を入手するための本調査の前に、監査対象の実態を把握するための予備調査を実施する。\nエ　一つの監査目的に対して、通常は、複数の監査手続きを組み合わせ監査を実施する。\n题目翻译：在获取和评估审计证据的描述中，根据《系统审计标准（平成30年）》的标准，以下哪一项不适当\nア：在使用敏捷方法进行系统开发项目时，只有格式完善的管理文档才能用作审计证据。\nイ：在对外包业务执行地点的审计中，如果系统审计员判断可以依赖从委托方获得的第三方保证报告，则可以省略现场调查。\nウ：为了获取充分且适当的审计证据，在主要调查之前，进行预备调查以了解审计对象的实际情况。\nエ：针对一个审计目的，通常结合多种审计程序来进行审计。\n这标准真不知道了，系统审计标准中并未规定敏捷项目的审计证据必须为格式完善的管理文档。实际上，在敏捷项目中，非正式文档（如会议记录、代码库、进度板等）也可以作为有效的审计证据，以反映项目的实际情况。所以答案为选项 ア\n第 23 问 BPOの説明はどれか。\nア　災害や事故で被害を受けても、重要事業を中断させない、又は可能な限り中断期間を短くする仕組みを構築すること\nイ　社内業務のうちコアビジネスでない事業に関わる業務の一部又は全部を、外部の専門的な企業に委託すること\nウ　製品の基準生産計画、部品表及び在庫情報を基に、資材の所要量と必要な時期を求め、これを基準に資材の手配、納入の管理を支援する生産管理手法のこと\nエ　プロジェクトを、戦略との適合性や費用対効果、リスクといった観点から評価を行い、情報化投資のバランスを管理し、最適化を図ること\n题目翻译：以下哪项是对 BPO 的解释\nア：即使在灾害或事故中受到损害，仍能确保重要业务不中断，或尽可能缩短中断时间的机制的构建\nイ：将公司内部业务中非核心业务的一部分或全部委托给外部专业公司处理\nウ：基于产品的基准生产计划、零件表和库存信息，确定材料的需求量和所需时间，并以此为基准支持材料的采购和交付管理的生产管理方法\nエ：从战略适配性、成本效益和风险等角度对项目进行评估，管理信息化投资的平衡并进行优化\nBPO (Business Process Outsourcing，业务流程外包) 是指将公司内部的非核心业务委托给外部专业公司处理，以集中资源在核心业务上。所以答案为选项 イ\nア 选项为业务连续性计划 (BCP, Business Continuity Plan)；ウ 选项中为所需量计划 (MRP, Material Requirements Planning)；エ 选项为项目组合管理 (PPM, Project Portfolio Management)\n第 24 问 IT投資効果の評価方法において、キャッシュフローベースで初年度の投資によるキャッシュアウトを何年後に回収できるかという指標はどれか。\nア　IRR(Internal Rate of Return)\nイ　NPV(Net Present Value)\nウ　PBP(Pay Back Period)\nエ　ROI(Return On Investment)\n题目翻译：在 IT 投资效果的评价方法中，基于现金流量来计算初始投资的现金流出在几年后可以回收的指标是哪一个\nア 是内部收益率法，表示项目投资的收益率，使得净现值为零的贴现率，是衡量项目收益水平的常用指标；イ 是净值算法，通过计算未来现金流的现值总和减去初始投资额，用以评估项目的整体价值；ウ 是回收期法，题目答案；エ 是投资回报率，通过投资收益与投资成本的比率，评估项目的盈利能力。所以选 ウ\n第 25 问 UMLの図のうち、業務要件定義において、業務フローを記述する際に使用する、処理の分岐や並行処理、処理の同期などを表現できる図はどれか。\nア　アクティビティ図\nイ　クラス図\nウ　状態マシン図\nエ　ユースケース図\n题目翻译：在UML的图表中，用于业务需求定义并描述业务流程，可以表达处理的分支、并行处理以及处理同步的图是哪一个\nア：活动图\nイ：类图\nウ：状态图\nエ：用例图\n活动图适用于描述业务流程，能够表示处理过程中的分支、并行处理和同步处理，因此通常用于业务需求的定义阶段；类图用于描述系统中的类及其属性、方法、类之间的关系等，它主要用于显示系统的静态结构；状态图用于描述对象在生命周期中的状态变化和状态间的转移，它适合表示对象的行为，尤其是在状态变化和事件响应方面；用例图用于描述系统的功能需求，以及系统如何与外部用户或其他系统进行交互，用例图通过表示不同的用例来定义系统的功能。所以选 ア\n第 26 问 PPMにおいて、投資用の資金源として位置付けられる事業はどれか。\nア　市場成長率が高く、相対的市場占有率が高い事業\nイ　市場成長率が高く、相対的市場占有率が低い事業\nウ　市場成長率が低く、相対的市場占有率が高い事業\nエ　市場成長率が低く、相対的市場占有率が低い事業\n题目翻译：在 PPM (产品组合管理) 中，作为投资资金来源的业务是哪一种\nア 市场增长率高、相对市场占有率高的业务\nイ 市场增长率高、相对市场占有率低的业务\nウ 市场增长率低、相对市场占有率高的业务\nエ 市场增长率低、相对市场占有率低的业务\nPPM 中，这类业务被称为 \u0026ldquo;金牛型 (Cash Cow)\u0026quot;。由于其市场占有率高，可以带来稳定的现金流，同时其市场增长率较低，通常不需要额外投资，因此可以作为其他高增长业务的资金来源。正确答案是 ウ\n第 27 问 半導体産業において、ファブレス企業と比較したファウンドリ企業のビジネスモデルの特徴として、適切なものはどれか。\nア　工場での生産をアウトソーシングして、生産設備への投資を抑える。\nイ　自社製品の設計、マーケティングに注力し、新市場を開拓する。\nウ　自社製品の販売に注力し、売上げを拡大する。\nエ　複数の企業から生産だけを専門に請け負い、多くの製品を低コストで生産する。\n题目翻译： 在半导体产业中，与无工厂企业相比，代工企业的商业模式特点是什么\nア 将工厂的生产外包，以减少在生产设备上的投资。\nイ 专注于自家产品的设计和营销，开拓新市场。\nウ 专注于自家产品的销售，扩大销售额。\nエ 专门承接多家企业的生产业务，以低成本生产大量产品。\n在半导体产业中，代工企业主要负责制造，并不设计自己的产品，而是专门为其他企业提供生产服务。这种模式使其能够以较低的成本批量生产多种产品。正确答案是 エ\n第 28 问 XBRLで主要な取扱いの対象とされている情報はどれか。\nア　医療機関のカルテ情報\nイ　企業の顧客情報\nウ　企業の財務情報\nエ　自治体の住民情報\n题目翻译：在 XBRL (eXtensible Business Reporting Language) 中，主要处理的对象信息是哪一项\nア 医疗机构的病历信息\nイ 企业的客户信息\nウ 企业的财务信息\nエ 地方政府的居民信息\nXBRL是一种用于商业和财务报告的标准化语言，旨在处理和交换公司财务数据。正确答案是 ウ\n第 29 问 リーダシップ論のうち、PM理論の特徴はどれか。\nア　優れたリーダシップを発揮する、リーダ個人がもつ性格、知性、外観などの個人的資質の分析に焦点を当てている。\nイ　リーダシップのスタイルについて、目標達成能力と集団維持能力の二つの次元に焦点を当てている。\nウ　リーダシップの有効性は、部下の成熟（自律性）の度合いという状況要因に依存するとしている。\nエ　リーダシップの有効性は、リーダがもつバーソナリティと、リーダがどれだけ統制力や影響力を行使できるかという状況要因に依存するとしている。\n题目翻译：在领导理论中，PM 理论的特点是哪一个\nア 聚焦于分析展现优秀领导力的领导者个人的特质，例如性格、智力、外表等个人资质。\nイ 关于领导风格，聚焦于目标达成能力和团队维持能力两个维度。\nウ 认为领导的有效性依赖于部下成熟度（自主性）的程度这一情境因素。\nエ 认为领导的有效性取决于领导者的个性，以及其行使控制力和影响力的程度这一情境因素。\nPM 理论 (Performance-Maintenance Theory) 认为，领导风格由“P (目标达成)”和“M(团队维持)”两个维度组成。因此，PM 理论的特点是关注领导者在任务达成和团队维持方面的能力。正确答案是 イ\n第 30 问 A社は、B社と著作物の権利に関する特段の取決めをせず、A社の要求仕様に基づいて、販売管理システムのプログラム作成をB社に委託した。この場合のプログラム著作権の原始的帰属に関する記述のうち、適切なものはどれか。\nア　A社とB社が話し合って帰属先を決定する。\nイ　A社とB社の共有帰属となる。\nウ　A社に帰属する。\nエ　B社に帰属する。\n题目翻译：A 公司在没有与B公司就著作权做出特别约定的情况下，基于 A 公司的需求规格将销售管理系统的程序编写委托给了 B 公司。在这种情况下，关于程序著作权原始归属的描述中，哪一项是正确的\nア A公司和B公司通过协商决定归属\nイ 归属于A公司和B公司共同拥有\nウ 归属于A公司\nエ 归属于B公司\n在没有特别约定的情况下，按照日本著作权法，委托合同中产生的作品的著作权通常归属于实际创作者，即 B 公司。只有在合同中明确规定著作权归委托方 (A公司) 时，著作权才会归属给 A 公司 (好像和中国一样)。因此正确答案是 エ\n","date":"2024-10-28T19:04:14+08:00","permalink":"https://blog.yexca.net/archives/190/","title":"2022 SA am1 -16-30"},{"content":"引言 2022 SA am1\n01-02: https://blog.yexca.net/archives/184 03-05: https://blog.yexca.net/archives/185 06-10: https://blog.yexca.net/archives/186 11-15: https://blog.yexca.net/archives/189 16-30: https://blog.yexca.net/archives/190 碎碎念 最近眼睛越来越疼了，看屏幕可能一小时就开始了，而且看东西很模糊，感觉需要休息眼睛了，不然再近视看不见真的会很难受 (要是不疼的话我应该都能更新完这张试卷了)\n第 11 问 OpenFlow を使った SDN(Software-Defined Networking) に関する記述として、適切なものはどれか。\nア　インターネットのドメイン名を管理する世界規模の分散データベースを用いて、IPアドレスの代わりに名前を指定して通信できるようにする仕組む\nイ　携帯電話網において、回線交換方式ではなく、パケット交換方式で音声通話を実現する方式\nウ　ストレージ装置とサーバを接続し、WWN(World Wide Name) によってノードやポートを識別するストレージ用ネットワーク\nエ　データ転送機能とネットワーク制御機能を論理的に分離し、ネットワーク制御を集中的に行う可能にしたアーキテクチャ\n题目翻译：以下关于使用 OpenFlow 的 SDN(软件定义网络) 的描述，哪一项是正确的\nア：使用一个全球分布的数据库来管理互联网的域名，以便可以使用名称而非 IP 地址进行通信。\nイ：在移动通信网络中，不通过电路交换方式，而是通过分组交换方式实现语音通话的方式。\nウ：连接存储设备和服务器，并使用 WWN（全球唯一名称）识别节点和端口的存储网络。\nエ：将数据转发功能和网络控制功能逻辑上分离，使集中化网络控制成为可能的架构。\n选项 ア 是DNS 的描述；イ 是移动通信中 VoIP(基于分组交换的语音传输方式) 的描述；ウ 是对 SAN(存储区域网络) 的描述。所以答案为选项 エ\n第 12 问 メッセージの送受信における署名鍵の使用に関する記述のうち、適切なものはどれか。\nア　送信者が送信者の署名鍵を使ってメッセージに対する署名を作成し、メッセージに付加することによって、受信者が送信者による署名であることを確認できようになる。\nイ　送信者が送信者の署名鍵を使ってメッセージを暗号化することによって、受信者が受信者の署名鍵を使って、暗号文を元のメッセージに戻すことができるようになる。\nウ　送信者が送信者の署名鍵を使ってメッセージを暗号化することによって、メッセージの内容が関係者以外に分からないようになる。\nエ　送信者がメッセージに固定文字列を付加し、更に送信者の署名鍵を使って暗号化することによって、受信者がメッセージの改ざん部位を特定できるようになる。\n题目翻译：关于消息收发中的签名密钥的使用，以下哪项描述是正确的\nア：发送者使用发送者的签名密钥对消息进行签名并附加到消息上，这样接收者可以确认该签名是发送者生成的。\nイ：发送者使用发送者的签名密钥加密消息，这样接收者可以使用接收者的签名密钥将密文还原为原始消息。\nウ：发送者使用发送者的签名密钥加密消息，使消息内容对非相关方不可见。\nエ：发送者在消息上附加固定字符串，再使用发送者的签名密钥加密，这样接收者可以确定消息被篡改的部分。\n这里讨论签名一般是 RSA 算法。一般用其公钥解密，私钥是不会泄露的，所以选项 イ 错误；签名密钥不用作加密消息，因为公钥公开，任何人都是可以看到的，只用于验证属于发送者，所以选项 ウ 错误；密钥无法确定被篡改的部分，所以选项 エ 错误。答案为选项 ア\n第 13 问 クライアント証明書で利用者を確認するリバースプロキシサーバを用いて、複数のWebサーバにシングルサインオンを行うシステムがある。このシステムに関する記述のうち、適切なものはどれか。\nア　クライアント証明書を利用者のPCに送信するのは、Webサーバではなく、リバースプロキシサーバである。\nイ　クライアント証明書を利用者のPCに送信するのは、リバースプロキシサーバではなく、Webサーバである。\nウ　利用者IDなどの情報をWebサーバに送信するのは、リバースプロキシサーバではなく、利用者のPCである。\nエ　利用者IDなどの情報をWebサーバに送信するのは、利用者のPCではなく、リバースプロキシサーバである。\n题目翻译：使用反向代理服务器，通过客户端证书验证用户并实现对多个 Web 服务器的单点登录系统。关于该系统的描述，以下哪项是正确的\nア：将客户端证书发送到用户的 PC 的是反向代理服务器，而不是 Web 服务器。\nイ：将客户端证书发送到用户的 PC 的是 Web 服务器，而不是反向代理服务器。\nウ：将用户 ID 等信息发送到 Web 服务器的是用户的 PC，而不是反向代理服务器。\nエ：将用户 ID 等信息发送到 Web 服务器的是反向代理服务器，而不是用户的 PC。\n这题倒是挺贴近现实的，挺多大公司都会使用吧，就像微软的那个每次登录会单独到一个登录的请求。用户端的证书存储在用户端，反向代理服务器负责处理客户端证书的验证，前两个选项错误；在反向代理服务器验证完成后，像服务器发送用户信息，所以答案为选项 エ\n第 14 问 内部ネットワークのPCからインターネット上のWebサイトを参照するときに、DMZに設置したVDI (Virtual Desktop Infrastructure) サーバ上のWebブラウザを利用すると、未知のマルウェアがPCにダウンロードされるのを防ぐというセキュリティ上の効果が期待できる。この効果を生み出すVDIサーバの動作の特徴はどれか。\nア　Webサイトからの受信データを受信処理した後、IPsecでカプセル化し、PCに送信する。\nイ　Webサイトからの受信データを受信処理した後、実行ファイルを削除し、その他のデータをPCに送信する。\nウ　Webサイトからの受信データを受信処理した後、生成したデスクトップ画面の画像データだけをPCに送信する。\nエ　Webサイトからの受信データを受信処理した後、不正なコード列が検知されない場合だけPCに送信する。\n题目翻译：当内部网络的 PC 访问互联网上的网站时，通过使用位于 DMZ（隔离区）中的 VDI（虚拟桌面基础设施）服务器上的浏览器，可以有效防止未知恶意软件下载到 PC 上。这种安全效果是由 VDI 服务器的哪个操作特性产生的？\nア：从网站接收数据后，将其用 IPsec 封装，然后发送到 PC。\nイ：从网站接收数据后，删除可执行文件，然后将其他数据发送到 PC。\nウ：从网站接收数据后，仅将生成的桌面屏幕的图像数据发送到 PC。\nエ：从网站接收数据后，只有在未检测到恶意代码时才发送到 PC。\n答案为选项 ウ，看名字就知道虚拟桌面只传输画面\n第 15 问 ファジングに該当するものはどれか。\nア　サーバにFINバケットを送信し、サーバからの応答を観測して、稼働しているサービスを見つけ出す。\nイ　サーバのOSやアプリケーションソフトウェアが生成したログやコマンド履歴などの解析して、ファイルサーバに保存されているファイルの改ざんを検知する。\nウ　ソフトウェアに、問題を引き起こしそうな多様なデータを入力し、挙動を監視して、脆弱性を見つけ出す。\nエ　ネットワーク上を流れるバケットを収集し、そのプロトコルヘッダやペイロードを解析して、あらかじめ登録された攻撃パターンと一致するものを検出する。\n题目翻译：以下哪个选项符合模糊测试（Fuzzing）的描述\nア：向服务器发送 FIN 数据包，并观察服务器的响应，以发现正在运行的服务。\nイ：分析服务器的操作系统或应用软件生成的日志和命令历史记录，以检测存储在文件服务器上的文件是否被篡改。\nウ：向软件输入可能引发问题的多种数据，监视其行为，并查找漏洞。\nエ：收集网络中传输的数据包，解析其协议头和有效负载，检测与预先注册的攻击模式相匹配的内容。\n模糊测试是一种自动化的软件测试技术，通过向程序输入随机或异常数据来触发潜在漏洞，从而检测软件中的错误和安全漏洞。Fuzzing 特别适用于发现系统中可能被忽视或未考虑到的边界条件和异常情况。它的目标在于测试软件在意外输入条件下的行为，并判断程序是否具备足够的鲁棒性和安全性。所以答案为选项 ウ\n选项 ア 描述的是 FIN 扫描，用于检测目标服务器上有哪些服务在运行，有点像 nmap 命令。选项 イ 入侵检测系统 (IDS) 工作的一部分。选项 エ 属于网络入侵检测系统 (NIDS) ，常用该技术来实时监控网络流量，发现并防御已知攻击，但包捕获与检测能够识别常见攻击模式，但难以检测到未知或变种攻击\n","date":"2024-10-26T21:41:16+08:00","permalink":"https://blog.yexca.net/archives/189/","title":"2022 SA am1 -11-15"},{"content":"引言 日本語のタイトルを書いても、この文章は主に日本語の内容ではありません。時間があれば追加かもしれません\n题目一： https://blog.yexca.net/archives/183 题目二： https://blog.yexca.net/archives/187 题目三：本文\n全部做下来的感觉就是可能因为是多专业共用的数学试题吧，线代不知道，高数和概率论几乎就是引导这让考生完成某一结论的证明或者了解某项东西。其中高数是弧长参数化，线代是 37% 法则。而如果知道这些结论会很好解出题目，事先没学过的话做出来的人是真厉害。至少让我从零开始那是包挂的\n同时因为是已有的理论，解题答案应该是对的，过程嘛，就不知道了 XD\n题目 Source: https://www.i.u-tokyo.ac.jp/edu/entra/examarchive.shtml 题目版权属于东京大学所有，仅为了方便观看而引用，无盈利行为\n$n$ 人のアルバイト候補者を面接し、その中の最適任者を採用したい。ただし、$n \\ge 2$ とする。候補者にあらかじめ順位 $1$、順位 $2$、$\\cdots$、順位 $n$　までの絶対的順位が定まっており、すでに面接した候補者についてはそれらの間の相対的順位が分かるものとする。面接は一人ずつ順に行うが、候補者の現れる順番はランダムに決定され、事前には分からない。採用プロセスでは、すでに面接した候補者の間での相対的順位に基づいて採否の決定が行われ、さらに以下の条件が課される。\n各候補者の面接の直後に、その候補者の採否を決定する。 ある候補者の採用が決まった時点で採用プロセスを終了する。 過去に不採用にした候補者を採用することはできない。 $n-1$ 回までの面接で採用しなかったときは、$n$ 番目の候補者を無条件で採用する。 アルバイトの採用において次のような戦略をとる。ただし、$1 \u0026lt; r \\le n$ とする。\n$r-1$ 回の面接までは無条件で候補者を不採用にする。 以降の面接では、候補者がその $r-1$ 人の中での最良候補（相対的順位 $1$）よりも良ければ採用する。 この戦略で、絶対的順位 $1$ の候補者を採用する確率を $P_{n}(r)$ とする。以下の問いに答えよ。\n（１）$P_{4}(2)$ を求めよ。\n（２）$P_{10}(3)=\\frac{2}{10}(\\frac{1}{2}+\\frac{1}{3}+\\cdots+\\frac{1}{9})$ となることを示せ。\n（３）$n$ 人の候補者に対して、$k$ 回目の面接で絶対的順位 $1$ の候補者を採用する確率を求めよ。ただし、$r \\le k \\le n$ である。\n（４）以下の漸化式において、$A,B$ に入る式を求めよ。\n$$ P_{n}(r)=A+B\\times P_{n}(r+1) $$\nただし、$A,B$ には $n,r$ と定数からなる式が入る。\n（５）$q=r/n$ とする。$n$ が十分大きいときに $P_{n}(r)$ は $-q\\ln(q)$ で近似できることを説明せよ。さらに、$-q\\ln(q)$ の最大値を与える $q\\in (0,1]$ の値を求めよ。ただし、$\\ln$ は自然対数を表す。\n中文解答 背景翻译：现希望在面试 $n$ 个候选人后找到最佳人选。其中 $n \\ge 2$ 。每个候选者的能力等级是确定的 (最好的、次好的、···、最差的) 。已经面试过的候选者就可以知道这些人的相对等级能力，面试是一个人一个人进行的，但是面试顺序是随机的，事前不知道。招聘中心将对已经面试过的人的相对能力等级而确定录用谁，并满足以下条件\n每个候补者面试后立即确定是否录用 一旦决定录取某人则所有面试结束 过去未录用的人不会录用 如果只剩一人，前面的人都不合格，则直接录用此人 招聘中心采用以下策略，其中 $1 \u0026lt; t \\le n$\n前 $r-1$ 人的面试直接拒绝 之后的面试中，若有人优于前 $r-1$ 中最优的人，则录用 在这个策略中，最好的候选人录取的概率表示为 $P_{n}(r)$，回答以下问题\n这题读完之后就想到了毕导的 那个如何科学有效脱单视频 ，和视频中的方法一样，也就是 $37%$ 法则，题目就是其描述，最后一问就是其 求解过程 第一问 题目翻译：求 $P_{4}(2)$\n$$ \\begin{align} P_{4}(2) \u0026amp;=\\frac{1}{4}+\\frac{1}{4} \\times \\frac{1}{2} + \\frac{1}{4} \\times \\frac{1}{3} \\ \u0026amp;=\\frac{1}{4}+\\frac{1}{8}+\\frac{1}{12} \\ \u0026amp;=\\frac{11}{24} \\end{align} $$\n这里的算式是最优秀的人在第二位的概率被选中、最优秀的人在第三位的概率被选中和最优秀的人在第四位的概率被选中。为了选择最优秀的人，需要保证第 $r$ 个人开始到最优秀的人之间的人不能比前面的 $r-1$ 人优秀。这句话有点绕啊，现在分情况讨论\n假设最优秀的人是第一人，那直接被淘汰，选中的概率为 $0$\n假设最优秀的人是第二人，由于从第二人开始选择是否录用，前面的人不可能比最优秀的人更优秀，所以选中的概率是 $1$\n假设最优秀的人是第三人，这时候有两种情况\n如果第二个人比第一个人优秀，那么最优秀的人不会被录用 如果第二个人没第一个人优秀，那么最优秀的人将会被录用 所以该情况选中的概率是 $\\frac{1}{2}$\n假设最优秀的人是第四人，这时候只有第二优秀的人在第一位才能保证最优秀的被录用 (分情况有六种，太麻烦了不写)，所以该情况选中的概率是 $\\frac{1}{3}$\n以上四种情况合起来 $P=\\frac{1}{4} \\times 0+\\frac{1}{4} \\times 1 +\\frac{1}{4} \\times \\frac{1}{2} + \\frac{1}{4} \\times \\frac{1}{3}$\n第二问 题目翻译：证明 $P_{10}(3)=\\frac{2}{10}(\\frac{1}{2}+\\frac{1}{3}+\\cdots+\\frac{1}{9})$\n现在假设最优秀的人在第 $m$ 位 ($3 \\le m \\le 10$)，为了保证选中最优秀的人，前 $m-1$ 个人中最优秀的人要在前两个人中，其概率为 $\\frac{2}{m-1}$，所以在 $m$ 范围内选中最优秀的人的概率为\n$$ \\begin{align} P =\u0026amp;\\frac{1}{10} \\times \\frac{2}{2}+\\frac{1}{10} \\times \\frac{2}{3}+\\frac{1}{10} \\times \\frac{2}{4}+\\frac{1}{10} \\times \\frac{2}{5}+\\ \u0026amp;\\frac{1}{10} \\times \\frac{2}{6}+\\frac{1}{10} \\times \\frac{2}{7}+\\frac{1}{10} \\times \\frac{2}{8}+\\frac{1}{10} \\times \\frac{2}{9} \\ =\u0026amp;\\frac{1}{10}(\\frac{2}{2}+\\frac{2}{3}+\\frac{2}{4}+\\frac{2}{5}+\\frac{2}{6}+\\frac{2}{7}+\\frac{2}{8}+\\frac{2}{9}) \\ =\u0026amp;\\frac{2}{10}(\\frac{1}{2}+\\frac{1}{3}+\\frac{1}{4}+\\frac{1}{5}+\\frac{1}{6}+\\frac{1}{7}+\\frac{1}{8}+\\frac{1}{9}) \\end{align} $$\n当最优秀的人在前两位时无法选中最优秀的人，所以\n$$ \\begin{align} P_{10}(3) \u0026amp;=\\frac{1}{10} \\times 0 + \\frac{1}{10} \\times 0 + P \\ \u0026amp;=P \\end{align} $$\n原命题得证\n第三问 题目翻译：对于 $n$ 个候选人，求在第 $k$ 次面试中录用最优的候选人的概率，其中 $r \\le k \\le n$\n要想第 $k$ 次面试录取最优秀的人，那么最优秀的人就在第 $k$ 位，为了保证选中最优秀的人，前 $k-1$ 个人中最优秀的人要在前 $r-1$ 人中，其概率为 $\\frac{r-1}{k-1}$，所以\n$$ P=\\frac{1}{n} \\times \\frac{r-1}{k-1} $$\n第四问 题目翻译：对于以下的渐进式 (公式略) ，求 $A$ 和 $B$。其中 $A,B$ 是用 $n,r$ 和常数的表达式\n$$ \\begin{align} P_{n}(r) \u0026amp;= \\frac{1}{n}(\\frac{r-1}{r-1}+\\frac{r-1}{r+1}+\\frac{r-1}{r+2}+\\cdots+\\frac{r-1}{n-1}) \\ \u0026amp;=\\frac{1}{n} \\sum_{i=r-1}^{n-1} \\frac{r-1}{i} \\ \u0026amp;= \\frac{r-1}{n}\\sum_{i=r-1}^{n-1}\\frac{1}{i} \\end{align} $$\n所以\n$$ P_{n}(r+1)=\\frac{r}{n}\\sum_{i=r}^{n-1}\\frac{1}{i} $$\n首先算 $B$\n$$ \\frac{r}{n} \\times B = \\frac{r-1}{n} \\ B = \\frac{r-1}{r} $$\n然后算 $A$ 因为两者之间缺了 $i=r-1$ 项即 $\\frac{r-1}{n} \\times \\frac{1}{r-1} = \\frac{1}{n}$\n所以 $A = \\frac{1}{n}$\n第五问 题目翻译：设 $q=r/n$，当 $n$ 足够大时，解释 $P_{n}(r)$ 可以用 $-q\\ln(q)$ 近似。进一步求 $-q\\ln(q)$ 的极大值所对应的 $q\\in (0,1]$。其中 $\\ln$ 表示自然对数\n上方已经给出了 $P_{n}(r)$ 的公式，当 $n$ 足够大时\n$$ \\sum_{i=r-1}^{n-1}\\frac{1}{i} \\approx \\int_{r}^{n} \\frac{1}{x} = \\ln(n)-\\ln(r)= \\ln(\\frac{n}{r}) $$\n所以\n$$ P_{n}(r) \\approx \\frac{r}{n}ln(\\frac{n}{r}) = q\\ln(\\frac{1}{q}) = -q\\ln(q) $$\n令 $y=-q\\ln(q)$，则 $\\frac{\\mathrm{d} y}{\\mathrm{d} q} = -\\ln(q)-1$ 令 $\\frac{\\mathrm{d} y}{\\mathrm{d} q}=0$ 得 $q=\\frac{1}{e}$\n也就是当 $q=\\frac{1}{e}$ 时，$-q\\ln(q)$ 取最大值\n这题我也不大理解，反正近似就对了，具体和 毕导视频中的公式 也有一点不一样，不想思考了\nWrote with ChatGPT\n","date":"2024-10-25T19:24:36+08:00","permalink":"https://blog.yexca.net/archives/188/","title":"东京大学大学院理工学 数学 2020 问题三 / 東大院理工学 数学 2020 問題三"},{"content":"引言 日本語のタイトルを書いても、この文章は主に日本語の内容ではありません。時間があれば追加かもしれません\n题目一： https://blog.yexca.net/archives/183 题目二：本文\n题目三： https://blog.yexca.net/archives/188 唉，干劲总是会被现实所打败，不过这次我伤心的时间倒是变短了，希望慢慢的可以好起来\n关于这题的话，应该属于一个单独的向量的课程吧，我是一点没看懂，后来想到 3b1b 的线性代数的本质才想到了数学中向量的一般表示，然后慢慢想\n不过事实上题目几乎也把这些东西的定义都给了出来，如果日本的教学不学的话，相当于是当场看定义，然后据此解题。只能说能解出来是真的很厉害，望而却步\n同时，因为全是证明题，无法确保过程是否正确\n题目 Source: https://www.i.u-tokyo.ac.jp/edu/entra/examarchive.shtml 题目版权属于东京大学所有，仅为了方便观看而引用，无盈利行为\n$xy$ 平面内の滑らかな曲線 $\\boldsymbol{p}=(p(t),q(t))(t \\in [a,b])$ を考える。時刻 $t=a^{\u0026rsquo;} $ から $b^{\u0026rsquo;}$ までの $\\boldsymbol{p}$ の長さ $l_{a^{\u0026rsquo;},b^{\u0026rsquo;}}$ は\n$$ l_{a^{\u0026rsquo;},b^{\u0026rsquo;}} = \\int_{a^{\u0026rsquo;}}^{b^{\u0026rsquo;}} \\sqrt{(\\frac{\\mathrm{d} p}{\\mathrm{d} t})^2+(\\frac{\\mathrm{d} q}{\\mathrm{d} t})^2} \\mathrm{d} t $$\nと定義され、$\\boldsymbol{p}$ の全長 $l_{a,b}$ を $L$ で表す。曲線 $\\boldsymbol{p}$ は、$\\frac{\\mathrm{d} \\boldsymbol{p}}{\\mathrm{d} t}=(0,0)$ とはならないものとする。時刻 $a$ から $t$ までの $\\boldsymbol{p}$ の長さ $l_{a,t}$ を変数 $s=s(t)$ で表すと、$\\boldsymbol{p}$ を媒介変数 $s \\in [0,L]$ の曲線とみることができる。そして、$s$ も時刻と呼ぶ。以下の問いに答えよ。\n（１）以下の等式を示せ。\n$$ \\sqrt{(\\frac{\\mathrm{d} p}{\\mathrm{d} s})^2+(\\frac{\\mathrm{d} q}{\\mathrm{d} s})^2} = 1 $$\n（２）$\\theta = \\theta(s)$ を時刻 $s$ における $\\boldsymbol{p}$ の接線ベクトル $\\frac{\\mathrm{d} \\boldsymbol{p}}{\\mathrm{d} s} = (\\frac{\\mathrm{d} p}{\\mathrm{d} s},\\frac{\\mathrm{d} q}{\\mathrm{d} s})$ と $x$ 軸とのなす角とする。このとき、以下の等式を示せ。\n$$ \\frac{\\mathrm{d} p}{\\mathrm{d} s} \\frac{\\mathrm{d}^2 q}{\\mathrm{d} s^2}-\\frac{\\mathrm{d} q}{\\mathrm{d} s}\\frac{\\mathrm{d}^2 p}{\\mathrm{d} s^2} = \\frac{\\mathrm{d} \\theta}{\\mathrm{d} s} $$\n以下では、曲線 $\\boldsymbol{p}$ は、滑らかな閉曲線で、凸集合 $\\boldsymbol{K}$ の境界となっているもの。また、$\\boldsymbol{p}$ は、反時計方向に $\\boldsymbol{K}$ をまわるものとする。\n（３）任意の時刻 $s$ で $\\frac{\\mathrm{d} \\theta}{\\mathrm{d} s} \\ge 0$ となることを説明せよ。\n（４）$\\boldsymbol{K}$ に含まれない点 $\\boldsymbol{x}=(x,y)$ は、時刻 $s \\in [0,L]$ および $\\boldsymbol{x}$ と $\\boldsymbol{K}$ の距離 $r$ によって。\n$$ \\boldsymbol{x} = \\boldsymbol{p} (s) + r \\boldsymbol{u} (s) $$\nと一意に表すことができる。ここで、$\\boldsymbol{u} (s)$ は、時刻 $s$ における $\\boldsymbol{p}$ の単位法線ベクトルで、$\\boldsymbol{K}$ の外を向いているものとする。そのような $\\boldsymbol{x} = (x,y)$ に対して、以下の等式を示せ。\n$$ \\left | det \\begin{pmatrix} \\frac{\\partial x}{\\partial s} \u0026amp; \\frac{\\partial x}{\\partial r} \\ \\frac{\\partial y}{\\partial s} \u0026amp; \\frac{\\partial y}{\\partial r} \\end{pmatrix} \\right | =1 +r\\frac{\\mathrm{d} \\theta}{\\mathrm{d} s} $$\n（５）非負実数 $D$ に対し、$K_D$ を $K$ から距離 $D$ 以内にある点の集合とする。このとき、$K_D$ の面積 $A_D = \\iint_{K_D} \\mathrm{d}x\\mathrm{d}y$ は、$K$ の面積 $A$ と $\\boldsymbol{p}$ の全長 $\\boldsymbol{L}$ を用いて\n$$ A_D = A + LD + \\pi D^2 $$\nと表せることを示せ。\n中文解答 假设翻译：考虑 $xy$ 平面上的光滑曲线 $\\boldsymbol{p}=(p(t),q(t))(t \\in [a,b])$ ，从时刻 $t=a^{\u0026rsquo;} $ 到 $t=b^{\u0026rsquo;}$ 的曲线 $\\boldsymbol{p}$ 的长度 $l_{a^{\u0026rsquo;},b^{\u0026rsquo;}}$ 定义为\n$$ l_{a^{\u0026rsquo;},b^{\u0026rsquo;}} = \\int_{a^{\u0026rsquo;}}^{b^{\u0026rsquo;}} \\sqrt{(\\frac{\\mathrm{d} p}{\\mathrm{d} t})^2+(\\frac{\\mathrm{d} q}{\\mathrm{d} t})^2} \\mathrm{d} t $$\n$\\boldsymbol{p}$ 的总长度 $l_{a,b}$ 记作 $L$ 。假设 $\\frac{\\mathrm{d} \\boldsymbol{p}}{\\mathrm{d} t}=(0,0)$ 不成立，用变量 $s=s(t)$ 表示从時刻 $a$ 到 $t$ 的曲线 $\\boldsymbol{p}$ 的长度 $l_{a,t}$ 。这样可以将 $\\boldsymbol{p}$ 看作参数 $s \\in [0,L]$ 的曲线，并将 $s$ 称为时刻\n这个描述其实就是弧长参数化 (arc length parametrization) 指使用曲线的弧长作为参数来表示曲线的一种特殊形式。具体来说，它将曲线上某一点到曲线起始点的距离（即弧长）作为新的参数，从而使得曲线的参数化不仅简洁，还能反映曲线的几何特性\n第一问 题目翻译：证明以下等式\n因为曲线的时刻 $t \\in [a,b]$ ，所以曲线的全长 $L$ 为\n$$ l_{a,b} = \\int_{a}^{b} \\sqrt{(\\frac{\\mathrm{d} p}{\\mathrm{d} t})^2+(\\frac{\\mathrm{d} q}{\\mathrm{d} t})^2} \\mathrm{d} t $$\n而 $s$ 是从 $a$ 到 $t$ 的弧长，即\n$$ s = \\int_{a}^{t} \\sqrt{(\\frac{\\mathrm{d} p}{\\mathrm{d} t})^2+(\\frac{\\mathrm{d} q}{\\mathrm{d} t})^2} \\mathrm{d} t $$\n所以 $s$ 是代表了从弧线的初始点 $a$ 到当前点的弧长，所以\n$$ \\frac{\\mathrm{d} s}{\\mathrm{d} t} = \\sqrt{(\\frac{\\mathrm{d} p}{\\mathrm{d} t})^2+(\\frac{\\mathrm{d} q}{\\mathrm{d} t})^2} $$\n因为 $\\boldsymbol{p}$ 可以看作参数 $s$ 的曲线，$s$ 是 $t$ 的函数，所以\n$$ \\frac{\\mathrm{d} p}{\\mathrm{d} t} = \\frac{\\mathrm{d} p}{\\mathrm{d} s} \\frac{\\mathrm{d} s}{\\mathrm{d} t} \\ \\frac{\\mathrm{d} q}{\\mathrm{d} t} = \\frac{\\mathrm{d} q}{\\mathrm{d} s} \\frac{\\mathrm{d} s}{\\mathrm{d} t} $$\n即\n$$ \\begin{align} \\frac{\\mathrm{d} s}{\\mathrm{d} t} \u0026amp;=\\sqrt{(\\frac{\\mathrm{d} p}{\\mathrm{d} s} \\frac{\\mathrm{d} s}{\\mathrm{d} t})^2+(\\frac{\\mathrm{d} q}{\\mathrm{d} s} \\frac{\\mathrm{d} s}{\\mathrm{d} t})^2} \\ \u0026amp;=\\sqrt{(\\frac{\\mathrm{d} p}{\\mathrm{d} s})^2+(\\frac{\\mathrm{d} q}{\\mathrm{d} s})^2} \\frac{\\mathrm{d} s}{\\mathrm{d} t} \\end{align} $$\n因为 $\\frac{\\mathrm{d} p}{\\mathrm{d} t} \\ne 0$ 所以 $\\frac{\\mathrm{d} s}{\\mathrm{d} t} \\ne 0$ 即\n$$ \\sqrt{(\\frac{\\mathrm{d} p}{\\mathrm{d} s})^2+(\\frac{\\mathrm{d} q}{\\mathrm{d} s})^2} = 1 $$\n这个证明表明在弧长参数化下，曲线的速度向量 $\\frac{\\mathrm{d} \\boldsymbol{p}}{\\mathrm{d} s}$ 的长度始终为 $1$\n第二问 题目翻译：$\\theta = \\theta(s)$ 在时刻 $s$ 时，曲线 $\\boldsymbol{p}$ 的切线 $\\frac{\\mathrm{d} \\boldsymbol{p}}{\\mathrm{d} s} = (\\frac{\\mathrm{d} p}{\\mathrm{d} s},\\frac{\\mathrm{d} q}{\\mathrm{d} s})$ 与 $x$ 轴的夹角。证明等式。\n一般情况下，向量是从零点开始到所表示的那一点，与 $x$ 轴的夹角为 $\\theta$ 则向量分量\n$$ v_x = \\left | v \\right | \\cos(\\theta) \\ v_y = \\left | v \\right | \\sin(\\theta) $$\n由第一问知 $\\begin{vmatrix} \\frac{\\mathrm{d} \\boldsymbol{p}}{\\mathrm{d} s} \\end{vmatrix} = 1$ 所以\n$$ \\begin{align} \\frac{\\mathrm{d} \\boldsymbol{p}}{\\mathrm{d} s} \u0026amp;= (\\frac{\\mathrm{d} p}{\\mathrm{d} s},\\frac{\\mathrm{d} q}{\\mathrm{d} s}) \\ \u0026amp;= (\\cos(\\theta(s)), \\sin(\\theta(s))) \\end{align} $$\n对分量对 $s$ 求导\n$$ \\begin{align} \\frac{\\mathrm{d}^2 p}{\\mathrm{d} s^2} \u0026amp;= -\\sin(\\theta(s)) \\cdot \\frac{\\mathrm{d} \\theta}{\\mathrm{d} s} \\ \\frac{\\mathrm{d}^2 q}{\\mathrm{d} s^2} \u0026amp;= \\cos(\\theta(s)) \\cdot \\frac{\\mathrm{d} \\theta}{\\mathrm{d} s} \\end{align} $$\n所以\n$$ \\begin{align} \\frac{\\mathrm{d} p}{\\mathrm{d} s} \\frac{\\mathrm{d}^2 q}{\\mathrm{d} s^2}-\\frac{\\mathrm{d} q}{\\mathrm{d} s}\\frac{\\mathrm{d}^2 p}{\\mathrm{d} s^2} \u0026amp;= \\cos(\\theta(s)) \\cdot \\cos(\\theta(s)) \\cdot \\frac{\\mathrm{d} \\theta}{\\mathrm{d} s} - \\sin(\\theta(s)) \\cdot (-\\sin(\\theta(s)) \\cdot \\frac{\\mathrm{d} \\theta}{\\mathrm{d} s}) \\ \u0026amp;= (\\cos(\\theta(s)))^2 \\cdot \\frac{\\mathrm{d} \\theta}{\\mathrm{d} s} + (\\sin(\\theta(s)))^2 \\cdot \\frac{\\mathrm{d} \\theta}{\\mathrm{d} s}) \\ \u0026amp;= \\frac{\\mathrm{d} \\theta}{\\mathrm{d} s} \\end{align} $$\n第三问 假设条件：曲线 $\\boldsymbol{p}$ 是一个光滑的闭曲线，并且是凸集合的边界 $\\boldsymbol{K}$。而且，曲线 $\\boldsymbol{p}$ 是以逆时针方向绕 $\\boldsymbol{K}$ 移动\n题目翻译：说明为什么任意时刻時刻 $s$ ， $\\frac{\\mathrm{d} \\theta}{\\mathrm{d} s} \\ge 0$ 恒成立\n这题不好说明，因为曲线 $\\boldsymbol{p}$ 是光滑凸曲线，曲线的切线变化是连续的并且不会反向，即单调的。并且是逆时针移动的话，任意时刻与 $x$ 轴的夹角 $\\theta$ 都是一直在增长的，所以导数就是一直在增长的，所以 $\\frac{\\mathrm{d} \\theta}{\\mathrm{d} s} \\ge 0$ 恒成立\n第四问 题目翻译：对于不包含在 $\\boldsymbol{K}$ 内的点 $\\boldsymbol{x}=(x,y)$ 可以唯一表示为 $s \\in [0,L]$ 和 $\\boldsymbol{x}$ 与 $\\boldsymbol{K}$ 的距离 $r$ 的函数\n$$ \\boldsymbol{x} = \\boldsymbol{p} (s) + r \\boldsymbol{u} (s) $$\n其中，$\\boldsymbol{u} (s)$ 是時刻 $s$ 下的 $\\boldsymbol{p}$ 的单位法向量，且方向指向 $\\boldsymbol{K}$ 的外部。对于这样的 $\\boldsymbol{x} = (x,y)$ 证明等式成立\n因为 $\\frac{\\mathrm{d} \\boldsymbol{p}}{\\mathrm{d} s} $ 是单位切线向量，$\\boldsymbol{u} (s)$ 是当时的单位法向量且方向指向 $\\boldsymbol{K}$ 的外部，所以\n$$ \\boldsymbol{u} (s) = (\\frac{\\mathrm{d} q}{\\mathrm{d} s},-\\frac{\\mathrm{d} p}{\\mathrm{d} s}) $$\n对 $\\boldsymbol{x}$ 分别对 $s$ 和 $r$ 求偏导\n$$ \\begin{align} \\frac{\\partial \\boldsymbol{x}}{\\partial s} \u0026amp;= \\frac{\\partial \\boldsymbol{p}}{\\partial s} + r\\frac{\\partial \\boldsymbol{u}}{\\partial s} \\ \\frac{\\partial \\boldsymbol{x}}{\\partial r} \u0026amp;= \\frac{\\partial \\boldsymbol{u}}{\\partial s} \\end{align} $$\n求其分量的偏导，对于 $x$\n$$ \\begin{align} \\frac{\\partial x}{\\partial s} \u0026amp;= \\frac{\\mathrm{d} p}{\\mathrm{d} s} + r\\frac{\\mathrm{d}^2 q}{\\mathrm{d} s^2} \\ \\frac{\\partial x}{\\partial r} \u0026amp;= \\frac{\\mathrm{d} q}{\\mathrm{d} s} \\end{align} $$\n对于 $y$\n$$ \\begin{align} \\frac{\\partial y}{\\partial s} \u0026amp;= \\frac{\\mathrm{d} q}{\\mathrm{d} s} - r\\frac{\\mathrm{d}^2 p}{\\mathrm{d} s^2} \\ \\frac{\\partial y}{\\partial r} \u0026amp;= -\\frac{\\mathrm{d} p}{\\mathrm{d} s} \\end{align} $$\n所以原矩阵可以变成\n$$ \\begin{pmatrix} \\frac{\\partial x}{\\partial s} \u0026amp; \\frac{\\partial x}{\\partial r} \\ \\frac{\\partial y}{\\partial s} \u0026amp; \\frac{\\partial y}{\\partial r} \\end{pmatrix} \\begin{pmatrix} \\frac{\\mathrm{d} p}{\\mathrm{d} s} + r\\frac{\\mathrm{d}^2 q}{\\mathrm{d} s^2} \u0026amp; \\frac{\\mathrm{d} q}{\\mathrm{d} s} \\ \\frac{\\mathrm{d} q}{\\mathrm{d} s} - r\\frac{\\mathrm{d}^2 p}{\\mathrm{d} s^2} \u0026amp; -\\frac{\\mathrm{d} p}{\\mathrm{d} s} \\end{pmatrix} $$\n对其求行列式\n$$ \\begin{align} \\det\\begin{pmatrix} \\frac{\\mathrm{d} p}{\\mathrm{d} s} + r\\frac{\\mathrm{d}^2 q}{\\mathrm{d} s^2} \u0026amp; \\frac{\\mathrm{d} q}{\\mathrm{d} s} \\ \\frac{\\mathrm{d} q}{\\mathrm{d} s} - r\\frac{\\mathrm{d}^2 p}{\\mathrm{d} s^2} \u0026amp; -\\frac{\\mathrm{d} p}{\\mathrm{d} s} \\end{pmatrix} \u0026amp;= (\\frac{\\mathrm{d} p}{\\mathrm{d} s} + r\\frac{\\mathrm{d}^2 q}{\\mathrm{d} s^2})(-\\frac{\\mathrm{d} p}{\\mathrm{d} s})-(\\frac{\\mathrm{d} q}{\\mathrm{d} s} - r\\frac{\\mathrm{d}^2 p}{\\mathrm{d} s^2})(\\frac{\\mathrm{d} q}{\\mathrm{d} s}) \\ \u0026amp;= -(\\frac{\\mathrm{d} p}{\\mathrm{d} s})^2 -r\\frac{\\mathrm{d}^2 q}{\\mathrm{d} s^2}\\frac{\\mathrm{d} p}{\\mathrm{d} s}-(\\frac{\\mathrm{d} q}{\\mathrm{d} s})^2+r\\frac{\\mathrm{d}^2 p}{\\mathrm{d} s^2}\\frac{\\mathrm{d} q}{\\mathrm{d} s} \\ \u0026amp;= -[(\\frac{\\mathrm{d} p}{\\mathrm{d} s})^2+(\\frac{\\mathrm{d} q}{\\mathrm{d} s})^2]-r(\\frac{\\mathrm{d}^2 q}{\\mathrm{d} s^2}\\frac{\\mathrm{d} p}{\\mathrm{d} s}-\\frac{\\mathrm{d}^2 p}{\\mathrm{d} s^2}\\frac{\\mathrm{d} q}{\\mathrm{d} s}) \\end{align} $$\n由第一问和第二问的结论可以得到\n$$ \\begin{align} \\left | \\det\\begin{pmatrix} \\frac{\\mathrm{d} p}{\\mathrm{d} s} + r\\frac{\\mathrm{d}^2 q}{\\mathrm{d} s^2} \u0026amp; \\frac{\\mathrm{d} q}{\\mathrm{d} s} \\ \\frac{\\mathrm{d} q}{\\mathrm{d} s} - r\\frac{\\mathrm{d}^2 p}{\\mathrm{d} s^2} \u0026amp; -\\frac{\\mathrm{d} p}{\\mathrm{d} s} \\end{pmatrix} \\right | \u0026amp;= \\left | -1-r\\frac{\\mathrm{d} \\theta}{\\mathrm{d} s} \\right | \\ \u0026amp;= 1+r\\frac{\\mathrm{d} \\theta}{\\mathrm{d} s} \\end{align} $$\n其实这里出现的矩阵是 雅可比矩阵 第五问 题目翻译：对于非负实数 $D$ ，定义 $K_D$ 为 $K$ 距离 $D$ 以内的点的集合。证明 $K_D$ 的面积 $A_D$ 可以用 $K$ 的面积和 $\\boldsymbol{p}$ 的全长 $L$ 表示，公式略\n这个证明我认为可以画个图比较好理解，但怎么用文字表述我没想到，大概就是图中的意思\n其中蓝色的是 $K$ 的面积，绿色的是把 $K$ 变成长方形的面积，然后图中为了方便看把拐角 (粉色) 画的很大，并且为了方便用的长方形，实际上应该是因为凸性且光滑封闭，所有的弯折处正好组成了一个圆，这部分的面积就是 $\\pi D^2$ 。这个就是想象拐角处无限小，无限逼近是一个直角，那么用 $LD$ 也是会有一定的面积没算进去 (因为是扇形)，所有的拐角没被算进去的加一起就是一个圆的面积\n所以 $A_D = A + LD + \\pi D^2$\nWrote with ChatGPT\n","date":"2024-10-24T22:46:25+08:00","permalink":"https://blog.yexca.net/archives/187/","title":"东京大学大学院理工学 数学 2020 问题二 / 東大院理工学 数学 2020 問題二"},{"content":"引言 2022 SA am1\n01-02: https://blog.yexca.net/archives/184 03-05: https://blog.yexca.net/archives/185 06-10: https://blog.yexca.net/archives/186 11-15: https://blog.yexca.net/archives/189 16-30: https://blog.yexca.net/archives/190 可能因为是多场考试共用的试卷吧，问题还是挺基础的，感觉像软考中级软件设计师的程度。不过一共有四场考试呢，也不知道啥时候能把这第一个写完呢\n第六问 一つの $I^2C$ バスに接続された二つのセンサがある。それぞれのセンサ値を読み込む二つのタスで排他的に制御したい。利用するリアルタイムOSの機能として、適切なものはどれか。\nア　キュー\nイ　セマフォ\nウ　マルチスレッド\nエ　ラウンドロビン\n题目翻译：有两个连接到同一个 I²C 总线的传感器。为了排他性地控制两个任务读取各自的传感器值，应使用哪种实时操作系统的功能？\nア：队列 (queue)\nイ：信号量 (semaphore)\nウ：多线程 (Multithreading)\nエ：轮转调度 (Round Robin)\n队列是一种数据结构，遵循 FIFO 即先进先出原则，适用于多个任务之间的通信或数据传递\n信号量是一种同步机制，主要用于控制对共享资源的访问，确保多个任务在并发环境下不会同时访问同一个资源。信号量分为两类：二值信号量 (用于排他性访问) 和计数信号量 (用于管理资源池)\n多线程指在一个进程内同时执行多个线程的机制。其本身不用于排他性控制，但往往需要配合信号量、互斥锁等机制来确保对共享资源的安全访问\n轮转调度是一种简单的任务调度算法，比如时间片轮转\n选项本身倒是还好，只是都是片假名，无疑增加了难度。综上所述，本题选择 イ\n第七问 アクチュエータの説明として、適切なものはどれか。\nア　与えられた目標量と、センサから得られた制御量に比較し、制御量を目標量に一致させるように操作量を出力する。\nイ　位置、角度、速度、加速度、力、温度などを検出し、電気的な情報に変換する。\nウ　エネルギー源からのパワーを、回転、直進などの働きに変換する。\nエ　マイクロフォン、センサなどが出力する微小な電気信号を増幅する。\n题目翻译：关于执行器的描述，哪项是正确的？\nア：将给定的目标值与从传感器获得的控制值进行比较，并输出一个操作量以使控制值与目标值一致。\nイ：检测位置、角度、速度、加速度、力、温度等，并将其转换为电信号。\nウ：将来自能源源的动力转换为旋转、直线运动等工作形式。\nエ：放大由麦克风、传感器等设备输出的微弱电信号。\nア 是控制器的功能，通常用于闭环控制系统中；イ 是传感器的功能，将物理量转换为电信号；ウ 是执行器的功能；エ 是放大器的功能。本题选 ウ\n第八问 第1、第2、第3正規形とリレーションの特徴 a, b, c の組合のうち、適切なものはどれか。\na：どの非キー属性も、主キーの真部分集合に対して関数従属しない。\nb：どの非キー属性も、主キーに推移的に関数従属しない。\nc：繰り返し属性が存在しない。\n第1正規形 第2正規形 第3正規形 ア a b c イ a c b ウ c a b エ c b a 题目翻译：以下关于 1NF、2NF 和 3NF 的定义，与特征 a, b, c 的组合，哪一项是正确的？\na：任何非主键属性不依赖于主键的真子集（部分依赖）。\nb：任何非主键属性不通过其他非主键属性依赖于主键（传递依赖）。\nc：不存在重复的属性。\n这个其实就是范式啦，我还 特意写了一篇文章 (翻译成正规形有点奇怪欸) 。参考 总结部分 可以知道 1NF 对应 c；2NF 对应 a；3NF 对应 b。答案为选项 ウ\n第九问 ビッグデータの利用におけるデータマイニングを説明したものはどれか。\nア　蓄積されたデータを分析し、単なる検索だけではわからない隠れた規則や相関関係を見つけ出すこと\nイ　データウェアハウスに格納されたデータの一部を、特定の用途や部門用に切り出して、データベースに格納すること\nウ　データ処理の対象となる情報を基に規定した、データの構造、意味及び操作の枠組みのこと\nエ　データを複数のサーバに複製し、性能と可用性を向上させること\n题目翻译: 以下哪项描述了大数据利用中的数据挖掘？\nア：分析积累的数据，发现通过简单搜索无法找到的隐藏规律和关联。\nイ：从数据仓库中提取一部分数据，按特定用途或部门需求存储到数据库中。\nウ：根据要处理的信息，定义数据的结构、意义和操作框架。\nエ：将数据复制到多个服务器上，以提高性能和可用性。\nア 是数据挖掘的正确描述；イ 是描述数据集市的过程，即从数据仓库中抽取部分数据用于特定用途；ウ 是数据模型的定义；エ 则是数据备份啦。答案为选项 ア\n第十问 UDPを使用しているものはどれか。\nア　FTP\nイ　NTP\nウ　POP３\nエ　TELNET\n题目翻译：以下哪项使用了 UDP 协议\nFTP 是文件传输协议，使用 TCP 确保数据安全；NTP 是网络时间协议，使用 NTP 确保速度；POP3 是邮局协议第三版，使用 TCP 确保邮件传输可靠性；TELNET 是远程终端协议，使用 TCP 建立可靠的远程终端会话。所以答案为选项 イ\n","date":"2024-10-22T15:37:34+08:00","permalink":"https://blog.yexca.net/archives/186/","title":"2022 SA am1 -06-10"},{"content":"引言 2022 SA am1\n01-02: https://blog.yexca.net/archives/184 03-05: https://blog.yexca.net/archives/185 06-10: https://blog.yexca.net/archives/186 11-15: https://blog.yexca.net/archives/189 16-30: https://blog.yexca.net/archives/190 碎碎念 星期一总是很累，在经历了周末的休息后总会在今天提不起精神。不过今天也不知道怎么回事我突然就一改之前快抑郁的感觉，尽管什么也没有做来着，突然就变得及其乐观。情感或者状态确实很奇妙\n所以呢，今天也摸了不少捏，差点就不写了感觉。不过这张试卷有 30 个试题，照目前的速度不得至少半个月才能看完 :cry:\n第三问 ポログラム言語のうち、ブロックの範囲を指定する方法として特定の記号や予約語を用いず、等しい文字数の字下げを用いるという特徴をもつものはどれか。\nア　C\nイ　Java\nウ　PHP\nエ　Python\n题目翻译: 在编程语言中，哪种语言的特点是不使用特定的符号或保留字来指定代码块的范围，而是通过相同字符数的缩进来指定范围？\n显然是 Python，即选项 エ\n第四问 キャッシュメモリのアクセス時間が主記憶のアクセス時間の1/30で、ヒット率が95％のとき、実効メモリアクセス時間は、主記憶のアクセス時間の約何と何倍になるか。\nア　0.03\nイ　0.08\nウ　0.37\nエ　0.95\n这题考实际内存访问实际 (EMAT)，可以通过以下公式计算 $$ EMAT = Cache Access Time \\times Hit Rate + Main Memory Access Time \\times Miss Rate $$\n设 Main Memory Access Time = T，则 Cache Access Time = $\\frac{T}{30}$ ，由题目知 Hit Rate = 95%，则 Miss Rate = 5%\n所以 EMAT = $\\frac{T}{30} \\times 95% + T \\times 5% \\approx 0.08T$ ，所以答案为选项 イ\n这题不会做，计组的话我也就听了一般，说实话应该也算忘的差不多了\n第五问 プロセッサ数と、計算処理におけるプロセスの並列化が可能な部分の割合とが、性能上へ及ぼす影響に関する記述のうち、アムダールの法則に基づいたものはどれか。\nア　全ての計算処理が並列化できる場合、速度向上比は、プロセッサ数を増やしてもある水準に漸近的に近づく。\nイ　並列化できない計算処理がある場合、速度向上比は、プロセッサ数に比例して増加する。\nウ　並列化できない計算処理がある場合、速度向上比は、プロセッサ数を増やしてもある水準に漸近的に近づく。\nエ　並列化できる計算処理の割合が増えると、速度向上比は、プロセッサ数に反比例して減少する。\n题目翻译：关于处理器数量和计算处理过程中可并行化的部分对性能的影响，基于阿姆达尔定律的描述是哪一项？\nア：如果所有的计算处理都可以并行化，对于速度提升比，即使增加处理器数量，也会逐渐接近某个水平。\nイ：如果存在无法并行化的计算处理，速度提升比会随着处理器数量的增加而成比例增长。\nウ：如果存在无法并行化的计算处理，对于速度提升比，即使增加处理器数量，也会逐渐接近某个水平。\nエ：随着可并行化的计算处理比例增加，速度提升比会随着处理器数量的增加而反比例减少。\n要想解出这题需要先知道什么是 アムダールの法則。Amdahl\u0026rsquo;s Law 描述了计算处理过程中，程序的并行化程度对性能提升的影响。指出即使增加处理器的数量，程序不能并行化的部分仍然会限制性能的提升。其公式如下 $$ S(N)=\\frac{1}{(1-P)+\\frac{P}{N}} $$ 其中 S(N) 表示使用 N 个处理器时的速度提升比、P 是程序中能够进行并行化的部分的比例、N 是处理器的数量\n综上所述，本题选 ウ\n","date":"2024-10-21T20:35:34+08:00","permalink":"https://blog.yexca.net/archives/185/","title":"2022 SA am1 -03-05"},{"content":"引言 2022 SA am1\n01-02: https://blog.yexca.net/archives/184 03-05: https://blog.yexca.net/archives/185 06-10: https://blog.yexca.net/archives/186 11-15: https://blog.yexca.net/archives/189 16-30: https://blog.yexca.net/archives/190 那么关于这篇文章，是我想要挑战一下，也没想着会成功，去参加系统架构师考试，也就是计算机专业技术与软件专业技术资格的高级考试，这个考试拿下来的证和学习到的知识可能大多数编码的时候用不上 (其实能用上只是想不到)，但有总比没有好，我尽量可以把这张试卷做完吧，这应该也可以慢慢将我从梦中拉回吧\n碎碎念 自己最近两年确实很浑浑噩噩了，以至于现在对于事情的处理方法也受到该状态的很大影响。一直这么下去终究不是办法，既然无法选择，那就尽力做好吧，我想要可以至少我去尝试一下吧，没有尝试的勇气才是最可怕的，这已经让我最近失去了一个机会了，还是应该有些改变或者变化才会比较可以生活得较为真实点，我也确实有时候觉得我活在梦里，倒不是活得好，而是不真实。文字得力量是有限得，事实的经历更具有说服力，尽管可能是虚假的被创造的事实，我开始去相信一些看似很离谱的事情\nemm，感觉在写日记似的，まあまあ、就这样吧\n引言说到感觉在做梦其实让我想到一个有意思的修仙小说，那个魔宗的人觉得自己是仙人，所在的世界只是一个幻境，自己是过来历练的，我都有时候觉得我被这个设定所影响了。所以不要再说废话了嘛\n第一问 ハミング符号とは、データに冗長ビットを付加して、1ビットの誤りを訂正できるようにしたものである。ここでは。$X_1, X_2, X_3, X_4$ の4ビットから成るデータに3ビットの冗長ビット $P_3, P_2, P_1$ を付加したハミング符号 $X_1X_2X_3P_3X_4P_2P_1$ を考える。付加したビット $P_1, P_2, P_3$ は、それぞれ\n$$ X_1 \\oplus X_3 \\oplus X_4 \\oplus P_1 = 0 \\ X_1 \\oplus X_2 \\oplus X_4 \\oplus P_2 = 0 \\ X_1 \\oplus X_2 \\oplus X_3 \\oplus P_3 = 0 $$\nとなるように決める。ここで、$\\oplus$ は排他的論理和を表す。\nハミング符号1110011には1ビットの誤りが存在する。誤りビットを訂正したハミング符号はどれか。\nア　0110011\nイ　1010011\nウ　1100011\nエ　1110111\n海明码题目，题目给出了公式，每个位置代入计算异或得\n$$ X_1 \\oplus X_3 \\oplus X_4 \\oplus P_1 = 1 \\ X_1 \\oplus X_2 \\oplus X_4 \\oplus P_2 = 1 \\ X_1 \\oplus X_2 \\oplus X_3 \\oplus P_3 = 1 $$\n可以得到出错的位置为 $(111)_2$ 即第 7 位，所以正确的数据为 0110011，即选项 ア\n看到海明码的时候我只觉得很熟悉，但具体是什么呢我已经完全不记得了，哎，之前到底学了啥捏\n海明码可以用于校验数据是否出错，并且进行一位的纠错，以原始数据 1100 为例，变成海明码的过程如下\n首先计算校验位的个数，$2^k \\ge k + m + 1$ 其中 m 为原始数据的个数，k 为校验位的个数，本例的 k 应为 3，共有三个校验位。校验位只会在 $2^n$ 即 1、2、4、8 ···，所以本例校验位在 1、2、4 位。此处以及以后说的位置一般为从右往左\n因为有三位校验位加四位数据，共有七个数，列出其二进制 (校验位 3 位，列出二进制为 3 位)\n7 6 5 4 3 2 1 111 110 101 100 011 010 001 校验位的位置，即 1、2、4 的数字分别对应 001、010、100，即 1 的位置在第一位、第二位、第三位，接下来找出所有位置相同的\n校验码位置 数字 1 位置 码 1 第一位，**1 1、3、5、7 2 第二位，*1* 2、3、6、7 4 第三位，1** 4、5、6、7 然后根据每一组 (上表一行同一个位置的码为一组) 计算确定校验位的码，需要借助原数据，如下表\n位置 7 6 5 4 3 2 1 数值 1 1 0 0 因为校验位数值不确定，先空着\n第一组数据，根据第 1、3、5、7 位的数字确定，共有 1 个 1，所以补 1 使 1 的个数为偶数\n第二组数据，根据第 2、3、6、7 位的数字确定，共有 2 个 1，所以补 0\n第三组数据，根据第 4、5、6、7 位的数字确定，共有 2 个 1，所以补 0\n所以海明码对应位置如下\n位置 7 6 5 4 3 2 1 数值 1 1 0 0 0 0 1 即数据 1100 的海明码为 1100001，校验方式其实和题目一样，毕竟题目例子也是七位数\n校验是怎么确定的呢，把题目中三行公式对应的位置换成从右往左数，可以看到其实就是上面确定校验码时候划分的三个组，所以校验方式也就是确定校验码个数后，再确定各组位置，然后进行异或操作，根据得到的结果 (全是 0 说明数据未改变)，从右往左排列，即\n···第三组、第二组、第一组\n得到的二进制数即数据发生改变的位置，改变数值则得到原来的海明码\n参考文章\n海明码一篇文章彻底搞懂 海明码的编码和校验方法 排他的論理和（XOR） 第二问 リストには、配列で実現する場合とポインタで実現する場合とがある。リストを配列で実現した場合の特徴として、適切なものはどれか。ここで、配列を用いたリストは配列に要素を連続して格納することによってリストを構成し、ポインタを用いたリストは要素と次の要素へのポインタを用いることによってリストを構成するものとする。\nア　リストにある実際の要素数にかかわらず、リストに入れられる要素の最大個数に対応した領域を確保し、実際には使用されない領域が発生する可能性がある。\nイ　リストの中間要素を参照するには、リストの先頭から順番に要素をたどっていくことから、要素数に比例した時間が必要となる。\nウ　リストの要素を格納する領域の他に、次の要素を指し示すための領域が別途必要となる。\nエ　リストへの挿入位置が分かる場合には、リストにある実際の要素数にかかわらず、要素の挿入を一定時間で行うことができる。\n这道题目问数组实现的列表有什么特征，除了 ア 都是指针构成列表的特征，答案为选项 ア\n问题还是很明显的，选错了就是我看不懂 :cry:，题目翻译如下 (ChatGPT)：\n列表可以使用数组或指针来实现。使用数组实现列表的特点是什么？在这里，数组实现的列表是通过将元素连续地存储在数组中来构成的，而使用指针的列表是通过使用元素和指向下一个元素的指针来构成的。\nア：无论列表中实际的元素数是多少，都要为列表中可容纳的最大元素个数分配内存空间，可能会出现未使用的空间。\nイ：要访问列表中的中间元素，需要从列表的开头开始逐个元素进行遍历，因此需要的时间与元素数量成正比。\nウ：除了存储列表元素的空间外，还需要单独的空间来指向下一个元素。\nエ：如果知道插入位置，那么无论列表中实际有多少元素，都可以在固定时间内插入元素。\n","date":"2024-10-20T20:19:11+08:00","permalink":"https://blog.yexca.net/archives/184/","title":"2022 SA am1 -01-02"},{"content":"引言 日本語のタイトルを書いても、この文章は主に日本語の内容ではありません。時間があれば追加かもしれません\n题目一：本文\n题目二： https://blog.yexca.net/archives/187 题目三： https://blog.yexca.net/archives/188 最近几年总是会觉得自己在学习上没有任何的收获，尽管自己可能确实听了课程。于是我便想着尝试去做题目 (是的，学习却不做题这种可能不是特别正常的现象会让当时的我觉得很正常，应该是太懒了)，结果这一做题目，怎么说呢，做我是不会，搜怎么做我倒是有上过相关课程的印象，于是我几乎是重新学了一遍的同时解完了该题\n同时，因为没有参考答案，前三题我用 Python 可以计算出来，答案应该是正确的，但最后两题是证明题，不保证证明是对的\n题目 Source: https://www.i.u-tokyo.ac.jp/edu/entra/examarchive.shtml 题目版权属于东京大学所有，仅为了方便观看而引用，无盈利行为\n正方行列 $A,B$ を\n$$ A=\\begin{pmatrix} 1 \u0026amp; \\sqrt{2} \u0026amp; 0 \\ \\sqrt{2} \u0026amp; 1 \u0026amp; \\sqrt{2} \\ 0 \u0026amp; \\sqrt{2} \u0026amp; 1 \\end{pmatrix}, B=\\begin{pmatrix} 0 \u0026amp; -\\frac{2}{3} \u0026amp; \\frac{1}{3} \\ \\frac{2}{3} \u0026amp; 0 \u0026amp; -\\frac{2}{3} \\ -\\frac{1}{3} \u0026amp; \\frac{2}{3} \u0026amp; 0 \\end{pmatrix} $$\nとする。また、行列 $I$ は単位行列とする。実正方行列 $X$ に対して、$\\exp(X)$ を\n$$ \\exp(X)=\\sum_{k=0}^{\\infty}(\\frac{1}{k!}X^{k})=I+X+\\frac{1}{2!}X^{2}+\\frac{1}{3!}X^{3}+\\cdots $$\nと定義するとき、以下の問いに答えよ。\n（1）$A$ の全ての固有値と、それらに対応する固有ベクトルを求めよ。ただし、固有ベクトルとして、ノルムは $1$ かつ第一要素は非負実数であるものを選べ。\n（2）非負整数 $n$ に対して、$A^{n}$ を求めよ。\n（3）$\\exp(A)$ を求めよ。\n（4）$\\alpha$ を実数とするとき、$\\exp(\\alpha B)$ が次式のように表せることを示せ。\n$$ \\exp(\\alpha B) = I + (\\sin\\alpha)B + (1-\\cos(\\alpha))B^{2} $$\nただし、ケーリー・ハミルトンの定理を用いてもよい。\n（5）$3$ 次元実ベクトル $a$ が与えられたとき、$3$ 次元実ベクトル $x$ に関する関数 $f$ を\n$$ f(x) = \\sum_{k=1}^{n} \\left | \\exp(\\frac{2\\pi k}{n}B)a - x \\right |^{2} $$\nとおく。ただし、$n \\ge 2$ とする。このとき、$x=(I+B^{2})a$ において $f$ が最小になることを示せ。\n第一问 题目: 求出 $A$ 的特征值与特征向量 (特征向量的模为1且第一元素为非负)\n根据特征方程 $\\det(A-\\lambda I) = 0$ 构造矩阵并计算其行列式。特征方程为\n$$ \\det(A-\\lambda I) =\\begin{vmatrix} 1-\\lambda \u0026amp; \\sqrt{2} \u0026amp; 0 \\ \\sqrt{2} \u0026amp; 1-\\lambda \u0026amp; \\sqrt{2} \\ 0 \u0026amp; \\sqrt{2} \u0026amp; 1-\\lambda \\end{vmatrix} = 0 $$\n按第一行展开，得\n$$ (1-\\lambda)[(1-\\lambda)^{2}-2]-\\sqrt{2}[\\sqrt{2}(1-\\lambda)]=0 $$\n求解，得\n$$ \\lambda_{1}=1, \\lambda_{2}=-1, \\lambda_{3}=3 $$\n接下来求每个特征值对应的特征向量，对于 $\\lambda_{1}=1$\n$$ (A-\\lambda_{1}I) = \\begin{pmatrix} 0 \u0026amp; \\sqrt{2} \u0026amp; 0 \\ \\sqrt{2} \u0026amp; 0 \u0026amp; \\sqrt{2} \\ 0 \u0026amp; \\sqrt{2} \u0026amp; 0 \\end{pmatrix} $$\n解方程 $(A-\\lambda_{1}I)\\mathbf{v}_{1}=0$ ，得到特征向量\n$$ \\mathbf{v}_{1}=\\begin{pmatrix} 1 \\ 0 \\ -1 \\end{pmatrix} $$\n对于 $\\lambda_{2}=-1$\n$$ (A-\\lambda_{2}I)=\\begin{pmatrix} 2 \u0026amp; \\sqrt{2} \u0026amp; 0 \\ \\sqrt{2} \u0026amp; 2 \u0026amp; \\sqrt{2} \\ 0 \u0026amp; \\sqrt{2} \u0026amp; 2 \\end{pmatrix} $$\n解方程 $(A-\\lambda_{2}I)\\mathbf{v}_{2}=0$ ，得到特征向量\n$$ \\mathbf{v}_{2}=\\begin{pmatrix} 1 \\ -\\sqrt{2} \\ 1 \\end{pmatrix} $$\n对于 $\\lambda_{3}=3$\n$$ (A-\\lambda_{3}I)=\\begin{pmatrix} -2 \u0026amp; \\sqrt{2} \u0026amp; 0 \\ \\sqrt{2} \u0026amp; -2 \u0026amp; \\sqrt{2} \\ 0 \u0026amp; \\sqrt{2} \u0026amp; -2 \\end{pmatrix} $$\n解方程 $(A-\\lambda_{3}I)\\mathbf{v}_{3}=0$ ，得到特征向量\n$$ \\mathbf{v}_{3}=\\begin{pmatrix} 1 \\ \\sqrt{2} \\ 1 \\end{pmatrix} $$\n对特征值进行归一化，总结\n$$ \\begin{align*} 特征值\u0026amp;: \\lambda_{1}=1, \\lambda_{2}=-1, \\lambda_{3}=3 \\ 特征向量\u0026amp;: \\mathbf{v}{1}=\\frac{1}{\\sqrt{2}} \\begin{pmatrix} 1 \\ 0 \\ -1 \\end{pmatrix}, \\mathbf{v}{2}=\\frac{1}{2} \\begin{pmatrix} 1 \\ -\\sqrt{2} \\ 1 \\end{pmatrix}, \\mathbf{v}_{3}=\\frac{1}{2} \\begin{pmatrix} 1 \\ \\sqrt{2} \\ 1 \\end{pmatrix} \\end{align*} $$\nPython 代码 通过 sympy 验算结果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import sympy as sp # 定义矩阵 A A = sp.Matrix([[1, sp.sqrt(2), 0], [sp.sqrt(2), 1, sp.sqrt(2)], [0, sp.sqrt(2), 1]]) # 计算特征值和特征向量 eigenvals = A.eigenvals() # 特征值 eigenvects = A.eigenvects() # 特征向量 print(f\u0026#34;A 的特征值为\u0026#34;) sp.pprint(eigenvals) print(f\u0026#34;A 的特征向量为\u0026#34;) sp.pprint(eigenvects) 输出结果如下\n第二问 题目: 求 $A^{n}$ ($n$ 为非负整数)\n根据对角化理论，矩阵 $A$ 可以分解为 $A=S^{-1}DS$ 由第一问可得\n$$ S=\\begin{pmatrix} 1 \u0026amp; 1 \u0026amp; 1 \\ 0 \u0026amp; -\\sqrt[]{2} \u0026amp; \\sqrt[]{2} \\ -1 \u0026amp; 1 \u0026amp; 1\n\\end{pmatrix}, D=\\begin{pmatrix} 1 \u0026amp; 0 \u0026amp; 0 \\ 0 \u0026amp; -1 \u0026amp; 0 \\ 0 \u0026amp; 0 \u0026amp; 3 \\end{pmatrix} $$\n计算 $S$ 的逆矩阵，得\n$$ S^{-1}=\\begin{pmatrix} \\frac{1}{2} \u0026amp; 0 \u0026amp; -\\frac{1}{2} \\ \\frac{1}{4} \u0026amp; -\\frac{\\sqrt{2}}{4} \u0026amp; \\frac{1}{4} \\ \\frac{1}{4} \u0026amp; \\frac{\\sqrt{2}}{4} \u0026amp; \\frac{1}{4} \\end{pmatrix} $$\n计算 $D^{n}$ 得\n$$ D^{n}=\\begin{pmatrix} 1^{n} \u0026amp; 0 \u0026amp; 0 \\ 0 \u0026amp; (-1)^{n} \u0026amp; 0 \\ 0 \u0026amp; 0 \u0026amp; 3^{n} \\end{pmatrix} $$\n$A^{n}=S^{-1}D^{n}S$ ，解得\n$$ A^{n}=\\begin{pmatrix} \\frac{1}{2}+(-1)^{n}\\frac{1}{4}+\\frac{3^{n}}{4} \u0026amp; (-1)^{n+1}\\frac{\\sqrt{2}}{4}+\\frac{\\sqrt{2}}{4}3^{n} \u0026amp; -\\frac{1}{2}+(-1)^{n}\\frac{1}{4}+\\frac{3^{n}}{4} \\ (-1)^{n+1}\\frac{\\sqrt{2}}{4}+\\frac{\\sqrt{2}}{4}3^{n} \u0026amp; (-1)^{n}\\frac{1}{2}+\\frac{1}{2}3^{n} \u0026amp; (-1)^{n+1}\\frac{\\sqrt{2}}{4}+\\frac{\\sqrt{2}}{4}3^{n} \\ -\\frac{1}{2}+(-1)^{n}\\frac{1}{4}+\\frac{3^{n}}{4} \u0026amp; (-1)^{n+1}\\frac{\\sqrt{2}}{4}+\\frac{\\sqrt{2}}{4}3^{n} \u0026amp; \\frac{1}{2}+(-1)^{n}\\frac{1}{4}+\\frac{3^{n}}{4} \\end{pmatrix} $$\nPython 代码 通过 sympy 验算结果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 import sympy as sp # 定义 sqrt(2) sqrt_2 = sp.sqrt(2) # 定义矩阵 S 和 S^{-1} S = sp.Matrix([[1, 1, 1], [0, -sqrt_2, sqrt_2], [-1, 1, 1]]) S_inv = sp.Matrix([ [sp.Rational(1, 2), 0, -sp.Rational(1, 2)], [sp.Rational(1, 4), -sqrt_2 / 4, sp.Rational(1, 4)], [sp.Rational(1, 4), sqrt_2 / 4, sp.Rational(1, 4)] ]) # 定义对角矩阵 D lambda_1 = 1 lambda_2 = -1 lambda_3 = 3 D = sp.diag(lambda_1, lambda_2, lambda_3) # 定义 n n = sp.symbols(\u0026#39;n\u0026#39;) # 计算 D^n D_n = D**n # 计算 A^n = S D^n S^{-1} A_n = S * D_n * S_inv # 打印结果 print(f\u0026#34;A^n = S D^n S^{-1} =\u0026#34;) sp.pprint(A_n) 输出结果如下\n其他解法 第四问提到了 ケーリー・ハミルトンの定理 (哈密尔顿–凯莱定理)，此定理可以用于解矩阵的幂运算\n第一问求出特征值后，令\n$$ \\lambda^{n} = f(\\lambda)g(\\lambda) +a\\lambda^{2} +b\\lambda +c $$\n代入特征值，又因为 $f(\\lambda_{1})=f(\\lambda_{2})=f(\\lambda_{3})=0$ 可得出方程组\n$$ \\left{\\begin{matrix} 1 =a+b+c \\ (-1)^{n} =a-b+c \\ 3^{n} =9a+3b+c \\end{matrix}\\right. $$\n解方程组得\n$$ \\left{\\begin{matrix} a=\\frac{(-1)^{n}+3^{n}-2}{8} \\ b=1-\\frac{1+(-1)^{n}}{2} \\ c=\\frac{1+(-1)^{n}}{2}-\\frac{(-1)^{n}+3^{n}-2}{8} \\end{matrix}\\right. $$\n代入公式 $A^{n}=f(A)g(A)+aA^{2}+bA+cI$ ，因为 $f(A)=0$ 所以 $A^{n}=aA^{2}+bA+cI$\n$$ A^{n}=\\begin{pmatrix} \\frac{1}{2}+(-1)^{n}\\frac{1}{4}+\\frac{3^{n}}{4} \u0026amp; (-1)^{n+1}\\frac{\\sqrt{2}}{4}+\\frac{\\sqrt{2}}{4}3^{n} \u0026amp; -\\frac{1}{2}+(-1)^{n}\\frac{1}{4}+\\frac{3^{n}}{4} \\ (-1)^{n+1}\\frac{\\sqrt{2}}{4}+\\frac{\\sqrt{2}}{4}3^{n} \u0026amp; (-1)^{n}\\frac{1}{2}+\\frac{1}{2}3^{n} \u0026amp; (-1)^{n+1}\\frac{\\sqrt{2}}{4}+\\frac{\\sqrt{2}}{4}3^{n} \\ -\\frac{1}{2}+(-1)^{n}\\frac{1}{4}+\\frac{3^{n}}{4} \u0026amp; (-1)^{n+1}\\frac{\\sqrt{2}}{4}+\\frac{\\sqrt{2}}{4}3^{n} \u0026amp; \\frac{1}{2}+(-1)^{n}\\frac{1}{4}+\\frac{3^{n}}{4} \\end{pmatrix} $$\n第三问 题目: 求 $\\exp(A)$\n由第二问可知 $A$ 可以对角化，所以\n$$ \\begin{align*} \\exp(A)\u0026amp;=\\exp(SDS^{-1})\\ \u0026amp;=I+SDS^{-1}+\\frac{1}{2!}(SDS^{-1})^{2}+\\frac{1}{3!} (SDS^{-1})^{3}+\\cdots \\ \u0026amp;= I+SDS^{-1} +\\frac{1}{2!}SD^{2}S^{-1}+\\frac{1}{3!}SD^{3}S^{-1}+\\cdots \\end{align*} $$\n提取 $S$ 和 $S^{-1}$ 得\n$$ \\begin{align*} \\exp(SDS^{-1})\u0026amp;=S(I+D+\\frac{1}{2!}D^{2}+\\frac{1}{3!}D^{3}+\\cdots)S^{-1} \\ \u0026amp;=S\\exp(D)S^{-1} \\end{align*} $$\n而 $D$ 为对角矩阵，所以\n$$ \\exp(D)=\\begin{pmatrix} e \u0026amp; 0 \u0026amp; 0 \\ 0 \u0026amp; e^{-1} \u0026amp; 0 \\ 0 \u0026amp; 0 \u0026amp; e^{3} \\end{pmatrix} $$\n求 $\\exp(A)=S\\exp(D)S^{-1}$ 得\n$$ \\exp(A)=\\begin{pmatrix} \\frac{1}{2}e+\\frac{1}{4}e^{-1}+\\frac{1}{4}e^{3} \u0026amp; -\\frac{\\sqrt{2}}{4}e^{-1}+\\frac{\\sqrt{2}}{4}e^{3} \u0026amp; -\\frac{1}{2}e+\\frac{1}{4}e^{-1}+\\frac{1}{4}e^{3} \\ -\\frac{\\sqrt{2}}{4}e^{-1}+\\frac{\\sqrt{2}}{4}e^{3} \u0026amp; \\frac{1}{2}e^{-1}+\\frac{1}{2}e^{3} \u0026amp; -\\frac{\\sqrt{2}}{4}e^{-1}+\\frac{\\sqrt{2}}{4}e^{3} \\ -\\frac{1}{2}e+\\frac{1}{4}e^{-1}+\\frac{1}{4}e^{3} \u0026amp; -\\frac{\\sqrt{2}}{4}e^{-1}+\\frac{\\sqrt{2}}{4}e^{3} \u0026amp; \\frac{1}{2}e+\\frac{1}{4}e^{-1}+\\frac{1}{4}e^{3} \\end{pmatrix} $$\nPython 代码 通过 sympy 验算结果\n1 2 3 4 5 6 7 8 9 10 11 12 13 import sympy as sp # 定义矩阵 A A = sp.Matrix([[1, sp.sqrt(2), 0], [sp.sqrt(2), 1, sp.sqrt(2)], [0, sp.sqrt(2), 1]]) # 计算 exp(A) exp_A = A.exp() # 打印结果 print(\u0026#34;exp(A) =\u0026#34;) sp.pprint(exp_A) 输出结果如下\n第四问 题目: 当 $\\alpha$ 是实数的时候，证明等式。(允许使用凯莱-哈密顿定理进行证明)\n对矩阵 $B$ 求特征方程\n$$ \\det(B-\\lambda I)=\\begin{pmatrix} -\\lambda \u0026amp; -\\frac{2}{3} \u0026amp; \\frac{1}{3} \\ \\frac{2}{3} \u0026amp; -\\lambda \u0026amp; -\\frac{2}{3} \\ -\\frac{1}{3} \u0026amp; \\frac{2}{3} \u0026amp; -\\lambda \\end{pmatrix} = -\\lambda^{3}-\\lambda $$\n由凯莱-哈密顿定理知\n$$ P(B)=-B^{3}-B=0 $$\n所以\n$$ B^{3}=-B $$\n从而可以求出\n$$ \\begin{align*} B^{4}\u0026amp;=B^{3}B=-B^{2} \\ B^{5}\u0026amp;=B^{4}B=-B^{3}=B \\end{align*} $$\n代入到 $\\exp(\\alpha B)$\n$$ \\begin{align*} \\exp(\\alpha B) \u0026amp;=I+\\alpha B+\\frac{1}{2!}(\\alpha B)^{2}+\\frac{1}{3!}(\\alpha B)^{3}+\\frac{1}{4!}(\\alpha B)^{4}+\\frac{1}{5!}（\\alpha B）^{5}+\\cdots \\ \u0026amp;=I+\\alpha B+\\frac{1}{2!}\\alpha^{2}B^{2}-\\frac{1}{3!}\\alpha^{3}B-\\frac{1}{4!}\\alpha^{4}B^{2}+\\frac{1}{5!}\\alpha^{5}B+\\cdots \\ \u0026amp;=I+(\\alpha-\\frac{1}{3}\\alpha^{3}+\\frac{1}{5!}\\alpha^{5}-\\cdots)B+(\\frac{1}{2!}\\alpha^{2}-\\frac{1}{4!}\\alpha^{4}+\\cdots)B^{2} \\end{align*} $$\n观察上式 $B$ 的系数为 $\\sin(\\alpha)$ 的泰勒展开，而 $B^{2}$ 的系数为 $1-\\cos(\\alpha)$ 的泰勒展开，所以\n$$ \\exp(\\alpha B) = I + (\\sin\\alpha)B + (1-\\cos(\\alpha))B^{2} $$\n第五问 题目: 给定三维实向量 $a$ ，定义三维实向量 $x$ 的函数 $f$ 如下 (公式略)。其中 $n \\ge 2 $ ，证明当 $x=(I+B^{2})a$ 时，函数 $f$ 取最小值。\n由第四问可知 $\\exp(\\alpha B)$ ，将 $\\alpha=\\frac{2\\pi k}{n}$ 代入得\n$$ \\exp(\\frac{2\\pi k}{n}B)=I+(\\sin(\\frac{2\\pi k}{n}))B+(1-\\cos(\\frac{2\\pi k}{n}))B^{2} $$\n将 $x=(I+B^{2})a$ 代入 $f$ 得\n$$ \\begin{align*} f(x)\u0026amp;=\\sum_{k=1}^{n}\\left | [I+(\\sin(\\frac{2\\pi k}{n}))B+(1-\\cos(\\frac{2\\pi k}{n}))B^{2}]a - (I+B^{2})a \\right |^{2} \\ \u0026amp;=\\sum_{k=1}^{n}\\left | [I+(\\sin(\\frac{2\\pi k}{n}))B+(1-\\cos(\\frac{2\\pi k}{n}))B^{2}-I-B^{2}]a \\right |^{2} \\ \u0026amp;=\\sum_{k=1}^{n}\\left | [(\\sin(\\frac{2\\pi k}{n}))B-(\\cos(\\frac{2\\pi k}{n})B^{2}]a \\right |^{2} \\end{align*} $$\n因为 $f(x)$ 是欧几里得范数得平方，即距离值，所以 $f(x)\\ge0$\n又因为 $\\sin x$ 和 $\\cos x$ 周期是 $2\\pi$ ，在 $k$ 从 $1$ 到 $n$ 的过程是对其周期进行等分，又因为周期内对称数值相加和为 $0$，所以\n$$ \\sum_{k=1}^{n}(\\sin(\\frac{2\\pi k}{n}))=\\sum_{k=1}^{n}(\\cos(\\frac{2\\pi k}{n}))=0 $$\n从而当 $x=(I+B^{2})a$ 时，$f(x)=0$ ，又因为 $f(x)\\ge0$，所以原命题成立\n参考资料 MIT - 线性代数 由妈咪说制作的 LaTeX 公式编辑器 《线性代数》教学视频 宋浩老师 WikiPedia - 哈密尔顿–凯莱定理 屠龙大法：利用哈密顿\u0026ndash;凯莱定理直接斩杀矩阵的高次幂，如有砍瓜切菜一般 Wrote with ChatGPT\n","date":"2024-10-14T21:37:58+08:00","permalink":"https://blog.yexca.net/archives/183/","title":"东京大学大学院理工学 数学 2020 问题一 / 東大院理工学 数学 2020 問題一"},{"content":"引言 最近因为替换硬碟而重新装了电脑系统，当我掏出那多年未动的 U 盘时里面的软件多少有点过时，有些是已经无法在新系统上运行的，还有好多我已经使用了相同功能的替代品，以及使用了一些新的软件，遂写此文章记录装机用到的软件\n回头发现这是 24.09.16 的文章，之间有事耽误，以及状态不是特别好，直到 24.10.02 才把文章写完\n系统 因为用了较长时间的 Win11，所以还是打算继续使用 Win11，U 盘里的系统太老了，于是去 MSDN itellyou 下载了新版镜像\n但是在装的时候却发现这玩意居然必须要联网才能装了，就是设置新系统的时候必须联网登录微软账户，要是没网络的话最好使用老版本 (记得应该是可以跳过的) 或者装 Win10 (然后再升级 Win11 (doge))\n2024.10.03\n今天刷到了 俩个跳过网络验证的方法 ，没尝试记录下\n第一个是按 Ctrl+Shift+F3 可以直接跳过，同时避免创建本地用户 (下次重启将重新进行设置)\n第二个是在联网界面按 Shift+F10 然后输入 oobe\\bypassnro.cmd 之后系统会重启，重启后在网络页面会出现没有网络连接的选项\n软件相关 我的装机盘已经好久没有使用了，里面的软件有些我已经不再使用，并且也开始使用一些新的软件，部分替代了原来的功能了，所以还是有必要写一下的，说不定下次装机看这篇文章的时候我又会换一批软件了 (虽然现在我不是很喜欢麻烦的事情)\n办公软件 基础的 Office 必不可少，采用 Office Tool 进行安装方便快捷\n以下所写仅安装 Word、Excel 和 PowerPoint\n下载 Office Tool: https://otp.landian.vip/zh-cn/download.html 启动 Office Tool，运行代码安装\n1 deploy /add O365ProPlusRetail_zh-cn /O365ProPlusRetail.exclapps Access,Bing,Groove,Lync,OneDrive,OneNote,Outlook,Publisher,Teams /channel Current /dlfirst 利用 kms 激活 Office，运行代码激活\n1 2 3 ospp /inslicid MondoVolume /sethst:kms.loli.beer /setprt:1688 /act # or use kms.03k.org ospp /inslicid MondoVolume /sethst:kms.03k.org /setprt:1688 /act 参考文章\nhttps://www.coolhub.top/archives/11 https://www.coolhub.top/archives/14 下载工具与网盘 迅雷: 使用的忘了从哪找的精简版。虽然吸血，但有些东西确实还是得用迅雷下载\nBitComet: BT 下载工具，同样使用了精简版。类似的工具还有 qBittorrent, µTorrent 等\nResilio Sync : 基于 BT 技术的同步软件，方便各端文件同步\nInternet Download Manage: 即 IDM，比较好用的多线程下载工具\n115 : 用于下载一些下不动的 BT。类似的工具有 pikpak\n百度网盘 : 开了会员很好用，但没会员就是折磨。时间，加钱可及。与之类似的如阿里网盘、夸克网盘可以需要时再下载\n社交软件 暂时使用的社交软件也就那样吧\nTencent\nQQ : 最近出的 NT 版本确实还行吧 WeChat: https://www.wechat.com/ Telegram: https://desktop.telegram.org/ 解压工具 之前的电脑上倒是装了不少的解压工具，但实际上使用的也就俩个，于是这次就只装两个了\nBandizip : 应该是较为流行的吧，之前当我刚听说时学校机房都用上了\nWinRAR: 比较古老的软件，但有些 rar 只有使用此软件才能解压\n其他的:\n7zip : 最为流行的解压软件 NanaZip : 7z 的美化，并且可以在 Win11 一级右键菜单显示 其他工具 Utools : 非常便捷的工具，官网有动画介绍，通过插件拓展使得其非常方便，比如本文就是使用其 MarkDown 拓展写的虽然有些地方不如 Typora 但胜在方便\nQuickLook : 快速预览文件的工具，用起来不是太理想，希望未来可以找到替代品。非安装版需要解锁后使用: https://github.com/QL-Win/QuickLook/issues/1 1Password : 密码管理工具，可以使用开源替代 bitwarden 。我已经彻底离不开密码管理器啦\npdf 阅读器: 感觉大部分都差不多，随缘用用\nFoxit PDF Wondershare PDFelement PDF XChange sandboxie : 沙盒工具，对于不想直接运行电脑上污染环境的很好用，非安装版每次运行需要管理员权限\nTickTick : To Do List 软件，全平台同步，不过最近感觉同步不是太顺畅\nQuiteRSS : RSS 订阅管理工具，但界面较为古老，不过由于我使用喜欢了也无所谓。毕竟转移只用压缩解压，RSS 订阅也不会少\nDuplicate Cleaner Pro: 之前用的清理软件找不到了，就用八酱的这个啦。虽然有些时候不是太好用，但使用长了后还行吧\nPixPin : 截图工具\nCode Tools VS Code : 只能说装机必备了\nTypora : Markdown 可视化书写工具\nGit: https://git-scm.com/downloads/win Git 安装后需要配置名称和邮箱。同时可以更新下 Github 的 SSH 公钥了\n1 2 git config --global user.name \u0026#34;Your Name\u0026#34; git config --global user.email \u0026#34;email@example.com\u0026#34; 参考文章: https://blog.yexca.net/archives/95 JetBrains\nIntelliJ IDEA : Java 编程 GoLand : Go 编程 Dataflare : 连接数据库的工具\nDocker 我已经完全离不开 Docker 了\n下载地址: https://docs.docker.com/desktop/install/windows-install/ 单独分一个章节是因为安装时出错 WSL Update Failed\n其实就是需要去 下载最新版本的 WSL ，然后重启电脑就好了\n参考文章\nhttps://forums.docker.com/t/wsl-update-failed/140473/3 https://github.com/docker/for-win/issues/13845 https://github.com/docker/for-win/issues/13580#issuecomment-1619667316 MySQL Docker : 因为使用其存储一些数据，所以还是挺有必要使用的，但使用频率不是太高，我觉得可以直接装 Docker 里，这样换系统之类的也方便啦 (也想过装服务器上，但觉得有时候可能会没有网络连接欸\n安装\n1 docker pull mysql:5.7 运行时需要配置端口和 ROOT 密码的环境变量 MYSQL_ROOT_PASSWORD\n博客 因为我博客使用 Jekyll 框架，还需要重新安装下，希望不要出问题\n运行环境\nRuby: https://www.ruby-lang.org/en/downloads/ RubyGems: https://rubygems.org/pages/download Node.js: https://nodejs.org/zh-cn 安装 Jekyll\n1 gem install jekyll 初始化博客\n1 bundle 好吧，有几个插件我重启也装不上，同时参考了 Installation Issues on MacOSX - Gem::Ext::BuildError: ERROR: Failed to build gem native extension 等文章也无法安装\n经朋友的提醒，确实还是得用 Docker 比较好，天天整环境得烦死，明明项目都用 Docker 我博客居然还在用本地安装\n参考我 主题安装文章 安装 VS Code 插件 Dev Containers extension 用于查看容器内部文件\n打开 VS Code 按下 F1 输入 Dev Containers: Clone Repository in Container Volume... 选择后输入一个 Git 链接 (即我的 blog 的源代码)\n等待一会后 (右下角可以看日志) 选择要使用的系统、软件等配置，我选择 Debian 系统，软件我没选\n首先更新软件\n1 sudo apt-get update 参考 官方教程 安装 Jekyll\n1 2 3 sudo apt-get install ruby-full build-essential # 上方是依赖 sudo gem install jekyll bundler 安装 NodeJS\n1 sudo apt install nodejs 安装依赖\n1 sudo bundle 会提示不要用 root 权限运行，但这只是容器，随便造，无视\n尝试部署项目\n1 bundle exec jekyll s 项目成功运行，但因为是容器的端口，需要映射到本地才能看，打开直接能看，VS Code nb (doge\n感觉比 Win 编译的要快，非常 Nice\n参考文章:\nhttps://jekyllcn.com/docs/installation/ https://jekyllrb.com/docs/installation/windows/#installation-via-bash-on-windows-10 https://code.visualstudio.com/docs/devcontainers/containers#_quick-start-open-a-git-repository-or-github-pr-in-an-isolated-container-volume 结尾 暂时需要用的就这些吧，有一些貌似自己用不到了或者使用频率低就想不卡里，就酱，加纳\n","date":"2024-10-02T21:35:24+08:00","permalink":"https://blog.yexca.net/archives/182/","title":"2024 装机记录"},{"content":"文章写于 2022.11.30，因早已不使用该面板与 CuteOne，文章并无最新适配，可能无法复现\n同时当时文章并未写完，我无相关需求，仅记录\n搭建过程 两篇文章\n宝塔面板Python项目管理器安装CuteOne – OneDrive多网盘挂载程序 - 大鸟博客 (daniao.org) CuteOne搭建个人云盘最全教学！_将暮的博客-CSDN博客 第一篇我在Python项目管理器部署后一直无法成功运行，遂找到第二篇文章，非常详细\n视频一直转圈不能播放、图片不显示 你可能遇到安装之后，图片也不显示，播放视频也一直在转圈圈；\n这个问题是因为SSL引起的，假设你不是SSL的，那么你应该没这个问题；\n如果你是SSL的，那么你需要修改：\napp\\templates\\themes\\default\\public\\layout.html\n\u0026lt;!-- \u0026lt;meta http-equiv=\u0026quot;Content-Security-Policy\u0026quot; content=\u0026quot;upgrade-insecure-requests\u0026quot; /\u0026gt;--\u0026gt;\n改成\n\u0026lt;meta http-equiv=\u0026quot;Content-Security-Policy\u0026quot; content=\u0026quot;upgrade-insecure-requests\u0026quot; /\u0026gt;\n记得修改之后，在后台的顶部有一个重启按钮，你需要重启一下才会生效；\n如果生效了，你就不需要重启了；\n或者你自己手动重启一下也行；\n所有SSL的问题都可以按照此方案解决；\n后台如果也这样。\n后台的文件路径是：\napp\\templates\\admin\\public\\layout.html\n也是同一句话。\n","date":"2024-09-10T23:06:59+08:00","permalink":"https://blog.yexca.net/archives/181/","title":"宝塔面板搭建 CuteOne"},{"content":"文章写于 2022.05.09，文章并无最新适配，可能无法复现。另推荐使用较新的项目\n通过 Onedrive 可以建立网盘网站，例如我的VRChat网盘已经没了，还可以直接建立网页，或者图床\noneindex 简介 Github: https://github.com/avedu/oneindex Onedrive Directory Index，不占用服务器空间，不走服务器流量，直接列出 OneDrive 目录，文件直链下载。\n环境 需要 PHP5.6+，需打开 curl 支持，新手(比如我)建议直接使用 宝塔 直接部署，方便快捷\n另因宝塔隐私泄露风波，有一些其他版本如 宝塔纯净版 ，请自行识别安装\n安装 从 Github 将仓库下载并上传至网站根目录并解压缩\n然后访问网站，进入安装程序\n检测 首先是同意条款，如果点击同意会返回，请将地址栏中最后的 \u0026amp;mdui-dialog 删除后按回车\n如果环境正常点击下一步\n程序安装 点击获取应用ID和机密(分两个页面显示，请注意保存)，然后登陆微软账号\n保持出现的应用机密，然后点击知道了，返回快速启动\n注意：此机密仅会显示一次，请妥善保存\n然后选择一门语言，比如Python，点击Get a client ID，复制获得的Client ID\n返回安装程序界面，输入应用机密和Client ID，然后点击下一步\n点击绑定账号，选择接受即可\n如果出现错误\n请返回输入应用机密和Client ID的界面，打开 Azure 的应用注册 ，这里应该有俩应用\n找到名为 oneindex 的应用，复制它的应用程序(客户端)ID填入Client ID\n还有一个没什么用，可以直接删除\n管理 安装完成后会有管理后台和访问网站选项\n可以进入管理后台修改网站名称，主题，后台密码等 (初始密码: oneindex)\n后台网址为您的域名/?/admin\n伪静态 设置 apache 或者 nginx 的 rewrite (使用 wordpress 的配置即可)\n以上为原作者的原话(部分内容有修改)，因我使用 宝塔 ，遂说明宝塔如何配置\n在宝塔面板的网站进入设置里伪静态，选择wordpress保存即可\n在网站管理后台将伪静态勾选保存即可\n这样链接中?会去除，访问后台可直接您的域名/admin\n特殊文件实现功能 Markdown 语法可参考我写的文章： Markdown 笔记 在文件夹底部添加说明:\n在 OneDrive 的文件夹中添加README.md文件，使用 Markdown 语法。\n在文件夹头部添加说明:\n在 OneDrive 的文件夹中添加HEAD.md 文件，使用 Markdown 语法。\n加密文件夹:\n在 OneDrive 的文件夹中添加.password文件，填入密码，密码不能为空。\n直接输出网页:\n在 OneDrive 的文件夹中添加index.html 文件，程序会直接输出网页而不列目录。 配合 文件展示设置-直接输出 效果更佳。\n因为直接输出网页，可以直接搭网站\n访问其他文件正常，但访问图片出现404 这是由于服务器软件 (Nginx/Apache) 接管了图片处理，删除相关配置即可\n以下为使用宝塔\n在网站-配置文件将下述代码注释掉即可\n1 2 3 4 5 location ~ .*\\.(gif|jpg|jpeg|png|bmp|swf)$ { expires 30d; access_log on; } 改为\n1 2 3 4 5 #location ~ .*\\.(gif|jpg|jpeg|png|bmp|swf)$ #{ # expires 30d; # access_log on; #} 此问题参考 部署 OneDrive for business (PHP)客户端程序 OneIndex 详细教程 - VirCloud\u0026rsquo;s Blog - Learning\u0026amp;Sharing 命令行功能 仅能在 PHP CLI 模式下运行\n清除缓存:\n1 php one.php cache:clear 刷新缓存:\n1 php one.php cache:refresh 刷新令牌:\n1 php one.php token:refresh 上传文件:\n1 php one.php upload:file 本地文件 [OneDrive文件] 上传文件夹:\n1 php one.php upload:folder 本地文件夹 [OneDrive文件夹] 例如：\n1 2 3 4 5 6 7 8 9 10 11 //上传demo.zip 到OneDrive 根目录 php one.php upload:file demo.zip //上传demo.zip 到OneDrive /test/目录 php one.php upload:file demo.zip /test/ //上传demo.zip 到OneDrive /test/目录并将其命名为 d.zip php one.php upload:file demo.zip /test/d.zip //上传up/ 到OneDrive /test/ 目录 php one.php upload:file up/ /test/ 计划任务 [可选]推荐配置，非必需。后台定时刷新缓存，可增加前台访问的速度。\n1 2 3 4 5 # 每小时刷新一次token 0 * * * * /具体路径/php /程序具体路径/one.php token:refresh # 每十分钟后台刷新一遍缓存 */10 * * * * /具体路径/php /程序具体路径/one.php cache:refresh Docker安装运行 请参考 TimeBye/oneindex ","date":"2024-08-27T11:00:24+08:00","permalink":"https://blog.yexca.net/archives/180/","title":"基于 Onedrive 建站 (oneindex)"},{"content":"文章写于 2022.06.09，因早已不使用该面板与 OLAINDEX，文章并无最新适配，可能无法复现\n不建议使用宝塔面板\n环境要求 PHP拓展要求\nPHP \u0026gt;= 7.4 PHP OpenSSL 扩展 PHP PDO 扩展 PHP Mbstring 扩展 PHP Tokenizer 扩展 PHP XML 扩展 PHP Ctype 扩展 PHP JSON 扩展 PHP BCMath 扩展 PHP Fileinfo 扩展 最低安装标准 nginx+php\n环境安装 PHP 宝塔的软件商店搜索安装PHP7.4\n然后打开PHP7.4的设置，到禁用函数\n将这三个proc_open，proc_get_status和putenv函数从其中删除\ncomposer 宝塔官方默认composer源为阿里云无需修改，其他版本可能需要\n1 2 3 curl -sS https://getcomposer.org/installer | php mv composer.phar /usr/local/bin/composer composer config -g repo.packagist composer https://mirrors.aliyun.com/composer # 更换源为国内源，国外服务器可忽略此步骤 部署 新建一个网站，PHP版本记得选择PHP-74\n进入网站根目录，点击终端，依次输入以下命令\n1 2 3 4 5 6 7 8 git clone https://github.com/WangNingkai/OLAINDEX.git tmp mv tmp/.git . rm -rf tmp git reset --hard composer install -vvv # 这里确保已成功安装 composer ，如果报权限问题，建议给予用户完整权限。 chmod -R 777 storage chown -R www:www * # 此处 www 根据服务器具体用户组而定 composer run install-app (此为自动安装，默认sqlite存储数据) 第五步忽略fileinfo\n1 2 3 composer install -vvv 改为 composer install -vvv --ignore-platform-req=ext-fileinfo --ignore-platform-req=ext-fileinfo --ignore-platform-req=ext-fileinfo --ignore-platform-req=ext-fileinfo 安装完成后会出现管理员名称和密码\n配置 在网站，点击域名，找到网站目录，将运行目录改为/public并保存\n点击伪静态，选择laravel5并保存\n点击配置文件\n将\rlocation ~ .*\\.(gif|jpg|jpeg|png|bmp|swf)$\r{\rexpires 30d;\rerror_log /dev/null;\raccess_log /dev/null;\r}\rlocation ~ .*\\.(js|css)?$\r{\rexpires 12h;\rerror_log /dev/null;\raccess_log /dev/null; }\r改为\r#location ~ .*\\.(gif|jpg|jpeg|png|bmp|swf)$\r#{\r# expires 30d;\r# error_log /dev/null;\r# access_log /dev/null;\r#}\r#location ~ .*\\.(js|css)?$\r#{\r# expires 12h;\r# error_log /dev/null;\r# access_log /dev/null; #}\r后台 登录域名为xxx.com/admin，将xxx.com替换为您的域名\n默认账号为admin，密码为123456\n参考文章 宝塔面板安装OLAINDEX 6.0教程 - 如默星空 OLAINDEX ","date":"2024-08-23T17:14:26+08:00","permalink":"https://blog.yexca.net/archives/179/","title":"宝塔面板搭建 OLAINDEX"},{"content":"文章写于 2022.06.12，本不想发布，但见文章写的较为完整想着发出来留念吧。因早已不使用该面板与 ZFile，文章并无最新适配，可能无法复现\n不建议使用宝塔面板\n安装依赖 查看系统版本 1、cat /etc/issue，此命令也适用于所有的 Linux 发行版。\n1 2 3 [root@S-CentOS home]# cat /etc/issue CentOS release 6.5 (Final) Kernel \\r on an \\m 2、cat /etc/redhat-release，这种方法只适合 Redhat 系的 Linux：\n1 2 [root@S-CentOS home]# cat /etc/redhat-release CentOS release 6.5 (Final) 3、lsb_release -a，即可列出所有版本信息：\n1 2 3 [root@S-CentOS ~]# lsb_release -a LSB Version: :base-4.0-amd64:base-4.0-noarch:core-4.0-amd64:core-4.0-noarch:graphics-4.0-amd64:graphics-4.0-noarch:printing-4.0-amd64:printing-4.0-noarch Distributor ID: CentOS 对应系统输入相应命令 1 2 3 4 5 # CentOS系统 yum install -y java-1.8.0-openjdk unzip # Debian/Ubuntu系统 apt update apt install -y openjdk-8-jre-headless unzip 创建网站 创建站点\n进入网站目录，打开终端，输入以下指令\n1 2 3 wget https://c.jun6.net/ZFILE/zfile-release.war unzip zfile-release.war \u0026amp;\u0026amp; rm -rf zfile-release.war chmod +x ./bin/*.sh 常用指令 在网站目录下终端\n1 2 3 ./bin/start.sh # 启动项目 ./bin/stop.sh # 停止项目 ./bin/restart.sh # 重启项目 放行端口 在安全里放行 8080 端口\n输入命令启动项目后访问 IP:8080 即可看到网站\n自定义域名 如需开启 https，请先申请证书后开启反向代理\n宝塔面板网站找到反向代理\n目标URL为 http://IP:8080，发送域名为 $host\n如果部署不成功 因使用其他版本宝塔导致我部署不成功，经自己探索得知配置文件有问题，可尝试在 反向代理 处 配置文件，将以下代码替换原先代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #PROXY-START/ location ^~ / { proxy_pass http://127.0.0.1:8080; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header REMOTE-HOST $remote_addr; add_header X-Cache $upstream_cache_status; #Set Nginx Cache set $static_fileJA2B5K30 0; if ( $uri ~* \u0026#34;\\.(gif|png|jpg|css|js|woff|woff2)$\u0026#34; ) { set $static_fileJA2B5K30 1; expires 12h; } if ( $static_fileJA2B5K30 = 0 ) { add_header Cache-Control no-cache; } } #PROXY-END/ 自定义配置 配置文件目录 ./WEB-INF/classes/application.yml\n具体配置项可参考： 官方文档-参数配置 特殊文件改变(展示文件) ZFile 的展示文件默认为 readme.md，但多数建站程序的展示文件为 README.md\nZFile 的加密文件默认为 password.txt，但 oneindex 的为 .password，如果去改文件名称显然过于麻烦\n打开 application.yml (双击可在宝塔内编辑)，按 CTRL+F ，输入 readme，找到以下代码\n1 2 3 constant: readme: readme.md password: password.txt 改为\n1 2 3 constant: readme: README.md password: .password 按下 CTRL+S 保存，然后执行重启命令即可\n参考文章 宝塔面板部署 ZFile 网盘系统（原创改良版） - 柚子蜜 linux 查看系统信息命令 - konglingbin - 博客园 ","date":"2024-08-16T14:43:25+08:00","permalink":"https://blog.yexca.net/archives/178/","title":"宝塔面板搭建 ZFile"},{"content":"最近服务器快过期了，便想着把 VRC Blog 迁移到 Github 上，于是便想着看看有什么好的主题没，刚开始是想着现在用的 Typecho 主题是从 Jekyll 移植，但 半年前 去搜索找不到了，然后最近又有点想了解 Hexo，找了半天主题又想到了之前挺喜欢的 Argon 好像有 Hexo 来着，然后便有了这篇文章\n环境 需要安装 Node.js 10.13 以上版本，推荐 12.0 以上\n需要安装 Git\n安装 运行命令\n1 npm install -g hexo-cli 检测安装是否成功\n1 hexo -h 创建新博客 选择到要安装的文件夹\n1 hexo init \u0026lt;folder_name\u0026gt; 进入文件夹\n1 cd \u0026lt;folder_name\u0026gt; 安装依赖\n1 npm i 创建完成后可以修改 ./_config 进行配置\n安装主题 到 主题站 挑选一个主题，不同主题可能安装方法不同，具体参考主题文档\n以下为 Argon 主题的安装\n克隆主题 首先在 ./themes 文件夹克隆主题仓库\n1 git clone https://github.com/solstice23/hexo-theme-argon.git 重命名克隆下的文件夹为 argon\n安装 ejs 渲染器\n1 npm install hexo-renderer-ejs 在 ./_config.yml 文件将 theme 改为 argon\n配置文件 修改文件 ./themes/argon/_config.yml 以更改配置\n配置搜索 在根目录运行\n1 npm install hexo-generator-search --save 然后在 ./_config.yml 中添加选项\n1 2 3 4 search: path: search.xml field: post content: true 写作 创建新文章\n1 hexo new [layout] \u0026lt;title\u0026gt; 其中 [layout] 是一个可选属性，具体如下\nLayout 描述 路径 post 文章，默认 source/_posts page 页面 source draft 草稿 source/_drafts 创建完成后进行文章的编写\n预览\n1 hexo s 访问 localhost:4000 查看\n构造静态文件 运行命令\n1 hexo generate 运行命令后只会针对没有的进行构造，把原先删除再构造好点\n参考文章 https://hexo.io/docs/ https://github.com/solstice23/hexo-theme-argon ","date":"2024-08-09T08:49:53+08:00","permalink":"https://blog.yexca.net/archives/177/","title":"Hexo 安装与使用"},{"content":"问题描述 n-皇后问题是在 n 行 n 列的棋盘上放置 n 个皇后，使得皇后彼此之间不受攻击，其规则是任意两个皇后不在同一行、同一列和相同的对角线上 (也就算国际象棋的皇后移动范围)\n问题分析 拟采用以下思路解决 n-皇后问题：\n第 i 个皇后放在第 i 行\n从第一个皇后开始，对每个皇后，从其对应行 (第 i 个皇后对应第 i 行) 的第一列开始尝试 若可以放置，确定位置，考虑下一个皇后 若与之前的皇后冲突，则考虑下一列 若超出最后一列，则重新确定上一个皇后的位置\n重复该过程，直到找到所有的放置方案\nC 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;math.h\u0026gt; #define N 4 // 皇后个数 // 判断第 k 个皇后目前放置位置是否与前面的皇后冲突 int isplace(int pos[], int k){ int i; for(i=1; i\u0026lt;k; i++){ if(pos[i]==pos[k] || fabs(i-k) == fabs(pos[i]-pos[k])) return 0; } return 1; } int main(){ int i,j; int count = 1; int pos[N+1]; // 初始化位置 for(i=1;i\u0026lt;=N;i++) pos[i]=0; j = 1; while(j\u0026gt;=1){ pos[j]=pos[j]+1; // 尝试摆放第 i 个皇后 while(pos[j]\u0026lt;=N \u0026amp;\u0026amp; !isplace(pos,j)){ pos[j]=pos[j]+1; // 得到一个摆放方案 } if(pos[j]\u0026lt;=N \u0026amp;\u0026amp; j==N){ printf(\u0026#34;方案 %d：\u0026#34;, count++); for(i=1;i\u0026lt;=N;i++) printf(\u0026#34;%d\u0026#34;, pos[i]); printf(\u0026#34;\\n\u0026#34;); } // 考虑下一个皇后 if(pos[j]\u0026lt;=N \u0026amp;\u0026amp; j\u0026lt;N){ j+=1; }else{ // 返回考虑上一个皇后 pos[j]=0; j-=1; } } return 1; } ","date":"2024-07-28T14:26:26+08:00","permalink":"https://blog.yexca.net/archives/176/","title":"算法 n-皇后问题 (回溯法)"},{"content":"引言 之前在移植 typecho 到 Docker 容器后，在开启 HTTPS 后登录后台将会报错，而将 HTTPS 关闭后则可以正常访问。因为在之前非 Docker 部署的时候可以正常访问，我以为是 Docker 网络的问题，而当时的修改是一次性的，不会再进行更新，所以我在关闭 HTTPS 修改完成后便不再管理。如今再次使用 typecho 再次遇到相同问题，考虑到需要更新文章，遂寻解决之法\n解决方法 解决方法也非常简单，在 data/config.inc.php 文件最后添加如下代码\n1 define(\u0026#39;__TYPECHO_SECURE__\u0026#39;, true); 然后重新启动即可\n成因分析 参考资料中猜测是因为用户与浏览器之间是 HTTPS 交互，但实际上 PHP 接收到的是来自 Cloud Flare 的 HTTP 交互，所以 PHP 使用了 HTTP 进行响应从而构成了这个问题\n参考文章 Typecho HTTPS 无法登陆后台 ","date":"2024-07-26T22:22:22+08:00","permalink":"https://blog.yexca.net/archives/175/","title":"Typecho HTTPS 无法登录访问后台"},{"content":"ElementUI 是饿了么团队开发的，一套为开发者、设计师和产品经理准备的基于 Vue2.0 的桌面端组件库\n组件是组成网页的部件，例如超链接、按钮、图片、表格、表单、分页条等\nVue2.x 官网： 国际 中国大陆 Vue3.x 官网： https://element-plus.org/zh-CN/#/zh-CN ElementUI 安装 安装 ElementUI 库 (在当前工程的目录下)，命令\n1 npm install element-ui@2.15.3 引入 ElementUI 组件库\n1 2 3 4 import ElementUI from \u0026#39;element-ui\u0026#39;; import \u0026#39;element-ui/lib/theme-chalk/index.css\u0026#39;; Vue.use(ElementUI); 入门使用 创建 src/views/element/elementView.vue 组件，从官网复制代码，如\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;!-- 按钮 --\u0026gt; \u0026lt;el-row\u0026gt; \u0026lt;el-button\u0026gt;默认按钮\u0026lt;/el-button\u0026gt; \u0026lt;el-button type=\u0026#34;primary\u0026#34;\u0026gt;主要按钮\u0026lt;/el-button\u0026gt; \u0026lt;el-button type=\u0026#34;success\u0026#34;\u0026gt;成功按钮\u0026lt;/el-button\u0026gt; \u0026lt;el-button type=\u0026#34;info\u0026#34;\u0026gt;信息按钮\u0026lt;/el-button\u0026gt; \u0026lt;el-button type=\u0026#34;warning\u0026#34;\u0026gt;警告按钮\u0026lt;/el-button\u0026gt; \u0026lt;el-button type=\u0026#34;danger\u0026#34;\u0026gt;危险按钮\u0026lt;/el-button\u0026gt; \u0026lt;/el-row\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { } \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; \u0026lt;/style\u0026gt; 在 App.vue 导入组件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;template\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;element-view\u0026gt;\u0026lt;/element-view\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import elementView from \u0026#39;./views/element/elementView.vue\u0026#39; export default { components: { elementView }, } \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt;\u0026lt;/style\u0026gt; 针对其他组件亦是如此\n导入 Axios 安装\n1 npm install axios 导入\n1 import axios from \u0026#39;axios\u0026#39;; Vue 路由 Vue Router 是 Vue 的官方路由，组成：\nVueRouter：路由器类，根据路由请求在路由视图中动态渲染选中的组件 \u0026lt;router-link\u0026gt;：请求链接组件，浏览器会解析成链接标签 \u0026lt;router-view\u0026gt;：动态视图组件，用于渲染展示与路由对应的组件 Axios 安装 命令\n1 npm install vue-router@3.5.1 定义路由 在 src/router/index.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import HomeView from \u0026#39;../views/HomeView.vue\u0026#39; const routes = [ { path: \u0026#39;/\u0026#39;, name: \u0026#39;home\u0026#39;, component: HomeView // 上方导入方式 }, { path: \u0026#39;/emp\u0026#39;, name: \u0026#39;emp\u0026#39;, // 直接导入方式 component: () =\u0026gt; import(\u0026#39;../views/tlias/empView.vue\u0026#39;) }, { path: \u0026#39;/redirect\u0026#39;, // 重定向 redirect: \u0026#39;/emp\u0026#39; } ] 使用 在需要使用的地方\n1 \u0026lt;router-link to=\u0026#34;/dept\u0026#34;\u0026gt;部门管理\u0026lt;/router-link\u0026gt; 在 App.vue\n1 2 3 4 5 \u0026lt;template\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;router-view\u0026gt;\u0026lt;/router-view\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 在 main.js\n1 2 3 4 5 6 import router from \u0026#39;./router\u0026#39; new Vue({ router, // 使用路由 render: h =\u0026gt; h(App) }).$mount(\u0026#39;#app\u0026#39;) 打包部署 命令\n1 npm run build 命令执行完成后会生成 dist 目录，将该目录文件部署即可\n","date":"2024-06-03T18:04:58+08:00","permalink":"https://blog.yexca.net/archives/174/","title":"ElementUI"},{"content":"早期前后端混合开发，沟通成本高，分工不明确，不便管理，不便维护扩展\n当前主流的开发模式为前后端分离，通过接口文档\n前后端分离开发 前端根据接口文档传输参数根据响应数据解析，后端根据接口文档接收参数并响应\n开发流程：需求分析-\u0026gt;接口定义 (API 接口文档)-\u0026gt;前后端并行开发 (遵守规范)-\u0026gt;测试-\u0026gt;前后端联调测试\n在接口开发完成前可以用 YApi 进行测试\n前端工程化 指在企业级的前端项目开发中，把前端开发所需的工具、技术、流程、经验等进行规范化、标准化\n模块化：JS、CSS 组件化：UI 结构、样式、行为 规范化：目录结构、编码、接口 自动化：构建、部署、测试 Vue 脚手架 Vue-cli 是 Vue 官方提供的一个脚手架，用于快速生成一个 Vue 的项目模板，需要 NodeJS\nVue-cli 提供了如下功能：\n统一的目录结构 本地调试 热部署：修改代码后无需重新运行，就可以加载最新程序 单元测试 集成打包上线 NodeJS 官网安装，配置 npm 包位置\n1 2 3 npm config set prefix \u0026#34;path\u0026#34; # 获取位置 npm config get prefix 切换 npm 的淘宝镜像\n1 npm config set registry https://registry.npm.taobao.org 安装 Vue-cli\n1 npm install -g @vue/cli 确认是否安装成功\n1 vue --version Vue 项目 有命令行和图形化界面两种\n1 2 3 4 # 命令行 vue create project-name # 图形化界面 vue ui 目录结构 根目录：\nnode_modules：存放整个项目的依赖包 public：项目静态文件 src：项目源代码 package.json：模块基本信息，项目开发所需要模块，版本信息 vue.config.js：保存 vue 配置的文件，如代理、端口的配置等 src 文件夹目录\nassets：静态资源 components：可重用的组件 router：路由配置 views：视图组件 (页面) App.vue：入口页面 (根组件) main.js：入口 js 文件 运行项目 使用 VS Code 可以直接在底部运行\n命令行运行\n1 npm run serve 更改端口 在 vue.config.js 文件\n1 2 3 4 5 6 7 const { defineConfig } = require(\u0026#39;@vue/cli-service\u0026#39;) module.exports = defineConfig({ transpileDependencies: true, devServer: { port: 7589 // 端口号 } }) 开发流程 入口文件为 src/main.js，以下是默认\n1 2 3 4 5 6 7 8 9 10 import Vue from \u0026#39;vue\u0026#39; import App from \u0026#39;./App.vue\u0026#39; import router from \u0026#39;./router\u0026#39; Vue.config.productionTip = false new Vue({ router, render: h =\u0026gt; h(App) // 将导入的App创建虚拟元素 }).$mount(\u0026#39;#app\u0026#39;) // 挂载到#app 上述有 import 关键字代表导入组件，与之相对有 export 代表导出组件\n上述 Vue 对象代码类似\n1 2 3 4 5 6 new Vue({ el: \u0026#34;#app\u0026#34;, // router: router, router, // 当值与键相同可省略 render: h =\u0026gt; h(App) }) Vue 的组件文件以 .vue 结尾，每个组件由三个部分组成：\u0026lt;template, script, \u0026lt;style\u0026gt;\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;!-- HTML标签 --\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; // JS export default{ data(){ return{ // 数据模型 } }, methods:{ // 方法 } } \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; /* CSS */ \u0026lt;/style\u0026gt; ","date":"2024-05-28T16:22:15+08:00","permalink":"https://blog.yexca.net/archives/173/","title":"简单Vue项目"},{"content":"引言 毕业论文真是折磨呢。这是什么时候的文章呢，这个文件创建时间 2023.11.30 而修改时间 2022.09.18，我看不懂，但我大受震撼\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 \u0026lt;script\u0026gt; function secondToDate(second) { if (!second) { return 0; } var time = new Array(0, 0, 0, 0, 0); if (second \u0026gt;= 365 * 24 * 3600) { time[0] = parseInt(second / (365 * 24 * 3600)); second %= 365 * 24 * 3600; } if (second \u0026gt;= 24 * 3600) { time[1] = parseInt(second / (24 * 3600)); second %= 24 * 3600; } if (second \u0026gt;= 3600) { time[2] = parseInt(second / 3600); second %= 3600; } if (second \u0026gt;= 60) { time[3] = parseInt(second / 60); second %= 60; } if (second \u0026gt; 0) { time[4] = second; } return time; }\u0026lt;/script\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; language=\u0026#34;javascript\u0026#34;\u0026gt; function setTime() { var create_time = Math.round(new Date(Date.UTC(2021, 11, 6, 14, 15, 19)).getTime() / 1000); var timestamp = Math.round((new Date().getTime() + 8 * 60 * 60 * 1000) / 1000); currentTime = secondToDate((timestamp - create_time)); currentTimeHtml = \u0026#39;This Blog has running: \u0026lt;br/\u0026gt;\u0026#39; + currentTime[0] + \u0026#39; y \u0026#39; + currentTime[1] + \u0026#39; d \u0026#39; + currentTime[2] + \u0026#39; h \u0026#39; + currentTime[3] + \u0026#39; m \u0026#39; + currentTime[4] + \u0026#39; s\u0026#39;; document.getElementById(\u0026#34;htmer_time\u0026#34;).innerHTML = currentTimeHtml; } setInterval(setTime, 1000); \u0026lt;/script\u0026gt; 引用 在想放入的地方加入\n1 \u0026lt;span id=\u0026#34;htmer_time\u0026#34; style=\u0026#34;color: pink;\u0026#34; /\u0026gt; 参考文章 个人博客添加运行时间 - 腾讯云开发者社区-腾讯云 ","date":"2024-05-14T11:08:25+08:00","permalink":"https://blog.yexca.net/archives/172/","title":"博客运行时间"},{"content":"Gateway 是所有微服务的统一入口，有以下功能\n身份认证和权限检验：网关作为微服务入口，需要校验用户是是否有请求资格，如果没有则进行拦截 请求路由、负载均衡：一切请求都必须先经过gateway，但网关不处理业务，而是根据某种规则，把请求转发到某个微服务，这个过程叫做路由。当然路由的目标服务有多个时，还需要做负载均衡 请求限流：当请求流量过高时，在网关中按照下流的微服务能够接受的速度来放行请求，避免服务压力过大 SpringCloud 的网关实现有两种\nZuul：基于 Servlet 实现，属于阻塞式编程 SpringCloudGateway：基于 Spring5 中提供的 WebFlux，属于响应式编程的实现，具备更好的性能 简单入门 创建项目，引入依赖\n1 2 3 4 5 6 7 8 9 10 \u0026lt;!--网关--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-gateway\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--nacos服务发现依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-alibaba-nacos-discovery\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 编写基础配置和路由规则\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 server: port: 10010 # 网关端口 spring: application: name: gateway # 服务名称 cloud: nacos: server-addr: localhost:8848 # nacos地址 gateway: routes: # 网关路由配置 - id: user-service # 路由id，自定义，只要唯一即可 # uri: http://127.0.0.1:8081 # 路由的目标地址 http就是固定地址 uri: lb://userService # 路由的目标地址 lb就是负载均衡，后面跟服务名称 predicates: # 路由断言，也就是判断请求是否符合路由规则的条件 - Path=/user/** # 这个是按照路径匹配，只要以/user/开头就符合要求 然后访问 localhost:10010/user/1 测试\n路由配置包括：\n路由id：路由的唯一标示\n路由目标（uri）：路由的目标地址，http代表固定地址，lb代表根据服务名负载均衡\n路由断言（predicates）：判断路由的规则，符合则转发到路由目的地\n路由过滤器（filters）：对请求或响应做处理\n断言工厂 在配置文件中写的断言规则只是字符串，这些字符串会被 Predicate Factory 读取并处理，转变为路由判断的条件\n例如上例 Path=/user/** 是按路径匹配，这个规则是由 org.springframework.cloud.gateway.handler.predicate.PathRoutePredicateFactory 类来处理的，类似的断言工厂有：\n名称 说明 示例 After 是某个时间点后的请求 - After=2037-01-20T17:42:47.789-07:00[America/Denver] Before 是某个时间点之前的请求 - Before=2031-04-13T15:14:47.433+08:00[Asia/Shanghai] Between 是某两个时间点之前的请求 - Between=2037-01-20T17:42:47.789-07:00[America/Denver], 2037-01-21T17:42:47.789-07:00[America/Denver] Cookie 请求必须包含某些cookie - Cookie=chocolate, ch.p Header 请求必须包含某些header - Header=X-Request-Id, \\d+ Host 请求必须是访问某个host（域名） - Host=.somehost.org,.anotherhost.org Method 请求方式必须是指定方式 - Method=GET,POST Path 请求路径必须符合指定规则 - Path=/red/{segment},/blue/** Query 请求参数必须包含指定参数 - Query=name, Jack或者- Query=name RemoteAddr 请求者的ip必须是指定范围 - RemoteAddr=192.168.1.1/24 Weight 权重处理 过滤器工厂 GatewayFilter 是网关中提供的一种过滤器，可以对进入网关的请求和微服务返回的响应做处理\nSpring 提供了 31 种不同的路由过滤器工厂，例如：\n名称 说明 AddRequestHeader 给当前请求添加一个请求头 RemoveRequestHeader 移除请求中的一个请求头 AddResponseHeader 给响应结果中添加一个响应头 RemoveResponseHeader 从响应结果中移除有一个响应头 RequestRateLimiter 限制请求的流量 更多参考： https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway/gatewayfilter-factories.html 请求头过滤器 以请求头过滤器为例，给所有进入 userService 的请求添加一个请求头：Hello=World\n在 gateway 中修改 application.yml，添加路由过滤\n1 2 3 4 5 6 7 8 9 10 spring: cloud: gateway: routes: - id: user-service uri: lb://userservice predicates: - Path=/user/** filters: # 过滤器 - AddRequestHeader=Hello, World # 添加请求头 然后可以修改 Controller 测试\n1 2 3 4 5 @GetMapping(\u0026#34;/{id}\u0026#34;) public User queryById(@PathVariable(\u0026#34;id\u0026#34;) Long id, @RequestHeader(\u0026#34;Hello\u0026#34;) String hello) { System.out.println(hello); return userService.queryById(id); } 默认过滤器 如果要对所有的路由都生效，则可以将过滤器工厂写到default下\n1 2 3 4 5 6 7 8 9 10 spring: cloud: gateway: routes: - id: user-service uri: lb://userservice predicates: - Path=/user/** default-filters: # 默认过滤项 - AddRequestHeader=Hello, World 全局过滤器 网关提供了 31 种过滤器，但每一种过滤器的作用都是固定的。如果我们希望拦截请求，做自己的业务逻辑则没办法实现\n而全局过滤器的作用也是处理一切进入网关的请求和微服务响应，与 GatewayFilter 的作用一样。区别在于 GatewayFilter 通过配置定义，处理逻辑是固定的；而 GlobalFilter 的逻辑需要自己写代码实现，定义方式是实现GlobalFilter接口\n1 2 3 4 5 6 7 8 9 10 public interface GlobalFilter { /** * 处理当前请求，有必要的话通过{@link GatewayFilterChain}将请求交给下一个过滤器处理 * * @param exchange 请求上下文，里面可以获取Request、Response等信息 * @param chain 用来把请求委托给下一个过滤器 * @return {@code Mono\u0026lt;Void\u0026gt;} 返回标示当前过滤器业务结束 */ Mono\u0026lt;Void\u0026gt; filter(ServerWebExchange exchange, GatewayFilterChain chain); } 在filter中编写自定义逻辑，可以实现下列功能：\n登录状态判断 权限校验 请求限流等 简单使用 目标：定义全局过滤器，拦截请求，判断请求的参数是否满足下面条件：\n参数中是否有authorization，\nauthorization参数值是否为admin\n如果同时满足则放行，否则拦截\n首先在 gateway 中定义一个过滤器：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 @Order(-1) // 优先处理 @Component public class AuthorizeFilter implements GlobalFilter { @Override public Mono\u0026lt;Void\u0026gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) { // 获取请求参数 MultiValueMap\u0026lt;String, String\u0026gt; params = exchange.getRequest().getQueryParams(); // 获取AuthorizeFilter参数，此处约定第一个为认证参数 String authorize = params.getFirst(\u0026#34;AuthorizeFilter\u0026#34;); // 检验 if(\u0026#34;admin\u0026#34;.equals(authorize)){ // 放行 return chain.filter(exchange); } // 拦截，禁止访问 exchange.getResponse().setStatusCode(HttpStatus.FORBIDDEN); // 结束处理 return exchange.getResponse().setComplete(); } } 过滤器执行顺序 请求进入网关会碰到三类过滤器：当前路由的过滤器、DefaultFilter、GlobalFilter\n请求路由后，会将当前路由过滤器和 DefaultFilter、GlobalFilter，合并到一个过滤器链（集合）中，排序后依次执行每个过滤器\n每个过滤器都有 int 类型的 order 值，order 值越小，优先级越高，执行顺序越靠前\n路由过滤器和 defaultFilter 的 order 值由 Spring 指定，默认从 1 开始递增\nGlobalFilter 通过实现 Ordered 接口，或者添加 @Order 注解来指定 order 值，由我们自己指定\n当过滤器的order值一样时，会按照 defaultFilter \u0026gt; 路由过滤器 \u0026gt; GlobalFilter的顺序执行\n其中通过实现接口指定 order 值：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 //@Order(-1) // 优先处理 @Component public class AuthorizeFilter implements GlobalFilter, Ordered { @Override public Mono\u0026lt;Void\u0026gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) { // 获取请求参数 MultiValueMap\u0026lt;String, String\u0026gt; params = exchange.getRequest().getQueryParams(); // 获取AuthorizeFilter参数，此处约定第一个为认证参数 String authorize = params.getFirst(\u0026#34;AuthorizeFilter\u0026#34;); // 检验 if(\u0026#34;admin\u0026#34;.equals(authorize)){ // 放行 return chain.filter(exchange); } // 拦截，禁止访问 exchange.getResponse().setStatusCode(HttpStatus.FORBIDDEN); // 结束处理 return exchange.getResponse().setComplete(); } @Override public int getOrder() { return -1; } } 跨域问题 同域为协议相同、 IP 或域名相同、端口相同\n跨域问题：浏览器禁止请求的发起者与服务端发生跨域 ajax 请求，请求被浏览器拦截的问题，解决方案便是 CORS\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 spring: cloud: gateway: globalcors: # 全局的跨域处理 add-to-simple-url-handler-mapping: true # 解决options请求被拦截问题 corsConfigurations: \u0026#39;[/**]\u0026#39;: allowedOrigins: # 允许哪些网站的跨域请求 - \u0026#34;http://localhost:8090\u0026#34; allowedMethods: # 允许的跨域ajax的请求方式 - \u0026#34;GET\u0026#34; - \u0026#34;POST\u0026#34; - \u0026#34;DELETE\u0026#34; - \u0026#34;PUT\u0026#34; - \u0026#34;OPTIONS\u0026#34; allowedHeaders: \u0026#34;*\u0026#34; # 允许在请求中携带的头信息 allowCredentials: true # 是否允许携带cookie maxAge: 360000 # 这次跨域检测的有效期 ","date":"2024-05-05T00:54:52+08:00","permalink":"https://blog.yexca.net/archives/171/","title":"Gateway 服务网关"},{"content":"Feign是一个声明式的 Http 客户端，Github： https://github.com/OpenFeign/feign 简单使用 引入依赖\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-openfeign\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 在启动类添加注解开启 Feign 的功能\n1 2 @EnableFeignClients @SpringBootApplication 编写 Feign 客户端\n1 2 3 4 5 @FeignClient(\u0026#34;userService\u0026#34;) public interface UserClient { @GetMapping(\u0026#34;/user/{id}\u0026#34;) User findById(@PathVariable(\u0026#34;id\u0026#34;) Long id); } 替换 RestTemplate\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 @Service public class OrderService { @Autowired private OrderMapper orderMapper; // @Autowired // private RestTemplate restTemplate; @Autowired private UserClient userClient; public Order queryOrderById(Long orderId) { // 1.查询订单 Order order = orderMapper.findById(orderId); // 2.查询用户 // String url = \u0026#34;http://localhost:8081/user/\u0026#34; + order.getUserId(); // String url = \u0026#34;http://userService/user/\u0026#34; + order.getUserId(); // User user = restTemplate.getForObject(url, User.class); // Feign User user = userClient.findById(order.getUserId()); // 3.封装用户信息 order.setUser(user); // 4.返回 return order; } } 自定义配置 Feign运行自定义配置来覆盖默认配置，可以修改的配置如下：\n类型 作用 说明 feign.Logger.Level 修改日志级别 包含四种不同的级别：NONE、BASIC、HEADERS、FULL feign.codec.Decoder 响应结果的解析器 http远程调用的结果做解析，例如解析json字符串为java对象 feign.codec.Encoder 请求参数编码 将请求参数编码，便于通过http请求发送 feign. Contract 支持的注解格式 默认是SpringMVC的注解 feign. Retryer 失败重试机制 请求失败的重试机制，默认是没有，不过会使用Ribbon的重试 一般只需要配置日志级别，日志的级别：\nNONE：不记录任何日志信息，这是默认值 BASIC：仅记录请求的方法，URL以及响应状态码和执行时间 HEADERS：在BASIC的基础上，额外记录了请求和响应的头信息 FULL：记录所有请求和响应的明细，包括头信息、请求体、元数据 配置方式有两种，一为配置文件，或者创建 bean\n配置文件 配置文件针对单个服务\n1 2 3 4 5 feign: client: config: userservice: # 针对某个微服务的配置 loggerLevel: FULL # 日志级别 针对所有服务\n1 2 3 4 5 feign: client: config: default: # 这里用default就是全局配置，如果是写服务名称，则是针对某个微服务的配置 loggerLevel: FULL # 日志级别 bean 先声明一个类，然后声明一个 Logger.Level 的对象\n1 2 3 4 5 6 public class DefaultFeignConfiguration { @Bean public Logger.Level feignLogLevel(){ return Logger.Level.BASIC; // 日志级别为BASIC } } 如果要全局生效，放在启动类的 @EnableFeignClients 注解中\n1 @EnableFeignClients(defaultConfiguration = DefaultFeignConfiguration .class) 如果是局部生效，放在 @FeignClient 注解中\n1 @FeignClient(value = \u0026#34;userService\u0026#34;, configuration = DefaultFeignConfiguration .class) Feign 使用优化 Feign 底层客户端实现：\nURLConnection：默认实现，不支持连接池\nApache HttpClient ：支持连接池\nOKHttp：支持连接池\n使用连接池可以提高 Feign 的性能\n下例为替换为 HttpClient\n引入依赖 1 2 3 4 5 \u0026lt;!--httpClient的依赖 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.github.openfeign\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;feign-httpclient\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 配置连接池 1 2 3 4 5 6 7 8 9 feign: client: config: default: # default全局的配置 loggerLevel: BASIC # 日志级别，BASIC就是基本的请求和响应信息 httpclient: enabled: true # 开启feign对HttpClient的支持 max-connections: 200 # 最大的连接数 max-connections-per-route: 50 # 每个路径的最大连接数 最佳实践 所谓最近实践，就是使用过程中总结的经验，最好的一种使用方式\nFeign 的客户端与服务提供者的 controller 代码非常相似\n1 2 3 4 5 6 7 8 9 10 11 12 // Feign 客户端 @FeignClient(\u0026#34;userService\u0026#34;) public interface UserClient { @GetMapping(\u0026#34;/user/{id}\u0026#34;) User findById(@PathVariable(\u0026#34;id\u0026#34;) Long id); } // Controller @GetMapping(\u0026#34;/user/{id}\u0026#34;) public User queryById(@PathVariable(\u0026#34;id\u0026#34;) Long id) { return userService.queryById(id); } 对于重复的代码，有两种简化方法\n方式一：继承 给消费者的 FeignClient 和提供者的 controller 定义统一的父接口作为标准\n定义一个接口\n1 2 3 4 public interface UserAPI{ @GetMapping(\u0026#34;/user/{id}\u0026#34;) User findById(@PathVariable(\u0026#34;id\u0026#34;) Long id); } Feign 客户端实现\n1 2 @FeignClient(value=\u0026#34;userService\u0026#34;) public interface UserClient extends UserAPI{} Controller 类\n1 2 3 4 5 6 @RestController public class UserController implements UserAPI{ public User findById(@PathVariable(\u0026#34;id\u0026#34;) Long id){ // code } } 优点：简单，实现了代码共享\n缺点：\n服务提供方、消费方紧耦合 参数列表中的注解映射并不会继承，因此Controller中必须再次声明方法、参数列表、注解 方式二：抽取方式 将 FeignClient 抽取为独立模块，并且把接口有关的 POJO、默认的 Feign 配置都放到这个模块中，提供给所有消费者使用\n创建一个新项目，引入 Feign 起步依赖\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-openfeign\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 在消费者处引入 feign-api 的依赖\n当定义的 FeignClient 不在 SpringBootApplication 的扫描包范围时，这些 FeignClient 无法使用，有两种方式解决\n指定 Feign 应该扫描的包 1 @EnableFeignClients(basePackages = \u0026#34;net.yexca.feign.clients\u0026#34;) 指定要加载的 Client 接口 1 @EnableFeignClients(clients = {UserClient.class}) ","date":"2024-05-03T23:11:52+08:00","permalink":"https://blog.yexca.net/archives/170/","title":"Feign 远程调用"},{"content":"需先安装软件，官网： https://nacos.io/zh-cn/ 在 conf/application.properties 文件中可以更改端口，默认为 8848\n注册服务 父工程中添加管理依赖\n1 2 3 4 5 6 7 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-alibaba-dependencies\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.6.RELEASE\u0026lt;/version\u0026gt; \u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt; \u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; 注释掉 Eureka 的依赖，并添加 Nacos 客户端的依赖\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-alibaba-nacos-discovery\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 修改 application.yml，添加 Nacos 地址，注释 Eureka 地址\n1 2 3 4 spring: cloud: nacos: server-addr: localhost:8848 启动 Nacos\n1 2 startup.cmd -m standalone # 参数为单机启动 访问 http://localhost:8848/nacos/ 登录账号密码都为 nacos\n分级存储模型 服务分为多个集群，每个集群有多个实例，集群可以按地区分配，提供访问速度\n相对的，Eureka 只有 服务-实例，无集群\n服务调用尽可能选择本地集群的服务，跨集群调用延迟较高。本地集群不可访问时，再去访问其它集群\n可以通过 application.yml 设置集群\n1 2 3 4 5 6 spring: cloud: nacos: server-addr: localhost:8848 discovery: cluster-name: Shanghai # 集群名称 然后设置 Ribbon 的策略为 Nacos 的\n1 2 3 4 5 # 给某个微服务配置负载均衡规则，这里是userService服务 userService: ribbon: NFLoadBalancerRuleClassName: com.alibaba.cloud.nacos.ribbon.NacosRule # NFLoadBalancerRuleClassName: com.netflix.loadbalancer.Nac # 负载均衡规则 然后可以在 Nacos 设置实例的权重 (0-1)，权重越大，访问频率越高\n环境隔离 Nacos 中服务存储和数据存储的最外层都是一个名为 namespace 的东西，用来做最外层隔离\n可以在 Nacos 中新建一个命名空间，如 dev，然后修改 application.yml\n1 2 3 4 5 6 7 spring: cloud: nacos: server-addr: localhost:8848 discovery: cluster-name: Shanghai # 集群名称 namespace: UUID # 此处为命名空间的UUID 不同 namespace 下的服务互相不可见，无法访问\n临时实例与非临时实例 对于临时实例，Nacos 的处理方法和 Eukera 一致\n对于非临时实例，Nacos 会主动询问是否存活，服务不可用不会删除，在服务不可用时，Nacos 会主动通知 消费者\n设置非临时实例\n1 2 3 4 5 spring: cloud: nacos: discovery: ephemeral: false # 设置为非临时实例 Nacos 配置管理 当微服务部署的实例变多，逐个更改配置非常麻烦，可以使用 Nacos 将配置集中管理，并且可以热更新\n简单使用 在 Nacos 控制台的配置管理，新建配置，其中 Data ID 为配置文件的 id，格式为 [服务名称]-[profile].[后缀名]，例如 userService-dev.yaml\n然后在配置内容书写配置即可，例如\n1 2 pattern: dateformat: yyyy-MM-dd HH:mm:ss 引入 Nacos 的配置管理客户端依赖\n1 2 3 4 5 \u0026lt;!--nacos配置管理依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-alibaba-nacos-config\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 配置获取的步骤\n项目启动 -\u0026gt; bootstrap.yml -\u0026gt; Nacos 配置文件 -\u0026gt; 本地 application.yml -\u0026gt; 创建 Spring 容器 -\u0026gt; 加载 bean\n添加 bootstrap.yml\n1 2 3 4 5 6 7 8 9 10 spring: application: name: userService # 服务名称 profiles: active: dev # 开发环境，这里是dev cloud: nacos: server-addr: localhost:8848 # Nacos地址 config: file-extension: yaml # 文件后缀名 测试\n1 2 3 4 5 6 7 8 9 10 11 12 @RestController @RequestMapping(\u0026#34;/user\u0026#34;) public class UserController{ @Value(\u0026#34;${pattern.dateformat}\u0026#34;) private String dateformat; @GetMapping(\u0026#34;/now\u0026#34;) public String now(){ return LocalDateTime.now().format(DateTimeFormatter.ofPattern(dateformat)) } } 访问页面查看效果\n热更新 可以通过两种方式实现\n方式一：在 @Value 注入的变量所在类上添加注解 @RefreshScope\n1 2 3 4 5 6 7 8 9 10 11 12 13 @RefreshScope // 配置自动刷新 @RestController @RequestMapping(\u0026#34;/user\u0026#34;) public class UserController{ @Value(\u0026#34;${pattern.dateformat}\u0026#34;) private String dateformat; @GetMapping(\u0026#34;/now\u0026#34;) public String now(){ return LocalDateTime.now().format(DateTimeFormatter.ofPattern(dateformat)) } } 方式二：使用 @ConfigurationProperties\n新建配置类\n1 2 3 4 5 6 @Component @Data @ConfigurationProperties(prefix = \u0026#34;pattern\u0026#34;) public class PatternProperties { private String dateformat; } Controller 类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // @RefreshScope // 配置自动刷新 @RestController @RequestMapping(\u0026#34;/user\u0026#34;) public class UserController{ // @Value(\u0026#34;${pattern.dateformat}\u0026#34;) // private String dateformat; @Autowired private PatternProperties properties; @GetMapping(\u0026#34;/now\u0026#34;) public String now(){ return LocalDateTime.now().format(DateTimeFormatter.ofPattern(properties.getDateformat())) } } 配置共享 微服务启动时，会从 Nacos 读取多个配置文件\n[spring.application.name]-[spring.profiles.active].yaml，例如：userService-dev.yaml\n[spring.application.name].yaml，例如：userService.yaml\n而 第二个 [spring.application.name].yaml 不包含环境，可以被多个环境共享\n配置优先级：[spring.application.name]-[spring.profiles.active].yaml \u0026gt; [spring.application.name].yaml \u0026gt; 本地配置\n","date":"2024-05-02T22:36:17+08:00","permalink":"https://blog.yexca.net/archives/169/","title":"Nacos 注册中心"},{"content":"消费者发起请求会被 Ribbon 拦截，Ribbon 从 Eureka 拉取提供者列表，Eureka 返回提供者列表，Ribbon 根据 IRule 选择服务器发起请求\n详细拦截：请求-\u0026gt;DynamicServerListLoadBalancer (获取url中的服务id,userService)-\u0026gt;DynamicServerListLoadBalancer-\u0026gt;Eureka-\u0026gt;DynamicServerListLoadBalancer-\u0026gt;IRule-\u0026gt;DynamicServerListLoadBalancer -\u0026gt;发起请求\n负载均衡策略 内置负载均衡规则类 规则描述 ZoneAvoidanceRule(Eureka 默认) 以区域可用的服务器为基础进行服务器的选择。使用 Zone 对服务器进行分类，这个 Zone 可以理解为一个机房、一个机架等。而后再对 Zone 内的多个服务做轮询 RoundRobinRule 简单轮询服务列表来选择服务器。它是 Ribbon 默认的负载均衡规则 AvailabilityFilteringRule 对以下两种服务器进行忽略： （1）在默认情况下，这台服务器如果3次连接失败，这台服务器就会被设置为“短路”状态。短路状态将持续30秒，如果再次连接失败，短路的持续时间就会几何级地增加（2）并发数过高的服务器。如果一个服务器的并发连接数过高，配置了 AvailabilityFilteringRule 规则的客户端也会将其忽略。并发连接数的上限，可以由客户端的 \u0026lt;clientName\u0026gt;.\u0026lt;clientConfigNameSpace\u0026gt;.ActiveConnectionsLimit 属性进行配置 WeightedResponseTimeRule 为每一个服务器赋予一个权重值。服务器响应时间越长，这个服务器的权重就越小。这个规则会随机选择服务器，这个权重值会影响服务器的选择 BestAvailableRule 忽略那些短路的服务器，并选择并发数较低的服务器 RandomRule 随机选择一个可用的服务器 RetryRule 重试机制的选择逻辑 使用随机策略 通过定义 IRule 实现可以修改负载均衡规则，有两种方式：\n代码方式：在配置类中，定义一个新的 IRule (全局设定) 1 2 3 4 @Bean public IRule randomRule(){ return new RandomRule(); } 配置文件方式：在 orderServer application.yml 文件中，添加新的配置以修改规则 1 2 3 userService: # 给某个微服务配置负载均衡规则，这里是userservice服务 ribbon: NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule # 负载均衡规则 懒加载 Ribbon 默认是采用懒加载，即第一次访问时才会去创建 LoadBalanceClient，请求时间会很长，而饥饿加载则会在项目启动时创建，降低第一次访问的耗时，配置开启饥饿加载：\n1 2 3 4 ribbon: eager-load: enabled: true clients: userService # 指定对 userService 这个服务饥饿加载 ","date":"2024-04-28T15:50:15+08:00","permalink":"https://blog.yexca.net/archives/168/","title":"Ribbon 负载均衡"},{"content":"显示模式 显示模式即标签的显示方式，用于布局网页的时候，根据标签的显示模式选择合适的标签摆放内容\n块级元素 (例如 div) 独占一行 宽度默认是父级的 100% 添加宽高属性生效 行内元素 (例如 span) 一行可以显示多个 设置宽高属性不生效 宽高尺寸由内容撑开 行内块元素 (例如 img) 一行可以显示多个 设置宽高属性生效 宽高尺寸也可以由内容撑开 可以通过 CSS 属性 display 转换显示模式，取值为：\n效果 块级 行内 行内块 属性值 block inline inline-block 盒子模型 作用：布局网页，摆放盒子和内容\n盒子模型组成部分：\n内容区域：width \u0026amp; height 内边距：padding (出现在内容与盒子边缘之间) 边框线：border 外边距：margin (出现在盒子外面) 边框线 属性值：边框线粗细 线条样式 颜色 不区分顺序\n常见线条样式有：\n线条样式 实线 虚线 点线 属性值 solid dashed dotted 1 2 3 div { border: 1px solid aqua; } 当然，还有可以设置单独方向的属性，属性值同上\n1 2 3 4 5 6 div { border-top: 1px solid red; border-left: 1px dashed red; border-bottom: 1px dotted red; border-right: 1px solid blue; } 内边距 设置内容与盒子边缘之间的距离\n1 2 3 4 5 6 7 8 9 10 11 12 /* 四个方向内边距相同 */ div { padding: 10px; } /* 分别设置四个方向 */ div { padding-top: 10px; padding-right: 20px; padding-bottom: 5px; padding-left: 10px; } padding 也有多值写法，可以通过一个属性控制四个内边距\n取值个数 示例 含义 一个 padding: 10px; 四个方向均为 10px 四个 padding: 10px 20px 30px 40px; 上 右 下 左 (顺时针) 两个 padding: 10px 30px 20px; 上 左右 下 三个 padding: 10px 20px; 上下 左右 尺寸内减模式 默认情况下 盒子尺寸=内容尺寸+内边距尺寸+边框尺寸，也就是说当给盒子加上 padding 和 border 属性后，盒子会变大\n1 2 3 4 5 6 div { height: 200px; width: 200px; /* 此盒子尺寸会变为 240*240 */ padding: 20px; } 如果想要盒子大小为 200*200，需要手动计算并将 heigh 和 width 值调为 160px\n而加上 box-sizing: border-box 后，盒子的大小将恒保持为 heigh 和 width 值\n1 2 3 4 5 6 7 div { height: 200px; width: 200px; /* 此盒子尺寸为 200*200 */ padding: 20px; box-sizing: border-box; } 外边距 作用：拉开两个盒子之间的距离。属性值与 padding 写法相同\n外边距不会使盒子变大\n如果将 margin 的左右属性值设置为 auto 将会使该盒子水平居中\n1 2 3 4 5 6 div { height: 200px; width: 800px; /* 此盒子将水平居中 */ margin: 0 auto; } 合并现象 垂直排列的同级元素，上下 margin 会合并，取值为较大的 margin\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;style\u0026gt; .box1 { width: 200px; height: 100px; background-color: aqua; margin-bottom: 10px; } /* 俩盒子之间间隔 20px */ .box2 { width: 100px; height: 100px; background-color: aquamarine; margin-top: 20px; } \u0026lt;/style\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;box1\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box2\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; 塌陷问题 父子级标签，子级添加上外边距将产生塌陷。会导致父级一起向下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;style\u0026gt; .father{ width: 300px; height: 300px; background-color: pink; } .son{ width: 100px; height: 100px; background-color: aqua; /* 俩盒子将一起向下塌陷 50px */ margin-top: 50px; } \u0026lt;/style\u0026gt; \u0026lt;div class=\u0026#34;father\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;son\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 解决方法：\n取消子级 margin，父级使用 padding 父级设置 overflow: hidden 父级设置 border-top 元素溢出 当盒子内容超过盒子大小是将产生溢出，可以用 overflow 属性控制溢出元素的内容的显示方式\n属性值 效果 hidden 溢出隐藏 scroll 溢出滚动 (无论是否溢出，都显示滚动条) auto 溢出滚动 (溢出才显示滚动条) 行内元素垂直位置 行内元素 (如 span) 添加 margin 和 padding 无法改变垂直位置，此时可以通过行高改变\n1 2 3 4 5 6 span { margin: 50px; padding: 20px; line-height: 100px; } 圆角效果 使用属性 border-radius 设置元素的外边框为圆角，属性值为圆角半径，可以使用数字+px 或百分比，多值与 padding 类似\n取值个数 含义 一个 四个角均为设定值 四个 左上 右上 右下 左下 (顺时针) 三个 左上 右上+左下 右下 两个 左上+右下 右上+左下 正圆形状 给正方形盒子设置圆角属性值为宽高的一半或 50%\n1 2 3 4 5 6 7 8 div { width: 100px; height: 100px; background-color: aqua; border-radius: 50%; /* 或者 border-radius: 50px */ } 胶囊形状 给长方形盒子设置圆角属性值为盒子高度的一半\n1 2 3 4 5 6 7 div { width: 100px; height: 50px; background-color: aqua; border-radius: 25px; } 阴影效果 使用 box-shadow 设置，属性值：x y 模糊半径 扩散半径 颜色 内外阴影\n其中 x 与 y 是必填，默认为外阴影，若设置内阴影属性值为 inset\n","date":"2024-04-13T22:06:58+08:00","permalink":"https://blog.yexca.net/archives/167/","title":"CSS 盒子模型"},{"content":"背景属性有以下这些\n描述 属性 背景色 background-color 背景图 background-image 背景图平铺方式 background-repeat 背景图位置 background-position 背景图缩放 background-size 背景图固定 background-attachment 背景图复合属性 background 背景图 网页中使用背景图实现装饰性的图片效果\n1 2 3 4 5 6 div { width: 500px; height: 300px; background-image: url(./img/00.jpg); } 背景图平铺方式 background-repeat 有四个值\n效果 不平铺 平铺 (默认) 水平方向平铺 垂直方向平铺 属性值 no-repeat repeat repeat-x repeat-y 背景图位置 background-position 的值为 水平方向位置 垂直方向位置 其中位置的值有关键字和坐标\n关键字有 left、right、center、top、bottom\n坐标使用 数字+px，正负皆可\n1 2 3 4 5 div { background-position: center top; /* 也可以数字和单词混用 */ /* background-position: -50px center; */ } 可以只写一个关键字，另一个方向为居中；数字只写一个为水平方向，垂直居中\n背景图缩放 background-size 常用三种属性值\n关键字 cover：等比例缩放背景图片以完全覆盖背景区，可能图片部分看不见 contain：等比例缩放背景图片以完全装入背景区，可能部分空白 百分比：根据盒子尺寸计算图片大小 数字+单位 (如 px) 百分比为 100% 时图片宽度和盒子宽度一致，高度等比例缩放\n背景图固定 background-attachment 使背景不会随着元素的内容滚动，属性值为 fixed\n背景图复合属性 background 属性值为 背景色 背景图 背景图平铺方式 背景图位置/背景图缩放 背景图固定 不区分顺序\n1 2 3 4 5 6 div { width: 500px; height: 500px; background: aqua url(./img/01.jpg) no-repeat center/cover; } ","date":"2024-04-10T16:21:51+08:00","permalink":"https://blog.yexca.net/archives/166/","title":"CSS 背景属性"},{"content":"文字控制属性可控制的内容如下\n名称 属性 字体大小 font-size 字体粗细 font-weight 字体倾斜 font-style 行高 line-height 字体族 font-family 字体复合属性 font 文本缩进 text-indent 文本对齐 text-align 修饰线 text-decoration 颜色 color 字体大小 属性值为文字尺寸，单位一般为 px\n1 2 3 p { font-size: 30px; } 字体粗细 属性值有数字或关键字\n1 2 3 4 5 6 7 8 p { font-weight: 400; /* 文字设为正常 */ /* font-weight: normal; */ } div { font-weight: 700; /* 文字设为加粗 */ /* font-weight: bold; */ } 字体倾斜 一般用作清除文字默认的倾斜效果\n1 2 3 4 5 6 em { font-style: normal; /* 将 em 标签倾斜效果移除 */ } p { font-style: italic; /* 将 p 标签内文字倾斜 */ } 行高 设置多行文本的间距，属性值有两种\n1 2 3 4 5 6 P { line-height: 30px; /* 行高为 30px */ } div { line-height: 2; /* 行高为 font-size 的两倍 (font-size 默认为 16px) */ } 行高指文本高度+上间距+下间距\n当行高属性值等于盒子 (div) 高度属性值时，可以实现垂直居中\n1 2 3 4 div { line-height: 100px; height: 100px; } 字体族 用于控制文字的字体，属性值为字体名\n1 2 3 p { font-family: 楷体; } 一般情况下会设置多个\n1 2 3 p { font-family: Microsoft YaHei, Heiti SC, tahoma, arial, Hiragino Sans GB, \u0026#34;\\5B8B\\4F53\u0026#34;, sans-serif; } 执行循序为从左到右，即浏览器会检测系统是否有当前字体，若没有，检测是否有下一个，直到最后一个，上述最后一个为 无衬线字体 的字体族名\nfont 复合属性 在开发设置字体时以下情况\n1 2 3 4 5 6 7 div { font-style: italic; /* 文字倾斜 */ font-weight: 700; /* 文字加粗 */ font-size: 30px; /* 字体大小为 30px */ line-height: 2; /* 行高为字号的 2 倍 */ font-family: 楷体; /* 设置字体 */ } 可以简写为\n1 2 3 4 div { font: italic 700 30px/2 楷体; /* 是否倾斜 加粗 字号/行高 字体 */ } 此属性一般用于设置网页文字公共样式，属性值必须按顺序书写，其中字号和字体值必须书写，其它可以省略\n文本缩进 属性值有两种，px 或 em，em 为当前标签的字号大小\n1 2 3 4 5 p { font-size: 20px; text-indent: 2em; /* 首行缩进两个字 */ /* text-indent: 40px; 与上一行代码效果一致 */ } 文本对齐方式 text-align 属性有三个值：left、center、right\n1 2 3 div { text-align: center; /* 文字中间对齐 */ } 此属性不仅可以用于文字对齐，如以下使用方式可以使图片居中\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; div { text-align: center; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div\u0026gt; \u0026lt;img src=\u0026#34;path\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; text-align 本质是控制内容的对齐方式，属性要设置给内容的父级，上例 img 的父级为 div\n文本修饰线 效果 无 下划线 删除线 上划线 属性值 none underline line-through overline 1 2 3 4 5 6 a { text-decoration: none; /* 去除链接的下划线 */ } del { text-decoration: none; /* 去除 del 标签的下划线，使 del 标签无效 */ } 文字颜色 颜色表示方式 属性值 说明 关键字 英语单词 red、green、aqua 等 rgb 表示法 rgb(r, g, b) r, g, b 表示红绿蓝三原色，取值 0-255 rgba 表示法 rgba(r, g, b, a) a 表示透明度，取值 0-1 十六进制表示法 #RRGGBB 两两一组，若相同可缩写。#ffcc00 -\u0026gt; #fc0 1 2 3 4 5 6 p { color: rgba(250, 200, 0, 0.5); } div { dolor: #acf; /* 等同于 #aaccff */ } ","date":"2024-03-14T21:07:15+08:00","permalink":"https://blog.yexca.net/archives/165/","title":"CSS 文字控制属性"},{"content":"CSS 三大特性：继承性、层叠性、优先级\n继承性 子级默认继承父级的文字控制属性，若子级有自己的样式则不继承\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;style\u0026gt; body { font: 30px/0.5 楷体; color: aqua; } \u0026lt;/style\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div\u0026gt;div\u0026lt;/div\u0026gt; \u0026lt;p\u0026gt;p\u0026lt;/p\u0026gt; \u0026lt;span\u0026gt;span\u0026lt;/span\u0026gt; \u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt;不继承颜色\u0026lt;/a\u0026gt; \u0026lt;/body\u0026gt; 层叠性 选择器类型相同时：\n相同的属性会覆盖：后面的 CSS 属性覆盖前面的 CSS 属性 不同的属性会叠加：不同的 CSS 属性都生效 1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;style\u0026gt; div { color: red; font-size: 30px; } div { color: aqua; font-weight: 700; } \u0026lt;/style\u0026gt; \u0026lt;div\u0026gt; 颜色为 aqua，字号 30px，加粗 \u0026lt;/div\u0026gt; 优先级 当一个标签使用了多种选择器时，优先级高的样式生效，优先级：\n通配符选择器 \u0026lt; 标签选择器 \u0026lt; 类选择器 \u0026lt; id 选择器 \u0026lt; 行内样式 \u0026lt; !important\n一般不使用 !important ，下例不使用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;style\u0026gt; #app { color: orange; } .box { color: blue; } div { color: red; } * { color: purple; } \u0026lt;/style\u0026gt; \u0026lt;div\u0026gt;标签选择器 red\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;类选择器 blue\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34; id=\u0026#34;app\u0026#34;\u0026gt;id 选择器 orange\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34; id=\u0026#34;app\u0026#34; style=\u0026#34;color: aqua;\u0026#34;\u0026gt;行内样式 aqua\u0026lt;/div\u0026gt; 使用 !important\n1 2 3 4 5 6 7 \u0026lt;style\u0026gt; div { color: aqua !important; } \u0026lt;/style\u0026gt; \u0026lt;div style=\u0026#34;color: blue\u0026#34;\u0026gt;aqua\u0026lt;/div\u0026gt; 复合选择器叠加优先级 按 (行内样式，id选择器个数。类选择器个数，标签选择器个数) 从左到右依次比较个数，同一级个数多的优先级高，若相同则比较下一级\n若有 !important 则优先级最高，继承的优先级最低\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 \u0026lt;style\u0026gt; /* (0, 0, 2, 1) */ .c1 .c2 div { color: blue; } /* (0, 1, 0, 1) */ div #box3 { color: red; } /* (0, 1, 1, 0) */ #box1 .c3 { color: aqua; } \u0026lt;/style\u0026gt; \u0026lt;div class=\u0026#34;c1\u0026#34; id=\u0026#34;box1\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;c2\u0026#34; id=\u0026#34;box2\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;c3\u0026#34; id=\u0026#34;box3\u0026#34;\u0026gt; aqua \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 例 2\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 \u0026lt;style\u0026gt; /* (0, 2, 0, 0) */ #father #son { color: aqua; } /* (0, 1, 1, 1) */ #father p.c2 { color: black; } /* (0, 0, 2, 2) */ div.c1 p.c2 { color: red; } /* 继承 */ #father { color: blue !important; } /* 继承 */ div#father.c1{ color: yellow; } \u0026lt;/style\u0026gt; \u0026lt;div class=\u0026#34;c1\u0026#34; id=\u0026#34;father\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;c2\u0026#34; id=\u0026#34;son\u0026#34;\u0026gt; aqua \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; Emmet 写法 即代码的简写方式，输入缩写 VS Code 会自动生成对应的代码\n对于 HTML\n说明 Emmet 效果 类选择器 标签名.类名 \u0026lt;div class=\u0026quot;box\u0026quot;\u0026gt;\u0026lt;/div\u0026gt; id 选择器 标签名#id名 \u0026lt;div id=\u0026quot;app\u0026quot;\u0026gt;\u0026lt;/div\u0026gt; 同级标签 div+p \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt; 父子级标签 div\u0026gt;p \u0026lt;div\u0026gt;\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;/div\u0026gt; 多个相同标签 span*3 \u0026lt;span\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt;\u0026lt;/span\u0026gt; 有内容的标签 div{内容} \u0026lt;div\u0026gt;内容\u0026lt;/div\u0026gt; 对于 CSS 多数为单词首字母\nh500+w300+bgc 会变为\n1 2 3 4 5 div { width: 500px; height: 300px; background-color: #fff; } ","date":"2024-03-11T16:38:34+08:00","permalink":"https://blog.yexca.net/archives/164/","title":"CSS 三大特性"},{"content":"CSS 引入方式 CSS 有三种引入方式，第一种为内部样式表，此方式仅学习使用\n1 2 3 4 5 6 7 8 9 10 \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; /* 此处写 CSS */ \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 第二种为行内样式，一般配合 JavaScript 使用\n1 \u0026lt;div style=\u0026#34;此处写 CSS\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; 最后一种为外部样式表，将 CSS 代码写在单独文件，通过 link 标签引入，开发时常用\n1 2 3 4 \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;css path\u0026#34; /\u0026gt; \u0026lt;/head\u0026gt; CSS 选择器 选择器的作用是查找标签，设置样式，一共四种基础选择器\n标签选择器 直接使用标签名作为选择器，即选中同名标签设置相同的样式\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; div{ /* 选中所以 div 标签设置样式 */ } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 可以使用的标签有 p、h1、div、a、img 等\n类选择器 用于查找标签，差异化设置标签的显示效果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; .first{ /* 选中 first div 设置样式 */ } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;first\u0026#34;\u0026gt; first div \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; second div \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 类名若是多个单词可用 - 连接，一个类选择器可用供多个标签使用，一个标签可以使用多个类名\n1 2 3 \u0026lt;div class=\u0026#34;first second\u0026#34;\u0026gt; 使用了两个类名 \u0026lt;/div\u0026gt; id 选择器 用于查找标签，差异化设置标签的显示效果，一般配合 JavaScript 使用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; #app{ /* 选中 id 为 app 的标签 */ } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 同一个 id 选择器在一个页面只能使用一次\n通配符选择器 查找页面所有标签，设置相同样式，一般用于清除标签的默认样式\n1 2 3 4 5 \u0026lt;style\u0026gt; *{ /* 书写样式影响所有标签 */ } \u0026lt;/style\u0026gt; 复合选择器 定义：由两个或多个基础选择器，通过不同的方式组合而成\n作用：更准确、更高效的选择目标元素 (标签)\n后代选择器 可以选中某元素的所有后代元素\n语法：父选择器 子选择器 { CSS 属性 }\n父选择器与子选择器之间用空格隔开，可以为类选择器或 id 选择器\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;style\u0026gt; div span{ color: aqua; } \u0026lt;/style\u0026gt; \u0026lt;span\u0026gt;颜色不会变\u0026lt;/span\u0026gt; \u0026lt;div\u0026gt; \u0026lt;span\u0026gt;颜色会变\u0026lt;/span\u0026gt; \u0026lt;p\u0026gt; \u0026lt;span\u0026gt;颜色会变\u0026lt;/span\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; 子代选择器 只选中某元素子级元素\n语法：父选择器 \u0026gt; 子选择器 { CSS 属性 }\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;style\u0026gt; div \u0026gt; span{ color: aqua; } \u0026lt;/style\u0026gt; \u0026lt;div\u0026gt; \u0026lt;span\u0026gt;颜色会变\u0026lt;/span\u0026gt; \u0026lt;p\u0026gt; \u0026lt;span\u0026gt;颜色不会变\u0026lt;/span\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; 并集选择器 选中多组标签设置相同的样式\n语法：选择器1, 选择器2, ..., 选择器N { CSS 属性 }\n1 2 3 4 5 6 7 8 9 \u0026lt;style\u0026gt; div, span, p { color: aqua; } \u0026lt;/style\u0026gt; \u0026lt;div\u0026gt;颜色会变\u0026lt;/div\u0026gt; \u0026lt;p\u0026gt;颜色会变\u0026lt;/p\u0026gt; \u0026lt;span\u0026gt;颜色会变\u0026lt;/span\u0026gt; 交集选择器 选中同时满足多个条件的元素\n语法：选择器1选择器2 { CSS 属性 } 选择器之间连写，没有任何符号\n如果交集选择器中有标签选择器，标签选择器必须书写在最前面\n1 2 3 4 5 6 7 8 9 \u0026lt;style\u0026gt; p.box { color: aqua; } \u0026lt;/style\u0026gt; \u0026lt;p class=\u0026#34;box\u0026#34;\u0026gt;颜色会变\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;p 标签，颜色不会变\u0026lt;/p\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;颜色不会变\u0026lt;/div\u0026gt; 伪类选择器 伪类表示元素状态，选中元素的某个状态设置样式\n鼠标悬停状态 语法：选择器:hover { CSS 属性 }\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;style\u0026gt; a:hover{ color: red; } .box:hover{ color: aqua; } \u0026lt;/style\u0026gt; \u0026lt;a href=\u0026#34;https://yexca.net\u0026#34;\u0026gt;yexca\u0026lt;/a\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt; div 标签 \u0026lt;/div\u0026gt; 任何标签都可以设置鼠标悬停的状态\n超链接的状态 选择器 作用 :link 访问前 :visited 访问后 :hover 鼠标悬停 :active 点击时 (激活) 若给超链接设置四个状态，需按顺序书写\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;style\u0026gt; a:link { color: green; } a:visited { color: red; } a: hover { color: aqua; } a: active { color: orange; } \u0026lt;/style\u0026gt; \u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt;a 标签\u0026lt;/a\u0026gt; 结构伪类选择器 作用：根据元素的结构关系查找元素\n选择器 说明 E:first-child 选择第一个 E 元素 E:last-child 选择最后一个 E 元素 E:nth-child(N) 选择第 N 个 E 元素 (从 1 开始) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;style\u0026gt; li:first-child { background-color: aqua; } li:last-child { background-color: green; } li:nth-child(3) { background-color: blue; } \u0026lt;/style\u0026gt; \u0026lt;ol\u0026gt; \u0026lt;li\u0026gt;aqua\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;2\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;blue\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;4\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;green\u0026lt;/li\u0026gt; \u0026lt;/ol\u0026gt; 其中第三个选择器可以使用公式选择多个元素\n功能 公式 偶数个标签 2n 奇数个标签 2n+1 或 2n-1 找到 5 的倍数的标签 5n 找到第 5 个以后的标签 (包括 5) n+5 找到第 5 个以前的标签 (包括 5) -n+5 伪元素选择器 作用：创建虚拟元素 (伪元素)，用来摆放装饰性的内容\n选择器 说明 E::before 在 E 元素里面最前面添加一个伪元素 E::after 在 E 元素里面最后面添加一个伪元素 注意：\n必须设置 content 属性，用来设置伪元素的内容，如果没有内容，则引号留空 伪元素默认为行内显示模式 优先级和标签选择器相同 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;style\u0026gt; div { width: 110px; height: 30px; background-color: aqua; font-size: 20px; } div::before { content: \u0026#39;yexca\u0026#39;; } div::after { content: \u0026#39;blog\u0026#39;; } \u0026lt;/style\u0026gt; \u0026lt;div\u0026gt;\u0026#39;\u0026lt;/div\u0026gt; \u0026lt;!-- 内容为 yexca\u0026#39;blog --\u0026gt; ","date":"2024-03-02T17:15:35+08:00","permalink":"https://blog.yexca.net/archives/163/","title":"CSS 选择器"},{"content":" Golang Series\nHello GoLang: https://blog.yexca.net/archives/154 GoLang (var and const) 变量与常量: https://blog.yexca.net/archives/155 GoLang (func) 函数: https://blog.yexca.net/archives/156 GoLang (slice and map) 切片: https://blog.yexca.net/archives/160 GoLang (OOP) 面向对象: 本文\nGoLang (reflect) 反射: https://blog.yexca.net/archives/204 GoLang (struct tag) 结构体标签: https://blog.yexca.net/archives/205 GoLang (goroutine) go 程: https://blog.yexca.net/archives/206 GoLang (channel) 通道: https://blog.yexca.net/archives/207 通过使用结构体构建类与对象的概念\n了解面向对象： 面向对象基础 struct 首先是自定义类型，使用 type 关键字，类似于 C\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package main import \u0026#34;fmt\u0026#34; type myType int func main() { var a myType fmt.Println(\u0026#34;a =\u0026#34;, a) fmt.Printf(\u0026#34;type of a is %T\u0026#34;, a) } /* * 输出 * a = 0 * type of a is main.myTye */ 定义类型使用 stuct\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package main import \u0026#34;fmt\u0026#34; type Person struct { name string age int } fun main() { var zhang Person zhang.name = \u0026#34;zhangSan\u0026#34; zhang.age = 20 fmt.Print(zhang) } 函数传递相关，不使用指针是值传递\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 package main import \u0026#34;fmt\u0026#34; type Person struct { name string age int } // 值传递，不会修改原数据 func changeName(person Person) { person.name = \u0026#34;liSi\u0026#34; } // 引用传递，会修改原数据 func changeAge(person *Person) { person.age = 18 } func main() { var zhang Person zhang.name = \u0026#34;zhangSan\u0026#34; zhang.age = 20 fmt.Println(zhang) changeName(zhang) fmt.Println(zhang) changeAge(\u0026amp;zhang) fmt.Println(zhang) } 封装 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 package main import \u0026#34;fmt\u0026#34; // 类 type Person struct { // 属性 name string age int } // 类的方法 func (this *Person) SetName(name string) { this.name = name } func (this *Person) SetAge(age int) { this.age = age } func (this *Person) GetName() string { return this.name } func (this *Person) GetAge() int { return this.age } func main() { person := Person{name: \u0026#34;zhangSan\u0026#34;, age: 18} fmt.Println(person) } 注意到上述 类名、方法名 首字母为大写，代表该类、方法可以被其他包访问 (java public)，若首字母小写则只能此包访问 (java private)，属性名也是同理\n继承 以下代码处于同一文件，父类\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 父类 type Person struct { name string age int } // 父类的方法 func (this *Person) Eat() { fmt.Println(\u0026#34;Person Eat...\u0026#34;) } func (this *Person) Walk() { fmt.Println(\u0026#34;Person Walk...\u0026#34;) } 子类\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 子类 type SuperMan struct { Person // 继承父类 level int // 子类属性 } // 子类重写父类方法 func (this *SuperMan) Walk() { fmt.Println(\u0026#34;SuperMan Walk\u0026#34;) } // 子类特有方法 func (this *SuperMan) Fly() {} main 函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func main() { // 定义子类属性，方式一 superMan1 := SuperMan{Person{\u0026#34;zhangSan\u0026#34;, 18}, 4} // 定义子类属性，方式二 var superMan2 SuperMan superMan2.name = \u0026#34;liSi\u0026#34; // 因为同一个包，可以访问父类属性 superMan2.age = 20 superMan2.level = 5 // 子类调用父类方法 superMan1.Eat() // 子类重写方法 superMan1.Walk() // 子类方法 superMan2.Fly() } 多态 以下代码处于同一文件，定义接口\n1 2 3 4 5 6 // 接口，本质是一个指针 type Animal interface { Sleep() GetName() string GetType() string } 实现类一\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 实现类一 type Cat struct { name string kind string } // 实现接口所有方法 func (this *Cat) Sleep() { fmt.Println(\u0026#34;Cat Sleep()\u0026#34;) } func (this *Cat) GetName() string { return this.name } func (this *Cat) GetType() string { return this.kind } 实现类二\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // 实现类二 type Dog struct { name string kind string } // 实现接口所有方法 func (this *Dog) Sleep() { fmt.Println(\u0026#34;Cat Sleep()\u0026#34;) } func (this *Dog) GetName() string { return this.name } func (this *Dog) GetType() string { return this.kind } func ShowAnimal(animal Animal) { fmt.Println(animal) } main\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 func ShowAnimal(animal Animal) { fmt.Println(animal) } func main() { var animal Animal animal = \u0026amp;Cat{\u0026#34;cat1\u0026#34;, \u0026#34;cat\u0026#34;} animal.Sleep() animal = \u0026amp;Dog{\u0026#34;dog1\u0026#34;, \u0026#34;dog\u0026#34;} animal.Sleep() cat := Cat{\u0026#34;cat2\u0026#34;, \u0026#34;cat\u0026#34;} dog := Dog{\u0026#34;dog2\u0026#34;, \u0026#34;dog\u0026#34;} ShowAnimal(\u0026amp;cat) ShowAnimal(\u0026amp;dog) } 万能类型与断言 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package main import \u0026#34;fmt\u0026#34; // 使用空接口表示万能数据类型 func f(arg interface{}) { // 类型断言机制(即类型转换) value, flag := arg.(string) if !flag { fmt.Println(\u0026#34;arg is not string type\u0026#34;) } else { fmt.Println(\u0026#34;arg is string type, arg =\u0026#34;, value) } } func main() { // 可以传入任意数据类型，包括自定 f(\u0026#34;abc\u0026#34;) f(123) f(3.14) } /* * 输出 * arg is string type, arg = abc * arg is not string type * arg is not string type */ ","date":"2024-03-01T15:35:38+08:00","permalink":"https://blog.yexca.net/archives/162/","title":"GoLang 面向对象"},{"content":"引入注册中心之前先引入提供者与消费者概念\n提供者与消费者 服务提供者：一次业务中，被其它微服务调用的服务。（提供接口给其它微服务）\n服务消费者：一次业务中，调用其它微服务的服务。（调用其它微服务提供的接口）\n提供者与消费者是相对的，一个服务既可以是提供者也可以是消费者\nEureka 若提供者有多个，消费者如何获取提供者信息，如何得知提供者的健康状态\n在启动时，微服务向 Eureka 注册服务信息，消费者可通过 Eureka 拉取提供者信息，然后远程调用。微服务会每 30s 向 Eureka 说明自己还活着，Eureka 会更新记录服务列表信息，剔除不健康服务器\n如果有多个服务提供者，消费者利用负载均衡算法，从服务列表中挑选一个\n搭建 新建一个 Maven Module，引入依赖\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-eureka-server\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 编写启动类\n1 2 3 4 5 6 7 @EnableEurekaServer @SpringBootApplication public class EurekaApplication { public static void main(String[] args) { SpringApplication.run(EurekaApplication.class,args); } } 配置文件\n1 2 3 4 5 6 7 8 9 server: port: 7995 spring: application: name: eureka-server eureka: client: service-url: defaultZone: http://127.0.0.1:7995/eureka 注册服务 引入依赖\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-eureka-client\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 编写配置\n1 2 3 4 5 6 7 spring: application: name: userService eureka: client: service-url: defaultZone: http://127.0.0.1:7995/eureka 服务使用 上例注册\n1 2 3 4 5 @Bean @LoadBalanced public RestTemplate restTemplate(){ return new RestTemplate(); } 修改调用的域名为服务名\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 @Service public class OrderService { @Autowired private OrderMapper orderMapper; @Autowired private RestTemplate restTemplate; public Order queryOrderById(Long orderId) { // 1.查询订单 Order order = orderMapper.findById(orderId); // 2.查询用户 // String url = \u0026#34;http://localhost:8081/user/\u0026#34; + order.getUserId(); String url = \u0026#34;http://userService/user/\u0026#34; + order.getUserId(); User user = restTemplate.getForObject(url, User.class); // 3.封装用户信息 order.setUser(user); // 4.返回 return order; } } ","date":"2024-02-29T16:53:15+08:00","permalink":"https://blog.yexca.net/archives/161/","title":"注册中心 - Eureka"},{"content":" Golang 系列\nHello GoLang: https://blog.yexca.net/archives/154 GoLang (var and const) 变量与常量: https://blog.yexca.net/archives/155 GoLang (func) 函数: https://blog.yexca.net/archives/156 GoLang (slice and map) 切片: 本文\nGoLang (OOP) 面向对象: https://blog.yexca.net/archives/162 GoLang (reflect) 反射: https://blog.yexca.net/archives/204 GoLang (struct tag) 结构体标签: https://blog.yexca.net/archives/205 GoLang (goroutine) go 程: https://blog.yexca.net/archives/206 GoLang (channel) 通道: https://blog.yexca.net/archives/207 Go 的切片是对数组的抽象\n数组 数组的长度不可改变\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package main import \u0026#34;fmt\u0026#34; func main() { // 定义方式一 var arr1 [10]int // 遍历 for i := 0; i \u0026lt; len(arr1); i++ { fmt.Println(\u0026#34;arr1[\u0026#34;, i, \u0026#34;]:\u0026#34;, arr1[i]) } // 定义方式二，赋值 arr2 := [10]int{0, 1, 2, 3} // range遍历 for index, value := range arr2 { fmt.Println(\u0026#34;index =\u0026#34;, index, \u0026#34;value =\u0026#34;, value) } // 定义不同长度 var arr3 [4]int fmt.Printf(\u0026#34;type of arr1 is %T\\n\u0026#34;, arr1) // [10]int fmt.Printf(\u0026#34;type of arr1 is %T\\n\u0026#34;, arr2) // [10]int fmt.Printf(\u0026#34;type of arr1 is %T\u0026#34;, arr3) // [4]int } 编译运行后可以发现 arr3 与 arr1，arr2 类型不同，那么在定义函数形参时也需要指定相应类型\n1 2 3 4 5 func test(arr [4]int) { for i := 0; i \u0026lt; len(arr); i++ { fmt.Println(\u0026#34;fmt_arr[\u0026#34;, i, \u0026#34;]:\u0026#34;, arr[i]) } } 上述函数只能传递 arr3，值传递，修改值不影响原数据\n定义切片 与数组相比切片长度不固定，可追加元素 (动态数组)，在追加时可能使切片的容量增大\n定义切片可以通过声明一个未指定大小的数组\n1 2 3 var name []type // 例如 var s []int 或者使用 make() 函数来创建切片\n1 2 3 var slice []type = make([]type, len) // len 为切片初始长度 // 也可以简写为 slice := make([]type, len) 可以使用可选参数 capacity 指定容量，省略与 length 相同\n1 var slice []type = make([]type, length, capacity) 切片初始化 直接初始化\n1 s := []int {1, 2, 3} 将数组值为切片初始化，从 startIndex 到 endIndex-1，这俩值都可省略\n1 s := arr[startIndex:endIndex] 省略 startIndex 或 endIndex 表示从第一个元素开始索引或索引到最后一个元素\nlen() 和 cap() 切片是可以索引的，通过 len() 函数获取长度\n而 cap() 为计算容量的方法，可以测量切片最长可以达到多少\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package main import \u0026#34;fmt\u0026#34; // 切片传递为引用传递，函数内修改影响原数据 func printSlice(slice []int) { fmt.Printf(\u0026#34;len=%d, cap=%d, slice=%v\u0026#34;, len(slice), cap(slice), slice) } func main() { s := make([]int, 3, 5) printSlice(s) } /* * 输出 * len=3, cap=5, slice=[0 0 0] */ 空切片 一个切片在未初始化之前默认为 nil (空切片)，长度为 0\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package main import \u0026#34;fmt\u0026#34; func printSlice(slice []int) { fmt.Printf(\u0026#34;len=%d, cap=%d, slice=%v\\n\u0026#34;, len(slice), cap(slice), slice) } func main() { var s []int printSlice(s) // 判断是否为空 if s == nil { fmt.Println(\u0026#34;slice is empty\u0026#34;) } } 切片截取 通过设置上下限截取切片\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package main import \u0026#34;fmt\u0026#34; func printSlice(slice []int) { fmt.Printf(\u0026#34;len=%d, cap=%d, slice=%v\\n\u0026#34;, len(slice), cap(slice), slice) } func main() { s := []int{0, 1, 2, 3, 4, 5, 6, 7} // 打印原始切片 fmt.Println(s) // 从2(包含)到5(不包含) printSlice(s[2:5]) // 从第一个到5(不包含) printSlice(s[:5]) // 从第二个到最后一个 printSlice(s[2:]) // 这样赋值修改 subS 将影响到 s subS := s[1:6] printSlice(subS) } append() 和 copy() 增加切片的容量与拷贝切片\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package main import \u0026#34;fmt\u0026#34; func printSlice(slice []int) { fmt.Printf(\u0026#34;len=%d, cap=%d, slice=%v\\n\u0026#34;, len(slice), cap(slice), slice) } func main() { var s []int printSlice(s) // 增加一个元素 s = append(s, 0) printSlice(s) // 增加多个元素 s = append(s, 1, 2, 3, 4) printSlice(s) // 创建一个容量为 s 两倍的 s2 s2 := make([]int, len(s), cap(s)*2) // 拷贝 s 到 s2，此时修改 s2 不影响 s copy(s2, s) printSlice(s2) } 切片的扩容：如果追加值超过容量，则将容量增加两倍\nmap map 有两种声明方式\n1 2 3 4 5 6 7 8 9 10 11 package main import \u0026#34;fmt\u0026#34; func main() { var map1 = make(map[string]string) // 插入数据 map1[\u0026#34;one\u0026#34;] = \u0026#34;1\u0026#34; map1[\u0026#34;two\u0026#34;] = \u0026#34;2\u0026#34; fmt.Println(map1) // map[one:1 two:2] } 第二种\n1 2 3 4 5 6 7 8 9 10 11 package main import \u0026#34;fmt\u0026#34; func main() { map1 := map[string]string{ \u0026#34;one\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;two\u0026#34;: \u0026#34;2\u0026#34;, } fmt.Println(map1) } map 嵌套 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package main import \u0026#34;fmt\u0026#34; func main() { map1 := make(map[string]map[string]string) map1[\u0026#34;first\u0026#34;] = make(map[string]string, 2) map1[\u0026#34;first\u0026#34;][\u0026#34;one\u0026#34;] = \u0026#34;1\u0026#34; map1[\u0026#34;first\u0026#34;][\u0026#34;two\u0026#34;] = \u0026#34;2\u0026#34; fmt.Println(map1) } /* * 输出 * map[first:map[one:1 two:2]] */ 修改遍历与删除 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package main import \u0026#34;fmt\u0026#34; func main() { map1 := make(map[string]map[string]string) map1[\u0026#34;first\u0026#34;] = make(map[string]string, 2) map1[\u0026#34;first\u0026#34;][\u0026#34;one\u0026#34;] = \u0026#34;1\u0026#34; map1[\u0026#34;first\u0026#34;][\u0026#34;two\u0026#34;] = \u0026#34;2\u0026#34; // 修改 map1[\u0026#34;first\u0026#34;][\u0026#34;one\u0026#34;] = \u0026#34;one\u0026#34; fmt.Println(map1) // 遍历 for key, value := range map1{ fmt.println(\u0026#34;key =\u0026#34;, key, \u0026#34;value =\u0026#34;, value) } // 删除 delete(map1, \u0026#34;first\u0026#34;) fmt.Println(map1) } 判断是否有某值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 package main import \u0026#34;fmt\u0026#34; func main() { map1 := make(map[string]string) map1[\u0026#34;one\u0026#34;] = \u0026#34;1\u0026#34; val, key := map1[\u0026#34;one\u0026#34;] if key { fmt.Println(val) } else { fmt.Println(\u0026#34;empty\u0026#34;) } } ","date":"2024-02-27T20:00:00+08:00","permalink":"https://blog.yexca.net/archives/160/","title":"GoLang 切片"},{"content":"这篇文章还是有点久远的，书写习惯和现在不同，甚至看着有点不习惯\n通过 crontab 命令，我们可以在固定的间隔时间执行指定的系统指令或 shell script 脚本。时间间隔的单位可以是分钟、小时、日、月、周及以上的任意组合\n命令格式 1 crontab [-u user] file crontab [-u user] [ -e | -l | -r ] 命令参数 -u user：用来设定某个用户的 crontab 服务 file：file 是命令文件的名字,表示将 file 做为 crontab 的任务列表文件并载入 crontab。如果在命令行中没有指定这个文件，crontab 命令将接受标准输入（键盘）上键入的命令，并将它们载入 crontab -e：编辑某个用户的 crontab 文件内容。如果不指定用户，则表示编辑当前用户的 crontab 文件 -l：显示某个用户的 crontab 文件内容，如果不指定用户，则表示显示当前用户的 crontab 文件内容 -r：从 /var/spool/cron 目录中删除某个用户的 crontab 文件，如果不指定用户，则默认删除当前用户的 crontab 文件 -i：在删除用户的 crontab 文件时给确认提示 文件格式 执行 crontab -e 命令后，会打开当前用户的 crontab 文件，在这个文件中，以 # 开头的语句是注释语句\n在 crontab 文件中，通过 m h dom mon dow command 这六个字段来设置定时任务，每一行对应一个定时任务。这六个字段的含义说明如下：\nm：对应分钟 (minute) 指定要在一小时之中的第几分钟执行该任务。取值范围是 0-59.\nh：对应小时 (hour) 指定要在一天之中的第几个小时执行该任务。取值范围是 0-23.\ndom：对应日期 (day of month) 指定要在一月之中的第几天执行该任务。取值范围是 0-31.\nmon：对应月份 (month) 指定要在一年之中的第几月执行该任务。取值范围是 1-12。 也可以通过月份英文名称的前三个字母来指定，不区分大小写。例 如，一月的英文单词是 january，那么这里可以用 jan 来指定一月。\ndow：对应星期几 (day of week) 指定要在一周之中的星期几执行该任务。取值范围是 0-7，0 和 7 都对应星期天。 也可以通过星期英文名称的前三个字母来指定，不区分大小写。例如，星期一的英文单词是 monday，那么这里可以用 mon 来指定星期一。\ncommand：对应具体的操作\n提供具体的命令来指定进行什么操作，可以提供脚本文件的路径来执行该脚本文件。\n这六个字段要求用空格隔开。且每个字段都必须提供值，不能省略某个字段的值。从第五个字段之后的所有内容都属于第六个字段，也就是要执行的操作\n前五个字段可以使用下面的特殊字符来指定一些特殊的时间：\n星号（*）：代表所有可能的值，例如month字段如果是星号，则表示在满足其它字段的制约条件后每月都执行该命令操作 逗号（,）：可以用逗号隔开的值指定一个列表范围，例如，\u0026ldquo;1,2,5,7,8,9\u0026rdquo; 中杠（-）：可以用整数之间的中杠表示一个整数范围，例如 \u0026ldquo;2-6\u0026rdquo; 表示 \u0026ldquo;2,3,4,5,6\u0026rdquo; 正斜线（/）：可以用正斜线指定时间的间隔频率，例如 \u0026ldquo;0-23/2\u0026rdquo; 表示每两小时执行一次。同时正斜线可以和星号一起使用，例如 */10，如果用在 minute 字段，表示每十分钟执行一次 在 command 字段中，可以使用换行符、或者 % 字符来分隔命令内容\n在第一个 % 之前的内容会传递给 shell 来执行，这个 % 自身会被替换成换行符，在 % 之后、直到行末的内容都作为标准输入传递\n如果需要提供 % 字符自身，需要用 \\% 进行转义\n常用方法 向 cron 进程提交一个 crontab 文件之前，首先要设置环境变量 EDITOR。cron 进程根据它来确定使用哪个编辑器编辑 crontab 文件\n由于默认使用 nano 编辑器不是特别好用，可以改为 vi，通过编辑 $HOME 目录下的 . profile 文件，在其中加入这样一行:\n1 EDITOR=vi; export EDITOR 然后保存并退出。不妨创建一个名为 cron 的文件，其中 是用户名，例如， yexcacron。在该文件中加入要定时执行的内容，例如\n1 2 3 # (put your own initials here)echo the date to the console every # 15minutes between 6pm and 6am 0,15,30,45 18-06 * * * /bin/echo \u0026#39;date\u0026#39; \u0026gt; /dev/console 在上面的例子中，系统将每隔 15 分钟向控制台输出一次当前时间。如果系统崩溃或挂起，从最后所显示的时间就可以一眼看出系统是什么时间停止工作的。在有些系统中，用 tty1 来表示控制台，可以根据实际情况对上面的例子进行相应的修改。为了提交你刚刚创建的 crontab 文件，可以把这个新创建的文件作为 cron 命令的参数:\n1 crontab yexcacron 现在该文件已经提交给 cron 进程，它将每隔 15 分钟运行一次。同时，新创建文件的一个副本已经被放在 /var/spool/cron 目录中，文件名就是用户名 (即 yexca)\n执行脚本 如果执行脚本需要使用变量\n1 30 6 * * * . /etc/profile;/bin/sh /root/zfile/bin/restart.sh 以上为每日 6.30 执行 zfile 的 restart.sh\n参考文章 crontab 定时任务 — Linux Tools Quick Tutorial Linux技巧：介绍设置定时周期执行任务的方法 - SegmentFault 思否 Linux命令之Crontab——定时任务 - SegmentFault 思否 nano编辑器使用教程 - VPS侦探 Linux vi/vim - 菜鸟教程 ","date":"2024-02-26T21:34:15+08:00","permalink":"https://blog.yexca.net/archives/159/","title":"Linux 定时任务 crontab"},{"content":"服务架构 单体架构 将业务的所有功能集中在一个项目中开发，打包一个包部署\n优点：架构简单、扩展性差、部署成本低，适合小型项目\n缺点：耦合度高\n分布式架构 根据业务功能对系统进行拆分，每个业务模块作为独立项目开发，称为一个服务\n优点：降低服务耦合、有利于服务升级拓展\n缺点：架构复杂、难度大，适合大型互联网项目\n微服务 微服务是一种经过良好架构设计的分布式架构方案，微服务架构特征：\n单一职责 ：微服务拆分粒度更小，每一个服务都对应唯一的业务能力，做到单一职责，避免重复业务开发 面向服务：微服务对外暴露业务接口 自治：团队独立、技术独立、数据独立、部署独立 隔离性强：服务调用做好隔离、容错、降级，避免出现级联问题 微服务技术 微服务方案需要技术框架落地，常见的：\nDubbo SpringCloud SpringCloudAlibaba 注册中心 zookeeper、 Redis Eureka、 Consul Nacos、 Eureka 服务远程调用 Dubbo 协议 Feign (http 协议) Dubbo、Feign 配置中心 无 SpringCloudConfig SpringCloudConfig、 Nacos 服务网关 无 SpringCloudGateway、 Zuul SpringCloudGateway、 Zuul 服务监控和保护 dubbo-admin，功能弱 Hystix Sentinel 微服务需要根据业务模块拆分\n单一职责：不同微服务，不要重复开发相同业务 数据独立：不要访问其它微服务的数据库 面向服务：将自己的业务暴露为接口，供其它微服务调用 SpringCloud SpringCloud 是目前使用最广泛的微服务框架。集成了各种微服务功能组件，并基于 SpringBoot 实现了这些组件的自动装配\n官网： https://spring.io/projects/spring-cloud/ 服务注册发现：Eureka、Nacos、Consul 统一配置管理：SpringCloudConfig、Nacos 服务远程调用：OpenFeign、Dubbo 统一网关路由： SpringCloudGateway、Zuul 服务链路监控：Zipkin、Sleuth 流控、降级、保护：Hystix、Sentinel 微服务调用 需求：根据订单 id 查询订单的同时，把订单所属的用户信息一起返回\n注册 RestTemplate 1 2 3 4 @Bean public RestTemplate restTemplate(){ return new RestTemplate(); } 服务远程调用 RestTemplate 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 @Service public class OrderService { @Autowired private OrderMapper orderMapper; @Autowired private RestTemplate restTemplate; public Order queryOrderById(Long orderId) { // 1.查询订单 Order order = orderMapper.findById(orderId); // 2.查询用户 String url = \u0026#34;http://localhost:8081/user/\u0026#34; + order.getUserId(); // RestTemplate的GET方法 User user = restTemplate.getForObject(url, User.class); // 3.封装用户信息 order.setUser(user); // 4.返回 return order; } } ","date":"2024-02-25T17:56:54+08:00","permalink":"https://blog.yexca.net/archives/158/","title":"Hi SpringCloud"},{"content":" Redis 基础: 本文\nRedis 分布式缓存: https://blog.yexca.net/archives/225/ Redis 是一个基于内存的 key-value 结构数据库，是互联网技术领域使用最为广泛的存储中间件\n官网： https://redis.io 中文网： https://www.redis.net.cn/ Redis 基于内存存储，读写性能高，适合存储热点数据 (商品、资讯、新闻) 。是用 C 语言开发的一个开源的高性能键值对数据库，存储 value 类型比较丰富，也被称为结构化的 NoSql (Not Only SQL) 数据库\nNoSql 泛指非关系型数据库，并不是要取代关系型数据库，而是关系型数据库的补充\n关系型数据库 (RDBMS)：\nMySQL Oracle DB2 SQLServer 非关系型数据库 (NoSQL)：\nRedis Mongo DB MemCached Redis 下载安装与运行 下载地址：\nWindows: https://github.com/microsoftarchive/redis/releases Linux: https://download.redis.io/releases/ cn: http://www.redis.cn/download.html Windows 版直接解压即可使用，Linux 版：\n解压 tar -zxvf redis-4.0.0.tar.gz -C /usr/local 安装依赖环境 yum install gcc-c++ 进入安装目录，编译 make 进入 redis 的 src 目录安装 make install 相关文件说明：\n/usr/local/redis-4.0.0/src/redis-server：Redis 服务启动脚本 /usr/local/redis-4.0.0/src/redis-cli：Redis 客户端脚本 /usr/local/redis-4.0.0/redis.conf：Redis 配置文件 服务端启动，以 Windows 版为例，启动命令：\n1 redis-server.exe redis.windows.conf 默认端口号为 6379，默认无密码，启动完成后可以用客户端连接\n命令行连接 通过 redis-cli.exe 进行连接\n1 redis-cli.exe -h ip -p port -a password 如果省略，则使用 127.0.0.1:6379\n可以通过修改配置文件 (redis.windows.conf) 设置密码\n1 requirepass 123456 修改完成后重启生效\n图形化连接 Github： https://github.com/qishibo/AnotherRedisDesktopManager 下载安装后新建连接，输入相关信息后连接即可\nDocker 部署 拉取镜像\n1 docker pull redis 获取配置文件，下载对应版本，抽取配置文件即可，Linux 为 redis.conf\n创建 Redis 数据映射文件夹，例如\n1 2 mkdir /home/redis mkdir /home/redis/data 修改配置文件，传送至部署机子，例如使用 scp 从 Win 传至 Linux\n1 scp pathOfFile root@IP:/PathOfFile 启动\n1 docker run -p 6379:6379 --name redis -v /home/redis/redis.conf:/etc/redis/redis.conf -v /home/redis/data:/data -d redis redis-server /etc/redis/redis.conf 参考资料： https://cloud.tencent.com/developer/article/1670205 Redis 数据类型 Redis 的 key 是字符串类型，value 有 5 种常用的数据类型\n字符串 (string)：普通字符串 哈希 (hash)：也叫散列 列表 (list)：按插入顺序排序，可以有重复元素 集合 (set)：无序集合，不允许重复元素 有序集合 (sorted set/zset)：集合中每个元素关联一个分数 (score)，根据分数升序排序 Redis 常用命令 Redis 大小写不敏感\n字符串操作常用命令：\n1 2 3 4 5 6 7 8 # 设置指定 key 值 SET key value # 获取指定 key 值 GET key # 设置指定 key 值，并将 key 的过期时间设为 seconds 秒 SETEX key seconds value # 只在 key 不存在时才设置 key 的值 SETNX key value hash 是一个 string 类型的 field 和 value 映射表，特别适合存储对象，常用命令：\n1 2 3 4 5 6 7 8 9 10 # 将哈希表 key 中的 field 值设为 value HSET key field value # 获取存储在哈希表中指定字段的值 HGET key field # 删除存储在哈希表中的指定字段 HDEL key field # 获取哈希表中所有字段 HKEYS key # 获取哈希表中所有值 HVALS key 列表是简单的字符串列表，按照插入顺序排列，常用命令：\n1 2 3 4 5 6 7 8 9 10 11 # 将一个或多个值插入到列表头部 LPUSH key value1 [value2] # 获取列表指定范围内的元素 LRANGE key start stop # 移除并获取列表最后一个元素 RPOP key # 获取列表长度 LLEN key # 移出并获取列表的最后一个元素 # 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止 BRPOP key1 [key2] timeout 类似队列，先进先出\n集合是字符串类型的无序集合，集合成员唯一，常用命令：\n1 2 3 4 5 6 7 8 9 10 11 12 # 向集合添加一个或多个成员 SADD key member1 [member2] # 返回集合中的所有成员 SMEMBERS key # 获取集合的成员数 SCARD key # 返回给定所有集合的交集 SINTER key2 [key2] # 返回所有给定集合的并集 SUNION key1 [key2] # 移除集合中一个或多个成员 SREM key member1 [member2] 有序集合是字符串类型元素的集合，每个成员关联一个 double 类型的分数，常用命令：\n1 2 3 4 5 6 7 8 # 向有序集合添加一个或多个成员 ZADD key score1 member1 [score2 member2] # 通过索引区间返回有序集合中指定区间内的成员 ZRANGE key start stop [WITHSCORES] # 有序集合中对指定成员的分数加上增量increment ZINCRBY key increment member # 移除有序集合中的一个或多个成员 ZREM key member1 [member2] 除了各数据类型专有，还有通用命令，即所有类型都可以使用的命令：\n1 2 3 4 5 6 7 8 # 查找所有符合给定模式(pattern)的key KEYS pattern # pattern可以为* # 检查指定key是否存在 EXISTS key # 返回key所存储的值的类型 TYPE key # 在key存在时删除key DEL key 在 Java 中操作 Redis 如同使用 JDBC 操作 MySQL 数据库一样，需要使用 Redis 的 Java 客户端进行操作 Redis\nRedis 的 Java 客户端很多，常用的几种：\nJedis Lettuce Spring Data Redis Jedis 封装最好，与 Redis 命令相同，是官方推荐；Lettuce 对线程调用更好，性能更好；Spring 对 Redis 客户端进行了整合，提供了 Spring Data Redis，在 Spring Boot 项目中还提供了对应的 Starter，即 spring-boot-starter-data-redis\nSpring Data Redis Spring Data Redis 是 Spring 的一部分，提供了在 Spring 应用中通过简单的配置就可以访问 Redis 服务，对 Redis 底层开发包进行了高度封装。在 Spring 项目中，可以使用Spring Data Redis来简化 Redis 操作。网址： https://spring.io/projects/spring-data-redis Maven 坐标：\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-data-redis\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; Spring Data Redis 中提供了一个高度封装类 RedisTemplate 对相关 api 进行了归类封装，将同一类型的操作封装为 operation 接口：\nValueOperations：string 数据操作 SetOperations：set 类型数据操作 ZSetOperations：zset 类型数据操作 HashOperations：hash 类型的数据操作 ListOperations：list 类型的数据操作 配置 Redis 数据源，配置文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # application spring: profiles: active: dev redis: host: ${sky.redis.host} port: ${sky.redis.port} password: ${sky.redis.password} database: ${sky.redis.database} # -dev sky: redis: host: localhost port: 6379 password: 123456 # 使用哪个数据库，不填默认为 0 database: 10 Redis 默认有 16 个数据库 (0-15)，可以通过修改配置文件来指定数据库的数量\n编写配置类，创建 RedisTemplate 对象\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 @Configuration @Slf4j public class RedisConfiguration { @Bean public RedisTemplate redisTemplate(RedisConnectionFactory redisConnectionFactory){ log.info(\u0026#34;开始创建 Redis 对象\u0026#34;); RedisTemplate redisTemplate = new RedisTemplate(); // 设置 redis 的连接工厂对象 redisTemplate.setConnectionFactory(redisConnectionFactory); // 设置 redis key 的序列化器 redisTemplate.setKeySerializer(new StringRedisSerializer()); return redisTemplate; } } 此配置类不是必须的，SpringBoot 框架会自动装配 RedisTemplate 对象，不过默认的序列化器为 JdkSerializationRedisSerializer，存储到 Redis 中的数据与原始数据有差别\n字符串类型数据 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @SpringBootTest public class RedisTest { @Autowired private RedisTemplate redisTemplate; @Test public void testString(){ // set redisTemplate.opsForValue().set(\u0026#34;name\u0026#34;, \u0026#34;Tom\u0026#34;); // get String name =(String) redisTemplate.opsForValue().get(\u0026#34;name\u0026#34;); System.out.println(name); // setex redisTemplate.opsForValue().set(\u0026#34;code\u0026#34;, \u0026#34;1234\u0026#34;, 2, TimeUnit.MINUTES); // setnx redisTemplate.opsForValue().setIfAbsent(\u0026#34;lock\u0026#34;,\u0026#34;1\u0026#34;); redisTemplate.opsForValue().setIfAbsent(\u0026#34;lock\u0026#34;,\u0026#34;2\u0026#34;); } } 哈希类型数据 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @Test public void testHash(){ HashOperations hashOperations = redisTemplate.opsForHash(); // hset hashOperations.put(\u0026#34;100\u0026#34;, \u0026#34;name\u0026#34;, \u0026#34;Jerry\u0026#34;); hashOperations.put(\u0026#34;100\u0026#34;, \u0026#34;age\u0026#34;, \u0026#34;20\u0026#34;); // hget String name =(String) hashOperations.get(\u0026#34;100\u0026#34;, \u0026#34;name\u0026#34;); System.out.println(name); // hkeys Set keys = hashOperations.keys(\u0026#34;100\u0026#34;); System.out.println(keys); // hvals List values = hashOperations.values(\u0026#34;100\u0026#34;); System.out.println(values); // hdel hashOperations.delete(\u0026#34;100\u0026#34;, \u0026#34;name\u0026#34;); } 列表类型数据 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Test public void testList(){ ListOperations listOperations = redisTemplate.opsForList(); // lpush listOperations.leftPushAll(\u0026#34;mylist\u0026#34;, \u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;); listOperations.leftPush(\u0026#34;mylist\u0026#34;, \u0026#34;d\u0026#34;); // lrange List mylist = listOperations.range(\u0026#34;mylist\u0026#34;, 0, -1); System.out.println(mylist); // rpop listOperations.rightPop(\u0026#34;mylist\u0026#34;); // llen Long size = listOperations.size(\u0026#34;mylist\u0026#34;); System.out.println(size); } 集合类型数据 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 @Test public void testSet(){ SetOperations setOperations = redisTemplate.opsForSet(); // sadd setOperations.add(\u0026#34;set1\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;,\u0026#34;c\u0026#34;,\u0026#34;d\u0026#34;); setOperations.add(\u0026#34;set2\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;,\u0026#34;x\u0026#34;,\u0026#34;y\u0026#34;); // smembers Set members = setOperations.members(\u0026#34;set1\u0026#34;); System.out.println(members); // scard Long size = setOperations.size(\u0026#34;set1\u0026#34;); System.out.println(size); // sinter Set intersect = setOperations.intersect(\u0026#34;set1\u0026#34;, \u0026#34;set2\u0026#34;); System.out.println(intersect); // sunion Set union = setOperations.union(\u0026#34;set1\u0026#34;, \u0026#34;set2\u0026#34;); System.out.println(union); // srem setOperations.remove(\u0026#34;set1\u0026#34;, \u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;); } 有序集合类型数据 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Test public void testZset(){ ZSetOperations zSetOperations = redisTemplate.opsForZSet(); // zadd zSetOperations.add(\u0026#34;zset1\u0026#34;, \u0026#34;a\u0026#34;, 10); zSetOperations.add(\u0026#34;zset1\u0026#34;, \u0026#34;b\u0026#34;, 12); zSetOperations.add(\u0026#34;zset1\u0026#34;, \u0026#34;c\u0026#34;, 9); // zrange Set zset = zSetOperations.range(\u0026#34;zset1\u0026#34;, 0, -1); System.out.println(zset); // zincrby zSetOperations.incrementScore(\u0026#34;zset1\u0026#34;, \u0026#34;c\u0026#34;, 10); // zrem zSetOperations.remove(\u0026#34;zset1\u0026#34;, \u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;); } 通用命令操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @Test public void testCommon(){ // keys Set keys = redisTemplate.keys(\u0026#34;*\u0026#34;); System.out.println(keys); // exists Boolean name = redisTemplate.hasKey(\u0026#34;name\u0026#34;); System.out.println(name); // type for (Object key : keys) { DataType type = redisTemplate.type(key); System.out.println(type.name()); } // del redisTemplate.delete(\u0026#34;set2\u0026#34;); } ","date":"2024-02-23T16:40:34+08:00","permalink":"https://blog.yexca.net/archives/157/","title":"Redis"},{"content":" Golang 系列\nHello GoLang: https://blog.yexca.net/archives/154 GoLang (var and const) 变量与常量: https://blog.yexca.net/archives/155 GoLang (func) 函数: 本文\nGoLang (slice and map) 切片: https://blog.yexca.net/archives/160 GoLang (OOP) 面向对象: https://blog.yexca.net/archives/162 GoLang (reflect) 反射: https://blog.yexca.net/archives/204 GoLang (struct tag) 结构体标签: https://blog.yexca.net/archives/205 GoLang (goroutine) go 程: https://blog.yexca.net/archives/206 GoLang (channel) 通道: https://blog.yexca.net/archives/207 多返回值 Go 函数可以返回多个值\n匿名返回 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package main import \u0026#34;fmt\u0026#34; func swap(a, b int) (int, int) { return b, a } func main() { var x, y = swap(10, 20) fmt.Println(x, y) } /* 输出 * 20 10 */ 有形参名返回 1 2 3 4 5 6 7 8 9 10 11 12 13 14 package main import \u0026#34;fmt\u0026#34; func swap(a, b int) (x int, y int) { x = b y = a return } func main() { var x, y = swap(10, 20) fmt.Println(x, y) } 上述返回值类型相同，可以合并\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package main import \u0026#34;fmt\u0026#34; func swap(a, b int) (x, y int) { x = b y = a // 如果不给 x,y 赋值，默认为0 return } func main() { var x, y = swap(10, 20) fmt.Println(x, y) } init 与 main init 可以在任意包，也可以在同一个包中出现多次，但建议只写一个\nmain 只能在 package main 中，且该包必须有该函数\n这两个函数为保留函数，定义时不能有参数和返回值\nGo 程序会自动调用 init() 和 main()\n程序执行 程序的初始化和执行都起始于 main 包，同一个包就算被多个包 import 导入也只会导入一次，下图为执行顺序\n例子\n假设结构如下\n1 2 3 4 5 6 hello -- InitLib1 -- lib1.go -- InitLib2 -- lib2.go main.go 内容如下\nlib1.go\n1 2 3 4 5 6 7 package InitLib1 import \u0026#34;fmt\u0026#34; func init() { fmt.Println(\u0026#34;lib1 init\u0026#34;) } lib2.go\n1 2 3 4 5 6 7 package InitLib2 import \u0026#34;fmt\u0026#34; func init() { fmt.Println(\u0026#34;lib2 init\u0026#34;) } main.go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package main import ( \u0026#34;fmt\u0026#34; // 此处下划线为包起别名，不起别名，导入不调用编译不通过 _ \u0026#34;hello/InitLib1\u0026#34; _ \u0026#34;hello/InitLib2\u0026#34; ) func init() { fmt.Println(\u0026#34;main init\u0026#34;) } func main() { fmt.Println(\u0026#34;main\u0026#34;) } 运行结果\n1 2 3 4 lib1 init lib2 init main init main 现在将 Lib1 包导入 Lib2，main 代码不变\nlib1.go\n1 2 3 4 5 6 7 8 9 10 package InitLib1 import ( \u0026#34;fmt\u0026#34; _ \u0026#34;hello/InitLib2\u0026#34; ) func init() { fmt.Println(\u0026#34;lib1 init\u0026#34;) } 运行 main 结果\n1 2 3 4 lib2 init lib1 init main init main lib2 只出现一次\n调用其他包函数 上例使用 _ 作为别名是匿名的，无法调用相应包的方法\n在 lib1 中增加函数\nlib1.go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package InitLib1 import ( \u0026#34;fmt\u0026#34; //_ \u0026#34;hello/InitLib2\u0026#34; ) // 首字母大写才可在其他包调用 func Lib1Test() { fmt.Println(\u0026#34;lib1 test\u0026#34;) } func init() { fmt.Println(\u0026#34;lib1 init\u0026#34;) } main.go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package main import ( \u0026#34;fmt\u0026#34; // 给包起别名 mylib1 \u0026#34;hello/InitLib1\u0026#34; _ \u0026#34;hello/InitLib2\u0026#34; ) func main() { // 通过别名.方法调用 mylib1.Lib1Test() fmt.Println(\u0026#34;main\u0026#34;) } /* * 输出 * lib1 init * lib2 init * lib1 test * main */ 或者可以直接使用 .，文件 main.go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 package main import ( \u0026#34;fmt\u0026#34; // 别名改为 . . \u0026#34;hello/InitLib1\u0026#34; _ \u0026#34;hello/InitLib2\u0026#34; ) func main() { // 直接使用 Lib1Test() fmt.Println(\u0026#34;main\u0026#34;) } 不推荐使用，假设俩包有同名函数，将发生歧义\n指针 与 C 指针类似\n调用函数可以使用两种方式传递参数，值传递与指针 (引用传递) 。默认情况使用值传递，像本文第一段代码即为值传递\n使用 \u0026amp; 可以获取变量对应的内存地址\n1 2 3 4 5 6 7 8 9 10 package main import ( \u0026#34;fmt\u0026#34; ) func main() { var a int fmt.Printf(\u0026#34;%x\u0026#34;, \u0026amp;a) } 引用传递将内存地址传递给函数，函数修改将影响实际参数，同样是交换函数，这次使用指针\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package main import \u0026#34;fmt\u0026#34; func swap(a, b *int) { var tmp = *a *a = *b *b = tmp } func main() { x, y := 10, 20 swap(\u0026amp;x, \u0026amp;y) fmt.Println(\u0026#34;x =\u0026#34;, x, \u0026#34;y =\u0026#34;, y) } defer defer 语句用于预定对一个函数的调用，可以称为延迟函数，作用：\n释放占用的资源 捕捉处理异常 输出日志 类似于 try\u0026hellip;catch\u0026hellip;finally 的 finally\n常用于处理成对的操作，如打开/关闭文件、获取/释放锁、连接/断开连接等，确保资源被适当地释放，即使在发生错误或提前返回的情况下也能保证执行\n如果一个函数中有多个 defer 语句，类似于栈，以 LIFO (后进先出) 顺序执行\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package main import \u0026#34;fmt\u0026#34; func deferDemo() { defer fmt.Println(\u0026#34;1\u0026#34;) defer fmt.Println(\u0026#34;2\u0026#34;) defer fmt.Println(\u0026#34;3\u0026#34;) defer fmt.Println(\u0026#34;4\u0026#34;) } func main() { deferDemo() } /* * 输出 * 4 * 3 * 2 * 1 */ recover 运行时 panic 异常一旦被引发就会导致程序崩溃，recover 为用于 \u0026ldquo;拦截\u0026rdquo; 运行时 panic 的内建函数，类似 Java 的 try\u0026hellip;catch 的抓取异常\nrecover 只有在 defer 调用的函数中有效\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 package main import \u0026#34;fmt\u0026#34; func deferDemo(i int) { var arr [10]int // 错误拦截在错误前设置 defer func() { // 设置recover拦截错误信息 err := recover() if err != nil { fmt.Println(err) } }() arr[i] = 10 } func main() { deferDemo(10) fmt.Println(\u0026#34;main code\u0026#34;) } /* * 输出 * runtime error: index out of range [10] with length 10 * main code */ ","date":"2024-02-22T04:47:28+08:00","permalink":"https://blog.yexca.net/archives/156/","title":"GoLang 函数"},{"content":" Golang 系列\nHello GoLang: https://blog.yexca.net/archives/154 GoLang (var and const) 变量与常量: 本文\nGoLang (func) 函数: https://blog.yexca.net/archives/156 GoLang (slice and map) 切片: https://blog.yexca.net/archives/160 GoLang (OOP) 面向对象: https://blog.yexca.net/archives/162 GoLang (reflect) 反射: https://blog.yexca.net/archives/204 GoLang (struct tag) 结构体标签: https://blog.yexca.net/archives/205 GoLang (goroutine) go 程: https://blog.yexca.net/archives/206 GoLang (channel) 通道: https://blog.yexca.net/archives/207 变量 声明变量一般使用 var 关键字\n单变量 定义类型 不指定初始值的声明，默认为 0\n1 2 3 4 5 6 7 8 package main import \u0026#34;fmt\u0026#34; func main() { var a int fmt.Println(\u0026#34;a =\u0026#34;, a) } 指定初始值，a 为 100\n1 2 3 4 5 6 7 8 package main import \u0026#34;fmt\u0026#34; func main() { var a int = 100 fmt.Println(\u0026#34;a =\u0026#34;, a) } 省略类型 在声明时不知道类型的话，Go 会自动判断变量类型\n1 2 3 4 5 6 7 8 9 10 11 12 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) func main() { var a = 100 fmt.Println(\u0026#34;a =\u0026#34;, a) fmt.Printf(\u0026#34;Type of a = %s\u0026#34;, reflect.TypeOf(a)) } := 基于省略类型会自动判断，可以使用 := 直接声明变量\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) func main() { p := 3.14 fmt.Println(\u0026#34;p =\u0026#34;, p) fmt.Printf(\u0026#34;Type of p is %s\u0026#34;, reflect.TypeOf(p)) } /* * 输出 * p = 3.14 * Type of p is float64 */ 多变量 相同类型 1 2 3 4 5 6 7 8 9 package main import \u0026#34;fmt\u0026#34; func main() { var a, b int fmt.Println(\u0026#34;a =\u0026#34;, a) fmt.Println(\u0026#34;b =\u0026#34;, b) } 相同类型赋值 1 2 3 4 5 6 7 8 9 package main import \u0026#34;fmt\u0026#34; func main() { var a, b int = 100, 200 fmt.Println(\u0026#34;a =\u0026#34;, a) fmt.Println(\u0026#34;b =\u0026#34;, b) } 不同类型 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) func main() { var a, b = 100, 3.14 fmt.Println(\u0026#34;a =\u0026#34;, a) fmt.Printf(\u0026#34;Type of a is %s\\n\u0026#34;, reflect.TypeOf(a)) fmt.Println(\u0026#34;b =\u0026#34;, b) fmt.Printf(\u0026#34;Type of b is %s\u0026#34;, reflect.TypeOf(b)) } /* * 输出 * a = 100 * Type of a is int * b = 3.14 * Type of b is float64 */ 不同类型 2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) func main() { a, b := 100, \u0026#34;Hello\u0026#34; fmt.Println(\u0026#34;a =\u0026#34;, a) fmt.Printf(\u0026#34;Type of a is %s\\n\u0026#34;, reflect.TypeOf(a)) fmt.Println(\u0026#34;b =\u0026#34;, b) fmt.Printf(\u0026#34;Type of b is %s\u0026#34;, reflect.TypeOf(b)) } 字符串类型在 go 里是个结构，包含指向底层数组的指针和长度，这两部分每部分都是 8 个字节，所以字符串类型大小为 16 个字节\n可以使用 unsafe.Sizeof() 函数查看类型占用\n全局变量 全局变量的声明不能使用 :=\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) var a, b int func main() { fmt.Println(\u0026#34;a =\u0026#34;, a) fmt.Printf(\u0026#34;Type of a is %s\\n\u0026#34;, reflect.TypeOf(a)) fmt.Println(\u0026#34;b =\u0026#34;, b) fmt.Printf(\u0026#34;Type of b is %s\u0026#34;, reflect.TypeOf(b)) } 或者使用分解的写法，这种写法一般用于全局变量\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) var ( a int = 1 b string = \u0026#34;Go\u0026#34; ) func main() { fmt.Println(\u0026#34;a =\u0026#34;, a) fmt.Printf(\u0026#34;Type of a is %s\\n\u0026#34;, reflect.TypeOf(a)) fmt.Println(\u0026#34;b =\u0026#34;, b) fmt.Printf(\u0026#34;Type of b is %s\u0026#34;, reflect.TypeOf(b)) } 常量 常量一般用 const 关键字定义\n定义 1 2 3 4 5 6 7 8 package main import \u0026#34;fmt\u0026#34; func main() { const c int = 9 fmt.Println(\u0026#34;c = \u0026#34;, c) } 也可以省略类型\n1 2 3 4 5 6 7 8 package main import \u0026#34;fmt\u0026#34; func main() { const c = 9 fmt.Println(\u0026#34;c = \u0026#34;, c) } 枚举 常量定义可以用于枚举\n1 2 3 4 5 6 7 8 9 package main func main() { const ( BEIJING = 0 SHANGHAI = 1 SHENZHEN = 2 ) } iota 自增长 上述枚举以 0 开始递增，可以使用 iota 代替\n1 2 3 4 5 6 7 8 9 10 11 12 13 package main import \u0026#34;fmt\u0026#34; func main() { const ( BEIJING = iota // 0 SHANGHAI // 1 SHENZHEN // 2 ) fmt.Println(BEIJING, SHANGHAI, SHENZHEN) } iota 可以用于表达式，但一般用于自增\n","date":"2024-02-20T06:41:18+08:00","permalink":"https://blog.yexca.net/archives/155/","title":"GoLang 变量与常量"},{"content":" Golang 系列\nHello GoLang: 本文\nGoLang (var and const) 变量与常量: https://blog.yexca.net/archives/155 GoLang (func) 函数: https://blog.yexca.net/archives/156 GoLang (slice and map) 切片: https://blog.yexca.net/archives/160 GoLang (OOP) 面向对象: https://blog.yexca.net/archives/162 GoLang (reflect) 反射: https://blog.yexca.net/archives/204 GoLang (struct tag) 结构体标签: https://blog.yexca.net/archives/205 GoLang (goroutine) go 程: https://blog.yexca.net/archives/206 GoLang (channel) 通道: https://blog.yexca.net/archives/207 Go 下载： https://go.dev/dl/ JetBrains GoLand： https://www.jetbrains.com/go/ Go 简介 Go 可以直接编译，直接运行即可部署，静态类型语言\n1 2 3 4 5 6 7 # 直接运行 go run hello.go # 编译 go build hello.go # 编译后运行 ./hello Go 的一些应用\n(1)、云计算基础设施领域\n代表项目：docker、kubernetes、etcd、consul、cloudflare CDN、七牛云存储等\n(2)、基础后端软件\n代表项目：tidb、influxdb、cockroachdb 等\n(3)、微服务\n代表项目：go-kit、micro、monzo bank的typhon、bilibili 等\n(4)、互联网基础设施\n代表项目：以太坊、hyperledger 等\nHello Go 1 2 3 4 5 6 7 8 9 10 11 package main // 定义包名 /* * 必须在源文件非注释第一行指明文件属于哪个包 * main 表示一个可独立执行的程序，每个 Go 应用程序都包含一个名为 main 的包 */ import \u0026#34;fmt\u0026#34; // 导入 fmt 包，实现了格式化 IO 的函数 func main(){ // 函数 fmt.println(\u0026#34;Hello Go\u0026#34;) } 一般 mian 函数是启动后第一个执行的函数，如果有 init 函数会先执行 init 函数\n定义函数时，{ 必须与函数名在同一行\n","date":"2024-02-19T07:58:37+08:00","permalink":"https://blog.yexca.net/archives/154/","title":"Hello GoLang"},{"content":"这是什么时候写的文章啊（\n查看是否有 Xfce 组 1 yum grouplist 如果没有，需要安装额外包 yum 源\n1 yum install epel-release -y 安装 X Window system 1 yum groupinstall \u0026#34;X Window system\u0026#34; 安装 Xfce 1 yum groupinstall xfce 安装中文字体 (楷体) 1 yum install cjkuni-ukai-fonts 进入 Xfce 桌面 1 systemctl isolate graphical.target 参考文章 CentOS 7安装Xfce桌面环境过程_qq_28641401的博客-CSDN博客 ","date":"2024-02-17T22:51:34+08:00","permalink":"https://blog.yexca.net/archives/153/","title":"CentOS 7 安装 Xfce"},{"content":"Happy Lunar Year!\n流程： https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/login.html 前端获取授权码，向 https://api.weixin.qq.com/sns/jscode2session 发起请求，获取 session_key 和 openid\n微信请求接口： https://developers.weixin.qq.com/miniprogram/dev/OpenApiDoc/user-login/code2Session.html 分析设计 接口设计 请求路径：/user/user/login\n请求方式：POST\n请求参数：code String (微信用户授权码)\n返回数据：\nid integer (用户 id) openid (微信 openid) token (jwt 令牌) 数据库表设计 用户第一次使用小程序会自动注册，将相关信息存储到 user 表\n字段名 数据类型 说明 id bigint 主键，自增 openid varchar(45) 微信用户唯一标识 name varchar(32) 用户姓名 phone varchar(11) 手机号 gender varchar(2) 性别 id_number varchar(18) 身份证号 avatar varchar(500) 微信用户头像路径 create_time datetime 注册时间 个人身份注册的小程序没有权限获取到微信用户的手机号\n程序配置 首先配置微信登录所需参数\napplication-dev.yml\n1 2 3 4 sky: wechat: appid: your_appid secret: your_secret application.yml\n1 2 3 4 sky: wechat: appid: ${sky.wechat.appid} secret: ${sky.wechat.secret} 配置为微信用户生成 jwt 令牌时使用的配置项\n1 2 3 4 5 6 sky: jwt: # 用户相关 user-secret-key: key user-ttl: 7200000 user-token-name: authentication Java 业务代码 controller\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 @RestController @RequestMapping(\u0026#34;/user/user\u0026#34;) @Api(tags = \u0026#34;用户相关接口\u0026#34;) @Slf4j public class UserController { @Autowired private UserService userService; @Autowired private JwtProperties jwtProperties; @PostMapping(\u0026#34;/login\u0026#34;) @ApiOperation(\u0026#34;微信登录\u0026#34;) public Result\u0026lt;UserLoginVO\u0026gt; login(@RequestBody UserLoginDTO userLoginDTO){ log.info(\u0026#34;微信用户登录：{}\u0026#34;, userLoginDTO.getCode()); // 微信登录 User user = userService.wxlogin(userLoginDTO); // 为微信用户生成jwt令牌 HashMap\u0026lt;String, Object\u0026gt; claims = new HashMap\u0026lt;\u0026gt;(); claims.put(JwtClaimsConstant.USER_ID, user.getId()); String token = JwtUtil.createJWT(jwtProperties.getUserSecretKey(), jwtProperties.getUserTtl(), claims); UserLoginVO userLoginVO = UserLoginVO.builder() .id(user.getId()) .openid(user.getOpenid()) .token(token) .build(); return Result.success(userLoginVO); } } service\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 @Service @Slf4j public class UserServiceImpl implements UserService { // 微信接口 public static final String WX_LOGIN = \u0026#34;https://api.weixin.qq.com/sns/jscode2session\u0026#34;; @Autowired private WeChatProperties weChatProperties; @Autowired private UserMapper userMapper; @Override public User wxlogin(UserLoginDTO userLoginDTO) { String openid = getOpenid(userLoginDTO.getCode()); // 判断openid是否合法 if (openid == null){ throw new LoginFailedException(MessageConstant.LOGIN_FAILED); } // 判断是否为新用户 User user = userMapper.getByOpenid(openid); // 若为新用户，自动注册 if (user == null){ user = User.builder() .openid(openid) .createTime(LocalDateTime.now()) .build(); userMapper.insert(user); } return user; } // 调用微信接口，获取用户openid private String getOpenid(String code){ Map\u0026lt;String,String\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(\u0026#34;appid\u0026#34;, weChatProperties.getAppid()); map.put(\u0026#34;secret\u0026#34;, weChatProperties.getSecret()); map.put(\u0026#34;js_code\u0026#34;, code); map.put(\u0026#34;grant_type\u0026#34;, \u0026#34;authorization_code\u0026#34;); String json = HttpClientUtil.doGet(WX_LOGIN, map); JSONObject jsonObject = JSON.parseObject(json); String openid = jsonObject.getString(\u0026#34;openid\u0026#34;); return openid; } } Mapper\n1 2 3 4 5 6 7 @Mapper public interface UserMapper { @Select(\u0026#34;select * from user where openid = #{openid}\u0026#34;) User getByOpenid(String openid); void insert(User user); } Mapper XML\n1 2 3 4 5 6 7 8 9 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34; \u0026gt; \u0026lt;mapper namespace=\u0026#34;com.sky.mapper.UserMapper\u0026#34;\u0026gt; \u0026lt;insert id=\u0026#34;insert\u0026#34;\u0026gt; insert into user(openid, name, phone, sex, id_number, avatar, create_time) VALUES (#{openid}, #{name}, #{phone}, #{sex}, #{idNumber}, #{avatar}, #{createTime}) \u0026lt;/insert\u0026gt; \u0026lt;/mapper\u0026gt; 拦截器 统一拦截用户端发送的请求进行 jwt 校验\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 @Component @Slf4j public class JwtTokenUserInterceptor implements HandlerInterceptor { @Autowired private JwtProperties jwtProperties; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { // 判断拦截类型，是controller还是其他资源 if(!(handler instanceof HandlerMethod)){ // 当前拦截的不是动态方法，直接放行 return true; } // 从请求中获取令牌 String token = request.getHeader(jwtProperties.getUserTokenName()); // 校验令牌 try { log.info(\u0026#34;jwt校验：{}\u0026#34;, token); Claims claims = JwtUtil.parseJWT(jwtProperties.getUserSecretKey(), token); Long userId = Long.valueOf(claims.get(JwtClaimsConstant.USER_ID).toString()); log.info(\u0026#34;当前用户id：{}\u0026#34;, userId); BaseContext.setCurrentId(userId); // 校验通过 return true; }catch (Exception ex){ // 校验未通过 return false; } } } 在 WebMvcConfiguration 注册拦截器\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Autowired private JwtTokenUserInterceptor jwtTokenUserInterceptor; /** * 注册自定义拦截器 * @param registry */ protected void addInterceptors(InterceptorRegistry registry) { log.info(\u0026#34;开始注册自定义拦截器...\u0026#34;); //......... registry.addInterceptor(jwtTokenUserInterceptor) .addPathPatterns(\u0026#34;/user/**\u0026#34;) .excludePathPatterns(\u0026#34;/user/user/login\u0026#34;) .excludePathPatterns(\u0026#34;/user/shop/status\u0026#34;); } ","date":"2024-02-10T18:09:17+08:00","permalink":"https://blog.yexca.net/archives/152/","title":"微信登录后端"},{"content":"官网： https://mp.weixin.qq.com/cgi-bin/wx 开发小程序之前需要先注册一个小程序，可以使用不同主体注册小程序，相应的权限也不同。例如以个人的身份注册小程序是无法获得支付权限的 (也可以使用测试号体验)\n注册完成后设置相关信息，获取 AppID 与 AppSecret，下载 开发者工具 ，登录，创建项目\n首先右上 详情-本地设置，勾选 不校验合法域名、web-view(业务域名)、TLS 版本以及 HTTPS 证书\n小程序的开发属于前端开发，主要使用 JavaScript\n小程序目录结构 小程序包含一个描述整体程序的 app 和多个描述各自页面的 page\n主体部分 由三个文件组成，必须放在项目的根目录\n文件 作用 app.js 小程序逻辑 app.json 小程序公共配置 app.wxss 小程序公共样式表，非必须文件，类似 CSS 页面 一个小程序有多个页面，存放在 pages 目录\n每个页面由四个文件组成\n文件类型 是否必须 作用 js 是 页面逻辑，JavaScript wxml 是 页面结构、布局，HTML json 否 页面配置 wxss 否 页面样式表，CSS 简单入门 小程序的编写风格类似于 Vue\n插值 wxml\n1 \u0026lt;view\u0026gt;{{title}}\u0026lt;/view\u0026gt; js\n1 2 3 4 5 Page({ data: { title: \u0026#39;Hello\u0026#39; } }) 获取用户信息 wxml\n1 2 3 4 \u0026lt;view\u0026gt; \u0026lt;button type=\u0026#34;default\u0026#34; bindtap=\u0026#34;getUserInfo\u0026#34;\u0026gt;获取用户信息\u0026lt;/button\u0026gt; \u0026lt;image src=\u0026#34;{{avatarUrl}}\u0026#34; style=\u0026#34;width: 100px; height: 100px;\u0026#34;/\u0026gt;{{nickName}} \u0026lt;/view\u0026gt; js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 Page({ data: { title: \u0026#39;Hello\u0026#39;, avatarUrl: \u0026#39;\u0026#39;, nickName: \u0026#39;\u0026#39; }, getUserInfo: function(){ wx.getUserProfile({ desc: \u0026#39;获取用户信息\u0026#39;, success: (res) =\u0026gt; { console.log(res); this.setData({ avatarUrl: res.userInfo.avatarUrl, nickName: res.userInfo.nickName }) } }) } }) 微信登录 wxml\n1 2 3 4 \u0026lt;view\u0026gt; \u0026lt;button type=\u0026#34;primary\u0026#34; bind:tap=\u0026#34;wxlogin\u0026#34;\u0026gt;微信登录\u0026lt;/button\u0026gt; 授权码：{{code}} \u0026lt;/view\u0026gt; js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 Page({ data: { code: \u0026#39;\u0026#39; }, wxlogin: function(){ wx.login({ success: (res) =\u0026gt; { console.log(\u0026#34;授权码：\u0026#34; + res.code); this.setData({ code: res.code }) }, }) } }) 微信登录流程： https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/login.html 发送 HTTP 请求 wxml\n1 2 3 4 \u0026lt;view\u0026gt; \u0026lt;button type=\u0026#34;warn\u0026#34; bind:tap=\u0026#34;sendRequest\u0026#34;\u0026gt;发送请求\u0026lt;/button\u0026gt; 响应结果：{{result}} \u0026lt;/view\u0026gt; js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 Page({ data: { result: \u0026#39;\u0026#39; }, sendRequest: function(){ wx.request({ url: \u0026#39;url\u0026#39;, // 请求路径 method: \u0026#39;GET\u0026#39;, // 请求方式 success: (res) =\u0026gt; { console.log(\u0026#34;响应结果：\u0026#34; + res.data); this.setData({ result: res.data // 响应数据 }) } }) } }) 编译与发布 上方编译按钮，编译完成后在左方预览\n代码开发完毕后，上传，指定版本号。上传成功后在微信公众平台提交审核后可以发布为线上版本\n","date":"2024-01-31T16:50:34+08:00","permalink":"https://blog.yexca.net/archives/151/","title":"了解微信小程序"},{"content":"引言 HTML 学习一 - 基础: https://blog.yexca.net/archives/146 HTML 学习二 - 列表、表格与表单: https://blog.yexca.net/archives/150 HTML 学习三 - 网页布局: https://blog.yexca.net/archives/195 列表 列表分为无序、有序列表和定义列表\n无序列表 unordered list -\u0026gt; list\n1 2 3 4 5 \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;第一项\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;第二项\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;第三项\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; 效果如下\n第一项\r第二项\r第三项\r有序列表 ordered list -\u0026gt; list\n1 2 3 4 5 \u0026lt;ol\u0026gt; \u0026lt;li\u0026gt;第一项\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;第二项\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;第三项\u0026lt;/li\u0026gt; \u0026lt;/ol\u0026gt; 效果如下\n第一项\r第二项\r第三项\r定义列表 个人记忆: define list -\u0026gt; define title -\u0026gt; define describe\n1 2 3 4 5 6 7 8 \u0026lt;dl\u0026gt; \u0026lt;dt\u0026gt;第一标题\u0026lt;/dt\u0026gt; \u0026lt;dd\u0026gt;1.1 描述\u0026lt;/dd\u0026gt; \u0026lt;dd\u0026gt;1.2 描述\u0026lt;/dd\u0026gt; \u0026lt;dt\u0026gt;第二标题\u0026lt;/dt\u0026gt; \u0026lt;dd\u0026gt;2.1 描述\u0026lt;/dd\u0026gt; \u0026lt;dd\u0026gt;2.2 描述\u0026lt;/dd\u0026gt; \u0026lt;/dl\u0026gt; 效果如下\n第一标题\r1.1 描述\r1.2 描述\r第二标题\r2.1 描述\r2.2 描述\rdl 标签里只能包含 dt 和 dd 标签，而 dt 和 dd 标签里可以包含任何内容\n表格 标签 说明 个人记忆 table 定义表格 tr 表格的行 table row th 表头单元格 table head td 内容单元格 table data 以下结构标签可以省略，主要是面向浏览器\n标签 说明 thead 定义头部内容 tbody 定义表格主体 tfoot 定义表格底部，汇总信息 表格示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 \u0026lt;table\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;\\\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;x\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;y\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;total\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tbody\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;a\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;50\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;50\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;100\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;b\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;50\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;50\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;100\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/tbody\u0026gt; \u0026lt;tfoot\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;total\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;100\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;100\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;100\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/tfoot\u0026gt; \u0026lt;/table\u0026gt; 效果如下\n\\\rx\ry\rtotal\ra\r50\r50\r100\rb\r50\r50\r100\rtotal\r100\r100\r100\r单元格合并 表格合并分为跨行合并与跨列合并，合并后应该删除被合并的单元格\n属性 说明 rowspan 跨行合并，值为合并的行数 colspan 跨列合并，值为合并的列数 例如将以上表格第二行第二列与第三行第二列跨行合并，最后一行最后三列跨列合并\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 \u0026lt;table\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;\\\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;x\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;y\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;total\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tbody\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;a\u0026lt;/td\u0026gt; \u0026lt;!-- 此处增加跨行合并属性 --\u0026gt; \u0026lt;td rowspan=\u0026#34;2\u0026#34;\u0026gt;50\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;50\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;100\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;b\u0026lt;/td\u0026gt; \u0026lt;!-- 此内容可以删除，此处注释 --\u0026gt; \u0026lt;!--\u0026lt;td\u0026gt;50\u0026lt;/td\u0026gt;--\u0026gt; \u0026lt;td\u0026gt;50\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;100\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/tbody\u0026gt; \u0026lt;tfoot\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;total\u0026lt;/td\u0026gt; \u0026lt;!-- 此处增加跨列合并属性 --\u0026gt; \u0026lt;td colspan=\u0026#34;3\u0026#34;\u0026gt;100\u0026lt;/td\u0026gt; \u0026lt;!-- 此内容可以删除，此处注释 --\u0026gt; \u0026lt;!--\u0026lt;td\u0026gt;100\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;100\u0026lt;/td\u0026gt;--\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/tfoot\u0026gt; \u0026lt;/table\u0026gt; 效果如下\n\\\rx\ry\rtotal\ra\r50\r50\r100\rb\r50\r100\rtotal\r100\r如果使用了结构标签 (thead, tbody, tfoot) 则不能跨结构合并，例如以上表格第三行不能和最后一行合并\n表单 form 标签 一张表单需要使用 form 标签确定表单的区域，以下所述标签需要放在 form 标签内\ninput 标签 多数表单使用 input 标签实现，根据 type 属性值的不同，实现不同功能\ntype 属性值 说明 text 文本框 password 密码框 radio 单选框 checkbox 多选框 file 上传文件 占位文本 占位文本即提示信息，文本框和密码框可以使用\n1 \u0026lt;input type=\u0026#34;text\u0026#34; placeholder=\u0026#34;提示信息\u0026#34; /\u0026gt; 效果如下\n单选框 radio 属性 作用 name 控件名称 checked 默认选中 以下代码实现选择性别\n1 2 3 性别： \u0026lt;input type=\u0026#34;radio\u0026#34; name=\u0026#34;gender\u0026#34; checked /\u0026gt;男 \u0026lt;input type=\u0026#34;radio\u0026#34; name=\u0026#34;gender\u0026#34; /\u0026gt;女 效果如下\n性别：\r男\r女\r文件上传 默认情况下 file 类型只能上传一个文件，若要上传多个文件，可以添加 multiple 属性\n1 \u0026lt;input type=\u0026#34;file\u0026#34; multiple /\u0026gt; 多选框 checkbox 又称复选框，默认选择可以使用属性 checked\n1 2 3 4 \u0026lt;input type=\u0026#34;checkbox\u0026#34; checked /\u0026gt; a \u0026lt;input type=\u0026#34;checkbox\u0026#34; /\u0026gt; b \u0026lt;input type=\u0026#34;checkbox\u0026#34; /\u0026gt; c \u0026lt;input type=\u0026#34;checkbox\u0026#34; /\u0026gt; d 下拉菜单 1 2 3 4 5 6 7 \u0026lt;select\u0026gt; \u0026lt;option\u0026gt;CN\u0026lt;/option\u0026gt; \u0026lt;option\u0026gt;USA\u0026lt;/option\u0026gt; \u0026lt;option\u0026gt;UK\u0026lt;/option\u0026gt; \u0026lt;!-- selected 指定默认选中 --\u0026gt; \u0026lt;option selected\u0026gt;JP\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; 文本域 实现多行输入文本的表单控件，一般为个人简介\n1 \u0026lt;textarea\u0026gt;提示信息\u0026lt;/textarea\u0026gt; label 标签 用于网页中某个标签的说明文本，还可以用于绑定文字和表单控件的关系，增大表单控件的点击范围\n例如上述性别单选框只有选中圆圈才可选择单选框，而使用此标签后可以实现选择文字也可选中单选框\n方法一 input 标签添加 id 属性，label 标签添加 for 属性，俩属性值相同\n1 2 3 4 \u0026lt;input type=\u0026#34;radio\u0026#34; name=\u0026#34;gender\u0026#34; id=\u0026#34;male\u0026#34;/\u0026gt; \u0026lt;label for=\u0026#34;male\u0026#34;\u0026gt;男\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;radio\u0026#34; name=\u0026#34;gender\u0026#34; id=\u0026#34;female\u0026#34;/\u0026gt; \u0026lt;label for=\u0026#34;female\u0026#34;\u0026gt;女\u0026lt;/label\u0026gt; 方法二 直接使用 label 标签包裹文字和表单控件\n1 2 \u0026lt;label\u0026gt;\u0026lt;input type=\u0026#34;radio\u0026#34; name=\u0026#34;gender\u0026#34; /\u0026gt;男\u0026lt;/label\u0026gt; \u0026lt;label\u0026gt;\u0026lt;input type=\u0026#34;radio\u0026#34; name=\u0026#34;gender\u0026#34; /\u0026gt;女\u0026lt;/label\u0026gt; 支持 label 标签增大点击范围的控件包括：文本框、密码框、上传文件、单选框、复选框、下拉菜单、文本域等\n按钮 button 标签根据 type 属性值的不同，功能不同\ntype 属性值 说明 submit 默认功能，提交数据到后台 reset 重置按钮，将表单控件恢复默认值 button 普通按钮，需配合 JavaScript 使用 1 \u0026lt;button type=\u0026#34;\u0026#34;\u0026gt;按钮\u0026lt;/button\u0026gt; ","date":"2024-01-29T13:24:25+08:00","permalink":"https://blog.yexca.net/archives/150/","title":"HTML 学习二 - 列表、表格与表单"},{"content":"引言 千万不要把死循环放进去啊！！！使用 systemd 方式\n新建脚本 在此文件中写入您的脚本\n1 vi /etc/rc.d/rc.local 赋予执行权限\n1 chmod +x /etc/rc.d/rc.local 编辑启动状态 编辑文件\n1 vi /usr/lib/systemd/system/rc-local.service 在最后一行加入 [Install]\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # This file is part of systemd. # # systemd is free software; you can redistribute it and/or modify it # under the terms of the GNU Lesser General Public License as published by # the Free Software Foundation; either version 2.1 of the License, or # (at your option) any later version. # This unit gets pulled automatically into multi-user.target by # systemd-rc-local-generator if /etc/rc.d/rc.local is executable. [Unit] Description=/etc/rc.d/rc.local Compatibility ConditionFileIsExecutable=/etc/rc.d/rc.local After=network.target [Service] Type=forking ExecStart=/etc/rc.d/rc.local start TimeoutSec=0 RemainAfterExit=yes SysVStartPriority=99 [Install] WantedBy=multi-user.target 然后使用 systemd 开机自启动\n1 systemctl enable rc-local.service 查看启动状态 使用以下命令\n1 systemctl status rc-local.service 参考文章 Fedora 22(15以上版本)开机自启动脚本 - 可酷可乐 - 博客园 ","date":"2024-01-28T14:25:58+08:00","permalink":"https://blog.yexca.net/archives/149/","title":"Fedora 开机启动运行脚本"},{"content":"JS 是一门跨平台、面向对象的脚本语言，是用来控制网页行为的，使网页可交互\nJS 引入方式 分为内部脚本和外部脚本两种\n内部脚本 将 js 代码定义在 HTML 页面中\nJS 代码必须位于 \u0026lt;script\u0026gt;\u0026lt;/script\u0026gt; 标签之间 在 HTML 文档中，可以在任意地方，放置任意数量的 \u0026lt;script\u0026gt; 一般会把脚本置于 \u0026lt;body\u0026gt; 元素的底部，可以改善显示速度 1 2 3 \u0026lt;script\u0026gt; alert(\u0026#34;Hello JavaScript\u0026#34;) \u0026lt;/script\u0026gt; 外部脚本 将 JS 代码定义在外部 JS 文件中，然后引入到 HTML 页面中\n外部 JS 文件中，只包含 JS 代码，不包含 \u0026lt;script\u0026gt; 标签 1 2 3 4 5 \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;script src=\u0026#34;./js/1.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;/html\u0026gt; JS 文件内容\n1 alert(\u0026#34;Hello JavaScript\u0026#34;) JS 基础语法 区分大小写，每行结尾的分号可有可无。注释有两种\n1 2 3 4 5 // 单行注释 /* 多行注释 */ 大括号表示代码块\n1 2 3 4 // 判断 if(count==3){ alert(count); } 输出语句 可以输出到警告框、HTML 或控制台\n1 2 3 4 5 6 // 浏览器弹出警告框 window.alert(\u0026#34;Hello from alert\u0026#34;) // 写入HTML在浏览器展示 document.write(\u0026#34;Hello from HTML\u0026#34;) // 写入浏览器控制台 console.log(\u0026#34;Hello from console\u0026#34;) 变量 JS 是一门弱类型语言，变量可以存放不同类型的值，变量名需要遵循如下规则：\n组成字符可以是任意字母、数字、下划线或者美元符号 数字不能开头 建议使用驼峰命名 定义变量有三个关键字 vat、let 和 const\nvar var 是 variable 的缩写，声明的变量为全局变量，可以重复定义\n1 2 3 4 5 6 7 8 9 10 // 重复声明 var a = 1; var a = \u0026#39;A\u0026#39;; alert(a); // 全局变量 { var b = \u0026#39;B\u0026#39;; } alert(b); let 在 ECMAScript6 新增，所声明的变量只在 let 所在的代码块内有效，且不允许重复声明\n1 2 3 4 5 6 7 8 let a = \u0026#39;A\u0026#39;; alert(a); // 局部变量 { let a=\u0026#39;A\u0026#39;; } alert(a); // 无输出，且在控制台报错 const 用来声明一个只读的常量，一旦声明，无法被改变\n1 2 3 const a = \u0026#39;A\u0026#39;; a = 1; alert(a); // 无输出，且在控制台报错 数据类型 JS 中分为原始类型和引用类型，即基本数据类型与对象\n原始类型有五种：\nnumber：数字 (整数、小数、NaN (Not a Number)) string：字符串，单双引皆可 boolean：布尔。true 和 false null：对象为空 undefined：当声明的对象未初始化时，该变量默认值是 undefined 使用 typeof 运算符可以获取数据类型\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // number console.log(\u0026#34;number 类型\u0026#34;); console.log(typeof 3); console.log(typeof 3.14); // string console.log(\u0026#34;\\nstring 类型\u0026#34;); console.log(typeof \u0026#39;A\u0026#39;); console.log(typeof \u0026#34;string\u0026#34;); // boolean console.log(\u0026#34;\\nboolean 类型\u0026#34;); console.log(typeof true); console.log(typeof false); // null - object console.log(\u0026#34;\\nnull-object 类型\u0026#34;); console.log(typeof null); // undefined var a; console.log(\u0026#34;\\nundefined 类型\u0026#34;); console.log(typeof a); 您也许会问，为什么 typeof 运算符对于 null 值会返回 \u0026ldquo;Object\u0026rdquo;。这实际上是 JavaScript 最初实现中的一个错误，然后被 ECMAScript 沿用了。现在，null 被认为是对象的占位符，从而解释了这一矛盾，但从技术上来说，它仍然是原始值\nReference: https://www.w3school.com.cn/js/pro_js_primitivetypes.asp 运算符 算数运算符：+、-、*、/、%、++、\u0026ndash; 赋值运算符：=、+=、-=、*=、/=、%= 比较运算符：\u0026gt;、\u0026lt;、\u0026gt;=、\u0026lt;=、!=、==、=== 逻辑运算符：$$、||、! 三元运算符：condition ? true : false == 与 ===\n== 会进行类型转换，而 === 不会进行类型转换，即类型与值都相等才为 true\n1 2 3 4 5 6 7 var a = 20; var aStr = \u0026#34;20\u0026#34;; var aInt = 20; console.log(a==aStr); // true console.log(a===aStr);// false console.log(a===aInt);// true 类型转换 字符串转换为数字使用 parseInt() 函数即可\n转换是从第一个字符开始，直到遇到非数值。若开始非数值，则转为 NaN\n1 2 3 4 5 6 7 var a = \u0026#34;12\u0026#34;; var b = \u0026#34;12A34\u0026#34;; var c = \u0026#34;A34\u0026#34;; console.log(parseInt(a)); // 12 console.log(parseInt(b)); // 12 console.log(parseInt(c)); // NaN 其他类型转为 Boolean\nNumber：0 和 NaN 为 false，其他均为 true String：空字符串为 false，其他均为 true Null 和 undefined：均为 false 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // number if (0) { console.log(\u0026#34;0\u0026#34;); } if (NaN) { console.log(\u0026#34;NaN\u0026#34;); } if (-1) { console.log(\u0026#34;-1\u0026#34;); } // 运行结果：-1 // String if (\u0026#34;\u0026#34;) { console.log(\u0026#34;空字符\u0026#34;); } if (\u0026#34; \u0026#34;) { console.log(\u0026#34;空格\u0026#34;); } // 运行结果：空格 // Null 和 undefined if (null) { console.log(\u0026#34;null\u0026#34;) } if (undefined) { console.log(\u0026#34;undefined\u0026#34;) } if (1) { console.log(\u0026#34;null 和 undefined 都是 false\u0026#34;) } // 运行结果：null 和 undefined 都是 false 流程控制 if\u0026hellip;else if\u0026hellip;else switch for while do\u0026hellip;while Reference: https://www.w3school.com.cn/jsref/jsref_statements.asp 函数 函数是被设计为执行特定任务的代码块\n函数的定义有两种形式，通常的语法为\n1 2 3 function functionName(var1,var2,...){ // code } 其中：\n形式参数不需要类型 返回值也不需要定义类型，可以之间在函数内部 return 返回 1 2 3 4 5 6 function add1(a, b){ return a+b; } var result = add1(10, 20); console.log(result); // 30 定义函数的方式二\n1 2 3 var functionName = function(var1, var2,...){ // code } 上例采用此方法\n1 2 3 4 5 6 var add2 = function(a, b){ return a+b; } var result = add2(10, 20); console.log(result); // 30 JS 中，函数调用可以传递任意个数的参数，但只接收定义形参个数\n对象 基础对象、浏览器对象模型 BOM、文档对象模型 DOM\nArray 数组 定义方法一\n1 2 3 var name = new Array(element1,element2,...); // 例如 var arr = new Array(1,2,3,4); 定义方法二\n1 2 3 var name = [element]; // 例如 var arr = [1,2,3,4]; 访问与赋值\n1 2 3 4 // 访问，下标从0开始 arr[2]; // 赋值 arr[4]=5; 数组长度可变，也可以存储任意类型的数据\n1 2 3 4 5 6 7 8 9 10 var arr = [1,2,3,4]; // console.log(arr); // 长度可变 arr[9] = 8; // console.log(arr); // 类型可变 arr[8] = \u0026#39;A\u0026#39;; console.log(arr); 属性 length 属性可以返回数组中元素的数量，用此属性遍历数组\n1 2 3 4 var arr = [1,2,3,4]; for (let i = 0; i \u0026lt; arr.length; i++) { console.log(arr[i]); } 方法 方法 描述 forEach() 遍历数组中的每个有值的元素，并调用一次传入的函数 push() 将新元素添加到数组的末尾，并返回新的长度 splice() 从数组中删除元素 forEach 遍历\n1 2 3 4 var arr = [1,2,3,4]; arr.forEach(function(e){ console.log(e); }) 上述代码可以用箭头函数简化\n1 2 3 4 // 箭头函数：(...) =\u0026gt; {...} 简化函数定义 arr.forEach(e =\u0026gt; { console.log(e); }); push 函数添加数值\n1 2 3 4 var arr = [1,2,3,4]; // 可以有多个值 arr.push(5,6,7,8); console.log(arr);// [1,2,3,4,5,6,7,8] splice 删除元素\n1 2 3 4 5 var arr = [1,2,3,4];// [1,2,3,4,5,6,7,8] arr.push(5,6,7,8); // 从第几个元素开始，删除几个元素 arr.splice(2,4); // 从第2个元素开始，删除4个元素 console.log(arr);// [1,2,7,8] 两种遍历的区别 for 遍历会遍历所有元素，包括 undefined。而 forEach 仅遍历有值元素\n1 2 3 4 5 6 7 8 9 10 11 12 var arr = [1,2,3,4]; arr[9] = 10; for (let i = 0; i \u0026lt; arr.length; i++) { console.log(arr[i]); }// 1,2,3,4,undefined,,,,,10 console.log(\u0026#34;==============================\u0026#34;); arr.forEach(e =\u0026gt; { console.log(e); })// 1,2,3,4,10 String 字符串 创建方式有两种\n1 2 3 4 // 方式一 var name = new String(\u0026#34;\u0026#34;); // 方式二 var name = \u0026#34;\u0026#34;; // 单双引皆可 属性与方法 属性或方法 描述 length 字符串的长度 charAt() 返回在指定位置的字符 indexOf() 检索字符串 trim() 去除字符串两边的空格 substring() 提取字符串中两个指定的索引号之间的字符 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 var str = \u0026#34;Hello String\u0026#34;; console.log(str.length); // 12 // 从0开始 console.log(str.charAt(4)); // 0 console.log(str.indexOf(\u0026#34;lo\u0026#34;)); // 3 var s = \u0026#34; Hello String \u0026#34;; var s = s.trim(); console.log(s); // Hello String // 开始，结束，含头不含尾 var s = s.substring(0,5); console.log(s); // Hello JS 自定义对象 定义格式\n1 2 3 4 5 6 var 对象名 = { 属性名: 属性值, 函数名: function(形参){ } } 例如\n1 2 3 4 5 6 7 8 9 10 11 var person = { name: \u0026#34;tom\u0026#34;, age: 18, gender: \u0026#34;male\u0026#34;, eat: function(){ console.log(\u0026#34;恰饭nya\u0026#34;); } } console.log(person.age); person.eat(); 其中方法有简写\n1 2 3 4 5 6 7 8 9 10 11 var person = { name: \u0026#34;tom\u0026#34;, age: 18, gender: \u0026#34;male\u0026#34;, // eat: function(){ // console.log(\u0026#34;恰饭nya\u0026#34;); // } eat(){ console.log(\u0026#34;恰饭nya\u0026#34;); } } JSON JavaScript Object Notation，JavaScript 对象标记法，JSON 是通过 JavaScript 对象标记法书写的文本，由于其语法简单，层次结构鲜明，现多用于作为数据载体，在网络中进行数据传输\n定义与实例\n1 2 3 4 // 定义 var 变量名 = \u0026#39;{\u0026#34;key1\u0026#34;:value1,\u0026#34;key2\u0026#34;:value2}\u0026#39;; // 示例 var userStr = \u0026#39;{\u0026#34;name\u0026#34;:\u0026#34;Tom\u0026#34;,\u0026#34;age\u0026#34;:18,\u0026#34;addr\u0026#34;:[\u0026#34;北京\u0026#34;,\u0026#34;上海\u0026#34;]}\u0026#39;; 其中 value 的数据类型为：\n数字 (整数或浮点数) 字符串 (在双引号中) 逻辑值 (true 或 false) 数组 (在方括号中) 对象 (在花括号中) null 在 JS 中有把对象转为 JSON 字符串的方法\n1 var jsonStr = JSON.stringify(jsObject) 也有把 JSON 字符串转为对象的方法\n1 2 var userStr = \u0026#39;{\u0026#34;name\u0026#34;:\u0026#34;Tom\u0026#34;,\u0026#34;age\u0026#34;:18,\u0026#34;addr\u0026#34;:[\u0026#34;北京\u0026#34;,\u0026#34;上海\u0026#34;]}\u0026#39;; var jsObject = JSON.parse(userStr) BOM Browser Object Model，浏览器对象模型，允许 JavaScript 与浏览器对话，JavaScript 将浏览器的各个组成部分封装成对象\nWindow：浏览器窗口对象 Navigator：浏览器对象 Screen：屏幕对象 History：历史记录对象 Location：地址栏对象 Window 浏览器窗口对象可直接使用，其中 window. 可以省略。属性有\n属性 描述 history 对 History 对象的只读引用 location 用于窗口或框架的 Location 对象 navigator 对 Navigator 对象的只读引用 方法有\n方法 描述 alert() 显示带有一段信息和一个确认按钮的警告框 confirm() 显示带有一段信息以及确认按钮和取消按钮的对话框 setInterval() 按照指定的周期 (以毫秒计) 来调用函数或计算表达式 setTimeout() 在指定的毫秒数后调用函数或计算表达式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // 获取window对象 window.alert(\u0026#34;获取window对象\u0026#34;); // 或者省略前面 alert(\u0026#34;省略了window\u0026#34;); // confirm var flag = confirm(\u0026#34;是否确认\u0026#34;); console.log(flag); // 定时器1 var i = 0; setInterval(function(){ i++; console.log(\u0026#34;定时器执行\u0026#34;+i+\u0026#34;次\u0026#34;); },2000); // 每两秒执行一次 //定时器2 setTimeout(function(){ console.log(\u0026#34;只会执行一次\u0026#34;); },3000); // 三秒后执行一次 Location 地址栏对象，使用 window.location 获取，其中 window. 可以省略\n属性 href 可以设置或返回完整的 URL\n1 2 3 4 // 获取当前地址栏地址 console.log(location.href); // 设置地址栏地址，会自动跳转 location.href = \u0026#34;https://blog.yexca.net/\u0026#34; DOM Document Object Model，文档对象模型，将标记语言的各个组成部分封装为对应的对象\nDOM 是 W3C 的标准，定义了访问 HTML 和 XML 文档的标准，分为三部分：\nCore DOM - 所有文档类型的标准模型 Document：整个文档对象 Element：元素对象 Attribute：属性对象 Text：文本对象 Comment：注释对象 XML DOM - XML 文档的标准模型 HTML DOM - HTML 文档的标准模型 Image: \u0026lt;img\u0026gt; Button: \u0026lt;input type='button'\u0026gt; JS 通过 DOM，就能够对 HTML 进行操作，例如：\n改变 HTML 元素的内容 改变 HTML 元素的样式 (CSS) 对 HTML DOM 事件做出反应 添加和删除 HTML 元素 HTML 中的 Element 对象可以通过 Document 对象获取，而 Document 对象是通过 window 对象获取的\nDocument 对象中提供了以下获取 Element 元素对象的函数\n根据 id 属性值获取，返回单个 Element 对象 1 var app = document.getElementById(\u0026#39;app\u0026#39;); 根据标签名称获取，返回 Element 对象数组 1 var links = document.getElementsByTagName(\u0026#34;a\u0026#34;); 根据 name 属性值获取，返回 Element 对象数组 1 var hobbys = document.getElementsByName(\u0026#39;hobby\u0026#39;); 根据 class 属性值获取，返回 Element 对象数组 1 var classes = document.getElementsByClassName(\u0026#39;cls\u0026#39;); 以上例子 HTML\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;DOM\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt;abc\u0026lt;/a\u0026gt;\u0026lt;br\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;hobby\u0026#34;\u0026gt;hobby1 \u0026lt;br\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;hobby\u0026#34;\u0026gt;hobby2 \u0026lt;br\u0026gt; \u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt;def\u0026lt;/a\u0026gt;\u0026lt;br\u0026gt; \u0026lt;div class=\u0026#34;cls\u0026#34;\u0026gt;class\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script src=\u0026#34;./js/10-DOM.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; 在获取元素后，就可以修改了，修改参考 https://www.w3school.com.cn/jsref/index.asp 左侧 HTML 对象\n例如上例修改第一个 a 标签文字\n1 2 3 4 // 获取 var links = document.getElementsByTagName(\u0026#34;a\u0026#34;); // 修改 links[0].innerHTML = \u0026#34;修改值\u0026#34;; 事件监听 事件是发生在 HTML 元素上的事情，比如按钮被点击、鼠标移动到元素上、按下键盘按键等\n而事件监听则指 JavaScript 可以在事件被侦测到时执行代码\n事件绑定 事件绑定有两种方式，方式一：通过 HTML 标签中的事件属性进行绑定\n1 2 3 4 5 6 \u0026lt;button id=\u0026#34;btn\u0026#34; onclick=\u0026#34;on()\u0026#34;\u0026gt;按钮\u0026lt;/button\u0026gt; \u0026lt;script\u0026gt; function on(){ alert(\u0026#34;按钮被点击1\u0026#34;); } \u0026lt;/script\u0026gt; 方式二：通过 DOM 元素属性绑定\n1 2 3 document.getElementById(\u0026#34;btn\u0026#34;).onclick=function(){ alert(\u0026#34;按钮被点击2\u0026#34;); } 常见事件 事件名 描述 onclick 鼠标单击事件 onblur 元素失去焦点 onfocus 元素获得焦点 onload 某个页面或图像被完成加载 onsubmit 当表单提交时触发该事件 onkeydown 某个键盘的键被按下 onmouseover 鼠标被移到某元素之上 onmouseout 鼠标从某元素移开 ","date":"2024-01-22T19:51:24+08:00","permalink":"https://blog.yexca.net/archives/148/","title":"JavaScript 学习"},{"content":"案例引入 获取员工数据，返回统一响应结果，在页面渲染展示\n首先需要引入 dom4j 依赖，用于解析 xml 文件\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.dom4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;dom4j\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.1.3\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 引入解析 XML 的工具类 XMLParserUtils、对应实体类 Emp、XML 文件 emp.xml\n引入静态页面文件，放在 resources/static\nSpringBoot 项目的静态资源 (h5+css+js 等前端资源) 默认存放目录为 clsspath:/static, classpath:/public, clsspath:/resources\n对应 Maven 来说 classpath 为 src/main/resources\n编写 Controller 程序，处理请求，响应数据 (此例代码省略，使用下述三层架构)\n三层架构 上例 emp 代码将数据访问、处理逻辑和接收响应请求放在一个 Controller 里，使得复用性差、难以维护，为此需要将其分开以满足单一职责原则，三层架构使得代码复用性强、便于维护、利于拓展\n三层架构分为 Controller、Service 与 Dao\nController：控制层，接收前端发送的请求，对请求进行处理，并响应数据 Service：业务逻辑层，处理具体的业务逻辑 Dao：数据访问层 (Data Access Object) 或持久层，负责数据访问操作，CRUD 浏览器发出请求 -\u0026gt; Controller 接收请求、响应数据 -\u0026gt; Service 逻辑处理 -\u0026gt; Dao 数据访问\n上例 emp 代码可以优化为\nController 1 2 3 4 5 6 7 8 9 @RestController public class EmpController { @RequestMapping(\u0026#34;/listEmp\u0026#34;) public Result listEmp(){ EmpService empServiceA = new EmpServiceA(); List\u0026lt;Emp\u0026gt; empList = empServiceA.listEmp(); return Result.success(empList); } } Service 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // interface public interface EmpService { public List\u0026lt;Emp\u0026gt; listEmp(); } public class EmpServiceA implements EmpService { private EmpDao empDao = new EmpDaoA(); public List\u0026lt;Emp\u0026gt; listEmp(){ List\u0026lt;Emp\u0026gt; empList = empDao.listEmp(); empList.forEach(emp -\u0026gt; { String gender = emp.getGender(); if(\u0026#34;1\u0026#34;.equals(gender)){ emp.setGender(\u0026#34;男\u0026#34;); } else if (\u0026#34;2\u0026#34;.equals(gender)) { emp.setGender(\u0026#34;女\u0026#34;); } String job = emp.getJob(); if(\u0026#34;1\u0026#34;.equals(job)){ emp.setJob(\u0026#34;讲师\u0026#34;); } else if (\u0026#34;2\u0026#34;.equals(job)) { emp.setJob(\u0026#34;班主任\u0026#34;); } else if (\u0026#34;3\u0026#34;.equals(job)) { emp.setJob(\u0026#34;就业指导\u0026#34;); } }); return empList; } } Dao 1 2 3 4 5 6 7 8 9 10 11 12 // interface public interface EmpDao { public List\u0026lt;Emp\u0026gt; listEmp(); } public class EmpDaoA implements EmpDao { public List\u0026lt;Emp\u0026gt; listEmp(){ String file = this.getClass().getClassLoader().getResource(\u0026#34;emp.xml\u0026#34;).getFile(); List\u0026lt;Emp\u0026gt; empList = XmlParserUtils.parse(file, Emp.class); return empList; } } 分层解耦 内聚：软件中各个功能模块内部的功能联系\n耦合：衡量软件中各个层/模块之间的依赖、关联的程度\n软件设计原则：高内聚低耦合\n具体见 https://blog.yexca.net/archives/145 例如上例三层架构，Controller 与 Service 耦合，Service 与 Dao 耦合\n在 Controller 中直接创建 Service 对象 EmpService empServiceA = new EmpServiceA(); 使用 A，若变更为 B 则需要更改 Controller，为了换 Service 而不更改 Controller，可以创建一个容器，使得 Controller 从容器获取对象 (依赖注入) ，Service 把服务注入容器 (控制反转)\n控制反转：Inverse Of Control，简称 IOC。对象的创建控制权由程序自身转移到外部 (容器) 依赖注入：Dependency Injection，简称 DI。容器为应用程序提供运行时，所依赖的资源 Bean 对象：IOC 容器中创建、管理的对象 IOC 要把某个对象交给 IOC 容器管理，需要在对应的类上加上如下注解之一\n注解 说明 位置 @Component 声明 bean 的基础注解 不属于以下三类时用此注解 (工具类) @Controller @Component 的衍生注解 标注在控制器类上 @Service @Component 的衍生注解 标注在业务类上 @Repository @Component 的衍生注解 标注在数据访问类上 (mybatis 整合，用的少) 声明 bean 时，可以通过 value 属性指定名字，若没有，默认类名首字母小写 在 SpringBoot 集成 web 开发中，声明控制器 bean 只能用 @Controller Bean 组件扫描 上面声明 bean 的四个注解，若想生效，还需被组件扫描注解 @ComponentScan 扫描\n此注解实际上已经包含在启动类声明注解 @SpringBootApplication 中，默认的扫描范围是启动类所在包及其子包\n通过 value 或者 basePackage 属性指定扫描范围\n1 @ComponentScan({\u0026#34;dao\u0026#34;,\u0026#34;net.yexca\u0026#34;}) 示例 上例中\nController 由于 @RestController 注解已经包含 @Controller，无需修改\nService 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 // interface public interface EmpService { public List\u0026lt;Emp\u0026gt; listEmp(); } // 在实现类添加 @Service // 将当前类交给IOC容器管理，成为IOC容器中的Bean public class EmpServiceA implements EmpService { private EmpDao empDao = new EmpDaoA(); public List\u0026lt;Emp\u0026gt; listEmp(){ List\u0026lt;Emp\u0026gt; empList = empDao.listEmp(); empList.forEach(emp -\u0026gt; { String gender = emp.getGender(); if(\u0026#34;1\u0026#34;.equals(gender)){ emp.setGender(\u0026#34;男\u0026#34;); } else if (\u0026#34;2\u0026#34;.equals(gender)) { emp.setGender(\u0026#34;女\u0026#34;); } String job = emp.getJob(); if(\u0026#34;1\u0026#34;.equals(job)){ emp.setJob(\u0026#34;讲师\u0026#34;); } else if (\u0026#34;2\u0026#34;.equals(job)) { emp.setJob(\u0026#34;班主任\u0026#34;); } else if (\u0026#34;3\u0026#34;.equals(job)) { emp.setJob(\u0026#34;就业指导\u0026#34;); } }); return empList; } } Dao 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // interface public interface EmpDao { public List\u0026lt;Emp\u0026gt; listEmp(); } // 在实现类添加 @Repository // 将当前类交给IOC容器管理，成为IOC容器中的Bean public class EmpDaoA implements EmpDao { public List\u0026lt;Emp\u0026gt; listEmp(){ String file = this.getClass().getClassLoader().getResource(\u0026#34;emp.xml\u0026#34;).getFile(); List\u0026lt;Emp\u0026gt; empList = XmlParserUtils.parse(file, Emp.class); return empList; } } DI 使用 @Autowired 注解可以注入依赖，不过默认是按照类型进行，如果存在多个相同类型的 bean 将报错\n将以上例子加上 DI (修改的代码将被注释)\nController 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @RestController public class EmpController { @Autowired // 运行时，IOC容器会提供该类型的Bean对象，并赋值给该变量 -- 依赖注入 private EmpService empService; @RequestMapping(\u0026#34;/listEmp\u0026#34;) public Result listEmp(){ //EmpService empServiceA = new EmpServiceA(); //List\u0026lt;Emp\u0026gt; empList = empServiceA.listEmp(); List\u0026lt;Emp\u0026gt; empList = empService.listEmp(); return Result.success(empList); } } Service 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 // interface public interface EmpService { public List\u0026lt;Emp\u0026gt; listEmp(); } // 在实现类添加 @Service // 将当前类交给IOC容器管理，成为IOC容器中的Bean public class EmpServiceA implements EmpService { @Autowired // 运行时，IOC容器会提供该类型的Bean对象，并赋值给该变量 -- 依赖注入 private EmpDao empDao; // private EmpDao empDao = new EmpDaoA(); public List\u0026lt;Emp\u0026gt; listEmp(){ List\u0026lt;Emp\u0026gt; empList = empDao.listEmp(); empList.forEach(emp -\u0026gt; { String gender = emp.getGender(); if(\u0026#34;1\u0026#34;.equals(gender)){ emp.setGender(\u0026#34;男\u0026#34;); } else if (\u0026#34;2\u0026#34;.equals(gender)) { emp.setGender(\u0026#34;女\u0026#34;); } String job = emp.getJob(); if(\u0026#34;1\u0026#34;.equals(job)){ emp.setJob(\u0026#34;讲师\u0026#34;); } else if (\u0026#34;2\u0026#34;.equals(job)) { emp.setJob(\u0026#34;班主任\u0026#34;); } else if (\u0026#34;3\u0026#34;.equals(job)) { emp.setJob(\u0026#34;就业指导\u0026#34;); } }); return empList; } } Dao 没有数据注入，无需修改\n@Primary 若将 Service 添加一个实现类 EmpServiceB 并且也使用了 @Autowired 程序将报错，可以通过 @Primary 注解指定使用哪个\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 // interface public interface EmpService { public List\u0026lt;Emp\u0026gt; listEmp(); } // 在实现类添加 @Service // 将当前类交给IOC容器管理，成为IOC容器中的Bean public class EmpServiceA implements EmpService { @Autowired // 运行时，IOC容器会提供该类型的Bean对象，并赋值给该变量 -- 依赖注入 private EmpDao empDao; // private EmpDao empDao = new EmpDaoA(); public List\u0026lt;Emp\u0026gt; listEmp(){ List\u0026lt;Emp\u0026gt; empList = empDao.listEmp(); empList.forEach(emp -\u0026gt; { String gender = emp.getGender(); if(\u0026#34;1\u0026#34;.equals(gender)){ emp.setGender(\u0026#34;男\u0026#34;); } else if (\u0026#34;2\u0026#34;.equals(gender)) { emp.setGender(\u0026#34;女\u0026#34;); } String job = emp.getJob(); if(\u0026#34;1\u0026#34;.equals(job)){ emp.setJob(\u0026#34;讲师\u0026#34;); } else if (\u0026#34;2\u0026#34;.equals(job)) { emp.setJob(\u0026#34;班主任\u0026#34;); } else if (\u0026#34;3\u0026#34;.equals(job)) { emp.setJob(\u0026#34;就业指导\u0026#34;); } }); return empList; } } @Primary // 使用此bean @Service // 将当前类交给IOC容器管理，成为IOC容器中的Bean public class EmpServiceB implements EmpService { @Autowired // 运行时，IOC容器会提供该类型的Bean对象，并赋值给该变量 -- 依赖注入 private EmpDao empDao; // private EmpDao empDao = new EmpDaoA(); public List\u0026lt;Emp\u0026gt; listEmp(){ List\u0026lt;Emp\u0026gt; empList = empDao.listEmp(); empList.forEach(emp -\u0026gt; { String gender = emp.getGender(); if(\u0026#34;1\u0026#34;.equals(gender)){ emp.setGender(\u0026#34;男\u0026#34;); } else if (\u0026#34;2\u0026#34;.equals(gender)) { emp.setGender(\u0026#34;女\u0026#34;); } String job = emp.getJob(); if(\u0026#34;1\u0026#34;.equals(job)){ emp.setJob(\u0026#34;讲师\u0026#34;); } else if (\u0026#34;2\u0026#34;.equals(job)) { emp.setJob(\u0026#34;班主任\u0026#34;); } else if (\u0026#34;3\u0026#34;.equals(job)) { emp.setJob(\u0026#34;就业指导\u0026#34;); } }); return empList; } } @Qualifier 指定使用哪个 bean，在 Controller 使用，将上方 @Primary 注解取消\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @RestController public class EmpController { @Qualifier(\u0026#34;empServiceA\u0026#34;) // 使用bean empServiceA @Autowired // 运行时，IOC容器会提供该类型的Bean对象，并赋值给该变量 -- 依赖注入 private EmpService empService; @RequestMapping(\u0026#34;/listEmp\u0026#34;) public Result listEmp(){ //EmpService empServiceA = new EmpServiceA(); //List\u0026lt;Emp\u0026gt; empList = empServiceA.listEmp(); List\u0026lt;Emp\u0026gt; empList = empService.listEmp(); return Result.success(empList); } } @Resource 与 @Qualifier 类似，不过不使用 @Autowired\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @RestController public class EmpController { // @Qualifier(\u0026#34;empServiceA\u0026#34;) // 使用bean empServiceA // @Autowired @Resource(name = \u0026#34;empServiceB\u0026#34;) // 使用bean empServiceB private EmpService empService; @RequestMapping(\u0026#34;/listEmp\u0026#34;) public Result listEmp(){ //EmpService empServiceA = new EmpServiceA(); //List\u0026lt;Emp\u0026gt; empList = empServiceA.listEmp(); List\u0026lt;Emp\u0026gt; empList = empService.listEmp(); return Result.success(empList); } } @Autowired 与 @Resource 区别\n@Autowired 是 Spring 框架提供的注解，而 @Resource 是 JDK 提供的注解\n@Autowired 默认是按照类型注入，而 @Resource 默认是按照名称注入\n","date":"2024-01-19T10:37:15+08:00","permalink":"https://blog.yexca.net/archives/147/","title":"三层架构与分层解耦"},{"content":"引言 HTML 学习一 - 基础: https://blog.yexca.net/archives/146 HTML 学习二 - 列表、表格与表单: https://blog.yexca.net/archives/150 HTML 学习三 - 网页布局: https://blog.yexca.net/archives/195 基本骨架 1 2 3 4 5 6 7 8 \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;网页标题\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; 网页主体 \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 一般有软件生成，例如在 VS Code 里可以新建 .html 文件后输入英文 ! 按 TAB 键自动生成\nhead 标签一般是面向浏览器，body 标签面向用户\n注释 1 \u0026lt;!-- 注释内容 --\u0026gt; 在 VS Code 中可以选中该行，使用快捷键 Ctrl + / 一键注释\n浏览器不会显示注释的内容\n标题与段落 1 2 3 4 5 6 7 8 \u0026lt;h1\u0026gt;一级标题\u0026lt;/h1\u0026gt; \u0026lt;h2\u0026gt;二级标题\u0026lt;/h2\u0026gt; \u0026lt;h3\u0026gt;三级标题\u0026lt;/h3\u0026gt; \u0026lt;h4\u0026gt;四级标题\u0026lt;/h4\u0026gt; \u0026lt;h5\u0026gt;五级标题\u0026lt;/h5\u0026gt; \u0026lt;h6\u0026gt;六级标题\u0026lt;/h6\u0026gt; \u0026lt;p\u0026gt;段落内容\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;段落内容\u0026lt;/p\u0026gt; 标题标签显示会文字加粗，独占一行\n段落标签内容独占一行，段落之间有空隙\n换行与水平线 在段落标签中的内容换行并不会被显现，如需换行需使用换行标签\n1 \u0026lt;br /\u0026gt; 水平线标签代码如下\n1 \u0026lt;hr /\u0026gt; 效果如下\n文本格式化标签 效果 标签名 缩写 加粗 strong b 倾斜 em i 下划线 ins u 删除线 del s 一般不推荐缩写，示例如下\n1 2 3 4 \u0026lt;p\u0026gt; 你好，我是 \u0026lt;em\u0026gt;yexca\u0026lt;/em\u0026gt;，\u0026lt;strong\u0026gt;欢迎\u0026lt;/strong\u0026gt;访问\u0026lt;ins\u0026gt;此博客\u0026lt;/ins\u0026gt;\u0026lt;br /\u0026gt; \u0026lt;del\u0026gt;然后我该写什么呢？\u0026lt;/del\u0026gt; \u0026lt;/p\u0026gt; 效果如下\n你好，我是 yexca，欢迎访问此博客\n然后我该写什么呢？\r图像标签 图像标签需要在 src 属性中指定指定图像的位置\n1 \u0026lt;img src=\u0026#34;path\u0026#34; alt=\u0026#34;图片不能加载时显示的内容\u0026#34; /\u0026gt; 路径分为绝对路径和相对路径，假设当前路径为 (Linux 系统)\n1 2 3 /home/yexca/code index.html photo.jpg 代码写在 index.html 文件，那么相对路径如下\n1 \u0026lt;img src=\u0026#34;./photo.jpg\u0026#34; /\u0026gt; 绝对路径如下\n1 \u0026lt;img src=\u0026#34;/home/yexca/code/photo.jpg\u0026#34; /\u0026gt; 超链接标签 1 \u0026lt;a href=\u0026#34;目标页面\u0026#34; target=\u0026#34;方式\u0026#34;\u0026gt;链接文字\u0026lt;/a\u0026gt; 此标题用于跳转网页，即网页中的链接，如果需要在新窗口打开网页，只需将 target 属性值为 _blank，例如以下代码\n1 2 3 4 5 \u0026lt;p\u0026gt; 跳转至 \u0026lt;a href=\u0026#34;https://yexca.net\u0026#34;\u0026gt;yexca\u0026lt;/a\u0026gt;\u0026lt;br /\u0026gt; 这个是新标签页：\u0026lt;a href=\u0026#34;https://yexca.net\u0026#34;\u0026gt;yexca\u0026lt;/a\u0026gt; \u0026lt;/p\u0026gt; 效果如下\n跳转至\ryexca\n这个是新标签页：yexca\r音视频标签 1 2 \u0026lt;audio src=\u0026#34;path\u0026#34;\u0026gt;音频标签\u0026lt;/audio\u0026gt; \u0026lt;video src=\u0026#34;path\u0026#34;\u0026gt;视频标签\u0026lt;/video\u0026gt; 音频标签属性如下\n属性 作用 说明 src 音频路径 必须属性，支持 mp3、ogg、wav controls 显示音频控制面板 loop 循环播放 autoplay 自动播放 浏览器一般禁止自动播放 视频标签属性如下\n属性 作用 说明 src 视频路径 必须属性，支持 mp4、webm、ogg controls 显示视频控制面板 loop 循环播放 muted 静音播放 autoplay 自动播放 浏览器支持在静音状态下自动播放 假设当前路径如下\n1 2 3 4 /home/yexca/code index.html audio.mp3 video.mp4 例如以下代码\n1 2 3 4 5 6 7 8 \u0026lt;audio src=\u0026#34;./audio.mp3\u0026#34; controls loop\u0026gt;\u0026lt;/audio\u0026gt; \u0026lt;!-- 显示控制，播完回到开始循环播放 --\u0026gt; \u0026lt;video src=\u0026#34;./video.mp4\u0026#34; controls loop\u0026gt;\u0026lt;/video\u0026gt; \u0026lt;!-- 显示控制，播完回到开始循环播放 --\u0026gt; \u0026lt;video src=\u0026#34;./video.mp4\u0026#34; controls muted autoplay\u0026gt;\u0026lt;/video\u0026gt; \u0026lt;!-- 此代码会自动播放 --\u0026gt; \u0026lt;video src=\u0026#34;./video.mp4\u0026#34; controls autoplay\u0026gt;\u0026lt;/video\u0026gt; \u0026lt;!-- 此代码不会自动播放 --\u0026gt; 布局标签 没有实义的用于布局网页的标签，划分区域或摆放内容\ndiv: 独占一行 span: 不换行 例如以下代码\n1 2 3 4 5 6 7 8 \u0026lt;div\u0026gt; div1 \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; div2 \u0026lt;/div\u0026gt; \u0026lt;span\u0026gt;span1\u0026lt;/span\u0026gt; \u0026lt;span\u0026gt;span2\u0026lt;/span\u0026gt; 效果如下\ndiv1\rdiv2\rspan1\rspan2\r## 字符转换\r用于在网页中显示预留字符。例如显示空格、\u0026lt;、\u0026gt;\nResult Description Entity Name Entity Number non-breaking space \u0026amp;nbsp; \u0026amp;#160; \u0026lt; less than \u0026amp;lt; \u0026amp;#60; \u0026gt; greater than \u0026amp;gt; \u0026amp;#62; \u0026amp; ampersand \u0026amp;amp; \u0026amp;#38; “ double quotation mark \u0026amp;quot; \u0026amp;#34; ‘ single quotation mark (apostrophe) \u0026amp;apos; \u0026amp;#39; ¢ cent \u0026amp;cent; \u0026amp;#162; £ pound \u0026amp;pound; \u0026amp;#163; ¥ yen \u0026amp;yen; \u0026amp;#165; € euro \u0026amp;euro; \u0026amp;#8364; © copyright \u0026amp;copy; \u0026amp;#169; ® registered trademark \u0026amp;reg; \u0026amp;#174; 例如显示 \u0026lt;p\u0026gt;\n1 2 3 \u0026lt;p\u0026gt; \u0026amp;lt;p\u0026amp;gt; \u0026lt;/p\u0026gt; 参考： HTML字元符號 \u0026amp;Nbsp; \u0026amp;Ensp; \u0026amp;Emsp; 的差異 ","date":"2024-01-18T14:43:34+08:00","permalink":"https://blog.yexca.net/archives/146/","title":"HTML 学习一 - 基础"},{"content":"系统设计的基本原理 抽象、模块化、信息隐蔽、模块独立\n模块化 在软件的体系结构中，模块是可组合、分解和更换的单元\n模块化是指将一个待开发的软件分解成若干个小的简单部分，即模块。每个模块可独立地开发、测试，最后组装成完整的程序。这是一种复杂问题 \u0026ldquo;分而治之\u0026rdquo; 的原则。模块化的目的是使程序的结构清晰，容易阅读、理解、测试和修改\n模块独立 模块独立是指每个模块完成一个相对独立的特定子功能，并且与其他模块之间的联系简单。衡量模块独立程度的标准有两个：耦合性和内聚性\n耦合 耦合是模块之间的相对独立性 (互相连接的紧密程度) 的度量。耦合取决于各个模块之间接口的复杂程度、调用模块的方式以及通过接口的信息类型等。一般模块之间可能的耦合方式有 7 种类型\n无直接耦合。指两个模块之间没有直接的关系，它们分别从属于不同模块的控制与调用，它们之间不传递任何信息 数据耦合。指两个模块之间有调用关系，传递的是简单的数据值，相当于高级语言中的值传递 标记耦合。指两个模块之间传递的是数据结构 控制耦合。指一个模块调用另一个模块，传递的是控制变量，被调用模块通过控制该控制变量的值有选择地执行模块内地某一功能 外部耦合。模块之间通过软件之外的环境联结 (如 I/O 将模块耦合到特定的设备、格式、通信协议上) 时称为外部耦合 公共耦合。指通过一个公共数据环境相互作用的那些模块间的耦合 内容耦合。当一个模块直接使用另一个模块的内部数据，或通过非正常入口转入另一个模块内部时，这种模块之间的耦合称为内容耦合 内聚 内聚是对一个模块内部各个元素彼此结合的紧密程度的度量。一个内聚程度高的模块 (在理想情况下) 应当只做一件事。一般模块的内聚性分为 7 种类型\n偶然内聚 (巧合内聚) 。指一个模块内的各处理元素之间没有任何联系 逻辑内聚。指模块内执行若干个逻辑上相似的功能，通过参数确定该模块完成哪一个功能 时间内聚。把需要同时执行的动作组合在一起形成的模块称为时间内聚模块 过程内聚。指一个模块完成多个任务，这些任务必须按指定的过程执行 通信内聚。指模块内的所有处理元素都在同一个数据结构上操作，或者各处理使用相同的输入数据或者产生相同的输出数据 顺序内聚。指一个模块中的各个处理元素都密切相关于同一功能且必须顺序执行，前一功能元素的输出就是下一功能元素的输入 功能内聚。这是最强的内聚，指模块内的所有元素共同作用完成一个功能，缺一不可 耦合性和内聚性是模块独立性的两个定性标准，在将软件系统划分模块时，应尽量做到高内聚、低耦合，提升模块的独立性\n系统结构设计原则 为保证总体结构设计顺利完成，应遵循以下几条原则\n分解-协调原则。整个系统是一个整体，具有整体目的和功能，但这些目的和功能的实现又是由相互联系的各个组成部分共同工作的结果。解决复杂问题的一个很重要的原则就是把它分解成多个小问题分别处理，在处理过程中根据系统总体要求协调各部门的关系 自顶向下的原则。首先抓住系统总的功能目的，然后逐层分解，即先确定上层模块的功能，再确定下层模块的功能 信息隐蔽、抽象的原则。上层模块只规定下次模块做什么和所属模块之间的协调关系，但不规定怎么做，以保证各模块的相对独立性和内部结构的合理性，使得模块与模块之间层次分明，易于理解、实施和维护 一致性原则。要保证整个软件设计过程中具有统一的规范、统一的标准和统一的文件模式等 明确性原则。每个模块必须功能明确、接口正确，消除多重功能和无用接口 模块之间的耦合尽可能小，模块的内聚度尽可能高 模块的扇入系数和扇出系数要合理。一个模块直接调用其他模块的个数称为模块的扇出系数；反之，一个模块被其他模块调用时，直接调用它的模块个数称为模块的扇入系数。模块的扇入、扇出系数必须适当。经验表明，一个设计得好的系统的平均扇入、扇出系数通常是 3 或 4，一般不应超过 7 ，否则会引起出错概率的增大。但菜单调用型模块的扇入与扇出系统可以大一些，公用模块的扇入系数可以大一些 模块的规模适当。过大的模块常常使系统分解得不充分，其内部可能包含了若干部分的功能，因此有必要进一步把原有的模块分解成若干功能尽可能单一的模块。但分解也必须适度，因为过小的模块有可能降低模块的独立性，造成系统接口的复杂性 模块的作用范围应该在其控制范围之内 系统文档 信息系统的文档是系统建设过程的 \u0026ldquo;痕迹\u0026rdquo; ，是系统维护人员的指南，是开发人员与用户交流的工具。规范的文档意味着系统是按照工程化开发的，意味着信息系统的质量有了形式上的保障。文档的欠缺、文档的随意性和文档的不规范，极有可能导致原来的开发人员流动以后，系统不可维护、不可升级，变成了一个没有扩展性、没有生命力的系统\n对文档在系统开发人员、项目管理人员、系统维护人员、系统评价人员以及用户之间的多种作用总结如下\n用户与系统分析人员在系统规划和系统分析阶段通过文档进行沟通。这里的文档主要包括可行性研究报告、总体规划报告、系统开发合同和系统方案说明书 系统开发人员与项目管理人员通过文档在项目期内进行沟通。这里的文档主要有系统开发计划 (包括工作任务分解表、PERT 图、甘特图和预算分配表等) 、系统开发月报以及系统开发总结报告等项目管理文件 系统测试人员与系统开发人员通过文档进行沟通。系统测试人员可以根据系统方案说明书、系统开发合同、系统设计说明书和测试计划等文档对系统开发人员所开发的系统进行测试。系统测试人员再将评估结果撰写成系统测试报告 系统开发人员与用户在系统运行期间进行沟通。用户通过系统开发人员撰写的文档运行系统。这里的文档主要是用户手册和操作指南 系统开发人员与系统维护人员通过文档进行沟通。这里的文档主要有系统设计说明书和系统开发总结报告 用户与维修人员在运行维护期间进行沟通。用户在使用信息系统的过程中，将运行过程中的问题进行记载，形成系统运行报告和维护修改建议。系统维护人员根据维护修改建议以及系统开发人员留下的技术手册等文档对系统进行维护和升级 ","date":"2024-01-16T08:10:10+08:00","permalink":"https://blog.yexca.net/archives/145/","title":"结构化开发"},{"content":"浏览器发送请求会先经过 DispatcherServlet 转给各 *Controller 程序进行处理，处理完成后返回给 DispatcherServlet 处理结果，然后再返回浏览器\nDispatcherServlet 被称为核心控制器或前端控制器\n对于浏览器请求数据，会被封装到 HttpServletRequest 对象，响应数据被封装到 HttpServletResponse\n*Controller 接收请求，设置响应\n请求 简单参数 首先为原始方式，获取请求参数通过 HttpServletRequest 对象手动获取\n1 2 3 4 5 6 7 8 9 @RequestMapping(\u0026#34;/simpleParam\u0026#34;) public String simpleParam(HttpServletRequest request){ String name = request.getParameter(\u0026#34;name\u0026#34;); String ageStr = request.getParameter(\u0026#34;age\u0026#34;); int age = Integer.parseInt(ageStr); System.out.println(name + \u0026#34;;\u0026#34; + age); return \u0026#34;OK\u0026#34;; } 当浏览器访问 http://localhost:8080/simpleParam?name=tom\u0026age=18 网页返回字符串 “OK”，程序返回 “Tom;18”\n显然这种方式过于麻烦，在 SpringBoot 中可以通过参数名与形参名相同，定义形参即可接收参数\n1 2 3 4 5 @RequestMapping(\u0026#34;/simpleParam\u0026#34;) public String simpleParam(String name, Integer age){ System.out.println(name + \u0026#34;;\u0026#34; + age); return \u0026#34;OK\u0026#34;; } 效果同上\n不过上述方法就是是请求的参数名不同也会继续运行，没有的参数为 null\n可以使用 @RequestParam 完成映射实现请求名与形参名不同\n1 2 3 4 5 6 7 @RequestMapping(\u0026#34;/simpleParam\u0026#34;) public String simpleParam(@RequestParam(name = \u0026#34;name\u0026#34;) String username, Integer age){ // 当声明@RequestParam后代表该参数必须被传递，不然报错 // 若更改为@RequestParam(name = \u0026#34;name\u0026#34;, required = false)代表该参数不是必须的 System.out.println(username + \u0026#34;;\u0026#34; + age); return \u0026#34;OK\u0026#34;; } 实体参数 如果只是少量的参数用上述可以，但若是较多的数据可以通过简单实体对象，请求参数名与形参对象属性名相同，定义 POJO 接收即可\n1 2 3 4 5 6 7 8 9 10 11 12 @RequestMapping(\u0026#34;/simplePojo\u0026#34;) public String simplePojo(User user){ System.out.println(user); return \u0026#34;OK\u0026#34;; } // User类 public class User{ private String name; private Integer age; // set get toString 方法 } 访问 http://localhost:8080/simplePojo?name=tom\u0026age=18 网页返回字符串 “OK”，程序返回 “User{name=\u0026lsquo;tom\u0026rsquo;, age=18}”\n复杂实体对象：请求参数名与形参属性名相同，按照对象层次结构关系即可接收嵌套 POJO 属性参数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 @RequestMapping(\u0026#34;/complexPojo\u0026#34;) public String complexPojo(UserComplex user){ System.out.println(user); return \u0026#34;OK\u0026#34;; } // User类 public class UserComplex{ private String name; private Integer age; private Address address; // set get toString } // Address类 public class Address{ private String province; private String city; // set get toString } 访问 http://localhost:8080/complexPojo?name=tom\u0026age=18\u0026address.province=beijing\u0026address.city=beijing 网页返回字符串 “OK”，程序返回 “UserComplex{name=\u0026lsquo;tom\u0026rsquo;, age=1000, address=Address{province=\u0026lsquo;ads,beijing\u0026rsquo;, city=\u0026lsquo;asda,beijing\u0026rsquo;}}”\n数组参数 请求参数名与形参数组名称相同且请求参数为多个，定义数组类型形参即可接受参数。例如复选框\n1 2 3 4 5 @RequestMapping(\u0026#34;/arrayParam\u0026#34;) public String arrayParam(String[] hobby){ System.out.println(Arrays.toString(hobby)); return \u0026#34;OK\u0026#34;; } 访问 http://localhost:8080/arrayParam?hobby=ads\u0026hobby=58s 网页返回字符串 “OK”，程序返回 “[ads, 58s]”\n集合参数 请求参数名与形参数组名称相同且请求参数为多个，@RequestParam 绑定参数关系\n1 2 3 4 5 @RequestMapping(\u0026#34;/listParam\u0026#34;) public String listParam(@RequestParam List\u0026lt;String\u0026gt; hobby){ System.out.println(hobby); return \u0026#34;OK\u0026#34;; } 访问 http://localhost:8080/listParam?hobby=ads\u0026hobby=58s 网页返回字符串 “OK”，程序返回 “[ads, 58s]”\n日期参数 使用 @DateTimeFormat 注解完成日期参数格式转换\n需要注意的是传参有三种形式\nyyyy-MM-dd HH:mm:ss yyyy/MM/dd HH:mm:ss yyyy年MM月dd日 HH时mm分ss秒 需要前后端统一才可\n1 2 3 4 5 @RequestMapping(\u0026#34;/dateParam\u0026#34;) public String dateParam(@DateTimeFormat(pattern = \u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;) LocalDateTime localDateTime){ System.out.println(localDateTime); return \u0026#34;OK\u0026#34;; } 访问 http://localhost:8080/dateParam?localDateTime=2024-01-01%2001:01:01 网页返回字符串 “OK”，程序返回 \u0026ldquo;2024-01-01T01:01:01\u0026rdquo;\nJSON 参数 JSON 数据键名与形参对象属性名相同，定义 POJO 类型形参即可接收参数，需要使用 @RequestBody 标识\n若要传输 JSON 数据，必须使用 POST 请求\n1 2 3 4 5 @RequestMapping(\u0026#34;/jsonParam\u0026#34;) public String jsonParam(@RequestBody UserComplex userComplex){ System.out.println(userComplex); return \u0026#34;OK\u0026#34;; } 请求数据\n1 2 3 4 5 6 7 8 { \u0026#34;name\u0026#34;: \u0026#34;jane\u0026#34;, \u0026#34;age\u0026#34;: \u0026#34;18\u0026#34;, \u0026#34;address\u0026#34;: { \u0026#34;province\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34; } } 使用 POST 方法请求 http://localhost:8080/jsonParam 数据如上，网页返回字符串 “OK”，程序返回 \u0026ldquo;UserComplex{name=\u0026lsquo;jane\u0026rsquo;, age=18, address=Address{province=\u0026lsquo;上海\u0026rsquo;, city=\u0026lsquo;上海\u0026rsquo;}}\u0026rdquo;\n路径参数 通过请求 URL 直接传递参数，使用 {...} 来标识该路径参数，需要使用 @PathVariable 获取路径参数\n1 2 3 4 5 @RequestMapping(\u0026#34;/path/{id}\u0026#34;) public String pathParam(@PathVariable Integer id){ System.out.println(id); return \u0026#34;OK\u0026#34;; } 访问 http://localhost:8080/path/52 网页返回字符串 “OK”，程序返回 \u0026ldquo;52\u0026rdquo;\n访问 http://localhost:8080/path/255 网页返回字符串 “OK”，程序返回 \u0026ldquo;255\u0026rdquo;\n对于多个路径参数\n1 2 3 4 5 @RequestMapping(\u0026#34;/path/{id}/{name}\u0026#34;) public String pathParam(@PathVariable Integer id, @PathVariable String name){ System.out.println(id + \u0026#34;;\u0026#34; + name); return \u0026#34;OK\u0026#34;; } 访问 http://localhost:8080/path/255/Tom 网页返回字符串 “OK”，程序返回 \u0026ldquo;255;Tom\u0026rdquo;\n总结 简单参数 定义方法形参，请求参数名与形参变量名一致 如果不一致，通过 @RequestParam 手动映射 实体参数 请求参数名，与实体对象的属性名一致，会自动接收封装 数组集合参数 数组：请求参数名与数组名一致，直接封装 集合：请求参数名与数组名一致，@RequestParam 绑定关系 日期参数 @DateTimeFormat JSON 参数 @RequestBody 路径参数 @PathVariable 响应 使用 @RequestBody 处理响应\n上面请求里之所以可以响应是因为注解 @RestController 包含 @Controller 和 @ResponseBody\n@RequestBody 类型：方法注解、类注解\n位置：Controller方法上或类上\n作用：将方法返回值直接响应，若返回值类型为 实体对象或集合 将会转换为 JSON 格式响应\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 @RestController public class ResponseController { @RequestMapping(\u0026#34;/hello\u0026#34;) public String hello(){ System.out.println(\u0026#34;Hello SpringBoot\u0026#34;); return \u0026#34;Hello SpringBoot\u0026#34;; } @RequestMapping(\u0026#34;/getAddr\u0026#34;) public Address getAddr(){ Address address = new Address(); address.setProvince(\u0026#34;上海\u0026#34;); address.setCity(\u0026#34;上海\u0026#34;); return address; } @RequestMapping(\u0026#34;/listAddr\u0026#34;) public List\u0026lt;Address\u0026gt; listAddr(){ List\u0026lt;Address\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); Address address1 = new Address(); address1.setProvince(\u0026#34;北京\u0026#34;); address1.setCity(\u0026#34;北京\u0026#34;); Address address2 = new Address(); address2.setProvince(\u0026#34;上海\u0026#34;); address2.setCity(\u0026#34;上海\u0026#34;); list.add(address1); list.add(address2); return list; } } 访问相应网址测试\n统一响应结果 以上三个方法返回类型都不一样，使得前端开发较为困难，为此可以统一响应结果为一个类\n1 2 3 4 5 6 7 8 9 public class Result{ // 响应码，1代表成功，0代表失败 private Integer code; // 提示信息 private String msg; // 返回的数据 private Object data; // ... } 使得所有的响应方法返回一个 Result 对象，使得项目管理与维护更容易\n例如如下类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 public class Result { private Integer code ;//1 成功 , 0 失败 private String msg; //提示信息 private Object data; //数据 data public Result() { } public Result(Integer code, String msg, Object data) { this.code = code; this.msg = msg; this.data = data; } public Integer getCode() { return code; } public void setCode(Integer code) { this.code = code; } public String getMsg() { return msg; } public void setMsg(String msg) { this.msg = msg; } public Object getData() { return data; } public void setData(Object data) { this.data = data; } public static Result success(Object data){ return new Result(1, \u0026#34;success\u0026#34;, data); } public static Result success(){ return new Result(1, \u0026#34;success\u0026#34;, null); } public static Result error(String msg){ return new Result(0, msg, null); } @Override public String toString() { return \u0026#34;Result{\u0026#34; + \u0026#34;code=\u0026#34; + code + \u0026#34;, msg=\u0026#39;\u0026#34; + msg + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, data=\u0026#34; + data + \u0026#39;}\u0026#39;; } } 那么上面代码可以改为\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 @RequestMapping(\u0026#34;/hello\u0026#34;) public Result hello(){ System.out.println(\u0026#34;Hello SpringBoot\u0026#34;); return Result.success(\u0026#34;Hello SpringBoot\u0026#34;); } @RequestMapping(\u0026#34;/getAddr\u0026#34;) public Result getAddr(){ Address address = new Address(); address.setProvince(\u0026#34;上海\u0026#34;); address.setCity(\u0026#34;上海\u0026#34;); return Result.success(address); } @RequestMapping(\u0026#34;/listAddr\u0026#34;) public Result listAddr(){ List\u0026lt;Address\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); Address address1 = new Address(); address1.setProvince(\u0026#34;北京\u0026#34;); address1.setCity(\u0026#34;北京\u0026#34;); Address address2 = new Address(); address2.setProvince(\u0026#34;上海\u0026#34;); address2.setCity(\u0026#34;上海\u0026#34;); list.add(address1); list.add(address2); return Result.success(list); } 访问相应网址测试\n","date":"2024-01-14T16:47:28+08:00","permalink":"https://blog.yexca.net/archives/144/","title":"Spring 请求响应"},{"content":"Maven 是一款用于管理和构建 java 项目的工具\nMaven 可以方便快捷的管理项目依赖的资源 (jar 包)，避免版本冲突问题；提供标准、统一的项目结构；标准跨平台的自动化项目构建方式\n安装 在 官网 下载后解压，然后配置本地仓库，修改 conf/setting.xml 中的 \u0026lt;localRepository\u0026gt; 为一个指定目录\n1 2 \u0026lt;!-- 例如本地库在 D:\\develop\\maven_repo --\u0026gt; \u0026lt;localRepository\u0026gt;D:\\develop\\maven_repo\u0026lt;/localRepository\u0026gt; 配置阿里云私服镜像，修改 conf/setting.xml 中的 \u0026lt;mirror\u0026gt; 标签，添加子标签\n1 2 3 4 5 6 \u0026lt;mirror\u0026gt; \u0026lt;id\u0026gt;alimaven\u0026lt;/id\u0026gt; \u0026lt;name\u0026gt;aliyun maven\u0026lt;/name\u0026gt; \u0026lt;url\u0026gt;http://maven.aliyun.com/nexus/content/groups/public/\u0026lt;/url\u0026gt; \u0026lt;mirrorOf\u0026gt;central\u0026lt;/mirrorOf\u0026gt; \u0026lt;/mirror\u0026gt; 配置环境变量：MAVEN_HOME 为 maven 解压目录，并将其 bin 目录加入 PATH 环境变量\n测试安装完成：在命令行输入 mvn -v 查看输出\n依赖配置 依赖：指当前项目运行所需要的 jar 包，一个项目中可以引入多个依赖\n配置步骤：\n在 pom.xml 中编写 \u0026lt;dependencies\u0026gt; 标签 在 \u0026lt;dependencies\u0026gt; 标签中使用 \u0026lt;dependency\u0026gt; 引入坐标 定义坐标的 groupId, artifactId, version 刷新配置，引入新加入的坐标 1 2 3 4 5 6 7 8 \u0026lt;!-- 例如引入 logback --\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;ch.qos.logback\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;logback-classic\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.3\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 可以到 https://mvnrepository.com/ 查找依赖坐标信息\n依赖传递 依赖具有传递性\n直接依赖：在当前项目中通过依赖配置建立的依赖关系 间接依赖：被依赖的资源如果依赖其他资源，当前项目间接依赖其他资源 当添加依赖时，若此包依赖其他包，将自动添加相关包\n当然，若某包的子包并不需要，可以排除依赖 (指主动断开依赖的资源，被排除的资源无需指定版本)\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;!-- 例如排除某项目的 junit --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.yexca\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-project\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;exclusions\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;groupId\u0026gt;junit\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit\u0026lt;/artifactId\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;/exclusions\u0026gt; \u0026lt;/dependency\u0026gt; 依赖范围 依赖的 jar 包，默认可以在任何地方使用，可以通过 \u0026lt;scope\u0026gt;...\u0026lt;/scope\u0026gt; 设置其作用范围：\n主程序范围有效 (main 文件夹范围内) 测试程序范围有效 (test 文件夹范围内) 是否参与打包运行 (package 指令范围内) scope 值 主程序 测试程序 打包 (运行) 范例 compile (默认) Y Y Y log4j test - Y - junit provided Y Y - servlet-api runtime - Y Y jdbc 驱动 1 2 3 4 5 6 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;junit\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.10\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; 生命周期 Maven 的生命周期就是为了对所有的 maven 项目构建过程进行抽象和统一\nMaven 中有 3 套相互独立的生命周期：\nclean：清理工作 default：核心工作，如：编译、测试、打包、安装、部署等 site：生成报告、发布站点等 其中每套生命周期包含一些阶段 (phase) ，阶段是有顺序的，后面的阶段依赖于前面的阶段\nclean pre-clean clean：移除上一次构建生成的文件 (target 文件夹) post-clean default validate initialize generate-sources process-sources generate-resources process-resources compile：编译项目源代码 process-classes generate-test-sources process-test-sources generate-test-resources process-test-resources test-compile process-test-classes test：使用合适的单元测试框架运行测试 (junit) prepare-package package：将编译后的文件打包，如 jar、war 等 verify install：安装项目到本地仓库 deploy site pre-site site post-site site-deploy 在同一套生命周期中，当运行后面的阶段时，前面的阶段都会运行\n分模块设计 分模块设计我们在进行项目设计阶段，就可以将一个大的项目拆分成若干个模块，每一个模块都是独立的，如果我们需要用到另外一个模块的功能，我们直接依赖模块就可以了\n可以把一些通用的实体类或工具类单独作为一个模块，若某一模块需要使用，直接引入对应的依赖即可\n方便项目的管理维护、扩展，也方便模块间的相互调用，资源共享\n继承 像 Lombok 依赖，可能项目中的每个模块都会使用，每个模块都声明一次相当繁琐，可以通过继承解决这个问题\n继承关系 创建一个父工程，将模块共有的依赖都提取到父工程进行配置，只要子类继承了父工程，依赖也会继承下来，这样就无需在各个子工程中进行配置了\n继承描述的是两个工程间的关系，与 java 中的继承相似，子工程可以继承父工程中的配置信息，常见于依赖关系的继承，可以简化依赖配置、统一管理依赖\n1 2 3 4 5 6 7 \u0026lt;!--指定父工程--\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;...\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;...\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;...\u0026lt;/version\u0026gt; \u0026lt;relativePath\u0026gt;....\u0026lt;/relativePath\u0026gt; \u0026lt;/parent\u0026gt; 如果是 JavaWeb 开发，可以让父工程继承 spring-boot-starter-parent，其他模块继承该父工程\n一般情况下，在文件结构中，子工程为父工程子级\n以下为例子\n父工程的打包方式为 pom 1 2 3 4 5 6 7 8 9 10 11 \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.7.5\u0026lt;/version\u0026gt; \u0026lt;relativePath/\u0026gt; \u0026lt;!-- lookup parent from repository --\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;groupId\u0026gt;net.yexca\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;tlias-parent\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;packaging\u0026gt;pom\u0026lt;/packaging\u0026gt; Maven打包方式：\njar：普通模块打包，SpringBoot 项目基本都是jar包 (内嵌 tomcat 运行) war：普通 web 程序打包，需要部署在外部的 tomcat 服务器中运行 pom：父工程或聚合工程，该模块不写代码，仅进行依赖管理 子工程指定父工程 1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;net.yexca\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;tlias-parent\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;!-- 指定父工程的pom文件的相对位置(如果不指定，将从本地仓库/远程仓库查找该工程) --\u0026gt; \u0026lt;relativePath\u0026gt;../tlias-parent/pom.xml\u0026lt;/relativePath\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;!-- \u0026lt;groupId\u0026gt;net.yexca\u0026lt;/groupId\u0026gt; -\t因为自动继承父工程，可以省略 --\u0026gt; \u0026lt;artifactId\u0026gt;tlias-utils\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; 父工程中配置共有依赖 1 2 3 4 5 6 7 \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.18.24\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 版本锁定 某依赖部分模块需要，部分模块不需要，可以在父级中管理依赖的 version，方便管理与修改\n可以通过 \u0026lt;dependencyManagement\u0026gt; 标签管理依赖版本\n父工程\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;!--统一管理依赖版本--\u0026gt; \u0026lt;dependencyManagement\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!--JWT令牌--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.jsonwebtoken\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jjwt\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.9.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/dependencyManagement\u0026gt; 子工程\n1 2 3 4 5 6 7 8 9 10 \u0026lt;dependencies\u0026gt; \u0026lt;!--JWT令牌--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.jsonwebtoken\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jjwt\u0026lt;/artifactId\u0026gt; \u0026lt;!-- \u0026lt;version\u0026gt;0.9.1\u0026lt;/version\u0026gt; - 因为父工程指定了版本，不需要填写 --\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 父工程的 \u0026lt;dependencyManagement\u0026gt; 配置只管理版本，不会将依赖引入子工程。只有在子工程引入才会引入，只是引入时无需指定版本号\n而 \u0026lt;dependencies\u0026gt; 会把依赖引入子工程\n属性配置 也可以通过自定义属性及属性引用的形式，在父工程中将依赖的版本号进行集中管理维护\n自定义属性：\n1 2 3 \u0026lt;properties\u0026gt; \u0026lt;lombok.version\u0026gt;1.18.24\u0026lt;/lombok.version\u0026gt; \u0026lt;/properties\u0026gt; 引用属性：\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${lombok.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 于是可以在父工程中将所以的版本号，集中管理维护\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 \u0026lt;properties\u0026gt; \u0026lt;maven.compiler.source\u0026gt;11\u0026lt;/maven.compiler.source\u0026gt; \u0026lt;maven.compiler.target\u0026gt;11\u0026lt;/maven.compiler.target\u0026gt; \u0026lt;lombok.version\u0026gt;1.18.24\u0026lt;/lombok.version\u0026gt; \u0026lt;jjwt.version\u0026gt;0.9.1\u0026lt;/jjwt.version\u0026gt; \u0026lt;aliyun.oss.version\u0026gt;3.15.1\u0026lt;/aliyun.oss.version\u0026gt; \u0026lt;jaxb.version\u0026gt;2.3.1\u0026lt;/jaxb.version\u0026gt; \u0026lt;activation.version\u0026gt;1.1.1\u0026lt;/activation.version\u0026gt; \u0026lt;jaxb.runtime.version\u0026gt;2.3.3\u0026lt;/jaxb.runtime.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${lombok.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;!--统一管理依赖版本--\u0026gt; \u0026lt;dependencyManagement\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!--JWT令牌--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.jsonwebtoken\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jjwt\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${jjwt.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--阿里云OSS--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.aliyun.oss\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;aliyun-sdk-oss\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${aliyun.oss.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.xml.bind\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jaxb-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${jaxb.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.activation\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;activation\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${activation.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- no more than 2.3.3--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.glassfish.jaxb\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jaxb-runtime\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${jaxb.runtime.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/dependencyManagement\u0026gt; 若想要修改依赖的版本，只需要在父工程的自定义属性，修改相应属性值即可\n聚合 若一个模块依赖另一个模块，打包该模块前需要先将其他模块 install 到本地仓库，然后再打包。如果依赖的模块很多，那么需要执行的操作过于繁琐\n通过 maven 的聚合就可以轻松实现项目的一键构建 (清理、编译、测试、打包、安装等)\n**聚合：**将多个模块组织成一个整体，同时进行项目的构建 **聚合工程：**一个不具有业务功能的“空”工程 (有且仅有一个pom文件。一般来说，继承关系中的父工程与聚合关系中的聚合工程是同一个) **作用：**快速构建项目 (无需根据依赖关系手动构建，直接在聚合工程上构建即可) 可以在聚合工程中通过 \u0026lt;modules\u0026gt; 设置当前聚合工程所包含的子模块的名称\n1 2 3 4 5 6 7 \u0026lt;!--聚合其他模块--\u0026gt; \u0026lt;modules\u0026gt; \u0026lt;!-- 工程路径 --\u0026gt; \u0026lt;module\u0026gt;../tlias-pojo\u0026lt;/module\u0026gt; \u0026lt;module\u0026gt;../tlias-utils\u0026lt;/module\u0026gt; \u0026lt;module\u0026gt;../tlias-web-management\u0026lt;/module\u0026gt; \u0026lt;/modules\u0026gt; 之后进行编译、打包、安装操作只在聚合工程上即可，其他工程会自动同步操作\n继承 聚合 作用 继承用于简化依赖配置、统一管理依赖 聚合用于快速构建项目 相同点 打包方式均为 pom，通常制作到同一 pom 均属于设计型模块，无实际内容 不同点 继承是在子模块中配置关系\n父模块无法感知哪些子模块继承了自己 聚合是在聚合工程中配置关系\n聚合可以感知到参与聚合的模块有哪些 私服 私服是一种特殊的远程仓库，它是架设在局域网内的仓库服务，用来代理位于外部的中央仓库，用于解决团队内部的资源共享与资源同步问题\n如果在项目中需要使用其他第三方提供的依赖，如果本地仓库没有，会自动连接私服下载，如果私服没有，私服此时会自动连接中央仓库，去中央仓库中下载依赖，然后将下载的依赖存储在私服仓库及本地仓库中\n私服一般一个公司一台，不用自己配置\n私服仓库与项目版本 私服仓库说明：\nRELEASE：存储自己开发的 RELEASE 发布版本的资源 SNAPSHOT：存储自己开发的 SNAPSHOT 发布版本的资源 Central：存储的是从中央仓库下载下来的依赖 项目版本说明：\nRELEASE (发布版本)：功能趋于稳定、当前更新停止，可以用于发行的版本，存储在私服中的RELEASE仓库中 SNAPSHOT (快照版本)：功能不稳定、尚处于开发中的版本，即快照版本，存储在私服的SNAPSHOT仓库中 配置 设置私服的访问用户名与密码，在 Maven 安装目录的 conf/settings.xml 的 servers 配置\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;servers\u0026gt; \u0026lt;server\u0026gt; \u0026lt;id\u0026gt;maven-releases\u0026lt;/id\u0026gt; \u0026lt;username\u0026gt;admin\u0026lt;/username\u0026gt; \u0026lt;password\u0026gt;admin\u0026lt;/password\u0026gt; \u0026lt;/server\u0026gt; \u0026lt;server\u0026gt; \u0026lt;id\u0026gt;maven-snapshots\u0026lt;/id\u0026gt; \u0026lt;username\u0026gt;admin\u0026lt;/username\u0026gt; \u0026lt;password\u0026gt;admin\u0026lt;/password\u0026gt; \u0026lt;/server\u0026gt; \u0026lt;/servers\u0026gt; 设置私服依赖下载的仓库组地址，文件同上，mirrors 与 profiles 标签\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 \u0026lt;mirrors\u0026gt; \u0026lt;mirror\u0026gt; \u0026lt;id\u0026gt;maven-public\u0026lt;/id\u0026gt; \u0026lt;mirrorOf\u0026gt;*\u0026lt;/mirrorOf\u0026gt; \u0026lt;url\u0026gt;http://127.0.0.1:8081/repository/maven-public/\u0026lt;/url\u0026gt; \u0026lt;/mirror\u0026gt; \u0026lt;/mirrors\u0026gt; \u0026lt;profiles\u0026gt; \u0026lt;profile\u0026gt; \u0026lt;id\u0026gt;allow-snapshots\u0026lt;/id\u0026gt; \u0026lt;activation\u0026gt; \u0026lt;activeByDefault\u0026gt;true\u0026lt;/activeByDefault\u0026gt; \u0026lt;/activation\u0026gt; \u0026lt;repositories\u0026gt; \u0026lt;repository\u0026gt; \u0026lt;id\u0026gt;maven-public\u0026lt;/id\u0026gt; \u0026lt;url\u0026gt;http://127.0.0.1:8081/repository/maven-public/\u0026lt;/url\u0026gt; \u0026lt;releases\u0026gt; \u0026lt;enabled\u0026gt;true\u0026lt;/enabled\u0026gt; \u0026lt;/releases\u0026gt; \u0026lt;snapshots\u0026gt; \u0026lt;enabled\u0026gt;true\u0026lt;/enabled\u0026gt; \u0026lt;/snapshots\u0026gt; \u0026lt;/repository\u0026gt; \u0026lt;/repositories\u0026gt; \u0026lt;/profile\u0026gt; \u0026lt;/profiles\u0026gt; pom 文件配置上传地址，在父工程中配置即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;distributionManagement\u0026gt; \u0026lt;!-- release版本的发布地址 --\u0026gt; \u0026lt;repository\u0026gt; \u0026lt;id\u0026gt;maven-releases\u0026lt;/id\u0026gt; \u0026lt;url\u0026gt;http://127.0.0.1:8081/repository/maven-releases/\u0026lt;/url\u0026gt; \u0026lt;/repository\u0026gt; \u0026lt;!-- snapshot版本的发布地址 --\u0026gt; \u0026lt;snapshotRepository\u0026gt; \u0026lt;id\u0026gt;maven-snapshots\u0026lt;/id\u0026gt; \u0026lt;url\u0026gt;http://127.0.0.1:8081/repository/maven-snapshots/\u0026lt;/url\u0026gt; \u0026lt;/snapshotRepository\u0026gt; \u0026lt;/distributionManagement\u0026gt; 配置完成后，执行父工程的 deploy 生命周期即可将项目发布到私服仓库\n","date":"2024-01-13T23:58:42+08:00","permalink":"https://blog.yexca.net/archives/143/","title":"Maven 学习"},{"content":"SpringBoot 入门例子 需求：使用 SpringBoot 开发一个 web 应用，浏览器发起 /hello 后，返回字符串 “Hello Spring”\n首先需要创建 SpringBoot 工程，并勾选 web 开发相关依赖\n然后创建控制类，路径在 *Application.java 同级创建文件 Controller/HelloController.java\n1 2 3 4 5 6 7 8 9 @RestController public class HelloController{ @RequestMapping(\u0026#34;/hello\u0026#34;) public String hello(){ String s = \u0026#34;Hello Spring\u0026#34;; System.out.println(s); return s; } } 运行 *Application.java 类，在浏览器访问 http://localhost:8080/hello HTTP 超文本传输协议基于 TCP 协议 (面向连接，安全) ，基于请求-响应模型 (一次请求对应一次响应)\nHTTP 协议是无状态的协议，对于事务处理没有记忆能力。每次请求-响应都是独立的，使得它速度快，相对的多次请求间不能共享数据\n其他详见： https://blog.yexca.net/archives/64 ","date":"2024-01-10T17:53:18+08:00","permalink":"https://blog.yexca.net/archives/142/","title":"JavaWeb 入门"},{"content":"新建目录，将网页文件放入 ./dict\n根目录装进文件 dockerfile 内容如下：\n1 2 3 4 5 6 # 基于nginx:1.20镜像 FROM nginx:1.20 # 将dist文件中的内容复制到 /usr/share/nginx/html/ 这个目录下面 COPY dist/ /usr/share/nginx/html/dist/ # 用本地的 nginx.conf 配置来替换nginx镜像里的默认配置 COPY nginx.conf /etc/nginx/nginx.conf 新建文件 nginx.conf 内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #user nobody; worker_processes 1; events { worker_connections 1024; } http { include mime.types; default_type application/octet-stream; sendfile on; #tcp_nopush on; keepalive_timeout 65; # HTTP server server { listen 80; server_name localhost; location / { root /usr/share/nginx/html/dist; index index.html index.htm; } error_page 500 502 503 504 /50x.html; location = /50x.html { root html; } } } 运行打包命令\n1 docker build -t username/imagename:v1.0 . tag 修改镜像名称 推送镜像的命名规范\n1 docker push 注册用户名/镜像名 修改 tag\n1 docker tag name username/imagename:v1.0 如果不加 tag ，推送时默认为 latest ，推送\n1 docker push username/imagename:v1.0 参考文章 docker: 打包h5项目的镜像 Docker镜像推送（push）到Docker Hub ","date":"2024-01-09T21:50:25+08:00","permalink":"https://blog.yexca.net/archives/141/","title":"Docker 创建与推送 H5 镜像"},{"content":"简单介绍设计模式\n设计模式 引 具体的设计模式\n创建型 结构型 行为型 类 工厂方法模式 适配器模式 (类) 解释器模式 模板方法模式 对象 抽象工厂模式\n生成器模式 原型模式 单例模式 适配器模式 (对象)\n桥接模式 组合模式 装饰器模式 外观模式 享元模式 代理模式 责任链模式 命令模式 迭代器模式 中介者模式 备忘录模式 观察者模式 状态模式 策略模式 访问者模式 其中\n工厂方法模式 与 抽象工厂模式 在 工厂模式 适配器模式 描述了类与对象\n推荐阅读 https://refactoringguru.cn/design-patterns ","date":"2023-12-27T16:14:15+08:00","permalink":"https://blog.yexca.net/archives/140/","title":"设计模式 Index"},{"content":"Visitor Pattern 对象行为型模式\n意图 表示一个作用于某对象结构中的各元素的操作。它不允许在不改变各元素的类的前提下定义作用于这些元素的新操作\n结构 其中：\nVisitor (访问者) 为该对象结构中 ConcreteElement 的每一个类声明一个 Visit 操作。该操作的名字和特殊标识了发送 Visit 请求给该访问者的那个类，这使得访问者可以确定正被访问元素的具体的类。这样访问者就可以通过该元素的特定接口直接访问它 ConcreteVisitor (具体访问者) 实现每个有 Visitor 声明的操作，每个操作实现本算法的一部分，而该算法片段乃是对应于结构中对象的类。ConcreteVisitor 为该算法提供了上下文并存储它的局部状态。这一状态常常在遍历该结构的过程中累积结构 Element (元素) 定义以一个访问者为参数的 Accept 操作 ConcreteElement (具体元素) 实现以一个访问者为参数的 Accept 操作 ObjectStructure (对象结构) 能枚举它的元素；可以提供一个高层的接口以允许该访问者访问它的元素；可以是一个组合或者一个集合，如一个列表或一个无序集合 适用性 Visitor 模式适用于：\n一个对象结构包含很多类对象，它们有不同的接口，而用户想对这些对象实施一些依赖于其具体类的操作 需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而又想要避免这些操作 \u0026ldquo;污染\u0026rdquo; 这些对象的类。Visitor 使得用户可以将相关的操作集中起来定义一个类中。当该对象结构被很多应用共享时，用 Visitor 模式让每个应用仅包含需要用到的操作 定义对象结构的类很少改变，但经常需要在此结构上定义新的操作。改变对象结构类需要重定义对所有访问者的接口，这可能需要很大的代价。如果对象结构类经常改变，那么可能还是在这些类中定义这些操作比较好 例子 1 某图书管理系统中管理着两种类型的文献：图书和论文。现在要求统计所有馆藏文献的总页码，采用 Visitor (访问者) 模式实现该要求，类图如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 interface LibraryVisitor{ void visit(Book p_book); void visit(Article p_article); void printSum(); } class LibrarySumPrintVisitor implements LibraryVisitor{ // 打印总页数 private int sum = 0; @Override public void visit(Book p_book) { sum = sum + p_book.getNumberOfPages(); } @Override public void visit(Article p_article) { sum = sum + p_article.getNumberOfPages(); } @Override public void printSum() { System.out.println(\u0026#34;SUM = \u0026#34; + sum); } } interface LibraryItemInterface{ void accept(LibraryVisitor visitor); } class Article implements LibraryItemInterface{ private String m_title; // 论文名 private String m_author; // 论文作者 private int m_start_page; private int m_end_page; public Article(String p_author, String p_title, int p_start_page, int p_end_page){ m_title = p_title; m_author = p_author; m_start_page = p_start_page; m_end_page = p_end_page; } public int getNumberOfPages(){ return m_end_page - m_start_page; } @Override public void accept(LibraryVisitor visitor) { visitor.visit(this); } } class Book implements LibraryItemInterface{ private String m_title; // 书名 private String m_author; // 书作者 private int m_pages; // 页数 public Book(String p_author, String p_title, int p_pages){ m_title = p_title; m_author = p_author; m_pages = p_pages; } public int getNumberOfPages(){ return m_pages; } @Override public void accept(LibraryVisitor visitor) { visitor.visit(this); } } 例子 2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 import java.util.ArrayList; import java.util.List; public class VisitorPattern { public static void main(String[] args) { PersonStructure personStructure = new PersonStructure(); Visitor1 visitor1 = new Visitor1(); System.out.println(\u0026#34;For Visitor1\u0026#34;); personStructure.Accept(visitor1); System.out.println(\u0026#34;The sum of student age: \u0026#34; + visitor1.getStudentAgeSum()); System.out.println(\u0026#34;The sum of teacher age: \u0026#34; + visitor1.getTeacherAgeSum()); Visitor2 visitor2 = new Visitor2(); System.out.println(\u0026#34;For Visitor2\u0026#34;); personStructure.Accept(visitor2); System.out.println(\u0026#34;Max score: \u0026#34; + visitor2.getMaxScore()); System.out.println(\u0026#34;Max work year: \u0026#34; + visitor2.getMaxWorkYear()); } } interface Visitor{ public void VisitS(Student student); public void VisitT(Teacher teacher); } class Visitor1 implements Visitor{// 分别统计学生和老师的年龄总和 private int studentAgeSum = 0; private int teacherAgeSum = 0; public int getStudentAgeSum() { return studentAgeSum; } public int getTeacherAgeSum() { return teacherAgeSum; } @Override public void VisitS(Student student){ System.out.println(\u0026#34;Visitor1: \u0026#34; + student.getName() + \u0026#34; Age: \u0026#34; + student.getAge()); studentAgeSum += student.getAge(); } public void VisitT(Teacher teacher){ System.out.println(\u0026#34;Visitor1: \u0026#34; + teacher.getName() + \u0026#34; Age: \u0026#34; + teacher.getAge()); teacherAgeSum += teacher.getAge(); } } class Visitor2 implements Visitor{ // 分别求出学生最高成绩以及老师最高工龄 private int maxScore = -1; private int maxWorkYear = -1; public int getMaxScore() { return maxScore; } public int getMaxWorkYear() { return maxWorkYear; } @Override public void VisitS(Student student){ System.out.println(\u0026#34;Visitor2: \u0026#34; + student.getName() + \u0026#34; Score: \u0026#34; + student.getScore()); if(student.getScore() \u0026gt; maxScore) maxScore = student.getScore(); // maxScore = Math.max(maxScore, student.getScore()); } public void VisitT(Teacher teacher){ System.out.println(\u0026#34;Visitor2: \u0026#34; + teacher.getName() + \u0026#34; WorkYear: \u0026#34; + teacher.getWorkYear()); if(teacher.getWorkYear() \u0026gt; maxWorkYear) maxWorkYear = teacher.getWorkYear(); // maxWorkYear = Math.max(maxWorkYear, teacher.getWorkYear()); } } class PersonStructure{ private List\u0026lt;Person\u0026gt; personList = new ArrayList\u0026lt;\u0026gt;(); public PersonStructure(){ personList.add(new Student(\u0026#34;Mike\u0026#34;, 16, 99)); personList.add(new Student(\u0026#34;Jane\u0026#34;, 15, 100)); personList.add(new Teacher(\u0026#34;Alice mana\u0026#34;, 20, 1)); } public void Accept(Visitor visitor){ for(Person p : personList){ p.Accept(visitor); } } } abstract class Person{ private String name; private int age; public abstract void Accept(Visitor visitor); public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } } class Student extends Person{ private int score; public int getScore() { return score; } public Student(String name, int age, int score){ this.setName(name); this.setAge(age); this.score = score; } @Override public void Accept(Visitor visitor){ visitor.VisitS(this); } } class Teacher extends Person{ private int workYear; public int getWorkYear() { return workYear; } public Teacher(String name, int age, int workYear){ this.setName(name); this.setAge(age); this.workYear = workYear; } @Override public void Accept(Visitor visitor){ visitor.VisitT(this); } } ","date":"2023-12-26T16:09:09+08:00","permalink":"https://blog.yexca.net/archives/139/","title":"访问者模式"},{"content":"Template Method Pattern 类行为型模式\n意图 定义一个操作中的算法骨架，而将一些步骤延迟到子类中。Template Method 使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤\n结构 其中：\nAbstractClass (抽象类) 定义抽象的原语操作，具体的子类将重定义它们以实现一个算法的各步骤；实现模板方法，定一个算法的骨架，该模板方法不仅调用原语操作，也调用定义在 AbstractClass 或其他对象中的操作 ConcreteClass (具体类) 实现原语操作以完成算法中与特定子类相关的步骤 适用性 Template Method 模式适用于：\n一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现 各子类中公共的行为应被提取出来并集中到一个公共父类中，以避免代码重复 控制子类扩展。模板方法旨在特定点调用 \u0026ldquo;hook\u0026rdquo; 操作 (默认的行为，子类可以在必要时进行重定义扩展) ，这就只允许在这些点进行扩展 例子 去课堂，学生是上课，写作业；老师授课，批改作业\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 public class TemplateMethodPattern { public static void main(String[] args) { Person stu = new Student(); Person tec = new Teacher(); stu.TemplateMethod(); System.out.println(\u0026#34;==========\u0026#34;); tec.TemplateMethod(); } } abstract class Person{ public void TemplateMethod(){ System.out.println(\u0026#34;go to class\u0026#34;); PrimitiveOperation1(); System.out.println(\u0026#34;End of class\u0026#34;); PrimitiveOperation2(); } public abstract void PrimitiveOperation1(); // 原语操作1：上课：学生：听课；老师：讲课 public abstract void PrimitiveOperation2(); // 原语操作2：作业：学生：做作业；老师：改作业 } class Student extends Person{ @Override public void PrimitiveOperation1(){ System.out.println(\u0026#34;Listen\u0026#34;); } public void PrimitiveOperation2(){ System.out.println(\u0026#34;Do assignments\u0026#34;); } } class Teacher extends Person{ @Override public void PrimitiveOperation1(){ System.out.println(\u0026#34;Teach\u0026#34;); } public void PrimitiveOperation2(){ System.out.println(\u0026#34;Grade assignments\u0026#34;); } } ","date":"2023-12-25T21:06:06+08:00","permalink":"https://blog.yexca.net/archives/138/","title":"模板方法模式"},{"content":"Strategy Pattern 对象行为型模式\n意图 定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。此模式使得算法可以独立于使用它们的客户而变化\n结构 其中：\nStrategy (策略) 定义所有支持的算法的公共接口。Context 使用这个接口来调用某 ConcreteStrategy 定义的算法\nConcreteStrategy (具体策略) 以 Strategy 接口实现某具体算法\nContext (上下文) 用一个 ConcreteStrategy 对象来配置；维护一个对 Strategy 对象的引用；可定义一个接口来让 Strategy 访问它的数据\n适用性 Strategy 模式适用于：\n许多相关的类仅仅是行为有异。\u0026ldquo;策略\u0026rdquo; 提供了一种用多个行为中的一个行为来配置一个类的方法\n需要使用一个算法的不同变体。例如，定义一些反映不同空间的空间/时间权衡的算法。当这些变体实现为一个算法的类层次吋，可以使用策略模式\n算法使用客户不应该知道的数裾。可使用策略模式以避免暴露复杂的、与算法相关的数据结构\n一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，将相关的条件分支移入它们各自的 Strategy 类中，以代替这些条件语句\n例子 1 某大型购物中心欲开发一套收银软件，要求其能够支持购物中心在不同时期推出的各种促销活动，如打折、返利 (例如，满300返100) 等等。现采用策略模式实现该要求，所设计的类图如下所示\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 import java.util.*; enum TYPE { NORMAL, CASH_DISCOUNT, CASH_RETURN}; interface CashSuper { public double acceptCash(double money); } class CashNormal implements CashSuper { // 正常收费子类 public double acceptCash(double money) { return money; } } class CashDiscount implements CashSuper { private double moneyDiscount; // 折扣率 public CashDiscount(double moneyDiscount) { this moneyDiscount = moneyDiscount; } public double acceptCash(double money) { return money* moneyDiscount; } } class CashReturn implements CashSuper { // 满额返利 private double moneyCondition; private double moneyReturn; public CashReturn(double moneyCondition, double moneyReturn) { this.moneyCondition = moneyCondition; // 满额数额 this.moneyReturn = moneyReturn; // 返利数额 } public double acceptCash(double money) { double result = money; if(money \u0026gt;= moneyCondition ) result = money - Math.floor(money / moneyCondition) * moneyReturn; return result; } } class CashContext { private CashSuper cs; private TYPE t; public CashContext(TYPE t) { switch(t) { case NORMAL: // 正常收费 cs = new CashNormal(); break; case CASH_DISCOUNT: // 打8折 cs = new CashDiscount(0.8); break; case CASH_RETURN: // 满300返100 cs = new CashReturn(300, 100); break; } } public double GetResult(double money) { return cs.acceptCash(money); } // 此处略去main()函数 } 例子 2 加减乘\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 public class StrategyPattern { public static void main(String[] args) { Strategy add = new AddStrategy(); Strategy subtraction = new SubtractionStrategy(); Strategy multiply = new MultiplyStrategy(); OperationContext context = new OperationContext(add); context.Operation(1, 2); context = new OperationContext(subtraction); context.Operation(1, 2); context = new OperationContext(multiply); context.Operation(1, 2); } } class OperationContext{ private Strategy strategy; public OperationContext(Strategy strategy){ this.strategy = strategy; } public void Operation(int a, int b){ strategy.operation(a, b); } } interface Strategy{ public void operation(int a, int b); } class AddStrategy implements Strategy{ @Override public void operation(int a, int b){ System.out.println(a + b); } } class SubtractionStrategy implements Strategy{ @Override public void operation(int a, int b){ System.out.println(a - b); } } class MultiplyStrategy implements Strategy{ @Override public void operation(int a, int b){ System.out.println(a * b); } } ","date":"2023-12-24T18:30:30+08:00","permalink":"https://blog.yexca.net/archives/137/","title":"策略模式"},{"content":"State Pattern 对象行为型模式\n意图 允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类\n结构 其中：\nContext (上下文) 定义客户感兴趣的接口：维护一个 ConcerteState 子类的实例，这个实例定义当前状态\nState (状态) 定义一个接口以封装与 Context 的一个特定状态相关的行为\nConcreteState (具体状态子类) 毎个子类实现与 Context 的一个状态相关的行为\n适用性 一个对象的行为决定于它的状态，并且它必领在运行吋刻根据状态改变它的行为\n一个操作中含有庞大的多分支的条件语句，且这些分支依赖于该对象的状态。这个状态常用一个或多个枚举常量表示。通常，有多个操作包含这一相同的条件结构，State 模式将毎一个条件分支放入一个独立的类中。这使得开发者可以根据对象自身的情况将对象的状态作为一个对象，这一对象可以不依赖于其他对象独立变化\n例子 1 某大型商场内安装了多个简易的纸巾售卖机，自动出售2元钱一包的纸巾，且每次仅售出一包纸巾。纸巾售卖机的状态图如下图所示\n采用状态 (State) 模式来实现该纸巾售卖机，得到如下图所示的类图。其中类 State 为抽象类，定义了投币、退币、出纸巾等方法接口。类 SoldState、SoldOutState、NoQuarterState 和 HasQuarterState 分别对应上图中纸巾售卖机的4种状态：售出纸巾、纸巾售完、没有投币、有2元钱\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 import java.util.*; interface State { public void insertQuarter();\t// 投币 public void ejectQuarter();\t// 退币 public void turnCrank();\t// 按下“出纸巾”按钮 public void dispense();\t// 出纸巾 } class TissueMachine { State soldOutState, noQuarterState, hasQuarterState, soldState, state; state = soldOutState; int count = 0; // 纸巾数 public TissueMachine(int numbers) { /* 实现代码省略 */ } public State getHasQuarterState() { return hasQuarterState; } public State getNoQuarterState() { return noQuarterState; } public State getSoldState() { return soldState; } public State getSoldOutState() { return soldOutState; } public int getCount() { return count; } // 其余代码省略 } class NoQuarterState implements State { TissueMachine tissueMachine; public void insertQuarter() { tissueMachine.setState(tissueMachine.getHasQuarterState()); } // 构造方法以及其余代码省略 } class HasQuarterState implements State { TissueMachine tissueMachine; public void ejectQuarter() { tissueMachine.setState(tissueMachine.getNoQuarterState()); } // 构造方法以及其余代码省略 } class SoldState implements State { TissueMachine tissueMachine; public void dispense() { if (tissueMachine.getCount() \u0026gt; 0) { tissueMachine.setState(tissueMachine.getNoQuarterState()); } else { tissueMachine.setState(tissueMachine.getSoldOutState()); } } } 例子 2 某航空公司的会员积分系统将其会员划分为：普卡 (Basic)、银卡 (Silver) 和金卡 (Gold) 三个等级。非会员 (NonMember) 可以申请成为普卡会员。会员的等级根据其一年内累积的里程数进行调整。描述会员等级调整的状态图如下图所示\n现采用状态 (State) 模式实现上述场景，得到如下图所示的类图\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 import java.util.*; abstract class CState { public int flyMiles; // 里程数 public abstract double travel(int miles, CFrequentFlyer context); // 根据累积里程数调整会员等级 } class CNoCustomer extends CState { // 非会员 public double travel(int miles, CFrequentFlyer context) { System.out.println(\u0026#34;Your travel will not account for points\u0026#34;); return miles; // 不累积里程数 } } class CBasic extends CState { // 普卡会员 public double travel(int miles, CFrequentFlyer context) { if (context.flyMiles \u0026gt;= 25000 \u0026amp;\u0026amp; context.flyMiles \u0026lt; 50000) context.setState(new CSilver()); if (context.flyMiles \u0026gt;= 50000) context.setState(new CGold()); return miles; } } class CGold extends CState { // 金卡会员 public double travel(int miles, CFrequentFlyer context) { if (context.flyMiles \u0026gt;= 25000 \u0026amp;\u0026amp; context.flyMiles \u0026lt; 50000) context.setState(new CSilver()); if (context.flyMiles \u0026lt; 25000); context.setState(new CBasic()); return miles + 0.5 * miles; // 累积里程数 } } class CSilver extends CState { // 银卡会员 public double travel(int miles, CFrequentFlyer context) { if (context.flyMiles \u0026lt;= 25000) context.setState(new CBasic()); if (context.flyMiles \u0026gt;= 50000) context.setState(new CGold()); return (miles + 0.25 * miles); // 累积里程数 } } class CFrequentFlyer { CState state; double flyMiles; public CFrequentFlyer() { state = new CNoCustomer(); flyMiles = 0; setState(state); } public void setState(CState state) { this.state = state; } public void travel(int miles) { double bonusMiles = state.travel(miles, this); flyMiles = flyMiles + bonusMiles; } } 例子 3 自动贩卖机，有货与无货\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 public class StatePattern { public static void main(String[] args) { Context context = new Context(); context.Request(); // count = 2 context.Request(); // count = 1 context.Request(); // count = 0 context.Request(); // switch to State A context.Request(); // count = 4 } } class Context{ // 贩卖机 private int count; private State state; public Context(){ count = 3; state = new StateA(); } public int getCount() { return count; } public State getState() { return state; } public void setCount(int count) { this.count = count; } public void setState(State state) { this.state = state; } public void Request(){ // 购买饮料 state.Handle(this); } } interface State{ public void Handle(Context context); } class StateA implements State{ // 有货 @Override public void Handle(Context context){ int count = context.getCount(); if(count \u0026gt;= 1){ context.setCount(count - 1); System.out.println(\u0026#34;Complete! あと\u0026#34; + context.getCount() + \u0026#34;個\u0026#34;); if(context.getCount() == 0){ context.setState(new StateB()); } }else{ System.out.println(\u0026#34;Refused!\u0026#34;); } } } class StateB implements State{ // 无货 @Override public void Handle(Context context){ int count = context.getCount(); if(count == 0){ System.out.println(\u0026#34;Refused!\u0026#34;); context.setCount(5); System.out.println(\u0026#34;Please try again\u0026#34;); context.setState(new StateA()); }else { context.setState(new StateA()); context.Request(); } } } ","date":"2023-12-22T15:11:16+08:00","permalink":"https://blog.yexca.net/archives/136/","title":"状态模式"},{"content":"Asynchronous JavaScript And XML，异步的 JS 和 XML。作用：\n数据交换：通过 Ajax 可以给服务器发送请求，并获取服务器响应的数据 异步交互：可以在不重新加载整个页面的情况下，与服务器交换数据并更新部分网页的技术 使用场景：搜索联想、用户名是否可用等\n同步与异步 同步指在访问网页时进行某操作需要请求服务器，在服务器处理时网页不可操作，直到服务器响应客户端时才可继续操作\n而异步在请求服务器的同时，客户端可以执行其他操作\n原生 Ajax 首先创建 XMLHttpRequest 对象 (用于和服务器交换数据)，然后向服务器发送请求，最后获取服务器响应数据\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Ajax\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;获取数据\u0026#34; onclick=\u0026#34;getDate()\u0026#34;\u0026gt; \u0026lt;div id=\u0026#34;div1\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; function getDate(){ // 创建XMLHttpRequest var xmlHttpRequest = new XMLHttpRequest(); // 发送异步请求 xmlHttpRequest.open(\u0026#39;GET\u0026#39;, \u0026#39;//127.0.0.1:8080/listEmp\u0026#39;); xmlHttpRequest.send(); // 获取服务响应数据 xmlHttpRequest.onreadystatechange=function(){ if(xmlHttpRequest.readyState==4 \u0026amp;\u0026amp; xmlHttpRequest.status==200){ document.getElementById(\u0026#34;div1\u0026#34;).innerHTML=xmlHttpRequest.responseText; } } } \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; 详细参考： https://www.w3school.com.cn/js/js_ajax_intro.asp Axios Axios 对原生的 Ajax 进行了封装，简化书写，快速开发。官网： https://www.axios-http.cn/ 使用 Axios 需要先引入 Axios 文件\n1 \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 使用 Axios 发送请求并响应结果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Axios\u0026lt;/title\u0026gt; \u0026lt;!-- 文件下载到了本地 --\u0026gt; \u0026lt;script src=\u0026#34;./js/axios-0.18.0.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;获取数据\u0026#34; onclick=\u0026#34;getData()\u0026#34;\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; function getData(){ axios({ method: \u0026#34;get\u0026#34;, url: \u0026#34;//127.0.0.1:8080/listEmp\u0026#34; }).then(result =\u0026gt; { console.log(result.data); }) } \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; 上述是 GET 方法，POST 方法需要添加数据\n1 2 3 4 5 6 7 8 9 function deleteData(){ axios({ method: \u0026#34;POST\u0026#34;, url: \u0026#34;//127.0.0.1:8080/deleteEmpById\u0026#34;, data: \u0026#34;id=1\u0026#34; }).then(result =\u0026gt; { console.log(result.data); }) } 当然，这样写还是过于繁琐，Axios 提供了别名\naxios.get(url[, config]) axios.delete(url[, config]) axios.post(url[, data[, config]]) axios.put(url[, data[, config]]) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 function getData(){ // axios({ // method: \u0026#34;get\u0026#34;, // url: \u0026#34;//127.0.0.1:8080/listEmp\u0026#34; // }).then(result =\u0026gt; { // console.log(result.data); // }) axios.get(\u0026#34;//127.0.0.1:8080/listEmp\u0026#34;).then(result =\u0026gt; { console.log(result.data); }) } function deleteData(){ // axios({ // method: \u0026#34;POST\u0026#34;, // url: \u0026#34;//127.0.0.1:8080/deleteEmpById\u0026#34;, // data: \u0026#34;id=1\u0026#34; // }).then(result =\u0026gt; { // console.log(result.data); // }) axios.post(\u0026#34;//127.0.0.1:8080/deleteEmpById\u0026#34;,\u0026#34;id=1\u0026#34;).then(result =\u0026gt; { console.log(result.data); }) } ","date":"2023-12-21T13:32:15+08:00","permalink":"https://blog.yexca.net/archives/135/","title":"Ajax 与 Axios"},{"content":"Observer Pattern 对象行为型模式\n意图 定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变吋，所有依赖于它的对象都得到通知并被自动更新\n结构 其中：\nSubject (目标) 知道它的观察者，可以有任意多个观察者观察同一个目标；提供注册和删除观察者对象的接口 Observer (观察者) 为那些在\u0026quot;目标发生改变时需获得通知的对象定义一个更新接口 ConcreteSubject (具体目标) 将有关状态存入各 ConcreteObserver 对象：当它的状态发生改变时，向它的各个观察者发出通知 ConcreteObserver (具体观察者) 维护一个指向 ConcreteSubject 对象的引用：存储有关状态，这些状态应与目标的状态保持一致：实现 Observer 的更新接口，以使自身状态与目标的状态保持一致 适用性 Observer 模式适用于：\n当一个抽象模型有两个方面，其中一个方面依赖于另一个方面，将这两者封装在独立的对象中以使它们可以各自独立地改变和复用 当对一个对象的改变需要同时改变其他对象，而不知道具休有多少对象有待改变吋 当一个对象必须通知其他对象，向它又不能假定其他对象是谁，即不希望这些对象是紧耦合的 例子 1 某文件管理系统中定义了类 OfficeDoc 和 DocExplorer。当类 OfficeDoc 发生变化时，类 DocExplorer 的所有对象都要更新其自身的状态。现采用观察者 (Observer) 设计模式来实现该需求，所设计的类图如下图所示\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 import java.util.*; interface Observer { public void update(); } interface Subject { public void Attach(Observer obs); public void Detach(Observer obs); public void Notify(); public void setStatus(int status); public int getStatus(); } class OfficeDoc implements Subject { private List\u0026lt;Observer\u0026gt; myObs; private String mySubjectName; private int m_status; public OfficeDoc(String name) { mySubjectName = name; this.myObs = new ArrayList\u0026lt;Observer\u0026gt;(); m_status = 0; } public void Attach(Observer obs) { this.myObs.add(obs); } public void Detach(Observer obs) { this.myObs.remove(obs); } public void Notify() { for (Observer obs : this.myObs) {obs.update(); } } public void setStatus(int status) { m_status = status; System.out.println(\u0026#34;SetStatus subject[\u0026#34; + mySubjectName + \u0026#34;]status:\u0026#34; + status); } public int getStatus() { return m_status; } } class DocExplorer implements Observer { private String myObsName; public DocExplorer(String name,Subject sub) { myObsName = name; sub.Attach(this); } public void update() { System.out.println(\u0026#34;update observer[\u0026#34; + myObsName + \u0026#34;]\u0026#34;); } } class ObserverTest { public static void main(String[] args) { Subject subjectA = new OfficeDoc(\u0026#34;subject A\u0026#34;); Observer observerA = new DocExplorer(\u0026#34;observer A\u0026#34;, subjectA); subjectA.setStatus(1); subjectA.Notify(); } } 例子 2 Subject 为 Youtuber，Observer 为订阅者\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 import java.util.ArrayList; import java.util.List; public class ObserverPattern { public static void main(String[] args) { Subject subjectA = new ConcerteSubject(); Observer observer1 = new ConcerteObserver(\u0026#34;Mike\u0026#34;, subjectA); Observer observer2 = new ConcerteObserver(\u0026#34;Jane\u0026#34;, subjectA); subjectA.Notify(); } } interface Subject{ // 目标 public void Attach(Observer observer); public void Detach(Observer observer); public void Notify(); public String getState(); public void setState(String state); } class ConcerteSubject implements Subject{ private String state; private List\u0026lt;Observer\u0026gt; observerList; public String getState() { return state; } @Override public void setState(String state) { this.state = state; this.Notify(); } public ConcerteSubject(){ state = \u0026#34;-1\u0026#34;; observerList = new ArrayList\u0026lt;\u0026gt;(); } public void Attach(Observer observer){ observerList.add(observer); } public void Detach(Observer observer){ observerList.remove(observer); } public void Notify(){ for(Observer o : observerList){ o.update(); } } } interface Observer{ // 观察者 public void update(); } class ConcerteObserver implements Observer{ private String name; private Subject subject; private String state; public ConcerteObserver(String name, Subject subject){ this.name = name; this.state = subject.getState(); this.subject = subject; subject.Attach(this); } @Override public void update(){ System.out.println(this.name + \u0026#34; Received\u0026#34;); this.state = subject.getState(); } } ","date":"2023-12-21T01:18:25+08:00","permalink":"https://blog.yexca.net/archives/134/","title":"观察者模式"},{"content":"从 ???? 我记不清了 开始喜欢上 ASMR 后就接触到了音声，不过高昂的价格显然会驱使我去广袤的互联网上搜索，于是便知道了这个网站，可此网站只有登录后才可以看到更多内容，而每年也几乎是不定时开放注册，这使我很好奇这个网站\n于是我便想着让服务器运行程序检测是否可以注册，然后通知\nGithub: yexca/hvdb 目标 检测是否可以注册，如果可以便通过 Telegram 通知\n检测是否可以注册 在 灵梦广场 的一个帖子回复中可以获知当开放注册时 login 的底下会出现 register\n那便可以用一种最简朴的方法，爬取这个网页，检查是否有此单词\nBot 配置 使用 Telegram 的 bot 通知需要先注册一个 bot\n对话 https://t.me/BotFather 输入 /newbot 指令按照步骤创建一个 bot\n和刚创建的 bot 对话，发送 hello\n然后访问 (将 TOKEN 替换为自己的 token)\n1 https://api.telegram.org/botTOKEN/getUpdates 会得到一个 json 文件，找到 id，此 id 为 chat_id\n参考： 使用Telegram Bot来实现推送通知 Python 通过 Python 是最简单的 (我也懒得看其他语言了)\n爬取使用 Requests 库，通知的话使用 pyTelegramBotAPI 多余的不解析了，直接放代码 (此文件名不要命名为 http.py 或 requests.py)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 import telebot import requests import time # 替换自己的 token bot = telebot.TeleBot(\u0026#34;TOKEN\u0026#34;, parse_mode=\u0026#34;MARKDOWN\u0026#34;) # You can set parse_mode by default. HTML or MARKDOWN def inform(): web = requests.get(\u0026#34;https://hvdb.me/\u0026#34;) str = web.text a = str.find(\u0026#34;register\u0026#34;) if a != -1: # 替换自己的 chat_id bot.send_message(\u0026#34;chat_id\u0026#34;, \u0026#34;[hvdb](http://hvdb.me/) register start\u0026#34;) t = 0 while True: inform() # 每小时执行一次 time.sleep(3600) # 计时是否执行了 24 小时 t += 1 # 每天提醒一次程序在执行 if t == 24: t -= 24 local_time = time.ctime(time.time()) inform_str = \u0026#34;{} 已执行\u0026#34;.format(local_time) # 替换自己的 chat_id bot.send_message(\u0026#34;chat_id\u0026#34;, inform_str) 参考资料\n关于报错“AttributeError:partially initialized module‘requests‘has no attribute‘get‘的解决方法 requests - 廖雪峰的官方网站 Python time sleep()方法 - 菜鸟教程 Python 日期和时间 - 菜鸟教程 Docker 封装 文件结构\n1 2 3 D:\\DOCKER\\HVDB Dockerfile inform.py Dockerfile 文件\n1 2 3 4 5 6 FROM python:3.11-alpine RUN pip install requests \\ \u0026amp;\u0026amp; pip install pyTelegramBotAPI COPY ./inform.py /app/inform.py CMD [ \u0026#34;python\u0026#34;, \u0026#34;/app/inform.py\u0026#34; ] 同目录下运行命令打包镜像\n1 docker build -t hvdb:v1.0 . 转移到服务器 Windows 下\n1 docker save -o hvdb:v1.0 hvdb.tar 等待打包完成，复制到服务器\n1 scp .\\hvdb.tar username@hostname:/path 复制完成后，服务器运行\n1 docker load -i hvdb.tar 参考： docker load报错：Error processing tar file(exit status 1): archive/tar: invalid tar header ","date":"2023-12-02T21:23:01+08:00","permalink":"https://blog.yexca.net/archives/133/","title":"hvdb 注册检测"},{"content":"Memento Pattern 对象行为型模式\n意图 在不破坏封装性的前提下捕获一个对象的内部状态，并在对象之外保存这个状态。这样以后就可以将对象恢复到原先保存的状态\n结构 其中：\nMemento (备忘录) 存储原发器对象的内部状态，原发器根据需要决定备忘录存储原发器的哪些内部状态；防止原发器以外的其他对象访问备忘录 Originator (原发器) 创建一个备忘录，用于记录当前时刻它的内部状态；使用备忘录恢复内部状态 Caretaker (管理者) 负责保存好备忘录；不能对备忘录的内容进行操作或检查 适用性 Memento 模式适用于：\n必须保存一个对象在某一个时刻的 (部分) 状态，这样以后需要时它才能恢复到先前的状态 如果一个用接口来让其他对象直接得到这些状态，将会暴露对象的实现细节并破坏对象的封装性 例子 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 import java.util.ArrayList; import java.util.List; public class MementoPattern { public static void main(String[] args) { Caretaker caretaker = new Caretaker(); Originator originator = new Originator(); originator.setState(\u0026#34;first\u0026#34;); Memento memento1 = originator.createMemento(); caretaker.addMemento(memento1); originator.setState(\u0026#34;second\u0026#34;); Memento memento2 = originator.createMemento(); caretaker.addMemento(memento2); originator.setState(\u0026#34;third\u0026#34;); Memento memento3 = originator.createMemento(); caretaker.addMemento(memento3); caretaker.showMemento(); Memento backup = caretaker.getMemento(2); originator.setMemento(backup); System.out.println(\u0026#34;=========\u0026#34;); System.out.println(originator.getState()); } } class Originator{ // 原发器 private String state; public void setState(String state){ this.state = state; } public String getState(){ return state; } public Memento createMemento(){ return new Memento(state); } public void setMemento(Memento memento){ state = memento.getState(); } } class Memento{ // 备忘录 private String state; public Memento(String state){ this.state = state; } public String getState(){ return state; } } class Caretaker{ // 管理者 private List\u0026lt;Memento\u0026gt; mementoList = new ArrayList\u0026lt;\u0026gt;(); public void addMemento(Memento memento){ mementoList.add(memento); } public Memento getMemento(int index){ return mementoList.get(index - 1); } public void showMemento(){ int i = 1; for(Memento m : mementoList){ System.out.println(\u0026#34;No.\u0026#34; + i + \u0026#34;: \u0026#34; + m.getState()); i++; } } } ","date":"2023-11-27T14:08:05+08:00","permalink":"https://blog.yexca.net/archives/132/","title":"备忘录模式"},{"content":"自从博客转移到 Github 上后本打算就这样不再购买新服务器的，不过可能是这几个月很平静使得我迫切想折腾一阵，也可能是 我可以不用，但不能没有 的心理使我冲动消费了一次\n目前的网站 (yexca.net 网域) 个人介绍？： http://yexca.net (目前还是半成品) 这个 Blog： http://blog.yexca.net 怀旧 Blog： http://wp.yexca.net VRChat Blog： http://vrc.yexca.net VRChat Docs： http://vrchat.yexca.net Navidrome： http://music.yexca.net (自用) ACG： http://acg.yexca.net (要不是看 DNS 记录我都忘记了，暂时没想好做什么) xlog(Web3)： http://xlog.yexca.net Docker 自从接触了 Docker 以后，我几乎什么项目都会想着用 Docker 部署，毕竟是真好用啊\n系统为 Debian10，root 账号登录，首先更新\n1 apt update 安装软件\n1 apt install curl gpg 更新 gpg\n1 curl -fsSL https://download.docker.com/linux/debian/gpg | gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg 添加 docker 源\n1 2 3 echo \\ \u0026#34;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/debian \\ buster stable\u0026#34; | tee /etc/apt/sources.list.d/docker.list \u0026gt; /dev/null 安装 docker\n1 2 apt update apt install docker-ce docker-ce-cli containerd.io docker-compose 启动 docker\n1 2 systemctl enable docker systemctl start docker 测试是否成功\n1 docker run --rm hello-world 此部分参考： 服务器用 Docker 部署记录 公钥登录 参考： SSH 公钥登录 Nginx 这次和之前一样也是用 nginx-ui 项目，docker 部署，配置文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 version: \u0026#39;3.1\u0026#39; services: nginx-ui: restart: always image: uozi/nginx-ui:latest container_name: nginx_UI volumes: - /home/nginx_ui/nginx:/etc/nginx - /home/nginx_ui/nginx-ui:/etc/nginx-ui - /home/nginx_ui/www:/www ports: - 80:80 - 443:443 如果是 DNS 处启用 HTTPS 的话就不用配置证书了，不然一直访问异常\n个人介绍 事实上在我将上一个服务器的网站全部变成 docker 部署之前就有想法，当时我特意将 Blog 域名从 yexca.xyz 改为 blog.yexca.xyz 就是为了空出域名，没想到都到了下一个服务器我才开始做\n域名 yexca.xyz 已不属于我\n我翻开之前准备的工程，创建时间是 2022.03.07，最后修改 2022.06.29，我这拖延症越来越严重了\n言归正传，事实上产生这个想法是看到了一些博主的个人介绍，例如 https://idealclover.top/ 、 https://the.moe/ 当然还有很多，只是时间有点太长了，实在找不到 (而且有的还更新了，变得更酷了)\n有些会开源，只要填上自己信息就可以自动生成介绍网页 (时间太长找不到项目了)\n不过最终我还是选择模仿 http://lolicon.app 的网页，至于为啥我也忘了 (好像是我去年决定的)\n参考文章\n用 CSS 实现自定义滚动条样式 如何给网站设置favicon.ico图标 Navidrome 冲动消费的一个主要原因还有想搞一个还行的音乐网站自用，之前有一个 基于 Onedrive 的 ，但在大陆访问体验不好，又恰逢 115 出活动，所以有了这篇文章\n体验后：什么玩意，还没 Onedrive 快，冲动是魔鬼，切不可冲动消费\n唉，本来还想着要是效果好再部署一个 kikoeru-express 来着\n首先需要支持挂载 115 网盘的 Rclone\n项目地址： https://github.com/gaoyb7/rclone-release 该项目使用与原 rclone 一致，只是加入了 115 支持\n获取 Cookie Chrome 抓取 Cookie 登录 115 后进入控制台的 Network，刷新网页，找到 cookie.js?_=[number]\n在 Request Headers 可找到 Cookie\nChrome 插件抓取 Cookie 使用插件可以很方便的查看 Cookie\n安装地址： Get cookies.txt LOCALLY App 的 Cookie 网页版 Cookie 时效较短，建议抓取 App 请求获取 Cookie，iOS 系统可使用 Stream 或者 Quantumult X 抓包，安卓系统使用抓包精灵，电脑端选择很多，例如 Fiddler\n这个 Cookie 随便抓一下就出来了，不写了\n配置 Rclone 可以通过命令配置或编辑配置文件\n使用命令配置 运行命令\n1 rclone.exe config 根据需求选择即可，Windows 下完成后配置文件生成在：\n1 C:\\Users\\%USERNAME%\\AppData\\Roaming\\rclone 编辑配置文件 如上目录创建文件 rclone.conf 内容如下\n1 2 3 4 5 [name] type = 115 uid = your_uid cid = your_cid seid = your_seid Windows 挂载测试 Windows 挂载需先安装 winfsp (安装完成后重启一下)\n1 .\\rclone.exe mount -v --read-only --vfs-read-chunk-size=4M --buffer-size=32M --network-mode 115: X: 按 Ctrl+C 结束挂载\nLinux docker 挂载 拉取镜像\n1 docker pull gaoyb7/rclone:latest 挂载\n1 2 3 4 5 6 7 8 9 10 11 12 docker run --rm \\ --volume /home/rclone/config:/config/rclone \\ --volume /home/rclone/data:/data:shared \\ --volume /etc/passwd:/etc/passwd:ro --volume /etc/group:/etc/group:ro \\ --device /dev/fuse --cap-add SYS_ADMIN --security-opt apparmor:unconfined \\ gaoyb7/rclone:latest \\ mount 115:/music /data/music --allow-other --allow-non-empty --vfs-cache-mode writes \u0026amp; # 上述命令仅最后一行为 Rclone 的命令，根据实际情况修改，格式如下 rclone mount DriveName:Folder LocalFolder # DriveName Rclone 挂载的名称 # Folder 云盘的路径 # LocalFolder 挂载到本地的文件 Navidrome 配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 version: \u0026#34;3.0\u0026#34; services: navidrome: image: deluan/navidrome:latest ports: - \u0026#34;8005:4533\u0026#34; restart: unless-stopped environment: # Optional: put your config options customization here. Examples: ND_SCANSCHEDULE: 1h ND_LOGLEVEL: info ND_SESSIONTIMEOUT: 24h ND_BASEURL: \u0026#34;\u0026#34; ND_LASTFM_ENABLED: \u0026#34;true\u0026#34; ND_LASTFM_APIKEY: your_LASTFM_APIKEY ND_LASTFM_SECRET: your_LASTFM_SECRET ND_LASTFM_LANGUAGE: zh ND_SPOTIFY_ID: your_SPOTIFY_ID ND_SPOTIFY_SECRET: your_SPOTIFY_SECRET ND_ENABLESHARING: \u0026#34;true\u0026#34; ND_UILOGINBACKGROUNDURL: \u0026#34;https://www.loliapi.com/acg\u0026#34; #随机图片接口 ND_UIWELCOMEMESSAGE: \u0026#34;主界面会看到的话\u0026#34; volumes: - \u0026#34;/home/navidrome/data:/data\u0026#34; - \u0026#34;/home/rclone/data/music:/music/115:ro\u0026#34; - \u0026#34;/home/navidrome/music:/music/server:ro\u0026#34; Blog 两个 Blog，均参考之前文章部署，部署出来应该也不会更新了\nWordpress yexca\u0026rsquo;Blog 之前用的图片 cdn 不能访问了，我尝试使用一些替换插件无果后懒得折腾了 (背景图片能看就行)\nTypecho VRChat 教程 我长时间不用忘了后台的密码，还好之前做了双重保险保留了备份文件，于是搭建一个新的，再导入数据。图片和上面那个一样，有时间换个 cdn 就好了 (目前只换了封面的)\nWarmaTap 把初音未来的声音替换为 Warma 声音的很好玩的网页\n偏电子音 Github: lwd-temp/warmatap 部署： http://yexca.net/warma_tap 偏人声 Github: MonianHello/WarmaTap 部署： http://yexca.net/warmatap MikuTap Github: HFIProgramming/mikutap 部署： http://yexca.net/mikutap MikuTap 是以 patatap 为灵感制作\n","date":"2023-11-03T15:34:01+08:00","permalink":"https://blog.yexca.net/archives/131/","title":"2023 新服务器部署记录"},{"content":"网站 手机访问即可查看 (只试过 IOS)\n2020: https://st.music.163.com/c/year2020 2021: https://st.music.163.com/c/year2021 2022: https://st.music.163.com/c/year2022 过程 Google 搜索 网易云年度报告，发现 https://st.music.163.com/c/reportreview2020 (手机访问情况下会出现 2020 年度报告入口)，顺着网站试着修改年份，发现 2020-2022 可以查看\n","date":"2023-10-29T23:45:01+08:00","permalink":"https://blog.yexca.net/archives/130/","title":"网易云音乐 2020-2022 年度报告"},{"content":"此文章写于 2022.12，由于多种原因未发布\n该系列文章为我阅读《Linux 系统管理、服务器设置、安全、云数据中心》所书写相关笔记\n第一部分：入门 这部分没有记录文章\n第 01 章 开始使用 Linux Linux 的历史。总结：Linux NB\n第 02 章 创建完美的 Linux 桌面 然后有了 Fedora 桌面折腾 第二部分：成为一名 Linux 高级用户 第 03 章 使用 shell shell 的一些用法与变量\n第 04 章 在文件系统中移动 文件相关 shell 命令、元字符、文件权限\n第 05 章 使用文本文件 vi 编辑器、查找文件 (locate 、find 、grep)\n第 06 章 管理运行中的进程 列出进程，杀死进程，限制进程\n第 07 章 编写简单的 shell 脚本 一些 shell 脚本的语法\n第三部分 称为一名 Linux 系统管理员 第 08 章 学习系统管理 /etc 下配置文件\n第 09 章 安装 Linux(なし) 没有文章。图形化或命令行个人安装。企业中批量安装\n第 10 章 获取和管理软件 RPM 和 DEB 包，yum 、rpm 、dnf 、apt 命令\n第 11 章 获取用户账户 管理用户账户与组账户\n第 12 章 管理磁盘和文件系统 创建文件系统，LVM 逻辑卷，挂载文件系统\n之后还有服务器管理员、Linux 安全技术、将 Linux 拓展到云。因各种原因，不进行笔记书写\n","date":"2023-10-21T14:18:15+08:00","permalink":"https://blog.yexca.net/archives/129/","title":"Linux 学习 Index"},{"content":"Mediator Pattern 对象行为型模式\n意图 用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间地交互\n结构 其中：\nMediator (中介者) 定义一个接口用于各同事 (Colleague) 对象通信 ConcreteMediator (具体中介中介) 通过协调各同事对象实现协作行为；了解并维护它的各个同事 Colleague class (同事类) 知道它的中介者对象；每一个同事类对象在需要与其他同事通信的时候与它的中介者通信 适用性 Mediator 模式适用于：\n一组对象以定义良好但是复杂的方式进行通信，产生的相互依赖关系结构混乱且难以理解 一个对象引用其他很多对象并且直接与这些对象通信，导致难以复用该对象 想定制一个分布在多个类中的行为，而又不想生成太多的子类 例子 1 在线支付是电子商务的一个重要环节，不同的电子商务平台提供了不同的支付接口。现在需要整合不同电子商务平台的支付接口，使得客户在不同平台上购物时，不需要关心具体的支付接口。拟采用中介者 (Mediator) 设计模式来实现该需求，类图如下所示\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 interface WebServiceMediator { public void buy(double money, WebService service); public void SetAmazon(WebService amazon); public void SetEbay(WebService ebay); } abstract class WebService { protected WebServiceMediator mediator; public abstract void SetMediator(WebServiceMediator mediator); public abstract void buyService(double money); public abstract void search(double money); } class ConcreteServiceMediator implements WebServiceMediator { private WebService amazon; private WebService ebay; public ConcreteServiceMediator() { amazon = null; ebay = null; } public void SetAmazon(WebService amazon) { this.amazon = amazon; } public void SetEbay(WebService ebay) { this.ebay = ebay; } public void buy(double money, WebService service) { if (service == amazon) amazon.search(money); else ebay.search(money); } } class Amazon extends WebService { public void SetMediator(WebServiceMediator mediator) { this.mediator = mediator; } public void buyService(double money) { mediator.buy(money, this); } public void search(double money) { System.out.println(\u0026#34;Amazon receive：\u0026#34; + money); } } class Ebay extends WebService { public void SetMediator(WebServiceMediator mediator) { this.mediator = mediator; } public void buyService(double money) { mediator.buy(money, this); } public void search(double money) { System.out.println(\u0026#34;Ebay receive：\u0026#34; + money); } } 例子 2 两个同事之间通信\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 public class MediatorPattern { public static void main(String[] args) { ConcreteMediator m = new ConcreteMediator(); Colleague1 c1 = new Colleague1(m); Colleague2 c2 = new Colleague2(m); m.setC1(c1); m.setC2(c2); c1.sendMessage(\u0026#34;hello\u0026#34;); c2.sendMessage(\u0026#34;hi\u0026#34;); } } abstract class Colleague{ protected Mediator mediator; } class Colleague1 extends Colleague{ public Colleague1(Mediator mediator){ this.mediator = mediator; } public void sendMessage(String message){ mediator.sendMessage(message, this); } public void Notify(String message){ System.out.println(\u0026#34;Colleague1 received: \u0026#34; + message); } } class Colleague2 extends Colleague{ public Colleague2(Mediator mediator){ this.mediator = mediator; } public void sendMessage(String message){ mediator.sendMessage(message, this); } public void Notify(String message){ System.out.println(\u0026#34;Colleague2 received: \u0026#34; + message); } } abstract class Mediator{ public abstract void sendMessage(String message, Colleague c); } class ConcreteMediator extends Mediator{ // 因为此例对象很少，所以直接定义 private Colleague1 c1; private Colleague2 c2; // 如果同事很多 // List\u0026lt;Colleague\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); // public void Add(Colleague c){ // list.add(c); // } public void setC1(Colleague1 c1){ this.c1 = c1; } public void setC2(Colleague2 c2){ this.c2 = c2; } @Override public void sendMessage(String message, Colleague c){ if(c == c1){ // 让同事2收到消息 c2.Notify(message); }else{ // 让同事1收到消息 c1.Notify(message); } } } ","date":"2023-10-15T17:14:26+08:00","permalink":"https://blog.yexca.net/archives/128/","title":"中介者模式"},{"content":"Iterator Pattern 对象行为型模式\n意图 提供一种方法顺序访问一个聚合对象中的各个元素，且不需要暴露该对象的内部表示\n结构 其中：\nIterator (迭代器) 定义访问和遍历元素的接口 ConcreteIterator (具体迭代器) 实现迭代器接口；对该聚合遍历时跟踪当前位置 Aggregate (聚合) 定义创建相应迭代器对象的接口 ConcreteAggregate (具体聚合) 实现创建相应迭代器的接口，该操作返回 ConcreteIterator 的一个适当的实例 适用性 Iterator 模式适用于：\n访问一个聚合对象的内容而无需暴露它的内部表示 支持对聚合对象的多种遍历 为遍历不同的聚合结构提供一个统一的接口 利用 Java 已实现迭代器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 import java.util.ArrayList; import java.util.Iterator; import java.util.List; public class IteratorPattern { public static void main(String[] args) { List\u0026lt;Book\u0026gt; bookList = new ArrayList\u0026lt;\u0026gt;(); String[] books = {\u0026#34;Linear Algebra\u0026#34;, \u0026#34;Algorithm\u0026#34;}; double[] prices = {25.8, 29.8}; for(int i = 0; i \u0026lt; 2; i++){ bookList.add(new Book(books[i], prices[i])); } // 访问元素 1 for(int i = 0; i \u0026lt; bookList.size(); i++){ Book book = bookList.get(i); System.out.println(\u0026#34;name: \u0026#34; + book.getName() + \u0026#34; price: \u0026#34; + book.getPrice()); } // 访问元素 2 System.out.println(\u0026#34;=====222=====\u0026#34;); for(Book book : bookList){ System.out.println(\u0026#34;name: \u0026#34; + book.getName() + \u0026#34; price: \u0026#34; + book.getPrice()); } // 访问元素 3 迭代器 System.out.println(\u0026#34;=====333=====\u0026#34;); Iterator iterator = bookList.iterator(); while (iterator.hasNext()){ Book book = (Book) iterator.next(); System.out.println(\u0026#34;name: \u0026#34; + book.getName() + \u0026#34; price: \u0026#34; + book.getPrice()); } } } class Book{ private String name; private double price; public Book(String name, double price){ this.name = name; this.price = price; } public double getPrice() { return price; } public String getName() { return name; } } 例子 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 import javax.sound.midi.Soundbank; import java.util.ArrayList; import java.util.List; public class IteratorPattern { public static void main(String[] args) { BookAggregate bookAggregate = new BookAggregate(); String[] books = {\u0026#34;Linear Algebra\u0026#34;, \u0026#34;Algorithm\u0026#34;}; double[] prices = {25.8, 29.8}; for(int i = 0; i \u0026lt; 2; i++){ bookAggregate.Add(new Book(books[i], prices[i])); } Iterator iterator = bookAggregate.CreateIterator(); while(iterator.hasNext()){ Book book = (Book)iterator.next(); System.out.println(\u0026#34;name: \u0026#34; + book.getName() + \u0026#34; price: \u0026#34; + book.getPrice()); } } } interface Iterator{ public boolean hasNext(); public Object next(); } class BookIterator implements Iterator{ private int index; private BookAggregate bookAggregate; public BookIterator(BookAggregate bookAggregate){ this.index = 0; this.bookAggregate = bookAggregate; } @Override public boolean hasNext(){ if (index \u0026lt; bookAggregate.getSize()) return true; return false; } @Override public Object next(){ Object obj = bookAggregate.get(index); index++; return obj; } } interface Aggregate{ public Iterator CreateIterator(); } class BookAggregate implements Aggregate{ private List\u0026lt;Book\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); public void Add(Book book){ list.add(book); } public Book get(int index){ return list.get(index); } public int getSize(){ return list.size(); } @Override public Iterator CreateIterator(){ return new BookIterator(this); } } class Book{ private String name; private double price; public Book(String name, double price){ this.name = name; this.price = price; } public double getPrice() { return price; } public String getName() { return name; } } ","date":"2023-10-12T09:09:24+08:00","permalink":"https://blog.yexca.net/archives/127/","title":"迭代器模式"},{"content":"Interpreter Pattern 类行为型模式\n意图 给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子\n结构 其中：\nAbstractExpression 声明一个程序的解释操作，这个接口为抽象语法树中所有的结点所共享 TerminalExpression 实现与文法中的终结符相关联的解释操作；一个句子中的每个终结符需要该类的一个实例 NonterminalExpression 对文法中的每一条规则都需要一个 NonterminalExpression 类；为每个符号都维护一个 AbstractExpression 类型的实例变量；为文法中的非终结符实现解释 (Interpret) 操作 Context 包含解释器之外的一些全局信息 Client 构建 (或被给定) 表示该文法定义的语言中一个特定的句子的抽象语法树，该抽象语法树由 NonterminalExpression 和 TerminalExpression 的实例装配而成；调用解释操作 适用性 Interpreter 模式适用于当有一个语言需要解释执行，并且可将该语言中的句子表示为一个抽象语法树时，以下情况效果最好：\n该文法简单 效率不是一个关键问题 例子 检查字符串：某区的某人员 (someone of ? region)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 import java.util.*; public class InterpreterPattern { public static void main(String[] args) { Context context = new Context(); context.check(\u0026#34;developer of A region\u0026#34;); } } class Context{ private String[] regions = {\u0026#34;A region\u0026#34;, \u0026#34;B region\u0026#34;, \u0026#34;C region\u0026#34;}; private String[] persons = {\u0026#34;developer\u0026#34;, \u0026#34;tester\u0026#34;}; private NonterminalExpression nte; public Context(){ TerminalExpression region = new TerminalExpression(regions); TerminalExpression person = new TerminalExpression(persons); nte = new NonterminalExpression(region, person); } public void check(String info){ boolean bool = nte.Interpret(info); if(bool){ System.out.println(\u0026#34;right\u0026#34;); }else { System.out.println(\u0026#34;wrong\u0026#34;); } } } interface Expression{ public boolean Interpret(String info); } class NonterminalExpression implements Expression{ TerminalExpression region; TerminalExpression person; public NonterminalExpression(TerminalExpression region, TerminalExpression person){ this.person = person; this.region = region; } @Override public boolean Interpret(String info){ String[] str = info.split(\u0026#34; of \u0026#34;); // \u0026#34;developer of A region\u0026#34; --\u0026gt; str = {\u0026#34;developer\u0026#34;, \u0026#34;A region\u0026#34;} return region.Interpret(str[1]) \u0026amp;\u0026amp; person.Interpret(str[0]); } } class TerminalExpression implements Expression{ private Set\u0026lt;String\u0026gt; set = new HashSet\u0026lt;\u0026gt;(); public TerminalExpression(String[] data){ for(String str : data){ set.add(str); } } @Override public boolean Interpret(String info){ return set.contains(info); } } ","date":"2023-10-09T17:31:58+08:00","permalink":"https://blog.yexca.net/archives/126/","title":"解释器模式"},{"content":"Command Pattern 对象行为型模式\n意图 将一个请求封装为一个对象，从而使得可以用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作\n结构 其中：\nCommand 声明执行操作的接口 ConcreteCommand 将一个接收者对象绑定于一个动作；调用接收者相应的操作，以实现 Execute Client 创建一个具体命令对象并设定它的接收者 Invoker 要求该命令执行这个请求 Receiver 知道如何实施与执行一个请求相关的操作。任何类都可能作为一个接收者 适用性 Command 模式适用于：\n抽象出待执行的动作以参数化某对象 在不同的时刻指定、排列和执行请求 支持取消操作 支持修改日志 用构建在原语操作上的高层操作构造一个系统 例子 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 public class CommandPattern { public static void main(String[] args) { // 接收者 对象 电视机 Tv tv = new Tv(); // 命令对象 Command oncommand = new OnCommand(tv); Command offcommand = new OffCommand(tv); // 请求者 Invoker invoker = new Invoker(); // 开机 invoker.setCommand(oncommand); invoker.Execute(); // 关机 invoker.setCommand(offcommand); invoker.Execute(); } } class Invoker{ // 请求者 private Command command; // 命令 public void setCommand(Command command){ // 设置请求者 的 请求的命令 this.command = command; } public void Execute(){ // 执行命令 command.Execute(); } } interface Command{ // 命令接口 public void Execute(); // 执行命令 } class OnCommand implements Command{ // 开机命令 private Tv tv; public OnCommand(Tv tv){ this.tv = tv; } @Override public void Execute(){ tv.OnAction(); } } class OffCommand implements Command{ // 关机命令 private Tv tv; public OffCommand(Tv tv){ this.tv = tv; } @Override public void Execute(){ tv.OffAction(); } } class Tv{ // 接收者 电视机 public void OnAction(){ System.out.println(\u0026#34;Tv On\u0026#34;); } public void OffAction(){ System.out.println(\u0026#34;Tv Off\u0026#34;); } } ","date":"2023-09-10T15:26:55+08:00","permalink":"https://blog.yexca.net/archives/125/","title":"命令模式"},{"content":"Chain of Responsibility Pattern 对象行为型模式\n意图 使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止\n结构 其中：\nHandler 定义一个处理请求的接口；(可选) 实现后继链 ConcreteHandler 处理它所负责的请求；可访问它的后继者；如果可处理该请求，就处理它，否则将请求转发给后继者 Client 向链上的具体处理者 (ConcreteHandler) 对象提交请求 适用性 Chain of Responsibility 模式适用于：\n有多个对象可以处理一个请求，哪个对象处理该请求运行时刻自动确定 想在不明确指定接收者的情况下向多个对象中的一个提交一个请求 可处理一个请求的对象集合应被动态指定 例子 学生请假，先辅导员，辅导员处理不了转院长，院长处理不了转校长\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 public class ChainOfResponsibilityPattern { public static void main(String[] args) { // 实例化对象 Handler counsellor = new Counsellor(); Handler president = new President(); Handler schoolmaster = new Schoolmaster(); // 设置对象下一级 counsellor.next = president; president.next = schoolmaster; schoolmaster.next = null; // 向辅导员请求7天假期 counsellor.HandlerRequest(7); } } abstract class Handler{ protected Handler next; public void setNext(Handler next){ this.next = next; } // 学生请假请求 public abstract void HandlerRequest(int request); } class Counsellor extends Handler{ // 辅导员 小于等于7天审批 @Override public void HandlerRequest(int request){ if (request \u0026lt;= 7) { System.out.println(\u0026#34;Counsellor Agree!\u0026#34;); } else { if(next != null){ next.HandlerRequest(request); } else { System.out.println(\u0026#34;Counsellor Refuse!\u0026#34;); } } } } class President extends Handler{ // 院长 小于等于15天审批 @Override public void HandlerRequest(int request){ if (request \u0026lt;= 15) { System.out.println(\u0026#34;President Agree!\u0026#34;); } else { if(next != null){ next.HandlerRequest(request); } else { System.out.println(\u0026#34;President Refuse!\u0026#34;); } } } } class Schoolmaster extends Handler{ // 校长 小于等于30天审批 @Override public void HandlerRequest(int request){ if (request \u0026lt;= 30) { System.out.println(\u0026#34;Schoolmaster Agree!\u0026#34;); } else { if(next != null){ next.HandlerRequest(request); } else { System.out.println(\u0026#34;Schoolmaster Refuse!\u0026#34;); } } } } ","date":"2023-09-09T07:02:55+08:00","permalink":"https://blog.yexca.net/archives/124/","title":"责任链模式"},{"content":"Proxy Pattern 对象结构型模式\n意图 为其他对象提供一种代理以控制对这个对象的访问\n结构 其中：\nProxy 保存一个引用使得代理可以访问实体；提供一个与 Subject 的接口相同的接口，使代理可以用来代替实体；控制对实体的存取，并可能负责创建和删除它 Subject 定义 RealSubject 和 Proxy 的共用接口，这样就在任何使用 RealSubject 的地方都可以使用 Proxy RealSubject 定义 Proxy 所代表的实体 适用性 Proxy 模式适用于在需要比较通用和复杂的对象指针代替简单的指针的时候，常见的情况有：\n远程代理 (Remote Proxy) 为一个对象在不同地址空间提供局部代表 虚代理 (Virtual Proxy) 根据需要对原始对象的访问，用于对象应该有不同的访问权限的时候 保护代理 (Protection Proxy) 控制对原始对象的访问，用于对象应该有不同的访问权限的时候 只能引用 (Smart Reference) 取代了简单的指针，它在访问对象时执行了一些附加操作。典型用途包括：对指向实际对象的引用计数，这样当该对象没有引用时，可以被自动释放；当第一次引用一个持久对象时，将它装入内存；在访问一个实际对象前，检查是否已经锁定了它，以确保其他对象不能改变它 例子 中介代理买东西\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 public class ProxyPattern { public static void main(String[] args) { RealSubject realSubject = new RealSubject(); Proxy proxy = new Proxy(realSubject); proxy.buy(); } } interface Subject{ public void buy(); } class Proxy implements Subject{ protected RealSubject realSubject; public Proxy(RealSubject realSubject){ this.realSubject = realSubject; } @Override public void buy() { System.out.println(\u0026#34;prepare\u0026#34;); realSubject.buy(); System.out.println(\u0026#34;complete\u0026#34;); } } class RealSubject implements Subject{ @Override public void buy() { System.out.println(\u0026#34;Money\u0026#34;); } } ","date":"2023-09-08T12:15:26+08:00","permalink":"https://blog.yexca.net/archives/123/","title":"代理模式"},{"content":"Flyweight Pattern 对象结构型模式\n意图 运用共享技术有效地支持大量细粒度的对象\n结构 其中：\nFlyweight 描述一个接口，通过这个接口 Flyweight 可以接受并作用于外部状态\nConcreteFlyweight 实现 Flyweight 接口，并为内部状态 (如果有) 增加存储空间。ConcreteFlyweight 对象必项是可共享的。它所存储的状态必须是内部的，即它必须独立于 ConcreteFlyweight 对象的场景\n并非所有的 Flyweight 子类都需要被共享。Flyweight 接口使共享成为可能，但它并不强制共亨。在 Flyweight 对象结构的某些层次，UnsharedConcreteFlyweight 对象通常将 ConcreteFlyweight 对象作为子结点\nFlyweightFactory 创建并管理 Flyweight 对象；确保合理地共享 Flyweight，当用户请求一个 Flyweight 时，FlyweightFactory 对象提供一个已创建的实例或者不存在时创建一个实例\nClient 维持一个对 Flyweight 的引用；计算或存储一个或多个 Flyweight 的外部状态\n适用性 Flyweight 模式适用于：\n一个应用程序使用了大量的对象 完全由于使用大量的对象，造成很大的存储开销 对象的大多数状态都可变为外部状态 如果删除对象的外部状态，那么可以用相对较少的共享对象取代很多组对象 应用程序不依赖于对象标识。由于 Flyweight 对象可以被共享，所以对于概念上明显有别的对象，标识测试将返回真值 例子 1 现要开发一个网络围棋程序，允许多个玩家联机下棋。由于只有一台服务器，为节省内存空间，采用享元模式实现该程序，类图如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 import java.util.ArrayList; enum PieceColor {BLACK, WHITE} // 棋子颜色 class PiecePods{ // 棋子位置 private int x; private int y; public PiecePods(int a, int b){ x = a; y = b; } public int getX(){ return x; } public int getY() { return y; } } abstract class Piece{ // 棋子定义 protected PieceColor m_color; // 颜色 protected PiecePods m_pos; // 位置 public Piece(PieceColor color, PiecePods pos){ this.m_color = color; this.m_pos = pos; } public abstract void draw(); } class BlackPiece extends Piece{ public BlackPiece(PieceColor color, PiecePods pos){ super(color, pos); } @Override public void draw(){ System.out.println(\u0026#34;Draw a black piece\u0026#34;); } } class WhitePiece extends Piece{ public WhitePiece(PieceColor color, PiecePods pos){ super(color, pos); } @Override public void draw(){ System.out.println(\u0026#34;Draw a white piece\u0026#34;); } } class PieceBoard{ // 棋盘上已有的棋子 private static final ArrayList\u0026lt;Piece\u0026gt; m_arrayPiece = new ArrayList\u0026lt;\u0026gt;(); private String m_blackName; // 黑方名称 private String m_whiteName; // 白方名称 public PieceBoard(String black, String white){ m_blackName = black; m_whiteName = white; } // 一步棋，在棋盘上放一颗棋子 public void setPiece(PieceColor color, PiecePods pos){ Piece piece = null; if(color == PieceColor.BLACK){ // 放黑子 piece = new BlackPiece(color, pos); System.out.println(m_blackName + pos.getX() + pos.getY()); piece.draw(); }else{ // 放白子 piece = new WhitePiece(color, pos); System.out.println(m_whiteName + pos.getX() + pos.getY()); piece.draw(); } m_arrayPiece.add(piece); } } 例子 2 五子棋\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 public class FlyWeightPattern { public static void main(String[] args) { PieceFactory factory = new PieceFactory(); Piece wp1 = factory.getPiece(0); wp1.draw(2023, 0527); } } class PieceFactory{ private Piece[] pieces = {new WhitePiece(), new BlackPiece()}; public Piece getPiece(int key){ if(key == 0) return pieces[0]; else return pieces[1]; } } abstract class Piece{ protected String color; public abstract void draw(int x, int y); } class WhitePiece extends Piece{ public WhitePiece(){ this.color = \u0026#34;white\u0026#34;; } @Override public void draw(int x, int y){ System.out.println(\u0026#34;draw a \u0026#34; + this.color + \u0026#34; piece x: \u0026#34; + x + \u0026#34; y: \u0026#34; + y); } } class BlackPiece extends Piece{ public BlackPiece(){ this.color = \u0026#34;Black\u0026#34;; } @Override public void draw(int x, int y){ System.out.println(\u0026#34;draw a \u0026#34; + this.color + \u0026#34; piece x: \u0026#34; + x + \u0026#34; y: \u0026#34; + y); } } 例子 3 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 import java.util.HashMap; import java.util.Map; import java.util.Random; public class FlyWeightPattern { public static void main(String[] args) { ShapeFactory sf = new ShapeFactory(); Random r = new Random(); String[] colors = {\u0026#34;red\u0026#34;, \u0026#34;blue\u0026#34;, \u0026#34;green\u0026#34;, \u0026#34;white\u0026#34;, \u0026#34;black\u0026#34;}; for (int i = 0; i \u0026lt; 10; i++) { int x = r.nextInt(colors.length); Shape s = sf.getShape(colors[x]); s.draw(r.nextInt(2023), r.nextInt(527)); } } } class ShapeFactory{ private Map\u0026lt;String, Shape\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); public Shape getShape(String key){ if (!map.containsKey(key)) { map.put(key, new Circle(key)); System.out.println(\u0026#34;create new circle, color: \u0026#34; + key); } return map.get(key); } } abstract class Shape{ protected String color; public abstract void draw(int x, int y); } class Circle extends Shape{ public Circle(String color){ this.color = color; } @Override public void draw(int x, int y) { System.out.println(\u0026#34;draw a \u0026#34; + this.color + \u0026#34; circle x: \u0026#34; + x + \u0026#34; y: \u0026#34; + y); } } ","date":"2023-09-07T13:54:55+08:00","permalink":"https://blog.yexca.net/archives/122/","title":"享元模式"},{"content":"Facade Pattern 对象结构型模式\n意图 为子系统中的一组接口提供一个一致的界面，Facade 模式定义了一个高层接口，这个接口使得这一子系统更加容易使用\n结构 其中：\nFacade 知道哪些子系统类负责处理请求；将客户的请求代理给适当的子系统对象 Subsystem classes 实现子系统的功能；处理有 Facade 对象指派的任务；没有 Facade 的任何相关信息，即没有指向 Facade 的指针 适用性 Facade 模式适用于：\n要为一个复杂子系统提供一个简单接口时，子系统往往因为不断演化而变得越来越复杂。大多数模式使用时都会产生更多更小的类，这使得子系统更具有可重用性，也更容易对子系统进行定制，但也给那些不需要定制子系统的用户带来一些使用上的困难。Facade 可以提供一个简单的默认视图，这一视图对大多数用户来说已经足够，而那些需要更多的可定制性的用户可以越过 Facade 层 客户程序与抽象类的实现部分之间存在着很大的依赖性。引入 Facade 将这个子系统与客户以及其他的子系统分离，可以提高子系统的独立性和可移植性 当需要构建一个层次结构的子系统时，使用 Facade 模式定义子系统中每层的入口点。如果子系统之间是相互依赖的，则可以让它们仅通过 Facade 进行通信，从而简化了它们之间的依赖关系 例子 1 以医院为例，就医时患者需要与医院不同的职能部门交互，完成挂号、门诊、取药等操作。为简化就医流程，可以设置一个接待员的职位，代患者完成上述就医步骤，患者只需要与接待员交互即可\nJava 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 import java.util.*; interface Patient { public String getName(); } interface Disposer { public void dispose(Patient patient); } class Registry implements Disposer { // 挂号 public void dispose(Patient patient) { System.out.println(\u0026#34;I am registering...\u0026#34; + patient.getName()); } } class Doctor implements Disposer { // 医生门诊 public void dispose(Patient patient) { System.out.println(\u0026#34;I am diagnosing...\u0026#34; + patient.getName()); } } class Pharmacy implements Disposer { // 取药 public void dispose(Patient patient) { System.out.println(\u0026#34;I am medicine... \u0026#34; + patient.getName()); } } class Facade { private Patient patient; public Facade(Patient patient) { this.patient = patient; } void dispose() { Registry registry = new Registry(); Doctor doctor = new Doctor(); Pharmacy pharmacy = new Pharmacy(); registry.dispose(patient); doctor.dispose(patient); pharmacy.dispose(patient); } } class ConcretePatient implements Patient { private String name; public ConcretePatient(String name) { this.name = name; } public String getName() { return name; } } public class FacadeTest { public static void main(String[] args) { Patient patient = new ConcretePatient(\u0026#34;zst\u0026#34;); Facade f = new Facade(patient); f.dispose(); } } C++ 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; class Patient { public: virtual string getName() = 0; }; class Disposer { public: virtual void dispose(Patient *patient) = 0; }; class Registry : public Disposer { // 挂号 public: void dispose(Patient *patient) { cout \u0026lt;\u0026lt; \u0026#34;I am registering....\u0026#34; \u0026lt;\u0026lt; patient-\u0026gt;getName() \u0026lt;\u0026lt; endl; } }; class Doctor : public Disposer { // 医生门诊 public: void dispose(Patient *patient) { cout \u0026lt;\u0026lt; \u0026#34;I am diagnosing....\u0026#34; \u0026lt;\u0026lt; patient-\u0026gt;getName() \u0026lt;\u0026lt; endl; } }; class Pharmacy : public Disposer { // 取药 public: void dispose(Patient *patient) { cout \u0026lt;\u0026lt; \u0026#34;I am giving medicine....\u0026#34; \u0026lt;\u0026lt; patient-\u0026gt;getName() \u0026lt;\u0026lt; endl; } }; class Facade { private: Patient *patient; public: Facade(Patient *patient) { this-\u0026gt;patient = patient; } void dispose() { Registry *registry = new Registry(); Doctor *doctor = new Doctor(); Pharmacy *pharmacy = new Pharmacy(); registry-\u0026gt;dispose(patient); doctor-\u0026gt;dispose(patient); pharmacy-\u0026gt;dispose(patient); } }; class ConcretePatient : public Patient { private: string name; public: ConcretePatient(string name) { this-\u0026gt;name = name; } string getName() { return name; } }; int main() { Patient *patient = new ConcretePatient(\u0026#34;zst\u0026#34;); Facade *f = new Facade(patient); f-\u0026gt;dispose(); return 0; } 例子 2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 public class FacadePattern { public static void main(String[] args) { Facade f = new Facade(); f.methodA(); } } class Facade{ SubSystemOne s1; SubSystemTwo s2; SubSystemThree s3; public Facade(){ s1 = new SubSystemOne(); s2 = new SubSystemTwo(); s3 = new SubSystemThree(); } public void methodA(){ s1.Operation(); } public void methodB(){ s2.Operation(); } public void methodC(){ s3.Operation(); } } class SubSystemOne{ public void Operation(){ System.out.println(\u0026#34;SubSystemOne\u0026#34;); } } class SubSystemTwo{ public void Operation(){ System.out.println(\u0026#34;SubSystemTwo\u0026#34;); } } class SubSystemThree{ public void Operation(){ System.out.println(\u0026#34;SubSystemThree\u0026#34;); } } ","date":"2023-09-06T03:02:02+08:00","permalink":"https://blog.yexca.net/archives/121/","title":"外观模式"},{"content":"Decorator Pattern 对象结构型模式\n意图 动态地给一个对象添加一些额外的职责。就增加功能而言，Decorator 模式比生成子类更加灵活\n结构 其中：\nComponent 定义一个对象接口，可以给这些对象动态地添加职责 ConcreteComponent 定义一个对象，可以给这个对象添加一些职责 Decorator 维持一个指向 Component 对象的指针，并定义一个与 Component 接口一致的接口 ConcreteDecorator 向组件添加职责 适用性 Decorator 模式适用于：\n在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责 处理那些可以撤销的职责 当不能采用生成子类的方式进行扩充时，一种情况是，可能有大量独立的拓展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长。另一种情况可能是，由于类定义被隐藏，或类定义不能用于生成子类 例子 1 某咖啡店当卖咖啡时，可以根据顾客的要求在其中加入各种配料，咖啡店会根据所加入的配料来计算费用。咖啡店所供应的咖啡及配料的种类和价格如下表所示\n现采用装饰器模式来实现计算费用的功能，得到如下类图\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 import java.util.*; abstract class Beverage { // 饮料 String description = \u0026#34;Unknown Beverage\u0026#34;; public String getDescription() { return description; } public abstract int cost(); } abstract class CondimentDecorator extends Beverage { // 配料 Beverage beverage; } class Espresso extends Beverage { // 蒸馏咖啡 private final int ESPRESSO_PRICE = 25; public Espresso() { description = \u0026#34;Espresso\u0026#34;; } public int cost() { return ESPRESSO_PRICE; } } class DarkRoast extends Beverage { // 深度烘焙咖啡 private final int DARKROAST_PRICE = 20; public DarkRoast() { description = \u0026#34;DarkRoast\u0026#34;; } public int cost() { rcturn DARKROAST PRICE; } } class Mocha extends CondimentDecorator { // 摩卡 private final int MOCHA_PRICE = 10; public Mocha (Beverage beverage) { this.beverage = beverage; } public String getDescription() { return beverage.getDescription() + \u0026#34;, Mocha\u0026#34;; } public int cost() { return MOCHA_PRICE + beverage.cost(); } } class Whip extends CondimentDecorator { // 奶泡 private final int WHIP_PRICE = 8; public Whip (Beverage beverage) { this.beverage = beverage; } public String getDescription() { return beverage.getDescription() + \u0026#34;, Whip\u0026#34;; } public int cost() { return WHIP_PRICE + beverage.cost(); } } public class Coffee { public static void main(String args[]) { Beverage beverage = new DarkRoast(); beverage = new Mocha(beverage); beverage = new Whip(beverage); System.out.println(beverage.getDescription() +\u0026#34; ￥\u0026#34;+ beverage.cost()); } } 例子 2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 public class DecoratorPattern { public static void main(String[] args) { Person p = new Student(\u0026#34;Mike\u0026#34;); p.Operation(); System.out.println(\u0026#34;\\n--------------------\u0026#34;); p = new DecoratorA(p); p.Operation(); System.out.println(\u0026#34;\\n--------------------\u0026#34;); p = new DecoratorB(p); p.Operation(); // No.2 Person p2 = new DecoratorB(new Student(\u0026#34;Jane\u0026#34;)); } } abstract class Person{ protected String name; public abstract void Operation(); } class Student extends Person{ public Student(String name){ this.name = name; } @Override public void Operation(){ System.out.print(name + \u0026#34; Study\u0026#34;); } } abstract class Decorator extends Person{ protected Person person; } class DecoratorA extends Decorator{ public DecoratorA(Person person){ this.person = person; } @Override public void Operation() { person.Operation(); System.out.print(\u0026#34; Play\u0026#34;); } } class DecoratorB extends Decorator{ public DecoratorB(Person person){ this.person = person; } @Override public void Operation() { person.Operation(); System.out.print(\u0026#34; Exam\u0026#34;); } } ","date":"2023-09-05T21:45:45+08:00","permalink":"https://blog.yexca.net/archives/120/","title":"装饰器模式"},{"content":"Composite Pattern 对象结构型模式\n意图 将对象组合成树型结构以表示 \u0026ldquo;部分 - 整体\u0026rdquo; 的层次结构。Composite 使得用户对单个对象和组合对象的使用具有一致性\n结构 其中：\nComponent 为组合中的对象声明接口；在适当情况下实现所有类共有接口的默认行为；声明一个接口用于访问和管理 Component 的子组件；(可选) 在递归结构中定义一个接口，用于访问一个父组件，并在合适的情况下实现它 Leaf 在组合中表示叶结点对象，叶结点没有子结点；在组合中定义图元对象的行为 Composite 定义所有子组件的那些组件的行为；存储子组件；在 Component 接口中实现与子组件有关的操作 Client 通过 Component 接口操纵组合组件的对象 适用性 Composite 模式适用于：\n想表示对象的部分 - 整体层次结构 希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象 例子 1 某公司的组织结构图如下图所示\n现采用组合（Composition）设计模式来构造该公司的组织结构，得到如下图所示的类图\n其中Company为抽象类，定义了在组织结构图上添加（Add）和删除（Delete）分公司/办事处或者部门的方法接口。类ConcreteCompany表示具体的分公司或者办事处，分公司或办事处下可以设置不同的部门。类HRDepartment和FinanceDepartment分别表示人力资源部和财务部\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 import java.util.*; abstract class Company { protected String name; public Company(String name) { this.name = name; } public abstract void Add(Company c); // 增加子公司、办尊处或部门 public abstract void Delete(Company c); // 删除子公司、办事处或部门 } class ConcreteCompany extends Company { private List\u0026lt;Company\u0026gt; children = new ArrayList\u0026lt;Company\u0026gt;(); // 存储子公司、办事处或部门 public ConcreteCompany(String name) { super(name); } public void Add(Company c) {children.add(c); } public void Delete(Company c) {children.remove(c); } } class HRDepartment extends Company { public HRDepartment(String name) { super(name); } // 其他代码省略 } class FinanceDepartment extends Company { public FinanceDepartment(String name) { super(name); } // 其他代码省略 } public class Test { public static void main(String[] args) { ConcreteCompany root = new ConcreteCompany(\u0026#34;北京总公司\u0026#34;); root.Add(new HRDepartment(\u0026#34;总公司人力资源部\u0026#34;)); root.Add(new FinanceDepartment(\u0026#34;总公司财务部\u0026#34;)); ConcreteCompany comp = new ConcreteCompany(\u0026#34;上海分公司\u0026#34;); comp.Add(new HRDepartment(\u0026#34;上海分公司人力资源部\u0026#34;)); comp.Add(new FinanceDepartment(\u0026#34;上海分公司财务部\u0026#34;)); root.Add(comp); ConcreteCompany comp1 = new ConcreteCompany(\u0026#34;南京办事处\u0026#34;); comp1.Add(new HRDepartment(\u0026#34;南京办事处人力资源部\u0026#34;)); comp1.Add(new FinanceDepartment(\u0026#34;南京办事处财务部\u0026#34;)); comp.Add(comp1); // 其他代码省略 } } 例子 2 层叠菜单是窗口风格的软件系统中经常采用的一种系统功能组织方式。层叠菜单中包含的可能是一个菜单项（直接对应某个功能），也可能是一个子菜单，现在采用组合（composite）设计模式实现层叠菜单，得到如下图所示的类图\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 import java.util.*; abstract class MenuComponent { // 构成层叠菜单的元素 protected String name; // 菜单项或子菜单名称 public void printName() { System.out.println(name); } public abstract boolean addMenuElement(MenuComponent element) ; public abstract boolean removeMenuElement(MenuComponent element); public abstract List\u0026lt;MenuComponent\u0026gt; getElement(); } class MenuItem extends MenuComponent { public MenuItem(String name) { this.name=name; } public boolean addMenuElement(MenuComponent element) { return false; } public boolean removeMenuElement(MenuComponent element) { return false; } public List\u0026lt;MenuComponent\u0026gt; getElement(){ return null; } } class Menu extends MemuComponent { private List\u0026lt;MenuComponent\u0026gt; elementsList; public Menu(String name) { this.name = name; this.elementList = new ArrayList\u0026lt;MenuComponent\u0026gt;; } public boolean addMenuElement(MenuComponent element) { return elementList.add(element); } public boolean removeMenuElement(MenuComponent element) { return elementList.remove(element); } public List\u0026lt;MenuComponent\u0026gt; getElement() { return elementList; } } class CompositeTest { public static void main(String[] args) { MenuComponent mainMenu = new Menu(\u0026#34;Insert\u0026#34;); MenuComponent subMenu = new Menu(\u0026#34;Chart\u0026#34;); MenuComponent element = new MenuItem(\u0026#34;On This Sheet\u0026#34;); mainMenu.addMenuElement(subMenu); subMenu.addMenuElement(element); printMenus(mainMenu); } private static void printMenus(MenuComponent ifile) { ifile.printName(); List\u0026lt;MenuComponent\u0026gt; children = ifile.getElement(); if (children == null) return; for(MenuComponent element; children) { printMenus(element); } } } 例子 3 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 import java.util.*; public class CompositePattern { public static void main(String[] args) { AbstractFile root = new Folder(\u0026#34;root\u0026#34;); AbstractFile bin = new Folder(\u0026#34;bin\u0026#34;); AbstractFile tmp = new Folder(\u0026#34;tmp\u0026#34;); AbstractFile file = new File(\u0026#34;file\u0026#34;); root.Add(bin); bin.Add(tmp); root.Add(file); // root.Remove(tmp); print(root); } static void print(AbstractFile file){ List\u0026lt;AbstractFile\u0026gt; lf = file.GetChildren(); file.Operation(); // 更简洁的方法 // if(lf == null) return; // for(AbstractFile i : lf) print(i); if (lf != null) { for (AbstractFile i : lf) { if (i != null) { print(i); } else return; } } else return; } } abstract class AbstractFile{ protected String name; public void Operation(){ System.out.println(name); } public abstract boolean Add(AbstractFile af); public abstract boolean Remove(AbstractFile af); public abstract List\u0026lt;AbstractFile\u0026gt; GetChildren(); } class Folder extends AbstractFile{ private List\u0026lt;AbstractFile\u0026gt; childrenList = new ArrayList\u0026lt;\u0026gt;(); public Folder(String name){ this.name = name; } @Override public boolean Add(AbstractFile af){ return childrenList.add(af); } @Override public boolean Remove(AbstractFile af){ return childrenList.remove(af); } @Override public List\u0026lt;AbstractFile\u0026gt; GetChildren(){ return this.childrenList; } } class File extends AbstractFile{ public File(String name){ this.name = name; } @Override public boolean Add(AbstractFile af){ System.out.println(\u0026#34;Forbidden\u0026#34;); return false; } @Override public boolean Remove(AbstractFile af){ System.out.println(\u0026#34;Forbidden\u0026#34;); return false; } @Override public List\u0026lt;AbstractFile\u0026gt; GetChildren(){ return null; } } ","date":"2023-09-03T15:44:45+08:00","permalink":"https://blog.yexca.net/archives/119/","title":"组合模式"},{"content":"Bridge Pattern 对象结构型模式\n意图 将抽象部分与其实现部分分离，使它们都可以独立地变化\n结构 其中：\nAbstraction 定义抽象类的接口，维护一个指向 Implementor 类型对象的指针 RefinedAbstraction 扩充由 Abstraction 定义的接口 Implementor 定义实现类的接口，该接口不一定要与 Abstraction 的接口完全一致；事实上这两个接口可以完全不同 一般来说，Implementor 接口仅提供基本操作，而 Abstraction 定义了基于这些基本操作的较高层次的操作 ConcreteImplementor 实现 Implementor 接口并定义它的具体实现 适用性 Bridge 模式适用于：\n不希望在抽象和它的实现部分之间有一个固定的绑定关系。例如，这种情况可能是因为，在程序运行时刻实现部分应可以被选择或者切换 类的抽象以及它的实现都应该可以通过生成子类的方法加以扩充。这是 Bridge 模式使得开发者可以对不同的抽象接口和实现部分进行组合，并分别对它们进行扩充 对一个抽象的实现部分的修改应对客户不产生影响，即客户代码不必重新编译 (C++) 想对客户完全隐藏抽象的实现部分 有许多类要生成的类层次结构 想在多个对象间共享实现 (可能使用引用计数) ，但同时要求客户并不知道这一点 例子 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 public class main { public static void main(String[] args) { Product ProductA1 = new ProductA(); Product ProductA2 = new ProductA(); Color red = new Red(); ProductA1.setName(\u0026#34;P-A1\u0026#34;); ProductA1.setColor(red); ProductA1.Operation; Color blue = new Blue(); ProductA1.setName(\u0026#34;P-A2\u0026#34;); ProductA1.setColor(blue); ProductA1.Operation; } } abstract class Product{ private String name; protected Color color; public void setName(String name){ this.name = name; } public String getName(){ return this.name; } public setColor(Color color){ this.color = color; } public abstract void Operation(); } class ProductA extends Product{ @Override public void Operation(){ color.OperationImp(this.getName()); } } class Color{ public void OperationImp(String name); } class Red extends Color{ @Override public void OperationImp(String name){ System.out.println(name + \u0026#34;: red\u0026#34;) } } class Blue extends Color{ @Override public void OperationImp(String name){ System.out.println(name + \u0026#34;: blue\u0026#34;) } } ","date":"2023-09-02T17:34:34+08:00","permalink":"https://blog.yexca.net/archives/118/","title":"桥接模式"},{"content":"Adapter Pattern 类结构型模式/对象结构型模式\n意图 将一个类的接口转换成客户希望的另外一个接口。Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作\n结构 类适配器使用多重继承对一个接口与另一个接口进行匹配 对象适配器依赖于对象组合 其中：\nTarget 定义 Client 使用的与特定领域相关的接口 Client 与符合 Target 接口的对象协同 Adaptee 定义一个已经存在的接口，这个接口需要适配 Adapter 对 Adaptee 的接口与 Target 接口进行适配 适用性 Adapter 模式适用于：\n想使用一个已经存在的类，而它的接口不符合要求 想创建一个可以服用的类，该类可以与其他不相关的类或不可预见的类 (即那些接口可能不一定兼容的类) 协同工作 (仅适用于对象 Adapter) 想使用一个已经存在的子类，但是不可能对每一个都进行子类化以匹配它们的接口。对象适配器可以适配它的父类接口 例子 1 某软件系统中，已设计并实现了用于显示地址信息的类 Address ，现要求提供基于 Dutch 语言的地址信息显示接口。为了实现该要求并考虑到以后可能还会出现新的语言接口，决定采用适配器模式实现该要求，类图如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 public class Adapter { public static void main(String[] args) { Address address = new Address(); DutchAddress dutchAddress = new DutchAddressAdapter(address); System.out.println(\u0026#34;The DutchAddress\u0026#34;); test(dutchAddress); } static void test(DutchAddress dutchAddress){ dutchAddress.plaats(); dutchAddress.postcode(); dutchAddress.straat(); } } class Address{ public void street(){/* code omission */} public void zip(){/* code omission */} public void city(){/* code omission */} } class DutchAddress{ public void straat(){/* code omission */} public void postcode(){/* code omission */} public void plaats(){/* code omission */} } class DutchAddressAdapter extends DutchAddress{ private Address address; public DutchAddressAdapter(Address address){ this.address=address; } @Override public void straat() { address.street(); } @Override public void postcode() { address.zip(); } @Override public void plaats() { address.city(); } } 例子 2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // 因 Java 不支持多重继承，以下为对象适配器 public class main{ public static void main(String[] args) { Target target = new Adapter(); target.Request(); } } class Target{ public void Request(){ System.out.println(\u0026#34;hello\u0026#34;); } } class Adapter extends Target{ private Adaptee a = new Adaptee(); @Override public void Request(){ a.SpecificRequest(); } } class Adaptee{ public void SpecificRequest(){ System.out.println(\u0026#34;hi\u0026#34;); } } ","date":"2023-09-01T15:03:03+08:00","permalink":"https://blog.yexca.net/archives/117/","title":"适配器模式"},{"content":"之前拥有服务器的时候虽然有过此想法，但毕竟只要服务器再开个站点就解决了并没有深入研究，如今服务器到期将 Blog 搬到 Github 上想要继续这样无疑是不可能的，于是便寻求解决方法\n失败的历程 虽然失败了，但还是要记录下来，肯定是我不会用\n之前只是试着玩玩，仅从 DNS 的 CNAME 试了发现不行便放弃了，这次使用互联网搜索\u0026quot;域名定向到路径 url\u0026quot;，从第一条搜索结果 https://cloud.tencent.com/developer/ask/sof/89340 得知工具网站： http://redirect.center/ 例子 从 https://acg.yexca.net 重定向到 https://blog.yexca.net/acg 不可访问\n按网站描述，CNAME 内容应该为 blog.yexca.net.opts-slash.acg.opts-https.redirect.center. 可实际效果并未达到，并且报错\n尝试了挺多都是报错，不试了，另寻他法\n注：网站最后一个介绍有自动生成\n新工具 使用互联网搜索 \u0026ldquo;redirect center\u0026rdquo; 第三条搜索结果 https://redirect.name/ 这个工具比那个好用很多，而且有效\n新例子 从 https://twinkle.yexca.net 重定向到 https://yexca.github.io/MusicPlayer-Twinkle/ 可以访问\n两条记录\n类型 名称 内容 CNAME twinkle alias.redirect.name TXT _redirect.acg Redirects to https://yexca.github.io/MusicPlayer-Twinkle/ 代码形式\n1 2 acg IN CNAME alias.redirect.name _redirect.acg IN TXT \u0026#34;https://blog.yexca.net/acg\u0026#34; ","date":"2023-08-28T15:31:01+08:00","permalink":"https://blog.yexca.net/archives/116/","title":"使用 CNAME 将域名重定向到带路径的 URL"},{"content":"Singleton Pattern 对象创建型模式\n意图 保证一个类仅有一个实例，并提供一个访问它的全局访问点\n结构 其中：\nSingleton 指定一个 Instance 操作，允许客户访问它的唯一实例 Instance 是一个类操作；可能负责创建它自己的唯一实例 适用性 Singleton 模式适用于：\n当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时 当这个唯一实例应该是通过子类化可扩展的，并且客户无须更改代码就能使用一个扩展的实例时 例子 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public class main{ // s1 和 s2 是同一个实例 (地址相同) Singleton s1 = Singleton.getInstance(); Singleton s2 = Singleton.getInstance(); } class Singleton{ private int num = 2023; public void setNum(int num){ this.num = num; } public int getNum(){ return this.num; } private Singleton(){} private static Singleton instance = new Singleton(); public static Singleton getInstance(){ return instance; } } ","date":"2023-07-05T13:58:25+08:00","permalink":"https://blog.yexca.net/archives/115/","title":"单例模式"},{"content":"最近游玩 ミリシタ 时连接不上，遂寻找解决方法 (顺便试试 Spotify 的嵌入效果，这个主题不支持直接解析 H5，懒得改了)\n域名 1 theaterdays.appspot.com 这里原先嵌入了 雨宿り 的 Spotify 的歌\n最近雨宿りの曲が大好きので、よく聞いていた。Last.fm で過去30日間雨宿りの「猫かぶり」は人気トラック一番になった。で、トップアーティストじゃない？トップアーティスト、もちろん湊あくあ！　草、ミリシタの文章で何を書いたか、どっちもミリシタと関係ないもん！\nclash 通过设置组更好选择\n首先设置 JP 组\n1 2 3 4 5 6 proxy-groups: - name: JP type: select proxies: - your jp proxy name - your jp proxy name 然后添加规则\n1 2 rules: - DOMAIN-SUFFIX,theaterdays.appspot.com,JP ","date":"2023-06-09T23:32:09+08:00","permalink":"https://blog.yexca.net/archives/114/","title":"アイドルマスター ミリオンライブ！的 IP 规则"},{"content":"Prototype Pattern 对象创建型模式\n意图 用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象\n结构 其中：\nPrototype 声明一个复制自身的接口 ConcretePrototype 实现一个复制自身的操作 Client 让一个原型复制自身从而创建一个新的对象 适用性 Prototype 模式适用于：\n当一个系统应该独立于它的产品创建、构成和表示时 当要实例化的类是在运行时刻指定时，例如，通过动态装载 为了避免创建一个与产品类层次平行的工厂类层次时 当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们，可能比每次用合适的状态手工实例化该类更方便一些 例子 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 public class main{ Product p1 = new Product(2023, 3.03); System.out.println(p1.getId() + \u0026#34; \u0026#34; + p1.getPrice()); // Product p2 = new Product(2023, 3.03); Product p2 = (Product) p1.Clone(); System.out.println(p2.getId() + \u0026#34; \u0026#34; + p2.getPrice()); } interface Prototype{ public Object Clone(); } class Product implements Prototype{ private int id; private double price; public Product(){} public Product(int id, double price){ this.id = id; this.price = price; } public int getId(){ return this.id; } public double getPrice(){ return this.price; } public void setId(int id){ this.id = id; } public void setPrice(double price){ this.price = price; } @Override public Object Clone(){ Product object = new Product(); object.id = this.id; object.price = this.price; return object; } } 例子 2 (使用官方接口) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 public class main{ Product p1 = new Product(2023, 3.03); System.out.println(p1.getId() + \u0026#34; \u0026#34; + p1.getPrice()); // Product p2 = new Product(2023, 3.03); Product p2 = (Product) p1.clone(); System.out.println(p2.getId() + \u0026#34; \u0026#34; + p2.getPrice()); } // 去除 // interface Prototype{ // public Object Clone(); // } // 实现接口 class Product implements Cloneable{ private int id; private double price; public Product(){} public Product(int id, double price){ this.id = id; this.price = price; } public int getId(){ return this.id; } public double getPrice(){ return this.price; } public void setId(int id){ this.id = id; } public void setPrice(double price){ this.price = price; } // 重写方法 @Override public Object clone(){ return super.clone(); } } ","date":"2023-06-02T19:31:44+08:00","permalink":"https://blog.yexca.net/archives/113/","title":"原型模式"},{"content":"Builder Pattern 对象创建型模式\n意图 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示\n结构 其中：\nBuilder 为创建一个 Product 对象的各个部件指定抽象接口 ConcreteBuilder 实现 Builder 的接口以构造和装配该产品的各个部件，定义并明确它所创建的表示，提供一个检索产品的接口 Director 构造一个使用 Builder 接口的对象 Product 表示被构建的复杂对象。ConcreteBuilder 创建该产品的内部表示并定义它的装配过程。包含定义组成组件的类，包括将这些组件装配成最终产品的接口 适用性 Builder 模式适用于：\n当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式 当构建过程必须允许被构造的对象有不同的表示时 例子 1 某快餐厅主要制作并出售儿童套餐，一般包括主餐（各类比萨）、饮料和玩具，其餐品种类可能不同，但其制作过程相同。前台服务员（Waiter）调度厨师制作套餐。现采用生成器模式实现制作过程。类图如下\nJava 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class Pizza { private String parts; public void setParts(String parts) { this.parts = parts; } public String toString() { return this.parts; } } abstract class PizzaBuilder { protected Pizza pizza; public Pizza getPizza() { return pizza; } public void createNewPizza() { pizza = new Pizza(); } public abstract void buildParts(); } class HawaiianPizzaBuilder extends PizzaBuilder { public void buildParts(){ pizza.setParts(\u0026#34;cross + mild + ham\u0026amp;pineapp1e\u0026#34;); } } class SpicyPizzaBuilder extends PizzaBuilder { public void buildParts() { pizza.setParts(\u0026#34;panbaked + hot + pepperoni\u0026amp;salami\u0026#34;); } } class Waiter { private PizzaBuilder pizzaBuilder; public void setPizzaBuilder(PizzaBuilder pizzaBuilder) {/*设置构建器*/ this.pizzaBuilder = pizzaBuilder; } public Pizza getPizza() { return pizzaBuilder.getPizza(); } public void construct() { /* 构建 */ pizzaBuilder.createNewPizza(); pizzaBuilder.buildParts(); } } class FastFoodOrdering { public static void main(String[] args) { Waiter waiter = new Waiter(); PizzaBuilder hawaiian_pizzabuilder = new HawaiianPizzaBuilder(); waiter.setPizzaBuilder(hawaiian_pizzabuilder); waiter.construct(); System.out.println(\u0026#34;pizza：\u0026#34; + waiter.getPizza()); // 输出：pizza：cross + mild + ham\u0026amp;pineapp1e } } C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; class Pizza { private: string parts; public: void setParts(string parts) { this-\u0026gt;parts = parts; } string getParts() { return parts; } }; class PizzaBuilder { protected: Pizza *pizza; public: Pizza *getPizza() { return pizza; } void createNewPizza() { pizza = new Pizza(); } virtual void buildParts() = 0; }; class HawaiianPizzaBuilder : public PizzaBuilder { public: void buildParts() { pizza-\u0026gt;setParts(\u0026#34;cross + mild + ham\u0026amp;pineapple\u0026#34;); } }; class SpicyPizzaBuilder : public PizzaBuilder { public: void buildParts() { pizza-\u0026gt;setParts(\u0026#34;pan baked + hot + pepperoni\u0026amp;salami\u0026#34;); } }; class Waiter { private: PizzaBuilder *pizzaBuilder; public: void setPizzaBuilder(PizzaBuilder *pizzaBuilder) { /* 设置构建器 */ this-\u0026gt;pizzaBuilder = pizzaBuilder; } Pizza *getPizza() { return pizzaBuilder-\u0026gt;getPizza(); } void construct() { pizzaBuilder-\u0026gt;createNewPizza(); pizzaBuilder-\u0026gt;buildParts(); } }; int main() { Waiter *waiter = new Waiter(); PizzaBuilder *hawaiian_pizzabuilder = new HawaiianPizzaBuilder(); waiter-\u0026gt;setPizzaBuilder(hawaiian_pizzabuilder); waiter-\u0026gt;construct(); cout \u0026lt;\u0026lt; \u0026#34;pizza: \u0026#34; \u0026lt;\u0026lt; waiter-\u0026gt;getPizza()-\u0026gt;getParts() \u0026lt;\u0026lt; endl; } // 程序的输出结果为： // pizza：cross + mild + ham*pineapple 例子 2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 import java.util.*; public class Main{ public static void main(String[] args) { Director d = new Director(); Builder b1 = new Builder1(); d.Construct(b1); Product p1 = new b1.getResult(); p1.show(); } } class Product{ List\u0026lt;String\u0026gt; parts = new ArrayList\u0026lt;String\u0026gt;(); public void Add(String part){ parts.add(part); } public void show(){ System.out.println(\u0026#34;The information of product:\u0026#34;); for(String s : parts) System.out.print(s + \u0026#34; \u0026#34;); System.out.println(); } } abstract class Builder{ public abstract void BuildPart(); public abstract Product getResult(); } class Builder1 extends Builder{ Product p = new Product(); @Override public void BuildPart(){ p.Add(\u0026#34;A1\u0026#34;); p.Add(\u0026#34;A2\u0026#34;); p.Add(\u0026#34;C\u0026#34;); } @Override public Product getResult(){ return p; } } class Builder2 extends Builder{ Product p = new Product(); @Override public void BuildPart(){ p.Add(\u0026#34;B1\u0026#34;); p.Add(\u0026#34;B2\u0026#34;); p.Add(\u0026#34;C\u0026#34;); } @Override public Product getResult(){ return p; } } class Director{ public void Construct(Builder builder){ builder.BuildPart(); } } ","date":"2023-06-01T23:33:17+08:00","permalink":"https://blog.yexca.net/archives/112/","title":"生成器模式"},{"content":"简单工厂模式 简单工厂模式属于创建型模式，但不属于 23 种设计模式之一\n定义：定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类\n在简单工厂模式中用于被创建实例的方法通常为静态 (static) 方法，因此简单工厂模式又被称为静态工厂方法 (Static Factory Method)\n需要什么产品就传入产品对应的参数，就可以获取所需要的产品对象，而无需知道其实现过程\n例如：有一家饺子店，当客户需要某种饺子时，饺子店生成对应的饺子给客户。这里就可以把饺子店看成工厂 (Factory) ，饺子看成产品 (Product) ，饺子的名称看成参数，饺子店根据不同的参数返回不同的饺子\n比如：客户想要韭菜饺子，这里韭菜就是参数，饺子店会根据参数韭菜返回韭菜饺子 (饺子店有韭菜饺子的前提下)\n三类角色：\n工厂 (核心) ​\t负责实现创建所有产品的内部逻辑，工厂类可以被外界直接调用，创建所需对象\n抽象产品 ​\t工厂类所创建的所有对象的父类，封装了产品对象的公共方法，所有的具体产品为其子类对象\n具体产品 ​\t简单工厂模式的创建目标，所有被创建的对象都是某个具体类的实例\n例子 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 public class SimpleFactory{ public static void main(String[] args){ Product productA = Factory.createProduct(\u0026#34;A\u0026#34;); productA.info(); // ... } } abstract class Product{ public abstract void info(); } class ProductA extends Product{ @Override public void info(){ System.out.println(\u0026#34;A\u0026#34;); } } class ProductB extends Product{ @Override public void info(){ System.out.println(\u0026#34;B\u0026#34;); } } class Factory{ public static Product creatProduct(String type){ Product p = null; // 此处未考虑异常情况以及处理 switch(type){ case \u0026#34;A\u0026#34;: p = new ProductA(); break; case \u0026#34;B\u0026#34;: p = new ProductB(); break; default: System.out.println(\u0026#34;Please try again\u0026#34;); break; } return p; } } 当增加产品时，将更改工厂，违反了 开发 - 封闭原则\n工厂方法模式 Factory Method Pattern 类创建型模式\n意图 定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method 使一个类的实例化延迟到其子类\n结构 其中：\nProduct 定义工厂方法所创建的对象的接口 ConcreteProduct 实现 Product 接口 Creator 声明工厂方法，该方法返回一个 Product 类型的对象，Creator 也可以定义一个工厂方法的默认实现，它返回一个默认的 ConcreteProduct 对象，可以调用工厂方法以创建一个 Product 对象 ConcreteCreator 重定义工厂方法以返回一个 ConcreteProduct 实例 适用性 Factory Method 模式适用于：\n当一个类不知道它所必须创建的对象的类的时候 当一个类希望由它的子类来指定它所创建的对象的时候 当类将创建对象的职责委托给多个帮助子类中的某一个，并且你希望将哪一个帮助子类是代理者这一信息局部化的时候 例子 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 // 在上一个代码的基础上修改 public class FactoryMethod{ public static void main(String[] args){ Factory factoryA = new FactoryA(); //Product productA = Factory.createProduct(\u0026#34;A\u0026#34;); Product productA = factoryA.createProduct(); productA.info(); // ... } } // 抽象类改接口 // abstract class Product interface class Product{ // public abstract void info(); public void info(); } // 继承改实现 // class ProductA extends Product{ class ProductA implements Product{ @Override public void info(){ System.out.println(\u0026#34;A\u0026#34;); } } // 继承改实现 // class ProductB extends Product{ class ProductB implements Product{ @Override public void info(){ System.out.println(\u0026#34;B\u0026#34;); } } // 实类改接口 // class Factory interface Factory{ public Product creatProduct(); } // 增加接口实现 class FactoryA implements Factory{ @Override public Product createProduct(){ return new ProductA(); } } class FactoryB implements Factory{ @Override public Product createProduct(){ return new ProductB(); } } 抽象工厂模式 Abstract Factory Pattern 对象创建型模式\n意图 提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类\n结构 其中：\nAbstractFactory 声明一个创建抽象产品对象的操作接口 ConcreteFactory 实现创建具体产品对象的操作 AbstractProduct 为一类产品对象声明一个接口 ConcreteProduct 定义一个将被相应的具体工厂创建的产品对象，实现 AbstractProduct 接口 Client 仅使用由 AbstractFactory 和 AbstractProduct 类声明的接口 适用性 Abstract Factory 模式适用于：\n一个系统要独立于它的产品的创建、组合和表示时 一个系统要由多个产品系列中的一个来配置时 当要强调一系列相关的产品对象的设计以便进行联合使用时 当提供一个产品类库，只想显示它们的接口而不是实现时 例子 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 public class AbstractFactory{ public static void main(String[] args){ Factory factory1 = new Factory1(); ProductA productA = factory1.createProductA(); productA.info(); // ... } } interface class ProductA{ public void info(); } class ProductA1 implements ProductA{ @Override public void info(){ System.out.println(\u0026#34;A1\u0026#34;); } } class ProductA2 implements ProductA{ @Override public void info(){ System.out.println(\u0026#34;A2\u0026#34;); } } interface class ProductB{ public void info(); } class ProductB1 implements ProductB{ @Override public void info(){ System.out.println(\u0026#34;B1\u0026#34;); } } class ProductB2 implements ProductB{ @Override public void info(){ System.out.println(\u0026#34;B2\u0026#34;); } } interface Factory{ public ProductA creatProductA(); public ProductB creatProductB(); } class Factory1 implements Factory{ @Override public ProductA createProductA(){ return new ProductA1(); } @Override public ProductB createProductB(){ return new ProductB1(); } } class Factory2 implements Factory{ @Override public ProductA createProductA(){ return new ProductA2(); } @Override public ProductB createProductB(){ return new ProductB2(); } } ","date":"2023-05-28T10:23:46+08:00","permalink":"https://blog.yexca.net/archives/111/","title":"工厂模式"},{"content":"问题描述 某公司购买长钢条，将其切割后进行出售。切割钢条的成本可以忽略不计，钢条的长度为英寸。已知价格表 $p$ ，其中 $p_{i}(i=1,2,\\cdots,m)$ 表示长度为 $i$ 英寸的钢条的价格。现要求解使销售收益最大的切割方案\n问题分析 假设长钢条的长度为 $n$ 英寸，最佳切割方案的最左边切割段长度为 $i$ 英寸，则继续求解剩余长度为 $m-1$ 英寸钢条的最佳切割方案。考虑所以可能的 $i$ ，得到的最大收益 $r_{n}$ 对应的切割方案即为最佳切割方案。$r_{n}$ 的递归定义如下\n$$ r_{n}=max_{1\\le i \\le n}(p_{i}+r_{n-i}) $$\nC 代码 对此问题有两种方案\n(1) 分治 (自顶向下) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int Top_Down_Cut_Rod(int p[], int n){ int r=0; // 最大价值 int i; if(n==0){ retrun 0; } for(i=1; i\u0026lt;=n; i++){ int tmp = p[i]+Top_Down_Cut_Rod(p, n-i); r = (r\u0026gt;=tmp) ? r : tmp; } return r; } 时间复杂度 $O(2^{n})$\n(2) 动态规划 (自底向上) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int Bottom_Up_Cut_Rod(int p[], int n, int *s){ // *s:子问题最优切割方法 int r[n+1]; // 子问题最优价值 r[0]=0; for(int j=1; j\u0026lt;=n; j++){ int tmp=0; for(int i=1; i\u0026lt;=j; i++){ if(p[i]+r[j-1] \u0026gt; tmp){ tmp = p[i]+r[j-i]; s[j]=i; } } r[i]=tmp; } return r[n]; } 时间复杂度 $O(n^{2})$\n其他 在搜索过程中发现已有的文章： 【基础算法】动态规划详解——钢条切割 ","date":"2023-05-27T19:37:08+08:00","permalink":"https://blog.yexca.net/archives/110/","title":"算法 钢条切割问题 (动态规划 分治)"},{"content":"问题描述 有 $n$ 枚硬币，其中有一枚是假币，已知假币的重量较轻。现只有一个天平，要求用尽量少的比较次数找出这枚假币\n问题分析 将 $n$ 枚硬币分成相等的两部分：\n当 $n$ 为偶数时，将前后两部分，即 $1\\cdots\\frac{n}{2}$ 和 $\\frac{n}{2}+1\\cdots n$ 放在天平的两端，较轻的一端里有假币，继续在较轻的这部分硬币中用同样的方法找出假币 当 $n$ 为奇数时，将前后两部分，即 $1\\cdots\\frac{n-1}{2}$ 和 $\\frac{n+1}{2}+1\\cdots n$ 放在天平的两端，较轻的一端里有假币，继续在较轻的这部分硬币中用同样的方法找出假币；若两端重量相等，则中间的硬币，即第 $\\frac{n+1}{2}$ 枚硬币是假币 C 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 #include \u0026lt;stdio.h\u0026gt; // coins:重量数组 first,last:数组第一个与最后一个下标 int getCounterfeitCoin(int *coins, int first, int last); int main(void){ int coins[10] = {2,2,1,2,2,2,2,2,2,2}; int tmp = getCounterfeitCoin(coins, 0, 9); printf(\u0026#34;第 %d 个是假币\\n\u0026#34;,tmp+1); return 0; } int getCounterfeitCoin(int *coins, int first, int last){ int firstSum=0; int lastSum=0; int i; // 只剩两枚硬币 if(first == last -1){ if(coins[first] \u0026lt; coins[last]) return first; return last; } // 偶数枚硬币 if ((last-first+1)%2 == 0){ for(i=first; i\u0026lt;first+(last-first)/2+1; i++){ firstSum += coins[i]; } for(i=first+(last-first)/2+1; i\u0026lt;last+1; i++){ lastSum += coins[i]; } if(firstSum \u0026lt; lastSum){ return getCounterfeitCoin(coins, first, first+(last-first)/2); }else{ return getCounterfeitCoin(coins, first+(last-first)/2+1, last); } }else{ // 奇数枚硬币 for(i=first; i\u0026lt;first+(last-first)/2; i++){ firstSum += coins[i]; } for(i=first+(last-first)/2+1; i\u0026lt;last+1; i++){ lastSum += coins[i]; } if(firstSum \u0026lt; lastSum){ return getCounterfeitCoin(coins, first, first+(last-first)/2-1); }else if(firstSum \u0026gt; lastSum){ return getCounterfeitCoin(coins, first+(last-first)/2+1, last); }else{ return first+(last-first)/2; } } } ","date":"2023-05-18T20:17:35+08:00","permalink":"https://blog.yexca.net/archives/109/","title":"算法 假币问题 (分治)"},{"content":"\u0026ldquo;每一个设计模式描述了一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心。这样，你就能一次又一次地使用该方案而不必做重复劳动\u0026rdquo;。设计模式的核心在于提供了相关问题的解决方案，使得人们可以简单方便地复用成功的设计和体系结构\n设计模式一般有以下 4 个基本要素\n模式名称 (Pattern Name) 。一个助记名，它用一两个词来描述模式的问题、解决方案和效果 问题 (Problem) 。问题描述了应该在何时使用模式 解决方案 (Solution) 。解决方案描述了设计的组成成分、它们之间的相互关系及各自的职责和协作方式 效果 (Consequences) 。效果描述了模式应用的效果及使用模式应权衡的问题 设计模式确定了所包含的类和实例，它们的角色、协作方式以及职责分配。每一个设计模式都集中于一个特定的面向对象设计问题或设计要点，描述了什么时候使用它，在另一些设计约束条件下是否还能使用，以及使用的效果和如何取舍。按照设计模式的目的可以分成三大类\n创建型模式与对象的创建有关；结构型模式处理类或对象的组合；行为型模式对类或对象怎样分配职责进行描述\n创建型 结构型 行为型 类 工厂方法模式 适配器模式 (类) 解释器模式\n模板方法模式 对象 抽象工厂模式\n生成器模式\n原型模式\n单例模式 适配器模式 (对象)\n桥接模式\n组合模式\n装饰器模式\n外观模式\n享元模式\n代理模式 责任链模式\n命令模式\n迭代器模式\n中介者模式\n备忘录模式\n观察者模式\n状态模式\n策略模式\n访问者模式 创建型设计模式 创建型模式抽象了实例化过程，它们帮助一个系统独立于如何创建、组合和表示它的那些对象。一个类创建型模式使用继承改变被实例化的类，而一个对象创建型模式将实例化委托给另一个对象\n随着系统演化得越来越依嫩于对象复合而不是类继承，创建型模式变得更为重要，当这种情况发生时，重心从对一组固定行为的硬编码 (Hard-coding) 转移为定义一个较小的基本行为集，这些行为可以被组合成任意数目的更复杂的行为，这样创建有特定行为的对象要求的不仅仅是实例化一个类\n在这些模式中有两个不断出现的主旋律\n它们都将关于该系统使用哪些具体的类的信息封装起来 它们隐藏了这些类的实例是如何被创建和放在一起的。整个系统关于这些对象所知道的是由抽象类所定义的接口 因此，创建型模式为什么被创建，谁创建它，它是怎样被创建的，以及何时创建这些方面给予了很大的灵活性。它们允许用结构和功能差别很大的 \u0026ldquo;产品\u0026rdquo; 对象配置一个系统。配置可以是静态的 (即在编译时指定) ，也可以是动态的 (在运行时)\n结构型设计模式 结构型设计模式涉及如何组合类和对象以获得更大的结构。结构型类模式采用继承机制来组合接口或实现。一个简单的例子是采用多重继承方法将两个以上的类组合成一个类，结果这个类包含了所有父类的性质。这一模式尤其有助于多个独立开发的类库协同工作。其中一个例子是类形式的 Adapter 模式。一般来说，适配器使得一个接口与其他接口兼容，从而給出了多个不同接口的统一抽象。为此，类适配器对一个 adaptee 类进行私有继承。这样，适配器就可以用 adaptee 的接口表示它的接口\n结构型对象模式不是对接口和实现进行组合，而是描述了如何对一些对象进行组合，从而实现新功能的一些方法。因为可以在运行时刻改变对象组合关系，所以对象组合方式具有更大的灵活性，而这种机制用静态类组合是不可能实现的\n行为型设计模式 行为模式涉及算法和对象间职责的分配。行为模式不仅描述对象或类的模式，还描述它们之间的通信模式。这些模式刻面了在运行时难以跟踪的、复杂的控制流。它们将用户的注意力从控制流转移到对象间的联系方式上来\n行为类模式使用继承机制在类间分派行为。其中 Template Method 较为简单和常用。模板方法是一个算法的抽象定义，它逐步地定义该算法，每一步调用一个抽象操作或一个原语操作，子类定义抽象操作以具体实现该算法。另一种行为类模式是 Interpreter，它将一个文法表示为一个类层次，并实现一个解释器作为这些类的实例上的一个操作\n行为对象模式使用对象复合而不是继承。一些行为对象模式描达了一组对等的对象怎样相互协作以完成其中任一个对象都无法单独完成的任务。这里一个重要的问题是对等的对象\n如何互相了解对方。对等对象可以保持显式的对对方的引用，但那会增加它们的耦合度。在极端情况下，每一个对象都要了解所有其他的对象。Mediator 在对等对象间引入一个 mediator 对象以避免这种情况的出现。mediator 提供了松耦合所需的间接性\n推荐阅读 https://refactoringguru.cn/design-patterns ","date":"2023-05-17T22:50:20+08:00","permalink":"https://blog.yexca.net/archives/108/","title":"设计模式 引"},{"content":"针对中国大陆无法进入游戏分流规则\nKey 在进入游戏时需要 udp 连接，而多数协议不支持 udp，即遇到 udp 会自动拒绝，所以将 udp 连接的 IP 设置为直连即可，下面是我抓取到的两个 IP\n1 2 3 8.209.196.179 # 第二个貌似直连不会连接，只用设置第一个就行 47.245.63.117 当然，为了安全起见 (指 tcp 连接与 udp 连接不一致可能造成的安全隐患) ，建议将相关域名都设置直连，即以下这些\n1 2 3 *.starrails.com *.hoyoverse.com 8.209.196.179/8 OpenClash 在 全局设置-规则设置 ，启用 自定义规则 ，第一个框的 rules: 下输入\n1 2 3 4 #rules: - DOMAIN-SUFFIX, starrails.com, DIRECT - DOMAIN-SUFFIX, hoyoverse.com, DIRECT - IP-CIDR, 8.209.196.179/8, DIRECT Quantumult X 编辑配置文件，跳转至 [filter_local] ，输入以下内容\n1 2 3 4 #SR host-suffix, starrails.com, direct host-suffix, hoyoverse.com, direct ip-cidr, 8.209.196.179/8, direct ","date":"2023-05-16T23:13:21+08:00","permalink":"https://blog.yexca.net/archives/107/","title":"Honkai: Star Rail 国际服分流规则"},{"content":"问题描述 在一块电路板的上下两端分别有 n 个接线柱。根据电路设计，用 $(i, \\pi(i))$ 表示将上端接线柱 i 与下端接线柱 $\\pi(i)$ 相连，称其为该电路板上的第 i 条连线\n下图所示的 $\\pi(i)$ 排列为 ${8, 7, 4, 2, 5, 1, 9, 3, 10, 6}$ 对于任何 $1 \\le i \u0026lt; j \\le n $ ，第 i 条连线和第 j 条连线相交的充要条件是 $\\pi(i)\u0026gt;\\pi(j)$\n在制作电路板时，要求将这 n 条连线分布到若干绝缘层上，在同一层上的连线不相交，现在要确定将哪些连线安排在一层上，使得该层上有尽可能多的连线，即确定连线集 $Nets={ (i,\\pi(i)),1\\le i\\le n }$ 的最大不相交子集\n问题分析 记 $N(i,j)={ t|(t,\\pi(t))\\in Nets, t\\le i, \\pi(t) \\le j }$ 。$N(i,j)$ 的最大不相交子集为 $MNS(i,j)$ ，$size(i,j)=|MNS(i,j)|$\n经分析，该问题具有最优子结构性质。对规模为 n 的电路布线问题，可以构造如下递归式\n$$ \\begin{align*} \u0026amp;(1) \\ 当 \\ i=1\\ 时， size(1,j)= \\begin{cases} 0, \u0026amp; \\text{j\u0026lt;$\\pi$(1)} \\ 1, \u0026amp; \\text{其他情况} \\end{cases} \\ \u0026amp;(2) \\ 当 \\ i\u0026gt;1\\ 时， size(i,j)= \\begin{cases} size(i-1,j), \u0026amp; \\text{j\u0026lt;$\\pi$(i)} \\ max{size(i-1,j),size(i-1,\\pi(i)-1)+1}, \u0026amp; \\text{其他情况} \\end{cases} \\end{align*} $$\nC 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #define N 10 // 问题规模 // 求最大不相交连接数 void maxNum(int pi[], int **size); // 构造最大不相交连接集合，net[i]表示最大不相交子集中第i条连线的上端接线柱的序号 int constructSet(int pi[], int **size, int *net); int main(void){ // 下标从1开始 int pi[N+1] = {0, 8, 7, 4, 2, 5, 1, 9, 3, 10, 6}; int net[N]; int **size; size = (int**)malloc(sizeof(int*)*(N+1)); for(int i=0;i\u0026lt;N+1;i++) size[i]=(int*)malloc(sizeof(int)*(N+1)); maxNum(pi, size); int m = constructSet(pi, size, net); printf(\u0026#34;最大不相交连接数为：%d\\n\u0026#34;,m); printf(\u0026#34;包含的连线为：\\n\u0026#34;); for(int i=0; i\u0026lt;m; i++){ printf(\u0026#34;(%d,%d)\\n\u0026#34;, net[i], pi[net[i]]); } } void maxNum(int pi[], int **size){ // size[i][j]: 上下端分别有i个和j个接线柱的电路板的第一层最大不相交连接数 int i,j; // when j\u0026lt;pi(1) for(j=0; j\u0026lt;pi[1]; j++) size[1][j]; // when j\u0026gt;=pi(1) for(j=pi[1]; j\u0026lt;=N; j++) size[1][j]; for(i=2; i\u0026lt;N; i++){ // when j\u0026lt;pi(i) for(j=0; j\u0026lt;pi[i]; j++) size[i][j] = size[i-1][j]; // when j\u0026gt;=c[i] for(j=pi[i]; j\u0026lt;=N; j++) size[i][j]=size[i-1][j]\u0026gt;=size[i-1][pi[i]-1]+1 ? size[i-1][j] : size[i-1][pi[i]-1]+1; } // 最大连接数 size[N][N] = size[N-1][N]\u0026gt;=size[N-1][pi[N]-1]+1 ? size[N-1][N] : size[N-1][pi[N]-1]+1; } // 构造最大不相交连接集合，net[i]表示最大不相交子集中第i条连线的上端接线柱的序号 int constructSet(int pi[], int **size, int *net){ int i; int j=N; int m=0; // 记录最大连接集合中的接线柱 for(i=N; i\u0026gt;1; i--){ // 递减 // (i,pi[i])是最大不相交子集的一条连线 if(size[i][j] != size[i-1][j]){ net[m++]=i; // 将i记录到数组net中，连接线数自增1 j=pi[i]-1; // 更新扩展连线柱区间 } } // when i=1 if(j\u0026gt;=pi[1]) net[m++] = 1; return m; } 其他 在搜索过程中发现已有的文章： 算法设计与分析——电路布线（动态规划） 参考文章 LaTeX公式手册 Typora中使用LaTeX：多行公式左对齐 用malloc动态申请一个二维数组的三种方法 ","date":"2023-05-16T17:53:31+08:00","permalink":"https://blog.yexca.net/archives/106/","title":"算法 电路布线问题 (动态规划)"},{"content":"使用 Rclone 挂载 Onedrive 歌曲文件，Navidrome 搭建网站，采用 docker 部署\nRclone 首先需要在 Windows 系统上运行获取配置，然后再在服务器上安装并挂载文件\n获取 Token 在 Windows 电脑上下载 Rclone，下载地址： https://rclone.org/downloads/ 下载完成后解压，解压完成后通过 cmd 进入该文件夹，然后运行\n1 rclone.exe authorize \u0026#34;onedrive\u0026#34; 在弹出的浏览器中登录并授权，授权完成后会打印 Token (大括号之间的，包括大括号)\n获取配置文件 运行命令\n1 rclone.exe config 根据需求选择即可，完成后配置文件生成在：\n1 C:\\Users\\%USERNAME%\\AppData\\Roaming\\rclone 复制配置文件 首先需要在服务器创建两个文件夹\n1 2 3 4 # 该文件夹放配置文件 /home/docker/rclone/config # 该文件夹放数据，即 Onedrive 映射到的文件夹 /home/docker/rclone/data 然后将配置文件放到对应的文件夹\n挂载目录 运行命令以拉取镜像\n1 docker pull rclone/rclone:latest 挂载目录\n1 2 3 4 5 6 7 8 9 10 11 12 docker run --rm \\ --volume /root/rclone/config:/config/rclone \\ --volume /root/rclone/data:/data:shared \\ --volume /etc/passwd:/etc/passwd:ro --volume /etc/group:/etc/group:ro \\ --device /dev/fuse --cap-add SYS_ADMIN --security-opt apparmor:unconfined \\ rclone/rclone \\ mount music:/ /data/music --allow-other --allow-non-empty --vfs-cache-mode writes \u0026amp; # 上述命令仅最后一行为 Rclone 的命令，根据实际情况修改，格式如下 rclone mount DriveName:Folder LocalFolder # DriveName Rclone 挂载的名称 # Folder 云盘的路径 # LocalFolder 挂载到本地的文件 上述命令最后的 \u0026amp; 表示后台运行，命令执行后会打印进程的 PID，如需关闭使用命令\n1 kill PID 了解更多？访问： Linux 学习 第六章 管理运行中的进程 根据示例，此处演示将 Onedrive 中 music (不区分大小写) 目录挂载至 /home/docker/rclone/data/music\n参考资料：\nhttps://rclone.org/onedrive/ https://rclone.cn/install.html Linux上使用Rclone挂载OneDrive或GoogleDrive并设置开机自启 部署 Navidrome 采用 docker-compose，首先创建文件夹，例如\n1 /home/docker/navidrome 创建文件 docker-compose.yml 并填入内容\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 vim docker-compose.yml # 输入内容 version: \u0026#34;3\u0026#34; services: navidrome: image: deluan/navidrome:latest ports: - \u0026#34;8001:4533\u0026#34; restart: unless-stopped environment: # Optional: put your config options customization here. Examples: ND_SCANSCHEDULE: 1h ND_LOGLEVEL: info ND_SESSIONTIMEOUT: 24h ND_BASEURL: \u0026#34;\u0026#34; volumes: - \u0026#34;/home/docker/navidrome/data:/data\u0026#34; - \u0026#34;/home/docker/rclone/data/music:/music:ro\u0026#34; 查看更多变量： Navidrome Configuration Options - Navidrome 然后运行命令\n1 docker-compose up -d 访问 IP:8001 即可\n参考资料：\nhttps://www.navidrome.org/docs/installation/docker/ Navidrome搭建一个属于自己的音乐播放器 歌曲信息 如果想要进行歌曲分类需要把歌曲的信息嵌入歌曲里，包括歌词\n可以使用工具 MusicTag 进行修改\n作者网站： 音乐标签pc版 当然还有其他的工具，或者这个 Web 版 xhongc/music-tag-web 使用客户端 这个网页端在 PC 上使用还行，但是手机上使用一言难尽，不过好在有一些客户端可以使用\n详情访问： https://www.navidrome.org/docs/overview/#apps ","date":"2023-05-02T02:27:39+08:00","permalink":"https://blog.yexca.net/archives/105/","title":"搭建个人音乐网站"},{"content":"图 (Diagram) 是一组元素的图形表示，大多数情况下把图画成顶点 (代表事物) 和弧 (代表关系) 的连通图。为了对系统进行可视化，可以从不同的角度画图，这样图是对系统的投影\nUML 2.0 提供了 13 种图，分别是类图、对象图、用例图、序列图、通信图、状态图、活动图、构件图、组合结构图、部署图、包图、交互概览图和计时图。序列图、通信图、交互概览图和计时图均被称为交互图\n(一) 类图 类图 (Class Diagram) 展现了一组对象、接口、协作和它们之间的关系。在面向对象系统的建模中所建立的最常见的图就是类图。类图给出系统的静态设计视图。包含主动类的类图给出了系统的静态进程视图\n类图中通常包括下述内容：\n类 接口 协作 依赖、泛化和关联关系 例如：\nStudent +id: int\n-name: String\n#age: int ~borrow(): bool +: public\n-: private\n#: protected\n~: package\n类图中也可以包含注解和约束。类图还可以含有包或子系统，二者都用于把模型元素聚集成更大的组块\n类图用于对系统的静态设计视图建模。这种视图主要支持系统的功能需求，即系统要提供给最终用户的服务。当对系统的静态设计视图建模时，通常以下述 3 种方式之一使用类图\n对系统的词汇建模 对简单的协作建模 对逻辑数据库模式建模 (二) 对象图 对象图 (Object Diagram) 展现了某一时刻一组对象以及它们之间的关系，描述了在类图中所建立的事物的实例的静态快照。对象图一般包括对象和链\n对象名：类名 属性 和类图一样，对象图给出系统的静态设计视图或静态进程视图\n(三) 用例图 用例图 (Use Case Diagram) 展现了一组用例、参与者 (Actor) 以及它们之间的关系\n用例图通常包含以下内容：\n用例 参与者 用例之间的拓展关系 \u0026lt;\u0026lt;extend\u0026gt;\u0026gt; 和包含关系 \u0026lt;\u0026lt;include\u0026gt;\u0026gt; ，参与者和用例之间的关联关系，用例与用例以及参与者与参与者之间的泛化关系 包含关系 一个用例包含另一个用例\n基本用例 \u0026ndash;\u0026lt;\u0026lt;include\u0026gt;\u0026gt;\u0026ndash;\u0026gt; 被包含用例\n扩展关系 一个用例执行的时候，可能会发生一些特殊的情况或可选的情况，这种情况就是这个用例的扩展用例\n扩展用例 \u0026ndash;\u0026lt;\u0026lt;extend\u0026gt;\u0026gt;\u0026ndash;\u0026gt; 基本用例\n用例图用于对系统的静态用例视图进行建模。这个视图主要支持系统的行为，即该系统在它的周边环境的语境中所提供的外部可见服务\n当对系统的静态用例视图建模时，可以用下列两种方式来使用用例图\n对系统的语境建模 对系统的需求建模 (四) 交互图 交互图用于对系统的动态方面进行建模。一张交互图表现的是一个交互，由一组对象和它们之间的关系组成，包含它们之间可能传递的信息。交互图表现为序列图、通信图、交互概览图和计时图，每种针对不同的目的，能适用于不同的情况。序列图是强调消息时间顺序的交互图；通信图是强调接受和发生消息的对象的结构组织的交互图；交互概览图强调控制流的交互图\n交互图一般包含对象、链和消息\n序列图 序列图 (Sequence Diagram) 是场景 (Scenario) 的图形化表示，描述了以时间顺序组织的对象之间的交互活动。形成序列图时，首先把参加交互的对象放在图的上方，沿水平方向排列。通常把发起交互的对象放在左边，下级对象以此放在右边。然后，把这些对象发生和接收的消息沿着垂直方向按时间顺序从上到下放置。这样，就提供了控制流随时间推移的清晰的可视化轨迹\n序列图有两个不同于通信图的特征\n序列图有对象生命线。对象生命线是一条垂直的虚线，表示一个对象在一段时间内存在 序列图有控制焦点。控制焦点是一个瘦高的矩形，表示一个对象执行一个动作所经历的时间段，既可以是直接执行，也可以是通过下级过程执行。矩形的顶部表示动作的开始，底部表示动作的结束 通信图 通信图 (Communication Diagram) 强调收发信息的对象的结构组织，在早期的版本中也被称作协作图。通信图强调参加交互的对象的组织。产生一张通信图，首先要将参加交互的对象作为图的顶点，然后把连接这些对象的链表示为图的弧，最后用对象发送和接收的消息来修饰这些链。这就提供了在协作对象的结构组织的语境中观察控制流的一个清晰的可视化轨迹\n通信图有两个不同于序列图的特性\n通信图有路径。为了指出一个对象如何与另一个对象链接，可以在链的末端附上一个路径构造型 通信图有顺序号。为表示一个消息的时间顺序，可以给消息加一个数字前缀，在控制流中，每个新消息的顺序号单调增加。为了使用嵌套，可使用带小数点的号码 序列图和通信图是同构的，它们之间可以相互转换\n(五) 状态图 状态图 (State Diagram) 展现了一个状态机，它由状态、转换、事件和活动组成。状态图关注系统的动态视图，对于接口、类和协作的行为建模尤为重要，强调对象行为的事件顺序\n状态图通常包括简单状态和组合状态、转换 (事件和动作)\n状态 状态是任何可以被观察到的系统行为模式，一个状态代表系统的一种行为模式。状态规定了系统对事件的响应方式。系统对事件的响应，既可以是做一个 (或一系列) 动作，也可以是仅仅改变系统本身的状态，还可以是既改变状态，又做动作\n在状态图中定义的状态主要有：初态 (即初始状态) 、终态 (即最终状态) 和中间状态。初态用一个黑圆点表示，终态用黑圆点外加一个圆表示，状态图中的状态用一个圆角四边形表示\n状态之间为状态转换，用一条带箭头的线表示。带箭头的线上的事件发生时，状态转换开始。一张状态图中只能有一个初态，而终态可以没有，也可以有多个\n三种标准事件：\nentry: 入口动作，进入状态，立即执行 exit: 出口动作，退出状态，立即执行 do: 内部活动，占有有限时间，并可以中断的工作 以上图例：\nentry/turnON: 当转入该状态时，做开灯动作 do/blinkFivetimes: 当处于该状态时，灯闪烁 5 次 exit/turnOFF: 当转出该状态时，做关灯动作 事件与转换 事件是在某个特定时刻发生的事情，它是对引起系统做动作或 (和) 从一个状态转换到另一个状态的外界事件的抽象。例如，观众使用电视遥控器，用户移动鼠标、单机鼠标等都是事件。简而言之，事件就是引起系统引起系统做动作或 (和) 转换状态的控制信息\n状态变迁通常是由事件触发的，在这种情况下，应在表示状态转换的箭头上标出触发转换的事件表达式\n如果在箭头线上未标明事件，则表示在源状态的内部活动执行完之后自动触发转换，事件表达式的语法如下\n事件说明[监护条件]动作表达式\n其中，事件说明的语法为：事件名(参数表)\n监护条件 (或者守护条件) 是一个布尔表达式。如果同时使用事件说明和监护条件，则当且仅当事件发生且布尔表达式为真时，状态转换才发生。如果只有监护条件没有事件说明时，则只要守卫条件为真，状态转换就发生\n转换包括两个状态 (原状态，目标状态) 事件，监护条件，动作\n事件触发转换 (迁移)\n活动 (动作) 可以在状态内执行，也可以在状态转换 (迁移) 时执行\n完整图 可以用状态图对系统的动态方面建模。这些动态方面可以包括出现在系统体系结构的任何视图中的任何一种对象的按事件排序的行为，这些对象包括类 (各主动类) 、接口、构件和结点\n当对系统、类或用例的动态方面建模时，通常是对反应型对象建模\n(六) 活动图 活动图 (Activity Diagram) 是一种特殊的状态图，它展现了在系统内从一个活动到另一个活动的流程。活动图专注于系统的动态视图，它对于系统的功能建模特别重要，并强调对象间的控制流程\n活动图一般包括活动状态和动作状态、转换和对象\n活动图可以表示分支、合并、分岔和汇合\n当对一个系统的动态方面建模时，通常有两种使用活动图的方式\n对工作流建模 对操作建模 (七) 构件图 构件图 (Component Diagram) 展现了一组构件之间的组织和依赖。构件图专注于系统的静态实现视图。它与类图相关，通常把构件映射为一个或多个类、接口或协作\n(八) 部署图 部署图 (Deployment Diagram) 是用来对面向对象系统的物理方面建模的方法，展现了运行时处理结点以及其中构件 (制品) 的配置。部署图对系统的静态部署视图进行建模，它与构件图相关。通常，一个结点是一个在运行时存在并代表一项计算资源的物理元素，至少拥有一些内容，常常具有处理能力，包含一个或多个构件。其中 \u0026lt;\u0026lt;artifact\u0026gt;\u0026gt; 表示制品\n总结 静态建模：类图、对象图、用例图\n动态建模：序列图 (顺序图，时序图) 、通信图 (协作图) 、状态图、活动图\n物理建模：构件图 (组件图) 、部署图\n交互图：序列图 (顺序图，时序图) 、通信图 (协作图)\n","date":"2023-04-13T20:02:00+08:00","permalink":"https://blog.yexca.net/archives/104/","title":"UML 中的图"},{"content":"面向对象分析强调的是对一个系统中对象的特征和行为的定义。目前，国际上已经出现了多种面向对象的方法。业界普遍接受的为 UML (Unified Modeling Language, 统一建模语言)\n统一建模语言是面向对象软件的标准化建模语言。由于其简单、统一，又能够表达软件设计中的动态和静态信息，目前已经成为可视化建模语言事实上的工业标准\nUML 由 3 个要素构成：UML 的基本构造块、支配这些构造块如何放置在一起的规则和运用与整个语言的一些公共机制\nUML 的词汇表包含 3 种构造块：事物、关系和图。事物是对模型中最具有代表性的成分的抽象；关系把事物结合在一起；图凝聚了相关的事物\n事物 UML 中有 4 种事物：结构事物、行为事物、分组事物和注释事物\n(1) 结构事物 (Structural Thing) 结构事物是 UML 模型中的名词。它们通常是模型的静态部分，描述概念或物理元素\n结构事物包括：\n类 (Class)\n接口 (Interface)\n协作 (Collaboration)\n用例 (Use Case)\n主动类 (Active Class)\n构件 (Component)\n制品 (Artifact)\n结点 (Node)\n(2) 行为事物 (Behavior thing) 行为事物是 UML 模型的动态部分。它们是模型中的动词，描述了跨越时间和空间的行为\n行为事物包括：\n交互 (Interaction) 状态机 (State Machine) 活动 (Activity) (3) 分组事物 (Grouping Thing) 分组事物是 UML 模型的组织部分，是一些由模型分解成的 \u0026ldquo;盒子\u0026rdquo; 。在所有的分组事物中，最主要的分组事物是包 (Package) 。包是把元素组织成组的机制，这种机制具有多种用途。结构事物、行为事物甚至其他分组事物都可以放进包内。包与构件 (仅在运行时存在) 不同，它纯粹是概念上的 (即它仅在开发时存在)\n(4) 注释事物 (Annotational Thing) 注释事物是 UML 模型的解释部分。这些注释事物用来描述、说明和标注模型的任何元素。注解 (Note) 是一种主要的注释事物。注解是一个依附于一个元素或者一组元素之上，对它进行约束或解释的简单符号\n关系 UML 中有 4 种关系：依赖、关联、泛化和实现\n依赖 (Dependency) 依赖是两个事物间的语义关系，其中一个事物 (独立事物) 发生变化会影响另一个事物 (依赖事物) 的语义。在图形上，把一个依赖画成一条可能有方向的虚线\n关联 (Association) 关联是一种结构关系，它描述了一组链，链是对象之间的连接。聚集 (Aggregation) 是一种特殊类型的关联，它描述了整体和部分间的结构关系。在关联上可以标注重复度 (Multiplicity) 和角色 (Role)\n关联、聚合、组合 关联：关联是一种结构关系，它描述了一组链，链是对象之间的连接。在关联上可以标注重复度 (多重度) 和角色 例：雇主与员工\n聚合：部分和整体的生命周期不一致，整体消失了，部分仍然存在，部分可以脱离整体存在 例：班级与学生，公司与员工\n组合：部分和整体的生命周期一致，整体消失了，部分也消失了，部分不可以脱离整体存在 例：人与大脑\n依赖与单向关联 依赖较偶然，临时。例如：人与食物，仅饿时依赖，饱了便不依赖\n单向关联，比较强烈，用单向线表示。例如：人与氧气，鱼与水\n泛化 (Generalization) 泛化是一种特殊/一般关系，特殊元素 (子元素) 的对象可替代一般元素 (父元素) 的对象。用这种方法，子元素共享了父元素的结构和行为。图形上指向父元素\n实现 (Realization) 实现是类元之间的语义关系，其中一个类元指定了由另一个类元保证执行的契约。在两种情况下会使用实现关系：一种是在接口和实现它们的类或构件之间；另一种是在用例和实现它们的协作之间\n","date":"2023-04-11T08:01:00+08:00","permalink":"https://blog.yexca.net/archives/103/","title":"UML"},{"content":"从想法产生到彻底实现，一共耗时三个月 (主要是太懒了)\n安装 Docker 使用了 APT 进行安装\n添加 HTTPS 传输的软件包以及 CA 证书 1 2 3 4 5 6 7 8 9 10 # 先更新一下 sudo apt-get update # 然后安装 sudo apt-get install \\ apt-transport-https \\ ca-certificates \\ curl \\ gnupg \\ lsb-release 为了确认所下载软件包的合法性，需要添加软件源的 GPG 密钥 1 2 3 4 5 6 # 国内源 curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/debian/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg # 官方源 curl -fsSL https://download.docker.com/linux/debian/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg 向 sources.list 中添加 Docker 软件源 首先需要确定 Debian 的版本号，然后替换下面命令的 $(lsb_release -cs)\n版本号需要在 https://mirrors.aliyun.com/docker-ce/linux/debian/dists/ 中\n1 2 3 4 5 6 7 8 9 10 # 国内源 echo \\ \u0026#34;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://mirrors.aliyun.com/docker-ce/linux/debian \\ $(lsb_release -cs) stable\u0026#34; | sudo tee /etc/apt/sources.list.d/docker.list \u0026gt; /dev/null # 官方源 echo \\ \u0026#34;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/debian \\ $(lsb_release -cs) stable\u0026#34; | sudo tee /etc/apt/sources.list.d/docker.list \u0026gt; /dev/null 如 Debian10 的是 buster ，Debian11 的为 bullseye\n1 2 3 4 # 此为 Debian11 的 echo \\ \u0026#34;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://mirrors.aliyun.com/docker-ce/linux/debian \\ bullseye stable\u0026#34; | sudo tee /etc/apt/sources.list.d/docker.list \u0026gt; /dev/null 以上命令会添加稳定版本的 Docker APT 源，如果需要测试版本的 Docker 请将 stable 改为 test\n然后安装 1 2 3 4 5 6 7 8 # 更新缓存 sudo apt-get update # 安装 docker sudo apt-get install docker-ce docker-ce-cli containerd.io # 安装 docker-compose sudo apt-get install docker-compose 或者可以试试一键安装脚本\n1 2 3 4 5 6 7 8 9 10 11 # 测试版 curl -fsSL test.docker.com -o get-docker.sh # 以下为稳定版 curl -fsSL get.docker.com -o get-docker.sh # 阿里云源 sudo sh get-docker.sh --mirror Aliyun # 微软 AzureChina 源 sudo sh get-docker.sh --mirror AzureChinaCloud 启动 Docker 1 2 sudo systemctl enable docker sudo systemctl start docker 使用命令以下测试是否成功启动\n1 docker run --rm hello-world 出现下述类似输出即安装启动成功\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 Unable to find image \u0026#39;hello-world:latest\u0026#39; locally latest: Pulling from library/hello-world 2db29710123e: Pull complete Digest: sha256:c77be1d3a47d0caf71a82dd893ee61ce01f32fc758031a6ec4cf1389248bb833 Status: Downloaded newer image for hello-world:latest Hello from Docker! This message shows that your installation appears to be working correctly. To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the \u0026#34;hello-world\u0026#34; image from the Docker Hub. (amd64) 3. The Docker daemon created a new container from that image which runs the executable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent it to your terminal. To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bash Share images, automate workflows, and more with a free Docker ID: https://hub.docker.com/ For more examples and ideas, visit: https://docs.docker.com/get-started/ Blog1: WordPress 创建相应文件夹 (例如 /root/wordpress)，然后创建 docker-compose.yml 文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 version: \u0026#39;3.3\u0026#39; services: db: image: mysql:5.7 volumes: - db_data:/var/lib/mysql restart: always environment: MYSQL_ROOT_PASSWORD: somewordpress MYSQL_DATABASE: wordpress MYSQL_USER: wordpress MYSQL_PASSWORD: wordpress wordpress: depends_on: - db image: wordpress:latest volumes: - /root/wordpress/uploads.ini:/usr/local/etc/php/conf.d/uploads.ini ports: - 8000:80 restart: always environment: WORDPRESS_DB_HOST: db:3306 WORDPRESS_DB_USER: wordpress WORDPRESS_DB_PASSWORD: wordpress WORDPRESS_DB_NAME: wordpress volumes: db_data: {} 创建 uploads.ini 文件\n1 2 3 4 5 file_uploads = On memory_limit = 256M upload_max_filesize = 10M post_max_size = 10M max_execution_time = 600 docker 容器运行相关 1 2 3 4 5 6 7 8 # 后台运行 docker-compose up -d # 停止 docker-compose stop # 停止并删除 docker-compose down Blog2: Typecho 使用镜像： 80x86/typecho 创建文件夹与相应文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 version: \u0026#39;3.0\u0026#39; services: typecho: image: 80x86/typecho:latest container_name: Typecho_Blog volumes: - /root/typecho/data:/data ports: - 8001:80 restart: always environment: PHP_TZ: Asia/Shanghai PHP_MAX_EXECUTION_TIME: 600 网盘网站 使用项目： https://github.com/px-org/PanIndex 官方教程： https://docs.noki.icu/ 1 2 3 4 5 6 7 8 9 10 version: \u0026#34;3.0\u0026#34; services: PanIndex: restart: always image: iicm/pan-index:latest container_name: VRC_Pan volumes: - /root/pan/data:/app/data ports: - 8002:5238 nginx 与 SSL 证书 使用项目： https://github.com/0xJacky/nginx-ui 1 2 3 4 5 6 7 8 9 10 11 12 13 version: \u0026#39;3.1\u0026#39; services: nginx-ui: restart: always image: uozi/nginx-ui:latest container_name: nginx_UI volumes: - /root/nginx/nginx:/etc/nginx - /root/nginx/nginx-ui:/etc/nginx-ui - /root/nginx/www:/www ports: - 80:80 - 443:443 在配置时代理宿主机的话，可以将宿主机 IP 视为 172.17.0.1\n具体可通过一些命令查询\n1 ip addr show docker0 GUI 没什么好说的\n进入容器内部 获取容器 ID 1 docker container ls 进入 1 docker exec -i [ID] bash 然后使用 bash 命令即可 (没有 bash 提示符)\n以下仅记录 耗时最长的就是调 nginx 和 ssl 配置了，最后一直不成功，便使用 GUI\nSSL 证书 使用了 neilpang/acme.sh ，使用了 DNS 验证，其他方式请参考 Run acme.sh in docker · acmesh-official/acme.sh Wiki (github.com) 创建相应文件夹与文件\n1 2 3 4 5 6 7 8 9 10 11 12 version: \u0026#39;3.1\u0026#39; services: acme.sh: image: neilpang/acme.sh container_name: acme.sh command: daemon volumes: - /root/acme/acme.sh:/acme.sh - /root/acme/conf:/.acme.sh environment: - CF_Key=\u0026#34;这是CF的API\u0026#34; - CF_Email=\u0026#34;这是CF的邮箱\u0026#34; 对于其他 DNS 服务商，请参考： https://github.com/acmesh-official/acme.sh/wiki/dnsapi 注册账号：\n1 docker exec acme.sh --register-account -m mail@server.com 获取证书 (此处为 CF)\n1 docker exec acme.sh --issue --dns dns_cf -d example.com -d www.example.com 获取后的证书和存储目录会打印出来，将此目录映射到 nginx 容器\n可以设置 cron 定时任务以自动更新证书，参考： Linux Crontab 定时任务 - 菜鸟教程 参考资料\ndocker获取Let\u0026rsquo;s Encrypt永久免费SSL证书 - 腾讯云开发者社区-腾讯云 (tencent.com) ZeroSSL.com CA · acmesh-official/acme.sh Wiki (github.com) Nginx 创建相应文件夹 (例如 /root/nginx)，然后创建 docker-compose.yml\n1 2 3 4 5 6 7 8 9 10 11 12 13 version: \u0026#39;3.1\u0026#39; services: nginx: restart: always image: nginx container_name: nginx ports: - 80:80 volumes: - /root/docker/nginx/conf.d:/etc/nginx/conf.d - /root/docker/nginx/www:/user/share/nfinx/html - /root/docker/nginx/log:/var/log/nginx - /root/acme/acme.sh:/ssl 然后运行，启动后当前目录有 conf.d 文件夹，在该文件夹新建以 .conf 为后缀的文件，例如 default.conf\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 server { listen 80; listen [::]:80; server_name \u0026lt;your_server_name\u0026gt;; rewrite ^(.*)$ https://$host$1 permanent; } map $http_upgrade $connection_upgrade { default upgrade; \u0026#39;\u0026#39; close; } server { listen 443 ssl http2; listen [::]:443 ssl http2; server_name \u0026lt;your_server_name\u0026gt;; # ssl 证书位置 ssl_certificate /path/to/ssl_cert; # ssl 密钥位置 ssl_certificate_key /path/to/ssl_cert_key; location / { proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection $connection_upgrade; proxy_pass http://172.17.0.1:9000/; } } 参考资料\ndocker安装nginx并配置ssl证书，代理宿主机服务_Blueeyedboy521的博客-CSDN博客_bitwarden docker ssl Nginx 安装 SSL 配置 HTTPS 超详细完整全过程-阿里云开发者社区 (aliyun.com) 快速部署 Docker 同时发布多个网站或服务_天道酬勤~的博客-CSDN博客_docker部署 一台服务器多个系统 Let\u0026rsquo;s Encrypt 使用教程，免费的SSL证书，让你的网站拥抱 HTTPS - Diamond-Blog (diamondfsd.com) Nginx反向代理的一次使用总结 - 简书 (jianshu.com) Nginx配置反向代理隐藏服务端口 - \u0026amp;大飞 - 博客园 (cnblogs.com) 参考文章 Debian - Docker — 从入门到实践 (gitbook.io) Docker 安装 Wordpress 博客 - 腾讯云开发者社区-腾讯云 (tencent.com) Docker部署WordPress解决“上传的文件尺寸超过php.ini中定义的upload_max_filesize值”问题_neiro-DevPress官方社区 (csdn.net) let’s Encrypt 证书之安装故障 Could not bind to IPv4 or IPv6. - 料网 (liaosam.com) 基于Let\u0026rsquo;s Encrypt生成免费证书-支持多域名泛域名证书 - DevOps在路上 - 博客园 (cnblogs.com) Docker Compose-菜鸟教程 (runoob.com) Nginx配置文件详解 - 程序员自由之路 - 博客园 (cnblogs.com) Docker使用acme.sh申请ssl证书 – 萌精灵 (moeelf.com) docker安装nginx并配置ssl证书，代理宿主机服务 ","date":"2023-04-04T22:31:45+08:00","permalink":"https://blog.yexca.net/archives/102/","title":"服务器用 Docker 部署记录"},{"content":"软件工程系列文章六\n软件质量是指反映软件系统或软件产品满足规定或隐含需求的能力的特征和特性全体\n软件质量管理是指对软件开发过程进行独立的检查活动，由质量保证、质量规划和质量控制 3 个主要活动构成\n软件质量保证是指为了保证软件系统或软件产品充分满足用户要求的质量而进行的有计划、有组织的活动，其目的是生产高质量的软件\n软件质量特性 讨论软件质量首先要了解软件的质量特性，目前已经有多种软件质量模型来描述软件质量特性，例如 ISO/IEC 9126 软件质量模型和 Mc Call 软件质量模型\nISO/IEC 9126 软件质量模型 ISO/IEC 9126 软件质量模型由 3 个层次组成：第一层是质量特性，第二层是质量子特性，第三层是度量指标\n功能性 (Functionality) 与一组功能及其指定的性质的存在有关的一组属性，功能是指满足规定或隐含需求的那些功能\n适应性 (Suitability) 。与对规定任务能否提供一组功能以及这组功能是否适合有关的软件属性 准确性 (Accurateness) 。与能够得到正确或相符的结果或效果有关的软件属性 互用性 (Interoperability) 。与其他指定系统进行交互操作的能力相关的软件属性 依从性 (Compliance) 。使软件服从有关的标准、约定、法规及类似规定的软件属性 安全性 (Security) 。与避免对程序及数据的非授权故意或意外访问的能力有关的软件属性 可靠性 (Reliability) 与在规定的一段时间内和规定的条件下软件维持在其性能水平有关的能力\n成熟性 (Maturity) 。与由软件故障引起失效的频度有关的软件属性 容错性 (Fault tolerance) 。与在软件错误或违反指定接口的情况下维持指定的性能水平的能力有关的软件属性 易恢复性 (Recoverability) 。与在故障发生后，重新建立其性能水平并恢复直接受影响数据的能力，以及为达到此目的所需的时间和努力有关的软件属性 易使用性 (Usability) 与为使用所需的努力和由一组规定或隐含的用户对这样使用所做的个别评价有关的一组属性\n易理解性 (Understandability) 。与用户为理解逻辑概念及其应用所付出的劳动有关的软件属性 易学性 (Learnability) 。与用户为学习其应用 (例如操作控制、输入、输出) 所付出的努力相关的软件属性 易操作性 (Operability) 。与用户为进行操作和操作控制所付出的努力有关的软件属性 效率 (Efficiency) 在规定条件下，与软件的性能水平与所用资源量之间的关系有关的软件属性\n时间特性 (Time behavior) 。与响应和处理时间以及软件执行其功能时的吞吐量有关的软件属性 资源特性 (Resource behavior) 。与软件执行其功能时，所使用的资源量以及使用资源的持续时间有关的软件属性 可维护性 (Maintainability) 与进行规定的修改所需要的努力有关的一组属性\n易分析性 (Analyzability) 。与为诊断缺陷或失效原因，或为判定待修改的部分所需努力有关的软件属性 易改变性 (Changeability) 。与进行修改、排错或适应环境变换所需努力有关的软件属性 稳定性 (Stability) 。与修改造成未预料效果的风险有关的软件属性 易测试性 (Testability) 。为确认经修改软件所需努力有关的软件属性 可移植性 (Portability) 与软件可从某一环境转移到另一环境的能力有关的一组属性\n适应性 (Adaptability) 。与软件转移到不同环境时的处理或手段有关的软件属性 易安装性 (Installability) 。与在指定环境下安装软件所需努力有关的软件属性 一致性 (Conformance) 。使软件服从与可移植性有关的标准或约定的软件属性 易替换性 (Replaceability) 。与一软件在该软件环境中用来替代指定的其他软件的可能和努力有关的软件属性 Mc Call 软件质量模型 Mc Call 软件质量模型从软件产品的运行、修正和转移 3 个方面确定了 11 个质量特性\nMc Call 也给出了一个三层模型框架。第一层是质量特性，第二层是评价准则，第三层是度量指标\n软件评审 通常，把 \u0026ldquo;质量\u0026rdquo; 理解为 \u0026ldquo;用户满意程度\u0026rdquo; 。为了使得用户满意，有以下两个必要条件\n设计的规格说明书符合用户的要求，这称为设计质量 程序按照设计规格说明所规定的情况正确执行，这称为程序质量 设计质量的评审内容 设计质量评审的对象是在需求分析阶段产生的软件需求规格说明、数据需求规格说明，以及在软件概要设计阶段产生的软件概要设计说明书等。通常从以下几个方面进行评审\n评价软件的规格说明是否合乎用户的要求，即总体设计思想和设计方针是否明确；需求规格说明是否得到了用户或单位上级机关的批准；需求规格说明与软件的概要设计规格说明是否一致等 评审可靠性，即是否能避免输入异常 (错误或超载等) 、硬件失效及软件失效所产生的失效，一旦发生应能及时采取代替手段或恢复手段 评审保密措施实现情况，即是否对系统使用资格进行检查 评审操作特性实施情况，即操作命令和操作信息的恰当性；输入数据与输入控制语句的恰当性；输出数据的恰当性；应答时间的恰当性等 评审性能实现情况，即是否达到所规定性能的目标值 评审软件是否具有可修改性、可扩充性、可互换性和可移植性 评审软件是否具有可测试性 评审软件是否具有复用性 程序质量的评审内容 程序质量评审通常是从开发者的角度进行评审，与开发技术直接相关。它是着眼于软件本身的结构、与运行环境的接口以及变更带来的影响而进行的评审活动\n软件的结构如下\n功能结构。需要检查的项目： 数据结构 功能结构 数据结构和功能结构之间的对应关系 功能的通用性 模块的层次 模块结构。模块层次结构是模块的静态结构，现在要检查模块的动态结构。模块分为处理模块和数据模块两类，模块间的动态结构也与这些模块分类有关。对这样的模块结构进行检查的项目如下 控制流结构 数据流结构 模块结构与功能结构之间的对应关系 处理过程的结构 与运行环境的接口 运行环境包括硬件、其他软件和用户，主要的检查项目如下\n与硬件的接口。包括与硬件的接口约定，即根据硬件的使用说明等所做出的规定；硬件故障时的处理和超载时的处理 与用户的接口。包括与用户的接口约定，即输入数据的结构；输出数据的结构；异常输入时的处理，超载输入时的处理；用户存取资格的检查等 软件容错技术 提高软件质量和可靠性的技术大致可分为两类，一类是避开错误，即在开发的过程中不让差错潜入软件的技术；另一类是容错技术，即对某些无法避开的差错，使其影响减至最小的技术\n容错软件的定义 规定功能的软件，在一定程度上对自身错误的作用 (软件错误) 具有屏蔽能力，则该软件为容错软件 规定功能的软件，在一定程度上能从错误状态自动恢复到正常状态，则该软件为容错软件 规定功能的软件，在因错误发生错误时仍然能在一定程度上完成预期的功能，则该软件为容错软件 规定功能的软件，在一定程度上具有容错能力，则该软件为容错软件 容错的一般方法 实现容错的主要手段是冗余。冗余是指对于实现系统规定功能是多余的那部分资源，包括硬件、软件、信息和时间。由于加入了这些资源，有可能使系统的可靠性得到较大的提高。通常，冗余技术分为 4 类\n结构冗余。结构冗余是通常采用的冗余技术，按其工作方法可以分为静态、动态和混合冗余 3 种 静态冗余 动态冗余 混合冗余 信息冗余。为检测或纠正信息在运算或传输中的错误需外加一部分信息 时间冗余。指以重复执行指令或程序来消除瞬时错误带来的影响 冗余附加技术。指为实现上述冗余技术所需的资源和技术，包括程序、指令、数据、存放和调动它们的空间和通道等 在屏蔽硬件错误的容错技术中，冗余附加技术包括：\n关键程序和数据的冗余存储及调用 检测、表决、切换、重构、纠错和复算的实现 在屏蔽软件错误的容错系统中，冗余附加技术的构成包括：\n冗余备份程序的存储及调用 实现错误检测和错误恢复的程序 实现容错软件所需的固化程序 软件工具 用来辅助软件开发、运行、维护、管理和支持等过程中的活动的软件称为软件工具\n软件开发工具 对应于软件开发过程的各种活动，软件开发工具通常有需求分析工具、设计工具、编码与排错工具、测试工具等\n软件维护工具 辅助软件维护过程中活动的软件称为软件维护工具，它辅助维护人员对软件代码及其文档进行各种维护活动。软件维护工具主要有版本控制工具、文档分析工具、开发信息库工具、逆向工程工具和再工程工具\n","date":"2023-04-03T19:59:00+08:00","permalink":"https://blog.yexca.net/archives/101/","title":"软件工程-软件质量与软件工具"},{"content":"软件工程系列文章五\n软件项目的成功率非常低的原因可能就是项目管理能力太弱。由于软件本身的特殊性及复杂性，将项目管理思想引入软件工程领域，就形成了软件项目管理\n软件项目管理涉及的范围 有效的软件项目管理集中在 4 个 P 上，即人员 (Person) 、产品 (Product) 、过程 (Procedure) 和项目 (Project)\n软件项目估算 软件项目估算涉及人、技术、环境等多种因素，因此，需要一些方法和技术来支持项目的估算，常用的估算方法有下列 3 种\n基于已经完成的类似项目进行估算 基于分解技术进行估算 基于经验估算模型的估算。典型的有 IBM 估算模型、CoCoMo 模型和 Putnam 模型 上述方法可以组合使用，以提高估算的精度\nCOCOMO 估算模型 COCOMO 模型是一种精确的、易于使用的成本估算模型。COCOMO 模型按其详细程度分为基本 COCOMO 模型、中级 COCOMO 模型和详细 COCOMO 模型\n基本 COCOMO 模型 基本 COCOMO 模型是一个静态单变量模型，用于对整个软件系统进行估算\n其公式如下：\nE=a(L)b D=cEd 其中，E 表示工作量，单位是人月；D 表示开发时间，单位是月；L 是项目的源代码行估计值，不包括程序中的注释及文档，其单位是千行代码；a、b、c、d 是常数\n基本 COCOMO 模型可通过估算代码行的值 L，然后计算开发工作量和开发时间的估算值\n中级 COCOMO 模型 中间 COCOMO 模型是一个静态多变量模型，它将软件系统模型分为系统和部件两个层次，系统由部件构成，它把软件开发所需的人力 (成本) 看作是程序大小和一系列 \u0026ldquo;成本驱动属性\u0026rdquo; 的函数\n中级 COCOMO 模型以基本 COCOMO 模型为基础，并考虑了 15 种影响软件工作量的因素，通过工作量调节因子 (EAF) 修正对工作量的估算，从而使估算更合理\n其公式如下：\nE=a(L)bEAF 其中，L 是软件产品的目标代码行数，单位是千行代码数；a、b 是常数\n详细 COCOMO 模型 它将软件系统模型分为系统、子系统和模块 3 个层次，除包括中级模型所考虑的因素外，还考虑了在需求分析、软件设计等进一步的成本驱动属性的影响\nCOCOMOII 模型 最初的 COCOMO 模型是得到产业界最广泛应用和讨论的软件成本估算模型之一，现在它已经演化成更全面的估算模型，称为 COCOMOII。和其前身一样，COCOMOII 也是一种层次结构的估算模型，被分为 3 个阶段性模型\n应用组装模型。在软件工程的前期阶段使用，这时用户界面的原型开发、对软件和系统交互的考虑、性能的评估以及技术成熟度的评价是最重要的 早期设计阶段模型。在需求已经稳定并且基本的软件体系结构已经建立时使用 体系结构阶段模型。在软件的构造过程中使用 和所有的软件估算模型一样，COCOMOII 模型也需要使用规模估算信息，在模型层次结构中有 3 中不同的规模估算选择：对象点、功能点和代码行。应用组装模型使用的是对象点；早期设计阶段模型使用的是功能点，功能点可以转换为代码行\n进度管理 软件项目进度管理的目的是确保软件项目在规定的时间内按期完成\n进度管理的基本原则 划分 相互依赖性 时间分配 工作量确认 确定责任 明确输出结果 确定里程碑 进度安排 进度安排的常用图形描述方法有 Gantt 图 (甘特图) 和项目计划评审技术 (Program Evaluation \u0026amp; Review Technique, PERT) 图\nGantt 图 Gantt 图是一种简单的水平条形图，它以日历为基准描述项目任务。水平轴表示日历时间线 (如时、天、周、月和年等) ，每个条形表示一个任务，任务名称垂直地列在左边的列中，图中水平条的起点和终点对应水平轴上的时间，分别表示该任务的开始时间和结束时间，水平条的长度表示完成该任务所持续的时间。当日历中同一时段存在多个水平条时，表示任务之间的并发\nGantt 图能清晰地描述每个任务从何时开始，到何时结束，任务的进展情况以及各个任务之间的并行性。但是它不能清晰地反映出各任务之间的依赖关系，难以确定整个项目的关键所在，也不能反映计划中有潜力的部分\nPERT 图 PERT 图是一个有向图，图中的箭头表示任务，它可以标上完成该任务所需的时间。图中的结点表示流入结点的任务的结束，并开始流出结点的任务，这里把结点称为事件。只有当流入该结点的所有任务都结束时，结点所表示的事件才出现，流出结点的任务才可以开始。事件本身不消耗时间和资源，它仅表示某个时间点\n一个事件有一个事件号和出现该事件的最早时刻和最迟时刻。最早时刻表示在此时刻之前从该事件出发的任务不可能开始；最迟时刻表示从该事件出发的任务必须在此时刻之前开始，否则整个工程就不能如期完成。每个任务还可以有一个松弛时间 (Slack Time) ，表示在不影响整个工期的前提下完成该任务有多少机动余地\nPERT 图不仅给出了每个任务的开始时间、结束时间和完成该任务所需的时间，还给出了任务之间的关系，即哪些任务完成后才能开始另外一些任务，以及如期完成整个工程的关键路径。图中的松弛时间 (最迟时刻 - 最早时刻) 则反应了完成某些任务时可以推迟其开始时间或延长其所需完成的时间。但是，PERT 图不能反映任务之间的并行关系\n软件配置管理 软件配置管理其主要目标包括： 变更标识、变更控制、版本控制、确保变更正确的实现、变更报告\n软件配置管理其主要内容包括：版本管理、配置支持、变更支持、过程支持、团队支持、变化报告、审计支持\n或者：软件配置标识、变更管理、版本控制、系统建立、配置审核、配置状态报告\n配置数据库可以分为以下三类：\n开发库。专供开发人员使用，其中的信息可能做频繁修改，对其控制相对宽松 受控库。在生存期某一阶段工作结束时发布的阶段产品，这些是与软件开发工作相关的计算机可读信息和人工可读信息。软件配置管理正是对受控库中的各个软件项进行管理，受控库也称为软件配置库 产品库。在开发的软件产品完成系统测试后，作为最终产品存入产品库，等待交付用户或现场安装 风险管理 一般认为软件风险包含两个特性：不确定性和损失。不确定性是指风险可能发生也可能不发生；损失是指如果风险发生，就会产生恶性后果。在进行风险分析时，重要的是量化每个风险的不确定程度和损失程度。为了实现这一点，必须考虑不同类型的风险\n项目风险威胁到项目计划。也就是说，如果项目风险发生，就有可能拖延项目的进度和增加项目成本。项目风险是指预算、进度、人员 (聘用职员及组织) 、资源、利益相关者、需求等方面的潜在问题以及它们对软件项目的影响。项目复杂度、规模及结构不确定性也属于项目风险因素\n技术风险威胁到要开发软件的质量及交付时间。如果技术风险发生，开发工作就可能变得很困难或根本不可能，技术风险是指设计、实现、接口、验证和维护等方面的潜在问题。此外，规格说明的歧义性、技术的不确定性、技术陈旧以及 \u0026ldquo;前沿\u0026rdquo; 技术也是技术风险因素。技术风险地发生是因为问题比我们所设想地更加难以解决\n商业风险威胁到要开发软件地生存能力，且常常会危害到项目或产品。5 个主要的商业风险如下：\n市场风险。开发了一个没有人真正需要的优良产品 策略风险。开发的产品不再符合公司的整体商业策略 销售风险。开发了一个销售部门不知道如何去销售的产品 管理风险。由于重点的转移或人员的变动而失去了高级管理层的支持 预算风险。没有得到预算或人员的保证 (一) 风险识别 风险识别试图系统化地指出对项目计划 (估算、进度、资源分配等) 地威胁。识别出已知风险和可预测风险后，项目管理者首先要做的是在可能时回避这些风险，在必要时控制这些风险\n识别风险的一种方法是建立风险条目检查表。该检查表可用于风险识别，并且主要用来识别下列几种类型中的一些已知风险和可预测风险\n产品规模。与要开发或要修改的软件的总体规模相关的风险 商业影响。与管理者或市场所施加的约束相关的风险 客户特性。与客户的素质以及开发者和客户定期沟通的能力相关的风险 过程定义。与软件过程定义的程度以及该过程被开发组织遵守的程度相关的风险 开发环境。与用来开发产品的工具的可得性及质量相关的风险 开发技术。与待开发软件的复杂性及系统所包含技术的 \u0026ldquo;新奇性\u0026rdquo; 相关的风险 人员才干及经验。与软件工程师的总体技术水平及项目经验相关的风险 风险条目检查表可以采用不同的方式来组织。与上述每个主题相关的问题可以针对每一个软件项目来回答。根据这些问题的答案，项目管理者就可以估计风险产生的影响\n当然，也可以采用另一种风险条目检查表格式，即仅仅列出与每一种类型有关的特性，最终给出一组风险因素和驱动因子以及它们发生的概率。风险因素包括性能、成本、支持和进度。风险因素是以如下方式定义的：\n性能风险。产品能够满足需求且符合其使用目的的不确定程度 成本风险。能够维持项目预算的不确定程度 支持风险。开发出的软件易于纠错、修改及升级的不确定程度 进度风险。能够维持项目进度且按时交付产品的不确定程度 (二) 风险预测 风险预测又称风险估计，它试图从两个方面评估一个风险：风险发生的可能性或概率；如果风险发生了所产生的后果\n(1) 风险预测活动 通常，项目计划人员与管理人员、技术人员一起进行以下 4 步风险预测活动\n建立一个尺度或标准，以反映风险发生的可能性 描述风险产生的后果 估算风险对项目和产品的影响 标注风险预测的整体精确度，以免产生误解 一种简单的风险预测技术是建立风险表。风险表的第 1 列列出所有的风险 (由风险识别活动得到) ，第 2-4 列列出每个风险的种类、发生的概率以及所产生的影响。风险所产生的影响可用一个数字来表示：\u0026ldquo;1\u0026rdquo; 表示灾难性的；\u0026ldquo;2\u0026rdquo; 表示严重的；\u0026ldquo;3\u0026rdquo; 表示轻微的；\u0026ldquo;4\u0026rdquo; 表示可忽略的\n(2) 评估风险影响 如果风险真的发生，有 3 个因素可能会影响风险所产生的后果，即风险的本质、范围和时间。风险的本质是指当风险发生时可能会带来的问题。例如，一个定义很差的与客户硬件的外部接口 (技术风险) 会妨碍早期的设计和测试，也有可能导致项目后期阶段的系统集成问题。风险的范围包括风险的严重性 (即风险有多严重) 及风险的整体分布情况 (即项目中有多少部分受到影响或有多少客户受到损害) 。风险的时间是指何时能够感受到风险的影响及风险的影响会持续多长时间。在大多数情况下，项目管理者希望 \u0026ldquo;坏消息\u0026rdquo; 越早出现越好，但在某些情况下则是越迟越好\n整体的风险显露度 (Risk Exposure, RE) 可由下面的关系确定：\nRE=P×C 其中，P 是风险发生的概率，C 是风险发生时带来的项目成本\n(三) 风险评估 在进行风险评估时，建立了如下形式的三元组：\n(Ri, li, xi) 其中，ri 表示风险，li 表示风险发生的概率，xi 表示风险产生的影响\n一种对风险评估很有用的技术就是定义风险参考水准。对于大多数软件项目来说，成本、进度和性能就是 3 种典型的风险参照水准。也就是说，对于成本超支、进度延期、性能降低 (或它们的某种组合) ，有一个表明导致项目终止的水准\n在风险评估过程中，需要执行以下 4 个步骤\n定义项目的风险参考水平值 建立每一组 (Ri, li, xi) 与每一个参考水平值之间的关系 预测一组临界点以定义项目终止区域，该区域由一条曲线或不确定区域所界定 预测什么样的风险组合会影响参考水平值 (四) 风险控制 风险控制的目的是辅助项目组建立处理风险的策略。一个有效的策略必须考虑以下 3 个问题\n(1) 风险避免 应对风险的最好方法是主动地避免风险，即在风险发生前分析引起风险的原因，然后采取措施，以避免风险的发生\n例如项目风险 ri 表示 \u0026ldquo;频繁的人员流动\u0026rdquo;，根据历史经验可知，该风险发生的概率 li 大约为 70%，该风险产生的影响 xi 是第 2 级 (严重的) 。为了避免该风险，可以采取以下策略\n与现有人员一起探讨人员流动原因 (如恶劣的工作条件、低报酬、竞争激烈的劳动力市场等) 在项目开始之前采取行动，设法缓解那些能够控制的起因 项目启动之后，假设会发生人员流动，当有人员离开时，找到能够保证工作连续性的方法 组织项目团队，使得每一个开发活动的信息都能被广泛传播和交流 制定工作产品标准，并建立相应机制以确保能够及时创建所有的模型和文档 同等对待所有工作的评审 给每一个关键的技术人员都指定一个后背人员 (2) 风险监控 项目管理者应监控某些因素，这些因素可以提供风险是否正在变高或变低的指示。在频繁的人员流动的例子中，应该监测团队成员对项目压力的普遍态度、团队的凝聚力、团队成员彼此之间的关系、与报酬和利益相关的潜在问题、在公司内及公司外工作的可能性\n(3) RMMM 计划 风险管理策略可以包含在软件项目计划中，或者风险管理步骤也可以组织成一个独立的风险缓解、监控和管理计划 (RMMM 计划) 。RMMM 计划将所有风险分析工作文档化，并由项目管理者作为整个项目计划中的一部分来使用\n建立了 RMMM 计划，而且项目已经启动之后，风险缓解及检测步骤也就开始了。风险缓解是一种问题规避活动，而风险检测是一种项目跟踪活动，这种监测活动有 3 个主要目的；评估所预测的风险是否真的发生了；保证正确地实施了个风险的缓解步骤；收集能够用于今后风险缝隙的信息。在很多情况下，项目中发生的问题可以追溯到不止一个风险，所以风险监测的另一个任务就是试图找到 \u0026ldquo;起源\u0026rdquo; (在整个项目中是哪些风险引起了哪些问题)\n","date":"2023-04-02T06:58:00+08:00","permalink":"https://blog.yexca.net/archives/100/","title":"软件工程-软件项目管理"},{"content":"软件工程系列文章四\n软件维护是软件生命周期的最后一个阶段，处于系统投入生产性运行之后的时期中，因此不属于系统开发过程。软件维护是在软件已经交付使用之后为了改正错误或满足新的需求而修改软件的过程，即软件在交付使用后对软件所做的一切改动\n系统可维护性概念 系统的可维护性可以定义为维护人员理解、改正、改动和改进这个软件的难易程度。提高可维护性是开发软件系统所有步骤的关键目的，系统是否能被很好地维护，可以用系统的可维护性这一指标来衡量\n系统可维护指标 可理解性。指别人能理解系统的结构、界面、功能和内部过程的难易程度。模块化、详细设计文档、结构化设计和良好的高级程序设计语言等都有助于提高可理解性 可测试性。诊断和测试的容易程度取决于易理解的程度。好的文档资料有利于诊断和测试，同时，程序的结构、高性能的测试工具以及周密计划的测试工序也是至关重要的。为此，开发人员在系统设计和编程阶段就应尽力把程序设计成易诊断和测试的。此外，在进行系统维护时，应该充分利用在系统测试阶段保存下来的测试用例 可修改性。诊断和测试的容易程度与系统设计所制定的设计原则有直接关系。模块的耦合、内聚、作用范围与控制范围的关系等都对可修改性有影响 维护与软件文档 文档是软件可维护性的决定因素。由于长期使用的大型软件系统在使用过程中必然会经受多次修改，所以文档显得非常重要\n软件系统的文档可以分为用户文档和系统文档两类。用户文档主要描述系统功能和使用方法，并不关心这些功能是怎样实现的；系统文档描述系统设计、实现和测试等各方面的内容\n可维护性是所有软件都应具有的基本特点，必须在开发阶段保证软件具有可维护性的特点。在软件工程的每一个阶段都应考虑并提高软件的可维护性，在每个阶段结束前的技术审查和管理复查中应该着重对可维护性进行复审\n软件文档 编写高质量文档可以提高软件开发的质量\n文档也是软件的一部分，没有文档的软件就不能称之为软件\n软件文档的编制在软件开发工作中占有突出的地位和相当大的工作量，高质量的文档对于软件产品的效益有着重要的意义\n系统维护的内容及类型 系统维护主要包括硬件维护、软件维护和数据维护\n硬件维护 硬件维护应由专职的硬件维护人员来负责\n软件维护 软件维护主要是根据需求变化或硬件环境的变化对应用程序进行部分或全部修改。修改时充分利用源程序，修改后要填写程序修改登记表，并在程序变更通知书上写明新旧程序的不同之处\n软件维护的内容一般有以下几个方面\n正确性维护。指改正在系统开发阶段已发现而系统测试阶段尚未发现的错误 适应性维护。指使应用软件适应信息技术变化和管理需求变化而进行的修改 完善性维护。是为扩充功能和改善性能而进行的修改，主要是指对已有的软件系统增加一些在系统分析和设计阶段中没有规定的功能与性能特征 预防性维护。为了改进应用软件的可靠性和可维护性，为了适应未来的软硬件环境的变化，应主动增加预防性的新的功能，以使应用系统适应各类变化而不被淘汰 数据维护 数据维护工作主要是由数据库管理员来负责，主要负责数据库的安全性和完整性以及进行并发性控制\n软件的质量属性 可靠性、可用性和可维护性是软件的质量属性，软件工程中，用 0-1 之间的数来度量\n可靠性是指一个系统对于给定的时间间隔内、在给定条件下无失效运作的概率。可以用 MTTF/(1+MTTF) 来度量，其中 MTTF 为平均无故障时间\n可用性是在给定的时间点上，一个系统能够按照规格说明正确运作的概率。可以用 MTBF/(1+MTBF) 来度量，其中 MTBF 为平均失效间隔时间\n可维护性是在给定的使用条件下，在规定的时间间隔内，使用规定的过程和资源完成维护活动的概率。可以用 1/(1+MTTR) 来度量，其中 MTTR 为平均修复时间\n","date":"2023-03-31T07:57:00+08:00","permalink":"https://blog.yexca.net/archives/99/","title":"软件工程-系统维护概述"},{"content":"软件工程系列文章三\n系统测试的意义、目的及原则 系统测试是为了发现错误而执行程序的过程，成功的测试是发现了至今尚未发现的错误的测试\n测试的目的就是希望能以最少的人力和时间发现潜在的各种错误和缺陷。用户应根据开发各阶段的需求、设计等文档或程序的内部结构精心设计测试用例，并利用这些实例来运行程序，以便发现错误的过程\n信息系统测试应包括软件测试、硬件测试和网络测试。硬件测试、网络测试可以根据具体的性能指标进行，此处所说的测试更多的是指软件测试\n系统测试是保证系统质量和可靠性的关键步骤，是对系统开发过程中的系统分析、系统设计和实施的最后复查。根据测试的概念和目的，在进行信息系统测试时应遵循以下基本原则\n应尽早并不断地进行测试。测试不是在应用系统开发完之后才进行的。由于原始问题的复杂性、开发各阶段的多样性以及参加人员之间的协调等因素，使得在开发的各个阶段都有可能出现错误。因此，测试应贯穿在开发的各个阶段，应尽早纠正错误，消除隐患 测试工作应该避免由原开发软件的人或小组承担，一方面，开发人员往往不愿否认自己的工作，总认为自己开发的软件没有错误；另一方面，开发人员的错误很难由本人测试出来，很容易根据自己编程的思路来制定测试思路，具有局限性，测试工作应由专门人员来进行，这样会更客观、更有效 在设计测试方案时，不仅要确定输入数据，而且要根据系统功能确定预期输出结果。将实际输出结果与预期结果相比较就能发现测试对象是否正确 在设计测试用例时，不仅要设计有效、合理的输入条件，也要包含不合理、失效的输入条件。在测试的时候，人们往往习惯按照合理的、正确的情况进行测试，而忽略了对异常、不合理、意想不到的情况进行测试，而这可能就是隐患 在测试程序时，不仅要检验程序是否做了该做的事，还要检验程序是否做了不该做的事。多余的工作会带来副作用，影响程序的效率，有时会带来潜在的危害或错误 严格按照测试计划来进行，避免测试的随意性。测试计划应包括测试内容、进度安排、人员安排、测试环境、测试工具和测试资料等。严格地按照测试计划可以保证进度，使各方面都得以协调进行 妥善保存测试计划、测试用例，作为软件文档地组成部分，为维护提供方便 测试例子都是精心设计出来的，可以为重新测试或追加测试提供方便。当纠正错误、系统功能扩充后，都需要重新开始测试，而这些工作的重复性很高，可以利用以前的测试用例或在其基础上修改，然后进行测试 系统测试阶段的测试目标来自于需求分析阶段\n传统软件的测试策略 有效的软件测试实际上分为 4 步进行，即单元测试、集成测试、确认测试和系统测试\n(一) 单元测试 单元测试也称为模块测试，在模块编写完成且无编译错误后就可以进行。单元测试侧重于模块中的内部处理逻辑和数据结构。如果选用机器测试，一般用白盒测试法。这类测试可以对多个模块同时进行\n(1) 单元测试的测试内容 单元测试主要检查模块的以下 5 个特征\n模块接口。模块的接口保证了测试模块的数据流可以正确地流入、流出。在测试中应检查以下要点： 测试模块的输入参数和形式参数在个数、属性、单位上是否一致 调用其他模块时，所给出的实际参数和被调用模块的形式参数在个数、属性、单位上是否一致 调用标准函数时，所用的参数在属性、数目和顺序上是否正确 全局变量在各模块中的定义和用法是否一致 输入是否仅改变了形式参数 开/关的语句是否正确 规定的 I/O 格式是否与输入/输出语句一致 在使用文件之前是否已经打开文件或使用文件之后是否已经关闭文件 局部数据结构。在单元测试中，局部数据结构出错是比较常见的错误，在测试时应重点考虑以下因素 变量的说明是否合适 是否使用了尚未赋值或尚未初始化的变量 变量的初始值或默认值是否正确 变量名是否有错 (例如拼写错) 重要的执行路径。在单元测试中，对路径的测试是最基本的任务。由于不能进行穷举测试，需要精心设计测试例子来发现是否有计算、比较或控制流等方面的错误 计算方面的错误。算术运算的优先次序不正确或理解错误；精度不够；运算对象的类型彼此不相容；算法错；表达式的符号表示不正确 比较和控制流的错误。本应相等的量由于精度造成不相等；不同类型进行比较；逻辑运算符不正确或优先次序错误；循环终止不正确 (如多循环一次或少循环一次) 、死循环；不恰当地修改循环变量；当遇到分支循环时出口错误等 出错处理。好的设计应该能预测到出错的条件并且有对出错处理的路径。虽然计算机可以显示出错信息的内容，但仍需要程序员对出错进行处理，保证其逻辑的正确性，以便于用户维护 边界条件。边界条件的测试是单元测试的最后工作，也是非常重要的工作。软件容易在边界出现错误 (2) 单元测试过程 由于模块不是独立运行的程序，各模块之间存在调用与被调用的关系。在对每个模块进行测试时，需要开发两种模块\n驱动模块。相当于一个主程序，接受测试例子的数据，将这些数据送到测试模块，输出测试结果 桩模块 (也称为存根模块) 。桩模块用来代替测试模块中所调用的子模块，其内部可进行少量的数据处理，目的是为了检验入口，输出调用和返回的信息 提高模块的内聚度可以简化单元测试。如果每个模块只完成一种功能，对于具体模块来讲，所需的测试方案数据会显著减少，而且更容易发现和预测模块中的错误\n(二)集成测试 集成测试就是把模块按系统设计说明书的要求组合起来进行测试。即使所有的模块都通过了测试，在集成之后，仍然可能出现问题\n通常，集成测试有两种方法：一种是非增量集成，分别测试各个模块，再把这些模块组合起来整体测试；另一种是增量集成，即以小增量的方式逐步进行构造和测试\n下面是一些增量集成策略\n(1) 自顶向下集成测试 自顶向下集成测试是一种构造软件体系结构的增量方法。模型的集成顺序为从主控模块 (主程序) 开始，沿着控制层次逐步向下，以深度优先或广度优先的方式将从属于 (或间接从属于) 主控模块的模块集成到结构中\n深度优先集成是首先集成位于程序结构中主控路径上的所有构件，也可以根据特定应用系统的特征进行选择\n主控模块用作测试驱动模块，用这些从属于主控模块的所有模块代替桩模块 依赖所选择的集成方法 (即深度优先或广度优先) ，每次用实际模块替换一个从属桩模块 在集成每个模块后都进行测试 在完成每个测试集之后，用实际模块替换另一个桩模块 可以执行回归测试，以确保没有引入新的错误 回到第 2 步继续执行此过程，直到完成了整个程序结构的构造 不用编写驱动模块，需要编写桩模块\n(2) 自底向上集成测试 自底向上集成测试就是从原子模块 (程序结构的最底层构件) 开始进行构造和测试。由于构件是自底向上集成的，在处理时所需要的从属于给定层次的模块总是存在的，因此，没有必要使用桩模块。自底向上集成策略可以利用以下步骤来实现\n连接底层构件以构成完成特定子功能的簇 编写驱动模块 (测试的控制程序) 以协调测试用例的输入和输出 测试簇 去掉驱动程序，沿着程序结构向上逐步连接簇 不需要编写桩模块，需要编写驱动模块\n(3) 回归测试 每当加入一个新模块作为集成测试的一部分时，软件发生变更，建立了新的数据流路径，可能出现新的 I/O，以及调用新的控制逻辑。这些变更可能会使原来可以正常工作的功能产生问题。在集成测试策略的环境下，回归测试是重新执行已测试过的某些子集，以确保变更没有传播不期望的副作用\n回归测试有助于保证变更不引入无意识行为或额外的错误。回归测试可以手工进行，方法是重新执行所有测试用例的子集，或者利用捕捉/回放工具自动执行。捕捉/回放工具使软件工程师能够为后续的回放与比较捕捉测试用例和测试结果。回归测试要执行的测试子集包含以下 3 种测试用例\n能够测试软件所有功能的具有代表性的测试样本 额外测试，侧重于可能会受变更影响的软件功能 侧重于已发生变更的软件构件测试 随着集成测试的进行，回归测试的数量可能变得相当庞大，因此，应将回归测试用例设计成只包括设计每个主要程序功能的一个或多个错误类的测试。一旦发生变更，对每个软件功能重新执行所有的测试是不切实际的，而且效率很低\n(4) 冒烟测试 当开发软件产品时，冒烟测试是一种常见的集成测试方法，是时间关键项目的决定性机制，它让软件团队频繁地对项目进行评估\n测试方法 在软件测试过程中，应该为定义软件测试模板，即将特定的测试方法和测试用例设计放在一系列的测试步骤中\n软件测试方法分为静态测试和动态测试\n静态测试。静态测试是指被测试程序不在机器上运行，而是采用人工检测和计算机辅助静态分析的手段对程序进行检测 人工检测。人工检测不依靠计算机而是依靠人工审查程序或评审软件，包括代码检查、静态结构分析和代码质量度量等 计算机辅助静态分析。利用静态分析工具对被测试程序进行特性分析，从程序中提取一些信息，以便检查程序逻辑的各种缺陷和可疑的程序构造 动态测试。动态测试是指通过运行程序发现错误。在对软件产品进行动态测试时可以采用黑盒测试法和白盒测试法 测试用例由测试输入数据和与之对应的预期输出结果组成。在设计测试用例时，应当包括合理的输入条件和不合理的输入条件\n(一) 黑盒测试 黑盒测试也称为功能测试，在完全不考虑软件的内部结构和特性的情况下，测试软件的外部特性\n常见的黑盒测试技术有等价类划分、边界值分析、错误推测和因果图等\n(1) 等价类划分 等价类划分将程序的输入域划分为若干等价类，然后从每个等价类中选取 一个代表性数据作为测试用例。每一类的代表性数据在测试中的作用等价于这一类中的其他值，这样就可以用少量代表性的测试用例取得较好的测试效果。等价类型划分有两种不同的情况：有效等价类和无效等价类。在设计测试用例时，要同时考虑这两种等价类\n(2) 边界值分析 输入的边界比中间更加容易发生错误，因此用边界值分析来补充等价类划分的测试用例设计技术。边界值划分选择等价类边界的测试用例，即注重于输入条件边界，又适用于输出域测试用例\n(3) 错误推测 错误推测是基于经验和直觉推测程序中所有可能存在的各种错误，从而有针对性地设计测试用例的方法。其基本思想是列举出程序中所有可能有的错误和容易发生错误的特殊情况，根据它们选择测试用例\n(4) 因果图 因果图法是从自然语言描述的程序规格说明中找出因 (输入条件) 和果 (输出或程序状态的改变) ，通过因果图转换为判定表\n(二) 白盒测试 白盒测试也称为结构测试，根据程序的内部结构和逻辑来设计测试用例，对程序的路径和过程进行测试，检查是否满足设计的需要\n白盒测试常用的技术是逻辑覆盖、循环覆盖和基本路径测试\n白盒测试的原则如下：\n程序模块中的所有独立路径至少执行一次 在所有的逻辑判定中，取 \u0026ldquo;真\u0026rdquo; 和取 \u0026ldquo;假\u0026rdquo; 的两种情况至少都能执行一次 每个循环都应在边界条件和一般条件下各执行一次 测试程序内部数据结构的有效性等 (1) 逻辑覆盖 逻辑覆盖考察用测试数据运行被测程序时对程序逻辑的覆盖程度，主要的逻辑覆盖标准有语句覆盖、判定覆盖、条件覆盖、判定/条件覆盖、条件组合覆盖和路径覆盖 6 种\n语句覆盖。语句覆盖是指选择足够的测试数据，使被测试程序中的每条语句至少执行一次。语句覆盖对程序执行逻辑的覆盖很低，因此一般认为它是很弱的逻辑覆盖 判定覆盖。判定覆盖是指设计足够的测试用例，使得被测程序中的每个判定表达式至少获得一次 \u0026ldquo;真\u0026rdquo; 值和 \u0026ldquo;假\u0026rdquo; 值，或者说是程序中的每一个取 \u0026ldquo;真\u0026rdquo; 分支和取 \u0026ldquo;假\u0026rdquo; 分支至少都通过一次，因此判定覆盖也称为分支覆盖。判定覆盖要比语句覆盖更强一些 条件覆盖。条件覆盖是指构造一组测试用例，使得每一判定语句中每个逻辑条件的各种可能的值至少满足一次 判定/条件覆盖。判定/条件覆盖是指设计足够的测试用例，使得判定中每个条件的所有可能取值 (真/假) 至少出现一次，并使每个判定本身的判定结果 (真/假) 也至少出现一次 条件组合覆盖。条件组合覆盖是指设计足够的测试用例，使得每个判定中条件的各种可能值的组合都至少出现一次。满足条件组合覆盖的测试用例是一定满足判定覆盖、条件覆盖和判定/条件覆盖的 路径覆盖。路径覆盖是指覆盖被测试程序中所有可能的路径 (2) 循环覆盖 执行足够的测试用例，使得循环中的每个条件都得到验证\n(3) 基本路径测试 基本路径测试法是在程序控制流图的基础上通过分析控制流图的环路复杂性，导出基本可执行路径集合，从而设计测试用例\n调试 调试发生在测试之后，其任务是根据测试时所发现的错误找出原因和具体的位置，进行改正\n常用的调试方法有以下几种\n(1) 试探法 调试人员分析错误的症状，猜测问题所在的位置，利用在程序中设置输出语句，分析寄存器、存储器的内容等手段获得错误的线索，一步步地试探和分析错误的所在\n(2) 回溯法 调试人员从发现错误症状的位置开始，人工沿着程序的控制流程往回跟踪代码，直到找出错误根源为止\n(3) 对分查找法 这种方法主要用来缩小错误的范围，如果已经知道程序中的变量在若干位置的正确取值，可以在这些位置上给这些变量以正确值，观察程序运行的输出结果，如果没有发现问题，则说明从赋予变量一个正确值开始到输出结果之间的程序没有错误，问题可能在除此之外的程序中。否则错误就在所考察的这部分程序中，对含有错误的程序段再使用这种方法，直到把故障范围缩小到比较容易诊断为止\n(4) 归纳法 归纳法就是从测试所暴露的问题出发，收集所有正确或不正确的数据，分析它们之间的关系，提出假想的错误原因，用这些数据来证明或反驳，从而查出错误所在\n(5) 演绎法 演绎法根据测试结果，列出所有可能的错误原因；分析已有的数据，排除不可能和彼此矛盾的原因；对其余的原因，选择可能性最大的，利用已有的数据完善该假设，使假设更具体；用假设来解释所有的原始测试结果，如果能解释这一切，则假设得以证实，也就找出错误\n","date":"2023-03-29T19:56:57+08:00","permalink":"https://blog.yexca.net/archives/98/","title":"软件工程-系统测试"},{"content":"软件工程系列文章二\n软件生存周期 可行性分析与项目开发计划 需求分析 概要设计 详细设计 编码 测试 维护 软件需求 在进行需求获取之前，首先要明确需要获取什么，也就是需求包含哪些内容。软件需求是指用户对目标软件系统在功能、行为、性能、设计约束等方面的期望\n功能需求。考虑系统要做什么，在何时做，在何时以及如何修改或升级 性能需求。考虑软件开发的技术性指标。例如，存储容量限制、执行速度、响应时间及吞吐量 用户或人的因素。考虑用户的类型。例如，各种用户对使用计算机的熟练程度，需要接受的训练，用户理解、使用系统的难度，用户错误操作系统的可能性等 环境需求。考虑未来软件应用的环境，包括硬件和软件。对硬件设备的需求包括机型、外设、接口、地点、分布、湿度、磁场干扰等；对软件的需求包括操作系统、网络、数据库等 界面需求。考虑来自其他系统的输入，到其他系统的输出，对数据格式的特殊规定，对数据存储介质的规定 文档需求。考虑需要哪些文档，文档针对哪些读者 数据需求。考虑输入、输出数据的格式，接收、发送数据的频率，数据的准确性和精度，数据流量，数据需保持的时间 资源使用需求。考虑软件运行时所需要的数据、其他软件、内存空间等资源；软件开发、维护所需的人力、支撑软件、开发设备等 安全保密要求。考虑是否需要对访问系统或系统信息加以控制，隔离用户数据的方法，用户程序如何与其他程序和操作系统隔离以及系统备份要求等 可靠性要求。考虑系统的可靠性要求，系统是否必须检测和隔离错误；出错后，重启系统允许的时间 软件成本消耗与开发进度需求。考虑开发是否有规定的时间表，软/硬件投资有无限制等 其他非功能性要求。如采用某种开发模式，确定质量控制标准、里程碑和评审、验收标准、各种质量要求的优先级等，以及可维护性方面的要求 系统设计 系统设计的主要目的就是为系统指定蓝图，在各种技术和实施方法中权衡利弊，精心设计，合理地使用各种资源，最终勾画出新系统的详细设计方案\n概要设计 开发人员把确定的各项功能需求转换成需要的体系结构\n1. 设计软件系统总体结构 其基本任务是采用某种设计方法，将一个复杂的系统按功能划分为模块；确定每个模块的功能；确定模块之间的调用关系；确定模块之间的接口，即模块之间传递的信息；评价模块结构的质量\n软件系统总体结构的设计是概要设计关键的一步，直接影响到下一个阶段详细设计与编码的工作。软件系统的质量及一些整体特性都在软件系统总体结构的设计中决定\n2. 数据结构及数据库设计 (1) 数据结构的设计 逐步细化的方法也适用于数据结构的设计。在需求分析阶段，已经通过数据字典对数据的组成、操作约束和数据之间的关系等方面进行了描述，确定了数据的结构特性，在概要设计阶段要加以细化，详细设计阶段则规定具体的实现细节。在概要设计阶段，宜使用抽象的数据类型\n(2) 数据库的设计 数据库的设计是指数据存储文件的设计，主要进行以下几方面设计\n概念设计。在数据分析的基础上，采用自底向上的方法从用户角度进行视图设计，一般用 E-R 模型来表述数据模型。E-R 模型既是设计数据库的基础，也是设计数据结构的基础 逻辑设计。E-R 模型是独立于数据库管理系统 (DBMS) 的，要结合具体的 DBMS 特征来建立数据库的逻辑结构 物理设计。对于不同的 DBMS，物理环境不同，提供的存储结构与存取方法各不相同。物理设计就是设计数据模式的一些物理细节，如数据项存储要求、存取方法和索引的建立等 3. 编写概要设计文档 文档主要有概要设计说明书、数据库设计说明书、用户手册以及修订测试计划\n4. 评审 对设计部分是否完整地实现了需求中规定的功能、性能等要求，设计方法的可行性，关键的处理及内外部接口定义的正确性、有效性、各部分之间的一致性等都一一进行评审\n详细设计 对每个模块进行详细的算法设计，用某种图形、表格和语言等工具将每个模块处理过程的详细算法描述出来 对模块内的数据结构进行设计 对数据库进行物理设计，即确定数据库的物理结构 其他设计。根据软件系统的类型，还可能要进行以下设计 代码设计。为了提高数据的输入、分类、存储和检索等操作，节约内存空间，对数据库中某些数据项的值要进行代码设计 输入/输出格式设计 用户界面设计 编写详细设计说明书 评审。对处理过程的算法和数据库的物理结构都要评审 系统设计的结果是一系列的系统设计文件，这些文件是物理实现一个信息系统 (包括硬件设备和编制软件程序) 的重要基础\n","date":"2023-03-29T17:04:45+08:00","permalink":"https://blog.yexca.net/archives/97/","title":"软件工程-需求分析与系统设计"},{"content":"软件工程系列文章一\n软件过程 软件开发的中所遵循的线路图称为 \u0026ldquo;软件过程\u0026rdquo;\n能力成熟度模型 (CMM) CMM 将软件过程改进分为以下 5 个成熟度级别\n初始级 (Initial) ​\t软件的特点是杂乱无章，有时甚至很混乱，几乎没有明确定义的步骤，项目的完成完全依赖个人的努力和英雄式核心人物的作用\n可重复级 (Repeatable) ​\t建立了基本的项目管理过程和实践来跟踪项目的费用、进度和功能特性，有必要的过程准则来重复以前在同类项目中的成功\n已定义级 (Defined) ​\t管理和工程两方面的软件过程已经文档化、标准化，并综合成整个软件开发组织的标准软件过程。所有项目都采用根据实际情况修改后得到的标准软件过程来开发和维护软件\n已管理级 (Managed) ​\t制定了软件过程和产品质量的详细度量标准。软件过程的产品质量都被开发组织的成员所理解和控制\n优化级 (Optimized) ​\t加强了定量分析，通过来自过程质量反馈和来自新观念、新技术的反馈使过程能不断持续地改进\nCMM 模型提供了一个框架，将软件过程改进的进化步骤组织成 5 个成熟度等级，为过程不断改进奠定了循序渐进的基础。这 5 个成熟度等级定义了一个有序的尺度，用来测量一个组织的软件过程成熟度和评价其软件过程能力\n能力成熟度模型集成 (CMMI) CMM 的成功导致了适用不同学科领域的模型的衍生，但一个工程常常涉及多个交叉学科，因此有必要将各种过程改进的工作集成起来。CMMI 是若干过程模型的综合和改进\nCMMI 提供了两种表示方法：阶段式模型和连续式模型\n1. 阶段式模型 阶段式模型的结构类似于 CMM，它关注组织的成熟度。CMMI-SE/SW/IPPD 1.1 版中有 5 个成熟度等级\n初始的：过程不可预测且缺乏控制 已管理的：过程为项目服务 已定义的：过程为组织服务 定量管理的：过程已度量和控制 优化的：集中于过程改进 2. 连续式模型 连续式模型关注每个过程域的能力，一个组织对不同的过程可以达到不同的过程域能力等级 (Capability Level, CL) 。CMMI 中包括 6 个过程域能力等级，等级号为 0~5。能力等级包括共性目标及相关的共性实践，这些实践在过程域内被添加到特定目标和实践中。当组织满足过程域的特定目标和共性目标时，就说该组织达到了那个过程域的能力等级\nCL0 (未完成的) ：过程域未执行或未得到 CL1 中定义的所有目标 CL1 (已执行的) ：其共性目标是过程将可标识的输入工作产品转换成可标识的输出工作产品，以实现支持过程域的特定目标 CL2 (已管理的) ：其共性目标集中于已管理的过程的制度化。根据组织级政策规定过程的运作将使用哪个过程，项目遵循已文档化的计划和过程描述，所有正在工作的人都有权使用足够的资源，所有工作任务和工作产品都被监控、控制和评审 CL3 (已定义级的) ：其共性目标集中于已定义的过程的制度化。过程是按照组织的剪裁指南从组织的标准过程集中剪裁得到的，还必须收集过程资产和过程的度量，并用于将来对过程的改进 CL4 (定量管理的) ：其共性目标集中于可定量管理的过程的制度化。使用测量和质量保证来控制和改进过程域，建立和使用关于质量和过程执行的定量目标作为管理准则 CL5 (优化的) ：使用量化 (统计学) 手段改变和优化过程域，以满足客户要求的改变和持续改进计划中的过程域的功效 软件过程模型 软件过程模型习惯上也称为软件开发模型，它是软件开发全部过程、活动和任务的结构框架。典型的软件过程模型有瀑布模型、增量模型、演化模型 (原型模型、螺旋模型) 、喷泉模型、基于构件的开发模型和形式化方法模型等\n瀑布模型 瀑布模型是将软件生存周期中的各个活动规定为依线性顺序连接的若干阶段的模型，包括需求分析、设计、编码、测试、运行与维护。它规定了由前至后、相互衔接的固定次序，如同瀑布流水逐级下落\n瀑布模型为软件的开发和维护提供了一种有效的管理模式，根据这一模式制定开发计划，进行成本预算，组织开发力量，以项目的阶段评审和文档控制为手段有效地对整个开发过程进行指导，所以它是以文档作为驱动、适合于软件需求很明确的软件项目的模型\n瀑布模型假设，一个待开发的系统需求是完整的、简明的、一致的，而且可以先于设计和实现完成之前产生\n瀑布模型的优点是，容易理解，管理成本低；强调开发的阶段性早期计划及需求调查和产品测试 不足之处是，客户必须能够完整、正确和清晰地表达他们的需要；在开始的两个或三个阶段中，很难评估真正的进度状态；当接近项目结束时，出现了大量的集成和测试工作；直到项目结束之前，都不能演示系统的能力 在瀑布模型中，需求或设计中的错误往往只有到了项目后期才能够被发现，对于项目风险的控制能力较弱，从而导致项目常常延期完成，开发费用超出预算\nV 模型 瀑布模型的一个变体是 V 模型\nV 模型描述了质量保证活动和沟通、建模相关活动以及早期构建相关的活动之间的关系。随着软件团队工作沿着 V 模型左侧步骤向下推进，基本问题需求逐步细化，形成问题及解决方案的技术描述。一旦编码结束，团队沿着 V 模型右侧的步骤向上推进工作，其实际上是执行了一系列测试 (质量保证活动) ，这些测试验证了团队沿着 V 模型左侧步骤向下推进过程中所生成的每个模型。V 模型提供了一种将验证确认活动应用于早期软件工程工作中的方法\n增量模型 增量模型融合了瀑布模型的基本成分和原型实现的迭代特征，它假设可以将需求分段为一系列增量产品，每一增量可以分别开发。该模型采用随着日程时间的进展而交错的线性序列，每一个线性序列产生软件的一个可发布的“增量”\n当使用增量模型时，第一个增量往往是核心的产品。客户对每个增量的使用和评估都作为下一个增量发布的新特征和功能，这个过程在每一个增量发布后不断重复，直到产生了最终的完善产品。增量模型强调每一个增量均发布一个可操作的产品\n增量模型作为瀑布模型的一个变体，具有瀑布模型的所有优点。此外，它还有以下优点：第一个可交付版本所需要的成本和时间很少；开发由增量表示的小系统所承担的风险不大；由于很快发布了第一个版本，因此可以减少用户需求的变更；运行增量投资，即在项目开始时，可以仅对一个或两个增量投资\n增量模型有以下不足之处：如果没有对用户的变更要求进行规划，那么产生的初始增量可能会造成后来增量的不稳定；如果需求不像早期思考的那样稳定和完整，那么一些增量就可能需要重新开发，重新发布；管理发生的成本、进度和配置的复杂性可能会超出组织的能力\n演化模型 软件类似于其他复杂的系统，会随着时间的推移而演化。在开发过程中，常常会面临以下情形：商业和产品需求经常变化，直接导致最终产品难以实现；严格的交付时间使得开发团队不可能圆满地完成软件产品，但是必须交付功能有限的版本以应对竞争或商业压力；很好地理解了核心产品和系统需求，但是产品或系统拓展的细节问题却没有定义。在上述情况和类似情况下，软件开发人员需要一种专门应对不断演变的软件产品的过程模型\n演化模型是迭代的过程模型，使得软件开发人员能够逐步开发出更完整的软件版本。演化模型特别适用于对软件需求缺乏准确认识的情况。典型的演化模型有原型模型和螺旋模型等\n原型模型 (Prototype Model) 并非所有的需求都能够预先定义，大量的实践表明，在开发初期很难得到一个完整的、准确的需求规格说明。这主要是由于客户往往不能准确地表达对未来系统地全面要求，开发者对要解决的应用问题模糊不清，以至于形成的需求规格说明常常是不完整的、不准确的，有时甚至是有歧义的。此外，在整个开发过程中，用户可能会产生新的要求，导致需求的变更。而瀑布模型难以适应这种需求的不确定性和变化，于是出现了快速原型 (Rapid Prototype) 这种新的开发方法。原型方法比较适合于用户需求不清、需求经常变化的情况。当系统规模不是很大也不太复杂时，采用该方法比较好\n原型是预期系统的一个可执行版本，反映了系统性质的一个选定的子集。一个原型不必满足目标软件的所有约束，其目的是能快速、低成本地构建原型。当然，能够采用原型方法是因为开发工具的快速发展，使得能够迅速地开发出一个让用户看得见、摸得着的系统框架。这样，对于计算机不是很熟悉的用户就可以根据这个框架提出自己的需求。开发原型系统首先确定用户需求，开发初始原型，然后征求用户对初始原型的改进意见，并根据意见修改原型\n原型模型开始于沟通，其目的是定义软件的总体目标，标识需求，然后快速制定原型开发的计划，确定原型的目标和范围，采用快速设计的方式对其进行建模，并构建原型。被开发的原型应交付给客户使用，并收集客户的反馈意见，这些反馈意见可在下一轮中对原型进行改进。在前一个原型需要改进，或者需要扩展其范围的时候，进入下一轮原型的迭代开发\n螺旋模型 对于复杂的大型软件，开发一个原型往往达不到要求。螺旋模型将瀑布模型和演化模型结合起来，加入了两种模型均忽略的风险分析，弥补了这两种模型的不足\n螺旋模型将开发过程分为几个螺旋周期，每个螺旋周期大致和瀑布模型相符合，每个螺旋周期分为如下 4 个工作步骤\n制定计划。确定软件的目标，选定实施方案，明确项目开发的限制条件 风险分析。分析所选的方案，识别风险，消除风险 实施工程。实施软件开发，验证阶段性产品 用户评估。评价开发工作，提出修正建议，建立下一个周期的开发计划 螺旋模型强调风险分析，使得开发人员和用户对每个演化层出现的风险有所了解，从而做出应有的反应。因此，该模型特别适用于庞大、复杂并且具有高风险的系统\n与瀑布模型相比，螺旋模型支持用户需求的动态变化，为用户参与软件开发的所有关键决策提供了方便，有助于提高软件的适应能力，并且为项目管理人员及时调整管理决策提供了便利，从而降低了软件开发的风险。在使用螺旋模型进行软件开发时，需要开发人员具有相当丰富的风险评估经验和专门知识。另外，过多的迭代次数会增加开发成本，延迟提交时间\n喷泉模型 喷泉模型是一种以用户需求为动力，以对象作为驱动的模型，适合于面向对象的开发方法。它克服了瀑布模型不支持软件重用和多项开发活动集成的局限性。喷泉模型使开发过程具有迭代性和无间隙性\n迭代意味着模型中的开发活动常常需要重复多次，在迭代过程中不断地完善软件系统，无间隙是指在开发活动 (如分析、设计、编码) 之间不存在明显地边界，也就是说，它不像瀑布模型那样，在需求分析活动结束后才开始设计活动，在设计活动结束后才开始编码活动，而是允许各开发活动交叉、迭代地进行\n喷泉模型的各个阶段没有明显的界限，开发人员可以同步进行。其优点是可以提高软件项目的开发效率，节省开发时间。由于喷泉模型在各个开发阶段是重叠的，在开发过程中需要大量的开发人员，不利于项目的管理。此外，这种模型要求严格管理文档，使得审核的难度加大\n统一过程 (UP) 模型 统一过程模型是一种“用例和风险驱动，以架构为中心，迭代并且增量”的开发过程，由 UML 方法和工具支持。迭代的意思是将整个软件开发项目划分为许多个小的“袖珍项目”，每个“袖珍项目”都包含正常软件项目的所有元素：计划、分析和设计、构造、集成和测试，以及内部和外部发布\n统一过程定义了 4 个技术阶段及其制品\n起始阶段 (Inception Phase)\n初始阶段专注于项目的初创活动，产生的主要工作产品有构想文档 (Vision Document) 、初始用例模型、初始项目术语表、初始业务用例、初始风险评估、项目计划 (阶段及迭代) 、业务模型以及一个或多个原型 (需要时)\n精化阶段 (Elaboration Phase)\n精化阶段在理解了最初的领域范围之后进行需求分析和架构演进，产生的主要工作产品有用例模型、补充需求、分析模型、软件体系结构描述等\n构建阶段 (Construction Phase)\n构建阶段关注系统的构建，产生实现模型，产生的主要工作产品有设计模型、软件构件、集成的软件增量、测试计划及步骤、测试用例以及支持文档\n移交阶段 (Transition Phase)\n移交阶段关注于软件提交方面的工作，产生软件增量，产生的主要工作产品有提交的软件增量、β 测试报告和综合用户反馈\n每次迭代产生包括最终系统的部分完成的版本和任何相关的项目文档的基线，通过逐步迭代基线之间相互构建，直到完成最终系统。在每个迭代中有 5 个核心工作流：\n捕获系统应该做什么的需求工作流 精化和结构化需求的分析工作流 在系统架构内实现需求的设计工作流 构造软件的实现工作流 验证实现是否如期望那样工作的测试工作流 随着 UP 的阶段进展，每个核心工作流的工作量发生了变化。4 个技术阶段由主要里程碑所终止\n初始阶段：生命周期目标 精化阶段：生命周期架构 构建阶段：初始运作功能 移交阶段：产品发布 统一过程的典型代表是 RUP (Rational Unified Process) 。RUP 是 UP 的商业扩展，完全兼容 UP，但比 UP 更完整、更详细\n敏捷方法 敏捷开发的总体目标是通过“尽可能早地、持续地对有价值的软件的交付”使客户满意。通过在软件开发过程中加入灵活性，敏捷方法 (Agile Development) 使用户能够在开发周期的后期增加或改变需求\n敏捷过程的典型方法有很多，每一种方法基于一套原则，这些原则实现了敏捷方法所宣称的理念 (敏捷宣言)\n1. 极限编程 (XP) XP 是一种轻量级 (敏捷) 、高效、低成本、柔性、可预测的、科学的软件开发方式。它由价值观、原则、实践和行为 4 个部分组成，彼此相互依赖、关联，并通过行为贯穿于整个生存周期\n4 大价值观：沟通、简单性、反馈和勇气 5 大原则：快速反馈、简单性假设、逐步修改、提倡修改和优质工作 12 个最佳实践 计划游戏 (快速制定计划、随着细节的不断变化而完善) 小型发布 (系统的设计要能够尽可能早地交付) 隐喻 (找到合适的比喻传达信息) 简单设计 (只处理当前的需求，使设计保持简单) 测试先行 (先写测试代码，然后再编写程序) 重构 (重新审视需求和设计，重新明确地描述它们以符合新的和现有的需求) 结对编程 集体代码所有制 持续集成 (可以按日甚至按小时为客户提供可运行的版本) 每周工作 40 个小时 现场客户 (系统最终用户代表应该全程配合 XP 团队) 编码标准 2. 水晶法 (Crystal) 水晶法认为每一个不同的项目都需要一套不同的策略、约定和方法论\n认为人对软件质量有重要的影响，因此随着项目质量和开发人员素质的提高，项目和过程的质量也随之提高。通过更好地交流和经常性的交付，软件生产力得到提高\n3. 并列争求法 (Scrum) 并列争求法使用迭代的方法，其中，把每 30 天一次的迭代称为一个“冲刺”，并按需求的优先级别来实现产品。多个自组织和自治的小组并行地递增实现产品，协调是通过简短的日常情况会议来进行，就像橄榄球中的“并列争球”。步骤如下：\n4. 自适应软件开发 (ASD) ASD 有 6 个基本的原则\n有一个使命作为指导 特征被视为客户价值的关键点 过程中的等待是很重要的，因此“重做”与“做”同样关键 变化不被视为改正，而是被视为对软件开发实际情况的调整 确定的交付时间迫使开发人员认真考虑每一个生产的版本的关键需求 风险也包含其中 5. 敏捷统一过程 (AUP) 敏捷统一过程 (Agile Unified Process, AUP) 采用“在大型上连续”以及在“小型上迭代”的原理来构建软件系统。采用经典的 UP 阶段性活动 (初始、精化、构建和转换) ，提供了一系列活动，能够使团队为软件项目构想出一个全面的过程流。在每个活动里，一个团队迭代使用敏捷，并将有意义的软件增量尽可能快地交付给最终用户。每个 AUP 迭代执行以下活动\n建模。建立对商业和问题域的模型表述，这些模型“足够好”即可，以便团队继续前进 实现。将模型翻译为源代码 测试。像 XP 一样，团队设计和执行一系列的测试来发现错误以保证源代码满足需求 部署。对软件增量的交付以及获取最终用户的反馈 配置及项目管理。着眼于变更管理、风险管理以及对团队的任一制品的控制。项目管理追踪和控制开发团队的工作进展并协调团队活动 环境管理。协调标准、工具以及适用于开发团队的支持技术等过程基础设施 ","date":"2023-03-28T15:45:47+08:00","permalink":"https://blog.yexca.net/archives/96/","title":"软件工程-软件过程与软件过程模型"},{"content":"整理一下自己学的 Git 相关的内容吧\n一、安装 在 Windows 上安装 Git 从 Git 官网下载安装： https://git-scm.com/download/win 安装完成后运行一次 Git Bash\n在 Linux 上安装 Git Debian：sudo apt-get install git\nFedora：dnf install git\nCentOS：yum install git\n其他参考： https://git-scm.com/download/linux 在 Mac OS X 上安装 Git 一是安装homebrew，然后通过homebrew安装Git，具体方法请参考homebrew的文档： http://brew.sh/ 二是直接从 AppStore 安装 Xcode，Xcode 集成了 Git，不过默认没有安装，你需要运行 Xcode，选择菜单 Xcode - Preferences，在弹出窗口中找到 Downloads，选择 Command Line Tools，点 Install 就可以完成安装了\nXcode 是 Apple 官方 IDE，功能非常强大，是开发 Mac 和 iOS App 的必选装备，而且是免费的\n二、配置 安装完成后需要配置自己的身份信息\n1 2 git config --global user.name \u0026#34;Your Name\u0026#34; git config --global user.email \u0026#34;email@example.com\u0026#34; 其中 Your Name 替换为您的姓名，email@example 替换为您的邮箱\n三、创建版本库 (仓库) 选择一个文件夹，然后执行命令\n1 git init 这样该文件夹就称为可以被 Git 管理的仓库，请勿乱修改 ./.git 目录下的文件 (通常这是隐藏文件)，该目录内容为 Git 跟踪管理版本库的\n或者也可以从 Github 上克隆仓库到本地\n克隆别人的仓库 如果不修改然后提交使用 HTTPS 就行，例如\n1 git clone https://github.com/yexca/typecho-theme-book.git 仓库链接可访问 仓库所在网页 ，点击 Code 获得\n如果克隆下来需要提交更改，需要仓库的拥有者将您的密钥添加到仓库的 Deploy keys ，此时可以使用 SSH 克隆\n1 git clone git@github.com:yexca/typecho-theme-book.git 不过一般修改提交的话还是先 fork 一份修改然后再 Pull requests 提交比较好\n参考： 如何使用github给大佬递茶 - idealclover 如何在 GitHub 提交第一个 pull request 克隆自己的仓库 先在个人的设置处添加 SSH 公钥： SSH and GPG keys (github.com) 然后以上俩方法皆可\n四、文件提交本地仓库 一通操作后，多了几个文件，该提交到仓库了\n将文件添加到本地仓库\n1 2 3 git add filename # 或者下面是提交所有修改的文件 git add . 添加完成后该提交了\n1 git commit -m \u0026#34;some details\u0026#34; 在 some details 处描述本次提交了什么\n那如果有些文件我不想提交到仓库呢，也就是有些文件可能不需要 Git 进行跟踪是否被修改\n创建 .gitignore 文件，然后把不想被 Git 管理的文件名填入一行一个即可\n1 2 3 4 5 # .gitignore 文件 test/ # 忽略 test 文件夹 test # 忽略 test 文件 *.py[cod] # 忽略 *.pyc *.pyo *.pyd 文件 !app.pyc # 不忽略 app.pyc 文件 忽略了也可以强制提交：git add -f test.pyc\n也有一些现成的文件，可以参考一下： https://github.com/github/gitignore 如果在使用过程中需要再次修改文件，需要先清除缓存\n1 2 3 4 5 6 # 清除缓存 git rm -r --cached . # 重新遍历文件 git add . # 提交文件 git commit -m \u0026#34;update .gitignore\u0026#34; 五、日志与撤销 使用 git status 可以查看仓库的状态\n使用 git diff 查看上次提交修改的内容\n使用 git log 查看历史记录，即日志，如果信息太多可以加上 --pretty=oneline 参数，此时可以看到 commit ID\n在 commit ID 后如果有 HEAD -\u0026gt; master 则说明此为最新提交，也就是当前版本，Git 使用 HEAD 表示当前版本，上一个版本就是 HEAD^，上上个版本是 HEAD^^ ，往上 60 个版本可以写成 HEAD~60\n回退到上一个版本 git reset --hard HEAD^\n回退到指定版本：\n1 2 3 4 git reset --hard commitID # 例如 commit ID 为 eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0，可以写如下： git reset --hard eaadf4 # 只要写前几位并可以识别就行，没必要写全 如果你操作失误回退了，请不要关闭命令行窗口，查看命令日志：git reflog 找到刚才的版本号回退即可\n六、本地仓库链接 Github 本地创建了一个仓库，想要上传到 Github 的话，可以在 Github 上新建一个 repo ，然后将本地仓库链接远程仓库以上传\n1 git remote add origin git@github.com:[your repo] 如果是从远程仓库克隆的不需要链接\n然后是在本地做了一些修改并提交，需要推送至远程仓库\n推送命令：git push origin master\n命令为推送到远程仓库的 master 分支\n这里需要注意的是使用 VS Code 创建的仓库默认分支为 master 而 Github 默认分支为 main，直接推送 git push origin main 会失败，可以先修改本地分支名字再推送\n1 git branch -m master main 不过也可以修改默认创建的分支名称为 main\n1 git config --global init.defaultBranch main 另外，可以设置默认推送仓库为 origin 的 main 分支\n1 git push --set-upstream origin main 这样之后推送的时候直接使用\n1 git push origin 即可\n如果链接仓库时输入错了\n首先查看远程仓库信息：git remote -v\n然后删除：git remote rm RepoName\n一般远程仓库名称为 origin，所以删除命令为 git remote rm origin\n七、分支管理 Git 分支是 Git 中用来独立开发不同功能、修复问题或实验新想法的机制。通过分支，可以在不影响主分支的情况下自由地进行更改\n列出所有分支: git branch\n创建分支：git branch new_branch\n切换到分支 1：git checkout new_branch\n切换到分支 1：git switch new_branch\n推送到分支：git push origin cheny\n比如添加一个搜索功能，首先将主分支提交完成后创建新分支\n1 git switch -c search 上述命令表示创建并切换到分支 search\n在新分支 search 修改并测试完成后提交\n1 2 git add . git commit -m \u0026#34;添加搜索功能\u0026#34; 然后切换回主分支 main\n1 git switch main 合并分支 search\n1 git merge search (可选) 删除 search 分支\n1 git branch -d search 八、创建服务端 参考： 搭建Git服务端及同步到指定目录 九、其他 同时使用 GitLab 和 Github： document-library/Git-study.md at master · LiangJunrong/document-library (github.com) 参考文章 document-library/Git-study.md at master · LiangJunrong/document-library · GitHub Git教程 - 廖雪峰的官方网站 (liaoxuefeng.com) 如何连接本地仓库与GitHub仓库_joy_we1的博客-CSDN博客 如何使用github给大佬递茶 - idealclover 如何在 GitHub 提交第一个 pull request 将本地master分支代码提交到远程main分支 git 修改.gitignore后生效 ","date":"2023-03-05T15:03:43+08:00","permalink":"https://blog.yexca.net/archives/95/","title":"Git 学习"},{"content":"秉持着 \u0026ldquo;不在自己硬盘的东西就不是自己的\u0026rdquo; 的原则，以及个人手机中日益增多的图片迫切需要整理放入硬盘中保存，以缓解手机内存危机，于是决定采取分画师下载储存。于是便需要一个方便记录，快速查询修改的方法，原来使用 Markdown 的清单，可随着画师增多，查询不免变得很慢\n时隔两天再次回想，「记录」这个东西，最好用的不就是数据库嘛！\n下载与安装 经过思考，决定使用 MySQL ，下载可参考： MySQL下载与安装 - 知乎 ，部分变了，不过也差不多啦\n安装我直接默认，一直下一步到完成 (太麻烦了)\n启动服务，win+R 输入 services.msc 找到服务开启\n数据库设计 说实话这也没啥好设计的吧，暂时主要下载 Pixiv 上画师，部分是 Twitter 上的，所以只用一张表应该就可以啦\nID name downloadDate lastDownloadID platform url 画师唯一标识 姓名 下载日期 最后下载作品 ID 平台 链接 这设计是第几范式呢？ 代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 -- 创建数据库 create database hello; -- 选择数据库 use hello; -- 创建表 create table pic ( ID varchar(99), name varchar(255), downloadedDate datetime, lastDownloadID varchar(255), platform varchar(50), url varchar(255), primary key(ID) ); 作品下载 Pixiv 使用 Powerful Pixiv Downloader 拓展， Chrome 应用商店链接 Github 链接： xuejianxianzun/PixivBatchDownloader 记得开启慢速抓取，不然下太快或一次下载过多会暂时封 IP\nTwitter 使用 Twitter Media Downloader 拓展， Chrome 应用商店链接 官网链接： Twitter メディアダウンローダ：ユーザータイムラインの原寸画像や動画をまとめてダウンロードするユーザースクリプト(PC用Google Chrome・Firefox等対応) - 風柳メモ 数据插入 1 2 3 4 5 6 -- 选择数据库 use hello; -- 插入数据 insert into pic values (\u0026#39;6049901\u0026#39;, \u0026#39;鬼针草\u0026#39;, \u0026#39;2023-02-09\u0026#39;, \u0026#39;105176620\u0026#39;, \u0026#39;pixiv\u0026#39;, \u0026#39;https://www.pixiv.net/users/6049901\u0026#39;) 多行数据的话，数据直接用 , 分隔\n数据更新 1 2 3 update pic set downloadedDate = \u0026#39;2023-03-02\u0026#39;, lastDownloadID = \u0026#39;105716156\u0026#39; where ID = \u0026#39;6049901\u0026#39; 了解更多： 数据库学习三 SQL 语言 – yexca\u0026rsquo;Blog MySQL 服务不见了 这里插入一个我遇到的问题，写在其他文章不大合适就放这了\n在要打开数据库导入数据时，发现我的服务里没 MySQL，解决：\n以管理员权限打开 CMD，进入 MySQL/bin 目录\n1 2 3 4 # 注册服务 mysqld --install # 启动服务 net start mysql 等待一会即可使用，数据并无丢失\n了解数据库？ 我编写的： 数据库学习一 数据库导论 – yexca\u0026rsquo;Blog 菜鸟教程： SQL 教程-菜鸟教程 参考文章 MySQL常见建表选项及约束 - GeaoZhang - 博客园 ","date":"2023-03-02T10:16:38+08:00","permalink":"https://blog.yexca.net/archives/94/","title":"数据库记录已下载画师作品"},{"content":"面向对象 (Object-Oriented, OO) 是一种非常实用的系统化软件开发方法\n面向过程和面向对象 以一个问题引入：把大象装进冰箱，需要几步？\n一般先打开冰箱，然后把大象装进冰箱，最后关上冰箱\n面向过程： 关心我该怎么做？一步步去实现这个功能\n对于上述问题:\n我打开冰箱 我把大象装进冰箱里 我关上冰箱门 面向对象 关心我该让谁去做？去调用对象的操作来实现这个功能\n对于上述问题\n创建对象：大象，冰箱\n冰箱打开门 大象钻进冰箱 冰箱关上门 面向对象基础 面向对象 = 对象 + 分类 + 继承 + 通过消息的通信\n可以说，采用这四个概念开发的软件系统是面向对象的\n对象 客观世界由许多具体的事物、事件、概念和规则组成，这些均可被看成对象\n在面向对象的系统中，对象是基本的运行时的实体，它既包括数据 (属性) ，也包括作用于数据的操作 (行为) 。一个对象通常可由对象名、属性和方法 3 个部分组成\n消息 对象之间进行通信的一种构造叫做消息。的一个消息发送给某个对象时，包含要求接收对象去执行某些活动的信息。接收到信息的对象经过解释，然后予以相应\n类似于方法调用的传参\n类 一个类定义了一组大体上相似的对象。一个类所包含的方法和数据描述一组对象的共同行为和属性。把一组对象的共同特征加以抽象并存储在一个类中是面向对象技术最重要的一点。是否建立了一个丰富的类库，是衡量一个面向对象程序设计语言成熟与否的重要标志\n类是在对象之上的抽象，对象是类的具体化，是类的实例。在分析与设计时，通常把注意力集中在类上，而不是具体的对象。也不必逐个定义每个对象，只需对类做出定义，而对类的属性进行不同赋值即可得到该类的对象实例\n类可以分为三种：实体类、接口类 (边界类) 和控制类。控制类的对象用来控制活动流，充当协调者\n有些类之间存在一般和特殊关系，即一些类是某个类的特殊情况，某个类是一些类的一般情况。特殊类是一般类的子类，一般类是特殊类的父类\n通常，把一个类和这个类的所有对象称为 \u0026ldquo;类及对象\u0026rdquo; 或对象类\n方法重载 方法重载方式\n方法名相同，参数个数不同 方法名相同，参数类型不同 方法名相同，参数类型顺序不同 以 java 为例，java 的函数 (方法) 的格式如下\n1 2 3 4 5 6 /* 权限修饰符 返回值类型 方法名(参数类型1 参数名1, 参数类型2 参数名2,···) { 方法体 } */ 以下为例子\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public class Test { // 原方法 public void sum(int a, double b) { System.out.println(a + b); } // 1. 方法名相同，参数个数不同 public void sum(int a, double b, int c) { System.out.println(a + b + c); } // 2. 方法名相同，参数类型不同 public void sum(int a, int b) { System.out.println(a + b); } // 3. 方法名相同，参数类型顺序不同 public void sum(double a, int b) { System.out.println(a + b); } } 面向对象三大特征 面向对象的三个基本特征是：封装、继承、多态\n封装 封装是一种信息隐蔽技术，它的目的是使对象的使用者和生产者分离，使对象的定义和实现分开。从程序设计者来看，对象是一个程序模块；从用户来看，对象为他们提供了所希望的行为\n也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public class Person{ private String name;\t// 使用 private 限制权限 private int age; public void setName(String name){ // 通过 public 方法提供修改对象属性的途径 this.name = name; } public String getName(){ // 通过 public 方法提供获取对象属性的途径 return name; } public void setAge(int age){ if (age \u0026gt;= 0 \u0026amp;\u0026amp; age \u0026lt;= 150) this.age = age; } public int getAge(){ return age } public void run(){ System.out,println(\u0026#34;润！\u0026#34;) } } 继承 继承是父类和子类之间共享数据和方法的机制。这是类之间的一种关系，在定义和实现一个类的时候，可以在一个已经存在的父类的基础上进行，把这个已经存在的类所定义的内容作为自己的内容，并加入若干新的内容\n一个父类可以有多个子类，这些子类都是父类的特例，父类描述了这些子类的公共属性和方法。一个子类可以继承它的父类 (或祖先类) 中的属性和方法，这些属性和操作在子类中不必定义，子类中还可以定义自己的属性和方法\n如果子类只从一个父类得到继承，称为 \u0026ldquo;单重继承\u0026rdquo; 。如果一个子类有两个或更多个父类，则称为 \u0026ldquo;多重继承\u0026rdquo;\n注：Java 中一个子类只能有一个父类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // 接上一段代码看 public class Student extends Person{ // 使用关键字 extends 指明要继承的父类 private int id; public void setId(int id){ this.id = id; } public int getId(){ return id; } public void study(){ System.out.println(getName() + \u0026#34;正在学习\u0026#34;); } // 重写父类方法 public void run(){ System.out,println(getName + \u0026#34;想润\u0026#34;) } } 多态 在收到消息时，对象要予以响应。不同对象收到同一消息可以产生完全不同的结果，这一现象称为多态。在使用多态的时候，用户可以发送一个通用的消息，而实现的细节则由接收对象自行决定。这样，同一消息就可以调用不同的方法\n多态的实现受到继承的支持，利用类的继承的层次关系，把具有通用功能的消息存放在高层次，而不同的实现这一功能的行为放在较低层次，在这些低层次上生成的对象能够给通用消息以不同的响应\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 // 父类 public class Person{ public void work(){ System.out.println(\u0026#34;工作\u0026#34;); } } // 子类 1 public class Student extends Person{ // 重写父类方法 public void work(){ System.out.println(\u0026#34;上学\u0026#34;); } public void run(){ System.out.println(\u0026#34;Only the young CAN RUN!\u0026#34;); } } // 子类 2 public class Worker extends Person{ // 重写父类方法 public void work(){ System.out.println(\u0026#34;上班\u0026#34;); } public void sleep(){ System.out.println(\u0026#34;睡觉\u0026#34;); } } // main public class main{ public static void main(String[] args){ // 编译看左边，运行看右边 Person stu = new Student(); stu.work; // 不可调用 stu.run(); 方法 Person wok = new Worker(); wok.work; // 不可调用 wok.sleep(); 方法 } } // 运行输出： // 上学 // 上班 多态的形式 多态有不同的形式，Cardelli 和 Wegner 把它分为 4 类\n参数多态：应用比较广泛的多态，被称为最纯的多态\n包含多态：在许多语言中都存在，最常见的例子就是子类型化，即一个类型是另一个类型的子类型\n过载多态：同一个名字在不同的上下文中所代表的含义不同\n动态绑定和静态绑定 绑定是一个把过程调用和响应调用所执行的代码加以结合的过程。在一般的程序设计语言中，绑定是在编译时进行的，叫做静态绑定。动态绑定则是在运行时进行的。因此，一个给定的过程调用和代码的结合直到调用发生时才进行\n动态绑定是和类的继承以及多态相联系的。在继承关系中，子类是父类的一个特例，所以父类可以出现的地方，子类对象也可以出现。因此在运行过程中，当一个对象发送消息请求服务时，要根据接收对象的具体情况将请求的操作与实现的方法进行连接，即动态连接\n面向对象分析 面向对象分析 (Object-Oriented Analysis, OOA) 的目的是为了获得对应用问题的理解。理解的目的是确定系统的功能、性能要求\n面向对象分析包含 5 个活动：认定对象、组织对象、描述对象间的相互作用、确定对象的操作、定义对象的内部信息\n面向对象设计 面向对象设计 (Object-Oriented Design, OOD) 是将 OOA 所创建的分析模型转化为设计模型，其目标是定义系统构造蓝图。通常的情况是，由概念模型生成的分析模型被装入到相应的执行环境中时，需要考虑实现问题加以调整和增补，如根据所用编程语言是否支持多继承或继承，而调整类结构。OOA 与 OOD 之间不存在鸿沟，采用一致的概念和一致的表示法，OOD 同样应遵循抽象、信息隐蔽、功能独立、模块化等设计准则\n面向对象设计的活动 OOD 在复用 OOA 的模型的基础上，包含与 OOA 对应如下五个活动\n识别类及对象 定义属性 定义服务 识别关系 识别包 面向对象设计原则 单一责任原则 ​\t就一个类而言，应该仅有一个引起它变化的原因。即，当需要修改某个类的时候原因有且只有一个，让一个类只做一种类型责任\n开放-封闭原则 ​\t软件实体 (类、模块、函数等) 应该是可以扩展的，即开放的；但是不可修改的，即封闭的\n里氏替换原则 ​\t子类型必须能够替换掉他们的基 (父) 类型。即，在任何父类可以出现的地方，都可以用子类的实例来赋值给父类型的引用。当一个子类型的实例应该能够替换任何其超类的实例时，它们之间才具有是一个 (is-a) 关系\n依赖倒置原则 ​\t抽象不应该依赖于细节，细节应该依赖于抽象。即，高层不应该依赖于底层模块，二者都应该依赖于抽象\n接口分离原则 ​\t不应该强迫客服依赖于它们不用的方法。接口属于客户，不属于它所在的类层次结构。即：依赖于抽象，不要依赖于具体，同时在抽象级别不应该有对于细节的依赖。这样做的好处就在于可以最大限度地应对可能的变化\n以上为面向对象方法中的五大原则。除了这五大原则之外，Robert C. Martin 提出的面向对象设计原则还包括以下几个\n重用发布等价原则 ​\t重用的颗粒就是发布的粒度\n共同封闭原则 ​\t包中的所有类对于同一类性质的变化应该是共同封闭的。一个变化若对一个包产生影响，则将对该包中的所有类产生影响，而对于其他的包不造成任何影响\n共同重用原则 ​\t一个包中的所有类应该是共同重用的。如果重用了包中的一个类，那么就要重用包中的所有类\n无环依赖原则 ​\t在包的依赖关系图中不允许存在环，即包之间的结构必须是一个直接的无环图形\n稳定依赖原则 ​\t朝着稳定的方向进行依赖\n稳定抽象原则 ​\t包的抽象程度应该和其稳定程度一致\n面向对象测试 就测试而言，用面向对象方法开发的系统测试与其他方法开发的系统测试没有什么不同\n一般来说，对面向对象软件的测试可分为下列 4 个层次进行\n算法层 类层 模板层 系统层 面向对象程序设计 程序设计范型 (Programming Paradigm) 是人们在程序设计时所采用的基本方式模型，决定了程序设计时采用的思维方式、使用的工具，同时又有一定的应用范畴。其发展经历了过程程序设计、模块化程序设计、函数程序设计、逻辑程序设计，发展到现在的面向对象程序设计范型\n面向对象程序设计 (Object-Oriented Programming, OOP) 的实质是选用一种面向对象程序设计语言 (Object-Oriented Programming Language, OOPL) ，采用对象、类及其相关概念所进行的程序设计。它的关键在于加入了类和继承性，从而进一步提高了抽象程度。特定的 OOP 概念一般是通过 OOPL 中特定的语言机制来体现的\nOOP 现在已经扩展到系统分析和软件设计的范畴，出现了面向对象分析和面向对象设计的概念，这部分在前面已经有所体现\n","date":"2023-02-25T19:34:30+08:00","permalink":"https://blog.yexca.net/archives/93/","title":"面向对象基础"},{"content":" SQL Series\n数据库学习一 数据库导论: https://blog.yexca.net/archives/86 数据库学习二 关系模型: https://blog.yexca.net/archives/87 数据库学习三 SQL 语言: https://blog.yexca.net/archives/88 数据库学习四 关系数据库理论: https://blog.yexca.net/archives/89 数据库学习五 范式: https://blog.yexca.net/archives/90 数据库学习六 数据库设计: https://blog.yexca.net/archives/91 数据库学习七 数据库的控制功能: 本文\n事务管理 事务是一个操作序列，这些操作 \u0026ldquo;要么都做，要么都不做\u0026rdquo;\n事务和程序是两个不同的概念，一般一个程序可包含多个事务\n在 SQL 语言中，事务定义的语句有以下三条\n1 2 3 4 5 6 -- 事务开始 BEGIN TRANSACTION -- 事务提交 COMMIT -- 事务回滚 ROLLBACK 事务具有 ACID 性质，原子性 (Atomicity) 、一致性 (Consistency) 、隔离性 (Isolation) 和持久性 (Durability)\n1 原子性 事务是原子的，要么都做，要么都不做\n2 一致性 事务执行的结果必须保证数据库从一个一致性状态变到另一个一致性状态\n因此，当数据库只包含成功事务提交的结果时，称数据库处于一致性状态\n3 隔离性 事务相互隔离\n当多个事务并发执行时，任一事务的更新操作直到其成功提交的整个过程，对其他事务都是不可见的\n4 持久性 一旦事务成功提交，即使数据库崩溃，其对数据库的更新操作也将永久有效\n数据库的备份与恢复 在数据库的运行过程中，难免会出现计算机系统的软、硬件故障，这些故障会影响数据库中数据的正确性，甚至破坏数据库，使数据库中的全部或部分数据丢失。因此，数据库的关键技术在于建立冗余数据，即备份数据。如何在系统出现故障后能够及时地使数据库恢复到故障前地正确状态，就是数据库恢复技术\n故障类型 数据库中的 4 类故障\n1 事务内部故障 采取REDO重做和UNDO撤销技术\n2 系统故障 DBMS 系统突然停转，系统要重启\n3 介质故障 硬件损坏\n4 计算机病毒 备份方法 恢复的基本原理是 \u0026ldquo;建立数据冗余\u0026rdquo; (重复存储) 。建立冗余数据的方法是进行数据转储和登记日志文件。数据的转储分为静态转储和动态转储、海量转储和增量转储、日志文件\n1 静态转储和动态转储 静态转储是指在转储期间不允许对数据库进行任何存取、修改操作\n动态转储是在转储期间允许对数据库进行存取、修改操作\n因此，转储和用户事务可并发执行\n2 海量转储和增量转储 海量转储是指每次转储全部数据\n增量转储是指每次只转储上次转储后更新过的数据\n3 日志文件 在事务处理的过程中，DBMS (数据库管理系统) 把事务开始、事务结束以及对数据库的插入、删除和修改的每一次操作写入日志文件。一旦发生故障，DBMS 的恢复子系统利用日志文件撤销事务对数据库的改变，回退到事务的初始状态。因此，DBMS 利用日志文件来进行事务故障恢复和系统故障恢复，并可协助后备副本进行介质故障恢复\n恢复 事务恢复有以下 3 个步骤 反向扫描文件日志 (即从最后向前扫描日志文件) ，查找该事务的更新操作 对事务的更新操作执行逆操作 继续反向扫描日志文件，查找该事务的其他更新操作，并做同样的处理，直到事务的开始标志 即事务异常终止，那么就撤销之前的所有操作\n系统故障的恢复 还没执行完的事务UNDO，丢失的事务REDO\n介质故障的恢复 重装数据库，重做已经完成的事务\n并发控制 并发操作带来的问题 1 丢失修改 我修改的东西没生效。比如我把网站logo改了，结果还是原来的\n2 不可重复读 我在一个事务中，连续两次读到的数据不一样 比如我刚开始读到银行余额为10元。此时单位突然发工资100元，那么第二次读就变成110元\n3 读脏数据 我要读取字段A，B，但读取时其他用户正在更新这两个字段 如果他跟新到一半我就读取（更新了A，正在更新B），此时读取的数据就是脏数据\n并发控制技术 并发控制的主要技术是封锁。基本封锁的类型有排他锁 (简称 X 锁或写锁) 和共享锁 (简称 S 锁或读锁)\n1 排他锁 若事务 T 对数据对象 A 加上 X 锁，则只允许 T 读取和修改 A，其他事务都不能再对 A 加任何类型的锁，直到 T 释放 A 上的锁\n2 共享锁 若事务 T 对数据对象 A 加上 S 锁，则只允许 T 读取 A，但不能修改 A，其他事务只能再对 A 加 S 锁，直到 T 释放 A 上的 S 锁。这就保证了其他事务可以读 A，但在 T 释放 A 上的 S 锁之前不能对 A 进行任何修改\n封锁协议 一级封锁协议（解决丢失修改） 修改时，必须加X锁，直到结束\n二级封锁协议（解决读脏数据） 读的时候，加S锁，用完就放\n三级封锁协议（解决不可重复读） 读的时候，加S锁，直到结束\n可串行性 假设多种情况都可以，然后获得结果 如果并发执行的结果跟上面的结果里面任意一个一样就可以\n事务T1：读取B，A=B+1，写回A 事务T2：读取A，B=A+1，写回B\n那么结果假设先T1，再T2，那么A=4，B=3； 假设先T2，再T1，那么A=3，B=4. 这个并发执行满足可串行性\n分布式数据库 分片透明 用户或应用程序不需要知道逻辑上访问的表具体是怎么分块存储的\n复制透明 采用复制技术的分布方法，用户不需要知道数据是复制到哪些节点，如何复制的\n位置透明 用户无需知道数据存放的物理位置\n逻辑透明 用户或应用程序无需知道局部场地使用的是哪种数据模型\n共享性 数据存储在不同的结点数据共享\n自治性 每结点对本地数据都能独立管理\n可用性 当某一场地故障时，系统可以使用其他场地上的副本而不至于使整个系统瘫痪\n分布性 数据在不同场地上的存储\n","date":"2023-02-12T08:15:00+08:00","permalink":"https://blog.yexca.net/archives/92/","title":"数据库学习七 数据库的控制功能"},{"content":" SQL Series\n数据库学习一 数据库导论: https://blog.yexca.net/archives/86 数据库学习二 关系模型: https://blog.yexca.net/archives/87 数据库学习三 SQL 语言: https://blog.yexca.net/archives/88 数据库学习四 关系数据库理论: https://blog.yexca.net/archives/89 数据库学习五 范式: https://blog.yexca.net/archives/90 数据库学习六 数据库设计: 本文\n数据库学习七 数据库的控制功能: https://blog.yexca.net/archives/92 数据库设计的策略 自顶向下与自底向上，常常两种方法综合使用\n数据库设计的步骤 新奥尔良法是目前得到公认的，较完整、较权威的数据库设计方法，它把数据库设计分为四个主要阶段\n用户需求分析。收集用户需求，确定系统边界 概念设计。描述概念模型较理想的是采用 E-R 方法 逻辑设计。E-R 图转换为关系模式，规范化 物理设计。逻辑模型在计算机中的具体实现方案 然后进行数据库实施阶段与数据库运行、维护阶段\n需求分析阶段 需求分析是在项目确定之后，用户和设计人员对数据库系统所要涉及的内容 (数据) 和功能 (行为) 的整理和描述，是以用户的角度来认识系统。\n这一过程是后续开发的基础，以后的逻辑设计和物理设计以及应用程序的设计都会以此为依据\n需求分析阶段的工作 调查机构情况 → 熟悉业务活动 → 明确用户需求 → 确定系统边界 → 分析系统功能 → 分析系统数据 → 编写分析报告\n需求分析阶段的文档 需求调查所得到的数据可能是零碎的、局部的，分析师和设计人员必须进一步分析和表达用户的需求，建立需求说明文档、数据字典和数据流程图\nE-R 模型 E-R (实体-联系) 模型是概念模型，用来描述现实世界的概念模型\n实体 用矩形表示，矩形框内写明实体名\n联系 用菱形表示，菱形框内写明联系名，并用无向边分别与有关实体连接起来，同时在无向边旁边标注上联系的类型 (1 : 1、1 : n、m : n)\n\u0026lt;1\u0026gt; 两个不同实体之间的联系\n一对一 (1 : 1)：指实体集 E1 中的一个实体最多只与实体集 E2 中的一个实体相联系 一对多 (1 : n)：表明实体集 E1 中的一个实体可与实体集 E2 中的多个实体相联系 多对多 (m : n)：表明实体集 E1 中的多个实体可与实体集 E2 中的多个实体相联系 \u0026lt;2\u0026gt; 两个以上不同实体集之间的联系\n两个以上不同实体集之间存在 1 : 1 : 1、1 : 1 : n、1 : m : n 和 r : n : m 的联系\n\u0026lt;3\u0026gt; 同一实体集内的二元联系\n同一实体集内的各实体之间也存在 1 : 1、1 : n 和 m : n 的联系\n属性 属性是实体某方面的特性，用椭圆表示，椭圆框内写明属性名 (主属性的属性名用下划线标记)，并用无向边与有关实体连接起来\n每个属性都有其取值范围。在同一实体集中，每个实体的属性及其域是相同的，但可能取不同的值\nE-R 模型中的属性有以下分类\n简单属性和复合属性 简单属性是原子的、不可再分的。复合属性可以细分为更小的部分 (即划分为别的属性)\n若不特别声明，通常指的是简单属性\n单值属性和多值属性 单值属性是定义的属性对于一个特定的实体都只有单独的一个值\n多值属性是定义的属性对于一个特定的实体有多个值\nNULL 属性 当实体在某个属性上没有值或者属性值未知时，使用 NULL 值，表示无意义或不知道\n派生属性 派生属性可以从其他属性得来\n例如职工有 入职时间 与 工作时长 属性，则 工作时长 可以由当前时间与 入职时间 之差获得，这里 工作时长 就是一个派生属性\n弱实体 在现实世界中有一种特殊的联系，这种联系代表实体间的所有关系。例如，职工与家属的联系，家属总是属于某职工的。这种实体对于另一些实体具有很强的依赖关系，即一个实体的存在必须以另一个实体为前提，将这类实体称为弱实体\n在 E-R 图中，弱实体使用双线矩形框表示\n超类和子类实体 例如职员实体是飞行员、机械师和管理员实体的超类 (父类)，超类和子类之间具有继承关系\n子类实体矩形两边有竖线，超类与子类的连线中有圆圈\n概念结构设计阶段 用 E-R 方法建立概念模型\n对需求分析阶段所得到的数据进行分类、聚集和概括，确定实体、属性和联系。概念结构的具体工作步骤包括选择局部应用、逐一设计分 E-R 图和 E-R 图合并\n需求分析阶段 → 抽象数据 → 设计局部视图 → 合并取消冲突 → 修改重构消除冗余 → 逻辑结构设计阶段\n选择局部应用 选择适当层次的数据流图，让这一层的每一部分对应一个局部应用，实现某一项功能\n逐一设计分 E-R 图 划分好各个局部应用之后，就要对每一个局部应用逐一设计分 E-R 图，又称为局部 E-R 图\nE-R 图合并 根据局部应用设计好各局部 E-R 图之后，就可以对各分 E-R 图进行合并，合并的目的在于在合并过程中解决分 E-R 图中相互间存在的冲突。最终构成一张全局 E-R 图\n分 E-R 图之间的冲突主要有以下三类：\n属性冲突 同一属性可能会存在于不同的分 E-R 图，由于设计人员不同或者出发点不同，对属性的类型、取值范围和数据单位等可能会不一致，这些属性对应的数据将来只能以一种形式在计算机中存储，这就需要在设计阶段进行统一\n命名冲突 相同的意义在不同分 E-R 图上有着不同的命名，或是名称相同的属性在不同的分 E-R 图中代表着不同的意义，这些也要进行统一\n结构冲突 同一实体在不同的分 E-R 图中有不同的属性，同一对象在某一分 E-R 图中被抽象为实体，而在另一分 E-R 图中又被抽象为属性，需要统一\n逻辑结构设计阶段 逻辑结构设计是在概念结构设计的基础上进行数据模型设计，可以是层次模型、网状模型和关系模型，本节介绍如何在全局 E-R 图基础上进行关系模型的逻辑结构设计。逻辑结构设计阶段的主要工作步骤包括确定数据模型、将 E-R 图转换成为指定的数据模型、确定完整性约束 (实体完整性，参照完整性和用户自定义完整性) 和确定用户视图\n概念设计阶段 → 转换为数据模型 → 关系规范化 → 模式优化 → 设计用户子模式 → 物理设计阶段\nE-R 图关系模式的转换 E-R 方法所得到的全局概念模型是对信息世界的描述，并不适用于计算机处理，为适合关系数据库系统的处理，必须将 E-R 图转换成关系模式。E-R 图是由实体、属性和联系三要素构成，而关系模式中只有唯一的结构 \u0026mdash; 关系模式，通常采用以下方法加以转换\n一、实体向关系模式的转换 将 E-R 图中的实体逐一转换成为一个关系模式，实体名对应关系模式的名称，实体的属性转换成关系模式的属性，实体标识符就是关系的吗 (键)\n二、联系向关系模式的转换 一对一联系的转换 一种方式是将联系归并到并联的两个实体的任一方，给待归并的一方实体属性集中增加另一方实体的码和该联系的属性即可，归并后的实体，码保持不变\n另一种方式 (一般不用) 是将联系转换成一个独立的关系模式，关系模式的名称取联系的名称，关系模式的属性包括该联系所关联的两个实体的码及联系的属性，关系的码取自任一方实体的码\n一对多联系的转换 一种方式是将联系归并到关联的两个实体的多方，给待归并的多方实体属性集中增加一方实体的码和该联系的属性即可，归并后的多方实体码保持不变\n另一种方式 (一般不用) 是将联系转换成一个独立的关系模式，关系模式的名称取联系的名称，关系模式的属性取该联系所关联的两个实体的码及联系的属性，关系的码是多方实体的码\n多对多联系的转换 多对多联系只能转换成一个独立的关系模式，关系模式的名称取联系的名称，关系模式的属性取该联系所关联的两个多方实体的码及联系的属性，关系的码是多方实体的码构成的属性组\n多对多对多联系的转换 与第三个大致相同\n超类和子类的转换 超类、子类实体都可转换为一个关系，并将超类实体的主码加到子类实体中\n关系模式的规范化 根据语义确定各关系模式的数据依赖 根据数据依赖确定关系模式的范式 如果关系模式不符合要求，要根据关系模式的分解算法对其进行分解，达到 3NF、BCNF 或 4NF 关系模式的评价及修正 物理设计阶段 逻辑设计阶段 → 确定数据库的物理模式 → 评价数据库的物理模式 → 数据库实施阶段\n数据库的实施与维护 物理结构设计阶段 → 定义数据库 → 数据装入与编写应用程序 → 数据库试运行 → 数据库运行维护阶段\n","date":"2023-02-11T08:15:00+08:00","permalink":"https://blog.yexca.net/archives/91/","title":"数据库学习六 数据库设计"},{"content":" SQL Series\n数据库学习一 数据库导论: https://blog.yexca.net/archives/86 数据库学习二 关系模型: https://blog.yexca.net/archives/87 数据库学习三 SQL 语言: https://blog.yexca.net/archives/88 数据库学习四 关系数据库理论: https://blog.yexca.net/archives/89 数据库学习五 范式: 本文\n数据库学习六 数据库设计: https://blog.yexca.net/archives/91 数据库学习七 数据库的控制功能: https://blog.yexca.net/archives/92 关系数据库中的关系必须满足一定的规范化要求，对于不同的规范化程度可以使用范式来衡量。目前主要有 6 钟范式：1NF、2NF、3NF、BCNF、4NF 和 5NF\n满足最低要求的称为 1NF，在 1NF 基础上进一步满足一些要求的为 2NF，以此类推。在这些范式中，最重要的是 3NF 和 BCNF，它们是进行规范化的主要目标\n一个低一级范式的关系模式，通过模式分解可以转换为若干个高一级范式的关系模式的集合，这个过程称为规范化\n第一范式 (1NF) 定义：设 R 是一个关系模式，R 属于第一范式当且仅当 R 中每一个属性 A 的值域只包含原子项，即不可分割的数据项\n1NF 不能排除数据冗余、更新 (插入、删除) 异常和修改复杂等问题，因为其中可能存在部分函数依赖\n第二范式 (2NF) 定义：设 R 是一个关系模式，R 属于第二范式当且仅当 R 是 1NF，且每个非主属性都完全依赖于候选码\n属于 2NF 的关系模式 R 也可能存在数据冗余和更新异常等问题，因为其中可能存在传递函数依赖\n第三范式 (3NF) 定义：设 R 是一个关系模式，R 属于第三范式当且仅当 R 是 2NF，且每个非主属性都非传递依赖于候选码\n属于 3NF 的关系模式 R 可能存在主属性对码的部分依赖和传递依赖\nBC 范式 (BCNF) 定义：设 R 是一个关系模式，F 是它的依赖集，R 属于 BCNF 当且仅当 R 是 3NF，当且仅当其 F 中每个依赖的决定因素必定包含 R 的某个候选码\n由 BCNF 的定义可以得到结论，一个满足 BCNF 的关系模式有：\n所有非主属性对每一个码都是完全函数依赖 所有的主属性对每一个不包含它的码，也是完全函数依赖 没有任何属性完全函数依赖于非码的任何一组属性 一个满足 BCNF 的关系模式 R 已消除了插入和删除异常\n只有两个属性的关系模式一定是 BCNF\n第四范式 (4NF) 定义：设有一关系模式 R\u0026lt;U, F\u0026gt; 是 1NF，如果对于 R 的每个非平凡多值依赖 X →→ Y (Y ⊈ X)，X 都包含了 R 的一个候选码，则称 R 是第四范式\n多值依赖 给定的关系模式 R\u0026lt;U, F\u0026gt;，有 X、Y、Z 是 U 的子集，并且 Z = U - X - Y，关系模式 R 中的多值依赖 X →→ Y 成立，当且仅当对 R 的任一关系 r，给定一对 (x, z) 值，有一组 Y 的值，这组值仅仅决定于 x 值而与 z 值无关\n平凡的多值依赖 若以上多值依赖的定义中有 X →→ Y 成立，而且 Z 为空集，则称 X →→ Y 为平凡的多值依赖\n范式总结 1NF（第一范式） 所有字段值都是不可分解的原子值\n2NF（第二范式） 不包含非主属性对码的部分函数依赖，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中\n3NF（第三范式） 不包含非主属性对码的传递函数依赖，确保数据表中每一列数据都和主键直接相关，而不能间接相关\nBCNF（BC范式） 消除每一属性对候选键的传递依赖，BCNF是修正的3NF\n1NF → 2NF：消除非主属性对码的部分函数依赖\n2NF → 3NF：消除非主属性对码的传递函数依赖\n3NF → BCNF：消除主属性对码的部分和传递函数依赖\nBCNF → 4NF：消除非平凡且非函数依赖的多值依赖\n候选码都是单个属性至少是 2NF\n关系模式的分解 对存在数据冗余、插入异常、删除异常问题的关系模式，应采取一个关系模式分解为多个关系模式的方法进行处理，相应地，原来存储在一个二维表内的数据就要分散到多个二维表中，要使这个分解有意义，起码的要求是后者不能丢失前者的信息\n在分解处理中会涉及一些新问题，为使分解后的模式保持原模式所满足的特性，其基本要求是模式分解具有无损连接性和保持函数依赖性\n无损连接 无损连接指的是对关系模式分解时，原关系模式下任一合法的关系实例在分解之后应能通过自然连接运算恢复起来\n即分解后的关系通过自然连接可以恢复为原关系\n保持函数依赖 做模式分解后的 F\u0026rsquo; (各个子模式函数依赖的并集) 是否与 F (原有的函数依赖集) 等价，F\u0026rsquo; 包含所有的 F 中的函数依赖则可以得出保持函数的依赖性 (充分条件)\n即分解后依赖不变\n参考： 模式分解保持函数依赖判断——数据库考试复习_guoyp2126的博客-CSDN博客 已知 R (ABCDEGH), F={A-\u0026gt;D, E-\u0026gt;D, D-\u0026gt;B, BC-\u0026gt;D,DC-\u0026gt;A}, 求保存函数依赖的 3NF 的分解\n1）求出最小函数依赖集 2）把不在F里面的属性都找出来，单独分一类 3）把每一个依赖左边相同的分成一类，没有一样的，那么就把A-\u0026gt;D改为{AD}, 如果一样{A-\u0026gt;B,A-\u0026gt;C}那么就改为{ABC} 4）如果候选码没出现在分离里面，把任意一个候选码作为一类\n最先函数依赖集Fmin={A-\u0026gt;D, E-\u0026gt;D, D-\u0026gt;B, BC-\u0026gt;D, DC-\u0026gt;A} GH没在F里面，单独一类{GH} 候选码：CE AE\n{AD}{ED}{DB}{BCD}{DCA}{CE}{GH}\n","date":"2023-02-10T08:13:00+08:00","permalink":"https://blog.yexca.net/archives/90/","title":"数据库学习五 范式"},{"content":" SQL Series\n数据库学习一 数据库导论: https://blog.yexca.net/archives/86 数据库学习二 关系模型: https://blog.yexca.net/archives/87 数据库学习三 SQL 语言: https://blog.yexca.net/archives/88 数据库学习四 关系数据库理论: 本文\n数据库学习五 范式: https://blog.yexca.net/archives/90 数据库学习六 数据库设计: https://blog.yexca.net/archives/91 数据库学习七 数据库的控制功能: https://blog.yexca.net/archives/92 关系模式 一个关系模式应当是一个五元组 (含关系名)\nR\u0026lt;U, D, dom, F\u0026gt;\nR 为关系名，它是符号化的元组语义 U 为一组属性 属性组 U 中的属性来自域 D dom 为属性列表到域的映射 F 为属性组 U 上的一组数据依赖 (函数依赖) 由于第三点与第四点对模式设计关系不大，因此通常把关系模式看作是一个三元组：R\u0026lt;U, F\u0026gt;，当且仅当 U 上的一个关系 r 满足 f 时，r 称为关系模式 R\u0026lt;U, F\u0026gt; 的一个关系\n例如：R 为成绩表，U 为 (学号，姓名，课程号，成绩)，F 为 {学号 → 姓名，课程号 → 课程名，(学号，课程号) → 成绩}\n函数依赖 函数依赖是一种最重要、最基本的数据依赖\n设 R(U) 是属性集 U 上的关系模式，X、Y 是 U 的子集。若对 R(U) 的任何一个可能的关系 r，r 中不可能存在两个元组在 X 上的属性值相等，而在 Y 上的属性值不等，则称 X 函数决定 Y 或 Y 函数依赖于 X。记作 X → Y\n非平凡的函数依赖 如果 X → Y，但 Y ⊈ X，则称 X → Y 是非平凡的函数依赖。一般情况下，总是讨论非平凡的函数依赖\n平凡的函数依赖 如果 X → Y，但 Y ⊆ X，则称 X → Y 是平凡的函数依赖\n完全函数依赖 在 R(U) 中，如果 X → Y，并且对于 X 的任何一个真子集 X\u0026rsquo; 都有 X\u0026rsquo; 不能决定 Y，则称 Y 对 X 完全函数依赖，记作 X -F-\u0026gt; Y\n部分函数依赖 如果 X → Y，但 Y 不完全函数依赖于 X，则称 Y 对 X 部分函数依赖，记作 X -P-\u0026gt; Y。部分函数依赖也称为局部函数依赖\n传递依赖 在 R(U, F) 中，如果 X → Y，Y ⊈ X，Y → Z，则称 Z 对 X 传递依赖\n参考： Untitled Document (pop0726.github.io) 码 设 K 为 R(U, F) 中属性的组合，若 K → U，且对于 K 的任何一个真子集 K\u0026rsquo; 都有 K\u0026rsquo; 不能决定 U，则 K 为 R 的候选码。若有多个候选码，则选一个作为主码。候选码通常也称为候选键，或者候选关键字\n主属性和非主属性 包含在任意一个候选码中的属性称为主属性，否则称为非主属性\n外码 若 R(U) 中的属性或属性组 X 非 R 的码，但 X 是另一个关系的码，则称 X 为外码\n超码 能表示出所有属性的集合，候选码是最小的超码\n全码 所有的属性都是主码\n函数依赖的公理系统 (Armstrong 公理系统) 设关系模式 R(U, F)，其中 U 为属性集，F 是 U 上的一组函数依赖，那么有以下 推理规则\n自反律：若 Y ⊆ X ⊆ U，则 X → Y 为 F 所蕴涵 增广律：若 X → Y 为 F 所蕴涵，且 Z ⊆ U，则 XZ → YZ 为 F 所蕴涵 传递律：若 X → Y，Y → Z 为 F 所蕴涵，则 X → Z 为 F 所蕴涵 根据上述三条推理规则又可推出下述三条推理规则\n合并规则：若 X → Y，X → Z，则 X → YZ 为 F 所蕴涵 伪传递律：若 X → Y，WY → Z 为 F 所蕴涵，则 XW → Z 为 F 所蕴涵 分解规则：若 X → Y，Z ⊆ Y，则 X → Z 为 F 所蕴涵 属性闭包计算 闭包计算即找出候选码，如何选出候选码？\n只出现在左边的一定是候选码 只出现在右边的一定不是候选码 左右都出现的不一定 左右都不出现的一定是候选码 再求确定的候选码的闭包，如果可以推出全部，那么当前确定的就是候选码，否则，你要把每一个可能的值放进当前确定的候选码里面进行求闭包 例如：\nR\u0026lt;U, F\u0026gt;，U(A, B, C, D, E, G) F = {AB → C, CD → E, E → A, A → G}, 求候选码\n1)只出现在左边：B, D 一定是候选码 2)只出现在右边：G 一定不是候选码 3)左右都出现的：A，C，E 不一定是候选码 5)求闭包\nBD → 啥也推不出来，所以要把每一个可能的求闭包 (BDA)+ ：可推出C，E，A，G 所以可以推出ABCDEG (BDC)+ ：可推出E，A，G 所以可以推出ABCDEG (BDE)+ ：可推出A，G，C 所以可以推出ABCDEG\n所以，它的候选码最终是{(BDA),(BDC),(BDE)}\n求最小函数依赖集 如何求最小依赖集？ 1）拆右边为多个元素的（比如A-\u0026gt;BC 拆为 A-\u0026gt;B和A-\u0026gt;C） 2）出去当前元素，求它的闭包，把集合里面所有元素都弄完 3）左边最小化（通过遮住元素来看能不能推出其他元素） 比如BCD，遮住B看能推出CD吗，遮住C看能推出BD吗，遮住D看能推出BC吗\n例： 已知关系 R\u0026lt;U,F\u0026gt; U{A, B, C, D, E, F, G} F = {BCD-\u0026gt;A, BC-\u0026gt;E, A-\u0026gt;F, F-\u0026gt;G, C-\u0026gt;D, A-\u0026gt;G} 求F的最小依赖集\n解：\n// (1)\n(BCD)+ = BCDED\n(BC)+ = BCD\n(A)+ = AG\n(F)+ = F\n(C)+ = C\n(A)+ = AFG（删除，因为有G）\n// (2)\nBCD-\u0026gt;A \u0026mdash;\u0026gt; BC-\u0026gt;A\nBC-\u0026gt;E\nA-\u0026gt;F\nF-\u0026gt;G\nC-\u0026gt;D\n","date":"2023-02-09T08:10:00+08:00","permalink":"https://blog.yexca.net/archives/89/","title":"数据库学习四 关系数据库理论"},{"content":" SQL Series\n数据库学习一 数据库导论: https://blog.yexca.net/archives/86 数据库学习二 关系模型: https://blog.yexca.net/archives/87 数据库学习三 SQL 语言: 本文\n数据库学习四 关系数据库理论: https://blog.yexca.net/archives/89 数据库学习五 范式: https://blog.yexca.net/archives/90 数据库学习六 数据库设计: https://blog.yexca.net/archives/91 数据库学习七 数据库的控制功能: https://blog.yexca.net/archives/92 SQL 语言的分类 DDL (Data Definition Language, 数据定义语言) 在数据库系统中，每一个数据库、数据库中的表、视图和索引等都是数据库的对象，要建立和删除一个数据库对象，都可以通过 SQL 语言来完成。DDL 包括 CREATE、ALTER 和 DROP 等\nDML (Data Manipulation Language, 数据操纵语言) DML 是指用来添加、修改和删除数据库中数据的语句，包括 INSERT、DELETE 和 UPDATE 等\nDQL (Data Query Language, 数据查询语言) 查询是数据库的基本功能，查询操作通过 SQL 数据查询语言来实现。例如，用 SELECT 查询表中的内容\nDCL (Data Control Language, 数据控制语言) DCL 包括数据库对象的权限管理和事务管理等\n(一)、DDL 数据定义语言 1. 建立数据库 1 create database \u0026lt;数据库名\u0026gt; 2. 建立基本表 1 2 3 4 5 6 7 create table \u0026lt;表名\u0026gt; ( \u0026lt;列名\u0026gt; \u0026lt;数据类型\u0026gt; [列级完整性约束条件], [···,] [表级完整性约束条件,] [···] ) \u0026lt;1\u0026gt; 数据类型 INT / INTEGER : 整数 FLOAT(n) : 浮点数，精度至少为 n 位数字 NUMERIC(p, d) / DECIMAL(p, d) / DEC(p, d) : 定点数，由 p 位数字 (不包括符号、小数点) 组成，小数点后面有 d 位数字 CHAR(n) : 长度为 n 的定长字符串 DATETIME : 日期时间型 1 2 3 4 5 6 -- 例如 create table test ( f1 char(10), f2 int ) \u0026lt;2\u0026gt; 列级完整性约束 not null: 不为空\nunique: 唯一\nnot null unique: 不为空且唯一\ndefault: 定义一个默认值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 -- 例如 create table test ( f1 int not null, -- 该列不能为空 f2 int unique, -- 该列值可以为空，但每行应不一样 f3 int not null unique, -- 该列不为空且每行不一样 f4 char(5) default \u0026#39;nashi\u0026#39; -- 若新增行未赋值，此列默认赋值 \u0026#39;nashi\u0026#39; ) \u0026lt;3\u0026gt; 表级完整性约束 名称 子句 对应关系完整性 主键子句 PRIMARY KEY 实体完整性 检查子句 CHECK 用户自定义完整性 外键子句 FOREIGN KEY 参照完整性 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 -- 例如 create table student ( sid int, primary key(sid) -- not null unique ) -- 或者 create table student ( sid int primary key ) create table course ( cid int, sid int, score int, check(score \u0026gt;= 0 and score \u0026lt;= 100), foreign key(sid) references student(sid) ) 对于完整性的检查 断言 (一般不主张用) 1 2 3 4 CREATE ASSERTION \u0026lt;断言名\u0026gt; \u0026lt;check子句\u0026gt; -- 其中check子句与where子句的表达式类似 -- 删除断言名称 DROP ASSERTION \u0026lt;断言名\u0026gt;; 触发器 当对一个表增、删、改的时候，对触发器里面的条件进行检查，如果成立，则执行触发器里面的动作，否则不执行里面的动作。\n1 2 3 4 5 6 7 8 9 10 11 12 13 CREATE TRIGGER \u0026lt;触发器名\u0026gt; -- 每当触发事件发生时，该触发器被激活 {BEFORE|AFTER} \u0026lt;触发事件\u0026gt; ON \u0026lt;表名\u0026gt; -- 指明触发器激活的时间是在执行触发事件前或后 REFERERCING NEW|OLD ROW AS \u0026lt;变量\u0026gt; -- REFERENCING指出引用的变量 FOR EACH{ROW|STATEMENT} -- 定义触发器的类型，指明动作体执行的频率 [WHEN \u0026lt;触发事件\u0026gt;] \u0026lt;触发动作体\u0026gt; -- 仅当触发条件为真时才执行出发动作体 -- 删除触发器 DROP TRIGGER \u0026lt;触发器名\u0026gt; ON \u0026lt;表名\u0026gt; 3. 修改基本表结构 增加一个新列 1 2 3 4 alter table \u0026lt;表名\u0026gt; add \u0026lt;列名\u0026gt; \u0026lt;类型\u0026gt; -- 例如 alter table test add f3 datetime 修改一个列 1 2 3 4 5 6 7 alter table \u0026lt;表名\u0026gt; alter column \u0026lt;列名\u0026gt; \u0026lt;新类型\u0026gt; -- MySQL -- alter table \u0026lt;表名\u0026gt; modify \u0026lt;列名\u0026gt; \u0026lt;新类型\u0026gt; -- 例如 alter table test alter column f3 float -- alter table test modify f3 float 删除一个列 1 2 3 4 5 6 7 alter table \u0026lt;表名\u0026gt; drop column \u0026lt;列名\u0026gt; -- MySQL -- alter table \u0026lt;表名\u0026gt; drop \u0026lt;列名\u0026gt; -- 例如 alter table test drop column f3 -- alter table test drop f3 4. 删除基本表 1 2 3 4 drop table \u0026lt;表名\u0026gt; -- 例如 drop table test (二)、DML 数据操纵语言 以下内容的例子基于这几张表\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 -- 注：为方便理解使用中文，在实际开发中，请尽量不要使用中文 -- 学生表 create table student ( 学号 char(5) not null unique, 姓名 char(8), 性别 char(2), 出生日期 datetime, 班号 char(5) ) -- 成绩表 create table score ( 学号 char(5), 课程号 char(5), 分数 int ) -- 教师表 create table teacher ( 教师编号 char(5) not null unique, 姓名 char(8), 性别 char(2), 出生日期 datetime, 职称 char(6), 系别 char(10) ) -- 课程表 create table course ( 课程号 char(5) not null unique, 课程名 char(20), 任课教师编号 char(5) ) 1. INSERT 插入语句 向 SQL 的基本表中插入数据有两种方式：直接插入元组值 或 插入一个查询的结果值\n直接插入元组值 1 2 3 4 5 6 7 8 9 10 11 12 13 insert into 表名[(列名序列)] values (元组值)[, ···] -- 或者 insert into 表名[(列名序列)] (table (元组值)[, (元组值), ···]) -- 例如 insert into student values (\u0026#39;108\u0026#39;, \u0026#39;张三\u0026#39;, \u0026#39;男\u0026#39;, \u0026#39;2000-01-01\u0026#39;, \u0026#39;09033\u0026#39;), (\u0026#39;109\u0026#39;, \u0026#39;李四\u0026#39;, \u0026#39;男\u0026#39;, \u0026#39;2000-05-05\u0026#39;, \u0026#39;09034\u0026#39;) -- 插入指定列 insert into student(学号，姓名，性别，出生日期) values (110, \u0026#39;王五\u0026#39;, \u0026#39;男\u0026#39;, \u0026#39;2000-04-18\u0026#39;) 插入一个查询的结果值 1 2 3 4 5 insert into 表名[(列名序列)] select \u0026lt;查询语句\u0026gt; -- 例如 insert into student select 111, \u0026#39;赵六\u0026#39;, \u0026#39;男\u0026#39;, \u0026#39;2000-03-19\u0026#39;, \u0026#39;09035\u0026#39; 2. DELETE 删除语句 1 2 3 4 5 6 7 delete from \u0026lt;表名\u0026gt; [where \u0026lt;条件表达式\u0026gt;] -- 例如 delete from student -- 删除整个表的所有内容 -- 删除学号为 111 的元组 delete from student where 学号 = 111 3. UPDATE 修改语句 1 2 3 4 5 6 7 8 9 10 11 12 update \u0026lt;表名\u0026gt; set \u0026lt;列名\u0026gt; = \u0026lt;值表达式\u0026gt;[, ···] [where \u0026lt;条件表达式\u0026gt;] -- 例如 update student set 班号 = \u0026#39;09058\u0026#39; where 学号 = 110 -- 或者 update student set 班号 = \u0026#39;09057\u0026#39;, 性别 = \u0026#39;女\u0026#39; where 学号 = 110 and 班号 = \u0026#39;09058\u0026#39; (三)、DQL 数据查询语言 SQL 数据查询功能是通过 SELECT 语句实现，完整语法如下\n1 2 3 4 5 6 select \u0026lt;目标表的列名或列表达式序列\u0026gt; from \u0026lt;关系表序列\u0026gt; [where \u0026lt;行条件表达式\u0026gt;] [group by \u0026lt;列名序列\u0026gt;] [having \u0026lt;组条件表达式\u0026gt;] [order by \u0026lt;列名\u0026gt; [asc|desc]] 1. 投影查询 使用 SELECT 命令可以选择查询表中的任意列，当为多个列时，中间使用逗号 , 分隔。当 FROM 子句中的关系表不止一个时，每个表的表名都要写出\n1 2 3 4 5 6 7 8 9 -- 例如 select 1 + 1 select 学号 * 100 from student -- 查询学生学号与分数 select student.学号, score.分数 from student, score -- 查询所有列 select * from student 使用 DISTINCT 可以去除重复行\n1 2 3 -- 去除重复行，查询被选修的课程 select distinct 课程号 from score 使用 AS 可为查询结果自定义列名\n1 2 3 -- 例如 select 学号 as \u0026#39;sno\u0026#39; from student 2. 选择查询 选择查询就是指定查询条件，只从源表提取或显示满足该查询条件的记录\n选择查询通常使用下列几类运算：\n运算符 代码 描述 集合成员运算符 IN\nNOT IN 在集合中\n不在集合中 字符串匹配运算符 LIKE 与 _ 和 % 进行单个或多个字符匹配 空值比较运算符 IS NULL\nIS NOT NULL 为空\n不能为空 算数运算符 \u0026gt;\n\u0026gt;=\n\u0026laquo;br /\u0026gt;\u0026lt;=\n=\n\u0026lt;\u0026gt; 大于\n大于等于\n小于\n小于等于\n等于\n不等于 逻辑运算符 AND\nOR\nNOT 与\n或\n非 \u0026lt;1\u0026gt; 条件表达式的比较运算 1 2 3 4 5 6 --- 查询分数在 60-80 之间的记录 select * from score where 分数 between 60 and 80 -- 使用 between 指包含 60 与 80，即 [60, 80] -- 等价于 where 分数 \u0026gt;= 60 and 分数 \u0026lt;= 80 \u0026lt;2\u0026gt; 字符串的匹配运算 1 where [not] like \u0026#39;匹配串\u0026#39; [escape \u0026#39;匹配串\u0026#39;] 其中 '匹配串' 可以是完整字符串，也可以包含通配符 % 和 _\n% : 代表任意长度的字符 _ : 代表任意单个字符 \u0026lt;3\u0026gt; 集合的比较运算 1 2 3 4 -- 查询成绩为 85、86 或 88 的记录 select * from score where 分数 in (85, 86, 88) \u0026lt;4\u0026gt; 逻辑组合运算 1 2 3 4 -- 查询 09031 班的所有女学生 select * from student where 班号 = \u0026#39;09031\u0026#39; and 性别 = \u0026#39;女\u0026#39; 3. 排序查询 通过使用 ORDER BY 子句可以对查询结果进行排序\n1 2 3 4 5 6 7 8 -- 升序 asc (默认，可省略) select 学号, 姓名 from student order by 学号 -- 降序 desc select 学号, 姓名 from student order by 学号 desc 也可以指定多个列排序，将会先排序第一个，然后排序第二个\n1 2 3 4 -- 以课程号升序，分数降序检索结果 select * from score order by 课程号 asc, 分数 desc ORDER BY 子句必须放在查询的最后！\n4. 聚合函数 聚合函数实现数据统计等功能，用于对一组值进行计算并返回单一的值\n通常与 group by 子句一起使用，常用的聚合函数有：\n函数名 描述 AVG 平均值 COUNT 计算指定表达式中选择的项数\nCOUNT(*) 统计查询输出的行数 MIN 最小值 MAX 最大值 SUM 数值总和 STDWV 计算指定表达式中所有数据的标准差 STDEVP 总体标准差 聚合函数参数的一般格式为：\n1 [all|distinct] expr 其中 ALL 表示对所有值进行聚合函数运算，默认值。而 DISTINCT 指定每个唯一值都被考虑。expr 为表达式\n1 2 3 4 -- 查询 \u0026#39;09031\u0026#39; 班学生人数 select count(*) as \u0026#39;人数\u0026#39; from student where 班号 = \u0026#39;09031\u0026#39; 5. 数据分组 因为聚合函数只会输出一个结果，查询某个列和聚合函数放一起时会报错\n可以通过数据分组计算某一个类别的聚合函数结果，即聚合函数作用范围变成了每组的所有记录\n如果想使用聚合函数作为筛选条件，必须放在 HAVING 子句后\n1 2 3 4 5 6 -- 查询最低分大于 70，最高分小于 90 的学生学号 select 学号 from score where 分数 is not null group by 学号 having min(分数) \u0026gt; 70 and max(分数) \u0026lt; 90 当 WHERE 子句、GROUP BY 子句、HAVING 子句和聚合函数同时出现在一个查询中时，SELECT 命令的执行顺序如下：\n执行 WHERE 子句，从表中选取行 由 GROUP BY 对选取的行进行分组 执行聚合函数 执行 HAVING 子句选取满足条件的分组 1 2 3 4 -- 查询每个课程的平均分 select 课程号, avg(分数) from score group by 课程号 聚合函数作为条件只能放在 HAVING 子句后，不能放在 WHERE 子句后\n当 SELECT 子句中由 列名 与 聚合函数 时，所有的 列名 都应该被分组\n6. 表的连接查询 在 FROM 子句中指定要连接的表，在 WHERE 子句中给出连接条件\n1 2 3 select \u0026lt;列名1\u0026gt;[, ···] from \u0026lt;表1\u0026gt;[, ···] where 连接条件 对于两个表的公共列，需要提供前缀，例如 student.学号\n在 SQL Server 中，连接分为内连接和外连接\n\u0026lt;1\u0026gt; 内连接 INNER JOIN Θ 连接，等值连接，自然连接\n内连接是最基本的连接方式，使用 INNER JOIN 关键字，不使用该关键字时默认均为内连接\n等值连接 即两个表之间的连接关系为 \u0026ldquo;等于\u0026rdquo;\n1 2 3 4 5 6 7 8 9 -- 查询所有学生的姓名、课程号和分数列 select student.姓名, score.课程号, score.分数 from student, score where student.学号 = score.学号 -- 即 select student.姓名, score.课程号, score.分数 from student inner join score on student.学号 = score.学号 为简化输入，可以使用表的别名\n1 2 3 4 -- 上一个例子的简化 select x.姓名, y.课程号, y.分数 from student x, score y where x.学号 = y.学号 非等值连接 即两个表之间的连接关系不是 \u0026ldquo;等于\u0026rdquo;\n自连接 将同一个表进行连接，这种连接称之为自连接\n1 2 3 4 5 6 -- 查询选修了 \u0026#39;3-105\u0026#39; 并且成绩高于 \u0026#39;109\u0026#39; 号同学成绩的学生记录 select x.课程号, x.学号, x.分数 from score x, score y where x.课程号 = \u0026#39;3-105\u0026#39; and x.分数 \u0026gt; y.分数 and y.学号 = \u0026#39;109\u0026#39; and y.课程号 = \u0026#39;3-105\u0026#39; order by x.分数 desc \u0026lt;2\u0026gt; 外连接 OUTER JOIN 左外连接 : LEFT OUTER JOIN 或 LEFT JOIN\n右外连接 : RIGHT OUTER JOIN 或 RIGHT JOIN\n全外连接 : FULL OUTER JOIN 或 FULL JOIN\n1 2 3 4 5 -- 左外连接例子 -- 查询所有课程的任课教师的姓名 select course.课程名, teacher.姓名 from course left join teacher on (course.任课教师编号 = teacher.教师编号) 7. 子查询 \u0026lt;1\u0026gt; 一般子查询 当一个查询是另一个查询的条件时，换言之，当从表中选取数据行的条件依赖于该表本身或其他表的联合信息时，需要使用子查询来实现\n子查询最常用于 SELECT 语句中的 WHERE 子句中\n1 2 3 4 5 6 7 8 -- 查询与学号为 \u0026#39;105\u0026#39; 的同学同年出生的学生 select 学号, 姓名, year(出生日期) as \u0026#39;出生年份\u0026#39; from student where year(出生日期) = ( select year(出生日期) from student where 学号 = \u0026#39;105\u0026#39; ) \u0026lt;2\u0026gt; 相关子查询 在一般子查询中，每个子查询仅执行一次，返回的值为主查询的 WHERE 子句所用。\n当主查询在判断每个待选行时，必须 \u0026ldquo;唤醒\u0026rdquo; 子查询，然后反馈给主查询。即内层的条件涉及到外层属性的子查询称为相关子查询\n1 2 3 4 5 6 7 8 9 -- 查询成绩比该课程平均成绩低的学生 select 学号, 课程号, 分数 from score a where 分数 \u0026lt; ( select avg(分数) from score b where a.课程号 = b.课程号 and 分数 is not null ) \u0026lt;3\u0026gt; 带 EXISTS 测试的子查询 EXISTS 代表存在量词 ∃，只返回逻辑真值或逻辑假值\n1 2 3 4 5 6 7 8 -- 查询所有任课教师的姓名和系别 select 姓名, 系别 from teacher a where exists ( select * from course b where a.教师编号 = b.任课教师编号 ) 或者还有 NOT EXISTS ，将结果取反\n8. 查询结果的并、交、差运算 可以使用以下运算符将两个 SELECT 查询语句的结果进行相应运算\nUNION : 并 INSTERSECT : 交 EXCEPT : 差 1 2 3 4 5 6 7 8 -- 并的例子 -- 查询所有教师和学生的姓名、性别和出生年份 select 姓名, 性别, year(出生日期) as \u0026#39;出生年份\u0026#39; from teacher union select 姓名, 性别, year(出生日期) as \u0026#39;出生年份\u0026#39; from student -- order by 出生年份 (四)、DCL 数据控制语言 数据控制控制的是用户对数据的存储权力，是由 DBA (数据库管理员) 决定的\n数据库的安全性 不安的因素：\n非授权对数据库的恶意存取和破坏 数据库中重要的数据泄露 安全环境的脆弱性 安全性控制：\n用户身份鉴别：静态口令鉴别、动态口令鉴别、生物特征鉴别、智能卡鉴别 存取控制 自主存取控制方法 (用户可以自定义和分配其他用户的操作权限) 自主存取控制 DBMS (数据库管理系统) 数据控制应具有以下功能\n通过 GRANT 和 REVOKE 将授权通知系统，并存入数据字典 当用户提出请求时，根据授权情况检查是否执行操作请求 SQL 标准包括 DELETE 、INSERT 、SELECT 和 UPDATE 权限。SELETE 权限对应于 READ 权限，SQL 还包括了 REFERENCES 权限，用来限制用户在创建关系时定义外码的能力\n1. 授权的语句格式 1 2 3 4 grant \u0026lt;权限\u0026gt;[, ···] on \u0026lt;对象类型\u0026gt; \u0026lt;对象名\u0026gt;[, ···] to \u0026lt;用户\u0026gt;[, ···] [with grant option] 不同类型的操作对象有不同的权限，常见的权限如下\n对象 对象类型 操作权限 属性列 TABLE SELECT、INSERT、UPDATE、DELETE、\nALL PRIVILEGES (4 种权限的总和) 视图 TABLE SELECT、INSERT、UPDATE、DELETE、\nALL PRIVILEGES (4 种权限的总和) 基本表 TABLE SELECT、INSERT、UPDATE、DELETE、ALTER、INDEX\nALL PRIVILEGES (6 种权限的总和) 数据库 DATABASE CREATETAB 建立表的权限，可由 DBA 授予普通用户 PUBLIC : 接受权限的用户可以是单个或多个具体的用户，PUBLIC 参数可将权限赋给全体用户 WITH GRANT OPTION : 若指定了此子句，那么获得了权限的用户还可以将权限赋给其他用户 2. 收回权限语句格式 1 2 3 revoke \u0026lt;权限\u0026gt;[, ···] on \u0026lt;对象类型\u0026gt; \u0026lt;对象名\u0026gt;[, ···] from \u0026lt;用户\u0026gt;[, ···] 数据库的角色 角色指的时一类人，比如 CEO、总监、普通职员，可以给一类人授权\n角色的创建 1 create role \u0026lt;角色名\u0026gt; 角色授权 1 grant \u0026lt;权限\u0026gt; on \u0026lt;对象类型\u0026gt; \u0026lt;对象名\u0026gt; to \u0026lt;角色1\u0026gt;[, ···] 把角色授权给其他用户或角色 1 2 grant \u0026lt;角色\u0026gt; to \u0026lt;角色\u0026gt;或\u0026lt;用户名字\u0026gt; [with admin option] with admin option 意味着这个用户可以把这权限授予其他角色或用户\n角色权限的收回 1 revoke \u0026lt;权限\u0026gt; on \u0026lt;对象名\u0026gt; from \u0026lt;角色名字\u0026gt; 视图机制 视图是从一个或者多个基本表或视图中导出的表，是一个虚拟表\n为不同的用户定义不同的视图，把不需要的数据给隐藏起来，这样用户就不会进行误操作\n视图的创建 1 2 3 create view \u0026lt;视图名(列表名)\u0026gt; as select \u0026lt;查询子句\u0026gt; [with check option] 子查询的 SELECT 语句通常不允许含有 ORDER BY 子句和 DISTINCT 语句 WITH CHECK OPTION 表示对 UPDATE 、INSERT 、DELETE 操作时保证被操作的行满足视图定义中的谓语条件 (即子查询中的条件表达式) 组成视图的属性列名或者全部省略或者全部指定。如果省略，则隐含该视图由 SELECT 子查询目标列的主属性组成 1 2 3 4 5 6 7 8 -- 关系模式：student(sno, sname, sex, SD, email) -- 建立 \u0026#39;计算机系 (CS)\u0026#39; 学生的视图，并且进行修改操作时 -- 保证视图中只有计算机系的学生会受到影响 create view cs-student as select sno, sname, sex from student where SD = \u0026#39;CS\u0026#39; with check option 视图的删除 1 2 3 4 drop view \u0026lt;视图名\u0026gt; --例如 drop view cs-student 审计 把对数据库的所有操作都记录到审计日志中，然后就可以通过日志审查这个里面是否有一些非法的行为\n1 2 3 4 -- 对修改“SC”数据的操作进行审计 AUDIT UPDATE ON SC; -- 取消对“SC”表的一切审计 NOAUDIT UPDATE ON SC; 数据加密 通过一些加密算法，把明文变成密文，这样别人就无法查看\n索引 利用索引可以使数据库程序无需对整个表进行扫描，就可以在其中找到所需数据\n数据库中的索引是某个表中一列或者若干列值的集合和相应的指向表中物理标识这些值的数据页的逻辑指针清单\n由内模式定义 (内模式定义所有的内部记录类型、索引和文件的组织方式)\n建立索引 1 2 create [unique] [cluster] index \u0026lt;索引名\u0026gt; on \u0026lt;表名\u0026gt;(列名[次序], ···) 次序：可选 ASC (默认) 或 DSC\nUNIQUE ：表明此索引的每一个索引值只对应唯一的数据记录\nCLUSTER ：表明要建立的索引是聚簇索引，意为索引项的顺序是与表中记录的物理顺序一致的索引组织\n删除索引 1 drop index \u0026lt;索引\u0026gt; ","date":"2023-02-08T08:00:00+08:00","permalink":"https://blog.yexca.net/archives/88/","title":"数据库学习三 SQL 语言"},{"content":" SQL Series\n数据库学习一 数据库导论: https://blog.yexca.net/archives/86 数据库学习二 关系模型: 本文\n数据库学习三 SQL 语言: https://blog.yexca.net/archives/88 数据库学习四 关系数据库理论: https://blog.yexca.net/archives/89 数据库学习五 范式: https://blog.yexca.net/archives/90 数据库学习六 数据库设计: https://blog.yexca.net/archives/91 数据库学习七 数据库的控制功能: https://blog.yexca.net/archives/92 关系模型中的基本术语 关系数据库系统是支持关系模型的数据库系统。有关关系模型的的一些基本术语如下：\n关系：一个关系就是一张二维表，每个关系有一个关系名 元组：表中的一行即为一个元组，对应存储文件中的一个记录值 属性：表中的列称为属性，每一列有一个属性名，属性值相当于记录中的数据项或者字段值 域：属性的取值范围，即不同元组对同一个属性的值所限定的范围 关系模式：对关系的描述称为关系模式，由关系名和其属性集合构成，关系模式的格式为：关系名(属性名 1，···，属性名 n) 通常一个关系模式对应一个关系文件的结果\n候选码 (候选键)：属性或属性组合，其值能够唯一地标识一个元组 主码 (主键)：在一个关系中可能有多个候选码，从中选择一个作为主码 主属性：包含在任何候选码中的属性称为主属性，不包含在任何候选码中的属性称为非主属性 外码 (外键)：如果一个关系中的属性或属性组并非该关系的码，但他们是另外一个关系的码，则称其为该关系的外码 全码：关系模式的所有属性组是这个关系模式的候选码，称为全码 超码 (超键)：一个包含码的属性集称为超码 关系模型的定义 关系的描述称为关系模式，他可以形式化地表示为：R(U, D, dom, F)\n其中 R 为关系名，U 为组成该关系的属性名集合，D 为属性组 U 中属性所来自的域，dom 为属性向域的映像集合，F 为属性间数据的依赖关系集合\n通常简记为 R(U) 或 R($A_1$, $A_2$, ···)，其中 R 为关系名，U 为属性名集合，$A_1$、··· 为个属性名\n关系模型由关系数据结构、关系操作集合和关系完整性约束三部分组成\n关系数据结构 关系模型中数据的逻辑关系是一张二维表格\n关系操作集合 关系模型给出了关系操作的能力\n常见的关系操作有：选择、投影、连接、除、并、交、差等查询操作和增加、删除操作等\n关系完整性约束 关系模型中的三个完整性规则如下：\n实体完整性：关系中主码的值不能为空或部分为空，也就是说，主码中属性即主属性不能取空值 参照完整性：如果关系 $R_2$ 的外码 X 与关系 $R_1$ 的主码相对应 (基本关系 $R_1$ 和 $R_2$ 不一定是不同的关系，即它们可以是同一个关系)，则外码 X 的每一个值必须在关系 $R_1$ 中主码的值中找到，或者为空值 用户定义的完整性：指用户对某一具体数据指定的约束条件进行检验 关系代数运算符 运算符 符号 含义 集合运算符 ∪\n–\n∩\n× 并\n差\n交\n笛卡尔积 专门的关系运算符 σ\nπ\n⋈\n÷ 选择\n投影\n连接\n除 比较运算符 ＞\n≥\n＜\n≤\n＝\n≠ 大于\n大于等于\n小于\n小于等于\n等于\n不等于 逻辑运算符 ¬\n∧\n∨ 非\n与\n或 传统的集合运算 专门的关系运算符 连接 连接有 θ 连接、等值连接与自然连接\nθ 连接：连接条件不为等于 等值连接：连接条件为等于 自然连接：除去重复属性的等值连接。最常用的连接运算 投影 投影运算是从关系的垂直方向进行运算，在关系 R 中选出若干属性列 A 组成新的关系，记作 $π_A(R)$\n选择 选择运算是从关系的水平方向进行运算，是从关系 R 中选择满足给定条件的元组，记作 $σ_F(R)$\n外连接 外连接运算是连接运算的扩展，可以处理由于连接运算而缺失的信息\n左外连接：取出左侧关系中所有与右侧关系中任一元组都不匹配的元组，用空值 null 填充所有来自右侧关系的属性 有外连接：取出右侧关系中所有与左侧关系中任一元组都不匹配的元组，用空值 null 填充所有来自左侧关系的属性 全外连接：完成左外连接和右外连接的操作 除法 符号转 SQL 语言 关系 R:\nA B C 1 2 3 4 5 6 7 8 9 投影转 SQL 语言 $π_?(?)$\n1 select ? from ? $π_{A, B, C}(R)$ 或者 $π_{1, 2, 3}(R)$\n1 select A, B, C from R 注：SQL 语言不支持列 (属性) 的序号\n选择转 SQL 语言 $π_?(σ_?(?))$\n1 select ? from ? where ? $π_{A, B, C}(σ_{B \u0026gt;= \u0026lsquo;5\u0026rsquo;}(R))$ 或者 $π_{1, 2, 3}(σ_{2 \u0026gt;= \u0026lsquo;5\u0026rsquo;}(R))$\n1 2 3 select A, B, C from R where B \u0026gt;= \u0026#39;5\u0026#39; # 或者 select A, B, C from R where B \u0026gt;= 5 笛卡尔积转 SQL 语言 $π_{R.A, R.B, R.C, S.A, S.B, S.D}(R×S)$\n1 2 3 4 select R.A, R.B, R.C, S.A, S.B, S.D from R, S # 升序排列 order by R.A asc 自然连接转 SQL 语言 关系 R(A, B, C) 与 S(B, C, D)\n$π_{R.A, R.B, R.C, S.D}(σ_{R.B = S.B ∩ R.C = S.C}(R×S))$\n1 2 3 select R.A, R.B, R.C, S.D from R, S where R.B = S.B and R.C = S.C ","date":"2023-02-07T06:00:00+08:00","permalink":"https://blog.yexca.net/archives/87/","title":"数据库学习二 关系模型"},{"content":"引言 之前数据库的写的很不好看，重新复习编写一下 (虽然这个也挺乱就是了)\nSQL Series\n数据库学习一 数据库导论: 本文\n数据库学习二 关系模型: https://blog.yexca.net/archives/87 数据库学习三 SQL 语言: https://blog.yexca.net/archives/88 数据库学习四 关系数据库理论: https://blog.yexca.net/archives/89 数据库学习五 范式: https://blog.yexca.net/archives/90 数据库学习六 数据库设计: https://blog.yexca.net/archives/91 数据库学习七 数据库的控制功能: https://blog.yexca.net/archives/92 数据库的四个基本概念 数据 描述事物的符号记录\n数据库 概括地讲，数据库数据具有永久存储、有组织和可共享的三个基本特点\n严格地讲，数据库是长期储存在计算机内、有组织的、可共享的大量数据的集合。数据库中的数据按一定的数据模型组织、描述和储存，具有较小的冗余度、较高的数据独立性和易拓展性，并可为各种用户共享\n数据库管理系统 是位于用户和操作系统之间的一层数据管理软件。和操作系统一样是计算机的基础软件\n主要功能：\n数据定义功能\n数据组织、存储和管理\n数据操纵功能\n数据库的事务管理和运行管理\n数据库的建立和维护功能\n其他功能（通信功能，数据转换功能，互访和互操作功能等）\n数据库系统 是由数据库、数据库管理系统（及其应用开发工具）、应用程序和数据库管理员（DBA）组成的存储、管理、处理和维护数据的系统\n计算机数据管理的发展 人工管理阶段 (20 世纪 50 年代中期以前) 数据不保存、不共享，不具有独立性\n文件系统阶段 (20 世纪 50 年代后期至 60 年代中后期) 可保存，但共享性差，冗余度大，独立性差\n数据库系统阶段 (20 世纪 60 年代 后期开始) 数据库系统的出现使信息系统从以 加工数据的程序为中心 转向围绕 共享的数据库 为中心的新阶段，实现整体数据的结构化\n数据的共享性高、冗余度低且易扩充：数据可以大大减少数据冗余，节约存储空间，数据独立性高\n数据模型的分类 根据模型应用的不同目的，可将模型分成两类或者两个层次，从信息世界中抽象的数据模型称为概念数据模型，从计算机世界中抽象出的 DBMS (数据库管理系统) 支持的数据模型称为结构数据模型 (或者数据模型)\n概念数据模型 (概念模型) 概念数据模型是独立于计算机系统的模型，完全不涉及信息在系统中的表示，只是用来描述某个特定组织所关心的信息结构，即按照用户的观点来对数据和信息建模，用于信息世界建模，一般采用实体 - 联系方法 (E-R 方法) 表示。主要用于数据库设计\n概念数据模型中的几个常用术语如下：\n实体：客观存在并可以相互区别的事物称为实体\n属性：描述实体的特性称为属性\n码：唯一标识实体的属性集称为码\n实体型：用实体名及其属性集合来抽象和刻画同类实体\n实体集：同一类型实体的集合\n域：属性的取值范围称为该属性的域\n联系：实体之间的对应关系称为联系\n两个实体之间的联系有三种类型\n一对一联系 一对多联系 多对多联系 实体 - 联系方法表示的概念数据模型称为 E-R 图。实体用矩形，属性用椭圆，并用无向边将其与有关实体连接\n结构数据模型 (逻辑模型) 结构数据模型是直接面向数据库的逻辑结构，任何一个 DBMS 都以某个结构数据模型为基础。主要用于数据库管理系统的实现\n结构数据模型主要包括：层次、网状、关系和面向对象模型\n层次模型 层次模型是用 \u0026ldquo;树结构\u0026rdquo; 来表示数据之间的联系，它的数据结构是一颗 \u0026ldquo;有向树\u0026rdquo;\n网状模型 网状模型是用 \u0026ldquo;图结构\u0026rdquo; 来表示数据之间的联系\n关系模型 关系模型是一种用二维表格结构来表示实体以及实体之间联系的数据模型。每个二维表由行、列组成，又可称为关系，关系模式是对关系的描述。因此可以说，关系模型是由关系模式组成的集合\n物理模型 是对数据最底层的抽象，它描述数据在系统内部的表述方法和存取方法，或在磁盘或磁带上的存储方式和存取方法，是面向计算机系统的\n数据库系统的结构 数据库产品很多，存储结构也各不相同，但体系结构基本上都具有相同的特征，采用 \u0026ldquo;三级模式和两级映像\u0026rdquo;\n三级模式 概念模式 (基本表) 也称为模式或逻辑模式，是数据库中全部数据的逻辑结构和特征的描述，是所有用户的公共数据视图\n外模式 (视图) 也称为用户模式或子模式，是用户与数据库系统的接口，是用户用到的那部分数据的描述\n内模式 (存储文件) 也称存储模式，一个数据库只有一个内模式。它是数据物理结构和存储方式的描述，是数据在数据库内部的组织方式\n两级映像 数据库系统在三级模式之间提供了两级映像：模式/内模式映像、外模式/模式映像\n正因为这两级映像保证了数据库中的数据具有较高的逻辑独立性和物理独立性\n模式/内模式映像 (存储) 存在于概念级和内部级之间，实现了概念模式和内模式之间的相互转换\n当数据库的存储结构改变时，有数据库管理员对模式 / 内模式作相应改变，可以使模式保持不变，从而应用程序也不用改变。保证了数据与程序的物理独立性\n外模式/模式映像 (视图) 存在于外部级和概念级之间，实现了外模式和概念模式之间的相互转换\n当模式改变时，由数据库管理员对各个外模式 / 模式映像作相应改变，可以使外模式保持不变。应用程序不必修改。保证了数据与程序的逻辑独立性\n数据的独立性是指数据与程序独立，将数据的定义从程序中分离出去。数据的独立性是由 DBMS 的二级映像功能来保证的。数据的独立性包括数据的物理独立性和数据的逻辑独立性\n数据的物理独立性：指用户的应用程序与数据库中数据的物理存储是相互独立的\n数据的逻辑独立性：指用户的应用程序与数据库中的逻辑结构是相互独立的\n数据与程序之间的独立性使得数据的定义和描述可以从应用程序中分离出去。另外，由于数据的存取由数据库管理系统管理，从而简化了应用程序的编制，大大减少了应用程序的维护和修改\n数据库系统的组成 硬件平台及数据库 足够大的内存、磁盘或磁盘阵列等设备，较高的通道能力以提高数据的传送率\n软件 数据库管理系统，支持数据库管理系统运行的操作系统，具有与数据库接口的高级语言及其编译系统，以数据库管理系统为核心的应用开发工具，为特定应用环境开发的数据库应用系统\n人员 开发、管理和使用数据库的人员主要包括数据库管理员、系统分析员和数据库设计人员、应用程序员和最终用户\n数据库管理员职责：决定数据库中信息内容和结构、决定数据库的存储结构和存取策略、定义数据的安全性要求和完整性约束条件、监控数据库的使用和运行、数据库的改进和重组、重构\n","date":"2023-02-06T19:57:35+08:00","permalink":"https://blog.yexca.net/archives/86/","title":"数据库学习一 数据库导论"},{"content":"第十二章 管理磁盘和文件系统 12.1 了解磁盘存储器 在大多数现代操作系统中，数据存储器的基本工作原理都是相同的。磁盘用作永久存储器，而 RAM (Random Access Memory，随机存储器) 和交换区则用作临时存储器。例如，当运行一条命令时，该命令将从硬盘复制到 RAM，以便计算机处理器 (CPU) 可以更快地访问该命令\n相对于从硬盘中访问数据，CPU 可以更快地从 RAM 中访问数据。但因为 RAM 造价过高，且断电即清除数据，磁盘容量是远大于 RAM 的\n当运行太多进程或运行了一个带有内存泄漏的进程而将 RAM 填满时，如果系统没有提供一种拓展系统内存的方法，则会导致新进程失败，于是便有了交换空间。采用一些算法将一些数据从 RAM 中换到磁盘中，在需要时再换回去\n当需要在不同类型的操作系统之间交换文件时，通常采用 VFAT 文件系统\n12.2 对硬盘进行分区 更改分区可能导致系统无法启动，建议先拿空硬盘熟练掌握后再实际应用\n12.2.1 理解分区表 从传统上将，PC 体系结构的计算机使用 MBR (Master Root Record) 分区表来存储关于硬盘分区大小和布局信息。然而，近年来，一种被称为 GUID (Global Unique Identifier) 分区表的新标准在部分 UEFI 计算机体系结构的计算机上得到了应用，从而取代了较老的 BIOS 系统启动方法\nMBR 规范所固有的局限性带来了对 GUID 分区的需求。MBR 分区的大小被限制在 2TB，而 GUID 分区可以创建最大 9.4ZB 的分区\nfdisk 命令不支持 gpt 分区，可以使用 parted 命令\n12.2.2 查看磁盘分区 fdisk -l /dev/sda 或 parted -l /dev/sdb\n由 sd? 设备 (如 sda 、sdb 等) 所表示的 SCSI 或者 USB 存储设备最多可以有 16 个次要设备 (比如主 /dev/sdc 设备以及 /dev/sdc1 到 /dev/sdc15) ，所以共有 15 个分区\n由 nvme 设备 (如 nvme0 、nvme1 等) 所表示的 NVMe SSD 存储设备可以划分一个或多个名称空间 (大多数设备只使用第一个) 和分区，例如 /dev/nvme0n1p1 表示第一个 nvme 设备上第一个名称空间的第一个分区\n对于 x86 计算机，磁盘最多可以有 4 个主分区。所以如果想要 4 个以上的分区，至少有一个分区时扩展分区。四个主分区外的任何分区都是逻辑分区，使用了来自拓展分区的空间\n12.2.3 创建单分区硬盘 一般添加一个存储介质的过程：\n安装新的硬盘或插入新的 USB 闪存驱动器\n对新硬盘进行分区\n在新硬盘上创建文件系统\n挂载文件系统\n如果使用 parted 命令进行修改，请谨慎执行每一步，因为 parted 命令的更改是立即生效的 而 fdisk 命令是可撤销的，只有在确定应用更改时才会实际更改\n数据无价，谨慎操作\n确定新增加的设备的名称 方法有许多，例如查看系统日志\njournalctl -f\n例如分配的名称为 /dev/sdb\n如果设备自动挂载需要先卸载 查看是否挂载 /dec/sdb：mount | grep sdb\n卸载分区：umount /dev/sdb1\n使用 parted 命令创建分区 parted /dev/sdb\n执行后将处于 parted 命令模式，可以使用 parted 单字母命令设置来使用分区\n删除分区 单命令 p 列出所有分区\n使用 rm 命令，回车后输入相应 Number 即可删除某分区\n创建 gpt 分区表 使用命令 mklabel gpt\n创建新分区 输入 mkpart 命令，系统会提示输入分区名称，文件系统类型，然后是分区的开始和结束\n例如命名 yexca-UDisk ，文件类型为 xfs ，分区从 1MB 开始，到 123GB 结束：\n1 2 3 4 5 (parted) mkpart Partition name? []? yexca-UDisk File system type? [ext2]? xfs Start? 1 End? 123GB 检查分区是否正确创建 单命令 p 列出所有分区\n分区创建完成后需要在分区上创建文件系统 例如创建 xfs 文件系统：mkfs -t xfs /dev/sdb1\n若没有 -t 选项，默认创建 ext2 文件系统\n挂载文件系统 1 2 3 4 # 创建挂载文件夹 mkdir /mnt/tmp # 挂载 /dev/sdb1 到 /mnt/tmp mount /dev/sdb1 /mnt/tmp 卸载文件系统 使用命令 umount /dev/sdb1\n默认情况下一般插入 USB 设备会自动挂载\n如果需要手动挂载，可在 /etc/fstab 添加一行\n1 /dev/sdb1 /mnt/tmp xfs defaults 0 1 共六段\n分区\n挂载的文件夹\n文件系统\n分区启动时挂载\n是否使用 dump 命令备份分区文件 (0 为不备份)\n在一定的挂载数量之后对分区进行错误检查\n12.2.4 创建一个多分区磁盘 使用 fdisk 命令介绍\n进入 fdisk 命令模式 fdisk /dev/sdb\n创建分区 单命令 n ，然后选择主分区 p 或拓展分区 e ，选择分区位置 (默认即可)\n然后是分配的空间，起始空间可以默认，回车后输入结尾空间：例如分配 5 GB 空间则输入 +5G ，若直接输数字则会被认为是扇区\n第四个分区，即拓展分区，分配空间可以两次都是默认\n检查分区 单命令 p\n默认的分区类型是 Linux ，如果想要转换分区类型 使用命令 t ，选择分区数，然后输入 L 查看分区类型列表，找到十六进制码，然后输入以更改\n检查更改并保存更改 单命令 p 以检查，单命令 w 以保存更改\n更改完毕后，检查内核是否知道对分区表的更改 1 2 3 4 5 grep sdb /proc/partitions # 如果没有输出预料的结果，执行以下命令 partprobe /dev/sdb # 再次检查 grep sdb /proc/partitions 创建文件系统 1 2 3 4 5 6 7 8 9 10 # 创建 ext4 文件系统 mkfs -t ext4 /dev/sdb1 # 创建交换区 mkswap /dev/sdb2 # 创建 ext2 文件系统 (默认值) mkfs /dev/sdb3 # 创建 VFAT 文件系统 mkfs -t vfat /dev/sdb4 # 使该分区称为 LVM 物理卷 pvcreate /dev/sdb5 12.3 使用逻辑卷管理分区 如果磁盘空间不足，恐怕只能将数据复制到另一个更大的磁盘中，但该过程需要停机且效率低下\nLVM (Logical Volume Management ，逻辑卷管理) 可采用灵活且高效的方式处理更改存储器的需求。通过使用 LVM ，可将物理磁盘分区添加到被称为 卷组 的空间池。逻辑卷根据需要从卷组分配空间\n12.3.1 检查现有的 LVM 使用命令 fdisk -l /dev/sda 查看是否存在 Linux LVM 分区，假设 /dev/sda2 为 LVM 分区\n查看该 LVM 分区是否在 LVM 组中使用\npvdisplay /dev/sda2\n假设卷组 (VG Name) 是 vg_abc ，查看卷组的信息\nvgdisplay vg_abc\n可以从物理卷使用的最小存储单位是 PE (Physical Extent) Size\n查看卷组的 PE 分配的位置\nlvdisplay vg_abc\n输出将展示多个逻辑卷名称，这些逻辑卷可以和物理卷一样直接使用名字进行挂载\n12.3.2 创建 LVM 逻辑卷 LVM 逻辑卷的使用是自上而下进行的，而创建 LVM 逻辑卷的过程则是从下而上进行。首先创建一个或多个物理卷 (pv) ，然后使用物理卷创建卷组 (vg) ，最后从卷组创建逻辑卷 (lv)\n准备一个有 LVM 分区的存储设备 创建过程 12.2.4 有提及\n将该物理卷加入卷组 vgcreate myvg0 /dev/sdb5\n查看卷组 vgdisplay myvg0\n若分区为 400M ，可以使用 396M 空间 (以 4M 为单位) 1 2 3 4 5 6 # 从卷组部分空间创建一个逻辑卷，例如创建 1G 逻辑卷 lvcreate -n name -L 1G myvg0 # 查看该逻辑卷是否存在 ls /dev/mapper/myvg0* # 输出以下则创建成功 /dev/mapper/myvg0-name 放入文件系统并挂载 1 2 3 4 5 6 7 8 # 创建 ext4 文件系统 mkfs -t ext4 /dev/mapper/myvg0-name # 创建挂载文件夹 mkdir /mnt/tmp # 挂载 mount /dev/mapper/myvg0-name /mnt/tmp # 检查是否挂载成功 df -h /mnt/tmp 或者也可以写入 /etc/fstab 以自动挂载 12.3.3 扩大 LVM 逻辑卷 如果用完了逻辑卷的空间，可添加空间而不必卸载该逻辑卷。为此，卷组中必须有可用的空间，然后扩大逻辑卷\n检查剩余空间 1 2 3 4 # 检查卷组可用空间 vgdisplay myvg0 # 检查逻辑卷可用空间 df -h /mnt/tmp 拓展逻辑卷 lvextend -L +1G /dev/mapper/myvg0-name\n调整文件系统大小 resize2fs -p /dev/mapper/myvg0-name\n检查是否调整成功 df -h /mnt/tmp\n12.4 挂载文件系统 事实上在上两节中已经涉及了挂载文件系统命令 mount 已经自动挂载配置 (文件 /etc/fstab)\n12.4.1 被支持的文件系统 输入命令 cat /proc/filesystems 以查看支持的文件系统类型，以下仅部分\n文件系统 描述 ext4 流行的 ext3 文件系统的继承者。支持最大 1EB 的卷以及最大 16 TB 的文件 iso9660 从 High Sierra 文件系统 (CD-ROM 的原始标准) 演变而来。数据 CD-ROM 通常使用该文件系统 Minix 最初用于 UNIX 的 Minix 版本。支持最多只有 30 个字符的文件名 msdos MS-DOS 文件系统类型，可用于挂载来自 Windows 操作系统的软盘 vfat Microsoft 扩展的 FAT 文件类型 exfat 为 SD 卡、USB 驱动器和其他闪存优化的扩展 FAT 文件系统 proc 不是真正的文件系统。是一个 Linux 内核的文件系统接口。/proc 的挂载点应该是一个 proc 文件系统。许多实用工具依赖 /proc 才能访问 Linux 内核信息 ReiserFS 日志文件系统。曾经的多个 Linux 发行版本默认文件系统类型，但如今是 ext 和 xfs swap 用于交换分区 squashfs 压缩且只读的文件系统类型 NFS Network Filesystem，用于在其他 Linux 或 UNIX 计算机上挂载文件系统 ntfs Windows NT 文件系统 xfs 最早由 Silicon Graphics 开发的高性能文件系统，可很好地使用大文件 gfs2 一种共享磁盘文件系统，运行多台计算机使用相沟通的共享磁盘，而不必通过网络文件系统层，如 CIFS 、NFS 等 输入 man fs 了解更多 Linux 文件系统相关信息\n12.4.2 启动交换区 1 2 3 4 5 6 # 查看交换分区数量 free -m # 创建交换分区 mkswap /var/opt/myswap # 启用交换分区 swapon /var/opt/myswap 如果在 /etc/fstab 添加了交换分区相关条目，如：\n/var/opt/myswap swap swap defaults 0 0\n可以使用 swapon -a 启用\n12.4.3 禁用交换区 swapoff /var/opt/myswap\n12.4.4 使用 fstab 文件定义可挂载的文件系统 12.2.3 已介绍，不过字段二可以使用 UUID 而非设备名，因为设备名是可变的\n查看 UUID：blkid\n12.4.5 使用 mount 命令挂载文件系统 同样在 12.2.3 已介绍\n12.4.6 以环回方式挂载磁盘镜像 也就是将 ISO 镜像文件挂载\n1 2 3 4 # 创建挂载文件夹 mkdir /mnt/tmp # 挂载 mount -o loop name.iso /mnt/tmp 12.4.7 使用 umount 命令 可以输入设备分区名或目录名\n设备分区名：umount /dev/sdb1\n目录名：umount /mnt/tmp\n通常，最好使用目录名\n如果一个目录正繁忙无法被卸载，可以：\n延迟卸载：umount -l\n强制卸载：umount -f\n12.5 使用 Cockpit 管理存储 GUI ，开启参考第八章\n","date":"2023-01-03T13:37:48+08:00","permalink":"https://blog.yexca.net/archives/85/","title":"Linux 学习 第十二章 管理磁盘和文件系统"},{"content":"第十一章 获取用户账户 用户账户保持了使用系统的人与运行在系统中的进程之间的边界，而组是一种将系统的权限一次性分配给多个用户的方法\n11.1 创建用户账户 每一个使用 Linux 系统的人都应该有一个单独的用户账户。通过拥有一个用户账户，可以提供用来完全存储文件的区域，以及调整用户界面 (GUI、路径、环境变量等) ，从而适合用户使用电脑的习惯\n可以通过 Cockpit 使用 GUI 创建账户，若没有安装：\n1 2 yum install cockpit -y systemctl enable --now cockpit.socket 然后浏览器打开 localhost:9090 以操作\n11.1.1 使用 useradd 命令添加用户 多数情况下使用 GUI 是比较麻烦的，所以可以使用 useradd 命令以添加用户 (root 权限) ，唯一必要的参数是用户的登录名，可用选项包括：\n可用选项 描述 -c \u0026ldquo;comment\u0026rdquo; 提供了对新用户账户的描述。一般为用户的全名 -d home_dir 设置账户所使用的主目录。默认使用登录名命名并放入 /home 目录 -D 并不创建新账户，而是将所提供的信息保存作为创建新用户的默认设置 -e expire_date 以 YYYY-MM-DD 格式分配账户的有效期限。例如：-e 2024-08-01 -f -1 设置密码过期后多少天，便永久封禁该账户。默认值 -1 表示禁用此选项 -g group 设置用户所在的主组 (必须已存在于 /etc/group 文件中) 。若没有该选项，将创建一个新组 (使用用户名作为组名) ，并将其作为用户的主组 -G grouplist 将新用户添加到以逗号分隔的增补组列表中。例如：-G wheel, sales, tech -k skel_dir 设置用户主目录的文件，复制自 skel_dir ，默认为 /etc/skel -m 自动创建用户的主目录。对于 Fedora 和 RHEL 该选项是默认的，但对于 Ubuntu 来说不是 -M 不创建用户主目录，尽管有 -m 选项也不创建 -n 禁用创建一个与新用户名和用户 ID 相匹配的新组的默认行为 -o 使用 -u uid 创建一个与另一个用户账户具有相同 UID 的用户账户 -p passwd 设置密码 (使用 MD5 加密过后的) 。如果此时未设置，可以使用 passwd user 命令。使用 openssl passwd 以输出通过 MD5 加密后的密码 -s shell 设置默认 shell 。例如：-s /bin/csh -u user_id 为账户指定用户 ID 号，若没有则自动分配。自动分配给常规用户的 ID 从 1000 开始 一般情况使用：\n1 2 3 # root 权限下 useradd yexca passwd yexca 在创建 yexca 这个账户的过程中，useradd 命令完成了以下活动：\n读取 /etc/login.defs 和 /etc/default/useradd 文件，获取创建账户所使用的默认值\n检查命令行参数，找出哪些默认值被重写\n根据默认值和命令行参数，在 /etc/passwd 和 /etc/shadow 文件中创建新用户条目\n在 /etc/group 文件中创建新的组条目\n在 /home 目录中根据用户名创建一个主目录\n将 /etc/skel 目录中的所有文件复制到新的主目录中。其中通常包括登录和应用程序启动脚本\n在 /etc/passwd 文件中的用户行：\nyexca:x:1001:1001::/home/yexca:/bin/bash\n字段之间以冒号分隔，分别为登录名、密码、用户 ID 、主组 ID 、注释字段、主目录、默认登录终端\n密码字段为 x 是被加密存储在 /etc/shadow\n在 /etc/group 文件中的组行：\nyexca:x:1001:\n同样以冒号分隔，分别为组名、组密码、组 ID 以及组中用户列表\n11.1.2 设置用户默认值 useradd 命令通过读取 /etc/login.defs 和 /etc/default/useradd 文件确定默认值，所以可以修改文件以修改默认值\n在不同 Linux 系统中 login.defs 不同，以下仅部分\n1 2 3 4 5 6 7 8 9 10 11 12 13 PASS_MAX_DAYS 99999 PASS_MIN_DAYS 0 PASS_MIN_LEN 5 PASS_WARN_AGE 7 UID_MIN 1000 UID_MAX 60000 SYS_UID_MIN 200 SYS_UID_MAX 999 GID_MIN 1000 GID_MAX 60000 SYS_GID_MIN 201 SYS_GID_MAX 999 CREATE_HOME yes 修改其他默认选项可以参阅 /etc/default/useradd 文件，可以通过 useradd -D 查看当前默认设置\n也可以将 -D 与一些其他选项搭配使用以修改 /etc/default/useradd 文件\n-b default_home \u0026mdash; 设置所创建主目录所在目录。通常为 /home\n-e default_expire_date \u0026mdash; 设置禁用用户账户的默认的截止日期。应当使用 YYYY-MM-DD 的日期格式\n-f default_inactive \u0026mdash; 设置密码过期后多少天账户被禁用\n-g default_group \u0026mdash; 新用户默认所在的组。通常会创建与用户具有相同名称和 ID 号的新组\n-s default_shell \u0026mdash; 默认 shell\n11.1.3 使用 usermod 修改用户 usermod 命令提供了一种简单明了的方法来更改账户参数\n选项 描述 -c \u0026ldquo;username\u0026rdquo; 更改描述 -d home_dir 更改主目录 -e expire_date 分配一个 YYYY-MM-DD 格式的新过期时间 -f -1 更改密码过期之后多少天永久禁用账户。默认值 -1 表示禁用该选项 -g group 更改用户所在主组 (需存在该组) -G grouplist 将用户的附属组设置为以逗号分隔的组列表。如果想保留原先组，请使用 -Ga -l login_name 更改登录名 -L 锁定账户 (在 /etc/shadow 文件的加密密码前添加一个感叹号) -m 将原主目录内容复制到新主目录。仅当 -d 选项被使用时该选项才有效 -o 只能与 -u 一起使用以取消 UID 必须唯一的限制 -s shell 更改 shell -u user_id 更改用户 ID -U 接触锁定 (将 /etc/shadow 文件的加密密码前的感叹号删除) 11.1.4 使用 userdel 删除用户 例如命令 userdel -r yexca 将用户 yexca 把 /etc/passwd 文件删除，-r 表示将主目录 /home/yexca 也删除\n在删除用户前可以先使用 find 命令查找用户遗留的文件，如：find / -user yexca -ls 或 find / -uid 1001 -ls\n因为没有分配给用户的文件可能会是一个安全隐患，比较好的做法是分配给一个真实的账户，可以使用 find / -nouser -ls 命令找到不与任何用户关联的文件\n11.2 了解组账户 如果要在多个用户中共享一组文件，那么组账户是非常有用的\n通过 chgrp grpName fileOrDir 命令以更改文件或目录所属组\n11.2.1 使用组账户 每一个用户都分配给一个主组，主组由 /etc/passwd 文件中每一条目的第三个字段的数字来表示\n一个用户可以属于多个增补组，也可以不属于任何增补组。如果用户 yexca 是组 yexca 和组 hi 的一名成员，那么在 /etc/group 文件中的条目将如下所示：\nyexca:x:1001:yexca\nhi:x:1002:yexca\n只有 root 权限的人才能改变分组，也就是普通用户无法更改自己的分组，也不能将其他用户添加到自己的组\n如果想要以某组身份创建文件，可以使用 newgrp 命令以临时成为某一组成员\n拥有 root 权限的用户可以使用 gpasswd 命令设置某组的组密码\n11.2.2 创建组账户 创建：groupadd groupName\n分配组号：groupadd -g gid groupName\n或者更改某用户的组，可以使用组名或组号\ngroupmod -g gid userName\ngroupmod -n groupName userName\n而如果改变增补组，参考 usermod 命令\n11.3 在企业中管理用户 通过使用 ACL (Access Control Lists) 技术以使任何用户，可将文件或目录的特定权限分配给任何用户和组\n11.3.1 使用 ACL 设置权限 两个命令，设置 setfacl 和获取 getfacl 某目录权限\n设置时，通过 -m 修改或 -x 删除权限，例如\nsetfacl -m u:userName:rwx filename\n11.3.2 为用户添加目录以便进行协作 当使用 chmod 命令更改权限时，一般会忽略一组特殊的三权限位，这些权限位可以在命令和目录上设置特殊权限\n例如：chmod 775 /home/yexca/tmp.txt ，实际上权限为 0775\n名称 数值 字母值 设置用户 ID 位 4 u+s 设置组 ID 位 2 g+s 粘滞位 1 o+t 创建组协作目录 (设置 GID 位) 1 2 3 4 5 6 7 8 9 10 11 # 创建一个用于协作的组 groupadd -g 301 cooperation # 添加一些用户 usermod -aG cooperation yexca # 创建协作目录 mkdir /mnt/co-tmp # 将组 cooperation 分配给该目录 chgrp cooperation /mnt/co-tmp # 更改目录权限 chmod 2775 /mnt/co-tmp # 此时如果查看该目录权限应该为 rwxrwsr-x 现在，若用户 yexca 在目录 /mnt/co-tmp 创建一个文件，该文件所属组为 cooperation，而不是 yexca\n创建受限制的删除目录 (粘滞位) 命令：chmod 1775 /mnt/tmp\n在受限制的删除目录中，除非是 root 用户或者目录的拥有者，不能删除其他用户的文件，即使拥有写入权限\n例如 /tmp 目录就是一个受限制的删除目录 (权限为 rwxrwxrwt)\n设置用户位 Set UID\n拥有设置用户位的可执行文件 (rwsr-xr-x) 代表其他用户可执行，但执行命令进程为拥有该文件的用户\n例如 su 命令，所有用户可执行，但执行的进程属于 root 用户\n11.4 集中用户账户 Linux 默认验证用户的方法是根据 /etc/passwd 文件和 /etc/shadow 文件的密码，但也可以使用其他方式\n例如 LDAP (Lightweight Directory Access Protocol)、NIS (Network Information Service)、Winbind 等\n","date":"2023-01-02T12:29:03+08:00","permalink":"https://blog.yexca.net/archives/84/","title":"Linux 学习 第十一章 获取用户账户"},{"content":"第十章 获取和管理软件 10.1 在桌面管理软件 通过软件与 GUI 管理\n10.2 超越 Software 窗口 Software 中能检索到的软件有限\n10.3 了解 Linux RPM 和 DEB 软件包 软件包称为 tarball (压缩包)，包含可执行文件 (命令)、文档、配置文件以及库\nDEB (.deb) 包 Debian GNU/Linux 项目创建了 .deb 包，这种包被 Debian 以及其他基于 Debian 的发行版本 (Ubuntu、Linux Mint、KNOPPIX 等) 所使用。通过 apt 或 dpkg 命令以安装、管理、更新和删除软件\nRPM (.rpm) 包 最初为 Red Hat Package Manager，后被命名为 RPM Package Manager。RPM 是 SUSE、Red Hat 发行版本 (RHEL、Fedora) 以及其他发行版本 (需基于 Red Hat 发行版本，如 CentOS、Oracle Linux 等) 的首选软件包格式。通过原先的 rpm 或增强的 yum 以及现在的 dnf 命令管理软件\nyum 终将被 dnf 命令所取代\n10.3.1 理解 DEB 包 Debian 软件包以存档文件格式保存了许多文件以及与一些软件相关的元数据。这些文件可以是可执行文件 (命令) 、配置文件以及其他软件项目。而元数据包括依赖项、许可、包大小、描述以及其他信息\n通过 apt* 命令以获取 (apt-get) 、搜索 (apt-cache search) 、查看详情 (apt-cache show) 、安装 (apt-get install) 、升级 (apt-get upgrade) 、列出已安装软件 (apt-cache pkgnames) 等\n通过 aptitude 命令以在 shell 中使用面向屏幕的菜单从而安装软件\n10.3.2 理解 RPM 包 RPM 包是不同文件的合并，而每个文件提供了一项功能。RPM 内部可以是构成软件功能的命令、配置文件以及文档或者元数据 (关于软件包的内容、软件包的来源、运行所需的条件以及其他信息)\n使用 rpm -q -i pakageName 命令查看某软件信息\n10.4 使用 yum 管理 RPM 软件包 10.4.1 从 yum 到 dnf 的转换 DNF 自称为 Dandified yum https://github.com/rpm-softwes-management/dnf/ 虽然 dnf 与 yum 保持了基本的命令行兼容性，但主要区别之一是它遵循严格的 API，并鼓励开发 dnf 的扩展和插件\n以下 yum 命令均可作为 dnf 命令使用\n有关 dnf 更多信息，可参考 https://dnf.readthedocs.io/ 10.4.2 了解 yum 的工作原理 基本语法 yum [options] command\n例如安装 Firefox：yum install firefox\n检查 /etc/yum.conf 文件中\ngpgcheck 表明是否对软件包验证\ninstallonly_limit=3 表明允许在系统中保存同一包的最多三个版本 (请不要将其设置为小于 2，以确保始终拥有至少两个内核包)\nclean_requirements_on_remove=True 表示在卸载某软件将一起卸载依赖项 (如果该依赖不被其他软件使用)\nbest=True 表示升级软件时优先尝试最新版本\ncachedir 表示缓存位置\nkeepcache 是否保留缓存\ndebuglevel 写入日志的详细级别，越高越详细\nmetadata_expire 元数据超时时间\n详细了解，使用 man yum.conf 命令\n检查 /etc/yum.repos.d/*.repo 文件 若想启用某软件库，将 .repo 文件放到此目录。文件内容大致如下\n1 2 3 4 5 6 7 [myrepo] # 开头，`[]` 内为库名 name=My repo # 详细描述 baseurl=https://rpmrepo.yexca.net/ # 虚构网址，不存在 # 包含 RPM 文件的 url 可以是 http://, ftp://,file:// enabled=1 # 是否启用该库，若没有默认启用 gpgcheck=1 # 是否检查软件包签名 gpgkey=file:///etc/MYKEY # 用于检查软件包的密钥位置 可以启用任意数量的软件库，但每次允许 yum 命令时将检查每一个库，将软件包相关元数据下载到本地系统，所有不要启用过多的软件库\n从 YUM 库中下载 RPM 软件包和元数据 在 rpm 目录有一个 repodata 目录，为所有启用库的 repodata 目录汇总\n元数据信息存储在 /var/cache/yum ，在达到超时时间后将获取最新元数据，yum 默认为 6h，dnf 默认为 48h\n将 RPM 软件包安装到 Linux 文件系统 相关软件下载到缓存中后，yum 命令通过运行 rpm 命令安装。如果软件包有脚本，先执行脚本。然后将软件包内容 (命令、配置文件、文档等) 复制到 RPM 元数据指定位置。最后运行安装后执行的脚本\n将 YUM 库的元数据存储到本地 RPM 数据库 包含在每个 RPM 软件库中的元数据最终被复制到本地的 RPM 数据库中，而 RPM 数据库存储在 /var/lib/rpm 目录的多个文件中\n10.4.3 借助第三方软件库使用 yum 为了稳定性，建议仅使用官方自带，但自己使用以舒适度优先，可以启用 RPM Fusion 第三方库，参考 https://rpmfusion.org/ 10.4.4 使用 yum 命令管理软件 搜索软件包 yum search keyword\n获取某软件详细信息 yum info firefox\n若知道命令、配置文件或库名，但不知道软件包名称 yum provides keyword\n使用 list 子命令以不同方式列出软件包名称 yum list firefox\nyum list available\nyum list installed\nyum list all\n查看某软件包的依赖、提供者等 yum deplist firefox | less\n安装和删除软件包 install 子命令用于安装一个或多个软件包，以及相应依赖包 yum install firefox 或 yum -y install firefox 以不需要同意之间安装\nreinstall 子命令可以重新安装某软件 yum reinstall firefox\nremove 子命令删除软件及其他包不需要的依赖项 yum remove firefox\n或者通过历史记录撤销\n使用 yum history 查看安装历史记录，yum history info 12 查看 id 为 12 的安装历史记录详情，yum history undo 12 撤销 id 为 12 的安装事务\n更新软件包 yum check-update 检查更新，yum update 更新全部软件，yum update firefox 更新 Firefox\n更新软件包组 为更方便地管理一套完整的软件包，yum 支持软件包组\nyum grouplist | less 查看软件包组\nyum groupinfo LXDE 查看 LXDE 桌面相关软件包组\nyum groupinstall LXDE 安装 LXDE 软件包组\nyum groupremove LXDE 删除整个 LXDE 组\n维护 RPM 软件包数据库和缓存 yum clean packages 清除软件安装包\nyum clean metadata 清除元数据\nyum clean all\n虽然可能不大，但 RPM 数据库有受损的可能\nyum check 检查缓存和数据库情况\nrpm --rebuilddb 重建数据库\n注：一般使用本地 RPM 数据库的最适合命令为 rpm\n从 YUM 库下载 RPM 只是下载，但不安装，下载到当前目录\nyumdownloader firefox\ndnf download firefox\n10.5 使用 rpm 命令安装、查询和验证软件 大部分情况下使用 rpm 命令对本地的安装包文件使用\n10.5.1 使用 rpm 安装和删除软件包 安装 rpm -i pakageName\n需要使用 rpm 包的完整名称，即包括基名、版本、内核等\n升级 rpm -Uhv pakageName\n-h 为打印 # 标识 (安装进度) ，-v 为更详细的输出\n更新 若当前目录有数以千计的 rpm 包，仅想对以此计算机已经安装过的升级\nrpm -Fhv *.rpm\n重新安装 rpm -Uhv --replacepkgs pakageName\n降级 rpm -Uhv --oldpackage pakageName\n删除 删除时仅需要基名，如删除 Firefox\nrpm -e firefox\n但并不会删除该软件的依赖\n10.5.2 查询 rpm 信息 安装玩软件后，使用 -q 选项以查询关于该软件包的信息，如相关描述 -qi 、文件列表 -ql 、配置文件 -qc\n查询使用基名即可，如：rpm -qi firefox\n还可以查询依赖 -q --requires 、软件包所提供的软件版本 -q --provides 、删除之前和之后运行的脚本 -q --scripts 、更改日记 -q --changelog\n通过 --queryformat 查询信息的不同标记，--querytags 以查看所有可用标记\n以上为本地 RPM 数据库查询，若添加 -p 选项可查询当前目录的软件包，此时需要输入全程，如 rpm -qip zsh-5.7.1-1.fc30.x86_64.rpm\n10.5.3 验证 rpm 软件包 注：该选项查阅其他资料并未发现，但本人 Linux 已删除，无法验证 (之前用的时候看到这没复现) ，但既然看到了，还是记录一下比较好\n通过使用 -V 选项对已安装的软件包检查，了解自首次安装以来是否被更改。若二进制文件 (/bin 目录下) 被更改，可能表明系统被破解。配置文件更改很常见\n查询已安装的 Firefox 的情况 rpm -V firefox\n如果输出以下字符，代表相应地方被修改；没有输出表示每个文件为原始状态\n字符 描述 S 文件大小不一致 M 模式不一致 (包括许可和文件类型) 5 MD5 校验不一致 D 设备主要 / 次要编号不匹配 L readLink (2) 路径不匹配 U 用户所有权不一致 G 组所有权不一致 T mTime 不一致 P caPabilities 不一致 这些指示符来自 rpm 手册的 Verify 部分\n可以使用 --replacekgs 以恢复至原始状态\n如果对安全性要求过高，可以备份 RPM 数据库，即 /var/lib/rpm 目录，然后存入只读介质，毕竟如果数据库也被破解，那校验将毫无意义\n10.6 在企业中管理软件 如 Kickstart 文件、PXE 启动、Satellite 服务器 (Spacewalk) 、容器映像\n可以自动化批量安装软件\n","date":"2022-12-08T16:35:57+08:00","permalink":"https://blog.yexca.net/archives/83/","title":"Linux 学习 第十章 获取和管理软件"},{"content":"第八章 学习系统管理 8.1 理解系统管理 su 命令 \u0026mdash; 以 root 用户身份打开一个 shell\nsudo 命令 \u0026mdash; 普通用户通过此命令运行其他命令时，该才会被赋予 root 权限\n8.2 使用图形化管理工具 Cockpit 是基于浏览器的系统管理工具\n安装 Cockpit 1 sudo dnf install cockpit 以 root 身份登录，启用 Cockpit 套接字 1 sudo systemctl enable --now cockpit.socker 在浏览器打开界面： localhost:9090 8.2.1 使用 system-config-* 工具 工具 命令 描述 域名系统 system-config-bind 如果计算机充当 DNS 服务器，应创建和配置区域 (Zone) HTTP system-config-httpd Apache Web 服务器 NFS system-config-nfs 设置与其他使用了 NFS 服务的计算机共享的目录 Root Password system-config-rootpassword 更改 root 密码 Samba NFS system-config-samba 配置 Win 共享文件夹 Services system-config-services 显示和更改 Fedora 中在不同运行级别的服务 Authentication authconfig-gtk 更改系统中对用户进行身份验证的方式 Date \u0026amp; Time system-config-date 设置日期和时间或与 NTP 服务器保存同步 Firewall system-config-firewall 配置防火墙 Language system-config-language 选择语言 Printing system-config-printer 配置本地和网络打印机 SELinux Management policycoreutils-gui 设置 SELinux 的强制模式和默认策略 Users \u0026amp; Groups system-config-users 用户账户相关 8.3 使用 root 用户账户 8.3.1 通过 shell 成为 root 用户 使用命令 su 即可转为 root 用户，但此时环境变量还是原来的账户\n使用 su - 以将变量也转变为 root 用户的\n此外，通过 su - username 可切换到指定用户\n8.3.2 使用 sudo 获取管理访问权限 使用 sudo 运行的命令拥有 root 权限，而且不需要 root 密码，只需要赋予相应用户权限即可\n以下为赋予 sudo 权限\n以 root 身份运行 visudo 命令\n添加如下所示行\n1 2 3 4 5 yexca ALL=(ALL) ALL # 或下面为使用 sudo 时不需要密码 # (该用户的密码，不是 root 用户的密码) yexca ALL=(ALL) NOPASSWD:ALL 这样将赋予用户 yexca 以 sudo 权限\n保存更改后文件 8.4.2 管理配置文件 大部分配置文件以纯文本的形式存在 /etc 目录下，以下为部分文件\n目录 描述 /etc/cron* 定义了 crond 计划执行的程序，如 cron.daily、cron.hourly /etc/cups 配置 CUPS 打印服务的文件 /etc/default 为各种实用工具设置默认值的文件 /etc/httpd 配置 Apache Web 服务器行为 /etc/rc?.d 针对每一种有效的系统状态，都有一个单独的 rc?.d 目录：rc0.d (关闭状态)、rc1.d (单用户状态)、rc2.d (多用户状态)、rc3.d (多用户加网络状态)、rc4.d (用户定义的状态)、rc5.d (多用户、网络与 GUI 登录状态) 和 rc6.d (重新启动状态) /etc/skel 创建新用户时，该目录文件被复制到新用户的主目录 /etc/sysconfig 包含各种服务所创建和维护的重要系统配置文件 /etc/systemd 包含与 systemd 实用工具 (用来管理启动进程和系统服务) 相关联的文件 /etc/xinetd.d 包含一组文件，每一个文件定义了一个 xinted 守护进程监听某一个特定端口所需的点播网络服务 8.4.3 管理日志文件和 Systemd.Journal rsyslogd 和 systemd 的 journalctl 命令\nrsyslogd 及前身 syslogd 将文件放到 /var/log 目录\n8.5 使用其他管理账户 例如 lp 、apache 、bin 等用户，默认不允许登录\n如果要登录需要将默认 shell 从 /sbin/nologin 或 /bin/false 改为真实 shell，例如 /bin/bash\n8.6 检查和配置硬件 8.6.1 检查硬件 通过 dmesg 或 journalctl 命令查看 Linux 启动时硬件检测信息以及驱动加载信息\n通过 lspci 命令查看计算机上 PCI 总线及连接到这些总线上的设备，lsusb 命令列出 USB 设备信息，lscpu 列出处理器信息\n8.6.2 使用可加载模块 如果想添加未被正确识别的硬件，可能需要手动加载\n列出可加载模块 通过 lsmod 命令，如要获取某一模块详情，通过 modinfo -d 模块 命令\n加载模块 使用 modprobe 命令加载任何被编译并安装到运行内核的模块\n删除模块 使用 rmmod 命令，或使用 modprobe -r 以将依赖模块一起删除\n8.7 小结 在 Linux中应该把各项服务 (http、git 等) 单独创建用户并限制登录权限以保证系统安全\n第九章 安装 Linux なし\n图形化安装不必多说，其他安装可参考 Arch 参考手册 我也写了一篇比 Arch 手册垃圾的文章： 虚拟机中 Arch Linux 安装记录 – yexca\u0026rsquo;Blog 另有远程安装例 PXE 启动之类因无法复现，无法理解\n","date":"2022-12-07T16:29:05+08:00","permalink":"https://blog.yexca.net/archives/82/","title":"Linux 学习 第八、九章 学习系统管理与安装 Linux"},{"content":"第七章 编写简单的 shell 脚本 如果需要反复执行某一任务，而该任务又需要输入大量的命令行，那么可以通过写入 shell 脚本以实现一条命令完成所有任务\n7.1 理解 shell 脚本 shell 脚本是一组包含命令、函数、变量或其他可以通过 shell 使用的功能。这些项目被输入一个纯文本文件中，而该文件可以作为一条命令来运行\n类似于 Windows 中的批处理文件 (.bat)\n7.1.1 执行和调试 shell 脚本 shell 脚本的主要优点是可以在任何文本编辑器中打开以查看脚本的内容，最大的缺点是大型或复杂的 shell 脚本的执行通常比编译后的程序要慢。可以通过两种基本的方法执行 shell 脚本\n将脚本名称作为 shell 的一个参数，例如：bash myscript\n在 shell 脚本第一行添加解释器名称 (#!/bin/bash)，给该文件添加执行权限后 (chmod +x myscript)，通过在命令行输入脚本的路径运行，例如 (./myscript.sh)\n在执行时跟在脚本名称后面的为命令行参数\n注释为 #\n可以在脚本开头添加 set-x 以使用 $ bash -x myscript 显示正在执行的命令\n7.1.2 理解 shell 变量 shell 变量中的变量名称是大小写敏感的，注意定义时等号 (=) 左右无空格，例如\nNAME=value\n可以为变量分配常量，例如文本、数字及下划线\n也可为变量赋值一个命令，例如：MYDATE=$(date) 以将 date 命令的输出分配给变量 MYDATE\n这样每次使用变量 MYDATE 将运行一次 date 命令并将结果赋值给 MYDATE 。可以将命令放在引号 ' 中以获得赋值时命令的运行结果\n特殊的 shell 字符：美元符号 ($)、引号 (')、星号 (*)、感叹号 (!) 等\n如果想在命令行输出显示 $HOME 需要转义 $，可使用 echo '$HOME' 或 echo \\$HOME ，即：\n如果想要 shell 从字面上解释单个字符，使用反斜杠 \\\n如果想从字面上解释一组字符，则使用单引号 (') 包围这些字符\n如果想从字面上解释一部分字符，使用双引号 (\u0026quot;) 包围一组文本，其中美元符号 ($)、引号 (') 和感叹号 (!) 将被解释，而其他字符 (例如星号 *) 则不会被解释\n为变量赋值直接使用变量名，而引用变量，即需要获取变量值时需要在变量名前加美元符号 ($)\n例如将某变量的值赋值给新变量：newVar=\u0026quot;$oldVar\u0026quot;\n特殊的 shell 位置参数 位置参数 ，或 命令行参数 ，名为 $0、$1、$2\u0026hellip;$n\n其中 $0 为被调用脚本的名称，而其他的则被赋予从命令行传递而来的参数值，例如：\n1 2 3 4 5 6 #!/bin/bash echo \u0026#34;第一个参数是 $1 ，第二个参数是 $2 \u0026#34; echo \u0026#34;该脚本名称为 $0 \u0026#34; echo \u0026#34;一共传入了 $# 个参数\u0026#34; echo \u0026#34;所有的参数为：$@ \u0026#34; 执行命令：./myscript hello bye ，运行结果为下：\n1 2 3 4 第一个参数是 hello ，第二个参数是 bye 该脚本名称为 /home/yexca/tmp/myscript 一共传入了 2 个参数 所有的参数为：hello bye 还有一个有意思的参数 $? 接受最后一条被执行的命令的退出状态，一般正常退出会返回 0\n读取参数 通过使用 read 命令读取用户输入\n1 2 3 4 #!/bin/bash read -p \u0026#34;请输入两个名词：\u0026#34; var1 var2 echo \u0026#34;刚刚输入了 $var1 和 $var2\u0026#34; 在 Bash 中进行参数扩展 想获取一个变量的值，需要在变量名前加美元符号 ($) ，例如 $var ，这其实是 ${var} 的简写\nBash 有一些规则可以以不同方式扩展参数值，以下为比较常用的，以 ${var} 为例\n示例 描述 ${var:-value} 如果变量未设置或为空，在将其扩展为 value ${var#pattern} 从 var 的值的 前面 开始砍掉与 pattern 最 短 的匹配项 ${var##pattern} 从 var 的值的 前面 开始砍掉与 pattern 最 长 的匹配项 ${var%pattern} 从 var 的值的 末尾 开始砍掉与 pattern 最 短 的匹配项 ${var%%pattern} 从 var 的值的 末尾 开始砍掉与 pattern 最 长 的匹配项 基于这些特性，可以有一些有用的应用，例如：\n1 2 3 4 5 6 7 8 9 myFileName=/home/yexca/myfile.txt # file 变为 myfile.txt file=${myFileName##*/} # dir 变为 /home/yexca dir=${myFileName%/*} # name 变为 myfile name=${file%.*} # extension 变为 txt extension=${file##*.} 7.1.3 在 shell 脚本中执行算法 Bash 使用了非类型化变量，除非使用 declare 告诉 Bash，否则变量被视为字符串。在进行运算时会自动转为整数，不需要在赋值时指定类型\n可以使用内置 let 命令或外部 expr 命令或 bc 命令完成整数运算\n如：let result=$num/16 ，或 let num=$RANDOM\n同时也有自增运算符，i++ 和 ++i\nlet 命令要求每个操作数与数学运算符之间不能存在空格\nexpr 命令则要求每个操作数和数字运算符之间存在空格\n而 bc 命令对空格没有要求，可以完成浮点运算\n7.1.4 在 shell 脚本中使用编程结构 \u0026ldquo;if\u0026hellip;then\u0026rdquo; 语句 1 2 3 if [ %var -eq 1 ]; then echo \u0026#34;The var is 1\u0026#34; fi 如果比较数字，-eq 比较好，但若比较字符串值，等号 (=) 不失为一个更好的选择\n1 2 3 if [ $str = \u0026#34;hello\u0026#34;]; then echo \u0026#34;hello\u0026#34; fi 此外还有不等号 !=\n通过使用 elif 语句，以提供更多的选择。使用 else 以代表其他情况\n1 2 3 4 5 6 7 8 $str=\u0026#34;$HOME\u0026#34; if [ -f \u0026#34;$str\u0026#34;]; then echo \u0026#34;$str 是一个普通文件\u0026#34; elif [ -d \u0026#34;$str\u0026#34;] echo \u0026#34;$str 是一个目录\u0026#34; else echo \u0026#34;???\u0026#34; fi 以下是一些可使用的测试条件\n运算符 测试的内容 -a file 文件是否存在，与 -e 相同 -b file 文件是否为一个专用设备 -c file 文件是否是特殊字符或字符设备。用来识别串行线路和终端设备 -d file 文件是否是一个目录 -e file 文件是否存在，与 -a 相同 -f file 文件是否存在，是否为普通文件 (不是目录、套接字、管道、链接或设备文件) -g file 文件是否设置了 SGID 位 -h file 文件是否设置了一个符号链接，与 -L 相同 -k file 文件是否设置了粘滞位 -L file 文件是否设置了一个符号链接，与 -h 相同 -n string 字符串的长度是否大于 0 字节 -O file 是否拥有该文件 -p file 文件是否为命名管道 -r file 文件是否可读 -s file 文件是否存在，并且大于 0 字节 -S file 文件是否存在，并且为套接字 -t file 文件是否为连接到终端的描述符 -u file 文件是否设置了 SUID 位 -w file 文件是否可写 -x file 文件是否可执行 -z string 字符串的长度是否为 0 字节 以下为两个变量之间比较\n运算符 测试的内容 expr1 -a expr2 俩表达式是否都为真 expr1 -o expr2 有一个为真 file1 -nt file2 第一个文件是否比第二个文件新 (使用修改时间戳) file1 -ot file2 第一个文件是否比第二个文件旧 (使用修改时间戳) file1 -ef file2 两个文件是否通过一个链接相关联 (硬链接或符号链接) var1 = var2 第一个变量是否等于第二个变量 var1 -eq var2 第一个变量是否等于第二个变量 var1 -ge var2 第一个变量是否大于等于第二个变量 var1 -gt var2 第一个变量是否大于第二个变量 var1 -le var2 第一个变量是否小于等于第二个变量 var1 -lt var2 第一个变量是否小于第二个变量 var1 != var2 第一个变量是否不等于第二个变量 var1 -ne var2 第一个变量是否不等于第二个变量 此外还可以把测试运算符与 \u0026amp;\u0026amp; 和 || 组合成类似于 C 语言中的三元运算符\nC：a\u0026gt;b ? a : b\nShell：[$a -gt $b] \u0026amp;\u0026amp; $a || $b\n也可单独使用。例如 [$a -eq $b] \u0026amp;\u0026amp; $a 为若 a 等于 b，则返回 a 的值\n[-d \u0026quot;$dirName\u0026quot;] || mkdir \u0026quot;$dirName\u0026quot; 为若 $dirName 路径不存在，则执行命令 mkdir \u0026quot;$dirName\u0026quot;\ncase 命令 与 C 语言中的 switch 语句类似，用于选择。一般形式为\n1 2 3 4 5 6 7 8 9 10 11 case \u0026#34;VAR\u0026#34; in Result1) body ;; Result2 | Result3) body ;; *) body ;; easc for\u0026hellip;do 循环 for 循环一般用于遍历一个列表\n1 2 3 4 5 6 7 8 9 10 for VAR in LIST do body done # 或者这样 for VAR in LIST ; do body done 例如：\n1 2 3 4 5 6 7 8 9 10 for num in 0 1 2 3 4 do echo \u0026#34;The number is $num\u0026#34; done # 或者将命令输出作为列表 for file in \u0026#39;/bin/ls\u0026#39; ; do echo $file done while\u0026hellip;do 和 until\u0026hellip;do 循环 结构如下\n1 2 3 4 5 6 7 8 9 10 11 # while...do while condition do body done # until...do until condition do body done 7.1.5 使用一些有用的文本操作程序 最常用的程序包括 grep、cut、tr、awk、sed。大部分程序都设计为使用标准输入和输出\n一般正则表达式分析器 也就是 grep ，是一种查找文件或文本模式的方法。可以当成一个有用的搜索工具\n格式 grep 要查找的内容 输入\n通过查看 man grep 以了解更多\n删除文本的行段 cut 命令可以从文本或文件中提取字段。例如\ngrep /home /etc/passwd | cut -d':' -f6 -\n首先 grep 命令从 /etc/passwd 文件获取包含 /home 的行，然后传入 cut 命令，cut 命令将这些行以 : 分割，然后取第六段 (-f6)\n转换或者删除字符 tr 命令是一个基于字符的转换器，可用于替换一个或一组字符，或者从文本行中删除一个字符\n1 2 3 4 5 6 7 8 9 # 转换大写为小写 FOO = \u0026#34;AbcDEF\u0026#34; echo $FOO | tr [A-Z] [a-z] # 将该列表中文件名中空格转换为下划线 for file in *; do f=\u0026#39;echo $file | tr [:blank:] [_]\u0026#39; [\u0026#34;$file\u0026#34; = \u0026#34;$f\u0026#34;] || mv -i -- \u0026#34;file\u0026#34; \u0026#34;$f\u0026#34; done 流编辑器 sed 命令是一个简单的脚本编辑器，只能执行一些简单的编辑，比如删除文本匹配特定模式的行，使用一种模式的字符替换另一种模式的字符等\n过于复杂，请通过在线文档了解\n7.1.6 使用简单的 shell 脚本 电话列表的例子\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #!/bin/bash # (@)/ph # A very simple telephone list # Type \u0026#34;ph new name number\u0026#34; to add to the list, or # just type \u0026#34;ph name\u0026#34; to get a phone number PHONELIST=~/.phonelist.txt # If no command line parameters ($#), there # is a problem, so ask what they\u0026#39;re talking about. if [$# -lt 1]; then echo \u0026#34;Whose phone number did you want? \u0026#34; exit 1 fi # Did you want to add a new phone number? if [$1 = \u0026#34;new\u0026#34;]; then shift echo $*\u0026gt;\u0026gt; $PHONELIST echo $* added to database exit 0 fi # Nope. But does the file have anything in it yet? # This might be out first time using it, after all. if [! -s $PHONELIST]; then echo \u0026#34;No names in the phone list yet!\u0026#34; exit 1 else grep -i -q \u0026#34;$*\u0026#34; $PHONELIST # Quietly search the file if [$? -ne 0]; then # Did we find anything? echo \u0026#34;Sorry, that name was not found in the phone ist\u0026#34; exit 1 else grep -i \u0026#34;$*\u0026#34; $PHONELIST fi fi exit 0 7.2 小结 通过编写 shell 脚本，可以自动完成许多最常见的系统管理任务\n","date":"2022-12-05T20:47:43+08:00","permalink":"https://blog.yexca.net/archives/81/","title":"Linux 学习 第七章 编写简单的 shell 脚本"},{"content":"引言 最近？看了《漫画数字电路》一书，大概记录一下\n书上的很多东西并没有记录在此处\n前述 数字电路分 组合电路 与 时序电路\n组合电路：现在输入信息的组合决定输出的电路\n时序电路：带有 “记忆” 的电路\nMIL 符号 逻辑电路的 与门 与 或门 符号引申为多个输入一个输出\n符号含义 与门 (ALL) ：多个输入全 1，输出为 1\n或门 (EXIST) ：有一个输入为 1，输入为1\n电路线 有 圆圈 的为 低电平 (0、L)\n无 圆圈 的为 高电平 (1、H)\n组合电路的制作 多数表决电路 多个人投票从两个结果中选出一个\n列出真值表，即所有可能出现的情况\n在真值表 H 输出的地方添加下划线\n“输入的线” 与 “将输入 NOT 的线” 搭建框架\n两列向下的电路线，第二列为 NOT 线，即从第一列连 非门 到第二列\n连接到 AND (与门)\n输入为 L 时，从将输入 NOT 的地方开始 (第二列)\n输入为 H 时，从最开始的地方划线 (第一列)\n然后，接入 AND\n重复此过程将 第二步 所划线的全部做完\n将 AND 的所有输出连接到 OR 电路的化简 数字电路设计流程：整理问题 - 真值表 - 化简 - 绘制电路\n通过 卡诺图 进行化简\n真值表转化为卡诺图 真值表制作时列从最高开始，例如 [C、B、A]，结果为 Z\n卡诺图为二维的真值表，一般用 0 与 1 表示电平\n如果三个输入，可以行为 B、A，列为 C，然后将结果填入二维表\n化简前了解 卡诺图的 左右 与 上下 都是连起来的，因为卡诺图的横方向与竖方向都是按 比特 (1 位) 变化的\n化简\n将在一起的 1 作为一个集合划分在一起\n寻找行与列的共同点\n若共同点为某值为 0 则使用 逆运算 ，即字母上一横杠\n例如\nC\\BA 00 01 11 10 0 1 1 1 上表中 共同点为 C 为 0，A 为 1，则表达式为 !C * A\n化简的规则 集合体的形状只能是长、宽为 1、2、4 的矩形 (或正方形)\n集合体可以相互重叠\n集合体的个数越少，面积越大越好\n注：左右和上下可以构成一个集合体；如果无法进一步 “形成集合体” 则说明电路已经无法再化简\n化简后画出电路图，只需要把所有的表达式按上一步的画图步骤 (第三步开始) 走即可\n电路的忽略 在刚开始确定输入时，因为二进制数的特性，可能会有不需要考虑的输入\n例如输入为月份，需要使用四位二进制数，一共有 16 个输入，其中 0、13、14、15 均为不需要考虑的输入\n这样的输入在卡诺图里可以使用 - 代替，可以化简计入集合体\n时序电路的制作 时序电路需要 组合电路 与 触发器\n关于 时序电路 的 “记忆”，例如自动贩卖机在投币时会记录当前投币总数，若无记忆则仅有最后一个硬币的面值\n引入一个触发器，例如 时钟 (CLK)，仅在 CLK 触发时，输入才会对输出有影响，否则输出保持不变\n以绘制电子骰子为例\n绘制状态迁移图 随着时间的变化，电子骰子如何变化？\n若停止为低电平，从 1 开始到 6 到 1\n如果为高电平，则在某点一直停止\n用二进制数来表示状态 把每种情况或者说状态使用二进制表示，然后绘制出 状态迁移表\n通过状态迁移表画出电路，可以使用 D 触发器存储状态\n设计组合电路 从 现在的状态 决定 下一个状态 事实上就是 组合电路\n","date":"2022-12-04T16:54:29+08:00","permalink":"https://blog.yexca.net/archives/80/","title":"欧姆社漫画数字电路读后"},{"content":"第六章 管理运行中的进程 Linux 是一种多用户的操作系统，也是一种多任务系统。多任务意味着可以同时运行多个程序，运行程序的实例通常被称为进程\n可通过 shell 启动、暂停、停止或杀死进程，还可将进程放到后台以及带到前台\n6.1 理解进程 进程是命令的运行实例。系统中的进程通过一个进程 ID (PID) 进行识别，PID 相对于当前系统是唯一的。除了 PID 号之外，进程还与一个特定的用户账户和组账号相关联，有助于确定该进程可以访问哪些系统资源\n用来显示进程相关信息的命令主要从 /proc 文件系统中存储的原始数据获取信息。每个进程都在 /proc 的一个子目录 (以该进程的 PID 命名) 中存储了自己的信息\n6.2 列出进程 使用 ps 命令或者 top 命令，其中 top 命令提供了一种 更面向屏幕的方式列出进程\n6.2.1 使用 ps 命令列出进程 使用 ps u 可显示用户名以及其他信息\nVSZ：虚拟内存大小 (Virtual Set Size) 显示了镜像进程的大小 (单位：KB)\nRSS：(Resident Set Size) 显示了内存中程序的大小\nVSZ 是分配给进程的内存数量，RSS 是进程实际使用的内存数量 (表明了不能被交换的物理内存)\nSTAT 列：S 表示一个当前运行的进程，R 表示一个睡眠进程，+ 表示进程与前台操作相关联\n查看当前用户所有进程：ps ux | less\n查看所有用户进程：ps aux | less\n也可以自定义输出列，并且根据某一列排序，例如\n1 ps -eo pid,user,uid,group,gid,vsz,rss,comm --sort=-vsz | less -e 为显示每一个运行中的进程，-o 后为显示的列，其中 comm 为命令，然后 --sort=-vsz 以 vsz 列从大到小排序\n6.2.2 使用 top 命令列出和更改进程 使用 top 命令，默认按进程当前所使用的 CPU 百分比排序来显示进程\ntop 命令可以完成的操作：\n命令 miaos h 帮助 M 按内存使用情况排序 1 切换显示所有 CPU 使用情况 (系统有多个 CPU) R 反向排序 u 然后输入用户名可以显示某用户的进程 r 改变进程优先级 (nice 值) k 杀死进程 (kill 命令) 6.2.3 使用 System Monitor 列出进程 GNOME 桌面的 GUI 工具\n6.3 管理后台和前台进程 对于没有 GUI 的系统，只能使用 shell 完成所有操作。虽然 Bash shell 没有包含一个 GUI 来管理多个程序，但可以在后台和前台直接移动活动程序，这样就可以运行很多程序并选择目前想要处理的程序\n6.3.1 启动后台进程 将命令放入后台：\n在命令后添加一个 \u0026amp;\n使用 at 命令运行其他命令\n对于运行中的进程使用 Ctrl+Z 停止，再输入 fg 带回前台或 bg 开始在后台运行\n为避免后台输出干扰前台操作，可将其定向到空设备 2\u0026gt;/dev/null\n可通过 jobs 命令查看后台运行的命令 (使用 -l 可查看 PID) 。在命令序号前 + 表示最近放到后台的作业，- 表示在最近放的后台作业之前放到后台的作业\n6.3.2 使用前台和后台命令 如果想引用一个后台作业，通过 % 和作业编号 (jobs 命令的输出) ，此外还有如下方式\n% \u0026mdash; 引用最近放入后台的 (即编号后带有 + 的)\n%string \u0026mdash; 以 string 开头的作业 (必须明确，即匹配结果唯一)\n%?string \u0026mdash; 命令行任意位置包含 string (同样必须明确，即匹配结果唯一)\n%-- \u0026mdash; 引用在最近放的后台作业之前放到后台的作业 (即编号后带有 - 的)\n使用 fg %1 以将编号为 1 的任务带到前台，使用 bg %5 以将停止的编号为 5 的命令在后台继续运行\n对于 vi 命令放到后台前会自动停止，记得先保存文件再放入后台以防忘记\n6.4 杀死和改变进程 可以向进程发送不同的信号来更改其行为，也可以更改进程的处理器优先级\n6.4.1 使用 kill 和 killall 命令杀死进程 虽然这俩命令常用于终止一个运行中的进程，但实际上是向进程发送一些有效信号。信号通过数字或名称来表示\n信号 数字 描述 SIGHUP 1 重新读取配置文件 SIGIN 2 通过键盘中断 SIGQUIT 3 通过键盘退出 SIGABRT 6 调用 abort(3) 生成的中止信号 SIGKILL 9 杀死信号 SIGTERM 15 终止信号 SIGCONT 19，18，25 继续被停止的进程 SIGSTOP 17，19，23 停止进程 对于最后两个信号，第一个值适用于 Alpha 和 SPARC，中间的值适用于 x86，最后一个值适用于 MIPS 体系结构\n默认为 SIGTERM (15) 信号。虽然不同进程可以对不同信号予以响应，然而任何进程都不能阻止 SIGKILL (9) 和 SIGSTOP 信号\n使用 kill 命令并根据 PID 向进程发送信息 1 kill [信号] [PID] 例如杀死进程 ID 为 2333 的进程：kill -9 2333 或者 kill -SIGKILL 2333\n使用 killall 命令并根据名称向进程发送信号 与 kill 命令类似，当要杀死许多同名命令很有用，但要防止改变有用的同名进程\n例如重启 gnome-shell：killall -1 gnome-shell\n6.4.2 使用 nice 和 renice 命令设置处理器优先级 当 Linux 内核尝试决定哪些运行中的进程可以访问 CPU 时，其中一个需要考虑的因素就是进程上的 nice 值，范围 -20~19，默认为 0\nnice 值越低，优先级越高，只有 root 用户可以设置负值并将优先级调高 (值调低)，普通用户只能调低 (值调高)\n可以使用 nice 命令运行一个带有特定 nice 值的命令，也可以使用 renice 命令和 PID 更改已运行进程的 nice 值，例如\nnice -n +5 updatedb \u0026amp; 在后台以 5 的优先级运行 updatedb 命令\nrenice -n 3 2333 将 PID 为 2333 的进程的 nice 值改为 3\n6.5 使用 cgroups 限制进程 为一个进程所设置的 nice 值不能应用于子进程，也就是说，nice 无法对特定用户或应用程序可以使用的 Linux 系统资源总量进行限制\n可以使用 cgroups 命令将一个进程确定为一个任务 (task)，并从属于一个特定的控制组。可以在一个层次结构中设置任务，其中包含一个被称为守护进程 (daemon) 的任务 (为所有后台服务器进程设置了默认限制) 以及子任务，子任务设置像 httpd 或 vsftpd 上的特定限制\n当一个任务启动一个进程时，其子进程将继承父进程限制设置，限制内容包括存储、处理器调度、进程报告、CPU 分配、设备访问、内存使用情况等\n设置 cgroups 可能非常棘手，包括编辑配置文件创建 cgroups (/etc/cgconfig.conf) 或限制特定用户或组 (/etc/cgrules.conf) 。可以使用 cgreate 命令创建 cgroups，从而将这些组添加到 /sys/fs/cgroup 层次结构中。如果设置不正确，系统可能无法启动\n","date":"2022-12-03T15:07:03+08:00","permalink":"https://blog.yexca.net/archives/79/","title":"Linux 学习 第六章 管理运行中的进程"},{"content":"第五章 使用文本文件 Linux 的大多数配置通过编辑纯文本文件完成。无论是修改 /etc 目录的文件配置本地服务，还是编辑 Ansible 目录文件配置主机的集合，纯文本文件仍然在这些任务中普遍使用\n5.1 使用 vim 和 vi 编辑文件 vim 是 vi 的改良版本，两者使用差不多，但 vim 会有引导和代码高亮等，建议使用 vim\n事实上，在部分 Linux 发行版中，vi 是使用别名 vim 来运行的，即输入 alias vi 输出为 alias vi = 'vim' ，但 root 用户一般不设置别名\n不过在 Linux 还有其他文本编辑器，例如 nano、gedit、jed、joe、kate、kedit、mcedit、nedit 等，其中纯文本的有 jed 和 joe\n5.1.1 开始使用 vi vi 有三个模式，主要两种为 命令模式 和 输入模式 ，还有 ex 模式。默认进入文件为命令模式 (使用 vi file 命令进入后)\n命令模式意味着在更改文本前需要先输入一条命令 (一俩个字母，有时还需要可选的数字参数) ，告诉 vi 您想做什么\n注意：命令的大小写敏感\n添加文本 如果要进入 输入模式 ，可以输入一个 输入 命令字母\n命令 描述 a 添加命令。在光标右侧输入文本 A 在命令结束处添加。从当前行末尾开始输入文本 i 插入命令。在光标左侧输入文本 I 在命令开始前插入。从当前行开头开始输入文本 o 在命令之下打开。在当前行之下打开一个新行，并进入插入模式 O 在命令之上打开。在当前行之上插入一个新行，并进入插入模式 进入插入模式后，在屏幕底部会出现 --INSERT--\n完成文本输入后，按 Esc 键返回命令模式 (有时需要按两次 (反正按 Esc 就对了)\n在文本中移动 仅移动一个字符使用以下按键\n按键 描述 箭头键 上下左右 h, j, k, l 左，下，上，右 Backspace, Space 左，右 移动多个字符的命令\n命令 描述 w 将光标移动到下一个单词的开头 (用空格、制表符或标点符号分隔) W 将光标移动到下一个单词的开头 (用空格或制表符分隔) b 将光标移动到前一个单词的开头 (用空格、制表符或标点符号分隔) B 将光标移动到前一个单词的开头 (用空格或制表符分隔) 0 (零) 将光标移到当前行的开头 $ 将光标移到当前行的末尾 H 将光标移到屏幕左上角 (屏幕上第一行) M 将光标移到屏幕中间行的第一个字符 L 将光标移到屏幕的左下角 (屏幕上的最后一行) 删除、复制和更改文本 这些命令可以配合移动键 (箭头、PgUp、PgDn、字母和特殊键) 和数字来确切指出删除、复制或更改什么\n命令 描述 x 删除光标下的字符 X 直接删除光标之前的字符 d\u003c?\u003e 删除一些文本 c\u003c?\u003e 更改一些文本 y\u003c?\u003e 复制一些文本 上表每个命令后的 \u0026lt;?\u0026gt; 代表了可使用移到命令的位置，例如\ndw \u0026mdash; 删除当前光标之后的一个单词\ndb \u0026mdash; 删除当前光标之前的一个单词\ndd \u0026mdash; 删除整个当前行\nc$ \u0026mdash; 更改当前字符开始到当前行末尾的字符并进入输入模式 (事实上就是删除后输入)\nc0 \u0026mdash; 更改从前一字符开始到当前行开头的字符并进入输入模式 (事实上就是删除后输入)\ncl \u0026mdash; 删除当前字符并进入输入模式\ncc \u0026mdash; 删除当前行并进入输入模式\nyy \u0026mdash; 将当前行复制到缓冲区\ny) \u0026mdash; 将光标右边的句子复制到缓冲区\ny} \u0026mdash; 将光标右边的段落复制到缓冲区\n也可以使用数字对上述命令进行修改，例如\n3dd \u0026mdash; 从当前行开始，删除 3 行\n3dw \u0026mdash; 删除接下来的 3 个 单词\n5cl \u0026mdash; 更改接下来 5 个字符 (也就是删除后进入输入模式)\n12j \u0026mdash; 向下移动 12 行\n5cw \u0026mdash; 删除接下来 5 个单词并进入输入模式\n4y) \u0026mdash; 复制接下来的 4 个句子\n粘贴 (放置) 文本 将最新存储到缓冲区的文本放到文件中\n命令 描述 P 放到光标左边，若为一行，放到上一行 p 放到光标右边，若为一行，放到下一行 重复命令 在删除、更改或粘贴文本后，通过 . 以重复行为。例如替换文本 Joe 为 Jim (cw) 后查找下一处按 . 以重复更改\n推出 vi 在命令模式下直接使用 ZZ 保存后退出，也可按 : 进入 ex 模式\n命令 描述 :w 保存当前文件，不退出 :wq 保存并退出，与 ZZ 相同 :q 退出，但仅未更改生效 :q! 强制退出，不保存更改 其他命令 u \u0026mdash; 撤销更改\nCtrl+R \u0026mdash; 恢复撤销 (重做) ，也就是撤销了先前的撤销操作\n:!command \u0026ndash; 在 :! 后跟一个 shell 命令，可直接运行，例如 :!date 查看当前日期。设置可以通过 :!bash 以启动一个新 shell，但建议进入前先保存，以防忘记返回 vi\nCtrl+g \u0026mdash; 显示正在编辑的文件名，底部还有当前所在行、文件总行数、内容百分比以及光标所在列号\n5.1.2 在文件中跳过 如果文件较长，用此方法移动更好\n命令 描述 Ctrl+f 向前翻页，一次一页 Ctrl+b 向后翻页，一次一页 Ctrl+d 向前翻半页 Ctrl+u 向后翻半页 G 转到文件最后一行 nG 转到文件第 n 行 (用数字替换 n) 5.1.3 搜索文本 通过 / 与 ? 向前或向后搜索文本，还可以使用元字符，例如\n/hello* \u0026mdash; 向前搜索 hello 开头的行\n?[pP]rint \u0026mdash; 向后搜索单词 print 或 Print\n在输入搜索后通过 n 或 N 可以在相同或相反方向载体搜索\n5.1.4 使用 ex 模式 vi 编辑器最初基于 ex 编辑器，因此无法在全屏模式下工作，但可以在 ex 模式下使用命令找到并更改一行或多行的文本，例如\n在命令模式下使用 : 进入 ex 模式\n:g/Local \u0026mdash; 搜索单词 Local，并打印相关行，如果输出结果满屏将发送到 more 命令\n:s/Local/Remote \u0026mdash; 将当前行首次出现的单词 Local 替换为 Remote\n:g/Local/s//Remote \u0026mdash; 文件每一行首次 Local 替换为 Remote\n:g/Local/s//Remote/g \u0026mdash; 文件所有 Local 替换为 Remote\n:g/Local/s//Remote/gp \u0026mdash; 文件所有 Local 替换为 Remote，并打印每一行\n5.1.5 了解更多 使用 vimtutor 将在 vim 编辑器中打开一个教程\n5.2 查找文件 为帮助找到系统中的文件，可使用一些命令\nlocate \u0026mdash; 根据名称查找文件\nfind \u0026mdash; 根据不同的属性查找文件\ngrep \u0026mdash; 在文本文件内部搜索包含所搜索文本的行\n5.2.1 使用 locate 命令根据名称查找文件 大多数 Linux 系统每天会运行一次 updatedb 命令，收集 Linux 系统中文件名并存入数据库，使用 locate 命令可从该数据库中搜索文件位置。可通过 sudo updatedb 命令更新数据库。仅可通过 locate 命令查看允许用户访问的文件\nlocate [str] ，或者使用 locate -i [str] 以忽略大小写。例如搜索包含 yexca 的目录并忽视 yexca 的大小写：locate -i yexca\n注：并不是所有的文件都在数据库，/etc/updated.conf 文件内容限制了被收集的文件\n5.2.2 使用 find 命令搜索文件 find 命令是在文件系统中搜索文件的最佳命令，可以基于不同属性 (元数据) 查找，并且可以在找到文件后进行处理\n注：文件元数据包括所有者、组、时间戳、文件大小、权限以及存储在文件 inode 中的其他信息\nfind 与 locate 的区别\n使用 find 查找将搜索文件系统，所以速度会比 locate 慢许多，不过可以实时查看系统中文件 (对于 locate 命令，如果文件过新未收录到数据库将无法被找到)。当然，使用 find 时要设置搜索起始点以限制搜索范围从而提高速度\nfind 命运有一个特殊的选项 -ls ，可以列出搜索到文件的详细信息，类似 ls -l 命令的输出\n注：对于普通用户搜索文件因权限问题会有许多错误，可将错误输出定向到 /dev/null 以忽略，即在命令末尾添加 2\u0026gt;/dev/null\n根据文件名查找文件 使用 -name 和 -iname (忽略大小写) 以输入想要搜索的文件名，也可使用文件匹配字符 (* 和 ?)，例如\n1 find /etc -iname \u0026#39;*passwd*\u0026#39; 在 /etc 目录下搜索包含 passwd 单词并忽略大小写的文件 (如不指定目录 (/etc) 将搜索当前文件夹)\n可使用 -type 选项以指定输出仅文件 (-type f) 或仅目录 (-type d)\n根据文件大小查找文件 通过 -size 选项和以 + 或 - 开头的数字查找相应范围，例如 find /etc -size +10M 查找 /etc 目录下大于 10MB 的文件\n1 find /bigdata -size +500M -size -5G -exec du -sh {} \\ 查找 /bigdata 目录下 500MB ~ 5GB 之间的文化，并针对每个文件运行 du 命令以查看文件大小\n根据用户查找文件 通过 -user 或 -group 以针对特定用户或组查找，还可使用 -not 和 -or\n1 find /home \\( -user yexca -or -user lemon \\) -ls 查找 /home 目录下 yexca 和 lemon 所拥有的文件\n根据权限查找文件 使用 -perm 选项，根据数字或字母找到文件。如果数字前使用 - ，则三位都要匹配；如果使用 + ，任一数字匹配即可；若不加东西，那么所有数字必须完整、精确匹配 (因用户不同)\n如果 find -perm /002 则将找到对 \u0026ldquo;其他人\u0026rdquo; 启用了写入权限的文件，而不用管其他权限位如何设置\n根据日期和时间查找文件 time 选项 (-atime、-ctime 和 -mtime) 能基于自文件被访问、更改或者文件的元数据被更改以来所经历的天数进行搜索。而 min 选项 (-amin、-cmin 和 -mmin) 则是基于所经历的分钟数进行修改\n在上述俩选项的参数前加 - 表示从当前时间到所查询的时间单位前的时间，+ 表示所查询时间单位之前以及更久的时间，如果省略，则完全匹配\n查看 10 分钟内被更改的内容 1 find /etc -mmin -10 查看三天内权限更改 1 find /bin /usr/bin -ctime -3 查看 300 多天未被访问的文件 1 find /var/www -atime +300 在查找文件时使用 \u0026rsquo;not\u0026rsquo; 和 \u0026lsquo;or\u0026rsquo; 通过使用 -not 或 -or 选项可以更好地搜索\n查找被 yexca 所有但不属于 yexca 组的文件 1 find /home -user yexca -not -group yexca -ls 被 yexca 所有并且大于 1GB 的文件 1 find /home -user yexca -and -size +1G -ls 查找文件和执行命令 通过使用 -exec 选项，可以在每一个找到的文件执行命令而不必确认，或使用 -ok 以确认是否执行该命令。两者语法相同\n1 2 find [options] -exec command {} \\; find [options] -ok command {} \\; 其中 {} 表示被找到的文件名，可多次使用。在命令末尾需要使用 \\; 。例如\n1 find /etc -iname passwd -exec echo \u0026#34;I found {}\u0026#34; \\; 查找名为 passwd 的文件并在 echo 的输出中包含该名称\n注：若了解更多，使用 man find 命令\n5.2.3 使用 grep 命令在文件中搜索 使用 grep 命令可以搜索包含某一文本 (搜索内容) 的文件。当搜索时，可以把包含文本的所有行打印，或只打印相关文件。grep 还可以搜索标准输出\n选项 描述 -i 忽略大小写 -v 搜索不包含指定文本的行 -r 递归搜索某目录的文件 -l 仅显示文件 \u0026ndash;color 突出显示搜索文本 (默认为红色) 在 /etc/sysconfig 目录递归搜索文本 root 1 grep -ri --color root /etc/sysconfig/ 从标准输出中搜索包含 inet 的行 1 ip addr show | grep inet ","date":"2022-11-19T21:07:03+08:00","permalink":"https://blog.yexca.net/archives/78/","title":"Linux 学习 第五章 使用文本文件"},{"content":"使用 Windows11 部署，其他系统 (如 Linux ) 请参考： AUTOMATIC1111/stable-diffusion-webui: Stable Diffusion web UI 空间占用 程序：5.3GiB (不含模型)\n运行：5.5GiB 以上\n请确保 C 盘空间至少 6GiB 再运行，否则电脑可能黑屏卡死\n环境 首先是网络环境，请确保连接上互联网\nGit\n官网： https://git-scm.com/ Python 3.10.6 以上 (最新版本可能不稳定)\n建议 3.10.8： https://www.python.org/downloads/release/python-3108/ 勾选 Add python.exe to PATH\n模型下载\n官方模型 (偏写实)\n通过磁力下载（请使用正规种子客户端）\n1 magnet:?xt=urn:btih:3a4a612d75ed088ea542acac52f9f45987488d1c\u0026amp;dn=sd-v1-4.ckpt\u0026amp;tr=udp%3a%2f%2ftracker.openbittorrent.com%3a6969%2fannounce\u0026amp;tr=udp%3a%2f%2ftracker.opentrackr.org%3a1337 其他下载方式\n访问 AUTOMATIC1111/stable-diffusion-webui Wiki Waifu 模型(二次元啦)\n访问 hakurei/waifu-diffusion-v1-3 at main 选择下载\n其他\nStable Diffusion Models (cyberes.github.io) 克隆仓库 选择一个合适的位置，右击选择 在终端中打开 ，然后输入以下命令\n1 git clone https://github.com/AUTOMATIC1111/stable-diffusion-webui.git 更新时可以进入该目录 (stable-diffusion-webui) 后使用 git pull 命令\n配置 将下载的模型放入 /models/Stable-diffusion 目录\n配置 /webui-user.bat 文件 在set VENV_DIR= 后任意输入字符串，然后保存退出\n运行 /webui-user.bat 文件\n下载文件过大 (6GiB 左右) ，可能会运行较长时间，期间无进度条提示（若感觉程序终止之类的，可通过网络带宽使用情况以判断是否正在下载）\n如果您的显示卡是 GTX1660 或者算出来的图是黑色的\n编辑 webui.bat ，在开头加入以下文本\n1 set COMMANDLINE_ARGS=--precision full --no-half 其他 详细了解： hua1995116/awesome-ai-painting: AI绘画资料合集（包含国内外可使用平台、使用教程、参数教程、部署教程、业界新闻等等） stable diffusion tutorial、disco diffusion tutorial、 AI Platform 训练模型： NovelAI hypernetwork 自训练教程 - 知乎 NovelAI软件获取 - novelai 资源站 咩小咩壁纸|NovelAI资源站 关键词例子\n1 2 NSFW, Prhololive, uruha_rushia, 1girl, bangs, bare shoulders, red eyes, blue dress, blue green hair, blue sleeves, blush, bow, breasts, chick, collarbone, detached collar, detached sleeves, double bun, eyebrows visible through hair, frills, hair orhament, medium hair, off-shoulder dress 参考文章 最火的AI绘画教程！免费开源，包教会 - 零度解说 【心得】(NSFW) AI 色圖製作體驗 + 關鍵字 @場外休憩區 哈啦板 - 巴哈姆特 ","date":"2022-10-30T16:23:07+08:00","permalink":"https://blog.yexca.net/archives/77/","title":"NovelAI 绘图 (WebUI)"},{"content":"引言 使用虚拟机安装，软件为 Fedora 的 盒子\n安装前准备 下载镜像 从 官方下载页面 下载，推荐使用 BT 下载 (请使用正规 torrent 客户端，例如 qBittorrent )\n然后放到虚拟机里\n验证引导模式 列出 efivars 目录\n1 ls /sys/firmware/efi/efivars 如果正确显示目录并且没有报告错误，则系统以 UEFI 模式引导，如果目录不存在，则可能以 BIOS 模式引导 (或 CSM 模式)\n这个虚拟机中使用 BIOS 模式\n连接到互联网 默认开启网络接口与 DHCP 服务，无需配置\n更新系统时间 开启与网络时间服务器 (NTP) 同步\n1 timedatectl set-ntp true 可使用 timedatectl status 检查服务状态\n建立硬盘分区 使用了传统的 fdisk 命令分区 (MBR 分区)，因为引导是 BIOS，采用官方的分区示例，仅做了两个分区 (swap 交换分区与其他)\n使用 fdisk -l 列出全部磁盘 (以 rom、loop 或 airoot 结尾的设备可以忽略)\n使用 fdisk /dev/设备名 开始分区\n命令 描述 n 新建分区 p 检查分区 t 改变分区类型 w 保存更改 指定分区大小使用 ++num+K/M/G/T/P ，若无后缀 (K/M/G/T/P) 则分配扇区\n格式化分区 创建交换分区 1 mkswap /dev/交换空间分区 创建文件系统 根据文件系统不同命令不同，例如 ext4 文件系统\n1 mkfs -t ext4 /dev/分区 挂载分区 将根分区挂载带 /mnt，若有多个分区，请务必先挂载根分区\n1 mount /dev/分区 /mnt 启用交换空间\n1 swapon /dev/交换空间分区 安装 选择镜像 文件 /etc/pacman.d/mirrorlist 定义了软件包从何处下载，在连接到互联网上后会自动更新，也可手动更改，我就不改了\n安装软件包 使用 pacstrap 脚本，安装 base 软件包和 Linux 内核以及 vim，如果安装其他软件包，在下面命令后加上名字即可，当然也可以之后使用 pacman 安装\n1 pacstrap /mnt base linux vim 配置系统 Fstab /etc/fstab 文件描述系统启动时如何自动挂载分区，可以使用以下命令自动生成 (使用 -U 或 -L 选项设置 UUID 或卷标，使用 UUID 以确保系统引导不会出错)\n1 genfstab -U /mnt \u0026gt;\u0026gt; /mnt/etc/fstab 检查自动配置是否正确\n1 cat /mnt/etc/fstab Chroot Chroot 至新安装的系统\n1 arch-chroot /mnt 时区 以上海时间为例\n1 ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime 生成 /etc/adjtime\n1 hwclock --systohc 此时可使用命令 date 查看时间是否正确\n本地化 编辑 /etc/locale.gen ，取消 en_GB.UTF-8 的注释\n然后生成 locale 信息\n1 locale-gen 创建 /etc/locale.conf 文件，编辑 LANG 变量，例如 LANG=en_GB.UTF-8\n网络配置 创建 /etc/hostname 文件输入主机名\n因为虚拟机使用 DHCP，就不 配置网络 了\nRoot 密码 1 passwd 安装引导程序 一般安装 GRUB，我用的虚拟机为 BIOS+MBR，安装 grub 软件包\n1 pacman -S grub 安装 grub (下属命令 /dev/设备，注意不是分区)\n1 grub-install --target=i386-pc /dev/设备 生成配置文件\n1 grub-mkconfig -o /boot/grub/grub.cfg 重启 使用 exit 或 Ctrl+D 退出 chroot 环境\n使用 umount -R /mnt 卸载被挂载的分区\n重启 reboot\n参考资料 Installation guide (简体中文) - ArchWiki ","date":"2022-10-02T13:39:26+08:00","permalink":"https://blog.yexca.net/archives/76/","title":"虚拟机中 Arch Linux 安装记录"},{"content":"第四章 在文件系统中移动 Linux 文件系统存储了计算机上所有的信息\n目录 描述 /bin 包含常见的 Linux 用户命令，比如 ls、sort、date 和 chmod /boot 包含可启动的 Linux 内核、最初的 RAM 盘和启动加载程序的配置文件 (GRUB) /dev 包含用来表示系统中设备访问点的文件。这些设备包括终端设备 (tty*) 、硬盘驱动器 (hd* 或 sd*) 、RAM (ram*) 以及 CD-ROM (cd*) 。用户可以直接通过这些设备文件访问相应的设备；然而，应用程序通常会对最终用户隐藏实际的设备名称 /etc 包含管理配置文件。其中大多数文件都是纯文本文件，只要用户拥有适当的权限，就可以使用任何文本编辑器编辑这些配置文件 /home 包含分配给每个带有登录账号的普通用户的目录 (root 用户是一个例外，使用 /root 作为主目录) /media 为自动挂载设备 (特别是可移动介质) 提供了一个标准位置。如果介质有一个卷名，那么一般来说使用该卷名作为挂载点 /lib 包含 /bin 和 /sbin 目录中的应用程序启动系统所需的共享库 /mnt 在该目录被标准的 /media 目录取代之前，/mnt 目录是许多设备常见的挂载点。一些可启动的 Linux 系统仍使用该目录来挂载硬盘分区和远程文件系统。此外很多人也在使用该目录临时挂载那些不需要永久挂载的本地或远程文件系统 /misc 该目录有时用来根据请求自动挂载文件系统 /opt 用来存储附加应用程序软件的目录结构 /proc 包含关于系统资源的信息 /root 表示 root 用户的主目录。因安全原因，没有位于 /home /sbin 包含管理命令和守护进程 /sys 包含用于调优块存储和管理 cgroups 的参数 /tmp 包含应用程序使用的临时文件 /usr 包含用户文档、游戏、图形文件 (X11) 、库 (lib) 以及其他不需要在启动过程中使用的命令和文件。/usr 目录中的文件在安装完毕就不可更改。理论上来讲，/usr 可以采用只读方式挂载 /var 包含不同应用程序所使用的数据目录。尤其可以在该目录中放置作为 FTP 服务器 (/var/ftp) 或 Web 服务器 (/var/www) 共享的文件。还包含所有的系统日至文件 (/var/log) 以及假脱机文件 (/var/spool，如 mail、cups 和 news) 。/var 目录所包含的目录和文件经常被修改。在服务器计算机上，通常会创建一个 /var 目录作为一个单独的文本系统，使用一个易于拓展的文件系统 4.1 使用基本的文件系统命令 cd 、pwd 、mkdir 、rmdir 、ls 、touch\n4.2 使用元字符和运算符 某些特殊字符被称为元字符或运算符\n4.2.1 使用文件匹配元字符 元字符 描述 * 匹配任何数量的字符 ? 匹配任何一个字符 [\u0026hellip;] 匹配括号之间的任一字符，可以包括一个连字符分隔的字母或数字范围 例如 ls [a-g]* 列举以字母 a 到字母 g 开头的文件或目录\n4.2.2 使用文件重定向元字符 元字符 描述 \u0026lt; 将文件的内容定向到命令。命令的默认行为，可省略，例如使用less bigfile 等同于 less \u0026lt; bigfile \u0026gt; 将命令的标准输出定向到一个文件。如果文件存在将被重写 (覆盖) 2\u0026gt; 将标准错误 (错误消息) 定向到文件 \u0026amp;\u0026gt; 将标准输出和标准错误都定向到文件 \u0026raquo; 将命令的输出定向到一个文件，并将该输出添加到现有文件的末尾 例如以下命令\n1 man chmod | col -b \u0026gt; /tmp/chmod 设置了手册页的格式 (使用 man 命令) ，删除了额外的退格键 (col -b) 以及将输出发送到文件 /tmp/chmod (如果文件存在，则删除之前的 /tmp/chmod 文件)\n1 echo \u0026#34;Hello World!\u0026#34; \u0026gt;\u0026gt; ~/hello 将文本 Hello World! 添加到 ~/hello\n重定向的另一种类型被称为 here text (或者 here document) ，例如\n1 2 3 4 5 6 7 ed /etc/resolv.conf \u0026lt;\u0026lt; resendit a nameserver 100.100.100.100 . w q resendit 通过 ed 文本编辑器向 /etc/resolv.conf 文件 (root 用户运行的脚本) 执行俩 resendit 之间的内容 (示例为添加 DNS 服务器的 IP 地址)\n4.2.3 使用括号拓展字符 通过使用大括号 {} 可以跨文件名、目录名或者命令中的其他参数扩展一组字符，例如\n1 touch memo{1,2,3,4,5} 将创建 memo1~memo5 共 5 个文件\n1 touch {John,Bill,Sally}-{Breakfast,Lunch,Dinner} 将创建 9 个文件\n1 touch {a..f}{1..5} 将创建 a1~f5 共 30 个文件\n4.3 列出文件和目录 一般 ls 命令被设置别名为 ls --color=auto ，可通过下面命令查看别名\n1 alias ls 使用 ls -la 命令可以查看详细信息 (-l) 和所有文件 (-a)\n列 文件 目录 1 权限 权限 2 链接到该项目的数量 链接到该项目的数量 3 文件所有者 目录所有者 4 文件所属组 目录所属组 5 文件的字节大小 包含该目录信息的文件的大小，非目录包含文件大小 6 最近一次修改的日期和时间 最近一次修改的日期和时间 7 文件名 目录名 注：\n时间和日期列的格式可以更改，根据 LANG 变量\n有时可执行文件权限为 s (-rwsr-sr-x) ，表示应用可被任何用户访问，但运行进程的所有权为应用程序的用户/组，而不是启动该命令的用户\n如果目录权限末尾是 t (drwxrwxr-t) ，则表示为该目录设置了一个粘滞位。表明目录的所有者允许其他用户添加文件，但阻止删除其他人添加的文件\n通过为某一目录分配一个 Set GID，该目录中所创建的任何文件都被分配到与目录组相同的组。如果在一个目录上看到的是一个大写 S 或 T 而不是执行位，则意味着分别设置了 Set GID 或粘滞位，而出于某些原因执行位没有开启\n如果权限末尾是加号 (-rw-rw-r-+) ，则说明在文件上设置了扩展属性，如 ACL 或 SELinux。末尾的点表示在文件中设置了 SELinux\n通过 cd ~yexca 可访问 yexca 的主目录，cd - 以返回之前的工作目录 ($OLDPWD 指向的目录) ，而cd . 指向当前工作目录 ($PWD)\nls 命令：-t 以最新修改时间顺序显示文件；-F 在目录后添加 / ，可执行文件后添加 * ，符号链接旁显示 @；--hide=yexca 隐藏显示 yexca 这个文件或目录；-S 按文件大小列出文件；-d 显示该目录的信息而非目录所包含的文件和目录\n4.4 了解文件权限和所有权 对于 ls -l 命令第一列\n第一位为文件类型\n字母 类型 - 文件 d 目录 l 符号链接 b 块设备 c 字符设备 s 套接字 p 命名的管道 后九位为权限，前三位为用户 (u) 的，中三位为所在组 (g) 的，后三位为其他人 (o) 的 (连起来就是 ugo，即尤吉欧)\n对于文件和目录，权限位含义略有不同\n权限 文件 目录 Read 查看文件内容 查看目录所包含的文件和子目录 Write 更改文件内容，重命名或删除文件 向目录添加文件或子目录。删除目录中的文件或子目录 Execute 将文件作为一个程序运行 将目录更改为当前目录，搜索目录或执行该目录中一个程序，访问目录中文件的文件元数据 (文件大小、时间戳等) 可通过 ls -ld 命令查看任何文件或目录的权限\n在 Fedora 和 Red Hat Enterprise Linux 中，当添加了一个新用户时，默认情况下该用户被分配到一个同名的组中，这种分配组的方法被称为用户专用组方案\n4.4.1 使用命令 chmod (数字) 更改权限 r = 4；w = 2；x = 1\n1 chmod -R 755 ~/myfile 更改 ~/myfile 下所有文件和目录 (-R) 和该目录的权限为 755 (rwxr-xr-x)\n4.4.2 使用 chmod (字母) 更改权限 1 chmod ug+rx files 1 chmod -R o-x ~/myfile 4.4.3 使用 umask 设置默认的文件权限 普通用户创建文件默认权限为 rw-rw-r\u0026ndash;，目录为 rwxrwxr-x。对于 root 用户分别为 rw-r\u0026ndash;r\u0026ndash; 和 rwxr-xr-x。这些默认值由 umask 值确定，输入该命令即可查看值，例如 0002\n若暂时忽略第一个 0 (前导零) ，那么 umask 值被视为对文件完全开放权限 (666) 或者对目录完全开放权限 (777) 。umask 值 002 生成对目录权限 775，文件为 644。默认情况下普通文件的执行权限被关闭\n如果临时更改 umask 值，直接 umask [权限] ，将权限值替换 [权限] ，例如 umask 000 然后创建的文件和目录权限分别为 -rw-rw-rw- 和 drwxrwxrwx\n如果永久更改需要向主目录 .bashrc 文件结尾处添加一条 umask 命令\n4.4.4 更改文件所有权 仅 root 用户可更改文件所有权\n1 chown user:group /etc/file 将 /etc/file 改为 user 所有和 group 组，可使用 -R 递归更改\n或者之更改所属用户 chown yexca /etc/file\n4.5 移动、复制和删除文件 mv、cp、rm、rmdir\nmv 命令通过添加 -i 或设置别名防止移动时重写已有文件，或使用 -b 则若有同名文件会先备份旧文件后移动新文件\ncp 命令使用 -a 将保持原来的日期/时间戳\n使用 -f 以强制应用更改 (例如 rm -rf /*)\n","date":"2022-09-25T20:35:02+08:00","permalink":"https://blog.yexca.net/archives/75/","title":"Linux 学习 第四章 在文件系统中移动"},{"content":"引言 应该是最近的最后一次折腾了，不过启用很多插件后开机后要很久才显示桌面，之后要禁用一些不常用的\n主题 通过 阅读书籍 得知 GNOME 的主题网站 ，然后去逛了下，打开第一个主题就深深吸引了我\n链接 主题： Fluent round gtk theme Github： vinceliuice/Fluent-gtk-theme: Fluent design gtk theme for linux desktops 安装 通过 Github 的 README 得知透明版的需要插件 Blur Me ，但我当时看的时候该插件不适配我的 GNOME 版本 (写文章时查看也没适配了) ，当时没装透明版本，但我忘了怎么就找到了一个支持的： Blur my Shell (这透明是真好看！！！)\n通过 Git 克隆仓库 1 git clone https://github.com/vinceliuice/Fluent-gtk-theme.git 运行脚本 1 ./install.sh 可以添加选项自定义，具体效果预览还是看 README 吧\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 -d, --dest DIR Specify destination directory (Default: /usr/share/themes) -n, --name NAME Specify theme name (Default: Fluent) -t, --theme VARIANT Specify theme color variant(s) [default|purple|pink|red|orange|yellow|green|grey|all] (Default: blue) -c, --color VARIANT Specify color variant(s) [standard|light|dark] (Default: All variants) -s, --size VARIANT Specify size variant [standard|compact] (Default: All variants) -i, --icon VARIANT Specify icon variant(s) for shell panel [default|apple|simple|gnome|ubuntu|arch|manjaro|fedora|debian|void|opensuse|popos|mxlinux|zorin] (Default: Windows icon) --tweaks Specify versions for tweaks [solid|float|round|blur|noborder|square] solid: no transparency version float: floating panel round: rounded windows blur: blur version for \u0026#39;Blur-Me\u0026#39; noborder: windows and menu with no border square: square windows button -h, --help Show help 图标 主题有一个配套的图标，这不得整上\n链接 Github： vinceliuice/Fluent-icon-theme: Fluent icon theme for linux desktops 安装 和主题差不多，先克隆仓库\n1 git clone https://github.com/vinceliuice/Fluent-icon-theme.git 然后运行脚本\n1 ./install.sh 当然也可以通过选项自定义，具体还是参考 README 吧\nDock 栏 使用插件： Dash to Dock for COSMIC 安装主题时预览的 Dock 栏不知道怎么装，但我找到了这个插件，在设置里调整一下也有透明效果\n音乐播放器 Rhythmbox 自带的音乐播放器用起来还行，但是没有单曲循环功能就有亿点不方便\nGithub： fossfreedom/alternative-toolbar: Modern, minimal and music-focused interface for Rhythmbox 安装 安装也挺简单，以下为 Fedora 安装\n先到 Releases 下载压缩包，然后配置环境\n1 sudo dnf install intltool git gnome-pkg-tools gobject-introspection glib2-devel pkg-config python3-gobject python3 然后解压并进入目录依次执行以下命令\n1 ./configure --prefix=/usr 1 make 1 sudo make install 卸载 到安装文件夹执行命令\n1 sudo make uninstall 桌面背景 想着能不能把 wallpaper engine 的视频作为桌面便去搜索了相关资料\n视频桌面 这玩意貌似不能在双显示屏情况下自动适配屏幕以及每次循环都会闪一下，弃用\n安装环境 mplayer 首先启用 rpmfusion 库\n1 sudo dnf install https://download1.rpmfusion.org/free/fedora/rpmfusion-free-release-32.noarch.rpm 然后使用 dnf 安装\n1 sudo dnf install mplayer xwinwrap 这软件只有 ubuntu 安装包，不过实际上直接解压也可以运行这个程序\n源码位置： Github deb 下载： xwinwrap_0.3.2git20171223_amd64.deb 提取文件后复制到 /usr/local/bin 然后赋予执行权限即可\n命令 如果是单显示器\n1 xwinwrap -ni -o 1 -fdt -fs -s -st -sp -b -nf -- mplayer -framedrop -nosound -loop 0 -wid WID -quiet ~/Pictures/bg.mp4 如果是双显示器，下述命令显示在右边的显示器上\n1 xwinwrap -g 1920x1080+1920+0 -fdt -ni -b -nf -- mplayer -framedrop -nosound -loop 0 -wid WID -quiet ~/Pictures/bg.mp4 具体命令选项可以 xwinwrap --help 或者看 参考文章第二篇 的相关部分\n按时自动换壁纸 虽然是可以换了，不过不仅要格式匹配还要命名，添加还得改文件，有点麻烦，弃用\n创建壁纸轮换范围 比如创建 ~/.backgrounds/pic.xml ，内容如下，根据情况替换\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 \u0026lt;background\u0026gt; \u0026lt;starttime\u0026gt; \u0026lt;year\u0026gt;2022\u0026lt;/year\u0026gt; \u0026lt;month\u0026gt;9\u0026lt;/month\u0026gt; \u0026lt;day\u0026gt;17\u0026lt;/day\u0026gt; \u0026lt;hour\u0026gt;1\u0026lt;/hour\u0026gt; \u0026lt;minute\u0026gt;00\u0026lt;/minute\u0026gt; \u0026lt;second\u0026gt;00\u0026lt;/second\u0026gt; \u0026lt;/starttime\u0026gt; \u0026lt;static\u0026gt; \u0026lt;duration\u0026gt;4000.0\u0026lt;/duration\u0026gt; \u0026lt;file\u0026gt;~/.backgrounds/pic/00001.jpg\u0026lt;/file\u0026gt; \u0026lt;/static\u0026gt; \u0026lt;transition type=\u0026#34;overlay\u0026#34;\u0026gt; \u0026lt;duration\u0026gt;847.0\u0026lt;/duration\u0026gt; \u0026lt;from\u0026gt;~/.backgrounds/pic/00001.jpg\u0026lt;/from\u0026gt; \u0026lt;to\u0026gt;~/.backgrounds/pic/00050.jpg\u0026lt;/to\u0026gt; \u0026lt;/transition\u0026gt; \u0026lt;static\u0026gt; \u0026lt;duration\u0026gt;4000.0\u0026lt;/duration\u0026gt; \u0026lt;file\u0026gt;~/.backgrounds/pic/00050.jpg\u0026lt;/file\u0026gt; \u0026lt;/static\u0026gt; \u0026lt;/background\u0026gt; static 指定某一张壁纸展示的时间 (秒) 和文件位置\ntransition 指定轮换范围以及过渡时间\n创建配置文件 比如创建 ~/.backgrounds/pic-timed.xml\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE wallpapers SYSTEM \u0026#34;gnome-wp-list.dtd\u0026#34;\u0026gt; \u0026lt;!-- /usr/share/gnome-background-properties --\u0026gt;\u0026lt;wallpapers\u0026gt; \u0026lt;wallpaper deleted=\u0026#34;false\u0026#34;\u0026gt; \u0026lt;name\u0026gt;Default Background\u0026lt;/name\u0026gt; \u0026lt;filename\u0026gt;~/.backgrounds/pic.xml\u0026lt;/filename\u0026gt; \u0026lt;options\u0026gt;zoom\u0026lt;/options\u0026gt; \u0026lt;shade_type\u0026gt;solid\u0026lt;/shade_type\u0026gt; \u0026lt;pcolor\u0026gt;#3465a4\u0026lt;/pcolor\u0026gt; \u0026lt;scolor\u0026gt;#000000\u0026lt;/scolor\u0026gt; \u0026lt;/wallpaper\u0026gt; \u0026lt;/wallpapers\u0026gt; 然后将该文件复制或者链接到 /usr/share/gnome-background-properties/ 就可以在 设置 - 背景 看到了\n或者尝试重启 gnome ( alt+F2 后输入 r )\n转换图片格式 安装 ImageMagick 后使用命令\n1 convert before.jpg after.png 随机换壁纸 很方便实用，除了每次都得手动运行 (不过或许可以创建为应用然后开机启动吧)\n创建脚本文件 1 vi ran_wallpaper.sh 输入以下内容，注意修改相关路径\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #!/bin/bash wallpaper_path=\u0026#34;~/wallpaper\u0026#34; # 壁纸路径 sleep_time=1 # 更换间隔 单位秒 find $wallpaper_path -name \u0026#39;*.*\u0026#39; | cat \u0026gt; /tmp/list # 获取图片列表 img_range_max=`cat /tmp/list | wc -l` # 获取图片数量，用来设定随机范围 while true do n=$((RANDOM%$img_range_max+1)) # 获取随机数 img_path=`awk NR==$n /tmp/list` # 获取该壁纸的完整路径 gsettings set org.gnome.desktop.background picture-uri file://$img_path # 更换壁纸命令 sleep $sleep_time done 运行 赋予运行权限\n1 chmod +x ran_wallpaper.sh 后台运行\n1 setsid ./ran_wallpaper.sh 警告 千万不要把这个脚本放进初始化守护进程服务！！！\n关闭 查找进程\n1 ps -ef |grep ran_wallpaper 第一列：用户名，第二列：PID，第三列：父级PID，最后一列：命令名称或路径\n关闭进程\n1 sudo kill -9 PID 桌面图标 其实我个人而言不是太需要，用 Win 时桌面也几乎干干净净的\n显示图标 使用插件： Gtk4 Desktop Icons NG (DING) 尽管这个插件不支持在多显示器上显示图标，但透明的背景真的很喜欢\n如果多显示器支持还是这个插件吧： Desktop Icons NG (DING) 不使用插件参考： Remove desktop support (#158) · Issues · GNOME / Files · GitLab 创建图标 新建并写入 .desktop 文件，例如\n1 2 3 4 5 6 7 8 [Desktop Entry] Name=Grey Hack # 显示的名称 Comment=Play this game on Steam # 鼠标指示的提示语 (貌似没什么用) Exec=steam steam://rungameid/605230 # 可执行程序路径 (在 Bash 下的启动方式) Icon=steam_icon_605230 # 图标的路径/定义 Terminal=false # 是否在终端运行 Type=Application # 应用类型 Categories=Game; # 分类 其他插件 左上 活动 变图标 Activities Icons 左上显示任务图标 App Icons Taskbar 音量处显示应用音量 Application Volume Mixer 剪贴板记录 Clipman 左上文件系统 Files Menu 左上应用列表 Frippery Applications Menu 自定义 GNOME Shell Just Perfection 右上切换代理 Proxy Switcher 下拉应用 quake-mode 显示桌面 Show Desktop Applet 切换声卡 Sound Input \u0026amp; Output Device Chooser 托盘图标 (Tray Icons) 放右上 Tray Icons: Reloaded 参考文章 Fedora 视频桌面 - 一个曾经的小码农\u0026hellip; Video Livestream Wallpaper For Your GNOME, Xfce Or bspwm Desktop - Linux Uprising Blog 常用的GNOME Shell 扩展 - pipci - 博客园 Linux 命令行处理图片（图片格式转换、缩放、旋转等）_打工人小飞的博客-CSDN博客 Linux切换壁纸,Linux 随机换壁纸_毛社长的博客-CSDN博客 在linux后台运行脚本命令和程序的方法大全_豆豆技术派的博客-CSDN博客 「GNOME 3」- 桌面图标（显示、Ubuntu 20.10、隐藏） - K4NZ BLOG Fedora:Gnome创建桌面图标，以Eclipse和IDEA为例 ","date":"2022-09-18T11:10:58+08:00","permalink":"https://blog.yexca.net/archives/74/","title":"Fedora 桌面折腾"},{"content":"引言 人嘛，有了比较好的就会追求更好的，欲望无穷无尽。本想整 NAS，奈何经济实力不够，于是通过四个项目在自己电脑整了入口、动画、漫画以及音声库，那么\n书接 上回 ，继续折腾\n成品展示 全部使用 Docker 部署，理论上应该只要 Docker 支持的平台就能复现\n调整了域名为 link.start.icu，本没有 .icu，可浏览器不能解析，只能加上 (不过莫名更好了吧)\n手机访问图片显示中间的 (有亿点不太理想)\n有时间把这玩意部署到服务器上搞个导航吧 (不过标题不能直接改有点麻烦，不想整 JS)\n注：使用 Docker Desktop 部署，所以就没有部署啦，可看 上回 的部署，过程差不多\n登录 Docker Hub 貌似安装 Docker Hub 使用 docker pull 要先登录\n首先到官网注册账号： Docker Hub 然后先需要初始化，执行命令\n1 gpg --generate-key 输入相关信息后注意输出的 pub 下一行的一串字符串，复制并替换为下述命令的 [pub]\n1 pass init [pub] 然后在 Docker Desktop 登录\n动画 - Jellyfin Docker Hub： jellyfin/jellyfin 官网： Jellyfin: The Free Software Media System 1 docker pull jellyfin/jellyfin 不过封面图片方面不是太理想，个人不是 NAS，懒得弄了\n可参考： 利用 Jellyfin + Bangumi 打造更舒适的动画媒体库 - 初之音 漫画 - Komga Docker Hub： gotson/komga 官网： Komga 1 docker pull gotson/komga 注：漫画过多扫描时可能会导致电脑很卡\n音声 - kikoeru-express Docker Hub： muveex/kikoeru-express Github： kikoeru-project/kikoeru-express 我下载的是 0.6.2 版本 (话说这玩意和某网站很像嘛)\n1 docker pull muveex/kikoeru-express:v0.6.2 本来看到文章想用 PLEX 的，但必须登录使用搞得有点不想用了，但界面看起来很好看，忍了。装完后发现要加自己的媒体库居然还要安装它的闭源软件，这玩意可以访问文件系统几乎所有文件 (但访问不了我挂载的) ，卸载了，可能我搞 NAS 才会再次使用吧\n引导 - Heimdall Docker Hub： linuxserver/heimdall/ 官网： Heimdall Application Dashboard 1 docker pull linuxserver/heimdall 另在 参考文章第二篇 有提到统一认证，不过我个人不是太需要就没整 (主要是看着就很复杂)\n后话 从此次折腾来看，可能并不需要为 NAS 的系统买单，硬件买电脑配件装个主机，软件装个 Linux 系统，通过各种开源项目想必应该也可以体验不错\n命令行操作不来可以装一些轻量的 GUI，例如 Xface、JWM 之类的\n参考文章 谈谈如何使用docker，搭建一台“群晖”_NAS存储_什么值得买 NAS也能用上【统一认证】_NAS存储_什么值得买 使用Plex \u0026amp; Docker搭建自己的媒体服务器 - RIN\u0026rsquo;S HOME 利用 Jellyfin + Bangumi 打造更舒适的动画媒体库 - 初之音 ","date":"2022-09-16T15:00:01+08:00","permalink":"https://blog.yexca.net/archives/73/","title":"个人内网折腾"},{"content":"引言 启用某插件后台 502 了\n进入数据库 选择进入 wp_options 表\n找到 active_plugins 条目，一般在第二页\n编辑此项目的 option_value 行\n删除不要的插件 注意：删除前先备份！！！\n找到不需要的插件的名字\n删除从 i 开始到 ;，例如 i:1;s:23:\u0026quot;elementor/elementor.php\u0026quot;;\n更改序号，也就是 i, 后的数字\n更改总数，也就是最开头 a: 后的数字\n参考文章 禁用数据库中的一个WordPress插件 - WordPress - GoDaddy 帮助 SG ","date":"2022-09-15T22:17:02+08:00","permalink":"https://blog.yexca.net/archives/72/","title":"WordPress 数据库禁用插件"},{"content":"引言 为了在内网更方便得看漫画\nIP 设置 路由器为 OpenWRT 系统\n路由器设置 在 网络- IP/MAC 绑定 将电脑绑定一个固定的 IP\nFedora 设置 因为我设置的 IP 与自动分配的不一致 (有线连接) ，固需要手动修改\n在 网络-设置 的 身份 加上 MAC 地址，IPv4 改为 手动，地址依次为 IP、255.255.255.255、路由器 IP，DNS 加上 路由器 IP，未取消勾选自动\n域名劫持 尽管可以通过 IP 直接访问，但是有一个域名会更加好记吧\n在路由器 网络-主机名 的 主机名 处填入域名，IP 地址 处填入电脑的 IP\n安装 Docker 安装了有 GUI 的 Docker Desktop\n设置仓库 1 dnf -y install dnf-plugins-core 1 2 3 sudo dnf config-manager \\ --add-repo \\ https://download.docker.com/linux/fedora/docker-ce.repo 下载 RPM 包 在 官网 Download 处 下载\n下载完成后直接双击安装\n安装 Komga Docker 设置 文件共享设置 在 Docker Desktop 的 设置-Resources-File sharing 添加漫画路径\n注：如果共享的目录在下次启动不存在 (未挂载) ，docker 将无法正常启动\n网络设置 不清楚是否非必须，在 设置-Resources-Network 设置为了自己的网段\n命令行安装 直接在 shell 敲入\n1 2 3 4 5 6 7 8 docker run \\ --name=komga \\ --user 1000:1000 \\ -p 2333:8080 \\ -v /home/yexca/komga/config:/config \\ -v /home/yexca/komga/data:/data \\ --restart unless-stopped \\ gotson/komga:latest -p 前一个为本机映射端口，后一个为容器\n-v 文件映射，将本机的目录 (/home/yexca/komga/config) 映射到容器的 (/config)\n注：无法映射本机的隐藏文件 (以 . 开头的文件)\nGUI 安装 在上一步做完后 Docker Desktop 的 Imags 会多出一个 gotson/komga，点击 run，然后配置\n第一行：名字\nPorts：映射到本机的端口，比如 80，这样就可以直接域名访问了\nVolumes：路径映射\nEnvironment variables：环境变量，此处用不到\n检测是否运行 使用命令查看\n1 docker ps -a 防火墙配置 打开端口\n1 firewall-cmd --zone=public --add-port=80/tcp 加载配置\n1 firewall-cmd --reload 查看端口打开状态\n1 firewall-cmd --zone=public --query-port=80/tcp 可能需要添加服务\n1 firewall-cmd --add-service=http 实在不能开就用 GUI 吧 (一开始就用会更快吧)\n1 sudo yum install firewall-config 参考文章 Install Docker Desktop on Fedora - Docker Documentation 【Docker】Error response from daemon: invalid mount config for type \u0026ldquo;bind\u0026rdquo;: bind source path does not exist - Qiita Run with Docker - Komga 简约但绝不简单的Komga-老苏的blog fedora 28 , firewalld 防火墙控制，firewall-cmd 管理防火墙规则 - xuyaowen - 博客园 Fedora防火墙配置 - 上官飞鸿 - 博客园 原神自动签到(Linux服务器Docker) - yexca\u0026rsquo;Blog Fedora 打开8080端口_chunqi zhi的博客-CSDN博客 ","date":"2022-09-14T18:47:16+08:00","permalink":"https://blog.yexca.net/archives/71/","title":"Fedora 安装 Komga 折腾记录"},{"content":"引言 每次连接机子都要输入密码属实有点麻烦 (因为我忘了\nOneClick 如果自己的电脑没有公钥需要先生成，一般在 ~/.ssh/id_rsa.pub\n1 ssh-keygen 然后在自己的电脑上运行下个命令\n1 ssh-copy-id username@RemoteIP 其中 username 替换为要登录的账户，RemoteIP 替换为要登录的 IP 地址\n等待提示输入密码\n然后直接 SSH 连接就可以登录上去啦\n1 ssh username@RemoteIP 非常的方便！\n写入文件 如果需要把别人的公钥写入或忘记密码可能使用这方法\n编辑配置文件 (可能需要提前更改文件权限) ~/.ssh/authorized_keys 加入公钥，一行一个，编辑完保存即可 (如果更改了文件权限别忘记改回 600)\n其实这时候已经可以免密登录了，不过可能还需要更改配置文件\n编辑文件 /etc/ssh/sshd_config\n1 2 3 PasswordAuthentication yes　# 口令登录 RSAAuthentication yes　# RSA认证 PubkeyAuthentication yes　# 公钥登录 如果需要同时使用公钥与密码验证登录\n更改上述配置文件\n1 AuthenticationMethods publickey,password 重启 SSHD 服务\n1 sudo service sshd restart 参考文章 SSH 公钥登录 - starnight_cyber - 博客园 ","date":"2022-09-12T19:24:25+08:00","permalink":"https://blog.yexca.net/archives/70/","title":"SSH 公钥登录"},{"content":"第三章 使用 shell 本章介绍的 Linux shell 称为 Bash shell，其全称为 Bourne Again shell。还有其他的 shell，例如在 BSD UNIX 用户中流行的 C shell (csh) ，以及在 UNIX System V 用户中非常流行的 Korn shel (ksh) ，Ubuntu 默认启动 Dash shell (速度比 Bash快) ，还有 Tcsh shell (一种改进的 C shell) 和 Ash shell (与 Bourne shell 非常相似)\n3.1 shell 和 Terminal 窗口 使用 Terminal 窗口 通过运行的 GUI，可以打开一个终端仿真程序 (有时也称为 Terminal 窗口) ，从而启动一个 shell\n大部分系统通过 Ctrl+Shift+T 快捷键打开，Fedora 可在程序中寻找，或者按 alt+F2 后输入 gnome-terminal\n使用虚拟控制台 大多数有 GUI 的 Linux 系统在启动时通常会运行多个虚拟控制台，虚拟控制台除了可以打开 GUI 之外，还可以打开多个 shell 会话\n通过 Ctrl+Shift+F1~F6 可切换虚拟控制台。以 Fedora 为例，tty1 为 gdm (登录屏幕) ，tty2 为第一个桌面， tty3 为第二个桌面 (纯文本) ，以此类推\n命令提示符 对于普通用户来说，默认的提示符是一个简单的美元符号\n$\n对于 root 用户来说，默认的提示符是一个英镑符号 (有时也称为 number sign 或 hash tag)\n#\n生动形象得说明了美国本源在英国\n3.2 选择 shell 使用 who 命令即可显示当前登录用户名，登录的虚拟控制台以及登录的时间\n使用 grep username /etc/passwd 命令，在输出的最后可看到默认使用的 shell\n可以通过输入命令以切换 shell，例如 ksh、tcsh、csh、sh、dash 或其他 shell (假设已经安装了这些 shell)\n学习 Bash shell 不仅是因为它是大多数安装中默认的 shell，也是因为它是大多数 Linux 认证考试中所使用的 shell\n3.3 运行命令 虽然只需要通过输入命令名称就可以运行许多命令，但更常见的做法是在命令之后输入 more，从而改变其行为。在命令之后输入的字符和单词成为选项和参数\n3.3.1 了解命令语法 大多数命令都有一个或多个用来改变命令行为的选项 一般选项由单个字母构成，并在前面添加一个连字符 - ，然而为了每次使用多个选项，也可以将多个但字母选项组合在一起，或者在每个选项前面都使用一个连字符\n一些命令的选项由一个完整的单词组成，一般需要在单词前使用双连字符 -- 。例如，为了使用 help 这个选项，需要输入 --help ，如果是 -help 将被解释为 -h 、-e 、-l 、-p 这四个选项。尽管有些命令不遵守双连字符约定，但大多数命令还是要在单词选项前使用双连字符\n此外，大多数命令还可在输入某些选项后或者整个命令行结尾处接受参数 参数是一个额外的信息块，比如文件名、目录、用户名、设备或其他用来告诉命令如何运行的信息。通常，在命令行中可以使用任意数量的参数，只要数量不超过单个命令行所允许的总字母数即可\n有时，一个参数与一个选项相关联，此时参数必须跟在选项之后。如果使用的是单字母选项，那么参数通常在一个空格后。而对于全单词选项，参数跟在一个等号 = 之后\n例如\n1 tar -cvf backup.tar /home/yexca 选项的含义是创建 (c) 一个名为 backup.tar 的文件 (f) ，其中包含 /home/yexca 目录的全部文件，并且在备份文件创建完毕 (v) 后显示详细信息。因为 backup.tar 是 f 选项的一个参数，所以 backup.tar 必须跟在选项之后\n1 ls --hide=Desktop \u0026ndash;hide 选项告诉 ls 命令不要显示名为 Desktop 的文件或目录，注意选项与参数之间没有空格\n还可以尝试其他的命令 uname 命令显示正在运行的系统类型，添加了 -a 选项后还可以查看主机名及内核版本\n当登录到一个 Linux 系统时，Linux 会认定您具有特定的身份，其中包括用户名、组名、用户 ID 和组 ID。此外，Linux 还会跟踪登录会话，从而了解登录的时间、空闲的时间以及登录的地点等。可通过 id 命令查看身份相关信息\n启用了 SELinux (Security Enhanced Linux) 的 Linux 发行版本都在 id 输出的末尾显示了额外信息，例如\ncontext=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023\nSELinux 提供了一种可以紧紧锁定 Linux 系统安全性的方法\n通过 who -uH 可添加关于空闲时间和进程 ID 信息 (u) ，以及要求打印标头 (H)\n空闲 (IDLE) 表示没有任何命令输入的情况下 shell 保持打开状态的时间长度。进程号 (PID) 表示用户登录 shell 的进程 ID。而备注 (COMMENT) 则表示用户用来进行登录操作的远程计算机名称 (前提是用户使用了网络上的另一台计算机进行登录) ，或者本地 X Display 的名称 (前提是用户正在使用一个 Terminal 窗口) ，比如 :0.0\n3.3.2 查找命令 为了找到所输入的命令，shell 在所谓的路径中进行查找，对于不在路径中的命令，可通过输入命令位置的完整标识进行运行\n通过 echo $PATH 以查看 shell 的环境变量 PATH\n参考： Linux 下 bin 目录 - yexca‘Blog 与其他一些操作系统不同的是，默认情况下，在搜索路径之前，Linux 并不会为了查找可执行文件检查当前目录，而是马上开始搜索路径，只有在可执行文件位于 PATH 环境变量或者给定了可执行文件的绝对地址或相对地址时，才会运行当前目录的可执行文件\n并不是所有的命令都位于 PATH 变量的目录中，一些命令内置于 shell，通过创建用来定义任何命令的别名以及选项，可以重写另外一些命令。下面是 shell 检查输入命令的顺序\n别名。由 alias 命令设置的名称，可输入此命令以查看创建的别名\nshell 保留字。shell 保留了一些单词用作特殊用途\n函数。一组能够在当前 shell 中共同运行的命令\n内置命令。内置于 shell 中的命令，在文件系统中没有命令的表现形式，例如 cd、echo、exit、pwd、history (查看以前运行的命令列表)、fg (将一个后台运行的命令带入前台) 、set (设置 shell 选项) 和 type (显示命令的位置)\n文件系统命令。存储在计算机文件系统中的命令 ( 这些命令由 PATH 变量值表示)\n为了知道命令的出处，可以使用 type 或者 which 命令，通过使用 type -a 可显示命令的所有已知位置\n如果一些命令不在 PATH 变量中，可使用 locate 命令尝试查找该命令，通过使用 locate 命令可以访问系统中任何可访问的部分\nlocate 命令会对整个文件系统进行查找，而不仅仅是在包含了命令的目录中查找，如果没有找到最近添加的文件，可以 root 用户身份运行 updatedb 以更新 locate 数据库\n3.4 使用命令历史记录重复执行命令 重复执行那些冗长、复杂且易于输错的命令将可以避免很多问题的出现\n3.4.1 命令行编辑 默认情况下，Bash shell 使用基于 Emacs 文本编辑器的命令行编辑。如果更喜欢使用 vi，可以将 set -o vi 添加到主目录的 .bashrc 文件中\n用来导航命令行的按键 按键 全称 含义 Ctrl+F 向前一个字符 前进一个字符 Ctrl+B 向后一个字符 后退一个字符 Alt+F 向前一个单词 前进一个单词 Alt+B 向后一个单词 后退一个单词 Ctrl+A 命令行开头 转到当前命令行的开头 Ctrl+E 命令行结尾 转到当前命令行的结尾 Ctrl+L 清除屏幕 清除屏幕，并使光标停留在屏幕顶部 用来编辑命令行的按键 按键 全称 含义 Ctrl+D 删除当前字符 删除当前字符 Backspace 删除前一个字符 删除前一个字符 Ctrl+T 调换字符 交换当前字符和前一个字符的位置 Alt+T 调换单词 交换当前单词和前一个单词的位置 Alt+U 大写单词 将当前单词改为大写 Alt+L 小写单词 将当前单词改为小写 Alt+C 首字母大写单词 把光标当前位置单词的头一个字母变为大写 Ctrl+V 插入特殊字符 添加一个特殊字符，例如添加 Tab 用来剪切和粘贴命令行中文本的按键 按键 全称 含义 Ctrl+K 剪切到行末 剪切光标后面的所有字符 Ctrl+U 剪切到行首 剪切光标后面的所有字符 Ctrl+W 剪切前一个单词 剪切位于当前光标之后的一个单词 Alt+D 剪切后一个单词 剪切位于当前光标之前的一个单词 Ctrl+Y 粘贴当前文本 粘贴最近剪切的文本 Alt+Y 粘贴早期文本 转回到早期剪切的文本并粘贴 Ctrl+C 删除整行 删除整个命令行 3.4.2 命令行补齐 为了减少按键，Bash shell 提供了多种不同的方法来补齐部分输入值。为了尝试补齐一个值，需要输入前几个字符并单击 Tab 键。下面是可以通过 Bash shell 部分输入的值：\n命令、别名或函数。如果所输入的文本以常规字符开头，shell 将尝试使用命令、别名或者函数名来补齐该文本\n变量。如果所输入的文本以美元符号 $ 开头，那么 shell 将使用来自当前 shell 的一个变量来补齐文本\n用户名。如果所输入的文本以波浪号 ~ 开头，shell 将使用一个用户名补齐文本。因此，~username 表示指定用户的主目录\n主机名。如果所输入的文本以 at 符号 @ 开头，shell 将使用来自 /etc/hosts 文件中的一个主机名补齐文本\n如果想要添加来自其他文件的主机名，只需要将 HOSTFILE 变量设置为该文件名，但该文件是与 /etc/hosts 相同的格式\n如果所输入的字符串可以产生多种补齐结果，此时可以通过双击 TAB 键列出所有可能的结果\n3.4.3 命令行重复执行 在输入完一行命令后，该命令行会保存到 shell 的历史命令列表中\n通过 history 命令查看历史命令列表，或者添加数字参数以显示指定数量的最新命令\n通过使用感叹号 ! 以重复执行这些命令，此种方法将直接执行，没有再次确认的机会\n!n \u0026mdash; 运行命令编号。例如 !255 将运行第 255 个命令\n!! \u0026mdash; 运行前一个命令\n!?string? \u0026mdash; 运行包含字符串的命令\n除了直接运行 history 外，还可重复执行特定命令并进行编辑\n按键 功能 描述 箭头键或Ctrl+P 与 Ctrl+N 步骤 遍历历史命令列表的每一个命令行，直到找到所需的命令行 Ctrl+R 反向增量搜索 按下后可输入一个搜索字符串，完成反向搜索。当输入字符串时，会出现可以运行或编辑的相匹配的命令行 Ctrl+S 向前增量搜索 与上一个类似，不过是向前搜索。并不是所有情况都可用 Alt+P 反向搜索 按下后可输入一个搜索字符串，完成反向搜索。输入字符串并单击 Enter 键后可看到该字符串的最新命令行 Alt+N 向前搜索 与上一个类似，不过是向前搜索。并不是所有情况都可用 还可使用 fc 命令以使用历史命令列表。输入 fc 后跟着一个历史命令行编号或一个范围 (例如 fc 233 255) ，将在文本编辑器中打开这些命令 (默认为 vi) ，关闭编辑器后命令将 (逐个) 运行\n关闭 shell 后，历史命令列表将保存到主目录的 .bash_history 文件中，默认最多保存1000条\n如果不想保存历史命令列表，就不要正常退出 shell，可通过 kill -9 PID 关闭 shell 会话以不保存历史命令\n将变量 HISTFILE 设置为 /dev/null 或保持 HISTSIZE 为空都是没用的，只要 shell 正常退出，就会永久保存 shell 历史\n3.5 连接和拓展命令 shell 真正强大的功能在于能将命令的输入和输出重定向到其他命令或文件中，反之亦然\n为了将命令串在一起，shell 使用了元字符 (metacharacter) 。元字符是对 shell 有特殊含义的输入字符，用于连接请求或拓展请求\n元字符包括管道字符 | 、与号 \u0026amp; 、分号 ; 、右括号 ) 、左括号 ( 、小于号 \u0026lt; 和大于号 \u0026gt;\n3.5.1 命令之间的管道 管道字符 | 将一个命令的输出连接到另一个命令的输入，例如\n1 cat /etc/passwd | sort | less 该命令列出 /etc/passwd 文件内容。输出到 sort 命令以对内容排序，最后发送到 less 以显示输出\n3.5.2 连续命令 使用分号 ; 将多个命令隔开可在同一命令行输入多条命令以执行连续的命令，例如\n1 date ; troff -me VertLargeDocument | lpr ; date 对一个很大的文档格式化，并显示格式化所需的时间\n3.5.3 后台命令 一些命令可能需要花费很长时间才能完成，可使用与号 \u0026amp; 让命令在后台运行，例如\n1 troff -me VertLargeDocument | lpr \u0026amp; 在进程结束之前不要关闭 shell 或杀死该进程，否则进程将终止\n3.5.4 拓展命令 通过命令替换，可以使一条命令的标准输出变为另一条命令的一个参数\n命令替换的两种形式是 $(command) 和 command (注意是反引号)\n两种形式中的命令可以包括选项、元字符和参数，例如\n1 vi $(find /home | grep xyzzy) 在 vi 命令运行之前完成了命令替换。首先 find 命令从 /home 目录寻找所有文件于目录，然后将输出连接到 grep 命令，将文件名中不包含 xyzzy 的过滤掉，最后使用 vi 打开所有文件进行编辑 (每次打开一个文件)\n注意：不要从根文件系统开始使用 grep，否则将匹配并尝试编辑几千个文件\n3.5.5 扩展算术表达式 有时可能需要将算术结果传递给一条命令。通过 S[expression] 或者 S(expression) ，例如\n1 echo \u0026#34;I am $[2022-1957] years old\u0026#34; 输出为 I am 65 years old\n1 echo \u0026#34;There are S(ls | wc -w) files in this directory\u0026#34; 该命令列出当前目录内容 (ls) 并运行了单词计数命令，计算出找到的文件数量 (wc -w) ，然后输出\n3.5.6 扩展变量 使用美元符号 $ 对 shell 中用来存储信息的变量进行拓展。当在命令行中扩展一个环境变量时，所打印的是变量的值，而不是变量名，例如\n1 ls -l $BASH 打印 bash 命令的长列表 -rwxr-xr-x. 1 root root 1390064 1月 20 2022 /usr/bin/bash\n3.6 使用 shell 变量 shell 本身使用变量存储了对用户的 shell 会话非常有用的信息。如果想要查看当前 shell 设置的所有变量，可以使用 set 命令\n其中，本地变量的一个子集被称为环境变量，对任何通过当前 shell 打开的新 shell 都是可用的。可以使用 env 命令查看环境变量\n除了所设置的变量之外，系统文件也会设置一些用来存储相关信息的变量，比如配置文件、邮箱以及路径目录的位置。此外，这些变量还可以存储关于 shell 提示符、历史命令列表的大小以及操作系统类型的相关值。如果想引用这些变量的值，需要在变量之前添加一个美元符号 $\n当启动一个 shell 时，许多环境变量已经被设置了，下表为一些既可以在使用 Bash shell 时设置，又可以为了使用不同功能而设置的变量\n变量 描述 BASH 包含了 Bash 命令的完整路径。其值通常为 /bin/bash BASH_VERSION 表示当前 Bash 命令版本的一个数字 EUID 表示当前用户有效的用户 ID 号。当启动 shell 时，根据 /etc/passwd 文件中的用户项进行赋值 FCEDIT fc 命令用来编辑 history 命令的文本编辑器，默认为 vi HISTFILE 历史命令文件的位置，通常位于 $HOME/bash_history HISTFILESIZE 可以存储的历史命令条目的数量。当达到该数量时，最早的命令将被丢弃，默认为 1000 HISTCMD 返回历史命令列表中当前命令的数量 HOME 主目录 HOSTTYPE 描述了 Linux 系统正在运行的计算机系统结构。对于 Intel 兼容的 PC，其值为 i386、i486 或 i386-Linux 类似的值。而对于 AMD 64 位计算机，其值为 x86_64 MAIL 邮箱文件的位置，通常为 /var/spool/mail/$USER OLDPWD 修改当前工作目录之前的工作目录 OSTYPE 用来识别当前操作系统。对于 Fedora，值为 Linux 或 Linux-gnu PATH 值为冒号 : 分隔的目录列表，主要用来查找需要输入的命令 PPID 当前 shell 的命令的进程 ID PROMPT_COMMAND 可以将该变量设置为一个命令名，以便在每次 shell 提示符显示之前运行该命令 PS1 设置 shell 提示符的值。由时命令需要额外的提示符，可以使用变量 PS2、PS3 等进行设置 PWD 表示当前目录 RANDOM 生成一个 0~99999 的随机数 SECONDS 自 shell 启动后的秒数 SHLVL 与当前 shell 会话相关联的 shell 级别数。当登录到 shell 时，值为 1，每执行一次 Bash 命令后该级别数将递增 (例如使用 su 命令或输入 bash) TMOUT 可以为该变量设置一个数字，表示 shell 可以空闲的秒数。在秒数到达后，shell 将会退出 (注销用户) 3.6.1 创建和使用别名 使用 alias 命令可以列出所有别名以及创建别名\n1 alias p = \u0026#39;pwd ; ls -CF\u0026#39; 运行 p 命令，将运行 pwd 命令后运行 ls -CF 以列的形式列出该目录的内容\n如果想删除，可使用 unalias 命令\n3.6.2 退出 shell 输入 exit 或者按 Ctrl+D\n3.7 创建自己的 shell 环境 可以通过调整 shell 以帮助更有效地工作\n3.7.1 配置 shell shell 的行为方式由多个配置文件所支持\n文件 描述 /etc/profile 为每个用户设置了用户环境信息，当首次登录时执行该文件。该文件还从 /etc/profile.d 目录的配置文件中收集相关的 shell 设置。除了为诸如用户邮箱位置以及历史文件大小的信息设置环境变量，还提供了路径值 /etc/bashrc 每次打开一个 Bash shell 时都会执行该文件，可通过每个用户的 ~/.bashrc 文件中的信息重写该文件。设置了默认的提示符，同时还可添加一个或多个别名 ~/.bash_profile 用来被每个用户用来输入 shell 具体用法的信息，只有当用户登录才会执行该文件。默认情况下，它设置一些环境变量并执行用户的 .bashrc 文件。该文件是添加环境变量的绝佳位置 ~/.bashrc 包含了特定于 Bash shell 的信息，当进行登录以及每次打开一个新 Bash shell 都会读取该文件。该文件是添加别名的好地方 ~/.bash_logout 每次注销时执行该文件，默认会清除屏幕 如果想更改 /etc/profile 或 /etc/bashrc 文件，则必须是 root 用户。一般创建 /etc/profile.d/custom.sh 文件来添加系统范围的设置，而不是直接编辑这些文件\nnano 编辑器 较为简单的文本编辑器，Ctrl+O 保存文件，Ctrl+X 退出文件\n3.7.2 设置提示符 提示符由一组字符组成，每当 shell 准备接收命令时都会显示这组字符。PS1 环境变量设置了提示符所包含的内容，如果需要额外的输入u，可以使用 PS2、PS3 以及 PS4 的值\n特殊字符 描述 \\! 显示当前命令历史记录编号，包括为用户名存储的所有以前的命令 \\# 显示当前命令的命令编号，仅包括用于获取 shell 的命令 \\$ 根据用户类型的不同，显示用户提示符 $ 或 root 提示符 # \\W 仅显示当前工作的基名 \\[ 出现在非打印字符序列之前。可用来向提示符添加终端控制序列，比如改变颜色、添加闪烁效果或使字符变粗 (所使用的终端决定了最终可用的序列) \\] 紧跟在非打印字符序列之后 \\\\ 显示一个反斜杠 \\d 显示当前日期的星期数、月份以及日子 \\h 显示正在运行 shell 的计算机的主机名 \\n 换行符 \\nnn 显示替换 nnn 的八进制数所表示的字符 \\s 显示当前 shell 的名称 \\t 以小时、分钟、秒的格式打印当前时间 \\u 打印当前用户名 \\w 显示当前工作目录的完整路径 如果仅临时修改，例如 export PS1=\u0026quot;[\\t\\w]\\$\u0026quot;\n如果永久修改，需要向 ~/.bashrc 添加 PS1 值\n阅读更多： Bash Prompt HOWTO 3.7.3 添加环境变量 有时可能需要向 .bashrc 文件添加一些环境变量\nTMOUT \u0026mdash; 设置在 Bash 自动退出之前 shell 可以处于非活跃状态多长时间\nPATH \u0026mdash; 设置了对所使用命令进行搜索的目录。例如为了添加目录 /home/yexca/bin，可添加以下代码\nPATH=$PATH: /home/yexca/bin ; export PATH\n该示例首先将所有当前的路径目录 ($PATH) 读取到新 PATH 变量中，然后添加 ~/bin 目录，最后导出新的 PATH 变量\n切勿将 . 添加到 PATH 变量，可能存在安全风险\nWHATEVER \u0026mdash; 可以创建自己的环境变量，为工作提供快捷方式。为这些变量选择一个未被使用的任何名称，并赋予一个有用的值。例如\nMYWORKDIR=/home/yexca/work ; export MYWORKDIR\n可通过输入 cd $MYWORKDIR 使设置的目录成为当前目录\n3.8 获取关于命令的信息 一些命令内置于 shell 中，例如 help | less 以浏览帮助信息，或者 help command 以查看某命令的帮助信息\n在命令中使用 --help 选项或 -h 选项以查看命令提供的帮助信息\n还有 info 和 man command 命令学习某一特定命令\n手册页是获取命令以及 Linux 系统中其他基本组件相关信息的最常用方法\n手册页有 8 个章节\n节数 节名称 描述 1 用户命令 可以由普通用户通过 shell 运行的命令 2 系统调用 某一应用程序中用来调用系统内核的编程函数 3 C 库函数 为特定编程库提供接口的编程函数 4 设备和特殊文件 表示硬件设备或软件设备的文件系统节点 5 文件格式和约定 文件类型或特定的配置文件 6 游戏 系统中可玩的游戏 7 杂项 对相关主题的 (如协议、文件系统) 概述 8 系统管理工具和守护进程 需要 root 或其他管理特权的命令 通过 man -k 可搜索手册页数据库。若无搜索结果可能是未初始化，使用 root 身份运行 mandb 以初始化数据库\n通过例如 man 5 passwd 以显示第 5 节内容\n浏览时通过 Page Down 和 Page UP 以翻页，或使用 Enter 与箭头键以移动一行。如果想要搜索，使用正斜杠 / 然后输入要搜索的内容，通过 n 重复向前搜索，N 以重复向后搜索。输入 q 以退出\n","date":"2022-09-12T15:04:10+08:00","permalink":"https://blog.yexca.net/archives/69/","title":"Linux 学习 第三章 使用 shell"},{"content":"引言 既然都有Win命令行了，那怎么能没有Linux呢\nWindows的文章： 命令行下载YouTube视频 下载yt-dlp 建议配置好Python环境，然后到 Releases · yt-dlp/yt-dlp · GitHub 下载yt-dlp，如果不想配置Python就下载yt-dlp_linux\n下载完成后赋予执行权限放在/usr/local/bin/下\n下载ffmpeg 参考官网 Download FFmpeg Fedora下使用以下命令\n1 sudo dnf install ffmpeg 配置文件 切换配置目录\n1 cd ~/.config 创建文件夹并进入\n1 2 mkdir yt-dlp cd yt-dlp 创建配置文件\n1 vi config 我的配置文件如下\n1 -f bv+ba/b -o ~/Videos/%(uploader)s/%(upload_date)s%(title)s%(id)s.%(ext)s --continue --merge-output-format mp4 解释一下\n1 2 3 4 5 6 7 8 9 10 11 12 -f bv+ba/b # 最高画质和音频 -o # 输出文件夹配置 /%(uploader)s/ # 按频道名创建文件夹 %(upload_date)s # 上传时间 %(title)s # 视频标题 %(id)s # 视频id .%(ext)s # 视频拓展名 --continue # 断点续传 --merge-output-format mp4 # 混合为mp4视频 参考文章 ffmpeg批量转换视频格式 话说自己的文章有必要放链接吗\n","date":"2022-09-10T19:29:58+08:00","permalink":"https://blog.yexca.net/archives/68/","title":"Linux 下载 youtube 视频"},{"content":"引言 这个黑幕很好玩啊，非常好玩啊，可惜首页无法渲染出来，而且 Markdown 编写渲染也难\n使用 编写文章时选择作为HTML编辑，插入以下语句\n1 \u0026lt;span class=\u0026#34;heimu\u0026#34; title=\u0026#34;黑幕弹框里的字\u0026#34;\u0026gt;需要隐藏的文字\u0026lt;/span\u0026gt; 插入CSS 本是想着实现首页也有黑幕，但实际测试发现首页不会渲染 (为什么不渲染啊啊啊啊啊啊啊！！！！！！！试试想象 Warma 的声音)\n进入后台设置，找到页脚设置，输入以下代码，或者在WP的自定义CSS处插入，不过需要去掉标签\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 \u0026lt;style\u0026gt; .heimu, .heimu a, a .heimu, .heimu a.new { background-color: #252525; color: #252525; text-shadow: none; } .heimu:hover, .heimu:active, .heimu:hover .heimu, .heimu:active .heimu { color: white !important; } .heimu:hover a, a:hover .heimu, .heimu:active a, a:active .heimu { color: lightblue !important; } .heimu:hover .new, .heimu .new:hover, .new:hover .heimu, .heimu:active .new, .heimu .new:active, .new:active .heimu { color: #BA0000 !important; } \u0026lt;/style\u0026gt; 注：因Argon不会渲染注释，所以我不把以下内容放入代码中：\n/*阅读更多：https://zh.moegirl.org/MediaWiki:Mobile.css 本文引自萌娘百科(https://zh.moegirl.org)，文字内容默认使用《知识共享 署名-非商业性使用-相同方式共享 3.0》协议。*/\n参考文章 Re：萌娘百科上的黑幕实现 – Vanilla_chan – 博客园 萌百黑幕CSS代码-Hiyoung’blog ","date":"2022-09-05T21:51:23+08:00","permalink":"https://blog.yexca.net/archives/67/","title":"萌百黑幕在 Argon 主题 WordPress 实现"},{"content":"引言 记录我使用OpenWRT路由器连接学校网的折腾过程，虽然最后的结果挺 emm？但在这个过程中还是了解到不少东西\n起始 通过在浏览器搜索openwrt通过深澜认证得到 恩山无线论坛 帖子回复下的一个开源项目： coffeehat/BIT-srun-login-script ，通过项目知道了有支持多平台（包括openwrt）的golang版本，于是开始折腾\n这是项目作者的文章： 深澜校园网登录的分析与python实现-北京理工大学版 折腾前 对于OpenWRT版本未提供编译后的版本，即IPK文件，又因为我水平不行看不懂README便请教同学得知为Linux的指令，但在实际操作后得知此命令为编译Linux内核，便放弃在实体机做开始使用虚拟机搞\n参考： Building a custom kernel/zh-cn - Fedora Project Wiki 开始折腾 另朋友发了 configuration - How to fix make error \u0026ldquo;No rule to make target \u0026lsquo;menuconfig\u0026rsquo;\u0026rdquo; when building a kernel for Beagleboard? - Unix \u0026amp; Linux Stack Exchange ，于是我便照着此帖子回答尝试\n创建虚拟机 因为我使用的Fedora自带虚拟机软件盒子，首先尝试装CentOS8，因为我的镜像文件放到了移动硬盘中，便直接挂载，选择。结果提示创建失败，然后我尝试了CentOS7，失败，然后Ubuntun，失败\n接连失败，要不是我之前用这软件创建过Win10我都快怀疑是不是软件不行了，打开错误日至，果然看不懂，不过我注意到路径有中文，于是把路径改为英文，再次尝试，失败\n然后第二天我在想既然是编辑内核，要不使用kali吧，于是把U盘中kali镜像复制到电脑，虽然最后安装失败但成功运行了，难道要把系统放本地才行吗\n于是我把CentOS7的镜像拷贝到~/Documents/下，安装成功。因想着只是编译IPK便只有root用户\n连接网络 本以为在Linux下创建Linux虚拟机可以直接共享网络的，于是我直接输入命令wget https://cdn.kernel.org/pub/linux/kernel/v5.x/linux-5.19.6.tar.xz，结果就是无法找到IP地址，使用命令ifconfig发现无IP\n参考文章 在虚拟机中设置静态IP（centos为例） 使虚拟机连上网络，不过在最后文件修改只需要将ONBOOT后的值改为yes然后加俩DNS就行\n安装git 连上网后我先装了个git，使用yum install git即可，然后配置姓名与邮箱\n1 git config --global user.name \u0026#34;Name\u0026#34; 1 git config --global user.email \u0026#34;email@example.com\u0026#34; 传输文件 继续使用wget下载Linux内核，尝试了三四次，几乎都是在50%左右下载失败而且速度很慢\n注：使用wget -c URL可实现断点续传\n然后就是盒子这个软件貌似支持直接拖拽传输，于是我在我的电脑下载好后直接托过去，失败，文件没有被传输过去，考虑到传输后的文件在~/Downloads/下，我使用的是root账户，于是我参考 Linux添加用户和管理员用户 创建了一个用户（差点把最后一步删除用户也执行了\n使用命令su username切换用户，创建文件夹~/Downloads/，再次拖入还是失败\n尝试使用盒子的共享功能将电脑的~/Public共享，但我怎么操作也不能在虚拟机里看到\n想必这软件只适配了RHEL和Fedora吧\nSSH 传输 然后我想到了通过SSH传输（因为我输入ftp发现没这个命令，懒得装了\n本地开启SSH连接，然后通过scp命令以使用SSH传输文件\n1 scp username@servername:/path/filename ~/Downloads/ 首先是确定IP，在虚拟机中输入命令ip route得知IP为10.0.2.2\n然后使用scp命令传输\n解压文件 使用tar命令解压文件\n1 tar -xzvf filename.tar.xz emm，非gzip压缩文件，那我不知道怎么解压啊\nSSH 传输 还是使用SSH传输吧，在scp命令加上-r即可传输文件夹\n开始尝试 按照步骤将解压后的文件放到/usr/src/下，把/boot下的config放到/usr/src/linux-5.19.6/.config，结果无论是把配置文件放到.config/下还是放到.config都无法运行make menuconfig命令\n总结 折腾失败，下次再来\n不过在我编写此文章时注意到原帖尝试直接在OpenWRT运行Python，有时间尝试一下\n再次尝试 然后我咨询了一位过了认证校园网的朋友(虽然他是普通路由器)，他将路由器的MAC地址改为自己电脑的，结果插上网线认证页面会自动转发到电脑，然后认证后就有网了，不过是锐捷网页认证\n然后考虑到深澜使用的是Portal认证也就是Web页面认证，既然是Web那想必就是使用HTTP了，我是否可以通过编辑HTTP报文的方式通过认证呢？那么Linux有命令可以发送HTTP报文吗，我搜了一下，发现curl与wget命令可以模拟get和post请求\n于是我打开Fiddler开始抓包，企图还原验证过程\n才怪，我用路由器连接上学校网，电脑插上网线连上路由器，输入认证页面IP，认证完成，路由器有网了\nLinux命令模拟Http的get或post请求 虽然没用到，不过既然看到了那就记录一下吧\nGET请求 curl 1 2 3 4 5 6 7 8 ## 如果这里的URL指向的是一个文件可以直接下载到本地 curl URL ## 显示全部信息 curl -i URL ## 只显示头部信息 curl -l URL ## 显示get请求全过程解析 curl -v URL wget 1 wget URL POST请求 curl 1 2 3 4 5 6 ## 通过-d参数，把访问的参数放在里面 curl -d \u0026#34;param1=value1\u0026amp;param2=value2\u0026#34; \u0026#34;URL\u0026#34; curl -d\u0026#39;param1=value1\u0026amp;param2=value2\u0026#39; -X POST URL curl -d \u0026#39;param1=value1\u0026#39; -d \u0026#39;param2=value2\u0026#39; -X POST URL wget 1 2 ## 通过--post-data参数实现 wget --post-data \u0026#39;user=name\u0026amp;passwd=passwd\u0026#39; URL 再次总结 有时候不能把某件事想的太复杂，往往很简单的事只思考而没实践就否认这种可能性是错误的，这次就是我一开始就把最后再次尝试部分否决才闹了这么一大圈~~（要不是流量卡的不行我才不会去试~~\n写到这时我想到了两句名言\n学而不思则罔，思而不学则殆\n实践得真知\n所以有些时候还是应该大胆去尝试，不要因为过多的思考而限制了自己！\n参考文章 求助深澜校园网Portal认证应该怎么刷固件？-小米无线路由器以及小米无线相关的设备-恩山无线论坛 configuration - How to fix make error \u0026ldquo;No rule to make target \u0026lsquo;menuconfig\u0026rsquo;\u0026rdquo; when building a kernel for Beagleboard? - Unix \u0026amp; Linux Stack Exchange 在虚拟机中设置静态IP（centos为例） yexca\u0026rsquo;Blog 安装Git - 廖雪峰的官方网站 Linux添加用户和管理员用户 - yexca\u0026rsquo;Blog linux 系统下如何进行用户之间的切换_M李丽的博客-CSDN博客_linux切换系统 使用ssh传输文件 - 思否 Linux tar 命令-菜鸟教程 Portal认证原理-曹世宏的博客 Linux命令发送Http的get或post请求(curl和wget两种方法)_cyl937的博客-CSDN博客 ","date":"2022-09-05T21:24:23+08:00","permalink":"https://blog.yexca.net/archives/66/","title":"记录 OpenWRT 通过深澜网络认证折腾"},{"content":"引言 因为接触了 YouTube-dl ，下载频道的所有内容非常好用，但是下载下来是 webm 格式兼容性不是太好，于是查看了使用 ffmpeg 转换格式的命令\n配置文件 后来发现改下配置文件就行，在文件后加上\n1 --merge-output-format mp4 放下我的配置文件\n1 -o \u0026#39;C:/Users/yexca/Downloads/Video/%(uploader)s/%(upload_date)s%(title)s%(id)s.%(ext)s\u0026#39; --merge-output-format mp4 单个命令 使用下述命令即可快速转码\n1 ffmpeg -i before.webm after.mp4 但一个一个转码属实是太慢了，于是想到了使用批处理\n批处理 新建记事本，输入以下代码\n1 for %%a in (*.webm) do ffmpeg -i \u0026#34;%%~a\u0026#34; -vcodec copy -f mp4 \u0026#34;%%~na.mp4\u0026#34; 其中(*.webm)为原始文件类型 “%%~na.mp4″为想要生成的文件类型\n然后保存并命名为run.bat后放到相应文件夹运行即可\n但这样每次想转不同的文件还得编辑下，不大实用啊（\ndos 然后我就看了一点 bat 文件的东西，简单写了下面的程序(需要使用GB2312编码才可以正常在命令行输出中文)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 echo off :0 echo 请输入数字选择操作 echo 1.转码 echo 2.删除 echo 3.退出 set /p choice=请选择 goto %choice% :1 set /p before=请输入转码前文件格式 set /p after=请输入转码后文件格式 echo 开始转码%before%到%after% for %%a in (*.%before%) do ffmpeg -i \u0026#34;%%~a\u0026#34; -vcodec copy -f %after% \u0026#34;%%~na.%after%\u0026#34; echo 转码完成 goto 0 :2 set /p delet=请输入需要删除的文件格式 echo 开始删除%delet% del *.%delet% del %delet% echo 删除完成 goto 0 :3 exit 放到相应文件夹下用就好了\n参考文章 youtube-dl 的一些实用技巧 · eisen blog 给新手的 20 多个 FFmpeg 命令示例 - 知乎 FDM挂了，youtube-dl鬼慢，烤肉man的末日到了！ 中 AnnMilne 的评论\n用bat命令运行ffmpeg进行批量转码-五仁的记录 Bat命令学习 - 阳光雨露\u0026amp; - 博客园 bat set命令详解_python資深小白的博客-CSDN博客 ","date":"2022-09-05T16:41:38+08:00","permalink":"https://blog.yexca.net/archives/65/","title":"ffmpeg 批量转换视频格式"},{"content":"引言 这是在我阅读了肖佳老师的书《HTTP抓包实战》后对HTTP相关内容的总结，主要还是报文相关(记录：阅读此书与写出此文章耗时5天)\nHTTP协议报文的结构 HTTP报文分2个：一个是HTTP请求报文，一个是HTTP响应报文\nHTTP请求报文(Request) HTTP请求报文分为3个部分，第一部分叫起始行(Request line)，第二部分叫首部(Request Header)，第三部分叫主体(Body)\n第一行中有Method(请求方法)、URI和协议版本。例如 GET https://blog.yexca.net/ HTTP/2\n第二部分是Header(首部)\n第三部分是Body(主体)\n注意：Header首部和Body主体之间有一个空行\nHTTP响应报文(Responese) HTTP响应报文与请求报文的结构基本一样，也分为3个部分，第一部分叫响应行(Response line)，第二部分叫响应首部(Response Header)，第三部分是0主体(Body)\n第一行有协议版本、状态码和状态码消息。例如HTTP/2 200\n第二部分是Header(首部)\n第三部分是Body(主体)\n注意：Header首部和Body主体之间有一个空行\nHTTP协议请求方法和状态码 URL格式 URL的全称为Uniform Reasource Locator，中文译名为统一资源定位符，用于完整地描述Internet上某一处资源的地址\nURL的基本格式如下：\nschema://host[:port#]/path/.../[?query-string][#anchor]\n属性 描述 schema(协议) 指定底层使用的协议(例如：http，https，ftp) host(域名) HTTP服务器的IP地址或者域名 port#(端口) HTTP服务器的默认端口是80,这种情况下端口号可以省略。如果使用了别的端口，则必须指明 path(资源的路径) 访问资源的路径 query-string(参数) 发送给HTTP服务器的数据 anchor(锚) 锚，页面内部超链接 HTTP请求方法 号 方法 描述 1 GET 请求指定的页面信息并返回实体主体 2 HEAD 类似于GET请求，只不过返回的响应中没有具体的内容，用于获取报头 3 POST 向指定资源提交数据进行处理请求(例如提交表单或者上传文件)，数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或对已有资源的修改 4 PUT 从客户端向服务器传送的数据取代指定文档的内容 5 DELETE 请求服务器删除指定的页面 GET与POST的区别 GET提交的数据会放在URL之后，以?分隔URL和传输数据(即query-string，键值对方式)，参数之间以\u0026amp;相连\n而POST方法是把提交的数据放在HTTP包的Body中\nGET提交的数据大小有限制(因为浏览器对URL的长度有限制)\n而POST方法提交的数据大小没有限制\nGET方式需要使用Request.QueryString来取得变量的值\n而POST方法通过Request.Form来获取变量的值\nHTTP状态码 HTTP状态码存在于HTTP的响应报文中，其作用是Web服务器用来告诉客户端发生了什么事\nHTTP状态码被分为5大类，随着协议的发展，HTTP规范中会定义更多的状态码吧\n状态码 已定义范围 分类 1XX 100～101 信息提示，表示请求已被成功接收，继续处理 2XX 200～206 成功，表示请求已被成功接收、理解、接受 3XX 300～305 重定向，要完成请求，必须进行进一步的处理 4XX 400～415 客户端错误，请求有语法错误或请求无法实现 5XX 500～505 服务器错误，服务器未能实现合法的请求 常见状态码 名称 释义 200 OK：服务器成功处理了请求 301/302 Moved Permanently(重定向)：请求的URL已移走。Response中应该包含一个Location URL，说明资源现在所处的位置 304 Not Modified(未修改)：客户端的缓存资源是最新的，需要客户端使用缓存 404 Not Found：未找到资源 401 禁止访问 501 Internal Server Error：服务器遇到一个错误，使其无法对请求提供服务 206(Partial Content，部分内容) 206状态码代表服务器已经成功处理了部分GET请求(只有发送GET方法的HTTP请求，Web服务器才可能返回206)\n应用比如说使用下载工具实现断点续传或者在线视频播放都是使用206状态码来实现\n例如现在打开视频网站的一个视频，对于视频所在的URL\n浏览器会发送一个GET请求，Header中包含Range: bytes=5303296-5336063，意思就是请求得到5303296-5336063之间的数据\nWeb服务器返回一个206的HTTP响应。Header中包含Content-Range: bytes 5303296-5336063/12129376，表明这次返回的内容范围\n301与302(Moved Permanently，重定向) 在得到301或302响应后，浏览器会再次请求位于Location中返回新的URL\n状态码301和302在语法上是一模一样的，都是在HTTP响应的Location中返回新的URL\n区别在于：\n301表示旧地址已经被永久移除了，这个资源不可访问了，搜索引擎会把权重算到新地址\n例如：防止用户输错域名或更换域名\n302表示旧地址的资源还在，仍然可以访问，这个重定向只是临时地从旧地址跳转到新地址，搜索引擎会把权重算到新地址\n例如：未登录状态下访问需要登陆才能访问的页面\n304(Not Modified，未修改) 状态码304表示上次的文档已经被缓存了，还可以继续使用\n400(Bad Request) 状态码400表示客户端请求有语法错误，发送的HTTP请求中的数据有错误，例如表单有错误或者Cookie有错误，不能被度武器所理解\n401(Unauthorized) 状态码401是指为授权错误。有些网页采用的是 HTTP 基本认证 (Basic Authentication) ，需要在HTTP请求Header中带上Authentication，否则服务器会返回状态码401\n404(Not Found) 该状态码表明服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求但不想说明理由时使用\n例如 BV1AB4y1D7Ft 这个视频仅在登录并且收藏的情况下才可见，否则将返回404\n403(Forbidden) 状态码403表示Web客户端发送的请求被Web服务器拒绝了。如果服务器想说明为什么拒绝请求，可以在Body中描述原因。但这个状态码通常表示服务器不想说明拒绝原因\n500(Internal Server Error) 状态码500代表服务器内部错误。出现错误的原因有很多，比如代码的错误、数据库连接语句出错、程序内部抛出异常、空指针错误等\n503(Server Unavailable) 状态码503表示服务器暂时不可用。由于服务器维护或者过载，服务器目前无法处理请求\n这个状况是临时的，并且将在一段时间以后恢复\n了解全部状态码 访问： HTTP 状态码-菜鸟教程 HTTP协议Header Header的语法格式是“key: value”，一行一个。每一个Header都有特殊的作用\nCache相关的Header HTTP请求与HTTP响应都有很多用于缓存的Header。HTTP缓存是指当Web请求抵达缓存时，如果本地有“已缓存的”副本，就可以从本地存储设备而不是原始服务器中获取该文件\nCookie Cookie是一种HTTP Cache，是HTTP中非常重要的内容。它由key=value的形式组成，比如ip_country=CN\n浏览器把Cookie通过HTTP请求中的“Cookie: header”发送给Web服务器，Web服务器通过HTTP响应中的“Set-Cookie: header”把Cookie发送给浏览器\nAccept Accept表示浏览器客户端可以接受的媒体类型。例如Accept: text/html代表可以接受服务器返回html\n通配符*代表任意类型，例如 Accept: text/html,*/*;q=0.8 代表浏览器可以处理所有的类型。一般浏览器客户端给Web服务器发送的都是类似这个\nAccept-Encoding Accept-Encoding跟压缩有关，浏览器发送HTTP请求告诉Web服务器浏览器支持的压缩形式，例如Accept-Encoding: gzip, deflate\nAccept-Language Accept-Language作用是声明自己接受的语言。注意语言与字符集的区别，中文是语言，中文有多种字符集，例如GB2312、GBK等。例如Accept-Language: en-US,en;q=0.8,zh-CN;q=0.6,zh;q=0.4,zh-TW;q=0.2\nUser-Agent User-Agent的作用是浏览器用来告诉服务器，客户端使用的操作系统及版本、CPU类型、浏览器及版本、浏览器渲染引擎、浏览器语言、浏览器插件等\n例如User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:103.0) Gecko/20100101 Firefox/103.0代表64位Linux系统，Firefox是103.0版本\n如果想要模拟各种不同的客户端，只要修改User-Agent，就可以伪装成各种客户端\nReferer Referer 主要用来让服务器判断来源页面，即用户是从哪个页面来的，网站通常用其统计用户来源，也可以用作放盗链等\nConnection 从HTTP/1.1起，系统默认都开启了Connection: Keep-Alive，保持连接特性。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件(如Apache)中设定这个时间\nHost Host的作用是指定被请求的主机和端口号，如果是80端口号会被自动隐藏\nHTTP协议中的缓存 缓存无处不在，有浏览器端的缓存、服务器端的缓存、代理服务器的缓存，还有ASP.NET页面的缓存、对象缓存、数据库缓存等等\nHTTP中具有缓存功能的是浏览器缓存和代理服务器缓存\nHTTP缓存是指当Web请求抵达缓存时，如果本地有“已缓存的”副本，就可以从本地存储设备而不是从原始服务器中提取这个文档\n缓存的优点：减少了冗余的数据传输，节省了传输时间；减少了服务器的负担，大大提高了网站的性能；加快了客户端加载网页的速度等\n如何判断缓存新鲜度 Web服务器通过以下两种方式来判断浏览器缓存是否最新\n浏览器把缓存文件的最后修改时间通过Header的If-Modified-Since告诉Web服务器。浏览器收到HTTP请求后，在Header中将文件最后修改世界Last-Modified与请求报文的If-Modified-Since相比较。若相同则说明文件是最新的，则发送状态吗304(Not Modified)给浏览器客户端；若不同则发送状态码200把最新文件发送给浏览器客户端\n浏览器把缓存文件的ETag通过Header的If-None-Match告诉Web服务器\n与缓存有关的Header HTTP请求报文Header 名称 释义 Cache-Control: max-age=0 以秒为单位 If-Modified-Since: Tue, 28 Jun 2022 00:50:56 GMT 缓存文件的最后修改时间 If-None-Match: \u0026ldquo;1771e0c387823da5329c20a76bece83c\u0026rdquo; 缓存文件的ETag值 Cache-Control: no-cache 不使用缓存 Pragma: no-cache 不使用缓存 HTTP响应报文Header 名称 释义 Cache-Control: public 响应被缓存，并且可以被多用户访问使用 Cache-Control: private 响应只能作为私有缓存，特定用户使用 Cache-Control: no-cache 提醒浏览器要从服务器提取文档进行验证 Cache-Control: no-store 绝对禁止缓存(用于机密、敏感文件) Cache-Control: max-age=60 60s后缓存过期(相对时间) Date: Thu, 01 Sep 2022 21:56:36 GMT 当前响应发送的时间 Expires: Thu, 01 Sep 2022 21:57:37 GMT 缓存过期的时间(绝对时间) Last-Modified: Tue, 28 Jun 2022 00:50:56 GMT 服务端文件的最后修改时间 Etag: \u0026ldquo;1771e0c387823da5329c20a76bece83c\u0026rdquo; 服务器文件的ETag值 注：浏览器总是优先使用cache-control，如果没有时才考虑Expires\nETag ETag是Entity Tag(实体标签)的缩写，是根据实体内容生成的一段hash字符串(类似于MD5或者SHA1之后的结果)，可以表示文件的状态。当资源发生改变时，ETag也随之发生改变\n使用ETag主要是为了解决一些Last-Modified无法解决的问题，比如说某些服务器不能精确得到文件的最后修改时间、一些文件最后修改时间改变了但是内容不变、某些文件修改特别频繁甚至达到了以秒为单位以下等\n注：Last-Modified只能精确到秒\n浏览器不使用缓存 使用Ctrl+Shift+R快捷键强制刷新浏览器，可以让浏览器不使用缓存，即浏览器的HTTP请求报文的Header中带有Cache-Control: no-cache，明确告诉Web服务器不使用缓存\n注：Pragma: no-cache与Cache-Control: no-cache作用相同，只是Pragma: no-cache是HTTP/1.0定义的，保留为了兼容性\n直接使用缓存，不经过服务器验证 使用Ctrl+R快捷键刷新浏览器，浏览器会去Web服务器验证缓存\n如果在地址栏直接输入地址并访问，浏览器会“直接使用有效的缓存”，不会发送HTTP请求去服务器验证缓存，这种情况叫作缓存命中\n公有缓存与私有缓存 公有缓存Cache-Control: public可以由多个用户共享访问，而私有缓存Cache-Control: private只能单个用户访问使用\nHTTP协议压缩和URL Encode HTTP压缩是指Web服务器和浏览器之间压缩传输文本内容的方法。HTTP采用通用的压缩算法，比如用gzip来压缩HTML、JavaScript、CSS文件\nHTTP内容编码与压缩的区别 在HTTP协议中，可以对Body部分进行编码，如可以采用gzip这样的编码，从而达到压缩的目地；也可以使用其他编码方式把内容搅乱或加密，以此来防止未被授权的第三方看到文档的内容。所以HTTP压缩其实就是HTTP内容编码的一种\nHTTP压缩的过程 浏览器发送HTTP请求Header中带Accept-Encoding: gzip,deflate告诉服务器浏览器支持gzip压缩\nWeb服务器接到HTTP请求后，先生成原始的HTTP响应，包含原始的Content-Type与Content-Length；然后通过gzip对HTTP响应的Body进行编码，并在编码后Header中的Content-Type与Content-Length替换为压缩后的大小，以及加上编码方式Content-Encoding: gzip；再把HTTP响应发送给浏览器\n浏览器接到HTTP响应后，根据Content-Encoding: gzip来对HTTP响应进行解码，获取到原始HTTP响应后显示出网页\n注：HTTP请求也是可以编码的，但是浏览器一般不会对HTTP请求编码\n内容编码类型 HTTP定义了一些标准的内容编码类型，并允许用扩展的形式添加更多的编码\n在Header中的Content-Encoding就是使用这些标准化的代号来说明编码时使用的算法\n编码 描述 gzip 表明实体采用GNU zip编码 compress 表明实体采用UNIX的文件压缩程序 deflate 表明实体是用zlib的格式压缩的 identity 表明没有对实体进行编码。当Header中没有Content-Encoding时，默认为此情况 gzip、compress以及deflate编码都是无损压缩算法，用于减少传输报文的大小，不会导致信息缺失。其中gzip通常效率最高，使用最为广泛\n深入理解Cookie机制 HTTP协议是无状态的，对于浏览器的每一次请求，服务器都会独立处理，不与之前或之后的请求发生关联。即使是同一个浏览器发送了3个请求，服务器也会独立处理这3个请求，服务器并不知道这3个请求是来自同一个浏览器\n会话机制与Cookie机制 服务器需要识别浏览器请求，就必须弄清楚浏览器的请求状态。既然HTTP协议是无状态的，那就让服务器和浏览器共同维护一个状态，这就是会话机制\n浏览器第一次请求服务器时，服务器创建一个会话，并将会话ID作为响应的一部分发送给浏览器\n浏览器存储会话ID，并在后续请求中带上会话ID\n服务器取得请求中的会话ID就知道是不是同一个用户了\n这样后续请求与第一次请求就产生了关联，而Cookie机制就是一种会话机制\n服务器在内存中保存会话对象，浏览器可以使用Cookie机制保存会话ID\nCookie是什么 Cookie是浏览器用来存储少量数据的一种机制，数据以key=value形式存储，多个Cookie之间以分号;分隔，浏览器发送HTTP请求时自动附带Cookie信息\nCookie最主要的作用是用来做用户认证，还可以用于保存用户的一些其他信息。也可以用于互联网精准广告定向技术，例如用户浏览了某些商品，就可以用Cookie记录下来，然后进行大数据深度分析，实现广告精准投放\n鉴于此项，目前欧洲的一些国家已经对Cookie立法，并规定必须经过用户的允许才可以保存用户的Cookie\nCookie的属性 根据网站不同，Cookie有所不同\nExpires 表示Cookie失效的时间，如果不指定则在关闭浏览器或页面时被浏览器删除\nPath 表示Cookie所属的路径，asp.net默认为/也就是根目录\n假设在同一个服务器上的目录如下：/test/、/test/cd/、/test/dd，Cookie1的Path在/test/，Cookie2的在/test/cd/，那么/test/下的所有页面都可以访问到Cookie1，而/test/dd/的自页面不能访问Cookie2.因为Cookie只能让其Path路径下的页面访问\nHttpOnly 这是个关乎安全方面的属性，将一个Cookie设置为HttpOnly后，通过JavaScript脚本将无法读取到Cookie信息，这能有效防止用XSS发起攻击\n一般来说，跟登录相关的Cookie必须设置为HttpOnly\nCookie的分类与位置 类别 描述 会话Cookie 临时的Cookie，记录了用户访问站点时的设置与偏好(例如访问本站时的Cookie)，关闭浏览器后将被删除 持久Cookie 存储在硬盘上，有过期时间。不管退出浏览器还是重启计算机都存在 网站的自动登录就是储存持久Cookie，在用户再次访问相同网站时会先在硬盘中查找相关Cookie然后放到HTTP请求报文中发送给服务器\n那么持久Cookie存在计算机那里呢？不同浏览器会在各自的独立空间存放Cookie，互不干扰\n例如Linux下Firefox的Cookie位置：~/.mozilla/firefox/xxxxxxxx.default-release/cookies.sqlite\nHTTP基本认证 HTTP协议是无状态的，浏览器和Web服务器之间可以通过Cookie来识别身份。那么一些桌面应用程序是如何跟Web服务器之间识别身份呢？\n一些网站和Web服务使用的是HTTP基本认证。有些桌面应用程序u也通过HTTP协议跟Web服务器交互，桌面应用程序一般不使用Cookie，而是把用户名+冒号+密码用Base64编码放在HTTP请求Header中的Authorization发送给服务端，这种方式叫HTTP基本认证(Basic Authentication)\n在基本认证中，Web服务器可以拒绝一个事物，要求客户端提供有效的用户名和密码，服务器会返回401状态码来初始化认证质询，并用WWW-Authenticate响应首部指定要访问的安全域。浏览器收到质询时，会打开一个对话框请求用户输入用户名和密码，然后将用户名和密码用Base64编码，再用Authorization请求首部发送给服务器\n一般家用路由器就是使用基本认证， RESTful API 就经常使用基本认证，使用命令curl -u username:password URI即可完成基本认证\nHTTP基本认证的缺点 HTTP协议是无状态的，同一个客户端对服务器的每个请求都需要认证\nBase64编码是可逆的，非常容易破解，所以基本认证相当于以明文的方式传输用户名和密码。所以基本认证一定要用HTTPS加密传输，稍微安全一点\n使用基本认证登录后，除非关闭浏览器或清除历史记录，否则无法登出。而Cookie机制的话，网站可以提供登出方式以使Cookie失效\n无法防止 重放攻击 摘要认证 摘要认证是针对基本认证存在的诸多问题而进行改良的方案。摘要认证是另一种HTTP认证协议，它试图修复基本认证的严重缺陷，进行如下改进\n通过传递用户名、密码等计算出来的摘要来解决以明文方式在网络上发送密码的问题\n通过服务器产生随机数 nonce 的方式防止恶意用户捕获并重放认证的握手过程\n通过客户端产生随机数 nonce 的方式支持客户端对服务器的认证\n通过对内容也加入摘要计算的方式，可以有选择地防止对报文内容的篡改\n参考文章 《图解HTTP》读后总结及浅谈 - yexca\u0026rsquo;Blog HTTP 状态码-菜鸟教程 IE/Firefox/Chrome等浏览器保存Cookie的位置 - 脚本小娃子 - 博客园 “登录“还是“登陆“？ - 知乎 重放攻击 - 维基百科，自由的百科全书 通俗易懂：到底什么是 REST API？ 表现层状态转换 - 维基百科，自由的百科全书 ","date":"2022-09-05T16:03:36+08:00","permalink":"https://blog.yexca.net/archives/64/","title":"HTTP 学习"},{"content":"引言 尽管 Fedora 系统自带 java 环境，不过是 OpenJDK 。有时候还是需要使用 Oracle 的\n下载 进入官网下载： Java Downloads | Oracle (下载需要登陆)\n找到 java8-Linux ，下载 x64 Compressed Archive (64位的压缩包版本)\n本文章写时文件名为 jdk-8u341-linux-x64.tar.gz\n移到相应目录 首先创建一个 java的 目录，在 /usr/local 中 1 sudo mkdir -p /usr/local/java 复制文件到此目录 假设下载的文件在 ~/Downloads ，进入下载目录\n1 cd Downloads 然后复制到上述目录\n1 sudo cp -r jdk-8u341-linux-x64.tar.gz /usr/local/java 解压缩安装文件 切换到 java 目录 1 cd /usr/local/java 解压缩安装文件 1 sudo tar xvzf jdk-8u341-linux-x64.tar.gz 配置$PATH 在 /etc/profile 末尾添加以下内容 1 2 3 4 JAVA_HOME=/usr/local/java/jdk1.8.0_341 PATH=$PATH:$HOME/bin:$JAVA_HOME/bin export JAVA_HOME export PATH 更新可用 java 版本列表 直接运行以下命令 1 sudo update-alternatives --install \u0026#34;/usr/bin/java\u0026#34; \u0026#34;java\u0026#34; \u0026#34;/usr/local/java/jdk1.8.0_341/bin/java\u0026#34; 1 1 sudo update-alternatives --install \u0026#34;/usr/bin/javac\u0026#34; \u0026#34;javac\u0026#34; \u0026#34;/usr/local/java/jdk1.8.0_341/bin/javac\u0026#34; 1 1 sudo update-alternatives --install \u0026#34;/usr/bin/javaws.itweb\u0026#34; \u0026#34;javaws.itweb\u0026#34; \u0026#34;/usr/local/java/jdk1.8.0_341/bin/javaws.itweb\u0026#34; 1 生效配置文件 首先重新加载系统范围的 PATH 文件 1 source /etc/profile 重启系统 1 reboot 切换 java 版本 可以运行命令查看 java 版本\n1 java -version 使用以下指令切换 1 sudo alternatives --config java 当前使用的 java 版本前会有+，找到相应版本，输入数字选择即可\n参考文章 如何在Fedora{OpenJDK 和 Oracle JDK}上安装Java？ ","date":"2022-09-02T17:37:51+08:00","permalink":"https://blog.yexca.net/archives/63/","title":"Fedora 安装 java8(Oracle JDK)"},{"content":" 该文章由 Hiyoung 编写\n其文章: https://blog.hiyoung.icu/2022/09/01/906d191f9a59/ Aria2是Linux下的一个下载工具,这里介绍Windows下的安装与配置,官方Aria2没有GUI界面所以配合AriaNG直接在Web界面进行操作.\nAriaNg 是一个让 aria2 更容易使用的现代 Web 前端. AriaNg 使用纯 html \u0026amp; javascript 开发, 所以其不需要任何编译器或运行环境.\n下载Aria2+AriaNG最新安装包 首先先在官网下载安装包\nAria2的Github地址 – Aria2官方文档 AriaNG的Github地址 – AriaNG官方文档 Aria2选择对应的操作系统下载压缩包即可,AriaNG解压后放在Aria2文件夹即可\nAriaNg 现在提供三种版本, 标准版、单文件版和 AriaNg Native.\n标准版适合在 Web 服务器中部署, 提供资源缓存和按需加载的功能.\n单文件版适合本地使用, 您下载后只要在浏览器中打开唯一的 html 文件即可.\nAriaNg Native 同样适合本地使用, 并且不需要使用浏览器.\n添加配置文件 将文件解压至该目录下后，你需要再新创 4 个空文件(可以先建一个空 txt 文件然后修改后缀名)：\nAria2.log （日志文件） aria2.session （用于记录下载历史，以便断点续传） aria2.conf （配置文件） HideRun.vbs （隐藏 cmd 窗口运行用到的） 修改配置文件 打开刚才创建的 aria2.conf 空文件，将以下内容填入（用记事本打开即可） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 ## \u0026#39;#\u0026#39;开头为注释内容, 选项都有相应的注释说明, 根据需要修改 ## ## 被注释的选项填写的是默认值, 建议在需要修改时再取消注释 ## ## 文件保存相关 ## # 文件的保存路径(可使用绝对路径或相对路径), 默认: 当前启动位置 dir=E:\\Aria2Download # 日志文件的保存路径 log=D:\\aria2-1.36.0-win-64bit-build1\\Aria2.log # 启用磁盘缓存, 0为禁用缓存, 需1.16以上版本, 默认:16M #disk-cache=32M # 文件预分配方式, 能有效降低磁盘碎片, 默认:prealloc # 预分配所需时间: none \u0026lt; falloc ? trunc \u0026lt; prealloc # falloc和trunc则需要文件系统和内核支持 # NTFS建议使用falloc, EXT3/4建议trunc, MAC 下需要注释此项 #file-allocation=none # 断点续传 continue=true ## 下载连接相关 ## # 最大同时下载任务数, 运行时可修改, 默认:5 #max-concurrent-downloads=5 # 同一服务器连接数, 添加时可指定, 默认:1 max-connection-per-server=5 # 最小文件分片大小, 添加时可指定, 取值范围1M -1024M, 默认:20M # 假定size=10M, 文件为20MiB 则使用两个来源下载; 文件为15MiB 则使用一个来源下载 min-split-size=10M # 单个任务最大线程数, 添加时可指定, 默认:5 #split=5 # 整体下载速度限制, 运行时可修改, 默认:0 #max-overall-download-limit=0 # 单个任务下载速度限制, 默认:0 #max-download-limit=0 # 整体上传速度限制, 运行时可修改, 默认:0 #max-overall-upload-limit=0 # 单个任务上传速度限制, 默认:0 #max-upload-limit=0 # 禁用IPv6, 默认:false #disable-ipv6=true # 连接超时时间, 默认:60 #timeout=60 # 最大重试次数, 设置为0表示不限制重试次数, 默认:5 #max-tries=5 # 设置重试等待的秒数, 默认:0 #retry-wait=0 ## 进度保存相关 ## # 从会话文件中读取下载任务 input-file=D:\\aria2-1.36.0-win-64bit-build1\\aria2.session # 在Aria2退出时保存`错误/未完成`的下载任务到会话文件 save-session=D:\\aria2-1.36.0-win-64bit-build1\\aria2.session # 定时保存会话, 0为退出时才保存, 需1.16.1以上版本, 默认:0 #save-session-interval=60 ## RPC相关设置 ## # 启用RPC, 默认:false enable-rpc=true # 允许所有来源, 默认:false rpc-allow-origin-all=true # 允许非外部访问, 默认:false rpc-listen-all=true # 事件轮询方式, 取值:[epoll, kqueue, port, poll, select], 不同系统默认值不同 #event-poll=select # RPC监听端口, 端口被占用时可以修改, 默认:6800 #rpc-listen-port=6800 # 设置的RPC授权令牌, v1.18.4新增功能, 取代 --rpc-user 和 --rpc-passwd 选项 #rpc-secret=\u0026lt;TOKEN\u0026gt; # 设置的RPC访问用户名, 此选项新版已废弃, 建议改用 --rpc-secret 选项 #rpc-user=\u0026lt;USER\u0026gt; # 设置的RPC访问密码, 此选项新版已废弃, 建议改用 --rpc-secret 选项 #rpc-passwd=\u0026lt;PASSWD\u0026gt; # 是否启用 RPC 服务的 SSL/TLS 加密, # 启用加密后 RPC 服务需要使用 https 或者 wss 协议连接 #rpc-secure=true # 在 RPC 服务中启用 SSL/TLS 加密时的证书文件, # 使用 PEM 格式时，您必须通过 --rpc-private-key 指定私钥 #rpc-certificate=/path/to/certificate.pem # 在 RPC 服务中启用 SSL/TLS 加密时的私钥文件 #rpc-private-key=/path/to/certificate.key ## BT/PT下载相关 ## # 当下载的是一个种子(以.torrent结尾)时, 自动开始BT任务, 默认:true #follow-torrent=true # BT监听端口, 当端口被屏蔽时使用, 默认:6881-6999 listen-port=51413 # 单个种子最大连接数, 默认:55 #bt-max-peers=55 # 打开DHT功能, PT需要禁用, 默认:true enable-dht=false # 打开IPv6 DHT功能, PT需要禁用 #enable-dht6=false # DHT网络监听端口, 默认:6881-6999 #dht-listen-port=6881-6999 # 本地节点查找, PT需要禁用, 默认:false #bt-enable-lpd=false # 种子交换, PT需要禁用, 默认:true enable-peer-exchange=false # 每个种子限速, 对少种的PT很有用, 默认:50K #bt-request-peer-speed-limit=50K # 客户端伪装, PT需要 peer-id-prefix=-TR2770- user-agent=Transmission/2.77 # 当种子的分享率达到这个数时, 自动停止做种, 0为一直做种, 默认:1.0 seed-ratio=0.7 # 强制保存会话, 即使任务已经完成, 默认:false # 较新的版本开启后会在任务完成后依然保留.aria2文件 #force-save=false # BT校验相关, 默认:true #bt-hash-check-seed=true # 继续之前的BT任务时, 无需再次校验, 默认:false bt-seed-unverified=true # 保存磁力链接元数据为种子文件(.torrent文件), 默认:false bt-save-metadata=true 注意:你需要将下面四行的内容修改为你自己的对应文件位置：\n1 2 3 4 5 6 7 8 # 文件的保存路径(可使用绝对路径或相对路径), 默认: 当前启动位置 dir=E:\\Aria2Download # 日志文件的保存路径 log=D:\\aria2-1.36.0-win-64bit-build1\\Aria2.log # 从会话文件中读取下载任务 input-file=D:\\aria2-1.36.0-win-64bit-build1\\aria2.session # 在Aria2退出时保存`错误/未完成`的下载任务到会话文件 save-session=D:\\aria2-1.36.0-win-64bit-build1\\aria2.session 最后两行的内容是保存下载历史的，如果有时 Aria2 不能启动的话，清空里面的内容就可以了。\n修改 HideRun.vbs 文件 打开HideRun.vbs文件,向其中添加\n1 CreateObject(\u0026#34;WScript.Shell\u0026#34;).Run \u0026#34;aria2c.exe --conf-path=aria2.conf\u0026#34;,0 接下来点击运行 HideRun.vbs 文件，（注意一定是 HideRun.vbs 文件而不是那个可执行文件！！），如果没有报错的话可以直接跳过下面这段：\n注意一下，这里也可以在文件前添加具体的文件目录前缀，但是前缀的文件目录中一定不要有空格\n例如:\n1 CreateObject(\u0026#34;WScript.Shell\u0026#34;).Run \u0026#34;C:\\Users\\he ne\\Downloads\\aria2c.exe --conf-path=aria2.conf\u0026#34;,0 但是由于 he ne 这一文件夹里面包含空格，就导致了系统不识别，类似的常见错位位置还多见于：D:Program Files (x86)，这里也是存在空格的，解决方式就是将这一前缀去除即可（但需要该 vbs 文件位于该 aria2 文件夹下）\n打开index.html 打开里面的 index.html 文件，如果显示 “已连接”，则表明搭建成功\n添加开机自启 创建 HideRun.vbs 文件的快捷方式，放入 windows 的开机自启目录即可：\n在运行窗口中输入：shell:startup\n这里便会打开自启目录文件夹，然后将该快捷方式拖入即可\n参考文章:\nAria2+AriaNG 配置指南（Win10 篇） AriaNG文档 ","date":"2022-09-01T23:06:38+08:00","permalink":"https://blog.yexca.net/archives/62/","title":"Aria2+AriaNG 配置使用"},{"content":"引言 默认情况下 Fiddler 仅抓包 HTTP，需要设置后才能捕获 HTTPS。现在大部分网站都是使用 HTTPS 或者 HSTS，所以开启 HTTPS 抓包是很必要的\nFiddler设置 在 设置-HTTPS 中勾选 Capture HTTPS traffic 即可，下一个 Ignore server certificate errors(unsafe) 也可勾选，不过可能不安全吧，然后保存\n浏览器设置 在勾选抓取 HTTPS 后使用浏览器可能会出现证书错误，即提示连接不安全或不是私密连接之类的，此时需要导入相关证书，以 Firefox 为例\n首先下载 Fiddler 证书，在上一部设置处有 Export root cerificate to Desktop，点击即可将证书导出至桌面(~/Desktop/)处\n然后进入Firefox的设置，在隐私与安全-证书处查看证书，然后导入刚刚下载的证书，将弹窗的信任什么什么全勾选\n导入完成后就可以正常访问了，Fiddler也可以正常抓取HTTPS请求与响应了\n","date":"2022-09-01T08:17:32+08:00","permalink":"https://blog.yexca.net/archives/61/","title":"Fiddler 抓包 HTTPS"},{"content":"引言 事实上命令文件放在哪都可自行决定，也就是自己想放哪就放哪，这些目录不过是约定，不过遵守约定会更好啦，毕竟没有人会想要自己的电脑一团糟吧，尤其是Linux\n优先级 Linux下的这些bin目录都是存放命令的，如果不同的目录下有相同名称的可执行程序，将通过优先级决定先运行哪个目录的二进制文件，可以通过使用命令echo $PATH查看环境变量以确定命令执行的优先级，比如我的系统输出如下：\n1 2 [yexca@yexca-PC ~]$ echo $PATH /home/yexca/.local/bin:/home/yexca/bin:/usr/local/bin:/usr/local/sbin:/usr/bin:/usr/sbin 从前到后以:分隔，越靠前优先级越高\n/bin 系统的一些指令。bin为binary的简写主要放置一些系统的必备执行档例如:cat、cp、chmod df、dmesg、gzip、kill、ls、mkdir、more、mount、rm、su、tar等\n/usr/bin 系统预装的可执行程序，会随着系统升级而改变\n后期安装的一些软件的运行脚本。主要放置一些应用软体工具的必备执行档例如c++、g++、gcc、chdrv、diff、dig、du、eject、elm、free、gnome*、 gzip、htpasswd、kfm、ktop、last、less、locale、m4、make、man、mcopy、ncftp、 newaliases、nslookup passwd、quota、smb*、wget等\n/usr/local/bin 给用户放置自己的可执行程序的地方，推荐放在这里，不会被系统升级而覆盖同名文件\n/sbin 一般是指超级用户指令**。**主要放置一些系统管理的必备程式例如:cfdisk、dhcpcd、dump、e2fsck、fdisk、halt、ifconfig、ifup、 ifdown、init、insmod、lilo、lsmod、mke2fs、modprobe、quotacheck、reboot、rmmod、 runlevel、shutdown等\n/usr/sbin 放置一些用户安装的系统管理的必备程式例如:dhcpd、httpd、imap、in.*d、inetd、lpd、named、netconfig、nmbd、samba、sendmail、squid、swap、tcpd、tcpdump等\n参考文章 Linux /usr/bin与/usr/local/bin区别_学亮编程手记的博客-CSDN博客 /bin,/sbin,/usr/sbin,/usr/bin 目录之简单区别_IT农夫的博客-CSDN博客 ","date":"2022-08-31T00:27:09+08:00","permalink":"https://blog.yexca.net/archives/60/","title":"Linux 下 bin 目录"},{"content":"引言 个人安装Fedora后装的一些东西\n修改终端快捷键 打开设置-键盘，在最下方查看及自定义快捷键\n自定义快捷键\n名称：Shell终端\n命令：gnome-terminal\n快捷键：自定\n更新系统 1 sudo dnf update 修改截图快捷键 还是习惯Win的快捷键\n上述截图处交互式截图改为Win+Shift+S\nUser目录修改为英文 中文目录及其不易使用终端操作\n先将语言改为英文\n1 export LANG=en_US 然后更新用户目录\n1 xdg-user-dirs-gtk-update 这个时候，会提示是否要将用户目录下的文件夹改为英文，选择是\n然后再将系统语言刷到中文\n1 export LANG=zh_CN.UTF-8 再执行更新用户目录命令\n1 xdg-user-dirs-gtk-update 再次输入上面的命令会提示是否改为中文，选择否，并选择不再提醒即可\nVsCode 配置环境\n1 sudo rpm --import https://packages.microsoft.com/keys/microsoft.asc 1 sudo sh -c \u0026#39;echo -e \u0026#34;[code]\\nname=Visual Studio Code\\nbaseurl=https://packages.microsoft.com/yumrepos/vscode\\nenabled=1\\ngpgcheck=1\\ngpgkey=https://packages.microsoft.com/keys/microsoft.asc\u0026#34; \u0026gt; /etc/yum.repos.d/vscode.repo\u0026#39; 刷新缓存\n1 dnf check-update 使用dnf安装\n1 sudo dnf install code 或者使用yum\n1 2 yum check-update sudo yum install code Edge浏览器 从Windows转来还不是特习惯火狐，再加上多端同步 （不过最安全的还是IE浏览器）\n下载 Microsoft Edge Web 浏览器 | Microsoft 下载.rpm\nMarkText 全平台支持的Markdown编辑器\nGitHub - marktext/marktext: 📝A simple and elegant markdown editor, available for Linux, macOS and Windows. 7-zip 安装\n1 yum install -y p7zip p7zip-plugins 压缩\n1 7z a after.7z before 解压\n1 7z x after.7z FeedReader RSS阅读器，我是在Fedora自带的软件搜索下载的\nTelegram 记得放到/opt/Telegram下再执行\nTelegram Messenger 网易云音乐 安装配置flatpak\n1 sudo dnf install flatpak 1 flatpak remote-add --if-not-exists flathub https://flathub.org/repo/flathub.flatpakrepo 安装netease.CloudMusic\n1 flatpak install flathub com.netease.CloudMusic 运行/点击图标运行\n1 flatpak run com.netease.CloudMusic 卸载\n1 flatpak uninstall com.netease.CloudMusic Nvidia驱动安装 安装\n1 sudo dnf install akmod-nvidia 可选\n1 sudo dnf install xorg-x11-drv-nvidia-cuda 安装完成后重启\n1 reboot 如果重启显示 Nvidia kernel module missing falling back to Nouveau\n首先确保禁用BIOS中的secure boot\nCheck the version of akmods package installed by running rpm -qa akmods\nRun sudo akmods --force \u0026amp;\u0026amp; sudo dracut --force to build the kernel modules\n此处参考： Fedora 34 NVIDIA kernel module missing. Falling back to nouveau - #4，来自 vk2bea - Ask Fedora 如果上述不行，请尝试使用下述方法\n卸载与Nvidia相关的全部东西sudo dnf remove \\*nvidia\\*\n安装驱动sudo dnf install akmod-nvidia\n此处参考： Nvidia kernel module missing falling back to Nouveau (Fedora 36 PR) : Fedora 桌面优化 对于我的笔记本来说默认字体有亿点小\n1 sudo dnf install gnome-tweak-tool 安装完成后在工具里会有优化这个软件\nQQ/Icalingua++ 这个QQ for Linux不会有人用吧，不会吧\n登陆和其他第三方一样报异常就离谱\nIcalingua++第三方： GitHub - Icalingua-plus-plus/Icalingua-plus-plus: A client for QQ and more. gnome拓展 不知道干什么，但感觉会有用的样子\n安装主机连接器\n1 sudo dnf install chrome-gnome-shell gnome-extensions-app 访问 Latest extensions in GNOME Shell Extensions 安装\nspeedtest 依次输入以下命令\n1 curl -s https://packagecloud.io/install/repositories/ookla/speedtest-cli/script.rpm.sh | sudo bash 1 sudo yum install speedtest Fedora已安装 git，gcc，gdb，python，OpenSDK java\nLibreOffice\n参考文章 修改 Fedora 下 user 目录为英文 – 腾讯云开发者社区-腾讯云 CentOS Fedora 利用p7zip压缩、解压文件_hkNaruto的博客-CSDN博客 Running Visual Studio Code on Linux fedora-netease-fedora网易云音乐安装脚本。该脚本用于在Fedora上一键安装网易云音乐，测试于FedoraKDE30。 Howto/NVIDIA - RPM Fusion 安装Fedora 36后# 需要做的8件事 桌面应用-如何使用 GNOME Shell 扩展 Howto/Secure Boot - RPM Fusion SPEEDTEST CLI: Internet connection measurement for developers ","date":"2022-08-24T12:13:30+08:00","permalink":"https://blog.yexca.net/archives/59/","title":"Fedora安装后"},{"content":"引言 今日使用 Git 推送提示fatal: unable to access 'https://github.com/yexca-VRChat/yexca-VRChat.github.io.git/': Failed to connect to 127.0.0.1 port 1081 after 2074 ms: Connection refused，重启电脑也没用，遂寻找解决方法 (为什么不让爷访问自己的仓库)\n解决过程 经查阅相关资料得知与代理有关，可我代理是放路由器啊\n于是我连接到另一个普通路由器再次推送还是同样问题\n然后尝试了设置 Git 的代理也是无果\n1 2 git config --global --unset http.proxy git config --global --unset https.proxy 最后想到我 WinXray 貌似好像大概开过吧，然后打开一看，果然开着 pac，关闭后再次推送成功\n参考文章 fatal: unable to access \u0026lsquo;https://github.com/fmoraless/e-commerce.git/\u0026rsquo;: Failed to connect to 127.0.0.1 port 56832: Connection refuse · Issue #11981 · desktop/desktop 解决git下载出现：Failed to connect to 127.0.0.1 port 1080: Connection refused拒绝连接错误_点亮～黑夜的博客-CSDN博客 git 报错:解决拒接接入问题_Huang_milk的博客-CSDN博客 ","date":"2022-08-15T02:44:47+08:00","permalink":"https://blog.yexca.net/archives/58/","title":"Github 拒绝访问 Connection refused"},{"content":"引言 使用 Git 可以更好的和朋友一起管理代码，也便于同步代码。由于我比较喜欢静态网站，因此使用 Git 同步网页文件很是实用\n安装 Git 登录 ROOT 账户，依次输入以下命令\n1 2 yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel perl-devel yum install git 创建用户 创建一个 Git 用户组和用户，用于运行 Git 服务\n1 2 groupadd git useradd git -g git 公钥获取 此部分为自己电脑的公钥，以 Windows 为例\n在 %UserProfile%/.ssh/ 目录下 id_rsa.pub 文件存储\n如若没有此文件，打开 cmd 运行 ssh-keygen 命令会自动生成\n导入公钥 将待导入的公钥导入 /home/git/.ssh/authorized_keys 文件里，一行一个。 若没有该文件，则创建一个\n1 2 3 4 5 cd /home/git/ mkdir .ssh chmod 755 .ssh touch .ssh/authorized_keys chmod 644 .ssh/authorized_keys 然后使用 vi 或 vim 命令将公钥导入，使用参考： vim 文本编辑 初始化 Git 仓库 选定一个目录作为 Git 仓库，假设为 /home/gitrepo/repo.git\n1 2 3 4 5 cd /home mkdir gitrepo chown git:git gitrepo cd gitrepo git init --bare repo.git 以上命令 Git 创建一个空仓库，服务器上的 Git 仓库通常都以 .git 结尾。然后，把仓库所属用户改为 git：\n1 chown -R git:git runoob.git 克隆仓库 1 2 3 git clone git@您的IP:仓库目录 // 例如 git clone git@127.0.0.1:/home/gitrepo/repo.git 同步目录 自动同步功能用到的是 Git 的钩子 (hook) 功能\n进入仓库目录 /home/gitrepo/repo.git\n1 2 cd /home/gitrepo/repo.git cd hooks 创建并编辑文件 post-receive\n1 vi post-receive 在该文件写入以下内容\n1 2 #!/bin/sh git --work-tree=同步到的目录 --git-dir=仓库位置 checkout -f 例如\n1 2 #!/bin/sh git --work-tree=/home/www/hexo --git-dir=/home/gitrepo/repo.git checkout -f 然后设置该文件读写权限\n1 chmod +x post-receive 改变 repo.git 目录的拥有者为 git 用户\n1 chown -R git:git /home/gitrepo/repo.git 更新代码 如果你可以确定什么都没有改过只是更新本地代码，直接使用\n1 git pull 正规流程\n1 2 3 4 5 6 7 8 9 // 查看本地分支文件信息，确保更新时不产生冲突 git status // 若文件有修改，可以还原到最初状态; 若文件需要更新到服务器上，应该先merge到服务器，再更新到本地 git checkout – [file name] // 查看当前分支情况 git branch // 若分支为本地分支，则需切换到服务器的远程分支 git checkout remote branch git pull 其他命令 1 2 3 4 git branch // 看看分支 git checkout aaa // 切换分支aaa git branck aaa // 创建aaa分支 git chechout -b aaa // 本地创建 aaa分支，同时切换到aaa分支。只有提交的时候才会在服务端上创建一个分支 禁用git用户的shell登录权限 出于安全考虑，我们要让 git 用户不能通过 shell 登录。可以编辑 /etc/passwd 来实现\n1 vi /etc/passwd 将\n1 git:x:1004:1004::/home/git:/bin/bash 改为\n1 git:x:1004:1004::/home/git:/usr/bin/git-shell 这样 git 用户可以通过 ssh 正常使用 git，但是无法登录 sehll\n参考文章 Linux chown 命令-菜鸟教程 Git 服务器搭建-菜鸟教程 Git - 生成 SSH 公钥 SSH key的介绍与在Git中的使用 - 简书 Git - 在服务器上搭建 Git git 更新代码到本地_ftToday的博客-CSDN博客 如何在服务器上搭建hexo博客-阿里云开发者社区 Linux权限详解（chmod、600、644、700、711、755、777、4755、6755、7755）_林20的博客-CSDN博客 详细解析Linux /etc/passwd文件 - Jtianlin - 博客园 ","date":"2022-08-13T10:28:50+08:00","permalink":"https://blog.yexca.net/archives/57/","title":"搭建 Git 服务端及同步到指定目录"},{"content":" 该文章由 Hiyoung 编写\n其文章: https://blog.hiyoung.icu/2022/08/11/607cac6fe835/ 现在主流流媒体网站都支持外链嵌入代码，但是B站(什么时候倒闭?)现在(2022/8/11)自带的外链引用默认为360P，且不能调节清晰度，非常的恶心，与Youtube相比高下立判，下面重点介绍一下B站的引用外链的参数和方法\nBilibili外链引用 原版引用链接：\n1 \u0026lt;pre class=\u0026#34;language-html\u0026#34; data-info=\u0026#34;HTML\u0026#34; data-role=\u0026#34;codeBlock\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token tag\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token tag\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026lt;\u0026lt;/span\u0026gt;iframe\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token attr-name\u0026#34;\u0026gt;src\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token attr-value\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation attr-equals\u0026#34;\u0026gt;=\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;//player.bilibili.com/player.html?aid=80433022\u0026amp;bvid=BV1GJ411x7h7\u0026amp;cid=137649199\u0026amp;page=1\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token attr-name\u0026#34;\u0026gt;scrolling\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token attr-value\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation attr-equals\u0026#34;\u0026gt;=\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;no\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token attr-name\u0026#34;\u0026gt;border\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token attr-value\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation attr-equals\u0026#34;\u0026gt;=\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;0\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token attr-name\u0026#34;\u0026gt;frameborder\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token attr-value\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation attr-equals\u0026#34;\u0026gt;=\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;no\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token attr-name\u0026#34;\u0026gt;framespacing\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token attr-value\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation attr-equals\u0026#34;\u0026gt;=\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;0\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token attr-name\u0026#34;\u0026gt;allowfullscreen\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token attr-value\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation attr-equals\u0026#34;\u0026gt;=\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;true\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token tag\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token tag\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026lt;/\u0026lt;/span\u0026gt;iframe\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; 修改后引用链接：\n1 \u0026lt;pre class=\u0026#34;language-html\u0026#34; data-info=\u0026#34;HTML\u0026#34; data-role=\u0026#34;codeBlock\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token tag\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token tag\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026lt;\u0026lt;/span\u0026gt;iframe\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token attr-name\u0026#34;\u0026gt;src\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token attr-value\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation attr-equals\u0026#34;\u0026gt;=\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;//player.bilibili.com/player.html?aid=80433022\u0026amp;bvid=BV1GJ411x7h7\u0026amp;cid=137649199\u0026amp;page=1\u0026amp;as_wide=1\u0026amp;high_quality=1\u0026amp;danmaku=1\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token attr-name\u0026#34;\u0026gt;scrolling\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token attr-value\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation attr-equals\u0026#34;\u0026gt;=\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;no\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token attr-name\u0026#34;\u0026gt;border\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token attr-value\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation attr-equals\u0026#34;\u0026gt;=\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;0\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token attr-name\u0026#34;\u0026gt;frameborder\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token attr-value\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation attr-equals\u0026#34;\u0026gt;=\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;no\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token attr-name\u0026#34;\u0026gt;framespacing\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token attr-value\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation attr-equals\u0026#34;\u0026gt;=\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;0\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token attr-name\u0026#34;\u0026gt;allowfullscreen\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token attr-value\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation attr-equals\u0026#34;\u0026gt;=\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;true\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token tag\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token tag\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026lt;/\u0026lt;/span\u0026gt;iframe\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; 哔哩哔哩外链key说明 key 说明 aid 之前 B 站使用的 AV 号 bvid 目前的 BV 号 page 第几个视频, 起始下标为 1 (默认值也是为 1)就是 B 站视频, 选集里的, 第几个视频 as_wide 是否宽屏 【1: 宽屏, 0: 小屏】 high_quality 是否高清 【1: 高清(最高1080p) / 0: 最低视频质量(默认)】 danmaku 是否开启弹幕 【1: 开启(默认), 0: 关闭】 vd_source=XXX\u0026amp;t=XXX 可加精准空降地址 YouTube外链引用 使用默认的YouTube外链即可,更高级功能可自己去 官方教程 学习\n1 \u0026lt;pre class=\u0026#34;language-html\u0026#34; data-info=\u0026#34;HTML\u0026#34; data-role=\u0026#34;codeBlock\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token tag\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token tag\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026lt;\u0026lt;/span\u0026gt;iframe\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token attr-name\u0026#34;\u0026gt;width\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token attr-value\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation attr-equals\u0026#34;\u0026gt;=\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;560\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token attr-name\u0026#34;\u0026gt;height\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token attr-value\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation attr-equals\u0026#34;\u0026gt;=\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;315\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token attr-name\u0026#34;\u0026gt;src\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token attr-value\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation attr-equals\u0026#34;\u0026gt;=\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;https://www.youtube.com/embed/OgcCOwj7wNY\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token attr-name\u0026#34;\u0026gt;title\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token attr-value\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation attr-equals\u0026#34;\u0026gt;=\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;YouTube video player\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token attr-name\u0026#34;\u0026gt;frameborder\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token attr-value\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation attr-equals\u0026#34;\u0026gt;=\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;0\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token attr-name\u0026#34;\u0026gt;allow\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token attr-value\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation attr-equals\u0026#34;\u0026gt;=\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token attr-name\u0026#34;\u0026gt;allowfullscreen\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token tag\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token tag\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026lt;/\u0026lt;/span\u0026gt;iframe\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; 视频演示 请前往 https://blog.hiyoung.icu/2022/08/11/607cac6fe835/ 观看效果\nYoutube 1 2 3 4 5 6 7 8 9 \u0026lt;iframe allow=\u0026#34;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\u0026#34; allowfullscreen=\u0026#34;\u0026#34; frameborder=\u0026#34;0\u0026#34; height=\u0026#34;315\u0026#34; loading=\u0026#34;lazy\u0026#34; src=\u0026#34;https://www.youtube.com/embed/ucbx9we6EHk\u0026#34; title=\u0026#34;YouTube video player\u0026#34; width=\u0026#34;560\u0026#34;\u0026gt;\u0026lt;/iframe\u0026gt; ### Bilibili(修改前) \u0026lt;iframe allowfullscreen=\u0026#34;true\u0026#34; border=\u0026#34;0\u0026#34; frameborder=\u0026#34;no\u0026#34; framespacing=\u0026#34;0\u0026#34; scrolling=\u0026#34;no\u0026#34; src=\u0026#34;//player.bilibili.com/player.html?aid=499408391\u0026amp;bvid=BV16K411N7qj\u0026amp;cid=230404689\u0026amp;page=1\u0026amp;as_wide=1\u0026#34;\u0026gt; \u0026lt;/iframe\u0026gt; ### Bilibili(修改后) \u0026lt;iframe allowfullscreen=\u0026#34;true\u0026#34; border=\u0026#34;0\u0026#34; frameborder=\u0026#34;no\u0026#34; framespacing=\u0026#34;0\u0026#34; scrolling=\u0026#34;no\u0026#34; src=\u0026#34;//player.bilibili.com/player.html?aid=499408391\u0026amp;bvid=BV16K411N7qj\u0026amp;cid=230404689\u0026amp;page=1\u0026amp;high_quality=1\u0026amp;danmaku=1\u0026#34;\u0026gt; \u0026lt;/iframe\u0026gt; 参考资料: Sanarous 博客 和 谷歌外链 API 教程 ","date":"2022-08-12T00:11:17+08:00","permalink":"https://blog.yexca.net/archives/56/","title":"博客视频外链引用"},{"content":"引言 最早接触 RSS 还是逛神社的时候，但当我知道有这么个东西的时候 RSS 就几乎凋零，不过还有类似于 RSSHub 之类的还在继续为之奋斗，不过 RSSHub 时常因网络问题无法连接，慢慢的放弃了。随着发现的博客越来越多，为了能够及时获取更新以及记录自己阅读过以及未阅读的文章，我再次使用 RSS\nRSS简介 RSS 的全称是 Really Simple Syndication（简易信息聚合），它是一种消息来源的格式规范，网站可以按照这种格式规范提供文章的标题、摘要、全文等信息给订阅用户，用户可以通过订阅不同网站 RSS 链接的方式将不同的信息源进行聚合，在一个工具里阅读这些内容\n换句话说，与当前主流媒体推荐内容使我们被动获取信息不同，RSS 是主动寻找知识的过程，需要我们主动发掘信息源，而且只会显示自己订阅信息源的内容\n为什么使用RSS 拿起手机，打开信息类 APP，首页就是推荐，再加上永远刷不到底部的设计和基于大数据的喜好推荐，很容易就将一天的时间陷入这些观点单一，毫无营养的内容。我不喜欢这种时间消逝的感觉，虽然学习之余需要放松刷刷，但我始终坚持放松应该要由自己掌控，不应被这种被动式接受，所以使用 RSS 也是我对信息茧房的一种抵抗吧\n往小了说，可能是为了标记自己未阅读的文章，获取自己关注的博客的文章，也为了不错过大佬的文章吧\n往大了说，在现如今推荐算法不断升级，不断精确的情况下，信息茧房愈加严重，慢慢得失去了主动获取信息的能力从而导致自己视野受限，甚至于失去学习能力\n如何使用 首先需要 RSS 阅读器，我选择 QuiteRSS ，开源软件\n然后需要 RSS 订阅源，这个需要自行寻找啦，如果网站不提供可以到 RSSHub 寻找是否有发布相关订阅源 (请保持网络环境正常)\n如何查找 RSS 订阅源： 如何查找要与 Feedzy RSS Feeds 一起使用的 RSS Feed URL 比如说本站的简体中文 RSS 订阅源： https://blog.yexca.net/feed.xml 检测是否为订阅源： Feed Validator for Atom and RSS 复制订阅源，打开软件，创建新消息源即可\n后记 唉，本来想着描述的挺好的，但真正写的时候我发现我无法使用语言来表达自己所要抒发的情感，不是无法使用语言表达，只是可能我深受各种网络信息毒害，可能，，已经不会写文章了吧。。。\n写之前想了很多，但真到写的时候却完全不知道怎么表达，就这样吧！\n参考文章/推荐阅读 求问神社的rss是啥啊 高效获取信息，你需要这份 RSS 入门指南 - 腾讯云开发者社区 RSS - 维基百科 RSS凋零——主动获取信息到推送时代 什麼是RSS？ ","date":"2022-08-09T16:08:14+08:00","permalink":"https://blog.yexca.net/archives/55/","title":"RSS"},{"content":"引言 昨日游玩接取第一个任务的记录，由于是复述，部分细节可能与实际情况不同\n接取任务 在通过某神秘人的考验后获得 HackShop 的网站，接到第一个任务\n任务内容为\u0026quot;The client wants the login credentials of the user Daronane. The remote ip of the victim is 54.44.37.52. It\u0026rsquo;s important that you access the correct machine behind the public ip. The victim\u0026rsquo;s ip LAN is 172.16.6.7\u0026quot;\n任务分析 任务要求为 Daronane 的登录凭证，受害者公网 IP 为 54.44.37.52，局域网 IP 为 172.16.6.7\n初步试探 通过 Grey Hack 单人模式游戏攻略（1）-MapleGe 文章方法尝试\n首先使用 whois 命令获得管理员邮箱地址为 Eggett@sabmi.net，向该邮箱发送 Login issue 邮件获取 Daronane 的密码为 pierra\n尝试使用 SSH 连接 54.44.37.52，输入命令 ssh Daronane@pierra 54.44.37.52 发现连接失败，错误信息为 incorrect user/password\n我怀疑是我输入错误 (毕竟手打的账号密码)，然后尝试了几次，甚至复制粘贴也是账号或密码错误便停止尝试\n我使用浏览器访问该 IP，自然是没什么线索，只有一行文字 Metlifegroup. Everything you need for your tech company 与一个图片 (貌似是树莓派)，猜测该网站可能是一个论坛，而受害者 Daronane 为该论坛用户？\n汉化游戏 想到在访问 HackShop 时弹出的 Exploits 的教程中有部分我没看懂，于是寻找该游戏汉化，打开创意工坊，果然找到了该游戏汉化 [简体中文](simplified Chinese)，订阅后重启游戏发现界面没汉化\n找到创意工坊下载地址，steam文件夹\\steamapps\\workshop\\content\\605230\\2825584160，通过阅读 README.md 文件得知需要将该文件夹下内容放至 C:\\Users\\%UserName%\\AppData\\LocalLow\\Loading Home\\Grey Hack\\ 文件夹下\n事实上只需要将 custom_lang.json 放入上述文件夹即可\n重新进入游戏，在左侧的 language 选择 Chinese 即可汉化\n阅读手册 阅读汉化后手册的 Exploits 部分 (发现和没汉化差不多)，还是不大理解这个东西是干什么的\n继续探寻 继续搜寻相关攻略，可一无所获，直到看到文章 Grey Hack: 一个比较简单的任务 - 哔哩哔哩 文章中脚本小子一词使我了解到这个 Exploits 相当于现实中的攻击脚本\n错误探索 到 HackShop 下载工具 scanlib 与 scanrouter\n尝试命令 scanlib 54.44.37.52，提示 Missing metaxploit，看不懂\n使用命令 nmap 54.44.37.52，得知该服务器开放俩端口，分别为 22 和 80，分别提供 SSH 与 HTTP 服务\n使用命令 scanrouter 得知该服务器有 Kernel_router.so:V1.0.0，然后寻找相关脚本，找到一脚本描述为 Get access to a shell，没有要求\n我将该脚本下载到 /home/yexca/hacktool，然后在终端进入该文件夹并输入命令 KernelRouterAccess 54.44.37.52，错误提示 Can't find metaxploit library in the /lib path or the current folder\n注：开始时没重命名，后来重命名为 KernelRouterAccess，以该名称为例写此文章，该文章其他脚本均为后续重命名，与商店中原名称不同\n从错误来看是缺失文件，看到 /lib 莫非是对方服务器没有相应文件不能识别所以不能进入吗？\n再次思索 考虑到通过 nmap 命令得知这个服务器开放 22 和 80 端口，又上述猜测受害者为该论坛用户，于是到 HackShop 寻找 http 脚本，找到一个脚本描述为 Grant access to the file /etc/passwd and decipher its contents，要求为 Minimum number of 1 users registered in the computer，也就是至少一名用户，该网站为论坛，估计应该不会直接使用 root 账号进行开发吧，而且估计是多用户开发\n下载脚本后输入命令 HttpPasswd 54.44.37.52 80，和使用上一个脚本一样提示 Can't find metaxploit library in the /lib path or the current folder\n我并没有惊讶，因为通过 scanrouter 命令扫描只有 Kernel_router.so:V1.0.0，没有 libhttp.so 之类的\n事实上我选择 HTTP 脚本，也是由于上述文章提到其实只要完成任务就行，不需要远程连接，你在本地执行脚本也不会留下痕迹\n然后我想着那继续尝试SSH吧，便进入 HackShop 寻找相应脚本找到一个脚本描述为 Take advantage of a vulnerability in the ssh service to inject a new password to a registered user，要求为 Any user logged in the computer，也就是有用户登陆过，考虑到开发该网站一定需要登录，所以该要求应该可以达到\n下载脚本后输入命令 SSHPasswd 54.44.37.52 22，还是提示 Can't find metaxploit library in the /lib path or the current folder\n这**怎么玩？？？贵服务器的 /lib 是啥都没有？难道我要每个种类的脚本都试一遍来确定 /lib 有什么吗？？？？那我岂不是得破产啊\n进入正轨 于是我借助搜索引擎寻找攻略，发现没有\n再次回想之前看到错误条件 Can't find metaxploit library in the /lib path or the current folder，我只看到了前面的 /lib 以及看不懂的 metaxploit，仔细查看后面有一个 or the current folder，这个 当前文件夹 是指什么呢？难道是我电脑上该脚本所处的文件夹，那我为了进攻岂不是要把相应的镜像像 libssh.so 之类的都下载一遍？\n打开黑市，并没有像 libssh.so 之类的镜像，联想到该游戏有命令 apt-get，在现实 Linux 中可以下载相关程序，于是游戏中输入命令 apt-get search ssh，果不其然有一个 libssh.so，使用命令 apt-get install libssh.so 安装 SSH\n安装完成后输入命令 SSHPasswd 54.44.37.52 22，结果还是提示 Can't find metaxploit library in the /lib path or the current folder\n我真是服了！！！\n再次打开 HackShop，我把 Tools 下的每个商品都看了一遍，其中 metaxploit.so 引起我的注意，这不就是报错信息中的那个 metaxploit 嘛！再结合错误信息中的 current folder，是不是报错因为缺少这玩意啊\n下载至脚本所在文件夹 (/home/yexca/hacktool)，考虑到 scanrouter 命令只扫到 Kernel_router.so，尝试运行 KernelRouterAccess 54.44.37.52，果然，获得了进入权限！\n获取权限 获得进入权限后想着先去删日志，输入命令 FileExplorer.exe，访问 /var/system.log，提示 Permission denied，权限不足，然后发现这脚本获得的是访客权限，那我找密码文件吧，访问 /etc/passwd，还是提示 Permission denied (事实上我几乎把该计算机的文件都看了一遍)\n啊这，那我买这脚本有屁用啊！\n因为 SSH 脚本是更改密码，风险较高，所以我使用 HTTP 脚本获取密码。输入命令 HttpPasswd 54.44.37.52 80，结果提示 can't read /etc/passwd. Permission denied，看到获取的权限是 guest，我**\n最后还是使用 SSH 脚本，输入命令 SSHPasswd 54.44.37.52 22，输入新密码 114514，成功修改了 Farraze 的密码\n输入命令 ssh Farraze@114514 54.44.37.52，成功进入受害者机器，输入命令 cat /etc/passwd，成功获取 root 的密码加密后信息\n再本地新建一个文件 (touch mima.txt)，将 root 密码信息拷如，然后解密 decipher mima.txt，成功获得 root 的密码为 44444 (这密码可还行)\n输入命令 exit 断开连接，接着输入 ssh root@44444 54.44.37.52，成功以 root 权限登入\n进入机器 进入后第一件事删除日志，然后该机器的用户有 Ralancl 和 Farraze，没有受害者 Daronane，果然是论坛用户吗，可我将这台机子翻了一遍也没找到相关东西 (顺便把这俩的钱转我账户上啦~)\n回想任务内容，提到了 IP 172.16.6.7\n输入命令 ping 172.16.6.7，显示 Ping successful，使用自己的电脑无法 Ping 通 (废话了属于是，内网的机子怎么 Ping 通)\n输入命令 nmap 172.16.6.7 查看开放端口，提示 command not found，命令未找到\n啊这，那我只好将我计算机的命令文件放到该计算机的 /bin 目录下了\n复制过去后再次输入命令 nmap 172.16.6.7，可以看到开放了 3306 端口，服务为 employees，这是啥玩意？\n通过搜索引擎得知 3306 端口一般为数据库端口，也就是说需要使用 sql 的脚本\n获得密码 进入 HackShop，搜索相关脚本，找到一个脚本描述为 Take advantage of a vulnerability in the sql service to inject a new password to a registered user，要求为 Any user logged in the computer，也就是有用户登陆过，数据库的创建必然要有用户登录过啊\n下载后输入命令 SqlChangePasswd 172.16.6.7 3306，提示 Connection refused. Address unreachable，访问拒绝，确实，数据库肯定是白名单的啦\n将脚本与 metaxploit.so 放到受害者机器 /root 目录下，再次输入命令，修改密码为 114514，修改用户为 Osquel\n那么现在问题来了，我修改密码然后呢？这服务器只开放了 3306 端口，我也进不去啊 XD\n好吧，再次进入 HackShop，搜索相关脚本，找到一个脚本描述为 Prints the contents of the file /etc/passwd，要求为 Any user logged in the computer，也就是有用户登陆过，和刚刚脚本要求一样\n将脚本放到受害者机器 /root 目录下，输入命令 SqlPrintPasswd 172.16.6.7 3306，得到该机子所以用户的密码，其中有受害者 Daronane 的\n复制到自己的电脑并解密后得到密码为: pierra\n？？？我将此密码发送给客户，得到了肯定的答复？？？\n我**\n精彩！ (来自于 YouTuber 黑镖客 的梗)\n后记 一开始就通过邮件获得了密码，然后我一阵折腾再次获得了密码 (属实是给我整无语了)\n收入为 200，但我买脚本花费远大于 200 (总体还是挺亏的)，不过脚本可以重复使用，而且探索的过程也是很有趣哒！\n这游戏的攻略可以说几乎没有啊，如果您是寻找相关攻略，希望该文章可以有所帮助\n","date":"2022-08-03T22:41:06+08:00","permalink":"https://blog.yexca.net/archives/54/","title":"记录 Grey Hack 第一个任务(获取密码)"},{"content":" 该文章由 Hiyoung 编写\n其文章: https://blog.hiyoung.icu/2022/08/03/0b5e2db181ab/ 最近经常要使用Github保存我学习过程中的代码，发现无法直接上传文件夹，遂在网上查了一下使用Git上传，所以写个博文记录一下\nGithub 端操作 1. 复制仓库地址 本地端操作 1. 在本地新建一个空文件夹 我这里已经clone完成\n2. 在文件夹内呼出 Git Bash 框 3. Clone 远程仓库 1 2 \u0026lt;pre class=\u0026#34;language-bash\u0026#34; data-info=\u0026#34;bash\u0026#34; data-role=\u0026#34;codeBlock\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token function\u0026#34;\u0026gt;git\u0026lt;/span\u0026gt; clone + 你的仓库地址 \u0026lt;span class=\u0026#34;token function\u0026#34;\u0026gt;git\u0026lt;/span\u0026gt; clone https://github.com/hiyoung3937/study_code.git //示例 4. 直接将需要上传的文件拖入即可 5. 上传 1 2 3 4 5 \u0026lt;pre class=\u0026#34;language-bash\u0026#34; data-info=\u0026#34;bash\u0026#34; data-role=\u0026#34;codeBlock\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token builtin class-name\u0026#34;\u0026gt;cd\u0026lt;/span\u0026gt; study_code.git //根据自己的远程仓库名输入 \u0026lt;span class=\u0026#34;token function\u0026#34;\u0026gt;git\u0026lt;/span\u0026gt; init \u0026lt;span class=\u0026#34;token function\u0026#34;\u0026gt;git\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token function\u0026#34;\u0026gt;add\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token builtin class-name\u0026#34;\u0026gt;.\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token function\u0026#34;\u0026gt;git\u0026lt;/span\u0026gt; commit -m “你的提交信息” \u0026lt;span class=\u0026#34;token function\u0026#34;\u0026gt;git\u0026lt;/span\u0026gt; push 命令说明 clone + 仓库地址 克隆你的仓库至本地 cd + 你的远程仓库名 进入到远程仓库内(根据自己的仓库名输入) git init 初始化Git git add . 将工作区的文件添加到暂存区（”.”是当前目录下的所有文件，也可只输入文件夹名称） git commit -m “你的提交信息” 将暂存区的文件添加到本地仓库 git push 提交到远程仓库（可能需要你输入帐号和密码） ","date":"2022-08-03T12:49:27+08:00","permalink":"https://blog.yexca.net/archives/53/","title":"使用 Git 上传文件至 Github"},{"content":"引言 哪个男孩不想使用命令行运行一些东西装逼呢。之前有所了解 youtube-dl，但看着过于复杂没去使用，今日尝试使用发现甚是好用啊！\n环境 安装 Python3.7+ 直接到 Python 官网 下载安装即可，安装时勾选Add Python x.x to PATH\n安装 yt-dlp yt-dlp 基于 youtube-dl 修改，实测下载速度较快\n下载 进入 releases 下载 yt-dlp.exe\n配置 将下载的文件放入一固定位置，打开 我的电脑 的 属性，进入 高级系统设置-环境变量-系统变量，选中 Path，点击编辑，新窗口点击新建，将 yt-dlp.exe 文件所在路径输入\n然后连点三个 确定 将所有窗口关闭\n测试 按下 Win+R 输入 cmd，回车\n在 cmd 中输入 yt-dlp，若出现 Usage: yt-dlp [OPTIONS] URL [URL...] 则代表配置成功\n更新 cmd 中输入 yt-dlp -U 即可\n下载视频 直接在 cmd 中输入 yt-dlp+空格+YouTube 视频链接 即可开始下载\n默认下载是 720P，保存位置在 C:/Users/%UserName%/\n修改下载保存位置 在 C:\\Users\\%UserName%\\AppData\\Roaming 新建一个文件夹并命名为 yt-dlp，然后进入新建的文件夹内，新建文件 config.txt\n在文件内输入以下代码\n1 -o \u0026#39;C:/Users/%UserName%/Downloads/Video/%(title)s.%(ext)s\u0026#39; 其中 C:/Users/%UserName%/Downloads/Video/ 为下载目录\n%(title)s.%(ext)s 为保存文件名形式，此处为视频标题.视频拓展名\n下载 1080P 因为 1080P 及以上视频是音视频分离的，所以需要先下载 ffmpeg\nffmpeg 进入 官网 ，左下角选择系统类型，然后选择下载\n我选择的是 Releases · BtbN/FFmpeg-Builds ，下载 ffmpeg-n5.0-latest-win64-gpl-5.0.zip\n然后放到一个固定文件夹并将 bin 文件目录放到系统变量里\n测试 打开 cmd，输入 ffmpeg -version，若出现版本号则配置成功\n查询命令 输入 yt-dlp -D [URL] 即可查看当前视频的全部形式(仅查询，不下载)\n下载命令 输入 yt-dlp -f [ID] [URL] 以下载指定形式视频，可以使用 [ID]+[ID] 组合以下载视频和音频，即 yt-dlp -f [ID]+[ID] [URL]，下载完成后会自动合并\n注：下载最高画质与音频：-f \u0026quot;bv+ba/b\u0026quot;\n调用 aria2 在下载命令后加入 --external-downloader aria2c --external-downloader-args \u0026quot;-x 16 -k 1M\u0026quot; 即可\n下载字幕 1 2 3 4 5 6 7 outube-dl --write-sub [url] // 这样会下载一个 vtt 格式的英文字幕和 mkv 格式的 1080p 视频下来 youtube-dl --write-sub --skip-download [url] // 下载单独的 vtt 字幕文件,而不会下载视频 youtube-dl --write-sub --all-subs [url] // 下载所有语言的字幕 (如果有的话) youtube-dl --write-auto-sub [url] // 下载自动生成的字幕 (YouTube only) 下载视频列表 1 2 3 4 5 6 7 youtube-dl -f [format code] [palylist_url] // 这种方式可以下载制定清晰度的 mp4 视频 youtube-dl [playlist_url] // 下载视频列表,这种方式下载的视频可能是 mkv 格式或者 webm 格式 youtube-dl -cit [playlist_url] // 下载视频列表,这种方式下载的视频可能是 mkv 格式或者 webm 格式 youtube-dl --yes-playlist [url] // 当链接为视频列表,则下载该列表视频,跟上面的一样,可能是 mkv 或者 webm 格式 可视化 Releases · jely2002/youtube-dl-gui 参考文章 yt-dlp 的 Github 页面 【备份】youtube-dl 使用介绍 - 简书 一文搞懂 Windows 系统【目录变量】的相关知识_黑就黑到底的博客-CSDN博客_username变量 ","date":"2022-07-25T12:52:27+08:00","permalink":"https://blog.yexca.net/archives/52/","title":"命令行下载 YouTube 视频"},{"content":"引言 近日网上冲浪时发现一觉得还不错的字体，便寻找更换字体方法。但实际使用下来没那么惊艳\n方式一 左下管理-设置(或者快捷键CTRL+,)进入设置界面，找到Editor:Font Family\n将默认的 Consolas, 'Courier New', monospace 改为要更换的字体即可\n方式二 Ctrl + Shift + P -\u0026gt; 输入 settings.json -\u0026gt; 选择 Preferences:Open Settings(JSON) 打开 settings.json 文件，然后将 \u0026quot;editor.fontFamily\u0026quot;: \u0026quot;要更改的字体\u0026quot;加入到 {} 中保存即可\n中英文字体分开 我们可以看到 VS Code 的默认字体有三个，以 , 分隔：Consolas, 'Courier New', monospace，要对中英文设置不同的字体，只需要将第一个和第二个分别设置一个英文字体和一个中文字体（英文字体, 中文字体）即可，例如SF NS Mono, '楷体'\n","date":"2022-07-13T17:47:57+08:00","permalink":"https://blog.yexca.net/archives/51/","title":"VS Code 更换字体"},{"content":"好像并没有解决方法，不过可以把快速访问中自己添加的全删除 (恢复默认)\n定位至 C:\\\\Users\\\\用户名\\\\AppData\\\\Roaming\\\\Microsoft\\\\Windows\\\\Recent\\\\AutomaticDestinations，将此文件夹目录下的文件进行备份后全部删除\n参考文章 ftp地址不能从快速访问中删除,其他的文件夹可以 – Microsoft Community ","date":"2022-06-27T13:31:58+08:00","permalink":"https://blog.yexca.net/archives/50/","title":"Windows 网络地址( FTP 地址)取消快速访问"},{"content":"引言 今日尝试了一下之前试过的无线中继，发现已经不会了，果然做一项东西还是要写个文章记录一下比较好啊\n本文中，将OpenWRT路由器连接的WIFI称为上级路由，OpenWRT路由器称为路由器\n前提 确保路由器与上层路由的LAN口地址(即进入路由器后台的地址)不可与上级路由一致，如一致将无法上网\n修改路由器LAN口地址 进入路由器后台的网络-接口，点击LAN的修改，改变其IPv4地址即可\n例如上级路由后台地址为192.168.1.1，路由器可改为192.168.5.1\n修改完并保存\u0026amp;应用后在浏览器输入修改后的地址访问路由器后台\n路由器连接WIFI 进入网络-无线，点击扫描，找到要连接的WIFI，点击加入网络，输入网络名称与密码，点击提交，然后点击保存\u0026amp;应用即可\n路由器开WIFI 如果路由器有2.4G和5G双频段，可以选择与上一步不同频段创建WIFI，这样兼容性最好 （如果另一个频段已经有一个WIFI，可能已经能用啦）\n如果只有单频段，则在相同频段新建一个，必须要新建，可能不会成功，毕竟有些路由器不支持单网卡同时入和出\n开WIFI和普通流程一样，在网络-无线处添加，输入SSID(即WIFI名称)和密码然后保存\u0026amp;应用即可\n参考文章 OpenWrt进阶教程之无线中继配置指南 - 爱一枝梅 ","date":"2022-06-23T14:50:21+08:00","permalink":"https://blog.yexca.net/archives/49/","title":"OpenWRT中继WIFI"},{"content":" 该文章由 Hiyoung 编写\n其文章: https://blog.hiyoung.icu/2022/08/18/5be9517606f2/ 使用PS自动化脚本批量处理图片 点击菜单栏的 窗口-\u0026gt;动作 (快捷键 alt+F9) 再选项卡底部点击新建文件夹（新建组），取名为修改图片大小（可以自己重命名） 再点击旁边的创建新动作，我们可以看到底部原点变为红色\n点击文件、打开，打开我们要处理的其中一张图片，修改图片大小，再点击确定，然后另存为，取个名字，存储。（不要使用导出，否则无法录入动作导致陷入死循环） 点击文件、自动、批处理 设置 播放处选择组和动作 源 选择需要修改的图片文件地址 目标 选择修改后的图片保存地址 勾选 “覆盖动作中的’打开’命令” 和 “覆盖动作中的‘存储为’命令”\n内容部分参考自互联网\n","date":"2022-06-10T00:54:44+08:00","permalink":"https://blog.yexca.net/archives/48/","title":"使用 PS 自动化脚本批量处理图片"},{"content":"引言 由于腾讯云函数从六月开始收费，于是便弃用改在自己的服务器上搭建\n既然六月收费为什么现在才写文章呢？因为可能还有三个月的免费试用我米游社的 Cookie 过期更换，故记录\n工具\u0026amp;原教程 原神签到小助手 每日福利不用愁 - 银弹博客 由于原文介绍了多种使用方法，自己的阅读体验不是太好，故写此文\n腾讯云函数处理 请将腾讯云函数冻结已确保不会收取费用\n当然，如果没什么其他需求可直接注销账号，但注销账号需要手持身份证照片，请注意\n前提 服务器可以连接上米忽悠的服务器 https://mihoyo.com 可在 SSH 命令行窗口输入 ping mihoyo.com 测试是否可以连接\n我的一个服务器就连接不上，只好换一个，唉\nDocker安装 可以直接使用一键脚本进行安装，实测 Debian10 和 CentOS7 正常安装 (请使用 root 账户)\n安装命令如下：\n1 curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun 也可以使用国内 daocloud 一键安装命令：\n1 curl -sSL https://get.daocloud.io/docker | sh 脚本安装 使用以下命令即可\n1 docker pull yindan/genshinhelper CentOS 错误 我使用 CentOS 安装时出现错误 Can't Connect to Docker Daemon\n请确保使用 root 账户，然后输入以下命令\n1 systemctl start docker 简易使用 Cookie 获取 获取米游社Cookie请参考： 原神树脂查看/推送 – yexca\u0026rsquo;Blog 注意：Cookie 应包含account_id和cookie_token两个字段\n多账号在不同Cookie中间加#即可，例如Cookie1#Cookie2#Cookie3\n简易配置 1 2 3 4 docker run -d --name=genshinhelper \\ -e COOKIE_MIHOYOBBS=\u0026#34;\u0026lt;COOKIE_MIHOYOBBS\u0026gt;\u0026#34; \\ --restart always \\ yindan/genshinhelper:latest 将自己的Cookie替换上述命令的\u0026lt;COOKIE_MIHOYOBBS\u0026gt;即可\n重新配置/更新Cookie 重新配置好像需要卸载再重装，然后再进行配置\n或者使用配置文件只需替换Cookie就可以了吧(没用过，Cookie有效期很长的)\n常用命令 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 查看Docker所有的容器 docker ps -a # 查看日志 docker logs -f genshinhelper --tail 100 # 重启 docker restart genshinhelper # 更新 docker pull yindan/genshinhelper docker rm -f genshinhelper # 之后依据基本使用或高级使用重新部署 # 卸载 docker rm -f genshinhelper docker image rm genshinhelper 高阶使用 可下载示例文件修改\nGithub: config.json Telegram: https://t.me/genshinhelperupdates/5 安装 假设配置文件位于服务器的 /etc/genshin/config.json，使用以下命令已映射配置\n1 2 3 4 docker run -d --name=genshinhelper \\ -v /etc/genshin:/app/genshincheckinhelper/config \\ --restart always \\ yindan/genshinhelper:latest 配置 配置文件可以只留下需要的参数，把非必须的参数删除，例如只需要Cookie\n则配置文件除了保持完整也可以写成：\n1 2 3 { \u0026#34;COOKIE_MIHOYOBBS\u0026#34;: \u0026#34;\u0026lt;COOKIE_MIHOYOBBS\u0026gt;\u0026#34;, } 配置文件新增 RANDOM_SLEEP_SECS_RANGE：随机延迟休眠秒数范围，单位：秒。设置成\u0026quot;0-0\u0026quot;为取消延迟。 CHECK_IN_TIME：每日签到时间。该时间和运行环境的时间有关，和时区无关。如果是docker，可以用TZ=Asia/Shanghai设置时区。 CHECK_RESIN_SECS：原神原粹树脂检测间隔时间，单位：秒。 COOKIE_RESIN_TIMER：需要开启原粹树脂检测账号的cookie。 SHOPTOKEN：微信积分商城的token，通过抓包获取。 ONEPUSH：推送配置。notifier为推送名字，params为所需参数。详见后文。\nOnePush 推送参数一览 推送名称 / notifier: bark\n参数大全 / params:\n{\u0026lsquo;required\u0026rsquo;: [\u0026lsquo;key\u0026rsquo;], \u0026lsquo;optional\u0026rsquo;: [\u0026rsquo;title\u0026rsquo;, \u0026lsquo;content\u0026rsquo;, \u0026lsquo;sound\u0026rsquo;, \u0026lsquo;isarchive\u0026rsquo;, \u0026lsquo;icon\u0026rsquo;, \u0026lsquo;group\u0026rsquo;, \u0026lsquo;url\u0026rsquo;, \u0026lsquo;copy\u0026rsquo;, \u0026lsquo;autocopy\u0026rsquo;]}\n推送名称 / notifier: custom\n参数大全 / params:\n{\u0026lsquo;required\u0026rsquo;: [\u0026lsquo;url\u0026rsquo;], \u0026lsquo;optional\u0026rsquo;: [\u0026lsquo;method\u0026rsquo;, \u0026lsquo;datatype\u0026rsquo;, \u0026lsquo;data\u0026rsquo;]}\n推送名称 / notifier: dingtalk\n参数大全 / params:\n{\u0026lsquo;required\u0026rsquo;: [\u0026rsquo;token\u0026rsquo;], \u0026lsquo;optional\u0026rsquo;: [\u0026rsquo;title\u0026rsquo;, \u0026lsquo;content\u0026rsquo;, \u0026lsquo;secret\u0026rsquo;, \u0026lsquo;markdown\u0026rsquo;]}\n推送名称 / notifier: discord\n参数大全 / params:\n{\u0026lsquo;required\u0026rsquo;: [\u0026lsquo;webhook\u0026rsquo;], \u0026lsquo;optional\u0026rsquo;: [\u0026rsquo;title\u0026rsquo;, \u0026lsquo;content\u0026rsquo;, \u0026lsquo;username\u0026rsquo;, \u0026lsquo;avatar_url\u0026rsquo;, \u0026lsquo;color\u0026rsquo;]}\n推送名称 / notifier: pushplus\n参数大全 / params:\n{\u0026lsquo;required\u0026rsquo;: [\u0026rsquo;token\u0026rsquo;, \u0026lsquo;content\u0026rsquo;], \u0026lsquo;optional\u0026rsquo;: [\u0026rsquo;title\u0026rsquo;, \u0026rsquo;topic\u0026rsquo;, \u0026lsquo;markdown\u0026rsquo;]}\n推送名称 / notifier: qmsg\n参数大全 / params:\n{\u0026lsquo;required\u0026rsquo;: [\u0026lsquo;key\u0026rsquo;], \u0026lsquo;optional\u0026rsquo;: [\u0026rsquo;title\u0026rsquo;, \u0026lsquo;content\u0026rsquo;, \u0026lsquo;mode\u0026rsquo;, \u0026lsquo;qq\u0026rsquo;]}\n推送名称 / notifier: serverchan\n参数大全 / params:\n{\u0026lsquo;required\u0026rsquo;: [\u0026lsquo;sckey\u0026rsquo;, \u0026rsquo;title\u0026rsquo;], \u0026lsquo;optional\u0026rsquo;: [\u0026lsquo;content\u0026rsquo;]}\n推送名称 / notifier: serverchanturbo\n参数大全 / params:\n{\u0026lsquo;required\u0026rsquo;: [\u0026lsquo;sctkey\u0026rsquo;, \u0026rsquo;title\u0026rsquo;], \u0026lsquo;optional\u0026rsquo;: [\u0026lsquo;content\u0026rsquo;, \u0026lsquo;channel\u0026rsquo;, \u0026lsquo;openid\u0026rsquo;]}\n推送名称 / notifier: telegram\n参数大全 / params:\n{\u0026lsquo;required\u0026rsquo;: [\u0026rsquo;token\u0026rsquo;, \u0026lsquo;userid\u0026rsquo;], \u0026lsquo;optional\u0026rsquo;: [\u0026rsquo;title\u0026rsquo;, \u0026lsquo;content\u0026rsquo;, \u0026lsquo;api_url\u0026rsquo;]}\n推送名称 / notifier: wechatworkapp\n参数大全 / params:\n{\u0026lsquo;required\u0026rsquo;: [\u0026lsquo;corpid\u0026rsquo;, \u0026lsquo;corpsecret\u0026rsquo;, \u0026lsquo;agentid\u0026rsquo;], \u0026lsquo;optional\u0026rsquo;: [\u0026rsquo;title\u0026rsquo;, \u0026lsquo;content\u0026rsquo;, \u0026rsquo;touser\u0026rsquo;, \u0026lsquo;markdown\u0026rsquo;]}\n推送名称 / notifier: wechatworkbot\n参数大全 / params:\n{\u0026lsquo;required\u0026rsquo;: [\u0026lsquo;key\u0026rsquo;], \u0026lsquo;optional\u0026rsquo;: [\u0026rsquo;title\u0026rsquo;, \u0026lsquo;content\u0026rsquo;, \u0026lsquo;markdown\u0026rsquo;]}\n推送例子 1 2 3 4 5 telegram ONEPUSH={\u0026#34;notifier\u0026#34;:\u0026#34;telegram\u0026#34;,\u0026#34;params\u0026#34;:{\u0026#34;markdown\u0026#34;:false,\u0026#34;token\u0026#34;:\u0026#34;xxxx\u0026#34;,\u0026#34;userid\u0026#34;:\u0026#34;xxx\u0026#34;}} discord ONEPUSH={\u0026#34;notifier\u0026#34;:\u0026#34;discord\u0026#34;,\u0026#34;params\u0026#34;:{\u0026#34;markdown\u0026#34;:true,\u0026#34;webhook\u0026#34;:\u0026#34;https://discord.com/api/webhooks/xxxxxx\u0026#34;}} docker 配置文件映射目录为：/etc/genshin:/app/genshincheckinhelper/config\n","date":"2022-06-09T13:33:42+08:00","permalink":"https://blog.yexca.net/archives/47/","title":"原神自动签到 (Linux 服务器 Docker)"},{"content":"引言 在学习 Markdown 用法 后，感觉非常好用 (最近的文章都是使用 Markdown 写的)，又因为编程或 Github 建站 会和 Markdown 打交道，而我编程使用 VS Code (看嘉然)，遂寻找是否可以实时预览\n快捷键 在 Markdown 文件界面 (.md 文件)，点击下文件界面 (鼠标文本光标在文件内)，然后按下 CTRL+K 后按下 V 即可，注意使用英文输入法\n以上是实时预览，可以按 CTRL+Shift+V 打开新窗口预览\n按钮 在 Markdown 文件右上角有个 打开侧边预览 预览，点击即可\n控制台 按 CTRL+Shift+P 打开控制台，然后输入 markdown 就能看到一些命令\n参考文章 Visual Studio Code 编写并实时预览 Markdown ","date":"2022-06-09T00:03:34+08:00","permalink":"https://blog.yexca.net/archives/46/","title":"VS Code 实时预览 Markdown"},{"content":"引言 首先我不是嘉心糖，我只是觉得很可爱 (我刚开始甚至都不知道是嘉然)，然后这个 Bug 挺多，自启动不是每次都能触发，但她太可爱啦\n然后这个拓展还可以改背景，但我个人不是太喜欢就没改\n效果预览如下 安装 打开 VS Code 然后在 拓展 搜索 A-SOUL-live2d 安装\n拓展地址： A-SOUL-live2d - Visual Studio Marketplace 其实可以直接去拓展那看，有安装过程，不用看我写的垃圾文章\n简单使用 安装完毕重启 VS Code，然后在资源视图最下方会有 LIVE2D-A-SOUL，展开 (不能展开就重启 VS Code)\n然后在 补充配置 处 生成 插件依赖文件，重启 VS Code，点击 启动 live2d\n右下角就会出现嘉然啦，可以把鼠标移上去，拖动右上角第三个图标以移动位置，第一个点击改变大小\n调整完位置，大小后可以在 配置信息 处开启 自启动，然后点击 保存当前配置 就可以打开VS Code就能看见嘉然啦~\n其他 以下复制自插件介绍\n基本操作\n启动、关闭live2d： 字面意思，会启动看板人物，初始默认位置右下角 保存当前配置： 在调整live2d大小缩放和拖拽位置后，可保存信息，下次启动时自动携带 重置默认位置： 当前位置异常，无法拖拽移动时可重置使用【缩放大小也会重置】 背景图 点击切换： 点击按钮为人物右侧图标第二个 保存背景图： 需要当前背景图存在才会生效。只能保存一份，再次点击会覆盖旧的 加载背景图： 加载保存的背景图 定时切换： 字面意思，可查看 切换按钮 是否旋转判断是否开启定时功能 背景图样式配置 下载背景图 配置信息\n自启动： 字面意思，开启后。vscode启动，live2d自动启动 定位依赖： 人物定位的依赖角 补充配置\n插件依赖文件： 插件依赖文件会在初次安装插件并启动时自动生成 生成： live2d无法正常启动时，可尝试点击该按钮，强制重新生成覆盖配置信息 移除： 卸载该插件前，请尽可能先执行该操作。 可移除插件对vscode文件的所有修改 人物功能\n目光跟随鼠标 【缺点，暂时无法实现整个页面的跟随】 点击互动 asoul粉丝导航网站入口 切换背景图 切换模型 溜冰场 音频测试 一个魂二创网站入口 模型来源 关于警告 使用会弹出 Code 损坏警告，原作者指出\n本插件是通过修改 vscode 的 js 文件的方式运行 所以会在初次安装，或者 vscode 升级的时候，出现以下提示，请选择 【不再提示】\n音频支持 当前插件仅一个简单的语音测试，暂且可以不用考虑该功能\nVS Code 使用的 Electron 版本不包含 ffmpeg ，需替换自带的 ffmpeg 动态链接库才能正常播放 (每次更新 VS Code 都需重新替换)\nVS Code for Windows 1.31.0 - 1.35.1 不需替换，1.36.0 后无此待遇\nVS Code for macOS 1.43+ 替换后闪退 解决方案 卸载 首先将 补充配置 移除，然后在 拓展 界面卸载插件即可\n","date":"2022-06-01T06:01:00+08:00","permalink":"https://blog.yexca.net/archives/45/","title":"VS Code 右下角嘉然"},{"content":"引言 最近基于 Github Pages 整了一个个人页面 (已经没了)，记录一下如何使用 Github Pages 建站以及自定义域名\n本文没有建站系统等，因为我也就写了一个 Markdown 文件\n创建Github仓库 首先需要注册一个 Github 账号，登录后 创建一个新仓库 其中 Repository name 为 username.github.io，例如我的 Github 用户名为 yexca，则输入 yexca.github.io\nGit环境安装 Windows 环境直接从 Git 官网直接 下载安装程序 即可\n安装完成后，打开Git Bash，在命令行输入以下代码\n1 2 git config --global user.name \u0026#34;Your Name\u0026#34; git config --global user.email \u0026#34;email@example.com\u0026#34; 其中 Your Name 替换为您的姓名，email@example.com 替换为您的邮箱\n例如我的\n1 2 git config --global user.name \u0026#34;yexca\u0026#34; git config --global user.email \u0026#34;yexca@duck.com\u0026#34; Github Desktop 安装 如果您熟悉 Git 的操作 熟悉 Git 操作怎么会来看我的文章，这一步可以跳过\n直接进入 Github Desktop 官网 下载安装即可\n克隆仓库 打开 Github Desktop 后登录 Github 账号选择一个空文件夹将上一步创建的仓库克隆到本地\n然后软件会出现一个仓库变动界面，右方会有一些快捷操作\n这里我使用 VS Code，点击 Open in Visual Studio Code 在 VS Code 打开\n建立网站 这里直接创建一个 README.md 文件使用 Markdown 编辑 (这里顺便放一个我写的Markdown笔记)\n编辑完成并保持后在 Github Desktop 点击 Commit to main，然后点击右方 Push origin 即可\n至此访问 username.github.io 即可看到网站内容如果没看到请等一段时间\n自定义域名 Github Pages 进入刚刚建立的仓库页面，点击 Settings，左侧找到 Pages，在 Custom domain 处输入自定义域名然后点击 Save\n注：在这里可以进行 Jekyll 建站主题的选择\nDNS 在域名的 DNS 解析处添加一个 CNAME 类型解析，将域名指向 username.github.io，其中 username 为您的 Github 用户名\nHTTPS 这里我用 Github 的不知为何没成功，于是使用 Cloudflare 在 DNS 解析处启用代理，然后在 SSL/TLS 的 边缘证书 处将 始终使用 HTTPS 打开即可\n其他建站 因无博客需求，我只是写一个简单的文件，如果是建立博客之类的可以使用一些建站工具\nJekyll Github官方支持的建站\nVuePress 中文网 Markdown推荐\nGitbook 适合建立文档类网站\nLOFFER Gridea 一个静态博客写作客户端\nHexo 快速、简洁且高效的博客框架\nHugo 参考文章 GitHub Pages 快速入门 - GitHub Docs GitHub Pages博客：自定义域名，HTTPS，CAA — 浮云的博客 GitHub Pages 搭建教程 安装Git - 廖雪峰的官方网站 ","date":"2022-05-28T15:30:43+08:00","permalink":"https://blog.yexca.net/archives/44/","title":"Github Pages 建站及自定义域名"},{"content":"引言 最近因建 网盘网站 了解了一下 Markdown，发现这玩意非常好用，于是写一份学习笔记\n可以通过 在线编辑器 边看边学，也可下载一些 编辑器 个人编写 Markdown 的工具为 Typora 复习可以去看官方的速查表 Markdown 语法速查表 标题 创建一个标题，仅需#+空格+标题文字，一共有六级，对应 HTML 的 h1~h6\n1 2 3 4 5 6 # 这是一级标题 ## 这是二级标题 ### 这是三级标题 #### 这是四级标题 ##### 这是五级标题 ###### 这是六级标题 一般的网页编写，一级标题是网页标题，二级开始为内容，用到四级差不多\n换行 仅需在上一行末尾加上俩个以上空格后回车即可，有些编辑器可直接换行\n例如以下代码\n1 2 这是第一行 //这里有俩空格，后面也有→ 这是第二行 效果如下\n这是第一行 //这里有俩空格，后面也有→\n这是第二行\n斜体 \u0026amp; 粗体 斜体为文本前后加一个 *，粗体为文本前后加俩 **\n例如以下代码\n1 2 3 *这是斜体* **这是粗体** ***这是斜体加粗体*** 效果如下\n这是斜体\n这是粗体\n这是斜体加粗体\n引用 创建引用区块仅需在段首添加 \u0026gt;+空格+内容\n例如以下代码\n1 2 3 \u0026gt; 这是一级引用 \u0026gt;\u0026gt; 这是二级引用 \u0026gt;\u0026gt;\u0026gt; 这是三级引用 效果如下\n这是一级引用\n这是二级引用\n这是三级引用\n列表 可以创建有序列表和无序列表\n有序列表 在列表项前添加 数字+.+空格+内容 即可\n例如以下代码\n1 2 3 1. 第一项 2. 第二项 3. 第三项 效果如下\n第一项 第二项 第三项 无序列表 使用 +，- 或 *+空格+ 内容 即可，但请不要混用 (为了兼容性)\n子项可以使用 四个空格 或一个 TAB 然后用父项格式即可\n不过为了符合 (markdownlint) 规范，一篇文章的所有无序列表尽量用一样的，比如都用 -\n例如以下代码\n1 2 3 4 5 6 - 第一项 - 第一项子一项 - 第一项子二项 - 第一项子二项子一项 - 第二项 - 第三项 效果如下\n第一项 第一项子一项 第一项子二项 第一项子二项子一项 第二项 第三项 代码 单行 将要变为代码的内容放在 \u0026ldquo;`\u0026rdquo; 中即可，如果代码中有 \u0026ldquo;`\u0026rdquo; ，请使用 \u0026ldquo;``\u0026rdquo;\n例如以下代码\n1 2 `将此内容变为代码块` ``此内容中含有\u0026#39;`\u0026#39;哦~`` 效果如下\n将此内容变为代码块\n此内容中含有'`'哦~\n代码块 可以通过将每一行缩进四个空格或一个 TAB\n或者上下行 \u0026ldquo;```\u0026rdquo; 包围，要使用高亮，请在上方 \u0026ldquo;```\u0026rdquo; 后写上语言类型\n为了符合规范，尽量使用第二种\n例如以下代码\n1 2 3 4 5 6 7 \\`\\`\\` C include\u0026lt;stdio.h\u0026gt; int main(void) { printf(\u0026#34;Hello World\u0026#34;); } \\`\\`\\` 效果如下\n1 2 3 4 5 include\u0026lt;stdio.h\u0026gt; int main(void) { printf(\u0026#34;Hello World\u0026#34;); } 分割线 在单独一行使用三个及以上的 *，- 或 _ 即可\n为了规范，尽量使用三个星号\n例如以下代码\n1 *** 效果如下\n链接 简易链接 直接将链接或邮箱地址使用 \u0026lt;\u0026gt; 括起来即可\n例如以下代码\n1 2 \u0026lt;https://yexca.net\u0026gt; \u0026lt;yexca@duck.com\u0026gt; 效果如下\nhttps://yexca.net yexca@duck.com 自定义文字的链接 [超链接显示名](超链接地址 \u0026quot;超链接 title\u0026quot;)，其中 \u0026quot;超链接 title\u0026quot; 可以不填\n例如以下代码\n1 2 [yexca的博客](https://blog.yexca.net) [yexca的博客](https://blog.yexca.net \u0026#34;其实是 yexca 和 Hiyoung 的博客\u0026#34;) 效果如下\nyexca的博客 yexca的博客 引用类型链接 例如以下代码\n1 2 3 4 [blog]: https://blog.yexca.net [contact]: \u0026lt;mailto:yexca@duck.com\u0026gt; 这是我的[个人博客][blog]，有问题可以[联系我][contact] 效果如下\n这是我的 个人博客 ，有问题可以 联系我 图片 插入图片 ![图片 alt](图片链接 \u0026quot;图片 title\u0026quot;)，其中 图片 alt 为当图片加载失败时显示的内容，图片 title 为鼠标放图片上显示的内容\n注意：部分 Markdwon 编辑器不支持 图片 title (比如本站这个主题)，为了规范，请至少确保填写 图片 alt\n例如以下代码\n1 ![图片](https://cdn.statically.io/gh/yexca/picx-images-hosting@master/2023/04-网站背景/blog-background.2p10z489pjc0.webp \u0026#34;这是本站的背景\u0026#34;) 效果如下\n图片包含链接 使用链接的语法，将图片放在 [] 里即可\n例如以下代码\n1 [![图片](https://cdn.statically.io/gh/yexca/picx-images-hosting@master/2023/04-网站背景/blog-background.2p10z489pjc0.webp)](https://www.pixiv.net/artworks/82542737) 效果如下\n转义字符 如果有不想被 Markdown 格式化的字符，只需要在前方加上 \\ 即可\n例如以下代码\n1 2 我想打出*但这会被斜体* 加上转移符\\*后面就不会斜体，而且可以显示 效果如下\n我想打出但这会被斜体\n加上转移符*后面就不会斜体，而且可以显示\n内嵌 HTML 直接使用即可，以缩略标签为例\n例如以下代码\n1 2 3 4 5 6 7 \u0026lt;details\u0026gt; \u0026lt;summary\u0026gt; 点我试试 \u0026lt;/summary\u0026gt; 被发现啦 \u0026lt;/details\u0026gt; 我可以用Markdown**变粗**，也可以同时用HTML\u0026lt;i\u0026gt;变斜\u0026lt;/i\u0026gt; 因为该站主题不可以直接解解析 H5，所以不演示\n表格 使用三个或多个 - 创建每列标题，使用 | 分割每列，使用 : 以左，右或居中对齐 (非必须)\n例如以下代码\n1 2 3 |标题|内容|备注| |:---|:---:|---:| |左对齐|居中|右对齐| 效果如下\n标题 内容 备注 左对齐 居中 右对齐 注意：不可以在表格中添加标题，引用，列表，图像或 HTML 标签等\n删除线 在要删除的内容前后添加 ~~\n例如以下代码\n1 我永远喜欢 ~~战争文学博士~~ Warma 效果如下\n我永远喜欢 战争文学博士 Warma\n任务列表 使用 -+空格+[ ] 或 [x]+空格+内容\n例如以下代码\n1 2 - [ ] 这个没完成呢 - [x] 这个完成啦 效果如下\n这个没完成呢 这个完成啦 使用 Emoji 表情 复制粘贴 多数情况可直接复制 Emojipedia 上的表情直接粘贴，请确保网页编码为 UTF-8\n使用表情符号简码 这个需要 Markdown 应用程序支持，以冒号 : 开头和结尾\n可以通过 表情符号简码列表 查询\n例如以下代码\n1 :blush:,:smiley: 效果如下\n😊,😃\n脚注 类似于论文参考文献的角标\n例如以下代码\n1 2 3 4 5 6 这里引用了维基百科[^1]，这里引用了 Github[^2]。 也可以使用英文，但不能用空格或 TAB[^yexca] [^1]: 这里可以使用文字，然后会在上方相应位置出现 [^2]: 或者使用链接 [Github](https://github.com/yexca) [^yexca]: [个人主页](https://lit.link/yexca) 效果如下，参考的东西在文章最末尾，点击角标可以看到\n这里引用了维基百科1，这里引用了 Github2。 也可以使用英文，但不能用空格或 TAB3\n注意：部分编辑器不支持\n参考文章 Markdown 官方教程 Markdown 学习 这里可以使用文字，然后会在上方相应位置出现\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n或者使用链接 Github \u0026#160;\u0026#x21a9;\u0026#xfe0e;\n个人主页 \u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2022-05-28T00:59:23+08:00","permalink":"https://blog.yexca.net/archives/43/","title":"Markdown 简述 (学习笔记)"},{"content":"引言 本人可直连进入游戏，但加速器等不可进入游戏，又因每次进入游戏关闭虚拟私人网路较为麻烦，寻找相应资料却无果，故写此文。(游戏为IOS日服)\n正文 通过查看日志文件确定了进入游戏时连接的域名\n将以下域名加入DIRECT即可\n1 sekai.colorfulpalette.org 后记 本想详细写写的，却发现游戏出了国际服和台服，如果详细写估计要花费很长时间并去校验，懒~\n","date":"2022-05-19T15:01:25+08:00","permalink":"https://blog.yexca.net/archives/42/","title":"プロセカ的IP规则"},{"content":" 该文章由 Hiyoung 编写\n添加管理员用户： 1、新建用户，这里新建一个temp_test的用户\nadduser temp\\_test **2、设置新用户密码** passwd temp_test\n3、将sudoers文件的权限修改成可编辑\nchmod -v u+w /etc/sudoers\n4、使用vim编辑sudoers文件\nvim /etc/sudoers\n5、在sudoes文件中添加如下的内容\n找到root ALL=(ALL) ALL\n然后添加temp_user ALL=(ALL) ALL\n如需新用户使用sudo时不用输密码，把最后一个ALL改为NOPASSWD:ALL即可。\n6、将sudoers文件的权限修改成不可编辑\nchmod -v u-w /etc/sudoers\n7、删除用户\nuserdel temp_test\n","date":"2022-05-16T15:29:21+08:00","permalink":"https://blog.yexca.net/archives/41/","title":"Linux 添加用户和管理员用户"},{"content":" 该文章由 Hiyoung 编写\nLinux不会自动创建不存在的文件夹,使用”mv”命令时需要注意文件夹是否存在,否则会将文件重命名。 为文件创建硬链接实际上是为文件创建了额外的名字部分(数据部分未改动),类似于C语言中创建了一个指针指向该文件。 为文件创建符号链接类似于WIN中的快捷方式,在使用”ls -li”命令中可以比较直观的看出区别。硬链接字节数和源文件一样，而符号链接字节数不同。 使用别名“alias”创建命令：在同一行同时运行多个命令用“;”分开；可以使用“type”查询命令是否已经在系统中；值得注意的是使用“alias”创建命令在结束shell会话时会消失（因为没有添加到文件中去）；使用”unalias”删除别名 使用“\u0026gt;”重定向会重写源文件，”\u0026gt;\u0026gt;”重定向会在源文件后续写 将错误信息写入文件（而不是显示在屏幕上）可以用“2\u0026gt;” 重定向标准输出和错误到同一个文件有两种方法：一是，在重定向的文件名后加上 ”2\u0026gt;\u0026amp;1“；二是，在重定向符前加 ”\u0026amp;“。 方法一（在老版本的shell也可使用）\n方法二\n","date":"2022-04-30T04:24:07+08:00","permalink":"https://blog.yexca.net/archives/40/","title":"Liunx 随手笔记"},{"content":" 该文章由 Hiyoung 编写\n其文章: https://blog.hiyoung.xyz/2022/09/03/3256bd2afccc/ 一、虚拟机设置 在菜单栏选择编辑→ 虚拟网络编辑器，打开虚拟网络编辑器对话框，选择Net网络连接方式，随意设置子网IP，点击NAT设置页面，查看子网掩码和网关，后面修改静态IP会用到。\n在VMnet8模式下选择nat连接，并且取消DHCP服务。\n点击NAT设置，记录下此时的网关\n在系统的网络设置处，检查VMnet8的网络配置\n二、Liunx主机设置 在root权限下输入命令 cd /etc/sysconfig/network-scripts 进入该文件夹，输入命令 ls 浏览该文件夹下的文件，找到ifcfg-en***文件，如下图所示：\nvim ifcfg-en***打开文件\n将BOOTPROTO=”dhcp”改为BOOTPROTO=”static”、ONBOOT=”no”改为ONBOOT=”yes”\n并在下方添加\nIPADDR=your ip（静态IP地址）\nNETMASK=your netmask（子网掩码，一般为255.255.255.0）\nGATEWAY=your gateway（网关地址）\nDNS1=8.8.8.8（国内外公共DNS即可）\nDNS2=8.8.4.4\n最后输入:wq退出即可\n","date":"2022-04-22T18:13:42+08:00","permalink":"https://blog.yexca.net/archives/39/","title":"在虚拟机中设置静态 IP（centos 为例）"},{"content":" 该文章由 Hiyoung 编写\n其文章: https://blog.hiyoung.xyz/2022/08/01/84a03702e5a9/ （参考视频： https://www.bilibili.com/video/BV1WY4y1H7d3?p=1 ）\n一、基础篇 1.1 Linux文件系统目录结构 来源：菜鸟教程 图中小箭头表示该文件实际位置在别处\n/bin： bin 是 Binaries (二进制文件) 的缩写, 这个目录存放着最经常使用的命令。 /boot：\n这里存放的是启动 Linux 时使用的一些核心文件，包括一些连接文件以及镜像文件。 /dev ：\ndev 是 Device(设备) 的缩写, 该目录下存放的是 Linux 的外部设备，在 Linux 中访问设备的方式和访问文件的方式是相同的。 /etc：\netc 是 Etcetera(等等) 的缩写,这个目录用来存放所有的系统管理所需要的配置文件和子目录。 /home：\n用户的主目录，在 Linux 中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的，如上图中的 alice、bob 和 eve。 /lib：\nlib 是 Library(库) 的缩写这个目录里存放着系统最基本的动态连接共享库，其作用类似于 Windows 里的 DLL 文件。几乎所有的应用程序都需要用到这些共享库。 /lost+found：\n这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。 /media：\nlinux 系统会自动识别一些设备，例如U盘、光驱等等，当识别后，Linux 会把识别的设备挂载到这个目录下。 /mnt：\n系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在 /mnt/ 上，然后进入该目录就可以查看光驱里的内容了。 /opt：\nopt 是 optional(可选) 的缩写，这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。 /proc：\nproc 是 Processes(进程) 的缩写，/proc 是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。\n这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件，比如可以通过下面的命令来屏蔽主机的ping命令，使别人无法ping你的机器：echo 1 \u0026gt; /proc/sys/net/ipv4/icmp_echo_ignore_all /root：\n该目录为系统管理员，也称作超级权限者的用户主目录。 /sbin：\ns 就是 Super User 的意思，是 Superuser Binaries (超级用户的二进制文件) 的缩写，这里存放的是系统管理员使用的系统管理程序。 /selinux：\n这个目录是 Redhat/CentOS 所特有的目录，Selinux 是一个安全机制，类似于 windows 的防火墙，但是这套机制比较复杂，这个目录就是存放selinux相关的文件的。 /srv：\n该目录存放一些服务启动之后需要提取的数据。 /sys：这是 Linux2.6 内核的一个很大的变化。该目录下安装了 2.6 内核中新出现的一个文件系统 sysfs 。sysfs 文件系统集成了下面3种文件系统的信息：针对进程信息的 proc 文件系统、针对设备的 devfs 文件系统以及针对伪终端的 devpts 文件系统。该文件系统是内核设备树的一个直观反映。当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。 /tmp：\ntmp 是 temporary(临时) 的缩写这个目录是用来存放一些临时文件的。 /usr：\nusr 是 unix shared resources(共享资源) 的缩写，这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于 windows 下的 program files 目录。 /usr/bin：\n系统用户使用的应用程序。 /usr/sbin：\n超级用户使用的比较高级的管理程序和系统守护程序。 /usr/src：\n内核源代码默认的放置目录。 /var：\nvar 是 variable(变量) 的缩写，这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。 /run：\n是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 /var/run 目录，应该让它指向 run。 1.2 文件基本属性 1.2.1 基本属性 在 Linux 中第一个字符代表这个文件是目录、文件或链接文件等等。\n当为 d 则是目录 当为 – 则是文件； 若是 l 则表示为链接文档(link file)； 若是 b 则表示为装置文件里面的可供储存的接口设备(可随机存取装置)； 若是 c 则表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置)。 接下来的字符中，以三个为一组，且均为 rwx 的三个参数的组合。其中， r 代表可读(read)、 w 代表可写(write)、 x 代表可执行(execute)。 要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号 – 。\n每个文件的属性由左边第一部分的 10 个字符来确定（如下图）。\n从左至右用 0-9 这些数字来表示。\n第 0 位确定文件类型，第 1-3 位确定属主（该文件的所有者）拥有该文件的权限。第4-6位确定属组（所有者的同组用户）拥有该文件的权限，第7-9位确定其他用户拥有该文件的权限。\n其中，第 1、4、7 位表示读权限，如果用 r 字符表示，则有读权限，如果用 – 字符表示，则没有读权限；\n第 2、5、8 位表示写权限，如果用 w 字符表示，则有写权限，如果用 – 字符表示没有写权限；第 3、6、9 位表示可执行权限，如果用 x 字符表示，则有执行权限，如果用 – 字符表示，则没有执行权限。\n1.2.2 Linux文件属主和属组 1、chgrp：更改文件属组 语法：\n1 chgrp [-R] 属组名 文件名 参数选项\n-R：递归更改文件属组，就是在更改某个目录文件的属组时，如果加上-R的参数，那么该目录下的所有文件的属组都会更改。 2、chown：更改文件属主，也可以同时更改文件属组 语法：\n1 2 chown [–R] 属主名 文件名 chown [-R] 属主名：属组名 文件名 进入 /root 目录（~）将install.log的拥有者改为bin这个账号：\n1 2 3 4 [root@www ~] cd ~ [root@www ~]# chown bin install.log [root@www ~]# ls -l -rw-r--r-- 1 bin users 68495 Jun 25 08:53 install.log 将install.log的拥有者与群组改回为root：\n1 2 3 [root@www ~]# chown root:root install.log [root@www ~]# ls -l -rw-r--r-- 1 root root 68495 Jun 25 08:53 install.log 3、chmod：更改文件9个属性 Linux文件属性有两种设置方法，一种是数字，一种是符号。\nLinux 文件的基本权限就有九个，分别是 owner/group/others(拥有者/组/其他) 三种身份各有自己的 read/write/execute 权限。\n先复习一下刚刚上面提到的数据：文件的权限字符为： -rwxrwxrwx ， 这九个权限是三个三个一组的！其中，我们可以使用数字来代表各个权限，各权限的分数对照表如下：\nr:4 w:2 x:1 每种身份(owner/group/others)各自的三个权限(r/w/x)分数是需要累加的，例如当权限为： -rwxrwx— 分数则是：\nowner = rwx = 4+2+1 = 7 group = rwx = 4+2+1 = 7 others= — = 0+0+0 = 0 所以等一下我们设定权限的变更时，该文件的权限数字就是 770。变更权限的指令 chmod 的语法是这样的：\n1 chmod [-R] xyz 文件或目录 选项与参数：\nxyz : 就是刚刚提到的数字类型的权限属性，为 rwx 属性数值的相加。 -R : 进行递归(recursive)的持续变更，以及连同次目录下的所有文件都会变更 举例来说，如果要将 .bashrc 这个文件所有的权限都设定启用，那么命令如下：\n1 2 3 4 5 [root@www ~]# ls -al .bashrc -rw-r--r-- 1 root root 395 Jul 4 11:45 .bashrc [root@www ~]# chmod 777 .bashrc [root@www ~]# ls -al .bashrc -rwxrwxrwx 1 root root 395 Jul 4 11:45 .bashrc 那如果要将权限变成 -rwxr-xr– 呢？那么权限的分数就成为 [4+2+1][4+0+1][4+0+0]=754。\n4、符号类型改变文件权限 还有一个改变权限的方法，从之前的介绍中我们可以发现，基本上就九个权限分别是：\nuser：用户 group：组 others：其他 那么我们就可以使用 u, g, o 来代表三种身份的权限。\n此外， a 则代表 all，即全部的身份。读写的权限可以写成 r, w, x，也就是可以使用下表的方式来看：\n| chmod | u g o a | +(加入) -(除去) =(设定) | r w x | 文件或目录 | |---|---|---|---|---| 如果我们需要将文件权限设置为 -rwxr-xr– ，可以使用 chmod u=rwx,g=rx,o=r 文件名 来设定:\n1 2 3 4 5 6 touch test1 // 创建 test1 文件 ls -al test1 // 查看 test1 默认权限 #-rw-r--r-- 1 root root 0 Nov 15 10:32 test1 chmod u=rwx,g=rx,o=r test1 // 修改 test1 权限 ls -al test1 -rwxr-xr-- 1 root root 0 Nov 15 10:32 test1 而如果是要将权限去掉而不改变其他已存在的权限呢？例如要拿掉全部人的可执行权限，则：\n1 2 3 chmod a-x test1 ls -al test1 #-rw-r--r-- 1 root root 0 Nov 15 10:32 test1 1.3 vim文本编辑 1.3.1 vim的三种模式 基本上 vi/vim 共分为三种模式，分别是命令模式、编辑模式和一般模式\n1.3.2 vim快捷命令 参考外部网站： https://www.runoob.com/linux/linux-vim.html 1.4 网络配置 1.4.1 VMware的三种网络连接模式 桥接模式：虚拟机直接连接外部网络（对外部网络可见），主机起到网桥的作用，虚拟机的地位和主机相同，从路由器分配独立的IP地址。\nNAT模式：主机和虚拟机构建一个专用网络，使用NAT对虚拟机进行IP转换（虚拟机对外部网络不可见）。此时虚拟机单独组成一个局域网，此时主机和虚拟机并不在一个网段，无法进行通信，所以又虚拟一个网卡（VMnet8）来连接至虚拟机所在的局域网。\n仅主机模式：这种模式仅仅只让虚拟机与主机通信，不连接至Internet\n1.4.2 配置静态IP 参考站内文章： 在虚拟机中设置静态IP（centos为例） 1.4.3 配置主机名 1 2 3 4 5 6 7 8 9 hostname #查看当前主机名 vim /etc/hostname #修改主机名 #修改后重启即可显示新主机名 #方法二 hostnamectl set-hostname ... #实时生效 1 2 #修改hosts文件 vim /etc/hosts 1.5 系统管理 1.5.1 service 服务管理 一个正在执行的程序或命令，称为“进程”\n启动后一直存在、常驻内存的进程，一般称为“服务”\n1 2 3 systemctl start|stop|restart|status servicename #基本语法 /usr/lib/systemd/system/ #服务所在目录 ","date":"2022-04-19T02:53:27+08:00","permalink":"https://blog.yexca.net/archives/38/","title":"系统学习 Linux 笔记"},{"content":"引言 2022 年 03 月 22 日，OBS 上架 Steam，方便了更新，但每次使用都要打开 Steam 着实有点麻烦。\n正文 Steam 库界面右击 OBS Studio ，依次选择 管理-浏览本地文件\n在文件资源管理器内进入路径 bin/64bit 或 bin/32bit，找到 obs64 或 obs32\n直接点击这个文件就可以启动 OBS，所以可以将其固定到 开始 屏幕或创建快捷方式\n右击创建快捷方式，将快捷方式放到桌面即可\n","date":"2022-04-11T22:19:48+08:00","permalink":"https://blog.yexca.net/archives/37/","title":"免启动 steam 打开 OBS"},{"content":"一、查询时间戳 打开网页 https://member.bilibili.com/x2/creative/h5/calendar/event?ts=0 按下 CTRL+F，输入 jointime，找到 jointime 后面的数字即为时间戳\n将时间戳复制\n二、转换时间戳 打开网站 时间戳 (Unix timestamp) 转换工具 – 在线工具 在相应位置输入时间戳点击转换即可\n参考资料 up教你如何查看自己的B站注册时间，精确到秒！哔哩哔哩 ","date":"2022-04-09T13:47:52+08:00","permalink":"https://blog.yexca.net/archives/36/","title":"查询B站注册时间(精确到秒)"},{"content":"引言 今日我写文章时，发现 PicX 图床无法使用并提示 Bad credentials，于是便寻找解决方法\n结论 其实就是 Github 的 Token 到期了，然后在邮箱里会收到一封邮件，名为 [GitHub] Your personal access token has expired\n邮件有三行，第二行 If this token is still needed，后面有个链接，点击打开并重新创建即可\n注意设置 Expiration 即 Token 期限\n重新创建后需要在 PicX 将图床配置重置下\n具体参考： 使用PicX自建免费图床 – yexca’Blog ","date":"2022-03-22T16:30:12+08:00","permalink":"https://blog.yexca.net/archives/35/","title":"使用 PicX 图床上传图片提示 \"Bad credentials\""},{"content":" 另外我写了模型修改教程，可以访问: https://vrchat.yexca.net/ 查看\n引言 近日通过好友告知 VRchat 中的钢琴可以自行弹奏，于是便学习了以下，写此篇文章以作记录。\n注：好像只可以 PC 模式下自动弹奏，当然，您也可以在 VR 下投出桌面试试（doge\n如果不使用 mid 文件 一、准备 为实现钢琴自动弹奏，需要安装两个软件，一个插件\n1）loopMIDI 此软件可在官网直接获取，官网链接： loopMIDI-Tobias Erichsen (tobias-erichsen.de) 文件直链： loopMIDISetup_1_0_16_27.zip （可能因为版本更新而失效）\n2）Jazz-Plugin 安装时请保持默认安装路径，否则可能无法正常使用\nWindows: 点此下载（插件官网链接） （如果官网链接无法下载，也可 点此下载 ）\nMac OS X: 点击下载 Linux version: 点击下载 3）浏览器插件 Jazz-MIDI Chrome，Opera，或者其他双核浏览器（如 360 安全浏览器等）： 点击前往 Chrome 应用店安装 如果无法访问Chrome应用店 Chrome 73 版本前的请下载 Jazz-MIDI-crx2.crx 使用，Chrome 73 之后的版本请下载 Jazz-MIDI-crx3.crx 使用。\nChrome进入拓展程序 通过在地址栏输入(或此处直接点击) chrome://extensions 并回车进入拓展程序\n如图所示\nEdge进入拓展程序 通过在地址栏输入(或此处直接点击) edge://extensions/ 并回车进入拓展程序\n如图所示\n如果出现弹窗，点击 管理拓展\n打开拓展程序界面后 首先打开“开发人员模式”，Chrome在右上，Edge在左中\n然后直接把下载好的crx文件拖入拓展程序界面即可\n二、步骤 1）打开loopMIDI，新建项目 新建项目先在右下 New port-name 输入名称，后点击左下 + (加号) 即可\n完成后项目会出现在上方，这里以 Hello World 为项目名\n2）开始播放 \u0026lt;1\u0026gt; 找到待播放的歌曲 首先，打开网站 MidiShow – 领先的MIDI音乐交流与下载网站 注册登录后搜索想播放的歌曲\n\u0026lt;2\u0026gt; 进行播放设置 如图所示，以 Hand in Hand 为例，点击 播放设置 按钮\n设置如图， MIDI 输出设备 选择刚刚使用 loopMIDI 新建的项目，这里为 Hello World\n\u0026lt;3\u0026gt; 开始播放 此时进入中文吧钢琴旁，选中板凳坐上去，然后在网页中点击播放即可\n如果使用 mid 文件 首先，请确保mid文件为钢琴谱，多轨文件可能会发生混乱，请自行编辑\n一、准备 1）loopMIDI 此软件可在官网直接获取，官网链接：\n此软件可在官网直接获取，官网链接： loopMIDI-Tobias Erichsen (tobias-erichsen.de) 文件直链： loopMIDISetup_1_0_16_27.zip （可能因为版本更新而失效）\n2）MidiPiano 此软件我在某下载软件网站获取(Google搜索结果第一个)\n网站链接： MidiPiano – Download (softonic.com) 二、步骤 1）在 loopMIDI 中新建项目 新建项目先在右下“New port-name”输入名称，后点击左下“+” (加号)即可\n完成后项目会出现在上方，这里以”Hello World”为项目名\n2）打开 MidiPiano，进行设置 点击播放列表，可直接将文件拖入，点击选项，将输出设备设置为刚刚 loopMIDI 创建的项目，此处为 Hello World\n如果出现弹窗 “MIDI 输入输出不能为同一个，会死机的！” 请点击选项中 Midi 输入设备，将刚刚 loopMIDI 创建的项目取消，然后再切至 Midi 输出设备 将其打开\n3）开始播放 此时进入中文吧钢琴旁，选中板凳坐上去，然后选择 播放列表 中想播放的歌曲，再点击 播放 即可\n参考资料 【VRChat】教你怎样在中文吧自动弹钢琴 哔哩哔哩 播放器选择及插件安装说明 ","date":"2022-03-22T16:11:47+08:00","permalink":"https://blog.yexca.net/archives/34/","title":"VRchat 在中文吧自动弹钢琴"},{"content":"引言 本文章为我自行搜集的一些免费图床，部分图床曾经使用过。当然，如果您想要使用图床，我推荐您阅读 使用 PicX 自建免费图床 – yexca’Blog 一、路过图床 官网链接： 路过图床 – 免费图片上传, 专业图片外链, 免费公共图床 高速稳定，单图最大 10MB\n二、ImgURL 官网链接： ImgURL 免费图床 游客每日限 10 次上传，单图最大 5MB\n三、SM.MS 官网链接： Image Upload – SM.MS – Simple Free Image Hosting 老牌图床，现在游客禁止上传，普通用户单图最大 5MB， 5GB 存储空间\n（另外该图床的图片直链链接域名是 loli.net\n四、KinhPicture 官网链接： KinhPicture – 聚合图床 岛主的聚合图床，支持阿里、百度、AWS S3 等 15 个接口，单图限制 2~32MB\n五.极兔图床 官网链接： 极兔图床 – 免费图床,匿名图床,免费CDN图床,图床API,专业的图片托管商 最大可上传 10MB 的图片\n六、Gimhoy 图床 官网链接： Gimhoy 图床-无限制永久免费图 七、bayimg 官网链接： bayimg – free uncensored image hosting ","date":"2022-03-20T16:54:36+08:00","permalink":"https://blog.yexca.net/archives/33/","title":"图床网站总结"},{"content":"前言 此文章所写方法仅一般用途，如有特殊需求请自行查阅\n一、使用 Win10/Win11 自带 1）系统自带截屏软件 Win10/Win11 自带一个截屏软件，名称为 “截图工具”，有两种形式使用\n\u0026lt;1\u0026gt; 打开软件使用 通过按下 Win 按键，打开所有应用，找到 “截图工具”打开\n如上为打开软件后界面，点击“新建”即可进行截屏\n\u0026lt;2\u0026gt; 使用快捷键 其实上图中软件界面已经有了快捷按键，为 Win+Shift+S，三个一起按键即可开始截屏\n完成截图后保存 当完成截图后，右下通知中心会出现一弹窗。\n如果是想通过聊天软件发送可直接在聊天界面输入框按下 Ctrl+V 即可出现图片\n如果想保存到本地可点击通知中心相应通知，弹出截图后按下 Ctrl+S 选择路径保存\n其他功能请自行探索\n2）使用系统自带的 Xbox Bar 通过按下 Win+G 即可打开 Xbox Bar，点击空白处或再次按下 Win+G 即可关闭\n\u0026lt;1\u0026gt; 通过 Xbox Bar 截屏和录屏 如图所示，红框中第一个按钮为截图，第三个按钮为录屏，再次按下以结束录屏(或按下屏幕上出现的一个悬浮窗上的结束按钮)\n如果未出现 “捕获” 框，请按下上图蓝框中按钮\n\u0026lt;2\u0026gt; 截屏和录屏所在位置 如上图所示，红框中有 “显示全部捕获”，点击即可出现使用 Xbox Bar 截屏或录屏的全部文件，每个文件下都会出现 “打开文件位置”，点击即可打开文件所在位置\n当然，Xbox Bar 所存储的文件路径在 此电脑/视频/摄像 (即 C:\\Users\\%username%\\Videos\\Captures)，截屏和录屏都在这\n二、使用第三方应用 如果是第三方的话会有很多选择，这里仅说明俩个，一般情况下系统自带完全够用\n1）使用 QQ/TIM/WeChat (微信) 进行截图或录制 QQ/TIM 的截图快捷键为 Ctrl+Alt+A，录屏快捷键为 Ctrl+Alt+S\nWeChat (微信) 的截屏快捷键为 Alt+A，未发现录屏功能\n两者均可在聊天界面输入框上方小剪刀图标右小箭头处进行修改 “截屏隐藏当前窗口”\n2）使用 OBS 进行录屏 OBS 简介 由于不是本文重点，此处复制官方简介，进入官方网站下载安装即可\nOBS Studio – Free and open source software for live streaming and screen recording\n官方网站： Open Broadcaster Software-OBS Github： obsproject/obs-studio: OBS Studio 录制屏幕教程 \u0026lt;1\u0026gt; 使用 OBS 进行录制 打开OBS界面如上图所示，在左下第二个有“来源窗口”，点击下方加号\n如上图所示，选择显示器采集，然后点两次确定即可出现显示器屏幕\n右方点“开始录制”即可开始录制当前桌面\n\u0026lt;2\u0026gt; 文件保存位置 点击左上 “文件-显示录像” 即可弹出录制文件保存位置\n问题：如果未出现屏幕 此问题解决方法为在 “NVIDIA 控制面板”，在 “管理 3D 设置” 中将 OBS 的 “为此程序选择首选图形处理器” 改为 “集成式”\n如下图所示，因我的电脑默认 “集成式”，我便未更改\n如不能解决，请自行搜索其他方法\n","date":"2022-03-19T13:57:39+08:00","permalink":"https://blog.yexca.net/archives/32/","title":"Windows 电脑截屏和录屏"},{"content":"引言 近期入正了Beat Saber(虽然是阿区)，于是便想着去添加自定义歌曲，通过steam的评论区得知 WGzeyu 大佬做了相关教程，但由于本人目的简单，而教程比较全，特写此文章进行总结\n一、准备 注: 2022.03.25: 今日更改相关东西发现 1.20.0 已有 Mod，请直接看第二步，同时，恢复数据部分已更新\n1）降级 由于当前最新版本1.20.0并无相关Mod，所以需要先进行降级，等Mod更新后可以再升级\n\u0026lt;1\u0026gt;下载1.19.0版本或更早 可在 WGzeyu大佬提供的网盘 下载，选择想下的版本后进行下载\n文件直链： 1.19.0 steam版 \u0026lt;2\u0026gt;替换1.20.0版本 解压下载的文件，然后通过steam打开游戏所在目录，返回上一级后将文件夹”Beat Saber“重命名为”Beat Saber 1.20.0“，然后将刚刚下载的文件更名为”Beat Saber“移到此文件夹\n\u0026lt;3\u0026gt;如何恢复数据 \u0026lt;1\u0026gt;使用steam打开游戏目录，删除UserData文件夹内的Beat Saber IPA\n\u0026lt;2\u0026gt;复制以下文件夹(按需复制)\nUserData（Mod设置）\nCustomSabers（光剑模型）\nCustomPlatforms（场景模型）\nCustomAvatars（人物模型）\nCustomNotes（方块模型）\n\u0026lt;3\u0026gt;然后进入”Beat Saber 1.20.0“文件夹，粘贴复制的那些文件夹，在弹出的提示中，选择【替换】\n\u0026lt;4\u0026gt;打开”Beat Saber“文件夹，进入Beat Saber_Data文件夹，剪切CustomLevels文件夹\n\u0026lt;5\u0026gt;进入”Beat Saber 1.20.0“文件夹，进入Beat Saber_Data文件夹，粘贴剪切的那个文件夹，在弹出的提示中，选择【替换】\n最后将“Beat Saber”文件夹删除，将“Beat Saber 1.20.0”文件夹重命名为“Beat Saber”\n2）相关软件 \u0026lt;1\u0026gt;Mod管理器”ModAssistant“ 此软件有英文版和中文版，请按需下载，网盘下载： 网盘链接 文件直链： ModAssistant中文增强版Mod安装器，支持PC不支持Quest \u0026lt;2\u0026gt;BeatSaber歌曲路径管理器 可通过上述网盘链接下载，文件直链： BeatSaber歌曲路径管理器 (5.3版本，可能因为更新而失效)\n\u0026lt;3\u0026gt;ResilioSync 可通过上述网盘链接下载，官网链接： ResilioSync 文件直链： ResilioSync64位 3）文件夹 上述软件除ResilioSync均为单文件应用，可放置常用软件文件夹\n另需在想要存放歌曲的位置建立一个文件夹，比如”E:\\games\\Beat Saber Song\\“，随意位置\n二、步骤 1）打开Beat Saber一次 2）打开”ModAssistant“ 点击同意后可进入左方”Mod“界面，左下可选择游戏版本，选择好后可安装Mod，或直接开始安装\n如果速度过慢可在”选项“中将软件源改为国内\n3）打开Beat Saber一次 4）打开ResilioSync 此部分步骤请参考： Beat Saber曲包资源同步 – ResilioSync (wgzeyu.com) 反正最后都是要打开这个网页的，已经有步骤了我就不写了（懒\n下载文件夹目录即选择上一步创建的文件夹\n5）打开BeatSaber歌曲路径管理器 初次打开根据提示选择，然后点添加目录，选择放歌曲的目录(即上一步下载的文件夹目录)\n然后点保存列表即可\n三、后续 当然，如果您有其他需求请参考 WGzeyu 的 教程 ","date":"2022-03-18T17:46:00+08:00","permalink":"https://blog.yexca.net/archives/31/","title":"Beat Saber 添加自定义歌单"},{"content":"引言 在玩了 Beat Saber 和 VRchat 等 VR 游戏后突然想到 i 社有部分游戏支持 VR，本人最喜欢玩恋活，于是试着进行游玩，但却遇到相关问题，本文仅作记录。另 VR 版无剧情，且本人使用原版所以遇到问题较少。\n前提/条件 以下图片和部分文字来自 Oculus 官网 Support ，部分英文自己进行了翻译，鉴于本人英文不是太好，请以官方原内容为准，以下列出主要内容，详情请参考 Oculus Link 的兼容性要求 数据线要求 Oculus Link 需使用能够支持数据和电源连接的优质 USB 数据线。为获得最佳舒适体验，您还应确保数据线长度至少为 3 米 (10 英尺)\n电脑要求 配件 推荐配置 CPU Intel i5-4590 / AMD 锐龙 5 1500X 或更高版本 显卡 请参阅下面的 GPU 表 内存 8 GB+ 内存 操作系统 Win10 USB 接口 1 个 USB 接口 Oculus Link 支持的 GPU NVIDIA GPU 支持 暂时不支持 NVIDIA Titan Z X NVIDIA Titan X X NVIDIA GeForce GTX 970 X NVIDIA GeForce GTX 1060 Desktop, 3GB X NVIDIA GeForce GTX 1060 Desktop, 6GB X NVIDIA GeForce GTX 1060M X NVIDIA GeForce GTX 1070(all) X NVIDIA GeForce GTX 1080(all) X NVIDIA GeForce GTX 1650 X NVIDIA GeForce GTX 1650 Super X NVIDIA GeForce GTX 1660 X NVIDIA GeForce GTX 1660 TI X NVIDIA GeForce RTX 20-series (all) X NVIDIA GeForce RTX 30-series (all) X AMD GPU 支持 暂时不支持 **** **** **** AMD 200 Series X AMD 300 Series X AMD 400 Series X AMD 500 Series X AMD 5000 Series X AMD 6000 Series X AMD Vega Series X 一、进入游戏 进入游戏 VR 版本直接打开 KoikatuVR.exe 即可，由于使用 steam 串流，故可提前进入 steamVR\n进入游戏前请确保戴上耳机，房门锁紧等以预防突发情况，如不能做到请注意行为 (doge)\n问题一：无法进入 steamVR 一、确保安装相关软件 1）steamVR 安装 首先打开 steam，然后按 Win + R ，输入 steam://run/250820，按下回车便会自动安装 steamVR\n2）Oculus 安装 访问 官网下载 ，注意：安装完成后会下载相关文件，完成后会要求登录账户，请确保网络环境正常\n如要求提供支付方式，可寻找 跳过 按钮\n如果登录一直在加载，无法成功登录 可通过修改 Hosts 解决，推荐使用火绒打开 hosts 文件修改\n如果不使用火绒，打开 C:\\Windows\\System32\\drivers\\etc，找到 hosts 这个文件，用记事本打开\n在文件末尾添加如下内容\n1 2 3 4 157.240.11.49 graph.oculus.com 157.240.11.49 www2.oculus.com 157.240.8.49 scontent.oculuscdn.com 157.240.8.49 securecdn.oculus.com 然后保存即可，如果不是使用火绒，请保存到一个地方然后移动回原目录并将后缀 .txt 去除\n二、确保 Link 线正常 事实上，连接 Quest2 的时候 Oculus 软件会有一步选择是否检测 Link 线，可通过此进行检测，如果当时未进行检测，可选择 设备 - Quest2 和 Touch-USB 检测 进行检测\n三、确保设置正常 1）Quest2 设备设置 使用 USB 连接 PC 和 Quest2 时 Quest 会弹出 允许访问数据，请选择拒绝，如果选择了 允许，请拔下再重新连接选择 拒绝\n2）Oculus 软件设置 其实直接打开 steamVR 会有弹窗 是否允许未知来源 此时选择允许即可\n当然，可以在软件的 设置 - 通用 - 未知来源 进行打开\n四、还是无法打开？换个姿势试试 如果以上都没问题但还是无法打开 steamVR，则可使用下述方式\n1）Quest2 设备 当连接 PC 后一般会有弹窗 启用 Oculus Link，此时选择 启用 即可\n如果上述未选择 启用 或没有弹窗，可在下方任务栏的最左方即 快速设置 中找到 Oculus Link，点击即可打开\n2）启动 steamVR 不会有人不知道 steamVR 怎么启动吧 (doge)\n如果先连接 VR 设备再打开 steam，那么 steam 的界面右上方应该有 \u0026ldquo;VR\u0026rdquo; 标识，点击即可打开\n如果无此标识，可在任务栏 (或者说右下托盘) 里找到 steam 图标，鼠标右击，倒数第二个即为 steamVR\n当然，可以在 steam 库中将 工具 也显示，这样可以在 steam 库中看见 steamVR\n二、开始游戏 我不知道这里应该写什么，分这个标题是因为问题二与游戏有关，那就写其他的吧 (doge)\n点击 KoikatuVR.exe 会自动打开 steamVR，所以可以在 Quest2 设备打开 Oculus Link 后直接打开 KoikatuVR 即可\n注意：游戏会在桌面有一个窗口，可通过 Win + D 最小化所有窗口，但当摘下头显再次戴上时好像会再次出现，请注意\n问题二：无法开始游戏/不知如何开始 如果您阅读其他文章或观看相关视频可能会得到仅支持部分设备 (支持啥我忘了)，如果和我一样去测试了 VR kanojo 能否正常运行，也可能会以为是靠注视，其实不然 (我就是想多写点)\n只需要按下 “摇杆” 即可出现选择线，按下前 “扳机键” 即可选择 (更多操作请看 三、操作说明)\n问题三：开始游戏后一直白屏，电脑上 一直在一半 可进 コイカツ！ DL 版 ，点击下方 体験版・無料ダウンロード 中的 コイカツ VR パッチ 进行下载\n文件直链： コイカツ VR パッチ 下载解压后会有一个可执行文件，运行后会出现 コイカツ！VR_0531 更新版 文件夹，将里面 setup 文件夹内容移动到游戏根目录并覆盖即可\n注意：此方法来源作者指出姿势会变成只有三个，由于我并未游玩，所以我没有姿势 (本来想着 VR 玩剧情的，但 VR 不能玩剧情)，以下为作者给出解决 (部分内容有修改)\n姿势是在故事模式里用过什么姿势，在 vr 里才能用，所以在故事模式里战斗的时候把所有姿势都点一遍，点完就换就行，然后到晚上存档，在退出换 vr，然后姿势就齐了\n原文地址： 兄弟们有没有玩了 vr 的 三、操作说明 此部分为自行游玩得出，仅作部分说明，其他操作请自行参考其他文章\n1）开始游戏 进入游戏后会有俩选项，分别为\nスタート，即 start，即开始\nエンド，即 End，即结束\n按下 \u0026ldquo;摇杆\u0026rdquo; ，会出现一条线，可进行选择 (前 \u0026ldquo;扳机键\u0026rdquo;)\n2）进入正文 左右手手腕部分会出现文字，可通过左右控制器上方按键即 Y 和 B 进行切换\n一共有俩个，进入战斗后有三个 (多了一个 移動)，分别为\n日文 英文 中文 作用 アクション Action 行动 前 \u0026ldquo;扳机键\u0026rdquo; 可进行各种操作 侧 \u0026ldquo;扳机键\u0026rdquo; 可打开菜单 按下” 摇杆 “可进行选择 システム system 系统 前 \u0026ldquo;扳机键\u0026rdquo; 可重置位置 移動 Move 移动 前 \u0026ldquo;扳机键\u0026rdquo; 按住可改变视角 3）注意 仅可在 \u0026ldquo;アクション\u0026rdquo; 时按下 \u0026ldquo;摇杆\u0026rdquo; 可以进行选择\n参考文章 Oculus Link 兄弟们有没有玩了 vr 的 Oculus 客户端在 Win10 上面无法安装或者登陆的解决方法_国韵的博客 - CSDN 博客_oculus 无法连接服务器 中国移动的日文 (别问我为什么会参考这个，问就是不会日语)\n","date":"2022-03-18T16:54:23+08:00","permalink":"https://blog.yexca.net/archives/30/","title":"使用 Quest2 VR 玩恋爱活动 (恋活 / koikatu) 遇到的问题及解决"},{"content":" 该文章由 Hiyoung 编写\n第一章：了解Web及网络基础 1.1简介 为理解HTTP应事先了解一下TCP/IP协议族，我们通常使用的网络（包括互联网）是在TCP/IP协议族的基础上运作，而HTTP属于它内部的一个子集。在互联网上的设备需要相互通信双方就必须要遵从相同的规则，我们把这些规则称为协议。（TCP/IP是对互联网相关的各类协议族的一个总称包括但不限于：PPPoE、HTTP、TCP、IP、UDP、IEEE 802.3…）\n在TCP/IP协议族中按照层次从上到下分为：应用层、传输层、网络层、数据链路层\n互联网协议套件-维基百科 在使用TCP/IP协议族进行通信时，客户端会从应用层往下走，服务端会从链路层往上走。客户端在层与层之间传输数据时，每经过一层时会为其加上该层的段首信息。相反，服务端会一层一层的消去首部。这种把数据信息包装起来的办法叫做封装。\n1.2 IP、TCP和DNS 1.2.1 IP协议 IP协议处于网络层，TCP/IP中的IP指的是IP协议，与IP地址并不是一回事。IP协议的作用是把各种数据包发送给对方。各种IP地址可以和MAC地址进行配对。IP地址可变换，但MAC地址基本上不会更改。IP 地址指明了节点被分配到的地址，MAC地址是指网卡所属的固定地址。\n1.2.2 MAC地址 IP之间的通信依赖MAC地址。通常会使用 ARP协议 来根据通信方的IP地址反查出对应的MAC地址\n1.2.3 TCP协议 按层次分，TCP 位于传输层，提供字节流服务（Byte Stream Service）——为了方便传输，将大块数据分割成以报文段（segment）为单位的数据包进行管理。一言以蔽之， TCP 协议为了更容易传送大数据才把数据分割，而且 TCP 协议能够确认数据最终是否送达到对方。\n为了确认数据是否送达到了对方，TCP采用了三次握手策略。握手过程中使用了TCP的标志（flag）——SYN（synchronize）和 ACK（acknowledgement）。\n1.2.4 负责域名解析的DNS服务 计算机既可以被赋予IP地址，也可以被赋予主机名和域名。DNS协议提供通过域名查找IP地址，或逆向从IP地址反查域名的服务。\n1.3 URL和URI 1.3.1 区别与关系 与URI（统一资源标识符）相比，我们更熟悉URL（Uniform Resource Locator，统一资源定位符）。URL正是使用Web 浏览器等访问Web 页面时需要输入的网页地址。比如 https://www.bilibili.com/ 就是URL。URI 用字符串标识某一互联网资源，而 URL 表示资源的地点（互联网上所处的位置）。可见URL是URI的子集。URI可被视为定位符（URL），名称（URN）或两者兼备。 统一资源名 （URN）如同一个人的名称，而 统一资源定位符 （URL）代表一个人的住址。换言之，URN定义某事物的身份，而URL提供查找该事物的方法。\n1.3.2 URI 格式 表示指定的URI，要使用涵盖全部必要信息的绝对URI、绝对URL以及相对URL。\n相对URL，是指从浏览器中基本URI处指定的URL，形如 /image/logo.gif。\n绝对URI的格式：\n登录信息（认证）：指定用户名和密码作为从服务器端获取资源时必要的登录信息（身份认证）。此项是可选项。\n服务器地址：使用绝对 URI 必须指定待访问的服务器地址。地址可以是类似 hackr.jp 这种 DNS 可解析的名称，或是192.168.1.1 这类 IPv4 地址 名，还可以是 [0:0:0:0:0:0:0:1] 这样用方括号括起来的 IPv6 地址名。\n服务器端口号 ：指定服务器连接的网络端口号。此项也是可选项，若用户省略则自动使用默认端口号。\n带层次的文件路径 ：指定服务器上的文件路径来定位特指的资源。这与 UNIX 系统的文件目录结构相似。\n查询字符串 ：针对已指定的文件路径内的资源，可以使用查询字符串传入任意参数。此项可选。\n片段标识符：使用片段标识符通常可标记出已获取资源中的子资源（文档内的某个位置）。但在 RFC 中并没有明确规定其使用方法。该项也为可选项。\n第二章：简单的HTTP协议 2.1 HTTP简介 HTTP是一种不保存状态的协议，所谓不保存状态是指HTTP协议自身并不会对每次的请求和响应之间的通信状态进行保存。所以引入了cookie技术来保存通信状态。（注：HTTP这本书出版较早，现在使用保存状态的技术是由 cookie、session和token 共同实现的）\n2.2 常用的HTTP方法 GET：获取资源\nGET方法是用来请求URL指定的资源。指定资源经服务器端解析后返回响应内容\nPOST：传输实体主体\nPOST用于向服务器传输数据，和获取的数据过大时也会使用POST方法。\nGET和POST的区别：\n先下结论，GET 和 POST 方法没有实质区别，只是报文格式不同。\n请求参数长度限制：GET请求长度最多1024kb，POST对请求数据没有限制\n请求参数：GET请求参数是通过URL传递的，多个参数以\u0026amp;连接，POST请求放在request body中。\n请求缓存：GET请求会被缓存，而POST请求不会，除非手动设置。\n安全性：POST比GET安全，GET请求在浏览器回退时是无害的，而POST会再次请求。\n历史记录：GET请求参数会被完整保留在浏览历史记录里，而POST中的参数不会被保留。\n编码方式：GET请求只能进行url编码，而POST支持多种编码方式。\n对参数的数据类型：GET只接受ASCII字符，而POST没有限制。\n此外， HTTP还有PUT、HEAD、DELETE等方法 在此不细细展开。\n2.3 HTTP的持久连接（三次握手四次挥手） 持久连接的特点是，只要任意一端没 有明确提出断开连接，则保持 TCP 连接状态。\n三次握手：建立TCP连接 四次挥手：断开TCP连接\n在持久连接中使用管线化技术可以不用等待响应即可直接发送下一个请求。\n2.4 使用cookie的状态管理 Cookie 会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie 的首部字段信息，通知客户端保存 Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入 Cookie 值后发送出去。\nCookie信息是在服务端产生发送给客户端进行保存的\n第三章 HTTP报文信息 3.1 HTTP的请求和响应报文结构 用于HTTP协议交互的信息被称为HTTP报文。请求端（客户端）的HTTP报文叫做请求报文，响应端（服务器端）的叫做响应报文。由8位字节流组成，通过HTTP通信传输。\n请求行：包含用于请求的方法，请求 URI 和 HTTP 版本。\n状态行：包含表明响应结果的状态码，原因短语和 HTTP 版本。\n首部字段：包含表示请求和响应的各种条件和属性的各类首部。一般有4种首部，分别是：通用首部、请求首部、响应首部和实体首部。\n其他：可能包含 HTTP 的 RFC 里未定义的首部（Cookie 等）。\n3.2 编码传输及分块传输 HTTP在传输数据过程中通过编码提升传输速率。\n3.2.1 报文主体和实体主体的差异 实体：作为请求或响应的有效载荷数据（补充项）被传输，其内容由实体首部和实体主体组成。\nHTTP 报文的主体用于传输请求或响应的实体主体。 **通常，报文主体等于实体主体。**只有当传输中进行编码操作时，实体主体的内容发生变化，才导致它和报文主体产生差异。\n3.2.2 分割发送实体主体 在HTTP通信过程中传输大容量数据时，通过把数据分割成多块能让浏览器逐步显示页面。把实体主体分块的功能称为分块传输编码。分块传输编码会将实体主体分成多个块。每一块都会用 十六进制来标记块的大小，而实体主体的最后一块会使用“0(CR+LF)”来标记。\n所谓的块也就是常称的包\n第四章 返回结果的HTTP状态码 4.1 状态码的类别 借助状态码用户可以知道服务器是否正常处理了请求，状态码种类繁多但常用的大概只要14种。\n4.2 2XX 成功 4.2.1 200 OK 表示从客户端发来的请求在服务器端被正常处理了。在响应报文内，随状态码一起返回的信息会因方法的不同而发生改变。\n4.2.2 204 No Content 该状态码代表服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分。\n4.3 3XX 重定向 重点介绍一下301重定向和302重定向，还有其他状态码可自行查看\n4.3.1 301 Moved Permanently 301重定向是永久性的重定向。该状态码表示请求的资源已被分配了新的URI，以后应使用资源现在所指的 URI。例如像下方给出的请求URI，当指定资源路径的最后忘记添加斜杠 “/”，就会产生 301 状态码。\nhttp://excample.com/sample 4.3.2 302 Found 302重定向是临时性的重定向。该状态码表示请求的资源已被分配了新的URI，希望用户（本次）能使用新的 URI 访问。和 301 Moved Permanently 状态码相似，但 302 状态码代表的资源不是被永久移动，只是临时性质的。\n4.4 4XX 客户端错误 有400 Bad Request、401 Unauthorized、403 Forbidden、404 Not Found。 重点介绍一下404 Not Found\n4.4.1 404 Not Found 该状态码表明服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由时使用。\n4.5 5XX 服务器端错误 5XX 的响应结果表明服务器本身发生错误。\n第五章 Web服务器 5.1 通信数据转发程序：代理、网关、隧道 5.1.1 代理 代理服务器的基本行为就是接收客户端发送的请求后转发给其他服务器。代理不改变请求URI，会直接发送给前方持有资源的目标服务器。值得一提的是代理是指对客户端的代理（也称为前向代理），而反向代理是指对服务器的代理。\n使用代理服务器可以利用缓存技术减少网络宽带的流量，有时也会为了信息安全而使用代理。\n缓存代理 代理转发响应时，缓存代理（Caching Proxy）会预先将资源的副本（缓存）保存在代理服务器上。当代理再次接收到对相同资源的请求时，就可以不从源服务器那里获取资源，而是将之前缓存的资源作为响应返回。\n反向代理 反向代理的优点有很多：\n对客户端隐藏服务器（集群）的IP地址\n安全：作为 应用层防火墙 ，为网站提供对基于Web的攻击行为（例如 DoS / DDoS ）的防护，更容易排查 恶意软件 等\n为后端服务器（集群）统一提供加密和 SSL 加速（如SSL终端代理）\n负载均衡 ，若服务器集群中有负荷较高者，反向代理通过 URL重写 ，根据连线请求从负荷较低者获取与所需相同的资源或备援\n对于静态内容及短时间内有大量访问请求的动态内容提供 缓存服务 对一些内容进行 压缩 ，以节约 带宽 或为网络带宽不佳的网络提供服务\n5.1.2 网关 网关的工作机制和代理十分相似。而网关能使通信线路上的服务器 提供非HTTP协议服务。\n","date":"2022-03-16T23:56:48+08:00","permalink":"https://blog.yexca.net/archives/29/","title":"《图解HTTP》读后总结及浅谈"},{"content":"注意 此文章复制自 《unity学习笔记》——将MMD模型导入unity ，仅用于个人记录使用，部分内容有修改\n方法1：利用unity插件直接读取fbx模型 第一步：安装插件 MMD4Mecanim (Beta) 插件地址： Stereoarts Homepage （应插件作者要求请勿上传至GitHub）\n文件直链： MMD4Mecanim_Beta_20200105.zip 第二步：打开unity，双击下载好的插件中 MMD4Mecanim.unitypackage 文件 第三步：将MMD模型（全部）文件导入unity 选择自动生成的.MMD4Mecanim，点击同意（此时可加动画音乐等）\n该方法好处是可以最大限度还原MMD本来的渲染效果，而且不用自己重新设置shader，并且不借助unity之外的其他软件\n方法2：利用Blender插件将MMD模型转为fbx导入 第一步：安装blender插件 GitHub: cats-blender-plugin 该插件可以让blender识别MMD的pmx文件，然后可以根据需要用blender导出成fbx、stl 等格式（fbx为unity可识别的格式）\n第二步：将导出的fbx模型与原模型的所有材质一起导入unity 在导入unity时可能效果或渲染风格会与原来的不一致，需要自己设置shader\n自己设置shader的好处是可以在unity中统一不同模型的美术风格，或者如果是想图个方便，可以在unity商店下载相应风格的模型，将下载模型的shader应用至导入的MMD模型即可（模型动作也可应用，颜色可以自己改\n","date":"2022-03-10T13:15:26+08:00","permalink":"https://blog.yexca.net/archives/28/","title":"将 MMD 模型导入 Unity"},{"content":"引言 在日常发文章时经常会需要插入图片（虽然我最近文章都没图片），但是如果使用自己服务器比较耗流量并且加载速度不是特别快，这就需要使用图床了，但是多数免费图床会有时不时图没了，速度慢等之类的问题，于是开始探索自建图床。\n可是如果特意花钱租云服务器托管图片，太贵划不来，使用付费图床多数有流量或空间限制，于是我不经意间发现一项目，一款基于 GitHub API \u0026amp; jsDelivr 开发的具有 CDN 加速功能的图床管理工具。\nPicX图床简介 官方网站： PicX图床 项目地址： XPoet/picx: 基于 GitHub API \u0026amp; jsDelivr 开发的具有 CDN 加速功能的图床管理工具 官方文档： 快速开始-PicX 图床 特点：只需选择一个 GitHub 仓库作为图床，然后在 PicX 官网 完成 Token 绑定和相应配置就能使用了，免下载\u0026amp;安装，如此简单。\n快速开始 首先，新建一个GitHub 仓库 点击链接 Create a New Repository Repository name填写一个名字(例image-hosting)\n仓库属性必须选 Public\n然后，创建一个带有 repo 权限的GitHub Token 点击链接 New personal access token 填写Note(即名字，例picx-image-hosting)\n注意： “Expiration”为此Token的有效期，请注意选择\n如果您过早看到这篇文章没有设置，请参考： 使用PicX图床上传图片提示“Bad credentials” – yexca’Blog Select scopes勾选repo，然后创建Token\n注意：新生成的 Token 只会显示一次，请妥善保存，如有遗失，重新生成即可。\n最后，到官网填写Token配置 打开 PicX官网 ，进入图床配置，填入Token\n然后选择仓库和目录方式\n新建目录：需手动输入一个新目录。 (使用 / 可创建多级目录，例如：A01/A02 表示创建了二级目录，最大支持创建三级目录。) 根目录：图片将直接存储在仓库根目录下。 自动目录：自动生成日期格式 YYYYMMDD 的目录。例如：20200909。 OK，图床已经配置完成，开始使用吧\n其他 设置默认开启图片压缩，可在“我的设置”进行修改\n","date":"2022-02-17T23:02:13+08:00","permalink":"https://blog.yexca.net/archives/27/","title":"使用 PicX 自建免费图床"},{"content":"引言 由于学校的教务系统查看课程表不是那么便捷，而且第三方课程表有一定的安全隐患并且广告奇多，于是便想着把课程表导入日历，我选择导入 Outlook 日历，这样可以实现 iOS，Windows 和 Android 多端同步。\n准备工作 一台电脑 一个 Android 手机 电脑安装 chrome 浏览器： 官网链接 手机安装 WakeUp 课表： 官网链接 第一步，导出课程表 一、使用 chrome 打开教务系统网址，进入课表界面\n二、导出 HTML 文件\n首先复制以下代码\n1 javascript:void(function(u,s){s=document.body.appendChild(document.createElement(\u0026#39;script\u0026#39;));s.src=u+\u0026#39;?ts=\u0026#39;+Date.now();s.charset=\u0026#39;UTF-8\u0026#39;}(\u0026#39;https://the-red-hat-was-uncovered.gitee.io/supwisdom-course-table/dist.js\u0026#39;)) 然后是添加收藏夹，Windows 下快捷键 Ctrl + D\n按下快捷键后，可以直接点「更多」按钮，来编辑刚添加的收藏，这时候可以改名称和 URL（网址），名称起个好记的（比如 “WakeUp 导出课表”），URL（网址）那里粘贴上刚刚复制的代码！然后再保存。\n最后点击刚刚收藏的网址（上述），此时浏览器会自动下载 “教务.html” 文件（即为下一步要用的文件）\n第二步，导入 WakeUp 课表 一、将上一步导出的文件发送到手机上\n二、导入课表至 WakeUp 课表\n手机打开 WakeUp 课表，导入新课表（右上第二个），点击 “从 HTML 文件导入”\n“选择学校/教务类型” 选择 “树维教务（简易导入）” ，不用选择学校，然后选择文件后点右下角\n导入完成后注意选择正确开学日期或者当前周数\n第三步，导入日历 在 WakeUp 课表点右上角第三个导出，选择 “导出为 ICS（日历用）格式”\n如果是 Android 手机可找到文件目录，点击文件，用日历打开即可\n如果是 iOS 手机可通过发邮件（带附件）的方式发到手机登录的邮箱，然后点击附件导入\n参考文章 树维教务简易导入 ","date":"2022-02-16T17:53:16+08:00","permalink":"https://blog.yexca.net/archives/26/","title":"将课程表导入日历（树维教务）"},{"content":"国内工具 使用站长工具的端口扫描，输入IP地址或域名和端口后点击开始扫描\n如果显示关闭，则端口未开放或无法连接\n工具链接： 端口扫描 – 站长工具 国外工具 使用 you get signal 的 Port Forwarding Tester 进行扫描\n进入后会自动填写您的IP和80端口，可修改为想要扫描的IP和端口后点击Check\n如果出现红旗并显示 port ** is closed on ***.***.***.*** 则端口未开放或无法连接\n工具链接： Open Port Check Tool – Test Port Forwarding on Your Router ","date":"2022-02-13T19:46:38+08:00","permalink":"https://blog.yexca.net/archives/25/","title":"查看服务器端口是否开放"},{"content":"引言 由于 QQ 软件过于臃肿并且权限过大，并且经常性卡住无法加载，所以便寻找其他方法，首先是通过 Telegram 收发 QQ 消息，但配置较为复杂且并不稳定，于是弃用并改用 VS Code\n插件简介 名称: QQ\nID: takayama.vscode-qq\n说明: lite qq for chat in working\n版本: 1.4.2\n发布者: takayama\nVS Marketplace 链接: VS Code QQ Extension Github项目地址： vscode-qq 注：本程序不在本地保存任何消息记录和图片。暂不支持临时会话。\n安装 首先安装 VS Code，访问 官网 点击 Download 即可下载安装\n然后访问上述 VS Code QQ Extension 链接点击 Install 即可自动打开VS Code安装\n或者打开 VS Code 在左侧“拓展”(或按CTRL+SHIFT+X)，然后搜索QQ(注意大写)，点击第一个安装\n功能 按快捷键“CTRL+SHIFT+P”打开命令面板\n输入“QQ Explorer: Login”（或只输入“login”会显示对应选项）后回车\n然后根据提示输入账号密码即可登录成功，此时会显示相功能\n输入“QQ Explorer: 搜索好友”即可搜索好友\n输入“QQ Explorer: 搜索群”即可搜索群\n设置 在登录成功后控制面板便会有设置，进入设置为json文件编辑，内容如下\n1 2 3 4 5 6 7 8 9 { \u0026#34;account\u0026#34;: ***********, // QQ号码 \u0026#34;password\u0026#34;: \u0026#34;********************************\u0026#34;, //QQ密码 \u0026#34;platform\u0026#34;: 5, //登录平台，可更改“1:手机，3:手表(功能不完整)，4:PC，5:pad(默认)” \u0026#34;show_me_add_group_request\u0026#34;: false, \u0026#34;theme\u0026#34;: \u0026#34;default\u0026#34;, // UI主题，可更改“default(默认)和console(控制台风格)” \u0026#34;theme_css\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;theme_js\u0026#34;: \u0026#34;\u0026#34; } 可自定义主题，详情参考： 修改/自定义UI主题 ","date":"2022-02-11T21:47:56+08:00","permalink":"https://blog.yexca.net/archives/24/","title":"使用 VS Code 收发 QQ 消息"},{"content":"引言 Potplayer 是非常优秀的视频播放软件，但最近的版本右下开始有弹窗广告非常的让人困扰，本文讲述两种方法解决右下弹窗\n使用无弹窗的旧版本（推荐） 最后一个无广告弹窗的版本是1.7.18958\n旧版本的所有PotPlayer都可以在以下地址下载获得：\nPotPlayer Old Versions Downloads 1.7.18958版本直接下载地址： 64位 | 32位 安装完成后打开设置（F5）可在”基本-自动更新“选择”不使用自动更新“\n使用绿色版 注：此版本使用体验个人感觉不是太好，例如不能靠近吸附，以源文件比例打开等\n蓝奏云链接 by zdBryan\n常规运行=安装版（含开始菜单快捷方式和程序卸载项的快捷方式）\n右键解压=绿色版（本身不提供便携式的软件要手动运行绿化处理）\n版本特点\n1、去效验，去右下角空白广告弹窗！卸载可选备份设置 2、禁止后台联网请求：境外广告、发送日志、检查升级 3、集成额外的音频解码器及视频解码器组件 4、预设配置：常规设置 + 默认启用自定义解码器H.265/HEVC及硬件加速 5、删除TV直播列表, 登陆程序,日志管理, 消息通知, 多语言等不必要的文件 参考文章 关于Potplayer右下角弹窗解决方案 PotPlayer v1.7.21589绿色版 ","date":"2022-02-06T21:37:45+08:00","permalink":"https://blog.yexca.net/archives/23/","title":"去除 Potplayer 右下弹窗"},{"content":"引言(废话) 闲来无事，于是便想要折腾一下路由器当网关（但事后发现这个路由器空间太小，安装不了多少插件，属实是白忙活了一下午）\n2022.02.17更新：不经意间发现了一个自带网关的FIR300M固件，但由于支持的method过于老旧，如需刷取，请注意辨别。\n原帖地址： 更新编译方法 - FIR300M/FIR302M的Openwrt固件,免拆机刷 百度网盘： 提取码: vouv OpenWRT简介 OpenWRT是基于Linux的适用于路由器的系统，有许多强大的插件和较强的可拓展性，并且可以通过SSH进行连接\n官网： OpenWrt Wiki - Welcome to the OpenWrt Project OpenWRT通用教程： 从零开始学习OpenWrt：刷機 + 使用 + 編譯教程 准备工作 一、软件 HFS 二、适用于FIR300M的OpenWRT固件（ 百度网盘 ） 三、电脑开启Telnet服务，参考 win10 怎么开启 telnet 服务 （win11也可，控制面板可以在设置搜索进入） 简要过程 一、登录路由器后台（192.168.1.1）并登录 二、访问 http://192.168.1.1/goform/Diagnosis?pingAddr=192.168.1.100|echo””|telnetd 三、打开cmd，输入：telnet 192.168.1.1 四、把固件传入路由器，等待完成 五、此时进入路由器后台即为OpenWRT（初始无密码，直接登录即可） 六、点击”System-Language and Style”可将语言改为中文 详细过程(第四步) 打开HFS，将“准备工作”第二步下的固件改名“1.bin”拖入窗口\n在cmd输入命令“telnet 192.168.1.1”并成功连接后依次输入以下命令\n1 2 3 cd /tmp wget http://192.168.1.100/1.bin //“192.168.1.100”替换为您的机器IP mtd_write -r write 1.bin Kernel （注意，这里的K是大写） 执行成功后路由器会自动重启，所以会显示“断开连接”\n插件安装 在OpenWRT管理后台点击“系统-软件包”即可安装相应插件\n建议上Github寻找相应插件，当然也可以自行编写\n因安装插件需要网络地址，可以直接复制Github相应项目Release下ipk包链接\n自己编写如何安装？您都会自己编写了还不会这个？（doge）\n注意 插件安装需要与路由器相兼容，部分插件可能需要环境依赖，即需要先安装其他插件\n具体可以通过报错信息进行判断\n参考文章 FIR300M免拆机刷Openwrt教程 路由器刷固件——斐讯路由器FIR300M刷OpenWrt固件教程 HFS – 超好用的本地文件分享利器，快速从电脑传文件到手机等设备 许迎果 第215期 OpenWrt插件的安装与卸载 ","date":"2022-02-06T20:44:10+08:00","permalink":"https://blog.yexca.net/archives/22/","title":"FIR300M 路由器刷固件 OpenWRT"},{"content":"引言(废话) 有些时候会有在Word文档中插入代码的需求，但是直接把代码拷贝过去会不大美观，而且没有高亮看着也非常难受\n工具一 CodeInWord 在word中优雅展现的代码/代码高亮/word中插入代码/代码格式化 工具二 Syntax Highlight Code In Microsoft Word 使用说明 没什么要说明的，把代码复制过去，选择相应语言，点击生成再复制到Word中即可\n附录 如果以上网站不可以使用，可在搜索引擎搜索”syntax highlight code in word“\n参考文章 如何优雅的在 Microsoft word中插入代码 ","date":"2022-01-20T14:28:52+08:00","permalink":"https://blog.yexca.net/archives/21/","title":"在 Microsoft Word 中插入代码（高亮）"},{"content":"前言 在游玩外区一些小游戏时，常常会由于乱码而不能游玩或者报错无法运行，此时需要转区以匹配正确文字\n虽然可以通过修改 Windows 的地区设置以运行，但很多时候此方法略显繁琐，并且需要重启电脑，游玩后如果不改回则可能导致正常软件无法使用，此时便需要相关转区软件\n软件获取 软件官网： Locale Emulator GitHub 项目地址(releases)： Locale Emulator – GitHub 配置说明 下载解压后点击 “LEInstaller” 根据需要为当前用户或所有用户安装\n安装完成后点击 “LEGUI” 配置转区环境 (如果游玩日本游戏则不需要，默认会自动配置)\n使用说明 找到待打开的游戏，右击运行文件 (.exe)\n然后选择 Locale Emulator，然后选择相应环境运行 (如果是 Win11，请点击“显示更多选项”)\n废话 仅作记录以自用，官网就有使用说明\n","date":"2022-01-14T15:53:40+08:00","permalink":"https://blog.yexca.net/archives/20/","title":"转区软件 Locale Emulator"},{"content":" 该文章由 Hiyoung 编写\n背景知识：\nlinux时钟概述\nlinux系统有两个时钟：一个是硬件时钟，即BIOS时间；另一个是系统时钟，是linux系统Kernel（内核）时间。\n在linux系统上程序运行时读取的时间都是系统Kernel（内核）时间。\n每次Linux启动时，系统Kernel（内核）会先去读取硬件时钟的设置（但是此时的硬件时间不一定是准确的），然后系统时钟就会独立于硬件继续运作。\n综上所述，所以想要永久修改linux时间并使得时间准确，就需要永久修改硬件时间，不然每次重新启动linux时，系统时间又变回之前的硬件时间。\nlinux时钟相关命令\n系统Kernel（内核）时钟的相关命令是timedatectl 或者 date；\n硬件BIOS时钟相关命令是hwclock 或者 clock。\n1.在Linux GLI界面输入data查看当前Linux系统时间 1 data 输入hwclock –show查看硬件时间\n1 hwclock --show 2.校准Linux系统时间（使用ntp服务时需要系统联网） CentOS 下安装配置ntp服务的步骤如下： 1 2 # 安装ntp服务的软件包 sudo yum install ntp 1 2 # 将ntp服务设置为缺省启动 sudo chkconfig ntp on 1 2 # 修改启动参数，增加-g -x参数，允许ntp服务在系统时间误差较大时也能正常工作 sudo vi /etc/sysconfig/ntpd 1 2 # 启动ntp服务 sudo service ntpd restart Ubuntu/Debian下安装配置ntp服务的步骤如下： 1 2 # 安装ntp服务的软件包 sudo apt-get install ntp 1 2 # 修改启动参数，增加-g -x参数，允许ntp服务在系统时间误差较大时也能正常工作 sudo vi /etc/default/ntp 1 2 # 启动ntp服务 sudo service ntp restart 将硬件时钟调整为与系统时钟一致 1 hwclock --systohc --localtime (好像这个更有效) # 或者\n1 timedatectl set-local-rtc 1 最后将日期写入CMOS永久生效 1 clock -w # 或者\n1 hwclock -w 3.开启谷歌BBR加速 本文的系统要求为 Debian 9或更高版本的 Debian Linux，其它操作系统所知不详，不知是否适合本文的方法。\n注意，本文的配置参数不仅仅是启用Google BBR，还包括一系列网络参数的优化，直接拷贝执行使用即可。\nGoogle BBR 一键加速VPS服务器很简单，SSH登录VPS后，分别执行以下2个命令即可（鼠标选中高亮后，点鼠标右键复制粘贴到root用户的#后面，然后回车）。\n命令1： 1 wget https://raw.githubusercontent.com/bannedbook/fanqiang/master/v2ss/server-cfg/sysctl.conf -O -\u0026gt; /etc/sysctl.con 如果提示 wget: command not found 的错误，这是因为你的系统wget没有安装，所以需要安先装 wget:\n\u0026lt;strong\u0026gt;apt-get install -y wget\u0026lt;/strong\u0026gt;\n命令2： 1 sysctl -p 执行成功后大致会输出：（视个人情况而言）\nfs.file-max = 51200\nnet.ipv4.conf.lo.accept_redirects = 0\nnet.ipv4.conf.all.accept_redirects = 0\nnet.ipv4.conf.default.accept_redirects = 0\nnet.ipv4.ip_local_port_range = 10000 65000\nnet.ipv4.tcp_fin_timeout = 15\nnet.ipv4.tcp_fastopen = 3\nnet.ipv4.tcp_keepalive_time = 1200\nnet.ipv4.tcp_rmem = 32768 436600 873200\nnet.ipv4.tcp_syncookies = 1\nnet.ipv4.tcp_synack_retries = 2\nnet.ipv4.tcp_syn_retries = 2\nnet.ipv4.tcp_timestamps = 0\nnet.ipv4.tcp_max_tw_buckets = 9000\nnet.ipv4.tcp_max_syn_backlog = 65536\nnet.ipv4.tcp_mem = 94500000 91500000 92700000\nnet.ipv4.tcp_max_orphans = 3276800\nnet.ipv4.tcp_mtu_probing = 1\nnet.ipv4.tcp_wmem = 8192 436600 873200\nnet.core.netdev_max_backlog = 250000\nnet.core.somaxconn = 32768\nnet.core.wmem_default = 8388608\nnet.core.rmem_default = 8388608\nnet.core.rmem_max = 67108864\nnet.core.wmem_max = 67108864\nnet.ipv4.tcp_congestion_control = bbr\n","date":"2022-01-14T01:30:54+08:00","permalink":"https://blog.yexca.net/archives/19/","title":"Linux 服务器（网络相关）"},{"content":"注意：此方法为临时连接，虚拟机重启或关机需要重新配置\n虚拟机网络适配器设置 虚拟机的网络适配器一共有三个设置\n桥接模式：指使用本机网络网段 NAT模式：使用VMware Network Adapter VMnet8的网段 Host-only(仅主机模式)：使用VMware Network Adapter VMnet1的网段 查看IP网段 打开VMware中左上“编辑-虚拟网络编辑器”即可看到VMnet1和VMnet8对应网段地址(子网地址)\n桥接模式的网段需要打开“设置-网络和Internet-高级网络设置”找到相应的本机连接的网络\n如果使用WiFi连接，点击“WLAN-查看其他属性”即可看到IP地址 如果使用有线连接，点击“以太网-查看其他属性”即可看到IP地址 注意：如果本机连接了以太网和WIFI，则可能需要对VMware中左上“编辑-虚拟网络编辑器” 进行相关设置\n需要给VMware管理员权限，如图示选择想要VMware连接的网卡\n设置虚拟机的IP地址 注：我使用的是桥接模式，我的本机IP为192.168.1.116，那么我可以将虚拟机设置为192.168.1.0-192.168.1.255中任意一个(除192.168.1.116)，即前三段一样，最后一段不一样即可\n首先，打开虚拟机并登录root用户，输入“ifconfig”命令查看网卡配置\n如果如图出现“ens33”和“lo”或者“其他”和“lo”\n输入命令\n1 2 3 # ifconfig 设备名(本例为\u0026#34;ens33\u0026#34;) 要分配的地址(这里选择的是192.168.1.110) ifconfig ens33 192.168.1.110 如果仅出现“lo”\n输入命令\n1 2 3 # ifconfig 设备名(一般为\u0026#34;eth0\u0026#34;) 要分配的地址(这里选择的是192.168.1.110) ifconfig eth0 192.168.1.110 配置完成后，可再次输入“ifconfig”命令查看网卡配置\n如上图IP成功改为192.168.1.110\n可以打开“Windows终端”，输入“ping 192.168.1.110”查看是否生效\n如图即可表示IP修改成功并可访问\n使用Xshell连接 打开Xshell，点击“新建”，名称可自行决定，主机填写IP，然后点击“连接”\n选择“接受并保存”，然后跟随提示输入用户名(root)和密码即可\n","date":"2021-12-26T15:34:59+08:00","permalink":"https://blog.yexca.net/archives/18/","title":"使用 xshell 连接虚拟机的 centos7 系统"},{"content":"顺序栈 (数组实现) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #include \u0026lt;stdio.h\u0026gt; // 元素 elem 进栈，a 为数组，top 值为当前栈的栈顶位置 int push(int* a,int top,int elem) { a[++top]=elem; return top; } // 数据元素出栈 int pop(int * a,int top) { if (top==-1) { printf(\u0026#34;空栈\u0026#34;); return -1; } printf(\u0026#34;弹栈元素：%d\\n\u0026#34;,a[top]); top--; return top; } int main(void) { int a[100]; int top=-1; top = push(a, top, 1); top = push(a, top, 2); top = push(a, top, 3); top = push(a, top, 4); top = pop(a, top); top = pop(a, top); top = pop(a, top); top = pop(a, top); top = pop(a, top); return 0; } 输出结果：\n弹栈元素：4\n弹栈元素：3\n弹栈元素：2\n弹栈元素：1\n空栈\n链栈 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; typedef struct lineStack{ int data; struct lineStack * next; }lineStack; // stack 为当前的链栈，a 表示入栈元素 lineStack* push(lineStack * stack,int a) { // 创建存储新元素的节点 lineStack * line=(lineStack*)malloc(sizeof(lineStack)); line-\u0026gt;data=a; // 新节点与头节点建立逻辑关系 line-\u0026gt;next=stack; // 更新头指针的指向 stack=line; return stack; } // 栈顶元素出链栈的实现函数 lineStack * pop(lineStack * stack) { if (stack) { // 声明一个新指针指向栈顶节点 lineStack * p=stack; // 更新头指针 stack=stack-\u0026gt;next; printf(\u0026#34;出栈元素：%d \u0026#34;,p-\u0026gt;data); if (stack) { printf(\u0026#34;新栈顶元素：%d\\n\u0026#34;,stack-\u0026gt;data); } else { printf(\u0026#34;栈已空\\n\u0026#34;); } free(p); } else { printf(\u0026#34;栈内没有元素\u0026#34;); return stack; } return stack; } int main(void) { lineStack * stack=NULL; stack=push(stack, 1); stack=push(stack, 2); stack=push(stack, 3); stack=push(stack, 4); stack=pop(stack); stack=pop(stack); stack=pop(stack); stack=pop(stack); stack=pop(stack); return 0; } 输出结果：\n出栈元素：4 新栈顶元素：3\n出栈元素：3 新栈顶元素：2\n出栈元素：2 新栈顶元素：1\n出栈元素：1 栈已空\n栈内没有元素\n","date":"2021-11-21T22:19:04+08:00","permalink":"https://blog.yexca.net/archives/17/","title":"数据结构 栈代码"},{"content":"代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; // malloc()、exit() #define Size 5 // 对 Size 进行宏定义，表示顺序表申请空间的大小 typedef struct Table { int * head; // 声明了一个名为head的长度不确定的数组，也叫“动态数组” int length; // 记录当前顺序表的长度 int size; // 记录顺序表分配的存储容量 }table; // 初始化函数 table initTable() { table t; t.head = (int*)malloc(Size * sizeof(int)); // 构造一个空的顺序表，动态申请存储空间 if (!t.head) // 如果申请失败，作出提示并直接退出程序 { printf(\u0026#34;初始化失败\u0026#34;); exit(0); } t.length = 0; // 空表的长度初始化为 0 t.size = Size; // 空表的初始存储空间为 Size return t; } // 插入函数，其中，elem 为插入的元素，add 为插入到顺序表的位置 table addTable(table t, int elem, int add) { int i; // 判断插入本身是否存在问题（如果插入元素位置比整张表的长度 +1 还大 (如果相等，是尾随的情况)，或者插入的位置本身不存在，程序作为提示并自动退出) if (add \u0026gt; t.length + 1 || add \u0026lt; 1) { printf(\u0026#34;插入位置有问题\u0026#34;); return t; } // 做插入操作时，首先需要看顺序表是否有多余的存储空间提供给插入的元素，如果没有，需要申请 if (t.length == t.size) { t.head = (int *)realloc(t.head, (t.size + 1) * sizeof(int)); if (!t.head) { printf(\u0026#34;存储分配失败\u0026#34;); return t; } t.size += 1; } // 插入操作，需要将从插入位置开始的后续元素，逐个后移 for (i = t.length - 1; i \u0026gt;= add - 1; i--) { t.head[i + 1] = t.head[i]; } // 后移完成后，直接将所需插入元素，添加到顺序表的相应位置 t.head[add - 1] = elem; // 由于添加了元素，所以长度 +1 t.length++; return t; } // 删除函数 table delTable(table t, int add) { int i; if (add \u0026gt; t.length || add \u0026lt; 1) { printf(\u0026#34;被删除元素的位置有误\u0026#34;); exit(0); } for (i = add; i \u0026lt; t.length; i++) { t.head[i - 1] = t.head[i]; } t.length--; return t; } // 查找函数，其中，elem 表示要查找的数据元素的值 int selectTable(table t, int elem) { int i; for (i = 0; i \u0026lt; t.length; i++) { if (t.head[i] == elem) { return i + 1; } } return -1; } // 更改函数，其中，elem 为要更改的元素，newElem 为新的数据元素 table amendTable(table t, int elem, int newElem) { int add = selectTable(t, elem); t.head[add - 1] = newElem; return t; } // 输出顺序表中元素的函数 void displayTable(table t) { int i; for (i = 0; i \u0026lt; t.length; i++) { printf(\u0026#34;%d \u0026#34;, t.head[i]); } printf(\u0026#34;\\n\u0026#34;); } int main() { int i, add; table t1 = initTable(); // 向顺序表中添加元素 for (i = 1; i \u0026lt;= Size; i++) { t1.head[i - 1] = i; t1.length++; } printf(\u0026#34;原顺序表：\\n\u0026#34;); displayTable(t1); printf(\u0026#34;删除元素1:\\n\u0026#34;); t1 = delTable(t1, 1); displayTable(t1); printf(\u0026#34;在第2的位置插入元素5:\\n\u0026#34;); t1 = addTable(t1, 5, 2); displayTable(t1); printf(\u0026#34;查找元素3的位置:\\n\u0026#34;); add = selectTable(t1, 3); printf(\u0026#34;%d\\n\u0026#34;, add); printf(\u0026#34;将元素3改为6:\\n\u0026#34;); t1 = amendTable(t1, 3, 6); displayTable(t1); return 0; } 结果 程序运行结果为：\n原顺序表：\n1 2 3 4 5\n删除元素 1:\n2 3 4 5\n在第 2 的位置插入元素 5:\n2 5 3 4 5\n查找元素 3 的位置:\n3\n将元素 3 改为 6:\n2 5 6 4 5\n","date":"2021-11-20T23:01:47+08:00","permalink":"https://blog.yexca.net/archives/16/","title":"数据结构 顺序表代码"},{"content":"简单链表 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include \u0026lt;stdio.h\u0026gt; struct student { long num; float score; struct student *next; }; void main() { struct student a, b, c, *head, *p; a.num = 99101; a.score = 89.5; b.num = 99103; b.score = 90; c.num = 99107; c.score = 85; // 对结点的 num 和 score 成员赋值 head = \u0026amp;a; // 将结点 a 的起始地址赋给头指针 head a.next = \u0026amp;b; // 将结点 b 的起始地址赋给 a 结点的 next 成员 b.next = \u0026amp;c; c.next = NULL; // c 结点的 next 成员不存放其他结点地址 p = head; // 使 p 指针指向 a 结点 do { printf(\u0026#34;%ld %5.1f\\n\u0026#34;, p-\u0026gt;num, p-\u0026gt;score); // 输出 p 指向的结点的数据 p = p-\u0026gt;next; //使 p 指向下一结点 }while(p != NULL); //输出完 c 结点后 p 的值为 NULL system(\u0026#34;pause\u0026#34;); } 内存分配函数 malloc 函数 1 void *malloc(unsigned int size); 作用是在内存的动态存储区中分配一个长度为 size 的连接空间。些函数的值（即返回值）是一个指向分配空间起始地址的指针（基类型为 void）。如果些函数未能成功地执行（例如内存空间不足）则返回空指针 NULL。\ncalloc 函数 1 void *calloc(unsigned n, unsigned size); 其作用是在内存的动态区存储中分配 n 个长度为 size 的连续空间。函数返回一个指向分配空间起始地址的指针，如果分配不成功，返回 NULL。 用 calloc 函数可以为一维数组开辟动态存储空间， n 为数组元素个数，每个元素长度为 size。\nfree 函数 1 void free(void *p); 其作用是释放由 p 指向的内存区，使这部分内存区能被其它变量使用， p 是最后一次调用 calloc 或 malloc 函数时返回的值。free 函数无返回值。请注意：以前的C版本提供的 malloc 和 calloc 函数得到的是指向字符型数据的指针。ANSI C 提供的 malloc 和 calloc 函数规定为 void * 类型。\n动态链表的实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #define NULL 0 #define LEN sizeof(struct student) struct student { long num; float score; struct student *next; }; struct student *create() { struct student *p1, *p2, *head; int num; float score; int n = 0; head = NULL; p1 = p2 = (struct student *)malloc(LEN); printf(\u0026#34;please input num and score.\\n\u0026#34;); scanf(\u0026#34;%d,%f\u0026#34;, \u0026amp;p1-\u0026gt;num, \u0026amp;p1-\u0026gt;score); while(p1-\u0026gt;num != 0) { n ++; if(n == 1) head = p1; else p2-\u0026gt;next = p1; p2 = p1; p1 = (struct student *)malloc(sizeof(struct student)); printf(\u0026#34;please input num and score.\\n\u0026#34;); scanf(\u0026#34;%d,%f\u0026#34;, \u0026amp;p1-\u0026gt;num, \u0026amp;p1-\u0026gt;score); } p2-\u0026gt;next = NULL; return head; } void printlist(struct student *head) { struct student *p; p = head; if(head != NULL) { do { printf(\u0026#34;num=%d score=%f\\n\u0026#34;, p-\u0026gt;num, p-\u0026gt;score); p = p-\u0026gt;next; }while(p != NULL); } } void main() { struct student *head; head = create(); printlist(head); system(\u0026#34;pause\u0026#34;); } // 打印链表 void printlist(struct student *head) { struct student *p; p = head; if(head != NULL) { do { printf(\u0026#34;num=%d score=%5.2f\\n\u0026#34;, p-\u0026gt;num, p-\u0026gt;score); p = p-\u0026gt;next; } while (p != NULL); } /* while(p -\u0026gt; next != NULL) { printf(\u0026#34;num=%d score=%f\\n\u0026#34;, p-\u0026gt;num, p-\u0026gt;score); p = p-\u0026gt;next; }*/ } // 删除节点 struct student *delNode(struct student *head, int num) { printf(\u0026#34;delNode.\\n\u0026#34;); struct student *p1, *p2; if(head == NULL) { printf(\u0026#34;The List is NULL.\\n\u0026#34;); } else { p1 = head; while(p1-\u0026gt;next != NULL \u0026amp;\u0026amp; p1-\u0026gt;num != num) { p2 = p1; p1 = p1-\u0026gt;next; } if(p1-\u0026gt;num == num) { if(p1 == head) head = p1-\u0026gt;next; else p2-\u0026gt;next = p1-\u0026gt;next; } else printf(\u0026#34;Can not find list num.\\n\u0026#34;); } return head; } // 更新节点 struct student *update(struct student *head, int index, int num, float score) { printf(\u0026#34;update.\\n\u0026#34;); struct student *p; if(head == NULL) { printf(\u0026#34;The List is NULL.\\n\u0026#34;); } else { p = head; while(p-\u0026gt;next != NULL \u0026amp;\u0026amp; p-\u0026gt;num != index) { p = p-\u0026gt;next; } if(p-\u0026gt;num == index) { p-\u0026gt;num = num; p-\u0026gt;score = score; } else printf(\u0026#34;Can not find list index.\\n\u0026#34;); } return head; } // 增加节点 struct student *add(struct student *head, int index, int num, float score) { printf(\u0026#34;add.\\n\u0026#34;); struct student *p1, *p2, *p3; if(head == NULL) { printf(\u0026#34;The List is NULL.\\n\u0026#34;); } else { p1 = p2 = head; while(p1-\u0026gt;next != NULL \u0026amp;\u0026amp; p1-\u0026gt;num != index) { p1 = p1-\u0026gt;next; p2 = p1; } if(p1-\u0026gt;num == index) { p3 = (struct student *)malloc(LEN); p3-\u0026gt;num = num; p3-\u0026gt;score = score; if(p2-\u0026gt;next == NULL) { p2-\u0026gt;next = p3; p3-\u0026gt;next = NULL; } else { p3-\u0026gt;next = p2-\u0026gt;next; p2-\u0026gt;next = p3; } } else printf(\u0026#34;Can not find list index.\\n\u0026#34;); } return head; } ","date":"2021-11-17T12:00:49+08:00","permalink":"https://blog.yexca.net/archives/15/","title":"数据结构 链表代码"},{"content":" 该文章由 Hiyoung 编写\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 //数组栈的实现 #include\u0026lt;stdio.h\u0026gt; #define MaxSize 50 typedef struct Stack_Array{ int data[MaxSize]; int top; }Sqstack,*pSqstack; void Initstack(); //初始化 int Isempty(); //判断栈空 int Push(); //入栈 int Pop(); //出栈 int Gettop(); //get 栈顶元素 int main(void) //测试 { int val; Sqstack s1; pSqstack ps1=\u0026amp;s1; Initstack(\u0026amp;s1); //初始化 if(Isempty(\u0026amp;s1)) //判断栈空 printf(\u0026#34;栈为空！\\n\u0026#34;); else printf(\u0026#34;栈不为空！\\n\u0026#34;); printf(\u0026#34;输入压栈元素的值\u0026#34;); //压栈 1 scanf(\u0026#34;%d\u0026#34;,\u0026amp;val); Push (ps1,\u0026amp;val); printf(\u0026#34;输入压栈元素的值\u0026#34;); //压栈 2 scanf(\u0026#34;%d\u0026#34;,\u0026amp;val); Push (ps1,\u0026amp;val); if(Isempty(ps1)) //判断栈空 printf(\u0026#34;栈为空！\\n\u0026#34;); else printf(\u0026#34;栈不为空！\\n\u0026#34;); if(Gettop(ps1,\u0026amp;val)) //GET栈顶元素 printf(\u0026#34;栈顶值为%d\\n\u0026#34;,val); else printf(\u0026#34;栈顶元素查找失败！\\n\u0026#34;); if(Pop(ps1,\u0026amp;val)) //出栈 printf(\u0026#34;出栈成功，出栈元素为%d\\n\u0026#34;,val); else printf(\u0026#34;出栈失败！\\n\u0026#34;); return 0; } //初始化 void Initstack (pSqstack ps1) { ps1-\u0026gt;top=-1; return; } //判断栈空 int Isempty(pSqstack ps1) { if(ps1-\u0026gt;top==-1) return 1; else return 0; } //若栈不满，则进行压栈 int Push(pSqstack ps1,int *val)//*val:接受一个地址(int *(\u0026amp;val)) { if(ps1-\u0026gt;top==MaxSize) return 0; else { ps1-\u0026gt;top++; ps1-\u0026gt;data[ps1-\u0026gt;top]=*val;//这里传递的是值，这里的*val是*(\u0026amp;val),\u0026amp;val是由主调函数输入 //也可写作ps1-\u0026gt;data[++ps1-\u0026gt;top]=*val; 一定是++ps1-\u0026gt;top return 1; } } //若栈不空，则进行出栈，用val返回栈顶元素 int\tPop(pSqstack ps1,int *val) { if(Isempty(ps1)) return 0; else { *val=ps1-\u0026gt;data[ps1-\u0026gt;top--]; return 1; } } //get栈顶元素，用val返回栈顶元素 int Gettop(pSqstack ps1,int *val) { if(Isempty(ps1)) return 0; else { *val=ps1-\u0026gt;data[ps1-\u0026gt;top]; return 1; } } 图解简化\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 //栈的链式存储实现 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #define Stack_Init_Size 10 // 初始化栈的最大长度 #define StackIncrement 10 // 若栈最大空间不够时，需要增加的长度 typedef int ElemType; typedef int Status; typedef struct { ElemType *base; // 栈底指针 ElemType *top; // 栈顶指针 int stack_size; // 栈的最大长度 } SqStack; // 初始化栈 Status InitStack(SqStack *S) { // 分配初始空间 S-\u0026gt;base = (ElemType *) malloc(Stack_Init_Size * sizeof(ElemType)); if (!S-\u0026gt;base) { exit(0); } S-\u0026gt;top = S-\u0026gt;base; /// 栈顶与栈底相同 S-\u0026gt;stack_size = Stack_Init_Size; // 栈的最大长度等于初始长度 return 1; } // 判断栈是否为空，只需要判断栈顶指针与栈底指针是否相同即可 Status EmptyStack(SqStack *S) { return S-\u0026gt;base == S-\u0026gt;top; } // 获取栈的实际长度，栈顶减去栈底指针即为栈的长度 Status LengthStack(SqStack *S) { if (S-\u0026gt;top == S-\u0026gt;base) { return 0; } return (Status) (S-\u0026gt;top - S-\u0026gt;base); } // 获取栈顶的元素，参数e用来存放栈顶的元素 Status GetTopStack(SqStack *S, ElemType *e) { if (S-\u0026gt;top == S-\u0026gt;base) { return 0; } *e = *(S-\u0026gt;top - 1); return 1; } // 进栈，参数e是要进栈的元素 Status PushStack(SqStack *S, ElemType e) { // 若栈的最大长度不会够用时，重新开辟，增大长度 if (S-\u0026gt;top - S-\u0026gt;base \u0026gt;= S-\u0026gt;stack_size) { S-\u0026gt;base = (ElemType *)realloc(S-\u0026gt;base, (S-\u0026gt;stack_size + StackIncrement) * sizeof(ElemType)); if (!S-\u0026gt;base) { return 0; } // 栈顶指针为栈底指针加上栈之前的最大长度 S-\u0026gt;top = S-\u0026gt;base + S-\u0026gt;stack_size; // 栈当前的最大长度等于栈之前的最大长度与增加的长度之和 S-\u0026gt;stack_size += StackIncrement; } *S-\u0026gt;top++ = e; // 先赋值，后栈顶指针上移 return 1; } // 出栈，参数e用来存放出栈的元素 Status PopStack(SqStack *S, ElemType *e) { if (S-\u0026gt;base == S-\u0026gt;top) { return 0; } *e = *--S-\u0026gt;top; // 栈顶指针先下移，后赋值 return 1; } // 销毁栈，释放栈空间，栈顶栈底指针置为NULL，长度置为0 Status DestroyStack(SqStack *S) { free(S-\u0026gt;base); S-\u0026gt;base = S-\u0026gt;top = NULL; S-\u0026gt;stack_size = 0; return 1; } // 遍历栈，依次打印每个元素 Status StackTraverse(SqStack *S) { ElemType *p; if (S-\u0026gt;top == S-\u0026gt;base) { printf(\u0026#34;Stack is NULL.\\n\u0026#34;); return 0; } p = S-\u0026gt;top; // 由栈顶依次向下遍历 while (p \u0026gt; S-\u0026gt;base) { p--; printf(\u0026#34;%d \u0026#34;, *p); } printf(\u0026#34;\\n\u0026#34;); return 1; } int main() { SqStack q, *S; S = \u0026amp;q; int i, n, e; printf(\u0026#34;Creat a NULL Stack :\\n\u0026#34;); InitStack(S); printf(\u0026#34;input the length of the Stack :\\n\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (i = 1; i \u0026lt;= n; i++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;e); PushStack(S, e); } printf(\u0026#34;Is the stack NULL?\\n\u0026#34;); if (EmptyStack(S)) { printf(\u0026#34;Yes!\\n\u0026#34;); } else { printf(\u0026#34;No!\\n\u0026#34;); } printf(\u0026#34;The length of stack is %d.\\n\u0026#34;, LengthStack(S)); printf(\u0026#34;The stack is :\\n\u0026#34;); StackTraverse(S); e = GetTopStack(S, \u0026amp;e); printf(\u0026#34;The top data is %d.\\n\u0026#34;, e); printf(\u0026#34;input the data to the stack :\\n\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;e); PushStack(S, e); printf(\u0026#34;The new stack is :\\n\u0026#34;); StackTraverse(S); printf(\u0026#34;Delete the top data : \u0026#34;); e = PopStack(S, \u0026amp;e); printf(\u0026#34;%d\\n\u0026#34;, e); printf(\u0026#34;The new stack is :\\n\u0026#34;); StackTraverse(S); printf(\u0026#34;Destroy the stack :\\n\u0026#34;); DestroyStack(S); StackTraverse(S); return 0; } ","date":"2021-11-11T23:03:27+08:00","permalink":"https://blog.yexca.net/archives/14/","title":"C 数据结构代码"},{"content":" 该文章由 ctxbb 编写\n","date":"2021-11-11T18:01:33+08:00","permalink":"https://blog.yexca.net/archives/13/","title":"扬州杏雨后"},{"content":"虽然米忽悠的米游社提供了原神树脂的查看，但是使用电脑时每次查看还要打开手机然后打开米游社着实有亿点不方便\n原作者文章： 自己做了一个树脂记录软件 原文软件链接： 提取码：1w5b 下载完成后打开，会提示输入 uid 和 cookie，下面是如何抓取米游社的 cookie\n首先打开 米游社 并登录\n然后按 F12 打开开发者工具，这时刷新网页\n然后点击“网络-ys/”，找到请求标头，然后在 cookie 右击复制\n注意：需要的 cookie 字段为 account_id=xxx; cookie_token=xxx，请自行修改\n**2022-6-6 修改 ( hiyoung )**\n由于米哈游修改了 bbs 可以获取的 Cookie，导致一次获取的 Cookie 缺失，所以需要增加步骤\n按下键盘上的 F12 或右键检查,打开开发者工具,点击 Console\n输入\n1 var cookie=document.cookie;var ask=confirm(\u0026#39;Cookie:\u0026#39;+cookie+\u0026#39;\\n\\nDo you want to copy the cookie to the clipboard?\u0026#39;);if(ask==true){copy(cookie);msg=cookie}else{msg=\u0026#39;Cancel\u0026#39;} 回车执行，并在确认无误后点击确定。此时 Cookie 已经复制到你的粘贴板上了\n注意：请使用 Chrome，Edge 获取也是不完整的 ( yexca )\n","date":"2021-11-10T15:21:30+08:00","permalink":"https://blog.yexca.net/archives/12/","title":"原神树脂查看与推送"},{"content":"首先我们找到要下载的视频 (废话)，复制图中框选部分的链接\n然后打开 视频下载解析网站 ，输入复制的链接然后点击解析视频图片 (如需验证根据网站提示进行即可)\n然后点击下载视频即可\n// 这篇好水\n","date":"2021-11-10T11:29:51+08:00","permalink":"https://blog.yexca.net/archives/11/","title":"微博视频下载"},{"content":"多数情况下，我们浏览网页一般使用浏览器或系统自带的返回，但有些系统的交互逻辑及其不好用，这时在网页添加一个返回上一页按钮可以极大改善浏览体验\n首先，在 WordPress 的后台点击“外观-自定义”来到可视化编辑页面\n在左方找到“额外CSS”选项（一般在最后）\n然后在里面输入下方代码\n1 2 3 4 5 6 7 8 .float-button { position: fixed; height: 90px; width: 40px; bottom: 90px; right: 50px; /* 可以自己修改相关描述 */ } 输入完成后保存，然后编辑主题相关界面\n如果您不能访问服务器文件，可以在 WordPress 后台的“外观-主题编辑器”中找到要添加的界面修改\n如果您可以访问服务器文件，可以打开路径 网站根目录/wp-content/themes/\u0026lt;您的主题名\u0026gt;/ 然后打开相应页面修改\n只需在相关页面文件插入下面代码并保存即可\n1 2 3 4 \u0026lt;div class=\u0026#34;float-button\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; name=\u0026#34;Submit\u0026#34; value=\u0026#34;返回\u0026#34; onclick=\u0026#34;javascript:history.back(-1);\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- 可以自己修改相关描述 --\u0026gt; 参考文章 网页上的“返回上一页”的几种实现代码 div 套路之悬浮的 button ","date":"2021-11-10T11:06:27+08:00","permalink":"https://blog.yexca.net/archives/10/","title":"WordPress 添加返回上一页按钮"},{"content":" 该文章由 Hiyoung 编写\n准备条件：win11 专业版及以上，将系统地区调至美国\n在设置-\u0026gt;应用 -\u0026gt; 可选功能 -\u0026gt; 更多Windows功能中勾选虚拟机平台，然后重启系统即可\n然后下载安装包，链接: https://pan.baidu.com/s/1215GlKeDCHcbE0I2SgtWLg 提取码: frkx\n下载完成后我们可以看到下面两个文件：倒数第二个是安卓子系统安装包，倒数第一个是WSA工具箱用于安装 apk 文件\n最下面两个文件\n现在我们以管理员身份打开 Windows power shell\n执行指令：add-appxpackage 空格 + 安卓子系统的文件路径（切记指令与路径之间加一个空格）\n!Win11android_4 出现上面这个即说明安装成功\n然后在开始菜单即可看到安装完成的安卓子系统，点击运行，勾选上开发者模式\n解压另一个 zip 文件运行，即可安装 apk 文件\n至此即安装完成\n**********以下内容由 yexca 添加**********\n如果工具箱无法安装或出现下图情况，请打开子系统设置，打开第一个选项“文件”，再打开工具箱即可 获取文件路径 在文件上鼠标右击选择“属性-安全”，第一行对象名称即为文件路径\nWSA 工具箱 原发布地址 ","date":"2021-11-09T23:45:42+08:00","permalink":"https://blog.yexca.net/archives/9/","title":"Win11 官方安卓子系统安装"},{"content":" 该文章由 Hiyoung 编写\n1.SQL ORDER BY 关键字 ORDER BY 关键字用于对结果集按照一个列或者多个列进行排序。\nORDER BY 关键字默认按照升序对记录进行排序。如果需要按照降序对记录进行排序，您可以使用 DESC 关键字\nSQL ORDER BY 语法 1 2 3 SELECT *column\\_name*,*column\\_name* FROM *table\\_name* ORDER BY *column\\_name*1,*column\\_name*2 ASC|DESC; –ASC 表示升序，DESC 表示降序\n–使用 order by 语句时应放在所有语句的最后使用，并且排序多个列时先排 column\\_name1 再 column\\_name2…\n2.删除所有数据（delete 和 drop table） 您可以在不删除表的情况下，删除表中所有的行。这意味着表结构、属性、索引将保持不变：DELETE FROM table\\_name;\n或\nDELETE * FROM table\\_name;\n**注释：**在删除记录时要格外小心！因为您不能重来！\nDROP TABLE 语句 DROP TABLE 语句用于删除表。DROP TABLE table\\_name\n**注释：**与 delete 不同的是 drop table 会删除表数据和结果，也是不可逆的！\nDROP DATABASE 语句 DROP DATABASE 语句用于删除数据库。DROP DATABASE database\\_name\nTRUNCATE TABLE 语句 如果我们仅仅需要删除表内的数据，但并不删除表本身，那么我们该如何做呢？\n请使用 TRUNCATE TABLE 语句：TRUNCATE TABLE table\\_name\n3.SQL JOIN SQL join 用于把来自两个或多个表的行结合起来。\n下图展示了 LEFT JOIN、RIGHT JOIN、INNER JOIN、OUTER JOIN 相关的 7 种用法。\nINNER JOIN：如果表中有至少一个匹配，则返回行 (INNER JOIN 与 JOIN 是相同的) LEFT JOIN：即使右表中没有匹配，也从左表返回所有的行 RIGHT JOIN：即使左表中没有匹配，也从右表返回所有的行 FULL JOIN：只要其中一个表中存在匹配，则返回行 注释：SQL 中的 join 语句其实对应数据库理论中的连接概念，left join、right join 和 inner join 对应自然连接，full join 对应笛卡尔积\n4.SQL 约束 (Constraints) 1 2 3 4 5 6 7 CREATE TABLE table_name ( column_name1 data_type(size) constraint_name, column_name2 data_type(size) constraint_name, column_name3 data_type(size) constraint_name, .... ); NOT NULL – 指示某列不能存储 NULL 值。 UNIQUE – 保证某列的每行必须有唯一的值。（一个表可以有多个UNIQUE约束但只能有一个 primary key，primary key 自动包含 unique 约束） PRIMARY KEY – NOT NULL 和 UNIQUE 的结合。确保某列（或两个列多个列的结合）有唯一标识，有助于更容易更快速地找到表中的一个特定的记录。（主键） FOREIGN KEY – 保证一个表中的数据匹配另一个表中的值的参照完整性。（外键） CHECK – 保证列中的值符合指定的条件。 DEFAULT – 规定没有给列赋值时的默认值。 5.AUTO INCREMENT 字段 我们通常希望在每次插入新记录时，自动地创建主键字段的值。\n我们可以在表中创建一个 auto-increment 字段。\n下面的 SQL 语句把 “Persons” 表中的 “ID” 列定义为 auto-increment 主键字段：CREATE TABLE Persons\n1 2 3 4 5 6 7 ( ID int IDENTITY(1,1) PRIMARY KEY, LastName varchar(255) NOT NULL, FirstName varchar(255), Address varchar(255), City varchar(255) ) 在上面的实例中，IDENTITY 的开始值是 1，每条新记录递增 1。\n**提示：**要规定 “ID” 列以 10 起始且递增 5，请把 identity 改为 IDENTITY(10,5)。\n要在 “Persons” 表中插入新记录，我们不必为 “ID” 列规定值（会自动添加一个唯一的值）：\n1 2 INSERT INTO Persons (FirstName,LastName) VALUES (\u0026#39;Lars\u0026#39;,\u0026#39;Monsen\u0026#39;) 上面的 SQL 语句会在 “Persons” 表中插入一条新记录。”ID” 列会被赋予一个唯一的值。”FirstName” 列会被设置为 “Lars”，”LastName” 列会被设置为 “Monsen”。\n6.触发器 参见： SqlServer 基础之(触发器) – wangchuang2017 – 博客园 ","date":"2021-11-08T11:51:18+08:00","permalink":"https://blog.yexca.net/archives/8/","title":"SQL 语句的一些语法细节 (SQL SERVER 语句)"},{"content":" 该文章由 Hiyoung 编写\n在安装完 SQL server 和 navicat 后在 navicat 中添加数据库：\n1.连接名无要求，按照自己需要命名\n2.打开安装好的 SQL server 配置管理器\n注意 SQL Server（SQLEXPRESS）要保证在运行中，否则 navicat 无法连接\n双击打开后点击服务，可以看到自己的主机名\n3.此时打开 navicat 在主机的地方填上：主机名 \\SQLEXPRESS (格式)\n4.用户名填 sa (为安装 SQL server 时的默认用户名，具体 SQL server 网上教程很多可以自己参考) ，密码是自己设置的 (同样在 SQL server 安装时设置的密码)\n5.测试连接成功即可使用\n注：仅个人在安装过程中遇到的问题，具体安装教程请参考网络\n附上 navicat 15 及注册机： https://pan.baidu.com/s/1cJ1EZ9Gyz6Jp6J03VqcDHA 提取码：3n7g\n","date":"2021-11-07T23:41:46+08:00","permalink":"https://blog.yexca.net/archives/7/","title":"关于在使用 Navicat 连接 SQL server 的一些问题"},{"content":" 该文章由 Hiyoung 编写\n其文章: https://blog.hiyoung.icu/2022/12/15/997871bc263d/ VSC只是一个纯文本编辑器，不是 IDE (集成开发环境)，不含编译器和许多其它功能，所以编译器要自己装好\n第一步：在 vscode 官网下载软件，链接： Visual Studio Code – Code Editing. Redefined 第二步：我们需要下载一个编译器，C 语言使用 gcc，链接： MinGW-w64 – for 32 and 64 bit Windows download | SourceForge.net ，选最新版本中的 x86\\_64-posix-seh 即可，网站下载可能较慢，下面给出百度网盘链接\n（以下附上百度网盘秒传链接：b48357234368d9ba439fc0db6e86531d#84cbf1dc60abe4fff77d035540ea3132#140697937#mingw64.zip）\n（正常百度网盘链接：链接: https://pan.baidu.com/s/17FYT\\_Y-s-I2yajFc2MICqw 提取码: ewis ）\n第三步：将 E:\\mingw64\\bin 添加到系统变量中（盘符根据自己编译器安装的位置）\n以 Win11 为例：打开设置-\u0026gt;系统-\u0026gt;关于-\u0026gt;高级系统设置-\u0026gt;环境变量-\u0026gt;系统变量-\u0026gt;点击Path-\u0026gt;编辑 -\u0026gt; 浏览 -\u0026gt; 把对应文件加入即可\n第四步：\n按 Win+R，运行 cmd（不要跳这一步），输入 gcc，应该会提示 no input files 而不是“不是内部命令或外部命令”或者“无法将“gcc” 项识别为 cmdlet、函数、脚本文件或可运行程序的名称”。如果是“不是内部命令或外部命令”，说明 gcc 在的文件夹没有在环境变量的Path中，要加进去才行。如果加了还是这样，重启（不要忘记重启）。如果重启了还不行，那就是你自己进行的操作有问题。\n输 gcc -v 可以显示出 gcc 的版本。如果显示出来的版本与你刚下的不同/更老，说明 Path 里原本有老版本的编译器，可能是安装其它 IDE 时装上的。则需要去掉 Path 里原来的那一个 gcc 的路径。\n这两项验证一定要符合，否则必须修改环境变量。小心别错删了。\n第五步：现在打开 vscode，下载相关插件\n第六步：我们需要写两个 json 文件，下面依次是 launch.json 和tasks.json（两个文件名也必须是 launch.json 和 tasks.json ） 注意看代码注释，两个文件都有几处地方需要将路径改为自己编译器的路径\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 { // 使用 IntelliSense 了解相关属性。 // 悬停以查看现有属性的描述。 // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387 \u0026#34;version\u0026#34;: \u0026#34;0.2.0\u0026#34;, \u0026#34;configurations\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;gcc.exe - 生成和调试活动文件\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;cppdbg\u0026#34;, \u0026#34;request\u0026#34;: \u0026#34;launch\u0026#34;, \u0026#34;program\u0026#34;: \u0026#34;${fileDirname}\\\\bin\\\\${fileBasenameNoExtension}.exe\u0026#34;,//这里意思生成的二进制代码会放入当前文件的bin文件夹中，我们需要自己新建一个bin文件夹 \u0026#34;args\u0026#34;: [], \u0026#34;stopAtEntry\u0026#34;: false, \u0026#34;cwd\u0026#34;: \u0026#34;${fileDirname}\u0026#34;, \u0026#34;environment\u0026#34;: [], \u0026#34;externalConsole\u0026#34;: false, \u0026#34;MIMode\u0026#34;: \u0026#34;gdb\u0026#34;, \u0026#34;miDebuggerPath\u0026#34;: \u0026#34;E:\\\\mingw64\\\\bin\\\\gdb.exe\u0026#34;, \u0026#34;setupCommands\u0026#34;: [ { \u0026#34;description\u0026#34;: \u0026#34;为 gdb 启用整齐打印\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;-enable-pretty-printing\u0026#34;, \u0026#34;ignoreFailures\u0026#34;: true } ], \u0026#34;preLaunchTask\u0026#34;: \u0026#34;C/C++: gcc.exe 生成活动文件\u0026#34; } ] } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 { \u0026#34;tasks\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;cppbuild\u0026#34;, \u0026#34;label\u0026#34;: \u0026#34;C/C++: gcc.exe 生成活动文件\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;E:\\\\mingw64\\\\bin\\\\gcc.exe\u0026#34;,//改成自己的文件路径 \u0026#34;args\u0026#34;: [ /*\u0026#34;${fileDirname}\\\\*.c\u0026#34;, \u0026#34;-o\u0026#34;, \u0026#34;${fileDirname}\\\\bin\\\\${fileBasenameNoExtension}.exe\u0026#34;, \u0026#34;-g\u0026#34;//多文件编译*/ \u0026#34;-g\u0026#34;, \u0026#34;${file}\u0026#34;, \u0026#34;-o\u0026#34;, \u0026#34;${fileDirname}\\\\bin\\\\${fileBasenameNoExtension}.exe\u0026#34;//这里意思生成的二进制代码会放入当前文件的 bin 文件夹中，我们需要自己新建一个 bin 文件夹 ], \u0026#34;options\u0026#34;: { \u0026#34;cwd\u0026#34;: \u0026#34;${fileDirname}\u0026#34; }, \u0026#34;problemMatcher\u0026#34;: [ \u0026#34;$gcc\u0026#34; ], \u0026#34;group\u0026#34;: { \u0026#34;kind\u0026#34;: \u0026#34;build\u0026#34;, \u0026#34;isDefault\u0026#34;: true }, \u0026#34;presentation\u0026#34;: { \u0026#34;echo\u0026#34;: true, \u0026#34;reveal\u0026#34;: \u0026#34;always\u0026#34;, // 执行任务时是否跳转到终端面板，可以为 always，silent，never。具体参见 VSC 的文档 \u0026#34;focus\u0026#34;: true, // 设为 true 后可以使执行 task 时焦点聚集在终端，但对编译 C/C++ 来说，设为 true 没有意义 \u0026#34;panel\u0026#34;: \u0026#34;shared\u0026#34; // 不同的文件的编译信息共享一个终端面板 }, \u0026#34;detail\u0026#34;: \u0026#34;调试器生成的任务。\u0026#34; }, { \u0026#34;type\u0026#34;: \u0026#34;cppbuild\u0026#34;, \u0026#34;label\u0026#34;: \u0026#34;(多文件)gcc.exe - 生成和调试活动文件\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;E:\\\\mingw64\\\\bin\\\\gcc.exe\u0026#34;,//改成自己的文件路径 \u0026#34;args\u0026#34;: [ \u0026#34;${fileDirname}\\\\*.c\u0026#34;, \u0026#34;-o\u0026#34;, \u0026#34;${fileDirname}\\\\bin\\\\${fileBasenameNoExtension}.exe\u0026#34;,//这里意思生成的二进制代码会放入当前文件的 bin 文件夹中，我们需要自己新建一个 bin 文件夹 \u0026#34;-g\u0026#34; ], \u0026#34;options\u0026#34;: { \u0026#34;cwd\u0026#34;: \u0026#34;${fileDirname}\u0026#34; }, \u0026#34;problemMatcher\u0026#34;: [ \u0026#34;$gcc\u0026#34; ], \u0026#34;group\u0026#34;: { \u0026#34;kind\u0026#34;: \u0026#34;build\u0026#34;, \u0026#34;isDefault\u0026#34;: true }, \u0026#34;presentation\u0026#34;: { \u0026#34;echo\u0026#34;: true, \u0026#34;reveal\u0026#34;: \u0026#34;always\u0026#34;, // 执行任务时是否跳转到终端面板，可以为 always，silent，never。具体参见 VSC 的文档 \u0026#34;focus\u0026#34;: true, // 设为 true 后可以使执行 task 时焦点聚集在终端，但对编译 C/C++ 来说，设为 true 没有意义 \u0026#34;panel\u0026#34;: \u0026#34;shared\u0026#34; // 不同的文件的编译信息共享一个终端面板 }, \u0026#34;detail\u0026#34;: \u0026#34;调试器生成的任务。\u0026#34; } ], \u0026#34;version\u0026#34;: \u0026#34;2.0.0\u0026#34; } 至此设置工作基本结束，vscode 有许多好用的插件可以自己探索，未来也会在写一篇文章推荐一些好用的插件\n","date":"2021-11-07T23:32:26+08:00","permalink":"https://blog.yexca.net/archives/6/","title":"VsCode 配置 C 语言环境"},{"content":"正文 安装完成 VS Code 和 Python 并配置环境变量后\n打开 VS Code，进入拓展搜索并下载 Python\n在资源管理器新建一个 Python 源文件 (.py) 后，资源管理器会在.vscode 文件夹下生成 setting.json 文件（若没有自动生成可自己创建）\n打开 setting.json 文件，并替换为以下代码\n1 2 3 4 5 6 { \u0026#34;python.linting.flake8Enabled\u0026#34;: true, \u0026#34;python.linting.flake8Args\u0026#34;: [\u0026#34;--max-line-length=248\u0026#34;], \u0026#34;python.linting.pylintEnabled\u0026#34;: false } 此时回到python文件，VS Code右下会弹出警告，点击下载\n按 CTRL+SHIFT+P 键，输入 Python: Select Interpreter (即 Python：选择编译器)\n然后选择您下载的编译器即可\n如果 .vscode 文件夹下有 launch.json 文件，需要在该文件的 configurations 中加入以下代码\n1 2 3 4 5 6 7 { \u0026#34;name\u0026#34;: \u0026#34;Python: 当前文件\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;python\u0026#34;, \u0026#34;request\u0026#34;: \u0026#34;launch\u0026#34;, \u0026#34;program\u0026#34;: \u0026#34;${file}\u0026#34;, \u0026#34;console\u0026#34;: \u0026#34;integratedTerminal\u0026#34; } 参考文章 VsCode 配置 Python 环境小白教程 VSCode 配置 Python 教程 ","date":"2021-11-07T11:28:58+08:00","permalink":"https://blog.yexca.net/archives/5/","title":"VsCode 配置 Python 环境"},{"content":" 该文章由 Hiyoung 编写\nmailto：可以自动调用当前系统默认的邮件客户端，并自动填充收件人、抄送人、密送人、主题、内容。\n参数说明:\nmailto： 收件人，多个以;分隔\ncc： 抄送人，多个以;分隔\nbcc： 密送人，多个以;分隔\nsubject： 主题\nbody： 内容\n各参数间用\u0026amp;连接即可\n例如：\u0026lt;a mailto:***@***.com?subject=this is subject\u0026amp;body=this is body\u0026gt;…\u0026lt;a\u0026gt;\n注：在 elementor 中应在文本编辑器的超链接选项中直接填写 mailto:***@***.com?subject=this is subject\u0026amp;body=this is body 即可\n","date":"2021-11-06T17:05:36+08:00","permalink":"https://blog.yexca.net/archives/4/","title":"如何自动调用当前系统默认的邮件客户端"},{"content":"正文 首先到待嵌入的视频将鼠标移到分享按钮上（不用点击）\n然后移到嵌入代码并复制\n（本例代码如下）\n1 \u0026lt;iframe src=\u0026#34;//player.bilibili.com/player.html?aid=583631611\u0026amp;bvid=BV1Tz4y1X7Bg\u0026amp;cid=206708397\u0026amp;page=1\u0026#34; scrolling=\u0026#34;no\u0026#34; border=\u0026#34;0\u0026#34; frameborder=\u0026#34;no\u0026#34; framespacing=\u0026#34;0\u0026#34; allowfullscreen=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;/iframe\u0026gt; 我们需要这串代码中的“aid”和“cid”部分（即 aid=583631611 和 cid=206708397 ）\n然后将 aid 和 cid 填入下方代码的相应位置\n1 2 3 \u0026lt;div style=\u0026#34;position: relative; padding: 30% 45%;\u0026#34;\u0026gt; \u0026lt;iframe style=\u0026#34;position: absolute; width: 100%; height: 100%; left: 0; top: 0;\u0026#34; src=\u0026#34;https://player.bilibili.com/player.html?cid=206708397\u0026amp;aid=583631611\u0026amp;page=1\u0026amp;as_wide=1\u0026amp;high_quality=1\u0026amp;danmaku=0\u0026#34; frameborder=\u0026#34;no\u0026#34; scrolling=\u0026#34;no\u0026#34;\u0026gt;\u0026lt;/iframe\u0026gt; \u0026lt;/div\u0026gt; （以上代码中 aid 和 cid 已替换）\n在编写文章的过程若插入视频只需将区块设成“自定义 HTML”然后把替换好aid和cid的代码拷贝过去即可\n如下为示例视频\n参考文章 关于博客园内嵌入bilibili视频 ","date":"2021-11-06T16:43:20+08:00","permalink":"https://blog.yexca.net/archives/3/","title":"WordPress 嵌入 BiLiBiLi 视频说明"},{"content":"默认情况下，WordPress 允许作者​​查看您网站媒体库中的所有图像。允许作者查看媒体库中的所有文件。 他们还可以查看由管理员 ， 编辑或其他作者上传的图像。\n对于许多网站而言，这可能并不重要。 但是，如果您运行一个多作者网站 ，则可能需要更改它。\n首先，进入 网站根目录/wp-content/themes/您当前使用的主题名称/\n找到 functions.php 文件并编辑，在末尾插入如下代码即可\n1 2 3 4 5 6 7 8 9 10 11 12 // Limit media library access add_filter( \u0026#39;ajax_query_attachments_args\u0026#39;, \u0026#39;wpb_show_current_user_attachments\u0026#39; ); function wpb_show_current_user_attachments( $query ) { $user_id = get_current_user_id(); if ( $user_id \u0026amp;\u0026amp; !current_user_can(\u0026#39;activate_plugins\u0026#39;) \u0026amp;\u0026amp; !current_user_can(\u0026#39;edit_others_posts \u0026#39;) ) { $query[\u0026#39;author\u0026#39;] = $user_id; } return $query; } 参考文章 如何限制媒体库对 WordPress 中用户自己上传的内容的访问 ","date":"2021-11-06T14:31:04+08:00","permalink":"https://blog.yexca.net/archives/2/","title":"WordPress 限制用户访问媒体库"},{"content":"欢迎使用 WordPress。这是您的第一篇文章。编辑或删除它，然后开始写作吧！\n","date":"2021-11-06T14:15:19+08:00","permalink":"https://blog.yexca.net/archives/1/","title":"Hello World！"}]