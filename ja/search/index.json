[{"content":" 📢　この記事は ChatGPT によって翻訳されました　はじめに 毎日動画を見たり、ゲームをしたり、これらは当然「リラックス」だと思っていた。\n終わった後には精神が回復するはずだ、と。\nでも実際は、そんな生活を続けても空虚で疲れきっている感覚しか残らなかった。\n理論的には大した消耗をしていないのに、こんなに気力が湧かないのはやっぱりおかしい。\nポモドーロの中での違和感 前に目の疲れがひどかった時、目を守るためにポモドーロタイマーを使って勉強していた。\n最初は目的がはっきりしていて、休憩のたびに遠くを眺めたり、横になったりしていた。効果は確かにあった。\nでも使い続けるうちに、「休憩のときに娯楽もしたい」と思うようになった。\n長めの休憩時間に動画を見たり、音楽を聴いたり、ゲームをしたり。\nすると効率が落ち、ポモドーロがだんだん面倒に感じてきた。\n勉強は疲れるし（集中している時に強制的に休まされる）、遊んでいても全然休まらない。\n20分しかないと思うと、遊んでいても不安になるだけだった。\n娯楽：もうひとつの集中 改めて考えると、娯楽はリラックスではないのかもしれない。\n娯楽も勉強と同じく「集中」を必要とする行為だから。\nポモドーロの設計も、集中をコントロールして、そのあとに休息を入れる仕組みだ。\n本来の「休息」とは、心身をゆるめて、集中の回復にあてるもの。\n実際に頭を空っぽにして、散歩に出たり、公園を歩いたり、本屋をぶらついたりすると、動画やゲームよりずっとリラックスできた。\n体力は少し消耗するけど、娯楽や勉強が消費するのは、むしろ精神力なんだと思う。\n娯楽とリラックスの再定義 だから、娯楽の定義を改めた方がいい。\n娯楽は勉強の疲れを癒すものではなく、むしろ精神力を使う行為だ。\n精神力が不足しているときにそれを続ければ、回復どころかさらに削られる。\nそうなると娯楽は意味を失ってしまう。まるでバッテリー残量が少ないのに、高負荷アプリを動かしているスマホみたいに。\n一方で、リラックスや休息は違う。\nそれは心と体を全部ゆるめて、漂わせるような感覚だと思う。\n精神力が足りないときは、精神も体力もあまり使わないことがいい。\n例えば、掃除をしたり、あてもなく歩いたり、何も考えずに過ごすこと。\n学びと娯楽のあいまいな境界 では、学びと娯楽の違いはどこにあるのか？\n結局は「興味」に左右されると思う。\nどんなに集中が必要でも、興味があれば娯楽になり、興味がなければ学びになる。\n例えばゲームなら、興味があるときは「楽しいから遊ぶ」で済む。\nでも「学び」として捉えると、「目標を達成しなきゃ」「ここまでやらなきゃ」となる。\n映画の IP でも同じ。\n興味があればただ身を任せて楽しむだけで、純粋に感動する。\n学びの視点なら、細部を分析したり、背景を調べたり、世界観を補完したりする。\nもちろん、境界ははっきりしていない。多くの場合は主観次第だ。\nリラックス：精神力の本当の補給 目的を持つ行動はすべて集中を必要とする。\nだから「リラックス」だと思われる行為も、実は目的がつくとリラックスにならない。\nスーパーに買い出しに行く、本屋で本を買う、公園に「休みに行く」…すべて目的がある。\n目的がついた時点で、それはもうリラックスじゃない。\n頭が空っぽにならないから、精神力も回復しない。\nリラックスは「少しの体力消耗で精神力を補う」ものだと思う。\nもし体力さえもきつければ、ただ横になって休むのが一番いい。\n結局、本当の休息とは「軽いことをする」ことじゃなく、「何もしないことを自分に許す」ことなんだ。\nまとめ 学びは人を成長させる。\n娯楽は人を興奮させる。\nでも、本当のリラックスは人を回復させる。\n人生は追いかけや刺激だけじゃなくていい。\n本当に必要なのは、娯楽を増やすことじゃなく、「立ち止まること」を学ぶことかもしれない。\n","date":"2025-08-22T22:17:38+09:00","permalink":"https://blog.yexca.net/ja/archives/253/","title":"リラックスは娯楽じゃない：精神力の再定義"},{"content":" 📢　この記事は ChatGPT によって翻訳されました　序：漂うような学習感 英語力を少しでも上げたいと思い、特に重要ではないことに関してはなるべく英語を使うようにしている。例えばゲームや日常で使うアプリなどだ。 しかし実際に使ってみると、何も身についていないような、どこか漂っているような感覚になる。まるで経験したはずなのに、何も経験していないような気がするのだ。\nよく考えると、これは「翻訳」から「没入」への落差なのかもしれない。母語である中国語が介入すると、その経験は自分の言語や思考に結びつく。しかし完全に非母語の環境では、その経験は母語と結びつかない。普段は母語で考えているので、自然と非母語での思考過程は無視されてしまう。\n比喩：コントロールされた実行感 自分の実体験で言えば、完全に英語のゲーム環境では、簡単な単語でさえ何も理解できないように感じる。だが友人と一緒にプレイして中国語で会話すると、状況は一気に変わる。翻訳モードに切り替わり、急に楽になり、全く分からなかった混乱から少し掌握感が生まれるのだ。\nそしてそれは東京での生活を思い出させる。日本語で会話していても、心の中ではあまり実感がなく、あたかも事前に決められた指令を実行しているだけで「生きている」感覚がない。だからこそ、中国語の歌を聴くのが好きになった。街を歩いているときでも、「自分はまだ生きている」と感じられるからだ。\n矛盾：理論上の最適と現実の退縮 とはいえ、これこそが語学学習で理想とされる「母語を完全に切り離す」環境ではないだろうか。英語ゲームに完全に没入し、中国語の干渉が一切ない状況。理論的には最も効果的な学習法のはずだ。まさに Thinking in English の状態に近い。\nしかし、実際の感覚はまるで逆だ。知らない単語に出会うと、途端に「自分には何もできない、何も分からない」と感じる。その瞬間、自然と退いてしまい、結局は何もせずに終わる。結果として、英語力は全く伸びていないように感じ、むしろ自信を失っていく。\n反省：完璧な特異点の幻覚 これまでの学習経験を振り返ると、自分は「学んでいる」という感覚がほとんどなかったことに気づいた。多くの場合、直感や経験に頼って判断していたのだ。ゲームや日常生活では、言語以外にも動作や指示、環境など様々な情報がある。もしかすると、自分はそうした情報だけを頼りに次の行動を決めていて、それで「理解したつもり」になっていたのかもしれない。実際には言語自体が無視され、学習は成立していなかったのだ。\nでは、これまで（言語に限らず）自分はどう学んできたのか。思えば、常に「完璧なタイミング」を待っていた気がする。全てが「完璧」でなければ、努力する意味は全くないと自分に言い聞かせてきた。まるで 「収集は止まらないが、学習は始まらない」 という感じだ。\nこの心構えは感情面だけでなく、環境や教材の選び方にも表れている。ほとんど「幅優先探索アルゴリズム」のように、各段階で「最適解」を求めてからでなければ進めない。そうでなければ「無意味」だと感じ、無理に取り組んでも結果は出ない。\n生活：理性と感情のずれ これは生活そのものにも通じる。ある不快な出来事（事柄や物）に対して、短期と長期では全く違った態度になることが多い。短期的には心を乱すが、長期的には大して重要ではなくなるのだ。\n例えばある物。長期的には役立つかもしれないが、今は全く役に立たない。「将来必要になるかも」と思って持ち続けることで、不快さを抱えたまま過ごす。しかし結局、その物は使われないまま終わることもある。\n片付けにも同じことが言える。理性では片付けた方が良いと分かっているのに、感情的にはやる気が出ない。あるいは「完璧なタイミング」が来るのを待ち続ける。その結果、その瞬間が来るまで、思い出すたびにイライラする。\n結論：「正解」はなさそうだ では、効率的に学習や生活をする「答え」はあるのだろうか？\nたぶん……ないと思う。生活は理性的な決断と感情的な決断で満ちている。ある時期に特定の能力を伸ばそうと計画しても、未来は予測不能で、感情の状態も変わる。結果は期待以上になることもあれば、期待以下になることもある。\nただ、全く工夫ができないわけではない。新しい情報が一瞬で計画を覆すこともあるから、別の視点で自分を縛る方法もあるだろう。例えば時間を固定して、学習量は変動させる。あるいは学習量を最低限に決めて、時間は変動させる。\n延長：目的性と新鮮さ ここで、さらに一つ考えた。何かに「目的」が生じると、感情的には続けにくくなる。娯楽でさえそうだ。例えば「ストレス解消のために」ゲームをする時、逆に「本当に解消できているのか」と気にしてしまう。その意識自体がプレッシャーとなり、かえって疲れ、いわゆる「デジタルED」のような状態になる。\nだから「趣味は多い方がいい」と言われるのだろう。それは確かに良い解決策だと思う。状況に応じて、異なる方法でストレスを発散できる（興味が前提であることが大事）。そうすれば一つの手段に依存せずに済む。\nけれど、本質はもっと単純かもしれない。新しいものから生まれる「新鮮さ」こそが鍵なのだ。\n結語：「不可控」の未来 さて、この文章は一体何を書いたのだろうか。正直、自分でもよく分からない。おそらく混乱した思考の産物なのだろう。\nでも、これこそが答えなのかもしれない——生活の「不可控」を受け入れること。理性ですべてを構築しようとしても、結局……理性だけでは全てを説明できないのだ。\n「状態—行動理論」が言うように、すべての変数を把握してはじめて100%の結果を予測できる。しかし、私たちはどうやって生活の「すべての変数」を集められるのだろうか。\nたぶん、その「集められない」という事実こそが、生活の変数の一つなのだ。\n","date":"2025-08-18T18:27:12+09:00","permalink":"https://blog.yexca.net/ja/archives/252/","title":"漂う学び、ずれた生活"},{"content":" 音に感じてシリーズ 曲 翻訳 リンク 僕が死のうと思ったのは 略 https://blog.yexca.net/ja/archives/214 あくあ色ぱれっと 略 https://blog.yexca.net/ja/archives/219 恋の押し売り 略 https://blog.yexca.net/ja/archives/220 17さいのうた 略 https://blog.yexca.net/ja/archives/224 drop 恋に落ちた https://blog.yexca.net/ja/archives/230 生きるを選んだ私へ 略 https://blog.yexca.net/ja/archives/239 rainy lady 雨女 https://blog.yexca.net/ja/archives/249 恋しくなったら手を叩こう 略 この記事 まえがき 📢　この部分は ChatGPT によって翻訳されました。　声と曲の雰囲気、めちゃくちゃ合ってて最高。\u0026ldquo;せーのっ\u0026rdquo; から始まるあの感じ、ふわっとした青春っぽさが広がって、すごく爽やかで甘い雰囲気の曲だなって思った。\n新曲（2025.06.04リリース）だから、その日に通知が来て、聴いた瞬間「これ訳したい！」って思って、そこからずっとリピートしてた。ちょっと頑張って、なんとなく透明感のある感じに仕上げたつもり。なるべく自分の中で「ここ気持ちいいな」って思えるところを意識して、短めのフレーズに合わせて訳してみた。\nでもやっぱり新曲だから、「音に感じて」ってシリーズで言うと、正直そんなに深い感情まではないかも。昔から聴いてる曲ほどの共鳴はないかな。この曲はなんというか…Honey Lemon Soda みたいな、日常にちょっとだけ甘さをくれる、そんな存在。\n動画 歌詞 ある時の日常が\n寂しくなっちゃって\n朝が怖くなって\n今眠れないのかい\n大人になったらさ\n治ると思ってた\n自己肯定感が\n溶けてく毎日かい\n耳に張り付いた君の涙声\nこんなにつらいから\nこの夜だけは2人で歌いましょう\n甘いお砂糖に溶けるように\n回る空気にほら舞うように\n君と踊る 君と踊る\nウォーアイニー\n最後までさ\n浮かず空色付くまでに\nその言葉が灰になる前に\n君と歌う\nそれもそれでいいな\nせーのっ\n恋しくなったら手を叩こう\n明日の前笑顔で手を叩こう\n幸せの意味も知らんけど\n今日だけは笑顔で叩こう\n少しだけ深呼吸して\n君はまだ君で居られる\n生きてゆく意味も知らんけど\n恋しくなったら手を叩こう\nココロの空調が\n整えらんなくて\n頬を伝う音に\nふと戸惑っちゃったのかい\nなんにも知らないよ\nこの世の定理とか\n誰か偉い人が\n教えてくれたらね\n震えるつま先\n明日の前でさ\nなんとか踏ん張って\nこのまま夜を2人で歌いましょう\n甘いお砂糖に溶けるように\n回る空気にほら舞うように\n君と踊る 君と踊る\nウォーアイニー\n最後までさ\n浮かぶ空色付くまでに\nその言葉が灰になる前に\n君と歌う\nそれもそれでいいな\nせーのっ\n恋しくなったら手を叩こう\n明日の前笑顔で叩こう\n幸せの意味も知らんけど\n今日だけは笑顔で叩こう\n少しだけ深呼吸して\n君はまだ君で居られる\n生きてゆく意味も知らんけど\n恋しくなったら手を叩こう\n","date":"2025-06-07T01:09:19+09:00","permalink":"https://blog.yexca.net/ja/archives/250/","title":"音に感じて - 《恋しくなったら手を叩こう》"},{"content":" 📢　この部分は ChatGPT によって翻訳されました。　このシリーズの記事、正直「日本語学習」に役立つことはほとんどないし、検索にも引っかかる可能性あるから、シリーズ名を実態に合わせて変更することにしました。 まあ、なんというか……ほとんどは自分の音楽に対する感想メモって感じかな。歌詞の翻訳も、基本は自分が聴いて感じたままの解釈で書いてるので、原文とずれてるところもあると思います。\n音に感じてシリーズ 曲 翻訳 リンク 僕が死のうと思ったのは 略 https://blog.yexca.net/ja/archives/214 あくあ色ぱれっと 略 https://blog.yexca.net/ja/archives/219 恋の押し売り 略 https://blog.yexca.net/ja/archives/220 17さいのうた 略 https://blog.yexca.net/ja/archives/224 drop 恋に落ちた https://blog.yexca.net/ja/archives/230 生きるを選んだ私へ 略 https://blog.yexca.net/ja/archives/239 rainy lady 雨女 この記事 恋しくなったら手を叩こう 略 https://blog.yexca.net/ja/archives/250 まえがき 📢　この部分は ChatGPT によって翻訳されました。　この曲の感想は……なんていうか、実はこの曲と出会ったきっかけは、前に書いたこの記事でもう話してたりするんだよね → https://blog.yexca.net/ja/archives/243/ 。 初めて聴いたとき、特に冒頭のあの数行が、当時の自分の気持ちとぴったり重なってて、すごく印象に残ってる。\nもちろん、そう感じたのは最初のあの部分だけで、後半は当時の日本語力じゃあんまり聞き取れなかったし、正直今でも訳してて「？？？」ってなるとこ多い（ てか訳してもあんま分かんない ）。全体としては、なんだか無力感というか、「自分ってちっぽけだな」って思わせられるような感覚があった。 この世界にはすごい人がたくさんいて、みんなキラキラしてて……羨ましくて、でもちょっと悲しくなる感じ。\nたぶん、自分が普段からボーカルなしのエレクトロ系ばっか聴いてるせいで、歌を聴くときって、歌詞よりも主観でイメージを乗せて楽しむことが多いんだと思う。 現実でかわいい女の子を見かけたり、すごい人と出会ったときとか、よくこの曲の冒頭がふと頭に浮かんでくる。 それは、尊敬とか憧れとかに混じって、「でも自分は……」みたいな、ちょっと切ない気持ちも入り混じった、なんとも複雑な感情。\nあとから改めて歌詞を読んでみて……どう言えばいいんだろう、「恋愛」って要素を抜きにしても、未来へのモヤモヤとか不安みたいなのが読み取れる気がする。 もちろん完全に恋バナじゃないとは言い切れないけど、「好きなことをやりたいけど、うまく言い出せない」みたいな気持ちは、別に恋愛に限らないんじゃないかなって。\n2025.05.26 この曲、歌ってみた。冒頭以外はぜんぜんついていけなくて、メロディもよく分からずグダグダだったけど、まあ楽しかったからOK（笑） ちなみに《粛聖!!ロリ神レクイエム☆》の原動画見つけて、ついでに歌ってみたら……なんか知らんけど、めっちゃ気持ちよかった（doge）\n動画 歌詞 は～ぁ可愛いいなぁ\nめっちゃキラキラしててすごいなぁ\n素直でいいなぁ\n人気者ってホントすごいなぁ\n面白くっていいなぁ\n友達沢山いるしすごいなぁ\n勝手に目が追っちゃうなぁ\n君色に染まちゃってるみたいな\nちょうどいい距離にいるのかな\n居心地が良すぎて眠たいわ\n散々してたシミュレーション\nリハーサル通りいかないものね\nいつも曖昧なままのふたりの温度\n答えなんて何も聞きたくないわ\nどうかしてるかな\n今日も rainy lady\nまだ まだ まだ まだ 雨模様みたい\n切ない距離と 気まずいシチュエーション\n期待なんてほんの1ミリくらい\nあぁついてないなぁ 大きな雨粒\nあぁ流れていく\nあっ 突然バッタリ会ったり\n脳内 君ばっかりだったり\n笑ったり怒ったり泣いちゃったりも\nちゃっかりしちゃったり?\n本来ドンマイ sorry もー無理\nしっかりもうコリゴリ\n一回グッバイさっぱり\nバイバイした方がいいのかな\nどんな言葉が どんな魔法なら\nどんな恋なら君にまで届くかな\nヒトリゴトが捗る雨フリの日々に\n明るい話題もまるでウワノソラ\nどうかしてるよね\nいつも rainy lady\nてるてるぼうずも悲しそうにしてる\n途切れ途切れに降り続く雨から\n想定外の贈り物なんて\nそっと傘の中 また降り出した\nAh\n空の合間に見えた淡い晴れ模様\n答えてほしいけど聞きたくなくて\nなんて意気地なし いつだろう sunny day\n悲しいくらい天気雨\nそっと集めつづけた沢山の思いが\n無意識に淡々と溢れてきちゃう\n何でもないよ 君がいるなら\n雨女でいいや\n君がいるから oh\nOh, sunny boy\nRainy lady\n","date":"2025-05-20T23:44:07+09:00","permalink":"https://blog.yexca.net/ja/archives/249/","title":"音に感じて - 《rainy lady》"},{"content":" 📢　この記事は ChatGPT によって翻訳されました。また、このソフトウェアは中国語簡体字のみです。　元々はちょっとしたものを適当に書くつもりで、二三日で飽きる予定だった（いつも大体そう）。でもバグらずに動いてくれることで時間めっちゃ節約できたし、どんどん使いやすくなっていった。\nそうすると以前思ってた「SQLite 使えばよくない？」って発想がよみがえってきた。確かに、毎回 MySQL 起動するのはめんどすぎるって話。で、今回のバージョンが生まれたわけ。やっと DB サービス起動しなくても使えるようになった～ （やっと人間が使えるものになった）\n使用方法 項目地址: https://github.com/yexca/PixivDownloader-SQLite GUI は前バージョンと似てるから、 https://blog.yexca.net/archives/211/ を見ればわかる。\n設定について 使う前に設定が必要：\nrefresh token（Pixiv のログイン認証。参考: Pixiv OAuth Flow ） ダウンロード先（デフォルトは D:\\Downloads） ダウンロードの仕方 その後は以下のどちらかを入力すれば OK：\nイラストレーター ID、または 作品 ID（両方入れた場合はイラストレーター ID 優先） 「下载」ボタンを押せば、全作品をダウンロードして DB に記録してくれる（記録がない場合は全部、記録がある場合は未ダウンロードのやつだけ）。\nエラー処理 プログラムのエラー処理は基本的にクローリング関係だけやってる。エラーポップアップが出たら、以下の問題が考えられる：\nrefresh token が設定されてない、または無効 イラストレーターアカウントが存在しない 作品が存在しない エラーの内容は詳しく出してないから、この3点をチェックしてみて。\nそれ以外（ソフトごとクラッシュとか）のエラーは 程序根目录/logs/app_*-*-*.log にある最新ログを送ってもらえれば、こっちで見ます。\n連絡先：PixivDownloader#yexca.net（@ に変えてね）\n新機能：MySQL から SQLite へ 一番の変更点は、MySQL を自分で用意しなくていいってところ。軽量な SQLite に切り替えた。\nそれで DB 設定とか全部いらなくなって、Pixiv の認証トークンとかと一緒に設定ファイルにした。\nあと icon も入れた（ChatGPT に適当に描かせたやつ）。UI も少しだけ調整したけど、そんなに変えてない。\nコードも一応構造化し始めたけど、最後の方はまたグチャった。まあ、いつかまた書き直すかもね\n旧 MySQL データベースからの移行方法 まあ前バージョン使ってる人いないと思うけど、一応書いとく。\nDB 構造の違いで、直接 SELECT して INSERT 文として出力するのが一番楽。こんな感じ：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 SELECT ID, name, downloadedDate, lastDownloadID, url FROM pic WHERE platform = \u0026#39;pixiv\u0026#39;; ~~~ 出力は SQL の INSERT 文にしてね（Dataflare ってツールがその機能ある）。 そのあと、Python ファイルを用意して以下を入れる： ```python import sqlite3 conn = sqlite3.connect(\u0026#34;pixiv.db\u0026#34;) cursor = conn.cursor() cursor.execute(\u0026#39;\u0026#39;\u0026#39; Create Table If Not Exists pic ( ID TEXT PRIMARY KEY, name TEXT, downloadedDate TEXT, lastDownloadID TEXT, url TEXT ) \u0026#39;\u0026#39;\u0026#39;) conn.commit() cursor.execute(\u0026#34;\u0026#34;\u0026#34; INSERT INTO `pic` (`ID`, `name`, `downloadedDate`, `lastDownloadID`, `url`) VALUES (\u0026#39;123\u0026#39;, \u0026#39;name1\u0026#39;, \u0026#39;2024-06-08 00:00:00\u0026#39;, \u0026#39;1234\u0026#39;, \u0026#39;https://www.pixiv.net/users/123\u0026#39;), (\u0026#39;234\u0026#39;, \u0026#39;name2\u0026#39;, \u0026#39;2025-02-12 00:05:36\u0026#39;, \u0026#39;2345\u0026#39;, \u0026#39;https://www.pixiv.net/users/234\u0026#39;), (\u0026#39;345\u0026#39;, \u0026#39;name3\u0026#39;, \u0026#39;2025-01-11 17:26:17\u0026#39;, \u0026#39;3456\u0026#39;, \u0026#39;https://www.pixiv.net/users/345\u0026#39;); \u0026#34;\u0026#34;\u0026#34; ) conn.commit() cursor.execute(\u0026#34;\u0026#34;\u0026#34; Select * from pic \u0026#34;\u0026#34;\u0026#34; ) rows = cursor.fetchall() for row in rows: print(row) conn.close() cursor.execute の中身を自分のバックアップ SQL に差し替えて、例として3件残しておいた。\nその後、できた pixiv.db を 程序根目录/resources に置けば OK。\nちょっとした開発感想：「グチャグチャ」から「混乱の理解」へ そういえば今回の開発、前回コードがグチャグチャすぎたのが気になって手を入れようとしたんだけど、途中で「あ～そりゃ前回グチャるわ」って理解した😂\nむしろ今回の方がさらにグチャったまである。途中から「もうリファクタやめてコピペでいいか」ってなって、キャメルケースとスネークケースが混ざるカオスが爆誕した。もう触りたくない。はぁ。\nとはいえ、動いてるし、使えるならまぁいいか～\n","date":"2025-05-18T16:20:33+09:00","permalink":"https://blog.yexca.net/ja/archives/248/","title":"Pixiv ダウンローダー再構築記：グチャグチャから混乱の理解へ"},{"content":" 📢 この記事は ChatGPT によって翻訳されました はじめに 最近、自分が次に何をやるか、何を学ぶかって考えてる時に、やたら目に入ってきたのが「DevOps」って言葉。最初ちょっとググったら、載ってる技術スタックはだいたい知ってるやつばっかで、「あーこれは全栈エンジニアみたいなもんか」って思ってた（まぁ実際ちょっと似てる気もする）\nでも興味がなかったから放置してた（というより開発熱が冷めてた）\nんで最近、4ヶ月くらい寝転がってて「やば、さすがに動かなきゃ」ってなって、またこの言葉を思い出した。改めて調べてみると……いやこれ、巻き込み力すごくね？フロントエンドとバックエンド分けても人間は一緒だし、今度は開発と運用も分離してるのに人間はやっぱり一緒、みたいな\nただ思い返すと、GitHub Action で自動化できるって話を見た瞬間に、Jekyll の時代を思い出した。あの頃は自動デプロイあったんだよね。でも自分は他のブログから移行してきて、サブフォルダ分類のクセが抜けず、それが対応してなかったから深掘りしなかった。\nでも今こそ、その Hugo ブログで自動デプロイできるか試してみたくなったわけ。毎回コンテナから pull してアップロードするの地味にめんどくさいしね\nワークフロー ワークフローの作成は、Git リポジトリのルートにある .github/workflows/ フォルダに YAML ファイルを置く形で定義する。ファイル名は自由だけど、今回はデプロイだから deploy.yml にした。\n構成は大きく「名前」「トリガー」「ジョブ」の3つ。\n名前 ここは適当でいい。とりあえず名前つけるだけ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 name: Build and Deploy Hugo Blog ~~~ ### トリガー Action Workflow にはいろんなトリガーがあるけど、今回は記事追加したとき（Push）に動けばいいかなって感じ。 あと手動トリガーも入れておく。GitHub 側の設定ミスとかで再実行したいとき用。 ```yaml on: push: branches: - main workflow_dispatch: ジョブ ジョブは複数定義できて、それぞれ並行で動く。今回は一個だけ。\nまずジョブ名を決める。\n1 2 jobs: build-deploy: 次にどの OS 上で実行するかを指定。今回は Ubuntu。\n1 2 3 jobs: build-deploy: runs-on: ubuntu-latest そして具体的なステップ。まずリポジトリのチェックアウト。\n1 2 3 steps: - name: Checkout source uses: actions/checkout@v4 続いて Hugo のセットアップ。\n1 2 3 4 5 - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#39;0.140.1\u0026#39; extended: true Hugo サイトのビルド。\n1 2 - name: Build Hugo site run: hugo --minify 最後に GitHub Pages 用リポジトリに push。\n1 2 3 4 5 6 7 - name: Deploy to BlogWeb repo uses: peaceiris/actions-gh-pages@v3 with: external_repository: yexca/Blog-Web-Hugo publish_branch: main publish_dir: ./public personal_token: ${{ secrets.PERSONAL_TOKEN }} 全部まとめるとこんな感じ：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 name: Build and Deploy Hugo Blog on: push: branches: - main workflow_dispatch: jobs: build-deploy: runs-on: ubuntu-latest steps: - name: Checkout source uses: actions/checkout@v4 - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#39;0.140.1\u0026#39; extended: true - name: Build Hugo site run: hugo --minify - name: Deploy to blogWeb repo uses: peaceiris/actions-gh-pages@v3 with: external_repository: yexca/Blog-Web-Hugo publish_branch: main publish_dir: ./public personal_token: ${{ secrets.PERSONAL_TOKEN }} トークン設定 他のリポジトリに push するにはトークンが必要。作り方は：\nSettings -\u0026gt; Developer Settings -\u0026gt; Personal access tokens -\u0026gt; Fine-grained tokens に進んで、対象リポジトリに書き込みできるトークンを生成。\nそのあとソースリポジトリ（俺の場合は yexca/Blog-Source-Hugo）の Settings -\u0026gt; Secrets and variables -\u0026gt; Actions の Repository secrets に追加。名前はワークフローに書いた通り PERSONAL_TOKEN にする。\n独自ドメインの設定 GitHub Pages を独自ドメインで使うには CNAME ってファイルにドメインを書いておく必要がある。\nでも GitHub Actions でデプロイするとき、既存のファイルが全部削除されて push されるから CNAME も消える。だからワークフローでファイルを生成する必要がある。\n方法は2つ：\nワークフロー内で CNAME を作成： 1 2 3 steps: - name: Add CNAME run: echo \u0026#39;blog.yexca.net\u0026#39; \u0026gt; public/CNAME Hugo の static フォルダに CNAME を入れておく（ビルド後そのまま出力される） テーマモジュールの問題 使ってるテーマが Git SubModule 経由だったから、そのまま push してもリンクだけで中身がない。自分の変更は push されないってこと。\nテーマをバックアップ 1 cp -r themes/Hugo-Theme-Stack tmp/Hugo-Theme-Stack-Backup SubModule の削除 初期化：\n1 git submodule deinit -f themes/Hugo-Theme-Stack Git から削除：\n1 git rm -f themes/Hugo-Theme-Stack 関連フォルダを削除：\n1 rm -rf .git/modules/themes/Hugo-Theme-Stack .gitmodules ファイルも削除：\n1 rm .gitmodules テーマを復元 1 cp -r tmp/Hugo-Theme-Stack-Backup themes/Hugo-Theme-Stack テストして問題なければバックアップ削除：\n1 rm -rf tmp JS エラーの修正 昔書いたブログ稼働時間コードで、古い書き方の 8 進数を使ってたせいで、hugo -minify したときにエラーが出た。\n元のコード：\n1 Date.UTC(2021, 10, 06, 14, 15, 19) 修正後：\n1 Date.UTC(2021, 10, 6, 14, 15, 19) 結び やっとローカルでの構築作業から解放された。Docker を使い始めた頃から、ローカル環境と開発環境は分けたいって思うようになって、ずっとコンテナで作業してた。\nでも今回で完全にローカルどころかクラウドに全部任せるようになって、もはや “環境潔癖症” を克服したとも言えるかも。\nで、改めて DevOps って考えてみると、これも結局、技術の進化が進みすぎた結果なのかもしれない。\n昔は機械ごとに環境合わせて、アセンブリ書いて、それが高級言語になって、さらにコンテナで環境障壁が壊れて、どんどん簡単に効率良くなってきた。けど、そのたびに「入門ライン」も引き上がってんだよね。\n確かに便利になったけど、同時に「ついていけなきゃ職失うスピード」も速くなってるってわけ。\nまあでも、仕事は仕事、生活は生活。技術は早いけど、世界や業界の変化はそこまで速くない……はず。少しくらいは休む余裕もある、よね。\n","date":"2025-05-16T18:14:06+09:00","permalink":"https://blog.yexca.net/ja/archives/247/","title":"DevOps を取り入れて：ブログの構築とデプロイを GitHub に任せた話"},{"content":" 📢 この記事は ChatGPT によって翻訳されました はじまり また自己紹介のタイミングで、ふと思い出したのが自分のブログだった。\n昔は Google で yexca って検索すれば一発で一番上に出てきて、そこからすぐブログに飛べた。\nでもドメインを変更してからというもの、何度検索してもブログはどこにも見当たらなくなった。\n最初はそこまで気にしてなくて、Google の制限とかペナルティみたいなもんかなって思ってた。\n公式には、ドメインを変えるときは 301 リダイレクトを1年間続けるのが推奨されてて、でも俺は半年で旧ドメインの期限切れちゃったんだよね。\nでも、もう2年経ったよ？そろそろ戻ってきてもいいんじゃないの？\nしかもおかしいのは、検索上位に出てくるのは昔のメンテ止まったようなサイトばかりで、\n俺が毎日更新して、調整して、あれこれいじりまくってるこのブログはまるでネットから消えたかのようになってた。\nというわけで原因調査開始 まずはブログを開いて \u0026lt;head\u0026gt; をチェック。\nん？\u0026lt;meta name='description'\u0026gt; がサイドバーに出てくるキャッチコピーになってる？\nあー…そういや、設定のとき「ここに表示されるよ」ってだけ書いてあって、Argon テーマの時と同じようなもんだと思ってたわ。\nつまり、今のサイト説明は意味不明ってことか。\nとはいえ、この言葉は自分のブログ人生をずっと一緒に歩んできたし、簡単に手放したくない。\nだったら、構造化データ（JSON-LD）を使って、説明の役割をそっちに任せればいいじゃん！\nってことで、テーマの \u0026lt;head\u0026gt; カスタムに以下を追加：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 \u0026lt;script type=\u0026#34;application/ld+json\u0026#34;\u0026gt; { \u0026#34;@context\u0026#34;: \u0026#34;https://schema.org\u0026#34;, \u0026#34;@type\u0026#34;: \u0026#34;Blog\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;yexca\u0026#39;Blog\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;{{ .Site.BaseURL }}\u0026#34;, \u0026#34;inLanguage\u0026#34;: \u0026#34;{{ .Site.Language.Lang }}\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;{{ .Site.Params.description }}\u0026#34;, \u0026#34;author\u0026#34;: { \u0026#34;@type\u0026#34;: \u0026#34;Person\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;yexca\u0026#34; } } \u0026lt;/script\u0026gt; ~~~ しかもサイトは多言語対応だから、部分的に変数で言語ごとに適応できるようにした方が良いね。 ## 言語という迷宮での探索 多言語サイトってことで、じゃあ言語変えて検索してみたらどうなる？って気になって、 `google.com.hk`、`google.com.tw`、`google.com.jp` で `yexca` を検索してみた。 結果は、なんと日本語環境ではちゃんと出てきた。 でも中国語では出てこない。英語はまぁ記事が少ないから仕方ないか。 つまり Google 的には `https://blog.yexca.net` が `yexca` に紐づいてるのは認識してるっぽいけど、 言語ごとの評価とかがうまく機能してないのかも？ さらに調べていくと `hreflang` の指定が足りないんじゃ？と気づいて、こんな感じで追加： ```html \u0026lt;link rel=\u0026#34;alternate\u0026#34; hreflang=\u0026#34;x-default\u0026#34; href=\u0026#34;https://blog.yexca.net/\u0026#34; /\u0026gt; \u0026lt;link rel=\u0026#34;alternate\u0026#34; hreflang=\u0026#34;zh-CN\u0026#34; href=\u0026#34;https://blog.yexca.net/\u0026#34; /\u0026gt; \u0026lt;link rel=\u0026#34;alternate\u0026#34; hreflang=\u0026#34;zh-TW\u0026#34; href=\u0026#34;https://blog.yexca.net/zh-tw/\u0026#34; /\u0026gt; \u0026lt;link rel=\u0026#34;alternate\u0026#34; hreflang=\u0026#34;ja\u0026#34; href=\u0026#34;https://blog.yexca.net/ja/\u0026#34; /\u0026gt; \u0026lt;link rel=\u0026#34;alternate\u0026#34; hreflang=\u0026#34;en\u0026#34; href=\u0026#34;https://blog.yexca.net/en/\u0026#34; /\u0026gt; これで検索エンジンには「これは多言語対応の同一サイトです」って明確に伝わる。\nちなみに、この \u0026lt;link\u0026gt; はすべての記事ページにも入るようにした。 すべての言語に翻訳があるわけじゃないけど、Google 側がちゃんと処理してくれるからそのままでOK。\n少しずつ埋める抜け穴 で、試しにどれかの記事を開いたら、「あれ？JSON-LD がまだサイト情報になってるやん？」ってなった。 これはちょっと違和感あるなと思って、条件分岐を入れることにした：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 {{ if .IsHome }} \u0026lt;!-- ホーム JSON-LD --\u0026gt; \u0026lt;script type=\u0026#34;application/ld+json\u0026#34;\u0026gt; { \u0026#34;@context\u0026#34;: \u0026#34;https://schema.org\u0026#34;, \u0026#34;@type\u0026#34;: \u0026#34;Blog\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;yexca\u0026#39;Blog\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;{{ .Site.BaseURL }}\u0026#34;, \u0026#34;inLanguage\u0026#34;: \u0026#34;{{ .Site.Language.Lang }}\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;{{ .Site.Params.description }}\u0026#34;, \u0026#34;author\u0026#34;: { \u0026#34;@type\u0026#34;: \u0026#34;Person\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;yexca\u0026#34; } } \u0026lt;/script\u0026gt; {{ else if .IsPage }} \u0026lt;!-- 記事 JSON-LD --\u0026gt; \u0026lt;script type=\u0026#34;application/ld+json\u0026#34;\u0026gt; { \u0026#34;@context\u0026#34;: \u0026#34;https://schema.org\u0026#34;, \u0026#34;@type\u0026#34;: \u0026#34;BlogPosting\u0026#34;, \u0026#34;mainEntityOfPage\u0026#34;: { \u0026#34;@type\u0026#34;: \u0026#34;WebPage\u0026#34;, \u0026#34;@id\u0026#34;: \u0026#34;{{ .Permalink }}\u0026#34; }, \u0026#34;headline\u0026#34;: \u0026#34;{{ .Title }}\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;yexca\u0026#39;Blog\u0026#34;, \u0026#34;author\u0026#34;: { \u0026#34;@type\u0026#34;: \u0026#34;Person\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;yexca\u0026#34; }, \u0026#34;publisher\u0026#34;: { \u0026#34;@type\u0026#34;: \u0026#34;Person\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;yexca\u0026#39;Blog\u0026#34; }, \u0026#34;datePublished\u0026#34;: \u0026#34;{{ .Date.Format \u0026#34;2006-01-02\u0026#34; }}\u0026#34;, \u0026#34;dateModified\u0026#34;: \u0026#34;{{ .Lastmod.Format \u0026#34;2006-01-02\u0026#34; }}\u0026#34;, \u0026#34;inLanguage\u0026#34;: \u0026#34;{{ .Site.Language.Lang }}\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;{{ .Params.description | default .Site.Params.description }}\u0026#34; } \u0026lt;/script\u0026gt; {{ end }} これでホームと記事で異なる JSON-LD が表示されるようになって、\n意味的にも正しいし、Google の構造化データガイドラインにもより適合する。\n小さな願い これでようやく一通り整った。\nもちろん、すぐに結果が出るわけじゃないけど、\nでも、確かに「信号」は送り出されたはず。\nあとはただ、待つだけ。Google がもう一度、俺の存在を認識してくれるのを。\n次に誰かにブログを紹介する時には、\nGoogle を開いて、yexca って検索して、すっと出てくるように。\n","date":"2025-04-27T17:38:16+09:00","permalink":"https://blog.yexca.net/ja/archives/246/","title":"自分の名前で検索されるために：小さなブログの SEO 調査実践記"},{"content":" この記事の一部は機械翻訳を使ったよ\nみんながカード使ってるからって、全員が還元目的ってわけじゃない。システム作ってる人だって、全員がエンジニアなわけでもない。 たまにいるんだよね、カード切ってるのに設計者っぽいやつ。システム組んでるのに、生活感があるやつ。\n1. 導入：カードオタクって何？ まず最初に紹介したいのが、どこかで見た「カード勢の七大あるある」：\nここでの「中国本土」とは、資金の出入りに制限がある地域を指している\n中国本土で外貨を使う方法を探す 海外で人民元を使う方法を探す 人民元を国外に持ち出すルートを探す 外貨を中国本土に持ち込む方法を考える 本土でほとんど使えないカードをつくる 海外でさらに使えないカードをつくる 暗証番号の桁数より少ない金額を、ほとんど使い道のないカードの間でぐるぐる回す ※中国本土では銀行のパスワードが6桁で設定されることが多く、「暗証番号より桁が少ない＝金額すら届かないのに頑張って動かしてる」的な自虐ネタ。他地域では異なる可能性あり\n……ね？もうゲーム感覚。 パッと見は、ただカード増やして、ポイント狙って、手数料節約して、レート得する方法探してるだけ。 なんかちょっとセコい技集めみたいに見えるでしょ。\nでも、本気のカード勢ってそうじゃない。\nカードオタクってのは、「数円節約したい人」じゃなくて、複数通貨、複数経路、複数制限の中で最適な資金ルートを構築しようとしてる設計者なんだよね。\n羊毛狙いじゃない。現実世界の構造を掘り下げてるんだ。\n生活っていうシステムを、最適化しようとしてるんだよ。\n2. システムアーキテクトって何してる人？ システムアーキテクトの資格を取ろうとすると、よく出てくる用語がある。 たとえば「モジュールの分離」「パフォーマンス最適化」「インターフェース設計」…… でもね、用語は置いといて、やってることは意外とシンプル。\n制限だらけの現実の中で、リソースを上手く割り振って、ルートを引いて、システム同士をつないで、壊れにくくて柔軟な全体構造を作る\nアーキテクトが考えてるのって、「このコード綺麗に書けた！」とかじゃないし、ただ図を描くのが仕事でもない。 一番重要なのは、複雑な制約がある現実世界の中で、ちゃんと動くシステムになってるかどうか。\nたとえば：\nシステム間で役割をどう分ける？ サービス同士はどうやって通信する？ インターフェースってどう作れば、将来の拡張にも対応できる？ 不具合が起きたら、どうやって見つけて影響を最小限にする？ 予算が限られてるとき、どこまで性能とコストのバランスを取る？ アーキテクトって、レゴビルダーっぽくもあるし、道路設計者っぽくもあるし、バグだらけの街を修理してる職人みたいでもある。\n最初から綺麗な地図なんてない。バグってたり、壊れてたりする世界の中で、少しずつルートを整えて、橋を補強して、構造を変えて、流れをスムーズにしていく。\nつまりは、現実的な制約の中で、「ちゃんと動いて、あとから直せて、維持費が払える」システムを設計するってこと。 カッコいい技術を見せるんじゃない。「完璧な設計」を目指すんじゃない。 とにかく壊れずに回り続けること。壊れても止まらないこと。それがアーキテクトの美学なんだよ。\n自分はこの話、資格試験のために勉強したんだけど…… 気づけばまたカード遊びに夢中になってたんだ。\n3. カードオタクの「構造的課題」って？ ただの節約マニアだと思ってた？違う違う。 アーキテクトが「お堅いエンジニアの世界」に生きてるって思ってた？それも違う。\n一見バラバラに見えるけど、カードオタクもアーキテクトも、根っこは同じことをやってる：\nルールが複雑で、コスト制約があって、正解が見えない中で、最適なルートと構造を探す。\nカード勢はカードを作る人じゃなくて、「資金の流れを設計してる人」 システムアーキテクトはコード書く人じゃなくて、「情報と制御の流れを設計してる人」\nカード勢が悩むのは： 「どうやったら手数料減らせる？リスク管理回避できる？制限の中でうまく流せる？」\nアーキテクトが考えるのは： 「どうやったら障害少なく？拡張性高く？現場で安定して動かせる？」\n試験勉強で学んだアーキテクトの思考法、振り返ってみたら、 これ……カード組んでるときと全く同じじゃんって気づいたんだよね。\nカード世界 アーキテクト世界 コア思考 手数料 レイテンシや性能コスト コスト最適化 通信ルートの制限 APIコール制限 プロトコル適応力 カードの発行ルール モジュールの設計ルール 規格・コンプライアンス 為替や通貨制限 クロスプラットフォーム対応 環境適応性 カードの種類が多すぎる 技術スタックの多様性 システム統合設計 銀行の風当たり システムのセキュリティ リスク設計 カード間の資金移動経路 データフロー設計 経路・構造デザイン カードやってるのって、別に儲けたいとかじゃないんだよ。 やってること、ほぼ構造設計なんだよね。\n「どのカードが一番得か？」じゃなくて、 「どうやって一番効率よく、損せず、リスク回避しつつ、お金を流すか？」を考えてる。\nポイントは「できるか」じゃなくて、「美しく流れるか」。 送れるかどうかじゃなくて、「そのフローに無駄や詰まりがないか」。\nカード勢がやってるのは、ある意味「複雑制約付きの最短経路問題」解いてるみたいなもん。 アーキテクトが設計するのは、「モジュール間の結合度やSLA制限を考慮した構成の最適化」\nね？ほぼ一緒でしょ。場所が違うだけで、やってること変わらんのよ。\n4. 地図を塗るように構築する日常ルート 他人は還元狙い、自分は生態系を解き明かしてるつもり。\nカード勢のルートって、本当に人それぞれ。 使ってる銀行も、口座の種類も、持ってる通貨も、ライフスタイルすらバラバラ。\nだから面白いのは攻略サイトをなぞることじゃなくて、自分の条件下で、自分だけの最適解を試行錯誤で見つけること。\n最初はただ「手数料ちょっとでも減らせないかな～」くらいで始めたんだけど、調べれば調べるほど奥が深い。 銀行ごとに振込条件も違うし、時間帯によって無料だったり、特定通貨じゃないと跳ねられたり、なぜか理由もなく止められたり。\nまるで最初は真っ黒なマップのゲームみたいに、ちょっとずつルートを開拓して、通れる場所を増やして、チェックポイントをマークしていく感じ。\n小さな額で何回も試して、失敗して、やり直して……その繰り返しで、 自分にとって「コストが許容できる通り道」が見えてくる。\nやがて「高コストの地雷ルート」を避けながら、レートのタイミングすら読んで浮き分を狙ったり、 そのうち「この通貨経由すればもうちょい節約できるかも」ってルート最適化まで始まる。\n中には最初から「絶対無理でしょ」って思ってたルートも、 試してみたら意外と通ったりするんだよね。\nたとえば：\n暗号通貨を使って資金移動できる取引所を経由してみたり 実生活で仮想通貨をそのまま使ってみたり フィアット通貨→ステーブルコインの自動化ルートを組んだり マイナーな国向けに特化した送金アプリを使ってみたり こうして銀行システムを迂回して、無理だと思ってた送金もいつの間にか実現できてたりする。\nこれってまさに、ネットワークアーキテクチャを再設計する感覚。 単なる送金じゃない。\n「価値」と「情報」を運ぶルートを、自分で定義し直してるんだ。\n5. カードで鍛えられるアーキテクト的センス 日々のルート選び、失敗とリカバリ、コストの見直し、リスクの見積もり……カード勢が普段やってること、実はめっちゃアーキテクトの訓練っぽい。\nサーバーもコードも使ってないけど、「構造を安定させて効率を高める」っていう思考は、まんまシステム設計のそれ。\n気づかないうちに、こんなスキルが身についてた：\nスキル 実際の行動 アーキテクトっぽさ ルール把握 銀行ごとの上限・仕様を把握 ドキュメント読解力 統合力 複数カードの連携・連結 システム統合の視点 コスト意識 手数料を可能な限り削る 性能とコストのバランス設計 モデル構築力 資金フローをルートで見える化 構造モデリングのセンス リスク対策 複数口座・バックアップ経由の構成 高可用性・冗長構成の考え方 美意識 「お金も、スマートに流れるべき」 設計美学、エンジニアの美意識 カードで遊んでるように見えて、現実世界でアーキテクトの脳みそを鍛えてる……そんな日常ってちょっとカッコよくない？\n6. 思考が整った瞬間に気づいたこと 手数料は敵。ルートは信仰。そして流れは芸術。\nオレがカードにハマったのは、ポイントが欲しかったからじゃない。 何度も試して、計算して、構造を調整して……その中で「流れの美しさ」に気づいてしまったから。\nコードも書かないし、サーバーも持ってないけど、 1つ1つの資金移動、設計したルート──それ全部が、自分の中のアーキテクチャだった。\n試験のためにアーキテクトの知識を詰め込んで、 でも日常の中でカードを回してるときの方が、ずっとその感覚をリアルに感じてた。\n好きなのは「やり切ること」じゃなくて、「ルートを気持ちよく設計すること」なんだ。\n他人から見たら「小手先の裏技」、でも自分の中では「構造の美学」。 「ただのポイント厨」って言われても、心の中では「生活アーキテクト」やってる。\nカードオタクって、たぶん「節約術」とか「投資ノウハウ」じゃない。 これは日常の中で、自分のシステム思考を育てていくリアルな実験場なんだと思う。\n問題を可視化して、ちょっとずつ改善して、構造を組み替えて、美しく仕上げる。 それが楽しい。\nカードは節約じゃなくて訓練だし、アーキテクチャは発明じゃなくて選択なんだ。 「いくら得したか」でも「どれだけコード書いたか」でもない。大事なのは、世界のロジックを自分の中に落とし込んだかどうか。\nそして今日も、ATMの前で10分考え込む。 「こっち経由した方が手数料安いかも」って脳内シミュレーションしながら。\nたぶんオレ、サーバーは動かしてないけど、ちゃんと設計してる。\n結論：人生こそが、最強のアーキテクチャ カードを切る、送金する、ルートを考える、最適な組み合わせを選ぶ──その全部、じつは目に見えない「システム設計」なんだよね。\nアーキテクチャって、サーバーとかAPIだけじゃない。ときには、財布やカード、支払い方法の間にひっそりと潜んでる。\nカード最適化の果てにいるのは、羊毛ハンターじゃない。\n──そこにいるのは、たぶん「生活アーキテクト」だよ。\nおまけ：オレの資金ルート（コードで書いてみた） このコード、実行用じゃないよ。ただの日常資金フローを建築っぽく書いてみただけ。「オレ、こう考えて動かしてるよ」っていう思考モデル。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // 海外送金ルート（イメージ） func RouteCNYtoJPY(CNY float64) JPY float64 { HKD := BOCExchange(CNY, to=\u0026#34;HKD\u0026#34;) log.Printf(\u0026#34;Exchanged %.2f CNY to %.2f HKD\u0026#34;, CNY, HKD) Transfer(HKD, from=\u0026#34;BOC\u0026#34;, to=\u0026#34;BOCHK\u0026#34;, by=\u0026#34;pbservice\u0026#34;) log.Println(\u0026#34;Transferred via pbservice → BOCHK\u0026#34;) Transfer(HKD, from=\u0026#34;BOCHK\u0026#34;, to=\u0026#34;Wise\u0026#34;, by=\u0026#34;fpservice\u0026#34;) log.Println(\u0026#34;Transferred via fps → Wise\u0026#34;) JPY := WiseConvert(HKD, to=\u0026#34;JPY\u0026#34;) log.Printf(\u0026#34;Converted %.2f HKD to %.2f JPY via Wise\u0026#34;, HKD, JPY) Deposit(JPY, to=\u0026#34;Revolut\u0026#34;, with=\u0026#34;ApplePay\u0026#34;) return JPY } 実行じゃなくて表現用のコード。生活の資金流れを、設計図っぽく組んでみた結果ってだけ。\n※この文章はあくまで個人の趣味と記録として書かれたものであり、金融アドバイスなどを意図したものではありません。ネタとしてお楽しみください。\n","date":"2025-04-22T00:35:15+09:00","image":"https://github.com/yexca/picx-images-hosting/raw/master/2025/04-FromCardEnthusiastToArchitect/250422-JP.3d4zmh3vn7.webp","permalink":"https://blog.yexca.net/ja/archives/245/","title":"カードオタクからアーキテクトへ──生活に宿るシステム設計の哲学"},{"content":" この記事の一部は機械翻訳を使ったよ\n2023年4月、私は家計簿をつけ始めた。2025年4月、記帳をやめた。\n最後の記録：¥0\n始まり：節約とコントロールのために きっかけはシンプルでした——支出を抑え、金銭感覚を高めること。最初は確かに効果的で、無駄遣いを抑えることができました。\n過程：最適解とカード収集の世界へ しかし次第に、「より良い」消費を求めて比較を始め、最適解を探すようになりました。最初は商品の比較だけでしたが、やがて支払い方法やツール、そして銀行の特典やカード開設の世界へと進みました。\n特典のためにカードを作り、便利さのためにカードを作り、気づけばカード収集の世界にどっぷりと浸かっていました。\n最初は節約のため、次に便利さのため、そして最後にはカードを集めるため。\n反作用：記帳が負担に こうして、記帳そのものが次第に負担となっていきました。アカウントが増え、シチュエーションが複雑になるにつれ、記帳にかかる時間や精神的なコストは実際の利益を上回るようになりました。​\n数百円の特典のために何時間も調べることもありました。最初は楽しかったものの、何度も繰り返すうちに、最適解を見つけても興奮しなくなり、最初の喜びは空虚感に変わっていきました。\n変化：最適解から心地よさへ もしかすると、私自身が変わったのかもしれません。消費に対する考え方も変わりました。\n「必要に応じてお得に」から「まあまあでいい、自分が心地よければいい」へ。​\nまた、設定した予算をすでに超えていることにも気づきましたが、それでもコントロールを失うことはありませんでした。むしろ、節約よりも時間と気持ちの方が大切だと、ますます理解するようになりました。\n反省：なぜ記帳していたのか？ 記帳のために、私は以下のようなことを始めました：​\nアカウントが多いため、何度も探し回る​ 通貨の変換のために、記帳アプリで新しいアカウントを頻繁に作成​ 商品を買うべきかどうかで長時間悩む​ 友人と遊びに行った際の支出で気分が台無しになる​ 私は考えざるを得ませんでした——私はなぜ記帳していたのか？\nその中で得られる利益は、本当に価値があるのか？​\n決断：手放し、リセット、再出発 そこで私は、細かいことを気にせず、「私は幸せか？」と自問することにしました。\n結果は——本当に幸せでした。そして、支出も思ったほど多くはありませんでした。\nおそらく、習慣が私を自然に価格比較へと導いていたのでしょう。あるいは、感情の価値は、そもそも特典で測れるものではないのかもしれません。​\nだから、手放す時が来たのだと思います。​\n記帳は、その使命を果たしました。\nもはやツールではなく、束縛となっていました。​\n行動習慣は、より良い生活のためのもの。\nそれが情熱で解消できず、生活の妨げとなるなら、別れを学ぶべきです。​\n終わりに：自分に感謝し、生活を続ける 2年間続けてきた習慣を手放すのは、確かに寂しいものです。\nでも、それも人生の一部なのでしょう。一生を共にできるものはありませんが、一緒に過ごした時間が美しいものであれば、それで十分です。​\n「私は節約上手」という象徴的なツールが一つ減ったとも言えます。\nしかし、これからの自分は、数字や記録に頼って安心感を得るのではなく、真の余裕と自由さで生きていきたいと思います。​\nコントロールできる状態から、未知への流れへ。\n早く適応できることを願っています。\n節約した時間を、より意味のある、より幸せなことに使えるように。​\nだから、\n最後の一筆、¥0 短い文章を添えて。 この2年間、真剣に記録してきた自分にありがとう。 これからは、節約した時間をもっと価値のある、もっと楽しいことに使えますように。​\nこのように、この体験をアーカイブしました。\nレコーディングは終わり、人生は始まったばかり\n","date":"2025-04-14T16:23:48+09:00","permalink":"https://blog.yexca.net/ja/archives/244/","title":"節約から生活、そして別れへ"},{"content":" 📢 この記事は ChatGPT によって翻訳されました 専門系の学習記事をブログに投稿するようになってから、だんだん内容が堅苦しくなってきて、自分でも開いた瞬間に「勉強しなきゃ」って思い込んでしまうようになった。\nそんな心理的な圧があって、最近はブログ記事を書くのがちょっと嫌になってた。\n前から「技術以外のことも書いてみたいな」って思ってたけど、なかなか踏み出せなくて。\nちょうど最近いろいろあったから、試しに非技術系の記事を書いてみようと思う。\n「まだ雨はやまない」 2025年3月23日、人生初の実物アルバムを買った！\nしぐれうい の「まだ雨はやまない」ってやつで、アルバムというより写真集みたいな可愛さがあって、見た瞬間「これは買いだな」って思った。\n……とはいえ、実は買うまでにちょっとした葛藤があった。\n今まで「見た目だけで衝動買い→実際はそんなに良くなかった」ってパターンが多すぎて、しかも生活費も限られてるから、何か買うたびにいつもすごい迷う。\n知らない歌手のアルバムを買うって、かなりチャレンジングな決断だったわけ（しかもまあまあ高いし doge）\n今年（2025年）1月に店頭で初めてこのアルバムを見たとき「かわいい！」って思って、そこから少しずつ気になり始めてた。\nその後、3月22日に VRChat 上で行われた沖縄展で初音ミクの新衣装を見たんだけど、それが しぐれうい のデザインと知って「あれ、この人前に見たな？」ってなった（あと23日のライブもちょっと見た）\n初音ミクのライブを見た、可愛かった！\nI watched Hatsune Miku\u0026#39;s live concert, so cute!\n也是看上初音未来的直播了 pic.twitter.com/r1JeMpQ9UA\n\u0026mdash; yexca (@yexcano) March 24, 2025 この時に「あのアルバムどうなってるんだろ」って気になって検索して、何曲か試しに聴いてみた。「まぁ悪くないかも」って感触。\nで、23日にいざ買おうと思ってお店まで行ったんだけど、手に取った瞬間また躊躇してしまって。\nなんか俺って「買う」って決めたらあえて前情報なしで体験するのが好きなんだけど、ちょっと調べ始めちゃったせいで、逆に買いたくなくなってきた。\nでもたぶん心のどこかでは「やっぱ欲しいな」って気持ちが残ってて、結局漫画だけ買って帰った。\nその帰り道、いつものように音楽アプリを開いてたら、ふと流れてきた曲がめちゃくちゃ良くて、無意識にお気に入りに追加しようとしたら……\n「え、この曲……見覚えある！」ってなって、調べたらあのアルバムに入ってたやつだった！\nそれを知った瞬間、迷わず踵を返して店に戻って即購入（笑）\n（rainy lady、良すぎる……）\n音源を取り出す まあ実際のところ、CDプレイヤーとか持ってないし、物理的に聴くことはあまりない。\nなので、この記事の本題はここ。「アルバムから音源を取り出す」ってやつ。\n参考にしたのはこの投稿： https://www.bilibili.com/opus/925630344961458181 本当なら取り出し手順とかいろいろ書こうと思ったけど、今回はリンク貼っとくだけにするわ。\n「アルストロメリア」 昨日（25日）、本当は友達とゲームする予定だったけど、「ちょっと外出たいな〜」って言われて予定変更。\nんじゃ俺も出かけるかって外に出た結果、なんと 鹿乃 のアルバムを発見してしまった！！\n見た瞬間、反射的に手に取ってレジへ直行。\n嬉しすぎて語彙力を失った。\nだって、鹿乃 だよ！？俺がめちゃくちゃ好きなアーティストだし、収録曲も全部分かってるし、内容も間違いない。\nワクワクしながら開封して、最後に微笑んでるジャケットを見た瞬間、もう心が完全に浄化された。\n好きなものを手に入れるって、ほんと幸せなんだなって改めて思った。\n今思い出すのはこの一言：「このような幸せ、あるでしょうか」\n――こんな幸せが、この世にあるなんて。\n結び 実際に書いてみて、やっぱ自分の表現力の乏しさとか、語彙の足りなさを痛感した。\nけどまあ、そんなにキッチリ書こうとする必要もないよな。\nそれって技術記事と変わらないし、たまにはゆる〜く、思ったままをぐちゃぐちゃに書くのも悪くないかも。\n","date":"2025-03-26T18:18:31+09:00","permalink":"https://blog.yexca.net/ja/archives/243/","title":"音楽を集めて、気持ちをしまう"},{"content":" 📢 この記事は ChatGPT によって翻訳されました ファイル作成時間を見ると試験後っぽいので、おそらく移動したときに「書こう」って思っただけかもしれない。\nOSの位置づけ コンピュータシステムはハードウェアとソフトウェアの2つの構成要素からなる。\nソフトウェアがインストールされていないコンピュータは「ベアマシン」と呼ばれていて、それを直接使うのは不便で、効率も悪い。\nオペレーティングシステム（OS）は、人と機械のギャップを埋めるためのソフトウェアで、ユーザーとコンピュータのインターフェース的な存在。\nOSの位置づけは下図のとおり：\n図からもわかるように、OS はベアマシン上の最初のソフトで、ハードウェア機能を最初に拡張する存在。他のすべてのソフト（編集、アセンブラ、コンパイラ、DB管理など）やアプリケーションは OS の上に成り立ってる。\nユーザーから見ても、OS があれば直接ハードをいじらずに済むし、OS 経由でコマンドやサービスを使って操作できる。だから OS はユーザーとコンピュータの間の重要な橋渡し役になってる。\nプロセス管理 プロセス管理（＝プロセッサ管理）は、複数のプログラムが同時に実行される環境（多重プログラミング、タイムシェアリングなど）で、各プログラムの動的な状態を「プロセス」として扱う。\nプロセスは「リソースを持ち独立して動ける単位」で、同時実行や協調動作・競合の制御が必要になる。\n順次実行の特徴 前順関係を示すグラフ（有向非巡回グラフ）で、ノードは処理単位、矢印は順番の関係を表す。\nたとえば Pi→Pj なら「Pi が終わらないと Pj は実行できない」。\n次の図では、入力→計算→出力の順番関係：\n順次実行の特徴は、以下の3つ：\n順序性 閉鎖性（外部の影響なしに動く） 再現性（毎回同じ結果） 同時実行の特徴 多重プログラムを導入すると、プログラムは並列に実行されることになる。\n前順関係のない処理は、CPU・I/O に並行して割り当てできる。\nたとえば CPU、入力デバイス、出力デバイスが1つずつあるときの例：\nこのときの特徴は以下：\n閉鎖性がなくなる 実行順が固定でなくなる プロセス間の制約が発生する（干渉・協調） プロセス状態と状態遷移 三態モデル 基本的な3つの状態：\n状態 CPU リソース 実行 〇 〇 準備 × 〇 待機 × × 五態モデル 現実のシステムでは「新規作成」「終了待ち」も加わる：\nプロセス間通信 複数のプロセスが同時に動くと、リソースの共有や協調作業が必要になる。\nこのときの情報のやりとりが「プロセス間通信」。\n同期（synchronization）：協調に必要な直接的な制御\n排他（mutual exclusion）：リソースをめぐる間接的な制御\n同期 たとえば A がバッファにデータを書いて、それを B が読む場合、A が終わらないと B は動けない。\nつまり「同期」とは、協調動作を行うプロセス同士のタイミング合わせのこと。\n排他 同時に1つしか使えないリソース（＝クリティカルリソース）を複数のプロセスが取り合うこと。\nたとえばプリンタ、共有変数など。\nクリティカルセクションの管理ルール 空いてたら入る 他が使ってたら待つ 必ず順番が回ってくる 待ち続けず、CPU を手放す セマフォ（信号量） Dijkstra が提唱した手法。\n以下2つの型がある：\n公共セマフォ（初期値 1）：排他制御 私用セマフォ（初期値 0）：同期制御 P/V操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 Procedure P(Var S:Semaphore); Begin S := S - 1; If S \u0026lt; 0 then W(S) {待機キューに追加} End; Procedure V(Var S:Semaphore); Begin S := S + 1; If S \u0026lt;= 0 then R(S) {待機から起こす} End; ~~~ ### 排他制御の例 ```c++ if 車が通ったら then begin P(mutex) COUNT := COUNT + 1; V(mutex) end GOTO L1; begin P(mutex) PRINT COUNT; COUNT := 0; V(mutex) end GOTO L2; ▶ 詳しくは： 【操作系统】进程间通信—互斥 同期制御の例 典型例：単一バッファの producer/consumer 問題。 セマフォの値 0 → データなし、1 → データあり。\n▶ 詳しくは： 【操作系统】进程间通信—同步 デッドロック（死锁） 例：リソース m＝5、プロセス数 n＝3、各プロセスは k＝3 個必要 → m＜nk ならデッドロックになる可能性あり\n回避条件：m ≥ n×(k-1)\nデッドロックの対策 放置（見なかったフリ） 予防（4条件の破壊） 静的割当：最初に全部渡す（効率悪い） 順序割当：リソースに優先順をつける 回避：状態を常にチェック（代表：銀行家のアルゴリズム） ▶ 銀行家算法： 動画リンク スレッド プロセスは「リソース単位」であり、「スケジューリング単位」でもあるけど、 これだと切り替えコストが高くなる。 そこで、「リソース＝プロセス」「スケジューリング＝スレッド」と分けた。\nスレッドは「軽量プロセス」とも呼ばれて、同じプロセス内のスレッド同士はメモリ空間などを共有できる。\nつまり：\nスレッド切り替えは軽い 複数タスクを高速に動かせる リソースはプロセス単位で保持される ","date":"2025-03-16T19:35:38+09:00","permalink":"https://blog.yexca.net/ja/archives/242/","title":"ソフトウェア設計技術者 - OS分野のノート"},{"content":" 📢 この記事は ChatGPT によって翻訳されました この記事は 2024-04-29 に書いたやつで、あとでちょっと修正したけど、結局完成してなかったみたい。しかももう関連ファイルも全部削除しちゃってる。まあ、いいや。\nWeBASE を使って直接 FISCO BCOS をデプロイした記録。\nDocker デプロイ CentOS で Docker を使ってセットアップ。\n環境構築 まず yum-utils をインストールして yum-config-manager を使えるように：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 yum install -y yum-utils ~~~ リポジトリを追加： ```bash # 公式 yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo # アリババクラウド yum-config-manager \\ --add-repo \\ https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo # 清華大学 yum-config-manager \\ --add-repo \\ https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/centos/docker-ce.repo Docker をインストール：\n1 yum install docker-ce docker-ce-cli containerd.io docker-compose-plugin Docker ミラーを設定（中科大のミラー）：\n1 vim /etc/docker/daemon 内容：\n1 2 3 { \u0026#34;registry-mirrors\u0026#34;: [\u0026#34;https://docker.mirrors.ustc.edu.cn\u0026#34;] } Docker を起動：\n1 systemctl start docker 設定を変更したら\n1 2 systemctl daemon-reload systemctl restart docker.service Python をインストール：\n1 yum install -y python36 epel-release python36-pip docker-compose をダウンロード：\n1 2 curl -L \u0026#34;https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)\u0026#34; -o /usr/local/bin/docker-compose chmod +x /usr/local/bin/docker-compose PyMySQL をインストール：\n1 pip3 install PyMySQL ブロックチェーンのデプロイ スクリプトを取得：\n1 wget https://osp-1257653870.cos.ap-guangzhou.myqcloud.com/WeBASE/releases/download/v1.5.5/webase-deploy.zip 解凍して移動：\n1 2 unzip webase-deploy.zip cd webase-deploy 設定ファイルを編集：\n1 vim common.properties Docker イメージを取得：\n1 python3 deploy.py pullDockerAll タイムアウトの値（30/60/120）を聞かれたら適当に入力。\nもし失敗したら、手動でイメージを pull：\n1 docker pull fiscoorg/fiscobcos:v2.9.1 インストール：\n1 python3 deploy.py installDockerAll deploy has completed が出たら成功。\n便利なコマンド一覧：\n1 2 3 4 5 6 7 8 9 10 11 12 # 一括操作 python3 deploy.py installDockerAll # デプロイと起動 python3 deploy.py stopDockerAll # 全停止 python3 deploy.py startDockerAll # 全再開 # ノード操作 python3 deploy.py startNode python3 deploy.py stopNode # WeBASE サービス操作 python3 deploy.py dockerStart python3 deploy.py dockerStop Java 環境でのデプロイ（非 Docker） Docker 使わないなら Java が必要。CentOS の場合 Oracle JDK を使う。\nOracle 公式から JDK8 をダウンロードして、解凍：\n1 2 tar -zxvf jdk-8u411-linux-x64.tar.gz mv jdk1.8.0_411 jdk-8u411 環境変数を設定：\n1 vim /etc/profile 内容：\n1 2 3 export JAVA_HOME=/home/yexca/software/jdk-8u411 export PATH=$JAVA_HOME/bin:$PATH export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOMR/lib/tools.jar 反映：\n1 source /etc/profile バージョン確認：\n1 java -version データベース：MariaDB まず yum リポジトリを追加：\n1 vim /etc/yum.repos.d/mariadb.repo 内容：\n1 2 3 4 5 6 [mariadb] name = MariaDB baseurl = https://mirrors.aliyun.com/mariadb/yum/11.2/centos/$releasever/$basearch module_hotfixes = 1 gpgkey = https://mirrors.aliyun.com/mariadb/yum/RPM-GPG-KEY-MariaDB gpgcheck = 1 キャッシュをクリアして更新：\n1 2 yum clean all yum makecache all インストール：\n1 yum install -y MariaDB-server MariaDB-client 起動：\n1 systemctl start mariadb.service 初期設定：\n1 mariadb-secure-installation ブロックチェーンのデプロイ 1 2 3 4 5 wget https://osp-1257653870.cos.ap-guangzhou.myqcloud.com/WeBASE/releases/download/v1.5.5/webase-deploy.zip unzip webase-deploy.zip cd webase-deploy vim common.properties python3 deploy.py installAll 操作コマンド一覧：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # 一括操作 python3 deploy.py installAll python3 deploy.py stopAll python3 deploy.py startAll # 各サービス個別操作 python3 deploy.py startNode python3 deploy.py stopNode python3 deploy.py startWeb python3 deploy.py stopWeb python3 deploy.py startManager python3 deploy.py stopManager python3 deploy.py startSign python3 deploy.py stopSign python3 deploy.py startFront python3 deploy.py stopFront # 可視化用 python3 deploy.py installWeBASE python3 deploy.py stopWeBASE python3 deploy.py startWeBASE アクセス ポートは web.port=5000（デフォルト）でアクセスできる。\nファイアウォールの設定：\n1 2 3 4 firewall-cmd --zone=public --list-ports firewall-cmd --zone=public --add-port=5000/tcp --permanent firewall-cmd --reload firewall-cmd --zone=public --query-port=5000/tcp スマートコントラクト 2025-03-13: ここに何を書こうとしたのか自分でも忘れた\nWeBASE 管理画面で、合約 IDE から新規作成。 コンパイル → ユーザー作成 → 秘密鍵登録 → トランザクションで動作確認、という流れ。\n参考 WeBASE 公式ドキュメント https://www.runoob.com/docker/centos-docker-install.html https://mariadb.org/download/?t=repo-config\u0026d=CentOS+7\u0026v=11.2\u0026r_m=aliyun https://blog.csdn.net/default7/article/details/122672341 https://www.cnblogs.com/potato-chip/p/13973780.html ","date":"2025-03-13T01:08:02+09:00","permalink":"https://blog.yexca.net/ja/archives/241/","title":"WeBASE を使って FISCO BCOS ブロックチェーンをデプロイする"},{"content":" 📢 この記事は ChatGPT によって翻訳されました はじめに ブログを国際化してからは他言語の投稿なんてほぼ見てなかったんだけど、\nある日ネットサーフィン中に「おっ、いい感じの日本語フォントじゃん？」ってのを見つけて、「これは導入するしかない！」ってなった。\nでもその時に他の言語フォントを見てみたら……ひどすぎて笑った。\n対象箇所の特定 要素を調べてみたら、フォントは変数でコントロールされてることがわかったので、\nテーマの SCSS ファイルを開いて、変数が定義されてる場所を検索。すんなり見つかった。\nフォント追加 既存の命名ルールに倣って、各言語ごとのフォント変数を追加した：\n1 2 3 4 5 6 7 8 9 10 11 12 13 /** * Global font family */ :root { --sys-font-family: -apple-system, BlinkMacSystemFont, \u0026#34;Segoe UI\u0026#34;, \u0026#34;Droid Sans\u0026#34;, \u0026#34;Helvetica Neue\u0026#34;; --zh-font-family: \u0026#34;Noto Sans SC\u0026#34;, \u0026#34;PingFang SC\u0026#34;, \u0026#34;Microsoft YaHei\u0026#34;; --zh-TW-font-family: \u0026#34;Noto Sans TC\u0026#34;, \u0026#34;PingFang TC\u0026#34;, \u0026#34;Microsoft JhengHei\u0026#34;; --ja-font-family: \u0026#34;Hiragino Kaku Gothic ProN\u0026#34;, \u0026#34;Hiragino Sans\u0026#34;, \u0026#34;BIZ UDPGothic\u0026#34;, Meiryo; --en-font-family: \u0026#34;Pacifico\u0026#34;, \u0026#34;Dancing Script\u0026#34;, \u0026#34;Lobster\u0026#34;, cursive; --base-font-family: \u0026#34;Lato\u0026#34;, var(--sys-font-family), var(--en-font-family), var(--zh-font-family), var(--zh-TW-font-family), var(--ja-font-family), sans-serif; --code-font-family: Menlo, Monaco, Consolas, \u0026#34;Courier New\u0026#34;, var(--en-font-family), var(--zh-font-family), var(--zh-TW-font-family), var(--ja-font-family), monospace; } 保存してビルドしてみたけど、特に変化なし。\n言語別フォント上書き設定 実は lang セレクタで言語ごとにフォントを上書きできる。 つまり \u0026lt;html lang=\u0026quot;xx\u0026quot;\u0026gt; によってフォントを切り替えるようにすればいいってこと。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 /* 中国語（簡体） */ :lang(zh), :lang(zh-CN) { font-family: var(--zh-font-family); } /* 中国語（繁体） */ :lang(zh-TW) { font-family: var(--zh-TW-font-family); } /* 英語 */ :lang(en) { font-family: var(--en-font-family); } /* 日本語 */ :lang(ja) { font-family: var(--ja-font-family); } このスタイルをビルドして適用したら、見た目が一気に整って満足。\n","date":"2025-03-10T23:56:56+09:00","permalink":"https://blog.yexca.net/ja/archives/240/","title":"国際化に対応したフォント設定"},{"content":" 音に感じてシリーズ 曲 翻訳 リンク 僕が死のうと思ったのは 略 https://blog.yexca.net/ja/archives/214 あくあ色ぱれっと 略 https://blog.yexca.net/ja/archives/219 恋の押し売り 略 https://blog.yexca.net/ja/archives/220 17さいのうた 略 https://blog.yexca.net/ja/archives/224 drop 恋に落ちた https://blog.yexca.net/ja/archives/230 生きるを選んだ私へ 略 この記事 rainy lady 雨女 https://blog.yexca.net/ja/archives/249 恋しくなったら手を叩こう 略 https://blog.yexca.net/ja/archives/250 まえがき 📢　この部分は ChatGPT によって翻訳されました。　最初に曲のタイトルを見たとき、なんとなく内容が想像できて、同時に自分が以前考えてた「命」についてのことも思い出した。 前はずっと「なんで生きてるんだろう」って答えが出なかったけど、逆に「じゃあなんで死なないの？」って考えてみたとき、自殺の方法とか、それに伴う結果を想像してみて、気づいたんだよね。 自分は自殺が怖いから、生きてるんだなって。 この曲のメッセージと、まさにリンクしててちょっとびっくりした。\nそういえば、こはならむ の曲は前から何曲か聴いたことあって、そのときはよく泣きながら歌ってて、正直ちょっと見るのが辛くなるくらいだった。 「この子、本当に大丈夫かな……」って心配になるくらいに。 でも、YouTube Music が新曲をレコメンドしてきて、それが明るめの雰囲気の曲で、「あ、なんか前より元気になってる？」ってちょっと嬉しくなった（※自分は全然抜け出せてないのに）。\nちゃんと歌詞を読んで理解したあと、「あれ、これめっちゃ良曲じゃん」ってなった。 もっと早く出会いたかったなあ。 同時に、このシリーズの記事を書いてて本当によかったって思った。 前はただなんとなく歌ってた曲が、今ではちゃんと意味が分かって、そこからいろんなことを感じ取れるようになった。 もはや「歌で日本語を学ぶ」じゃなくて、「歌で人生を学んでる」レベル。 前に聴いてた曲の“もうひとつの面”を発見する感じ、すごく不思議だし、もっと好きになった気がする。 （ちなみに、「アスナがキリトに問いかけた“もし本当の自分を知ったらどうなる？”ってやつ思い出したんだけど、ほんと、もっと好きになると思う）\nそして、いつもどおり、このシリーズの翻訳は原文どおりじゃないとこも多いです。 ネタに走った部分もあったけど、合わないところはあとでちゃんと消してます！\n2025.05.26 この曲も歌ってみた。語彙ちょっと難しかったけど、「透明なまま終わっていきなよ、私はもうきっと大丈夫」って叫ぶところ、めっちゃ解放された感じで最高だった！感情ぶちまけた～！ ……まあ、そのあと知らない単語にボコられたけどね（泣）\n動画 歌詞 なつかしい音 なつかしい匂い なつかしい景色\n蘇よみがえるトラウマ 見たくない顔 聞きたくない声\n許せない人たち もう行けなくなっちゃった、あの駅\n暗い「人目が怖いの」\nそんな記憶 あいして生きる\n透明なまま終わっていきなよ\n私はもうきっと大丈夫\n嫌い泣きたいも今振り返れば\n泡と消える刹那せつな\n私見て下を見た気でいなよ そのまま\n消えてしまいたいと願ったような夜に\n笑ってられてるよ 永遠に消えないんだよ\n狭い世界で くだらない談だんに怯おびえてる私\n霞かすんで歪ゆがんだ脳 明白めいはくな病\n傷跡きずあとは消えないまま 責任の所在は？\nあの日の子供が泣くのだ 今でも\n今日ものうのう生きている 永世えいせい罪人ざいにん共に問う\n替えの効かないもの 戻らないものに手を出した自じ覚かくはある？\n許せぬ過去を睨にらんでも仕方ない、って\n言葉は理解するが 時に解決を促うながさせる\n卑ひ劣れつさに 愚ぐ劣れつさに\n反吐へどが出る 反吐へどが出る\n「忘れろ」も言葉のナイフだ\n私は今日も立っている 私は今日も歌っている\n透明なまま終わっていきなよ\n私はもう大丈夫\n嫌い泣きたいも今振り返れば\n私を生かすのは私なのだ\n透明なまま終わっていきなよ\n私はもう、もう大丈夫\n嫌い泣きたいも今振り返れば\n決して消えぬ「愛」か\n私見て下を見た気でいなよ そのまま\n消えてしまいたいと願ったような夜に\n笑っているんだよ 笑っているんだよ 笑っているんだよ\n","date":"2025-03-07T01:26:31+09:00","permalink":"https://blog.yexca.net/ja/archives/239/","title":"音に感じて - 《生きるを選んだ私へ》"},{"content":" 📢 この記事は ChatGPT によって翻訳されました 同じく コンピュータネットワークのノート と同時期に書いたやつ。試験ではこの2つの分野が一緒に出るから、勉強も同時進行だった。\nファイアウォール技術 ファイアウォール（Firewall）は、内部ネットワークと外部ネットワークの境界に設置されるフィルタリング装置。内部ネットワークは信頼できる、安全なものとみなされ、外部ネットワークはその逆という前提。\n目的は、保護されたネットワークに対する「望ましくない」「認可されていない」通信を遮断すること。\nつまり、境界管理を通して内部ネットワークのセキュリティポリシーを強化するもの。\nファイアウォールはネットワークセキュリティの中心であり、全ての通信を監視・制御・監査・アラート処理する。\nだからこそ、自分自身もセキュリティの脅威に晒されやすい場所にあるので、しっかりした製品を選ぶのが大事。\n発展の歴史は以下の通り：\nパケットフィルタリング アプリケーションゲートウェイ ステートフルインスペクション（状態検査） パケットフィルタリング型 パケットのヘッダ情報（送信元アドレス・宛先アドレス・プロトコル・ポート番号など）で判断し、通すかどうか決める。\n特徴：\nユーザーには透明で高速 ネットワーク層レベルの制御 スプーフィング（なりすまし）をある程度防げる ルーターに組み込めるので、別途機器いらず 欠点：\nアプリ層の制御はできない 粒度が荒い 新しいタイプの攻撃には対応できない アプリケーションプロキシ型 内部と外部を完全に分離し、内部→外部の通信は一度プロキシが受け取ってから外部と通信、返ってきたらまたプロキシ経由で内部に返す。\nつまり外部との直接接続はさせない。\nメリット：\nアプリ層・トランスポート層・ネットワーク層の全てを監視できる\nデメリット：\n設定が面倒\n動作が遅い\nステートフルインスペクション型 上の2つのいいとこ取り。安全性を保ちつつ、スピードも確保できる。\nウイルス 特徴：\n伝染性 隠蔽性 感染性 潜伏性 トリガー性（発動条件付き） 破壊性 ウイルスの種類：\nWorm（ワーム） Trojan（トロイの木馬） Backdoor（バックドア） Macro（マクロウイルス） マクロウイルスの感染対象：ドキュメントやスプレッドシートなど\n代表例：\nトロイ：冰河（Ice River） ワーム：Happytime、熊猫烧香（香水パンダ）、Code Red、Love Bug、Stuxnet ネットワーク攻撃 DoS攻撃：リクエストを送りまくってサービス不能にさせる リプレイ攻撃：以前キャプチャした通信を再送して認証突破を狙う パスワード攻撃：正規ユーザーになりすましてログイン トロイの木馬：アプリやゲームに見せかけて裏で侵入 ポートスキャン攻撃：開いてるポートを探して攻撃 ネットワークスニッフィング：同じネットワーク内の通信を傍受 IPスプーフィング：送信元IPを偽装して信用させる SQLインジェクション：不正なSQLを注入して情報抜き出し・改変など 侵入検知技術のタイプ：\nエキスパートシステム型 モデルマッチング型 単純なパターンマッチ型 ネットワークセキュリティ技術 SSL (Secure Socket Layer)\n1994年 Netscape が開発したトランスポート層の暗号通信プロトコル\nSSL 3.0 は事実上の標準として広まった\nTLS (Transport Layer Security)\nIETF が SSL3.0 を基に仕様化したバージョン\nSSL の後継プロトコルとして現在主流\nSSH (Secure Shell)\nアプリ層とトランスポート層にまたがるリモートログイン用プロトコル\n当初は UNIX 用だったが今ではマルチプラットフォームに対応\nパスワードやコマンドの盗聴対策に有効\nHTTPS\nHTTP + SSL による暗号化通信。セキュリティ強化版 HTTP\nMIME (Multipurpose Internet Mail Extensions)\nメールで非ASCIIデータ（バイナリ・画像・音声など）を送るための拡張規格\nPGP (Pretty Good Privacy)\nRSA 公開鍵暗号に基づいたメール暗号化ソフト\nメールの暗号化＆デジタル署名の機能を持つ\n","date":"2025-03-04T18:38:28+09:00","permalink":"https://blog.yexca.net/ja/archives/238/","title":"ソフトウェア設計技術者 - 情報セキュリティ分野のノート"},{"content":" 音に感じてシリーズ 曲 翻訳 リンク 僕が死のうと思ったのは 略 https://blog.yexca.net/ja/archives/214 あくあ色ぱれっと 略 https://blog.yexca.net/ja/archives/219 恋の押し売り 略 https://blog.yexca.net/ja/archives/220 17さいのうた 略 https://blog.yexca.net/ja/archives/224 drop 恋に落ちた この記事 生きるを選んだ私へ 略 https://blog.yexca.net/ja/archives/239 rainy lady 雨女 https://blog.yexca.net/ja/archives/249 恋しくなったら手を叩こう 略 https://blog.yexca.net/ja/archives/250 まえがき 今日は2019年12月のN1試験を試してみて、思いがけず合格した。とてもうれしいので、また日本語の勉強の記事をやろう。\nなんでこんなに可愛い曲があるな、心も溶けるかも\n動画 歌詞 夢の中で君と過ごしても\nまた覚めるたび君が離れないの\n退屈なベッドで1人きり\nあぁ 迎えに来てよ王子様\n君を知りたい 気持ちもどかしい\nいっそシャボン玉になって弾けたい\nあぁ 君が好き なんて言えない\nたまに冷たい 君がわかんない\n君の場所びゅーんと飛んでって\nアニメみたいに2人恋に落ちて\nくすぐったいくらいに君のこと\n考える1人の夜がいいの\nふわふわと浮かぶ甘い心\n頭離れない君は悪い男？\nわからないことにもやもやして\n夢でも君のことを考えて\nあぁ いじけちゃって嫌になっても 考えちゃう\nねぇ 優しかったり冷たくなったり 迷路みたい\nあぁ 攻略サイトも見当たらないから やり直しばかり\nもー知らないもんって強がり\nでも嫌いになんてなれるわけもない\nそう思うほど胸も痛くなる愛\n私の恋のキュービットは\nいつになったら現れるの\n夢の中で君と過ごしても\nまた覚めるたび君が離れないの\n退屈なベッドで1人きり\nあぁ 迎えに来てよ王子様\n君を知りたい 気持ちもどかしい\nいっそシャボン玉になって弾けたい\nあぁ 君が好き なんて言えない\nたまに冷たい 君がわかんない\nひいふうみいよ 数えて\n君につぎ 会える日を楽しみに眠るの\nいつでも会えるよう\n昨日よりもかわいくなるために生きるよ\n気付いてくれるかな\n君の好きなメイクにしてみたとか (どうかな？)\n少し重すぎかな\n優柔不断で何も決まんないや (もう)\n可愛くなれるかな\n君の前だとチークはいらないか (ねえ ねえ)\n私と同じかな\nこの気持ち君も同じだといいな\n夢の中で君と過ごしても\nまた覚めるたび君が離れないの\n退屈なベッドで1人きり\nあぁ 迎えに来てよ王子様\n君を知りたい 気持ちもどかしい\nいっそシャボン玉になって弾けたい\nあぁ 君が好き なんて言えない\nたまに冷たい 君がわかんない\nふわふわな気持ちを隠しても\n君の眼を見るとまた零れるちゃうよ\n味のないケーキも君となら\n大好きな時間に変わってく\n君を知りたい もっと知りたい\n好きの2文字が口から出せない\nあぁ 君が好き を隠した日々\nたまに冷たい 君も愛おしい\n","date":"2025-02-06T22:06:10+09:00","permalink":"https://blog.yexca.net/ja/archives/230/","title":"音に感じて - 《drop》"},{"content":" 音に感じてシリーズ 曲 翻訳 リンク 僕が死のうと思ったのは 略 https://blog.yexca.net/ja/archives/214 あくあ色ぱれっと 略 https://blog.yexca.net/ja/archives/219 恋の押し売り 略 https://blog.yexca.net/ja/archives/220 17さいのうた 略 この記事 drop 恋に落ちた https://blog.yexca.net/ja/archives/230 生きるを選んだ私へ 略 https://blog.yexca.net/ja/archives/239 rainy lady 雨女 https://blog.yexca.net/ja/archives/249 恋しくなったら手を叩こう 略 https://blog.yexca.net/ja/archives/250 まえがき 私も未来のことを迷っているけど、でも生活がずっと続いているから、自分を変えなきゃね\n動画 歌詞 こんな私の未熟なうたを　聴いてくれてどうも有難うね\n未熟: みじゅく\nもう少しで私は未熟な大人に　なるみたいです\nなんか笑っちゃうね\n本当はね\nもっと前を向けるようなうたを　書くつもりだったけど\n書けなくて\n私はまだ　他の誰かを支えられるほど\n強くなかったみたい　ごめんね\n拝啓　未来の私へ　今そこで\nどんなことをして　生きていますか\n拝啓　今の私へ　今ここで\nどんなことをしたら　生きていけるんでしょうか\n\u0026ldquo;好きだからかっこいい\u0026quot;とか　\u0026ldquo;そばにいる\u0026quot;とか\n\u0026ldquo;勝手に盗んだ\u0026quot;とか　書いてた\nどうせだったらもうちょっと　貴方みたいに\nやさしいうたを書けばよかったね\n本当はね　好きなことだけして生きたいの\nでもそれは上手な生き方とは言えないから\n無駄になっても　意味がなくても\n今はここから　離れなきゃいけないの　ごめんね\n拝啓　未来の私へ　今そこで\nどんな大人になって　生きていますか\n拝啓　今の私へ　今ここで\nどんな大人になりたいと　言えばいいんでしょうか\n「さよなら」は悲しくなるからさ\n「またね」って言わせて\nいつか私が　今みたいな　うたを書けなくなっても\n怒らないでね\n拝啓　過去の私へ　今の私は\nずっと夢見ていたこと叶えてるよ\n拝啓　今の私へ\nこんな情けない　うただって歌えばいいよ\n情け: なさけ\nそれが私だから\n拝啓　未来の私へ　今そこは\nどんな綺麗な世界が　広がっていますか\n拝啓　今の私へ　今ここが\nどんな世界よりも　幸せでした\nこんな私の未熟なうたを　聴いてくれてどうも有難うね\nこれから私は未熟な大人に　なる準備をします\n「じゃあ またね」\n","date":"2025-01-25T16:57:49+09:00","permalink":"https://blog.yexca.net/ja/archives/224/","title":"音に感じて - 《17さいのうた》"},{"content":" 音に感じてシリーズ 曲 翻訳 リンク 僕が死のうと思ったのは 略 https://blog.yexca.net/ja/archives/214 あくあ色ぱれっと 略 https://blog.yexca.net/ja/archives/219 恋の押し売り 略 この記事 17さいのうた 略 https://blog.yexca.net/ja/archives/224 drop 恋に落ちた https://blog.yexca.net/ja/archives/230 生きるを選んだ私へ 略 https://blog.yexca.net/ja/archives/239 rainy lady 雨女 https://blog.yexca.net/ja/archives/249 恋しくなったら手を叩こう 略 https://blog.yexca.net/ja/archives/250 まえがき 甘い曲だよねー\n2025年01月27日歌った、めっちゃ可愛かった！！！\n動画 歌詞 ハートマーク作って\n届け届け届け\nきっと恋の押し売り\n好きで好きでごめん\n出会っちゃった！\nときめいちゃった？ ときめく\n私だけ？ドキドキしてるの\nちゃんと気にかけて\n私だけ！甘やかして\n(Ah)　君と話す理由欲しくて探している\n(なんで？)　強がっていても恋に負けちゃうんだね\nハートマーク作って\n届け届け届け\nきっと恋の押し売り\n好きで好きでごめん\nハートのレスください\n早く早く早くー！\nこれは恋の押し売り\n返品なんてダメよ\n取られたくないんだよ…\n誰よりも可愛くなりたい\n完全勝利して\n私だけって言わせてやる！\n(Ah)　君の胸を狙う私の恋の銃口\n(なんで？)　震えちゃうんだろう\nいつか撃ち抜けるまで 撃ち抜く: うちぬく\nせーっの！BANG\n期待させてよ\nもっともっともっと\n私浮ついちゃって 浮つく: うわつく\nバカだバカだごめん\nハートは忙しくて\nあっちこっちどっちー？\n今はまだまだプロローグ\n押して押して押すの\n私、君に出会えて変わったの！\nそりゃあ悩んじゃう事もあるけど…\nもっともっと可愛くなりたいって思うし\n何より君に好きって言ってもらいたい！\n笑顔の私(可愛い)\n泣いちゃう私(可愛い)\n怒った私(可愛い)\n恋する私…\n甘えさせてよ\nずっとずっとずっと\nきっと後悔させない\nお願い　好きになって\nハートマーク作って\n届け届け届け\nきっと恋の押し売り\n好きで好きでごめん\nハートのレスください\n早く早く早くー！\nこれは恋の押し売り\n返品なんてダメよ\n","date":"2025-01-20T16:24:43+09:00","permalink":"https://blog.yexca.net/ja/archives/220/","title":"音に感じて - 《恋の押し売り》"},{"content":" 音に感じてシリーズ 曲 翻訳 リンク 僕が死のうと思ったのは 略 https://blog.yexca.net/ja/archives/214 あくあ色ぱれっと 略 この記事 恋の押し売り 略 https://blog.yexca.net/ja/archives/220 17さいのうた 略 https://blog.yexca.net/ja/archives/224 drop 恋に落ちた https://blog.yexca.net/ja/archives/230 生きるを選んだ私へ 略 https://blog.yexca.net/ja/archives/239 rainy lady 雨女 https://blog.yexca.net/ja/archives/249 恋しくなったら手を叩こう 略 https://blog.yexca.net/ja/archives/250 音に感じてシリーズ\n曲 リンク 僕が死のうと思ったのは https://blog.yexca.net/ja/archives/214 あくあ色ぱれっと この記事 恋の押し売り https://blog.yexca.net/ja/archives/220 17さいのうた https://blog.yexca.net/ja/archives/224 drop https://blog.yexca.net/ja/archives/230 まえがき また歌詞だけ書こう、次回何か日本語で感想を書くほうがいいかな。\n2025年01月27日、この曲を歌った、その時湊あくあが歌った 誇り高きアイドル を思い出した、とっても楽しかった。私もあくあ色に染まられたかもXD\n動画 歌詞 何をしても不器用で　何かとミスしてばっか\nダメダメな私だって\nできる事があるの\n凹んで悲しくたって　笑顔にしてあげるんだ\nここにいるから　早く　私を見つけてね\nLove You Love You, I love you\nLove You Love You, Ah,I love you so much\nLove You Love You, I love you\nLove You Love You\n（あぁ　愛してもっと）\nいつでも隣にいるし、いつでも一緒に笑える\n私をたくさん知って　たくさん好きって言って\nワガママで朝も苦手　ドジだし　ダメダメだけど\nそれでも私の事を　見ててね\n描く夢の未来へ続く\n道をキミと歩けますように\nねぇもっと！好きになってもらいたいの！\n頭の中は君ばっか！\nってゆーかそっぽなんて向いてないで！\nあぁもう！ヤキモキしちゃうわ　Ah\nずっとずっと好きがいいの\n心の奥もトキメイちゃうくらい\nこっち向いててよね　ダーリン？\nあぁもう離さないから、絶対に！\nLove You Love You, I love you\nLove You Love You\n（あぁ　愛してもっと）\nキミがいるから私　いつでも頑張れるんだ\n落ち込んで悲しくたって　キミがいるから\u0026hellip;\nキミがいるから　歩いてこれた\nキミがいなくちゃ　前も見れない\n嫌な事とか辛い事とかあったって\nキミの力でここまで笑ってこれたんだ\n今度はもっと私がぐっとひっぱって　連れて行くんだ\nキミがいるから私がいるの\nこんな私を　愛してくれる？\nねぇもっと　ねぇもっと\nまだもっと　受け止めてよね！ねぇいい？\nさぁ声を上げて！\nねぇもっと　ねぇもっと\n好きになってもらいたいの\nいつでも　そう私ばっか みたいにそっぽなんて向かせないわ\nね、ほら夢中にしちゃうわ　Ah\nずっとずっと好きがいいの！心も体も染まっちゃうくらいに\nこっち向いててよねダーリン?\nあぁもう離さないから、絶対に　絶体ね　絶体よ　約束だよ\n（あぁ 愛してもっと）\n","date":"2025-01-20T00:16:48+09:00","permalink":"https://blog.yexca.net/ja/archives/219/","title":"音に感じて - 《あくあ色ぱれっと》"},{"content":" この記事の一部は機械翻訳を使ったよ\nMyBatis シリーズ\nインストールと開始方法: https://blog.yexca.net/ja/archives/215 使い方: この記事\n削除 パラメータ名を中に入れたプレースホルダとして #{} を使用します\n1 2 3 4 5 6 @Mapper public interface EmpMapper { // 削除 @Delete(\u0026#34;delete from mybatis.emp where id = #{id}\u0026#34;) public void delete(Integer id); } テスト\n1 2 3 4 5 6 7 8 9 @SpringBootTest class Mybatis02ApplicationTests { @Autowired private EmpMapper empMapper; @Test void contextLoads() { empMapper.delete(17); } } 通常、戻り値は必要ありません。戻り値は、この操作によって影響を受ける行の数です。\n1 2 3 4 5 6 @Mapper public interface EmpMapper { // 削除 @Delete(\u0026#34;delete from mybatis.emp where id = #{id}\u0026#34;) public int delete(Integer id); } プレースホルダー パラメータプレースホルダは #{} と ${} です\nプレースホルダー #{} ${} 形状 プリコンパイル スプライシング いつ使うか パラメータの受け渡し、ログインなど テーブル名とリストを動的に設定する 長所と短所 安全性と高性能 SQLインジェクションの問題がある 挿入（新規） プレースホルダも使用されますが、渡されるパラメータが多すぎる場合は、オブジェクトのカプセル化を使用することができ、正式なパラメータ名はオブジェクトのパラメータ名になります。\n1 2 3 4 5 6 7 @Mapper public interface EmpMapper { // 増加 @Insert(\u0026#34;insert into mybatis.emp(username, name, gender, image, job, entrydate, dept_id, create_time, update_time) \u0026#34;+ \u0026#34;values (#{username},#{name},#{gender},#{image},#{job},#{entrydate},#{deptId},#{createTime},#{updateTime});\u0026#34;) public void insert(Emp emp); } テスト\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 @SpringBootTest class Mybatis02ApplicationTests { @Autowired private EmpMapper empMapper; @Test public void testInsert(){ Emp emp = new Emp(); emp.setUsername(\u0026#34;Tom\u0026#34;); emp.setName(\u0026#34;トム\u0026#34;); emp.setGender((short) 1); emp.setImage(\u0026#34;tom.jpg\u0026#34;); emp.setJob((short) 1); emp.setEntrydate(LocalDate.of(2000,1,1)); emp.setDeptId(1); emp.setCreateTime(LocalDateTime.now()); emp.setUpdateTime(LocalDateTime.now()); empMapper.insert(emp); } } 主キーの値を取得する 場合によっては、データが正常に追加された後、データベースに挿入されたデータの主キーを取得する必要があります。\n1 2 3 4 5 6 7 8 9 @Mapper public interface EmpMapper { // 主キーを取得します。最初の属性は、emp オブジェクトの id 属性に割り当てられた主キー値を定義します。2 番目の属性は、返される主キー値を表します。 @Options(keyProperty = \u0026#34;id\u0026#34;, useGeneratedKeys = true) // 増加 @Insert(\u0026#34;insert into mybatis.emp(username, name, gender, image, job, entrydate, dept_id, create_time, update_time) \u0026#34;+ \u0026#34;values (#{username},#{name},#{gender},#{image},#{job},#{entrydate},#{deptId},#{createTime},#{updateTime});\u0026#34;) public void insert(Emp emp); } 更新（変更） 増加と同様に、オブジェクトにカプセル化することができます\n1 2 3 4 5 6 7 @Mapper public interface EmpMapper { // 変更 @Update(\u0026#34;update mybatis.emp set username = #{username}, name = #{name}, gender = #{gender}, image = #{image}, job = #{job}, \u0026#34;+ \u0026#34;entrydate = #{entrydate}, dept_id = #{deptId}, update_time = #{updateTime} where id = #{id};\u0026#34;) public void update(Emp emp); } テスト\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 @SpringBootTest class Mybatis02ApplicationTests { @Autowired private EmpMapper empMapper; @Test public void testUpdate(){ Emp emp = new Emp(); emp.setUsername(\u0026#34;Tom2\u0026#34;); emp.setName(\u0026#34;トム2\u0026#34;); emp.setGender((short) 1); emp.setImage(\u0026#34;tom.jpg\u0026#34;); emp.setJob((short) 1); emp.setEntrydate(LocalDate.of(2000,1,1)); emp.setDeptId(1); emp.setUpdateTime(LocalDateTime.now()); emp.setId(19); empMapper.update(emp); } } クエリ クエリには、IDに基づいてすべての属性をクエリするクエリと条件に基づいてクエリするクエリの2種類があります。\nIDによるクエリ インタフェース\n1 2 3 4 5 6 @Mapper public interface EmpMapper { // IDによるクエリ @Select(\u0026#34;select * from mybatis.emp where id = #{id}\u0026#34;) public Emp idSelect(Integer id); } テスト\n1 2 3 4 5 6 7 8 9 10 11 12 @SpringBootTest class Mybatis02ApplicationTests { @Autowired private EmpMapper empMapper; @Test public void testIdSelect(){ Emp emp = empMapper.idSelect(19); System.out.println(emp); } } 結果\n1 Emp(id=19, username=Tom2, password=123456, name=汤姆2, gender=1, image=tom.jpg, job=1, entrydate=2000-01-01, deptId=null, createTime=null, updateTime=null) クラス Emp のフィールド名がデータベースと異なるため、クエリ結果は null になります。\n解決方法は3つあります\nエイリアスの使用 1 2 3 4 5 6 7 @Mapper public interface EmpMapper { // 方法 1: エイリアス @Select(\u0026#34;select id, username, password, name, gender, image, job, entrydate, dept_id deptId, create_time createTime, update_time updateTime\u0026#34; + \u0026#34; from mybatis.emp where id = #{id}\u0026#34;) public Emp idSelect(Integer id); } @Results アノテーションの使用 1 2 3 4 5 6 7 8 9 10 11 @Mapper public interface EmpMapper { // 方法 2: @Results @Result アノテーション @Results({ @Result(column = \u0026#34;dept_id\u0026#34;, property = \u0026#34;deptId\u0026#34;), @Result(column = \u0026#34;create_time\u0026#34;, property = \u0026#34;createTime\u0026#34;), @Result(column = \u0026#34;update_time\u0026#34;, property = \u0026#34;updateTime\u0026#34;) }) @Select(\u0026#34;select * from mybatis.emp where id = #{id}\u0026#34;) public Emp idSelect(Integer id); } 自動包装の使用 フィールド名と属性名がキャメルケース命名規則に準拠している場合は、自動キャメルケース命名カプセル化を有効にすることができ、Mybatisはキャメルケース命名規則に従って自動的にマッピングします。具体的には、データベースはアンダースコア「a_column」をJava属性「aColumn」にマッピングします。\nキャメルケース命名を有効にするには、application.propertiesに追加します。\n1 mybatis.configuration.map-underscore-to-camel-case=true 然后直接使用最初的代码\n1 2 3 4 5 6 @Mapper public interface EmpMapper { // IDによるクエリ @Select(\u0026#34;select * from mybatis.emp where id = #{id}\u0026#34;) public Emp idSelect(Integer id); } 使いやすさのために、IDEA に MyBatisX プラグインをインストールすることができます。\n条件による検索 要件: 従業員名 (あいまい一致)、性別 (完全一致)、雇用日 (範囲) に基づいて条件を満たす従業員情報を検索します。\n1 2 3 4 5 6 7 8 @Mapper public interface EmpMapper { // 条件による検索 // \u0026#39;%${name}%\u0026#39; のように名前に使用される ${} は、\u0026#39;\u0026#39; 内でも使用できることに注意してください。 @Select(\u0026#34;select * from mybatis.emp where name like \u0026#39;%${name}%\u0026#39; and gender = #{gender} and \u0026#34; + \u0026#34;entrydate between #{begin} and #{end} order by update_time desc\u0026#34;) public List\u0026lt;Emp\u0026gt; conditionSelect(String name, short gender, LocalDate begin, LocalDate end); } 文字列の連結には補間が使用されるため、この方法は安全ではありません。\n1 2 3 4 5 6 7 @Mapper public interface EmpMapper { // より安全な条件付きクエリ @Select(\u0026#34;select * from mybatis.emp where name like concat(\u0026#39;%\u0026#39;,#{name},\u0026#39;%\u0026#39;) and gender = #{gender} and \u0026#34; + \u0026#34;entrydate between #{begin} and #{end} order by update_time desc\u0026#34;) public List\u0026lt;Emp\u0026gt; conditionSelect(String name, short gender, LocalDate begin, LocalDate end); } concat 関数は文字列を連結するために使用されます。テスト\n1 2 3 4 5 6 7 8 9 10 11 12 @SpringBootTest class Mybatis02ApplicationTests { @Autowired private EmpMapper empMapper; @Test public void testConditionSelect(){ List\u0026lt;Emp\u0026gt; empList = empMapper.conditionSelect(\u0026#34;张\u0026#34;, (short) 1, LocalDate.of(2010, 1, 1), LocalDate.of(2020, 1, 1)); System.out.println(empList); } } パラメータ名の説明 SQLで使用される#{}内の変数名はSpringBoot 2.x以降では自動的に認識されますが、バージョン1.xまたはMyBatisのみを使用する場合は、メソッド内で定義された変数名をアノテーションを使用して指定する必要があります。\n1 2 3 4 5 6 7 8 9 10 11 @Mapper public interface EmpMapper { // より安全な条件付きクエリ @Select(\u0026#34;select * from mybatis.emp where name like concat(\u0026#39;%\u0026#39;,#{name},\u0026#39;%\u0026#39;) and gender = #{gender} and \u0026#34; + \u0026#34;entrydate between #{begin} and #{end} order by update_time desc\u0026#34;) public List\u0026lt;Emp\u0026gt; conditionSelect(String name, short gender, LocalDate begin, LocalDate end); } // 上記のコードは1.xでは動作しません。またMyBatisのみを使用する場合も動作しません。関数に注釈を付ける必要がある。 public List\u0026lt;Emp\u0026gt; conditionSelect(@Param(\u0026#34;name\u0026#34;) String name, @Param(\u0026#34;gender\u0026#34;) short gender, @Param(\u0026#34;begin\u0026#34;) LocalDate begin, @Param(\u0026#34;end\u0026#34;) LocalDate end); XML マッピングファイルの使用 SQL コードが比較的短い場合は、アノテーションを使用すると便利ですが、SQL が長かったり複雑だったりする場合は、少し乱雑に見えます。この目的のために、XML マッピング ファイルを使用できます。仕様は以下の通りです\nXML マッピングファイルの名前は Mapperイ ンターフェースの名前と一致しており、XML マッピングファイルと Mapper インターフェースは同じパッケージ（同じパッケージ、同じ名前）に配置されています。 XML の名前空間属性は Mapper インターフェースの完全修飾名と一致している XML 内の SQL 文の id 属性は Mapper インターフェースのメソッド名と一致しており、戻り値の型も一致している XML Maven プロジェクトでは、Java 以外のファイルは src/main/resources の下に配置されます。このディレクトリの下に Mapper インターフェースと一致するディレクトリを作成します。\nインターフェースが net.yexca.mapper.EmpMapper.java の場合、XML ファイルは net.yexca.mapper.EmpMapper.xml にあります。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;https://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;!-- 上記のヘッダーファイルを見つけるには、公式ウェブサイトにアクセスしてください。 --\u0026gt; \u0026lt;!-- namespace 属性はインターフェースである --\u0026gt; \u0026lt;mapper namespace=\u0026#34;net.yexca.mapper.EmpMapper\u0026#34;\u0026gt; \u0026lt;!-- id属性はメソッド名です --\u0026gt; \u0026lt;!-- resultTypeは単一のレコードでカプセル化された型です --\u0026gt; \u0026lt;select id=\u0026#34;conditionSelect\u0026#34; resultType=\u0026#34;net.yexca.pojo.Emp\u0026#34;\u0026gt; select * from mybatis.emp where name like concat(\u0026#39;%\u0026#39;,#{name},\u0026#39;%\u0026#39;) and gender = #{gender} and entrydate between #{begin} and #{end} order by update_time desc \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt; インターフェースクラス 1 2 3 4 @Mapper public interface EmpMapper { public List\u0026lt;Emp\u0026gt; conditionSelect(String name, short gender, LocalDate begin, LocalDate end); } 動的 SQL 動的 SQL は、ユーザー入力または外部条件に応じて変化する SQL ステートメントです。\nたとえば、上記の最後の条件クエリでは、クエリを実行するために 3 つの条件すべてを入力する必要があります。実際の使用では、1 つまたは 2 つの条件のみを指定するか、指定しない (すべてをクエリする) ことができます。上記の手順に従って実行すると、空の結果が返されます。\nwhere if 条件が真であるかどうかを判断するために使用されます。条件判定を実行するには、テスト属性を使用します。条件が真の場合、SQLを連結します。\nたとえば、名前が空でない場合、連結条件は名前によって照会されます。\n1 2 3 \u0026lt;if test=\u0026#34;name!=null\u0026#34;\u0026gt; name like contact(\u0026#39;%\u0026#39;,#{name},\u0026#39;%\u0026#39;) \u0026lt;/if\u0026gt; where タグは、where キーワードを生成するかどうか、および and キーワードと or キーワードを自動的に削除するかどうかを管理します。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;select id=\u0026#34;conditionSelect\u0026#34; resultType=\u0026#34;net.yexca.pojo.Emp\u0026#34;\u0026gt; select * from mybatis.emp \u0026lt;where\u0026gt; \u0026lt;if test=\u0026#34;name!=null\u0026#34;\u0026gt; name like concat(\u0026#39;%\u0026#39;,#{name},\u0026#39;%\u0026#39;) \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;gender!=null\u0026#34;\u0026gt; and gender = #{gender} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;begin!=null and end!=null\u0026#34;\u0026gt; and entrydate between #{begin} and #{end} \u0026lt;/if\u0026gt; \u0026lt;/where\u0026gt; order by update_time desc \u0026lt;/select\u0026gt; set SQL の set キーワードを置き換え、UPDATE ステートメントで使用する余分なカンマを自動的に削除します。\nたとえば、次のSQL文は動的SQLに変更されます。\n1 2 3 4 5 6 7 8 9 10 update mybatis.emp set username = #{username}, name = #{name}, gender = #{gender}, image = #{image}, job = #{job}, entrydate = #{entrydate}, dept_id = #{deptId}, update_time = #{updateTime} where id = #{id}; XML\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;update id=\u0026#34;update2\u0026#34;\u0026gt; update mybatis.emp \u0026lt;set\u0026gt; \u0026lt;if test=\u0026#34;username != null\u0026#34;\u0026gt;username = #{username},\u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;name != null\u0026#34;\u0026gt;name = #{name},\u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;gender != null\u0026#34;\u0026gt;gender = #{gender},\u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;image != null\u0026#34;\u0026gt;image = #{image},\u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;job != null\u0026#34;\u0026gt;job = #{job},\u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;entrydate != null\u0026#34;\u0026gt;entrydate = #{entrydate},\u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;deptId != null\u0026#34;\u0026gt;dept_id = #{deptId},\u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;updateTime != null\u0026#34;\u0026gt;update_time = #{updateTime}\u0026lt;/if\u0026gt; \u0026lt;/set\u0026gt; where id = #{id}; \u0026lt;/update\u0026gt; foreach foreach タグはトラバーサルに使用されます\n1 2 3 4 \u0026lt;!--走査するコレクション 横断された要素 デリミタ 開始前と開始後に連結されたSQLフラグメント--\u0026gt; \u0026lt;foreach collection=\u0026#34;ids\u0026#34; item=\u0026#34;id\u0026#34; separator=\u0026#34;,\u0026#34; open=\u0026#34;(\u0026#34; close=\u0026#34;)\u0026#34;\u0026gt; #{id} \u0026lt;/foreach\u0026gt; ids が [13, 14, 15] の場合、上記は (13,14,15) を生成します。\n要件: ID 1、2、3 の項目を走査して削除します。 SQL文は\n1 delete from emp where id in(1,2,3) インターフェースメソッド\n1 public void deleteByIds(List\u0026lt;Integer\u0026gt; ids); XML\n1 2 3 4 5 6 \u0026lt;delete id=\u0026#34;deleteByIds\u0026#34;\u0026gt; delete from mybatis.emp where id in \u0026lt;foreach collection=\u0026#34;ids\u0026#34; item=\u0026#34;id\u0026#34; separator=\u0026#34;,\u0026#34; open=\u0026#34;(\u0026#34; close=\u0026#34;)\u0026#34;\u0026gt; #{id} \u0026lt;/foreach\u0026gt; \u0026lt;/delete\u0026gt; テスト\n1 2 3 4 5 @Test public void testDeleteByIds(){ List\u0026lt;Integer\u0026gt; ids = Arrays.asList(13,14,15); empMapper.deleteByIds(ids); } sql と include 開発プロセスでは、多数の SQL ステートメントが繰り返される場合があります。sql タグを使用して再利用可能な SQL フラグメントを定義し、include タグを使用して再利用できます。\n1 2 3 4 5 6 7 \u0026lt;!-- id属性を通じてステートメントを一意に識別する --\u0026gt; \u0026lt;sql id = \u0026#34;commonCode\u0026#34;\u0026gt; \u0026lt;!-- SQL语句 --\u0026gt; \u0026lt;/sql\u0026gt; \u0026lt;!-- refid 属性は参照ステートメントを指定します。 --\u0026gt; \u0026lt;include refid = \u0026#34;commonCode\u0026#34; /\u0026gt; ","date":"2025-01-13T21:06:03+09:00","permalink":"https://blog.yexca.net/ja/archives/216/","title":"MyBatis 使い方"},{"content":" この記事の一部は機械翻訳を使ったよ\nMyBatis シリーズ\nインストールと開始方法: この記事\n使い方: https://blog.yexca.net/ja/archives/216 MyBatis は JDBC 開発を簡素化する優れた永続層フレームワークです。\nMySQL インストール (Windows) ダウンロード: https://dev.mysql.com/downloads/mysql/ ZIP Archive をダウンロード\n解凍し、環境変数 MYSQL_HOME PATH パス %MYSQL_HOME%\\bin を設定します。\n管理者権限で cmd を開き、mysql と入力して、設定が成功したかどうかを確認します。\nMySQL を初期化する コマンドを入力してください\n1 mysqld --initialize-insecure しばらく待つと、MySQL ディレクトリに data フォルダが生成されます。\nMySQL サービスを登録する コマンド\n1 mysqld -install MySQL サービスを開始する コマンド\n1 2 3 4 # mysqlサービスを開始する net start mysql # mysqlサービスを停止する net stop mysql root パスワードを変える コマンド\n1 mysqladmin -u root password 1234 ログインパラメータ\n1 2 3 4 mysql -u ユーザー名 -p パスワード -h 接続するMySQLサーバーのIPアドレス (デフォルト127.0.0.1) -P ポート番号 (デフォルト 3306) # 例えば mysql -u root -p # 実行後、パスワードの入力を求められます 入門例 まず、SpringBoot プロジェクトを作成し、依存関係「MyBatis Framework」と「MySQL Driver」を選択します。\nデータベース 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 create database mybatis; use mybatis; create table user( id int unsigned primary key auto_increment comment \u0026#39;ID\u0026#39;, name varchar(100) comment \u0026#39;名前\u0026#39;, age tinyint unsigned comment \u0026#39;年齢\u0026#39;, gender tinyint unsigned comment \u0026#39;性別, 1:男, 2:女\u0026#39;, phone varchar(11) comment \u0026#39;電話番号\u0026#39; ) comment \u0026#39;ユーザーテーブル\u0026#39;; insert into user(id, name, age, gender, phone) VALUES (null,\u0026#39;白眉鹰王\u0026#39;,55,\u0026#39;1\u0026#39;,\u0026#39;18800000000\u0026#39;); insert into user(id, name, age, gender, phone) VALUES (null,\u0026#39;金毛狮王\u0026#39;,45,\u0026#39;1\u0026#39;,\u0026#39;18800000001\u0026#39;); insert into user(id, name, age, gender, phone) VALUES (null,\u0026#39;青翼蝠王\u0026#39;,38,\u0026#39;1\u0026#39;,\u0026#39;18800000002\u0026#39;); insert into user(id, name, age, gender, phone) VALUES (null,\u0026#39;紫衫龙王\u0026#39;,42,\u0026#39;2\u0026#39;,\u0026#39;18800000003\u0026#39;); insert into user(id, name, age, gender, phone) VALUES (null,\u0026#39;光明左使\u0026#39;,37,\u0026#39;1\u0026#39;,\u0026#39;18800000004\u0026#39;); insert into user(id, name, age, gender, phone) VALUES (null,\u0026#39;光明右使\u0026#39;,48,\u0026#39;1\u0026#39;,\u0026#39;18800000005\u0026#39;); application.properties 1 2 3 4 5 6 7 8 9 10 # データベース接続情報を構成する # ドライバークラス名 spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver # データベース接続URL spring.datasource.url=jdbc:mysql://localhost:3306/mybatis # データベースに接続するためのユーザー名 spring.datasource.username=root # データベースに接続するためのパスワード spring.datasource.password=1234 User クラス 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 public class User { private Integer id; private String name; private short age; private short gender; private String phone; public User() { } public User(Integer id, String name, short age, short gender, String phone) { this.id = id; this.name = name; this.age = age; this.gender = gender; this.phone = phone; } public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public short getAge() { return age; } public void setAge(short age) { this.age = age; } public short getGender() { return gender; } public void setGender(short gender) { this.gender = gender; } public String getPhone() { return phone; } public void setPhone(String phone) { this.phone = phone; } @Override public String toString() { return \u0026#34;User{\u0026#34; + \u0026#34;id=\u0026#34; + id + \u0026#34;, name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, age=\u0026#34; + age + \u0026#34;, gender=\u0026#34; + gender + \u0026#34;, phone=\u0026#39;\u0026#34; + phone + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#39;}\u0026#39;; } } UserMapper インタフェース 1 2 3 4 5 6 @Mapper // 実行時に、インターフェースの実装クラスオブジェクト（プロキシオブジェクト）が自動的に生成され、管理のために IOC コンテナに引き渡されます。 public interface UserMapper { // ここではアノテーションを使用してSQL文を記述します @Select(\u0026#34;select * from user\u0026#34;) public List\u0026lt;User\u0026gt; list(); } テストクラス 1 2 3 4 5 6 7 8 9 10 11 12 @SpringBootTest class MybatisStartApplicationTests { @Autowired private UserMapper userMapper; @Test void contextLoads() { List\u0026lt;User\u0026gt; list = userMapper.list(); list.forEach(System.out::println); } } データベース接続プール データベース接続プールは、データベース接続 (Connection) の割り当てと管理を担当するコンテナです。\nこれにより、アプリケーションは新しいデータベース接続を確立する代わりに、既存のデータベース接続を再利用できます。\nアイドル時間が最大アイドル時間を超える接続を解放して、接続の解放の失敗によるデータベース接続の喪失を回避します。\n利点: リソースの再利用とシステム応答速度の向上\n公式標準インターフェース: DataSource\n一般的な製品: Hikari (SpringBoot デフォルト)、Druid\nLombok 上記の例では、User クラスはいくつかの属性のみを定義していますが、多くのメソッドが必要なため、コードが肥大化しています。この目的には、Lombok を使用できます。\nLombok は、アノテーションを通じてコン​​ストラクター、getter/setter、equals、hashcode、toString などのメソッドを自動的に生成し、ログ変数を自動的に生成して Java 開発を簡素化し、効率を向上させる実用的な Java クラス ライブラリです。\n注釈 効果 @Getter/@Setter すべてのプロパティに get/set メソッドを提供する @ToString クラスの読みやすい toString メソッドを自動的に生成します @EqualsAndHashCode クラスが所有する非静的フィールドに基づいて、equals メソッドと hashCode メソッドを自動的にオーバーライドします。 @Data より包括的なコード生成機能を提供します(@Getter+@Setter+@ToString +@EqualsAndHashCode) @NoArgsConstructor エンティティクラスのパラメータなしのコンストラクタメソッドを生成する @AllArgsConstructor static 変更フィールドに加えて、エンティティ クラスのパラメータを持つコンストラクタ メソッドを生成します。 Lombok の導入 依存関係を導入します。バージョン番号は不要で、SpringBoot によって設定されます。\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; User クラス 1 2 3 4 5 6 7 8 9 10 @Data @NoArgsConstructor @AllArgsConstructor public class User { private Integer id; private String name; private short age; private short gender; private String phone; } Lombok はコンパイル時に対応する Java コードを自動的に生成します。Lombok を使用するにはプラグインをインストールする必要がありますが、IDEA ではデフォルトでインストールされています。\n","date":"2025-01-12T23:59:48+09:00","permalink":"https://blog.yexca.net/ja/archives/215/","title":"MyBatis のインストールと開始方法"},{"content":" 音に感じてシリーズ 曲 翻訳 リンク 僕が死のうと思ったのは 略 この記事 あくあ色ぱれっと 略 https://blog.yexca.net/ja/archives/219 恋の押し売り 略 https://blog.yexca.net/ja/archives/220 17さいのうた 略 https://blog.yexca.net/ja/archives/224 drop 恋に落ちた https://blog.yexca.net/ja/archives/230 生きるを選んだ私へ 略 https://blog.yexca.net/ja/archives/239 rainy lady 雨女 https://blog.yexca.net/ja/archives/249 恋しくなったら手を叩こう 略 https://blog.yexca.net/ja/archives/250 まえがき てっ、この記事は日本語なので、もう日本語の勉強じゃない？書く必要がないかもね\nまあ、とりあえず歌詞を書こうかな\n動画 歌詞 僕ぼくが死しのうと思おもったのは　ウミネコが桟さん橋ばしで鳴ないたから\n波なみの随意ずいいに浮うかんで消きえる　過去かこも啄ついばんで飛とんでいけ\n僕ぼくが死しのうと思おもったのは　誕生日たんじょうびに杏あんずの花はなが咲さいたから\nその木こ漏もれ日びでうたた寝ねしたら　虫むしの死し骸がいと土つちになれるかな\n薄荷はっか飴あめ　漁港ぎょこうの灯台とうだい　錆さびたアーチ橋ばし　捨すてた自転車じてんしゃ\n木造もくぞうの駅えきのストーブの前まえで　どこにも旅たび立だてない心こころ\n今日きょうはまるで昨日きのうみたいだ　明日あすを変かえるなら今日きょうを変かえなきゃ\n分かってる　分かってる　けれど\n僕ぼくが死しのうと思おもったのは　心こころが空からっぽになったから\n満みたされないと泣ないているのは　きっと満みたされたいと願ねがうから\n僕ぼくが死しのうと思おもったのは　靴紐くつひもが解ほどけたから\n結むすびなおすのは苦手にがてなんだよ　人ひととの繋つながりもまた然しかり\n僕ぼくが死しのうと思おもったのは　少年しょうねんが僕ぼくを見みつめていたから\nベッドの上うえで土下座どげざしてるよ　あの日ひの僕ぼくにごめんなさいと\nパソコンの薄うす明あかり　上階じょうかいの部屋へやの生活音せいかつおん\nインターフォンのチャイムの音おと　耳みみを塞ふせぐ鳥とりかごの少年しょうねん\n見みえない敵てきと戦たたかってる　六畳ろくじょう一間ひとまのドンキホーテ\nゴールはどうせ醜みにくいものさ\n僕ぼくが死しのうと思おもったのは　冷つめたい人ひとと言いわれたから\n愛あいされたいと泣ないているのは　人ひとの温ぬくもりを知しってしまったから\n僕ぼくが死しのうと思おもったのは　あなたが奇麗きれいに笑わらうから\n死しぬことばかり考かんがえてしまうのは　きっと生いきる事ことに真面目まじめすぎるから\n僕ぼくが死しのうと思おもったのは　まだあなたに出会であってなかったから\nあなたのような人ひとが生うまれた　世界せかいを少すこし好すきになったよ\nあなたのような人ひとが生いきてる　世界せかいに少すこし期待きたいするよ\n","date":"2025-01-11T01:10:51+09:00","permalink":"https://blog.yexca.net/ja/archives/214/","title":"音に感じて - 《僕が死のうと思ったのは》"},{"content":" 📢 この記事は ChatGPT によって翻訳されました Python でのパッケージ化は今の OS 環境に依存する。\nWindows なら .exe、Linux なら ELF 形式になる。\nクロスプラットフォームの出力は非対応。\nインストール pip でインストール：\n1 2 3 4 5 6 7 8 9 pip install pyinstaller ~~~ ## 単一ファイルとしてビルド `--onefile` を指定すればOK： ```bat pyinstaller --onefile main.py よく使うオプション（Windows 向け） --windowed: ターミナルを表示しない（GUI アプリ向け） --icon=icon.ico: アイコン追加 --hidden-import: 必要な依存を手動で指定 --add-data: 追加のリソースファイルを含める --debug: デバッグ情報を出力 複数ファイル構成でビルド --onedir でディレクトリ形式に：\n1 pyinstaller --onedir main.py この場合、依存ファイルは _internal フォルダに入ってて、ちょっと扱いづらい。\npyinstaller 6.1.0 以上なら --contents-directory が使える：\n1 pyinstaller --contents-directory . .\\main.py これで依存と実行ファイルが同じフォルダ内にまとまる。\nファイルの追加（設定ファイルなど） たとえば project/conf/settings.json を一緒に含めたい場合：\nまずは複数ファイル形式でビルド：\n1 pyinstaller --name my_program --contents-directory . .\\main.py すると my_program.spec ってファイルが生成される。これを編集：\n1 datas=[(\u0026#39;conf/settings.json\u0026#39;, \u0026#39;conf/\u0026#39;)], 編集したら、dist/ フォルダの中を一度消してから（消さなくてもOK）再ビルド：\n1 pyinstaller my_program.spec 実際のプロジェクト この方法で、 このソフト を exe にできた （でもまだエラーハンドリング入れてない）\n参考記事 https://www.cnblogs.com/yqbaowo/p/17863429.html ","date":"2025-01-07T17:26:09+09:00","permalink":"https://blog.yexca.net/ja/archives/213/","title":"Pythonでpyinstallerを使って実行ファイル化する"},{"content":" この記事の一部は機械翻訳を使ったよ\nまえがき 今日は最近設計した半透明、すりガラスと丸みを帯びた角についてまとめようと思っていたけど、突然2023年12月01日何かを作ったことを思い出したので、それも一緒に再編成しようと思う\nウェブサイトの背景 現代の (アニメ風) ウェブページは背景が必要だ\n1 2 3 4 5 6 7 8 body{ background-image: url(\u0026#39;../img/77194247_p0.jpg\u0026#39;); background-size: cover; background-attachment: fixed; /* 固定 */ background-repeat: no-repeat; /* 繰り返さない */ padding: 0; margin: 0; } 半透明とすりガラス そして、背景にマスクを加えて、半透明効果とすりガラス効果を実現する\n1 2 3 4 5 6 7 8 9 10 11 .layout { /* display: flex; */ margin: 0; padding: 0; display: flex; width: 100vw; height: 100vh; backdrop-filter: blur(2px); /* 背景ぼかし効果 */ -webkit-backdrop-filter: blur(2px); /* Safari サポート */ background: rgba(0, 0, 0, 0.4); /* 半透明黒い背景 */ } ウェブページのリニューアル そういえば、文章を書くのは面倒だな。プログラムしていると邪魔されて、プログラムが終わった時はとても疲れてしまったので、書きたくなくなった。だから今は気軽に文章を書いている\nプロジェクトのリング: https://github.com/yexca/MusicPlayer-Twinkle 顺便更新了下之前的文章 https://blog.yexca.net/archives/116/ 用此方法加了个示例: https://twinkle.yexca.net ところで、以前の文章も更新したよ (簡体字中国語で) https://blog.yexca.net/archives/116/ その方法で例を作った: https://twinkle.yexca.net カード効果 これも現代的な設計だよねー\n1 2 3 4 5 6 7 8 9 10 .card { width: 300px; padding: 20px; background-color: rgba(255, 255, 255, 0.5); /* 半透明白い背景 */ border-radius: 15px; /* 丸みを帯びた角 */ box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); /* 影 */ backdrop-filter: blur(10px); /* 背景ぼかし効果 */ border: 1px solid rgba(255, 255, 255, 0.3); /* ボーダー */ color: pink; /* 文字の色 */ } まあ、時間があればカードのデザインを基にしてプロジェクトを進めよう (また新しい沼にハマっちゃった)\nTwinkle ちなみに、プロジェクトの内容は Twinkle の音楽、詳しくはこちら\nhttps://twinkle130527.wixsite.com/twinkle https://www.dojin-music.info/circle/1255 SoundCloud\nhttps://soundcloud.com/twintwinkles ","date":"2025-01-05T16:19:36+09:00","permalink":"https://blog.yexca.net/ja/archives/212/","title":"すりガラス効果"},{"content":" 📢 この記事は ChatGPT によって翻訳されました 2025-05-18 更新\nSQLite版も書いた。もうデータベース設定しなくていい： https://blog.yexca.net/archives/248 3日かけてとりあえず動くやつを作ってみた。\nただしエラー処理はしてないから、バグったら 再起動してね。\nGitHub リポジトリはこちら： https://github.com/yexca/PixivDownloader-MySQL はじめに これは ダウンロード済みのイラストを DB に記録する ってところから始まってて、\nずっと同じ作業してるのアホらしくなって「コンピュータにやらせよう」ってなったんだよね。\nたまたま最近「プログラム作りたいな」って思ってたし、\nついでにこの前作ってたやつ（ https://github.com/yexca/yasumiProject ）にも満足してなかったし、\n年末年始で時間あったから、よっしゃやるかって感じで。\n説明 一応形にはなったけど、エラー処理はないし、\nGUI アプリとしては初めてちゃんと作ったやつだから、コードはぐちゃぐちゃ。\nなので整理も多言語対応も放棄した（笑）\nしかも作ってる途中で「これ SQLite でよくね？」って気づいたんだけど、\nもう半分以上作っちゃったから「まあ最後までやるか」って流れに。\n本当は exe にもしたかったけど、設定ファイル使ってるから面倒だし、\nしかも最初ビルドしたやつがウイルス扱いされて焦ったし\nってことで放置。\nUI 背景画像出典： https://www.pixiv.net/artworks/83273073 ホーム画面： 設定画面： 設定 もともとの DB をベースに作ったので、カスタマイズ性はほぼない。\nDB のテーブル作成 SQL は以下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 CREATE TABLE pic ( ID varchar(99), -- 一意な識別子 name varchar(255), -- 作者の名前 downloadedDate datetime, -- ダウンロード／更新日 lastDownloadID varchar(255), -- 最新の作品ID platform varchar(50), -- プラットフォーム名 url varchar(255), -- リンク PRIMARY KEY(ID) )ENGINE=InnoDB DEFAULT CHARSET=utf8mb4; ~~~ Pixiv の API はログインが必要だけど、 IDとパスワードでのログインは不可。 この方法で Auth Token を取得する：https://gist.github.com/ZipFile/c9ebedb224406f4f11845ab700124362 背景画像は Git に入れてない。パスは `app\\resources\\images\\background.png` あと Python が必要。依存関係は pip で： ```bash pip install -r requirements.txt 使い方 実行：\n1 python main.py Pixiv の認証画面と設定画面で必要な設定を済ませたらホームへ戻る。\n画面に Pixiv の ユーザーID または 作品ID を入力すると、 そのユーザーのすべての作品を自動で取得してくれる。\nおわりに 正直、自分でもこのアプリ使ってないけど、 開発経験の一歩としてはなかなか良かったと思ってる。\n","date":"2025-01-03T20:05:44+09:00","permalink":"https://blog.yexca.net/ja/archives/211/","title":"Pixiv ダウンローダー"},{"content":" 📢 この記事は ChatGPT によって翻訳されました はじめに この文章は自分用。タイトルは「2024 年まとめ」ってことになってるけど、近年の生活の気付きや心の流れを記録するために書いてる。\n文章力はそんなにないし、書きたいことはいっぱいあるけど、うまくまとめられないのでこのままでいく。\n2020 から 2024 のこと 2020年あたりから、「時間がめっちゃ早く過ぎる」って感覚が強くなってきた。\nいろいろ経験してるのに、2019年以前の「1日1日をちゃんと生きてた感覚」や「長く感じる感覚」がなくなった気がする。\nでも客観的に見ると、毎年ちゃんといろんなことしてる。特に今年（2024）はほんとにいろいろあった。\n2020 这年高考，之后我开始了第一次远离家乡的生活，大学生活时加入了社团，参加不少活动来着 2021 上半年参加不少社团活动，下半年我更换了手机进入苹果生态、转专业、建立本博客 2022 我在 Switch OLED 刚出时溢价购买并玩得不亦乐乎，同年购入 Quest2 开启 VR 旅途，并编写了一些 VRChat 教程，同时还在年末去了南京市游玩 2023 这一年换校区了，开始参加一些二次元活动，如原神和必胜客、喜茶的联动，后期学校放开也是逛了逛周边地区，参加了软考和日语能力考试，购买了 Google Pixel6 以及开始迷上办卡 2024 这应该是我最精彩的一年，年初开始去深圳实习，在此期间逛 Costco 在深圳的新店、第一次看海、认识到了许多很好的人、逛了华强北、去了香港、逛了澳门、第一次坐船等，我的思想也逐渐转变，回学校、毕业回家后对于他人的态度也有转变，开始和我的家人交流，和家人去了徐州游玩，开始尝试做饭，自己 DIY 物品，考取驾照等，这之后还去了日本，第一次坐飞机，第一次穿二次元衣服出门、第一次参加漫展 (C105) 等等 年々経験値は増えてるのに、主観的には「何もしてないのに時間だけが過ぎた」って思ってしまう。\nそれがちょっとした混乱を生む。\n人生を説明しようとした理論たち ※注意：以下は全部自分の妄想。学術的な根拠は一切ないので、信じすぎないように！\n実は 2023 年後半、院試の勉強しないといけなかったんだけど、目がめちゃくちゃ痛くて、\n一日中起きてられなくなって、寝たり起きたりを繰り返してた。\nそんなときにふと「生活を説明する理論」みたいなものを考え出した。\n状態行動理論 一番最初に思いついたのは「状態行動理論」。\n人の行動って、感情・情報・経験・周囲の影響とか、いろんな変数で決まるんじゃないかって。\nその変数に重みを与えて数値化できれば、かなり高精度で行動を予測できるんじゃないか？\nもしすべての人の状態が分かったら、人生ってもう全部決まってるんじゃないか、って発想。\n最初はただの妄想で遊んでたんだけど、ある日「これ Unity の State Behavior と似てるな」と思って命名した。\n圏理論（サークル理論） それと同時に「影響要素のグループ化」を考えるために圏理論も思いついた。\nネット上でいろんなジャンルにハマってみると、明確に分かれたサークル（圏）があることに気づいた。\nサークルごとに「当然の常識」が違ってて、あるところではすごく普通なことが、他ではめっちゃ驚かれる。\n情報バブル（フィルターバブル）に似てるけど、これは自分が選んだ「関心」で囲まれてるサークルの話。\n名言が刺さる理由 「なんで名言ってこんなに刺さるんだろう」って考えたことない？\nこれも、いろんな人の経験が抽象化されて生まれた言葉で、\n自分がその抽象パターンの別の実装に当てはまるから「めっちゃ分かる！」って感じるんだと思う。\nもっとちゃんと言えば、人間の歴史って膨大すぎて、どんな選択肢も誰かがすでに通った道。\nつまり「絶対正しい」とか「絶対間違ってる」ってことはなくて、状況次第で相対的に正しかったり間違ってたりするだけ。\n信頼理論 最近のお気に入りは「信頼理論」。\n人間社会って信頼の上に成り立ってる。\n横断歩道を渡るとき「ドライバーがちゃんと止まってくれるはず」って信じてる。\nすれ違う人がナイフを出して襲ってこないって信じてる。\n日常のほとんどは「当たり前に信じてること」で成り立ってる。\nまあ、ほかにもいろいろ考えてたけど、全部は思い出せないや。\n理論と行動の乖離 「もし子どもみたいに自由に好きなことができたら、もっと自由を感じられるんじゃないか」\n……でも、たぶんその子どもはもう“ルールの土の中”に埋められてしまったのかもしれない。\n生活のいろんな問題が「理論的に説明できる」ようになったけど、\nそれは問題を解決する助けにはならなかった。むしろ逆効果。\n理論を使って選択肢を全部考える。\n結果、何かを経験しても「あ、これ前に想定してたパターンだな」ってなって、\nまるでゲームで NPC の会話をスキップするように、現実のやりとりにも熱量を感じなくなった。\nだから娯楽に逃げた。散歩、買い物、ランニング、旅行、ゲーム……\nでも「楽しまなきゃ」という義務感があって、純粋に楽しめない。\n心の中では「タスク処理」になってて、\nストレスがたまったら「ストレス値を下げるイベントを配置する」ってだけ。\n自分で自分をマネージしてる。設計者も実行者も自分。\nでもそのシナリオは、感情が抜けた“タスク完了型”の人生になってる。\n何かをするときに「これはルール通りか？」って無意識に考えてて、\n少しでも逸脱すると「良くない」って感じてしまう。\n認められるために正解を探してるのかもしれない。\nそれってまさに、圏理論の一部じゃない？ 自分もまた“説明”の中に閉じ込められてる存在なんじゃないか。\nbilibili の埋め込みが微妙だったから Youtube に変更。\n鹿乃の公式アカウントがあるので、動画元は BV1zr4y1n7sM\nもしかして、これって「うつ」じゃない？って思ったこともある。\n自殺のシミュレーションすらした。\nでも、ふと思い出したのが『僕が死のうと思ったのは』の歌詞：\n「死ぬことばかり考えてしまうのは、きっと生きることに真面目すぎるから」\n——そう、まさにそれ。\n自分はたぶん、人生に対して真面目すぎたんだ。\nほかの歌詞も刺さった：\n「今日はまるで昨日みたいだ」 「見えない敵と戦ってる」 「明日を変えるなら今日を変えなきゃ、分かってる……けど」 「冷たい人と言われたから」 「人の温もりを知ってしまったから」 「あなたのような人が生きてる、世界に少し期待するよ」 でも、自分が人に相談することすらも「理論的に説明できる」って思ってる。\n「こういう条件で質問したら、こう返ってくる」って、API 呼び出しみたいに。\n安心を得ることも予測通りで、あまりに“予定調和”すぎてリアルさがない。\nでも人生って、予定通りにはいかない。\nだからこそ、自分は不確定性が怖くなってた。\nその恐怖を抑えるために、理論を増やして、どんどんルール化していった。\nでも感情は予測できない。理性で封じようとしても限界がある。\nだからこそ、「理論に頼りすぎると壊れる」ってことがわかってきた。\n説明から行動へ 時間は流れる水。\n自分はその水の量ばかり計っていて、温度を確かめるのを忘れてた。\n理論を使ってすべてを整理したつもりだったけど、\nその枠組みが逆に自分を縛ってた。\n自由に行動できるはずなのに、常に見えない“縛り”がある気がして、\n感情も経験も、すべてルールのもとで処理しようとしてた。\nでも、感情ってのは「理論の例外」であっていいんだ。\nそろそろ「自分の感情」を優先していいんだ。\n最初に気づいたのは「理論が役に立たない瞬間がある」ってことだった。\nそして、その気づきすらも理論で説明しようとしてた（笑）\nでも変われる。人は変わる。いろんな要因が重なったとき、方向が変わる。\nたとえば、人と関わることが増えてきた。\n以前の自分は内向的で、対人関係がめんどくさいと思ってたけど、\n理論を通せば「別に違反でもなんでもないし、関わってみてもいいか」って思えた。\nそれが始まりだった。\n最初に「すごくいい人」に出会って、そこから徐々に交流が広がった。\nそして視野も広がって、理論も深まって、選択肢が増えた。\n（同時に怖さも増えたけど、それはリスクとリターンの話）\nいろんなことを試してみるうちに、「理論の正しさ」よりも「感情の納得感」が大事だと気づいた。\nそれが「量的に整理された生活」からの脱却になった。\nとはいえ、それでもまだ足りない。\nなぜなら感情もまた“数値化”できてしまうから。\nある日、リスニング練習中に聞こえてきたこの会話：\nA：どっちがいい？\nB：A がいいんじゃない？\nA：でも B のほうが良くない？（理由付き）\nB：結論決まってんのになんで聞いたの？\n……これが、めちゃくちゃ心に刺さった。\n自分はいつも、もう結論出てるのに、何度も人に確認するタイプ。\n最適解を求めてるわけじゃなくて、「確実さ」がほしいだけ。\n不確実性が怖い。\nでも、たぶん……\nそもそも「自分の目標」って、自分の感情から出たものじゃなかったのかも。\n「こうすれば評価される」「こうすればうまくいく」っていう、理論で作った目標だった。\nだからこれからは、自分の「好き」の重みをもっと増やしていく。\n理論は道具であって、支配者じゃない。\n人生の設計者は自分。楽しむために使うんだ。\n現在 いま、自分は「自由に表現できる」し、「自由に行動できる」\n（もちろん法律は守るけどね）\nこの文章もその一歩。\n以前の自分だったら、こんな考えをまとめるのは恥ずかしかったと思う。\nだから、いくつかのサブ理論はもう忘れてしまった。\nでも今は思うんだ。\n生きるって、プロセスなんだ。\n変えられない事実なら、適応するしかない。\nいろんな人と出会う。\n良い人もいれば、運悪くつらい人もいる。\n悲しい気持ちが続くときって、たぶん「悲しいこと」が一時的に積み重なってるだけ。\n「どんなときも、ちゃんとした姿で登場しよう。すべての経験に本気で向き合う」\n……これは 自己紹介ページ に書いた言葉だけど、\n世界から見れば自分はただの数字かもしれない。\nでも、自分にとっては、自分が“世界そのもの”なんだよ。\n「 万物皆浮云、只要好心情 」\n自分の Atopes を起動しよう。\nやりたいことをやって、ほしいものを買って、行きたい場所に行こう。\n深く考えすぎなくていい。思いっきり自分を出していい。\n今ふと、 https://github.com/RimoChan のアイコンが思い浮かんだ。\n心から「生活を楽しむ」ってこういうことだな。\n楽しく生きるのも1日。つらく生きるのも1日。\nもう内面で自分を消耗するの、やめよう。\nおわりに 来年はどうなるかな？\n最後は、ブログの紹介文で締めよう。\nこの不完全な世界を、理想のカタチにプログラミングしよう！\n","date":"2024-12-31T17:40:09+09:00","permalink":"https://blog.yexca.net/ja/archives/210/","title":"2024 年まとめ"},{"content":" 📢 この記事は ChatGPT によって翻訳されました はじめに 情報を読む機会が増えると、他言語で記事を書きたくなることってあるよね（最近の作品はだいたい多言語対応だし）。\nそれに、卒論で多言語対応を入れて以来、自分が作るツールやデザインもいつのまにか多言語対応を意識するようになってきた。\nたとえば最近書いた https://github.com/yexca/yasumiProject この練習用のプロジェクトにも多言語化を入れてみた（ただし古くさすぎて微妙だった……モダンなやつを https://github.com/yexca/yasumiProject-frontend 別で作成中、できれば完成まで続けたい）。\nそれで、ふと自分のブログを見てみたら、多分一番長く付き合ってる作品なのに、まだ多言語化してなかった。\nもちろん基本的に簡体字で記事を書いてるからってのもあるけど、 https://jekyllblog.yexca.net/ 前のブログでは UI の一部が中国語、一部が英語になってて、正直ごちゃごちゃだったと思う。\n自分は読めるけど、他の人にはちょっとわかりづらいかもって感じだった。\nJekyll のときは頑張って多言語化しようとしたけど、うまくいかなかったので Hugo に乗り換えた（Hugo はネイティブに多言語サポートしてるから）。\nただ、テーマによって構造が結構違う。自分が今使ってるテーマはカテゴリ・タグの扱いが前とは全然違うから、カスタムする必要がある。\nこの記事、結構ざっくりしてる。\nというのも、多言語設定はほぼテーマ依存で、自分もテーマのサンプルを参考にして設定したから、あんまり書くことがない。\n（とはいえ、Hugo の公式ドキュメントはめちゃくちゃ丁寧）\n環境 Docker で Hugo のコンテナを使ってるから、環境構築はほぼノータッチ。\n使ってる環境については https://blog.yexca.net/archives/182/#%E5%8D%9A%E5%AE%A2 をどうぞ。\nブログの新規作成 新しい Hugo サイトを作成：\n1 hugo new site blogName フォルダに移動：\n1 cd blogName Git 初期化：\n1 git init テーマを追加（ここでは hugo-theme-stack を使用）：\n1 git submodule add https://github.com/CaiJimmy/hugo-theme-stack/ themes/hugo-theme-stack hugo.toml にテーマ設定を追加：\n1 theme = \u0026#39;hugo-theme-stack\u0026#39; ローカルでプレビュー：\n1 hugo server ドラフト記事も含めてプレビューする場合：\n1 hugo server -D 一部の変更（設定ファイルやページ構成など）が反映されない場合はキャッシュを削除：\n1 hugo --cleanDestinationDir 本番ビルド（public/ フォルダに生成される）：\n1 hugo 多言語対応 設定ファイル（自分は yml 形式を使用）にて、デフォルト言語を指定：\n1 2 defaultContentLanguage: \u0026#39;zh-cn\u0026#39; # デフォルトの言語コード defaultContentLanguageInSubdir: false # デフォルト言語に言語コード付きのURLを使うかどうか 各言語の設定は以下のように：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 languages: zh-cn: contentDir: \u0026#39;content/zh-cn\u0026#39; disabled: false languageCode: \u0026#39;zh-cn\u0026#39; languageDirection: \u0026#39;ltr\u0026#39; languageName: \u0026#39;简体中文\u0026#39; title: \u0026#34;yexca\u0026#39;Blog\u0026#34; weight: 1 zh-tw: contentDir: \u0026#39;content/zh-tw\u0026#39; disabled: false languageCode: \u0026#39;zh-tw\u0026#39; languageDirection: \u0026#39;ltr\u0026#39; languageName: \u0026#39;繁體中文\u0026#39; title: \u0026#34;yexca\u0026#39;Blog\u0026#34; weight: 2 フォントの多言語対応については： https://blog.yexca.net/archives/240 記事の書き方 Jekyll と違って Hugo の記事作成はちょっと複雑。 特に多言語化すると、フォルダ構成やルールが増えるけど、そのぶん柔軟性も高い。\nまず、上で設定した各言語に合わせて content/zh-cn や content/zh-tw といったフォルダを作成する必要がある。\nテーマによって、どのフォルダに記事を置くかが決まってることもある。たとえば stack テーマの場合：\n1 2 3 params: mainSections: - posts つまり、簡体字の投稿は content/zh-cn/posts に置くのが推奨される。 （他にも指定されてるフォルダがある場合は、テーマの例を見てね）\n記事作成例（タイムゾーンを Asia/Tokyo に指定して新規作成）：\n1 TZ=\u0026#34;Asia/Tokyo\u0026#34; hugo new content/zh-cn/posts/test.md タイムゾーンを指定しない場合は UTC になる。 自分は Jekyll に慣れてるから、いちいち時間を書くのが面倒でこうしてる。\nテンプレートは blogName/archetypes/ にあるので、yml 形式に変更することも可能。\n参考記事 Hugo - Quick start https://stack.jimmycai.com/guide/ Hugo - Multilingual mode ","date":"2024-12-27T23:11:45+09:00","permalink":"https://blog.yexca.net/ja/archives/209/","title":"Hugo でブログの多言語対応をする"},{"content":" この記事の一部は機械翻訳を使ったよ\nGo バックエンドのシンプルな (非技術的なフレームワーク) 実装\n~~皆さんご存知のとおり、~~バックエンド開発は一般的にインターフェース指向開発、つまり CRUD エンジニアです。この記事では、Go を使用して、データベースからデータを読み取り、JSON データを返す方法について説明します。\nデータベース この例では、MySQL データベースのカテゴリ テーブルからカテゴリ名と ID を読み取ります。テーブル構造は次のとおりです。\n1 2 3 4 5 6 DROP TABLE IF EXISTS categories ; CREATE TABLE categories ( id INT AUTO_INCREMENT PRIMARY KEY, name VARCHAR(255) NOT NULL, description VARCHAR(255) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4; プロジェクト構造 この例のプロジェクト構造は次のようになります。\n1 2 3 4 5 6 7 8 9 10 11 12 13 project/ ├── database/ // データベースパッケージ │ └── database.go // データベース接続 ├── handler/ // ハンドラパッケージ │ └── category.go // カテゴリ関連のインターフェース ├── model/ // データモデルパッケージ │ ├── category.go // カテゴリテーブルモデル │ └── response.go // レスポンスデータモデル ├── router/ // ルーティングパッケージ │ └── router.go // ルーティング設定 ├── utils // ツールキット │ └── response.go // 統合レスポンス ├── main.go // プログラムエントリ 次にディレクトリについて説明します\ndatabase このパッケージはデータベースへの接続を管理します\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 // database.go package database import ( \u0026#34;database/sql\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; _ \u0026#34;github.com/go-sql-driver/mysql\u0026#34; ) var DB *sql.DB func InitDB() { var err error dsn := \u0026#34;username:password@tcp(address:3306)/name?charset=utf8\u0026#34; DB, err = sql.Open(\u0026#34;mysql\u0026#34;, dsn) if err != nil { log.Fatalf(\u0026#34;Failed to open database: %v\u0026#34;, err) } // Test Connect err = DB.Ping() if err != nil { log.Fatalf(\u0026#34;Failed to ping database: %v\u0026#34;, err) } fmt.Println(\u0026#34;Successfully connected Database!\u0026#34;) } handler このパッケージは、特定の処理のロジック（3 層アーキテクチャの service に似ています）を処理して、データベース処理も階層化できます（Mapper に似ています）が、これは単なる簡単な例です、それだけです〜\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 // category.go package handler import ( \u0026#34;net/http\u0026#34; \u0026#34;project/database\u0026#34; \u0026#34;project/model\u0026#34; \u0026#34;project/utils\u0026#34; ) func GetCategories(w http.ResponseWriter, r *http.Request) { // Select Database rows, err := database.DB.Query(\u0026#34;select id,name from categories\u0026#34;) if err != nil { http.Error(w, \u0026#34;Failed to query Categories\u0026#34;, http.StatusInternalServerError) return } defer rows.Close() // analyze data var categories []model.Category for rows.Next() { var category model.Category err = rows.Scan(\u0026amp;category.Id, \u0026amp;category.Name) if err != nil { utils.JSONResponse(w, http.StatusInternalServerError, \u0026#34;Failed to analyze Categories\u0026#34;, nil) //http.Error(w, \u0026#34;Failed to analyze Categories\u0026#34;, http.StatusInternalServerError) return } categories = append(categories, category) } // return JSON //w.Header().Set(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;) //json.NewEncoder(w).Encode(categories) utils.JSONResponse(w, http.StatusOK, \u0026#34;\u0026#34;, categories) } コメントアウトされた内容は統合レスポンスインターフェースには適用されず、JSON が直接返されます。\nmodel ここでのデータモデルは、一般的にフロントエンドから受け取るもの、データベースから受け取るもの、フロントエンドに返すものの 3 つに分けられます。これは単純な例なので、細かくは説明していません。\n1 2 3 4 5 6 7 8 // category.go package model type Category struct { Id int `json:\u0026#34;id\u0026#34;` Name string `json:\u0026#34;name\u0026#34;` Description string `json:\u0026#34;description\u0026#34;` } 応答のデータモデルは\n1 2 3 4 5 6 7 package model type Response struct { Code int `json:\u0026#34;code\u0026#34;` Msg string `json:\u0026#34;msf\u0026#34;` Data interface{} `json:\u0026#34;data\u0026#34;` } router このパッケージはルーティング、つまり、どのパスにアクセスして対応する処理ロジックを指定するかを管理します（3 層アーキテクチャの controller に似ています）\n1 2 3 4 5 6 7 8 9 10 11 12 13 // router.go package router import ( \u0026#34;github.com/gorilla/mux\u0026#34; \u0026#34;project/handler\u0026#34; ) func InitRouter() *mux.Router { router := mux.NewRouter() router.HandleFunc(\u0026#34;/categories\u0026#34;, handler.GetCategories).Methods(\u0026#34;GET\u0026#34;) return router } utils このパッケージはツールクラスであり、一般的なツールを定義するために使用されます\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // response.go package utils import ( \u0026#34;encoding/json\u0026#34; \u0026#34;log\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;project/model\u0026#34; ) func JSONResponse(w http.ResponseWriter, code int, message string, data interface{}) { w.Header().Set(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json; charset=utf-8\u0026#34;) w.WriteHeader(http.StatusOK) err := json.NewEncoder(w).Encode(model.Response{Code: code, Msg: message, Data: data}) if err != nil { log.Fatal(err) return } } main プログラムエントリー\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // main.go package main import ( \u0026#34;log\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;project/database\u0026#34; \u0026#34;project/router\u0026#34; ) func main() { // init Database database.InitDB() // Init Router r := router.InitRouter() // start log.Println(\u0026#34;Starting server on port 8848\u0026#34;) log.Fatal(http.ListenAndServe(\u0026#34;:8848\u0026#34;, r)) } go run main.go を実行すると、プログラムはポート 8848 をリッスンします。\n","date":"2024-12-22T22:07:15+08:00","permalink":"https://blog.yexca.net/ja/archives/208/","title":"GoLang バックエンドを使い始める"},{"content":" この記事の一部は機械翻訳を使ったよ\nGolang シリーズ\nHello GoLang: https://blog.yexca.net/ja/archives/154 GoLang (var and const) 変数と定数: https://blog.yexca.net/ja/archives/155 GoLang (func) 関数: https://blog.yexca.net/ja/archives/156 GoLang (slice and map) スライス: https://blog.yexca.net/ja/archives/160 GoLang (OOP) オブジェクト指向: https://blog.yexca.net/ja/archives/162 GoLang (reflect) リフレクション: https://blog.yexca.net/ja/archives/204 GoLang (struct tag) 構造タグ: https://blog.yexca.net/ja/archives/205 GoLang (goroutine) ゴルーチン: https://blog.yexca.net/ja/archives/206 GoLang (channel) チャンネル: この記事\nゴルーチン (Goroutine) は channel を通じてデータを転送できます。参照型 channel は複数の Goroutine が通信するために使用できます。同時実行の安全性を確保するために、内部で同期を実装します。\nこれは、 RabbitMQ (簡体字中国語) に似ています (これは学習に便宜上の例えです、実は異なるものです)\n変数を定義する channel は参照型です。関数をコピーまたは呼び出すと、同じ channel オブジェクトが参照されます。ゼロ値は nil です。\nmake() 関数によって作成される。例えば\n1 2 3 c := make(chan int) // 容量を 3 に追加 c := make(chan int, 3) 容量が 0 の場合、channel はバッファリングされず、読み取りと書き込みがブロックされます。 容量が 0 より大きい場合、キャッシュがあり、非ブロッキングであり、いっぱいになるまでブロックされません。\nデータの送受信には \u0026lt;- を使用します\n1 2 3 4 5 6 7 8 // channel にデータを送信する channel \u0026lt;- 3 // 受信して破棄 \u0026lt;-channel // スペースがないことに注意してください // 値を受け取って変数に割り当てる x := \u0026lt;-channel // 受信して変数に割り当て、受信が成功したかどうか（channel が空かどうか）を判定します data, flag := \u0026lt;-channel バッファリングなし 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package main import \u0026#34;fmt\u0026#34; func main() { c := make(chan int) go func() { defer fmt.Println(\u0026#34;A.defer\u0026#34;) c \u0026lt;- 6 fmt.Println(\u0026#34;A running\u0026#34;) }() num := \u0026lt;-c fmt.Println(\u0026#34;num =\u0026#34;, num) fmt.Println(\u0026#34;main over\u0026#34;) } バッファリング 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { c := make(chan int, 3) go func() { defer fmt.Println(\u0026#34;A over\u0026#34;) for i := 0; i \u0026lt; 3; i++ { c \u0026lt;- i fmt.Println(\u0026#34;A goroutine, i =\u0026#34;, i, \u0026#34;len =\u0026#34;, len(c), \u0026#34;cap =\u0026#34;, cap(c)) } }() time.Sleep(2 * time.Second) for i := 0; i \u0026lt; 3; i++ { num := \u0026lt;-c fmt.Println(\u0026#34;main, num =\u0026#34;, num) } fmt.Println(\u0026#34;main over\u0026#34;) } channel を閉じる close() で閉じる\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package main import \u0026#34;fmt\u0026#34; func main() { c := make(chan int, 5) go func() { for i := 0; i \u0026lt; 5; i++ { c \u0026lt;- i } // 閉じる close(c) }() for { if data, ok := \u0026lt;-c; ok { fmt.Println(data) } else { break } } fmt.Println(\u0026#34;Main Finished\u0026#34;) } range の使用 上記の main の for ループは、range を使用して短縮することができます。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package main import \u0026#34;fmt\u0026#34; func main() { c := make(chan int, 5) go func() { for i := 0; i \u0026lt; 5; i++ { c \u0026lt;- i } close(c) }() //for { // if data, ok := \u0026lt;-c; ok { // fmt.Println(data) // } else { // break // } //} for data := range c { fmt.Println(data) } fmt.Println(\u0026#34;Main Finished\u0026#34;) } 一方向 channel デフォルトでは、channel は双方向、つまり読み取りと書き込みが可能です。チャネルの方向を読み取り専用または書き込み専用に指定することもできます。\n1 2 3 4 5 var c chan int // 通常の双方向チャネルを宣言する // c1 は書き込みのみ可能 var c1 chan\u0026lt;- int // c2 は読み取り専用です var c2 \u0026lt;-chan int 双方向チャネルを一方向チャネルに変換することは可能ですが、その逆はできません。つまり、関数パラメータを一方向として定義し、それを双方向に渡すことができます。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // chan\u0026lt;- // 書き込みのみ func counter(out chan\u0026lt;- int) { defer close(out) for i := 0; i \u0026lt; 5; i++ { out \u0026lt;- i // 相手が読んでいない場合はブロックします } } // \u0026lt;-chan // 読み取り専用 func printer(in \u0026lt;-chan int) { for num := range in { fmt.Println(num) } } func main() { c := make(chan int) // 双方向 go counter(c) // プロデューサー printer(c) // 消費者 fmt.Println(\u0026#34;done\u0026#34;) } select select は複数の channel 上のデータ フローを監視できます。構文は switch に似ていますが、各 case ステートメントには IO 操作が含まれている必要があります。\n通常は for{} コードブロック内に置く\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 package main import \u0026#34;fmt\u0026#34; func main() { c := make(chan int) quit := make(chan int) go func() { for i := 0; i \u0026lt; 10; i++ { fmt.Println(\u0026lt;-c) } quit \u0026lt;- 0 }() // main x, y := 1, 1 for { select { case c \u0026lt;- x: tmp := x x = y y = tmp + y case \u0026lt;-quit: fmt.Println(\u0026#34;quit\u0026#34;) return // デフォルトを設定することもできますが、この例では不要です } } } ","date":"2024-12-21T14:52:55+08:00","permalink":"https://blog.yexca.net/ja/archives/207/","title":"GoLang チャンネル"},{"content":" この記事の一部は機械翻訳を使ったよ\nGolang シリーズ\nHello GoLang: https://blog.yexca.net/ja/archives/154 GoLang (var and const) 変数と定数: https://blog.yexca.net/ja/archives/155 GoLang (func) 関数: https://blog.yexca.net/ja/archives/156 GoLang (slice and map) スライス: https://blog.yexca.net/ja/archives/160 GoLang (OOP) オブジェクト指向: https://blog.yexca.net/ja/archives/162 GoLang (reflect) リフレクション: https://blog.yexca.net/ja/archives/204 GoLang (struct tag) 構造タグ: https://blog.yexca.net/ja/archives/205 GoLang (goroutine) ゴルーチン: この記事\nGoLang (channel) チャンネル: https://blog.yexca.net/ja/archives/207 プロセス -\u0026gt; スレッド -\u0026gt; コルーチン\nコルーチン (coroutine) は軽量スレッドとも呼ばれます。システム リソースを使い果たすことなく、数万のコルーチンを簡単に作成できます。複数のコルーチンは、スレッドに割り当てられたコンピューター リソースを共有します。\nGo 言語は、ゴルーチン (goroutine) と呼ばれるコルーチンをネイティブにサポートしています。Go の並行性は、goroutine と channel を通じて実装されます。\ngoroutine を作成する go キーワードでゴルーチンを開始する\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func newTask() { i := 0 for { fmt.Println(\u0026#34;newTask goroutine i =\u0026#34;, i) i++ time.Sleep(1 * time.Second) } } func main() { go newTask() i := 0 for { fmt.Println(\u0026#34;main goroutine i =\u0026#34;, i) i++ time.Sleep(1 * time.Second) } } 匿名関数の使用 もちろん、匿名関数を使用することもできます\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { go func() { defer fmt.Println(\u0026#34;A.defer\u0026#34;) func() { defer fmt.Println(\u0026#34;B.defer\u0026#34;) fmt.Println(\u0026#34;B\u0026#34;) }() // 匿名関数の実行を示します fmt.Println(\u0026#34;A\u0026#34;) }() time.Sleep(2 * time.Second) } 匿名関数は戻り値に実体パラメータを持つこともできますが、goroutine の戻り値は channel を介して送信する必要があります。次の例では、実体パラメータのみを示しています。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { go func(a, b int) { fmt.Println(\u0026#34;a =\u0026#34;, a, \u0026#34;b =\u0026#34;, b) }(10, 20) time.Sleep(2 * time.Second) } 退出 メインの goroutine が終了すると、他の動作中の goroutine も自動的に終了します。\nただし、runtime.Goexit() を使用して、現在の goroutine の実行を直ちに終了することもできます (defer が実行されます)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;runtime\u0026#34; \u0026#34;time\u0026#34; ) func main() { go func() { defer fmt.Println(\u0026#34;A.defer\u0026#34;) func() { defer fmt.Println(\u0026#34;B.defer\u0026#34;) runtime.Goexit() // ゴルーチンを終了する fmt.Println(\u0026#34;B\u0026#34;) }() // 匿名関数の実行を示します fmt.Println(\u0026#34;A\u0026#34;) }() time.Sleep(2 * time.Second) } /* * 出力 * B.defer * A.defer */ ","date":"2024-12-17T21:16:31+08:00","permalink":"https://blog.yexca.net/ja/archives/206/","title":"GoLang ゴルーチン"},{"content":" この記事の一部は機械翻訳を使ったよ\nGolang シリーズ\nHello GoLang: https://blog.yexca.net/ja/archives/154 GoLang (var and const) 変数と定数: https://blog.yexca.net/ja/archives/155 GoLang (func) 関数: https://blog.yexca.net/ja/archives/156 GoLang (slice and map) スライス: https://blog.yexca.net/ja/archives/160 GoLang (OOP) オブジェクト指向: https://blog.yexca.net/ja/archives/162 GoLang (reflect) リフレクション: https://blog.yexca.net/ja/archives/204 GoLang (struct tag) 構造タグ: この記事\nGoLang (goroutine) ゴルーチン: https://blog.yexca.net/ja/archives/206 GoLang (channel) チャンネル: https://blog.yexca.net/ja/archives/207 構造タグはパッケージ内のクラスの役割を記述するために使用できます。\nタグの値を取得する tag を定義するには ` を使用します (markdown コードブロックのキー)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) type User struct { // 複数の tag はスペースで区切られます name string `doc:\u0026#34;name\u0026#34; info:\u0026#34;nameOfUser\u0026#34;` age int `info:\u0026#34;ageOfUser\u0026#34;` } func main() { user := User{\u0026#34;zhangSan\u0026#34;, 18} findTag(\u0026amp;user) } func findTag(input interface{}) { t := reflect.TypeOf(input).Elem() for i := 0; i \u0026lt; t.NumField(); i++ { tagInfo := t.Field(i).Tag.Get(\u0026#34;info\u0026#34;) tagDoc := t.Field(i).Tag.Get(\u0026#34;doc\u0026#34;) fmt.Println(\u0026#34;info:\u0026#34;, tagInfo, \u0026#34;doc:\u0026#34;, tagDoc) } } JSON 変換 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 package main import ( \u0026#34;encoding/json\u0026#34; \u0026#34;fmt\u0026#34; ) type User struct { // パブリックプロパティのみが JSON に変換できることに注意してください Name string `json:\u0026#34;name\u0026#34;` Age int `json:\u0026#34;age\u0026#34;` } func main() { user := User{\u0026#34;zhangSan\u0026#34;, 18} // struct --\u0026gt; json jsonStr, err := json.Marshal(user) if err != nil { fmt.Println(\u0026#34;error\u0026#34;, err) } else { fmt.Printf(\u0026#34;jsonStr : %s\\n\u0026#34;, jsonStr) } // json --\u0026gt; struct var user2 User err = json.Unmarshal(jsonStr, \u0026amp;user2) if err != nil { fmt.Println(\u0026#34;error\u0026#34;, err) } else { fmt.Println(user2) } } ","date":"2024-12-11T18:31:18+08:00","permalink":"https://blog.yexca.net/ja/archives/205/","title":"GoLang 構造タグ"},{"content":" この記事の一部は機械翻訳を使ったよ\nGolang シリーズ\nHello GoLang: https://blog.yexca.net/ja/archives/154 GoLang (var and const) 変数と定数: https://blog.yexca.net/ja/archives/155 GoLang (func) 関数: https://blog.yexca.net/ja/archives/156 GoLang (slice and map) スライス: https://blog.yexca.net/ja/archives/160 GoLang (OOP) オブジェクト指向: https://blog.yexca.net/ja/archives/162 GoLang (reflect) リフレクション: この記事\nGoLang (struct tag) 構造タグ: https://blog.yexca.net/ja/archives/205 GoLang (goroutine) ゴルーチン: https://blog.yexca.net/ja/archives/206 GoLang (channel) チャンネル: https://blog.yexca.net/ja/archives/207 反射指の一種の用途であり、自己記述と自己制御が可能です\npair Go 言語变量には type と value の部分が含まれ、pair で構成されます\nstatic type はコード実行時に見られるタイプであり、concrete type は runtime システムに見られるタイプです。\nこのタイプは、static type ではなく変数の concrete type に応じて成功するかどうかを判断します。したがって、concrete type が write メソッドの命令も実装している場合、タイプは write として承認される可能性があります。\n反射はタイプに基づいて確立され、静的タイプであり、固定されているため、反射は主に interface タイプに関係します (concrete type)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 package main import \u0026#34;fmt\u0026#34; type ReadBook interface { Read() } type WriteBook interface { Write() } type Book struct { } func (this *Book) Read() { fmt.Println(\u0026#34;read Book\u0026#34;) } func (this *Book) Write() { fmt.Println(\u0026#34;write Book\u0026#34;) } func main() { // b: pair\u0026lt;type:Book, value:book{} のアドレス\u0026gt; b := \u0026amp;Book{} // r: pair\u0026lt;type:, value:\u0026gt; var r ReadBook // r: pair\u0026lt;type:Book, value:book{} のアドレス\u0026gt; r = b r.Read() var w WriteBook w = r.(WriteBook) // r のタイプは Book であるため w.Write() } TypeOf と ValueOf Reflect.TypeOf() は pair 中の type を取得します、reflect.ValueOf() は pair 中の value を取得します\n1 2 3 4 5 6 7 8 9 10 11 12 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) func main() { a := 3.14 fmt.Println(\u0026#34;type of a:\u0026#34;, reflect.TypeOf(a)) // float64 fmt.Println(\u0026#34;value of a:\u0026#34;, reflect.ValueOf(a)) // 3.14 } 型转换 reflect.ValueOf() を実行すると、型が reflect.Value 变量になります。\n既知原データの種類 既知原データ型は直接强制转换可能\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) func main() { a := 3.14 fmt.Println(\u0026#34;type of a:\u0026#34;, reflect.TypeOf(a)) fmt.Println(\u0026#34;value of a:\u0026#34;, reflect.ValueOf(a)) value := reflect.ValueOf(a) fmt.Printf(\u0026#34;type of value:%T\\n\u0026#34;, value) // reflect.Value newA := value.Interface().(float64) fmt.Printf(\u0026#34;type of newA:%T\\n\u0026#34;, newA) // float64 } 型変換は完全に一貫している必要があることに注意することが重要です。そうでないと、ポインタなどの panic が発生します。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) func main() { a := 3.14 fmt.Println(\u0026#34;type of a:\u0026#34;, reflect.TypeOf(a)) fmt.Println(\u0026#34;value of a:\u0026#34;, reflect.ValueOf(a)) // 輸送先住所 point := reflect.ValueOf(\u0026amp;a) fmt.Printf(\u0026#34;type of value:%T\\n\u0026#34;, point) // reflect.Value // 型をポインタに変換する newA := point.Interface().(*float64) fmt.Printf(\u0026#34;type of newA:%T\\n\u0026#34;, newA) // *float64 } つまり、反射することができます \u0026ldquo;反射型オブジェクト\u0026rdquo; 再再再转换は \u0026ldquo;インターフェース変数\u0026rdquo;\n未知原データ型 Field を横断して取得\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) type Person struct { // 一行は 1 つの field です Name string Age int Rank float64 } // メソッドはパブリックであることに注意してください。プライベートの場合はアクセスできません。 func (person Person) Sleep() { fmt.Println(\u0026#34;person sleep\u0026#34;) } func main() { p := Person{\u0026#34;zhangSan\u0026#34;, 18, 5.2} getFieldAndMethod(p) } func getFieldAndMethod(input interface{}) { getType := reflect.TypeOf(input) fmt.Println(\u0026#34;type:\u0026#34;, getType.Name()) getValue := reflect.ValueOf(input) fmt.Println(\u0026#34;value/AllField:\u0026#34;, getValue) // 属性を取得します numField := getValue.NumField() for i := 0; i \u0026lt; numField; i++ { fieldType := getType.Field(i) fieldValue := getValue.Field(i).Interface() fmt.Printf(\u0026#34;%s: %v = %v\\n\u0026#34;, fieldType.Name, fieldType.Type, fieldValue) } // メソッドを取得します numMethod := getType.NumMethod() for i := 0; i \u0026lt; numMethod; i++ { method := getType.Method(i) fmt.Printf(\u0026#34;%s: %v\\n\u0026#34;, method.Name, method.Type) } } reflect.Value による割り当て 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) func main() { a := 3.14 // ポインタの場合のみ割り当て可能 pointer := reflect.ValueOf(\u0026amp;a) // 元の値を取得するためのアドレスを設定します newValue := pointer.Elem() // 値が設定可能かどうかをチェックする fmt.Println(\u0026#34;value canSet:\u0026#34;, newValue.CanSet()) if newValue.CanSet() { // 設定できる場合 newValue.SetFloat(9.96) // 変数の値を表示 fmt.Println(\u0026#34;value of a:\u0026#34;, a) // 9.96 } else { fmt.Println(\u0026#34;error\u0026#34;) } } reflect.Value 経由でメソッドを呼び出す 関数名による呼び出し\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) type User struct { name string age int } func (user User) MethodHasArgs(a string, b int) { fmt.Println(\u0026#34;User MethodHasArgs\u0026#34;) } func (user User) MethonNotArgs() { fmt.Println(\u0026#34;User MethodNotArgs\u0026#34;) } func main() { user := User{\u0026#34;zhangSan\u0026#34;, 18} value := reflect.ValueOf(user) // 関数名で呼び出す method1 := value.MethodByName(\u0026#34;MethodHasArgs\u0026#34;) // ビルドパラメータ args1 := []reflect.Value{reflect.ValueOf(\u0026#34;string\u0026#34;), reflect.ValueOf(18)} // 関数の呼び出し method1.Call(args1) // パラメータなしで呼び出す method2 := value.MethodByName(\u0026#34;MethonNotArgs\u0026#34;) args2 := make([]reflect.Value, 0) method2.Call(args2) } リフレクションの基本原則 ","date":"2024-12-03T14:07:18+08:00","permalink":"https://blog.yexca.net/ja/archives/204/","title":"GoLang リフレクション"},{"content":"問題一： https://blog.yexca.net/ja/archives/198 問題二：この記事\n問題三 (簡体字中国語)： https://blog.yexca.net/archives/200 問題四 (簡体字中国語)： https://blog.yexca.net/archives/202 問題五 (簡体字中国語)： https://blog.yexca.net/archives/203 まえがき この質問を初めて見たときは形式言語（とオートマトン理論）に関する質問だと思ったのですが、実際にやってみると数学に関する質問でした （どちらも習ってないので同じです） 全体的な難易度は特に難しいわけではありません （私は東京大学の試験問題を受験したので、ここでの問題はそれほど難しくありません） しかし、それらを解くには、より多くの理論的基礎を習得する必要があります\nトピックの著作権は東京理科大学に帰属します。閲覧の便宜のために引用しているだけで、営利行為は一切ありません。\n1 命題論理について考える。命題 $\\varphi$ を $(\\neg p_0 \\to \\neg p_1) \\wedge (\\neg p_1 \\to p_0)$ とする。ただし、$p_0, p_1$ は命題記号である。\na）以下の表が $\\varphi$ の真理値表になるように（ア）～（エ）にあてはまる値を答えよ。ただし、1は真を表し、0は偽を表す。\n$p_0$ $p_1$ $\\varphi$ 0 0 （ア） 0 1 （イ） 1 0 （ウ） 1 1 （エ） b）命題 $\\varphi$ が恒真（トートロジー）であるか否か答えよ。\nc）命題 $\\varphi$ が充足可能であるか否か答えよ。\n1-a 先ずは、命題 $\\varphi$ を整理する\n$$ \\begin{align} \\varphi \u0026amp;= (\\neg p_0 \\to \\neg p_1) \\wedge (\\neg p_1 \\to p_0) \\ \u0026amp;= (p_0 \\vee \\neg p_1) \\wedge (p_1 \\vee p_0) \\end{align} $$\nこれより\n$p_0$ $p_1$ $\\varphi$ 0 0 0 0 1 0 1 0 1 1 1 1 ゆえに、ア：0、イ：0、ウ：1、エ：1\n1-b $\\varphi=0$ の場合が存在するため、恒真命題ではない\n1-c $\\varphi=1$ の場合が存在するため、充足可能である\n2 命題論理の自然演繹について考える。$p_1, p_2, p_3$ は命題記号であり、$\\wedge I$ は連言の導入規則、$\\wedge E_L$ は連言の除去規則（左）、$\\wedge E_R$ は連言の除去規則（右）、$\\to E$ は含意の除去規則である。\na）$(p_1 \\wedge p_2) \\wedge p_3$ を仮定とし、$p_1 \\wedge (p_2 \\wedge p_3)$ を結論とする以下の自然演繹の導出（証明図）を完成させたい。（ア）～（オ）にあてはめる命題を答えよ。\n$$ \\cfrac{ \\cfrac{ \\cfrac{(p_1 \\wedge p_2)\\wedge p_3}{(ア)}\\wedge E_L }{p_1}\\wedge E_L \\quad \\cfrac{ \\cfrac{ \\cfrac{(p_1 \\wedge p_2) \\wedge p_3}{(イ)}\\wedge E_L }{(ウ)}\\wedge E_R \\quad \\cfrac{(p_1 \\wedge p_2) \\wedge p_3}{(エ)}\\wedge E_R }{(オ)}\\wedge I }{p_1 \\wedge (p_2 \\wedge p_3)}\\wedge I $$\nb）$p_1 \\wedge p_2$ と $p_1 \\to (p_2 \\to p_3)$ を仮定とし、$p_3$ を結論とする以下の自然演繹の導出（証明図）を完成させたい。（ア）～（エ）にあてはめる命題を答えよ。\n$$ \\cfrac{ \\cfrac{(ア)}{p_2}\\wedge E_R \\quad \\cfrac{ \\cfrac{(イ)}{p_1}\\wedge E_L \\quad (ウ) }{(エ)}\\to E }{p_3}\\to E $$\nc）命題の集合 ${ \\neg p_0 \\to \\neg p_1, \\neg p_1 \\to p_0 }$ が矛盾するか無矛盾であるかを答え、その理由を述べよ。\n2-解答 質問に示されている記号を理解できれば、この質問に答えるのは比較的簡単です。\n$\\wedge I$ は交差のインポート規則であり、$A$ と $B$ を $A \\wedge B$ に変換する。\n$\\wedge E_L$ は交差除去規則であり、左側を残す。つまり、$A \\wedge B$ は $A$ になる。\n$\\wedge E_R$ は交差除去規則であり、右側を残す。つまり、$A \\wedge B$ は $B$ になる。\n$\\to E$ は含意除去規則であり、$A$ と $A \\to B$ を $A$ に変換する。\n2-a ア: $p_1 \\wedge p_2$ イ: $p_1 \\wedge p_2$ ウ: $p_2$ エ: $p_3$ オ: $p_2 \\wedge p_3$ $$ \\cfrac{ \\cfrac{ \\cfrac{(p_1 \\wedge p_2)\\wedge p_3}{p_1 \\wedge p_2}\\wedge E_L }{p_1}\\wedge E_L \\quad \\cfrac{ \\cfrac{ \\cfrac{(p_1 \\wedge p_2) \\wedge p_3}{p_1 \\wedge p_2}\\wedge E_L }{p_2}\\wedge E_R \\quad \\cfrac{(p_1 \\wedge p_2) \\wedge p_3}{p_3}\\wedge E_R }{p_2 \\wedge p_3}\\wedge I }{p_1 \\wedge (p_2 \\wedge p_3)}\\wedge I $$\n2-b ア: $p_1 \\wedge p_2$ イ: $p_1 \\wedge p_2$ ウ: $p_1 \\to (p_2 \\to p_3)$ エ: $p_2 \\to p_3$ $$ \\cfrac{ \\cfrac{p_1 \\wedge p_2}{p_2}\\wedge E_R \\quad \\cfrac{ \\cfrac{p_1 \\wedge p_2}{p_1}\\wedge E_L \\quad p_1 \\to (p_2 \\to p_3) }{p_2 \\to p_3}\\to E }{p_3}\\to E $$\n2-c 無矛盾である。命題を整理する\n$$ \\neg p_0 \\to \\neg p_1 \\equiv p_0 \\vee \\neg p_1 \\ \\neg p_1 \\to p_0 \\equiv p_1 \\vee p_0 $$\n真理値表を作る\n$p_0$ $p_1$ $\\neg p_0 \\to \\neg p_1$ $\\neg p_1 \\to p_0$ 0 0 1 0 0 1 0 1 1 0 1 1 1 1 1 1 $p_0=1, p_1=0$ または $p_0=1, p_1=1$ の場合は、両方の命題が成り立つ\n少なくとも一つの真理値割り当てで命題集合が成り立つため、命題の集合 ${ \\neg p_0 \\to \\neg p_1, \\neg p_1 \\to p_0 }$ は無矛盾である\n3 一階述語論理について考える。\na）以下の論理式のモデルは存在するか。存在するならば、モデルのユニバースの濃度の最小値を答えよ。存在しないならば、その理由を述べよ。\n$$ \\exists x \\exists y \\exists z \\space \\neg(x=y) \\wedge \\neg(y=z) \\wedge \\neg(z=x) $$\nb）以下の論理式のモデルは存在するか。存在するならば、そのモデルを1つ挙げよ。存在しなければ、その理由を述べよ。\n$$ \\exists x \\forall y(x=y) $$\n3-a この論理式のモデルは存在する。モデルのユニバースの濃度の最小値は3である。\n3-b この論理式のモデルは存在する。例えば、ユニバース $U={a}$ を設定する。この場合、$U$ のすべての要素が $x$ と等しいため、論理式が成り立つ。\n4 一階述語論理の自然演繹について考える。以下が成り立つか否か答え、その理由を述べよ。ただし、$P$ はアリティ2の述語記号とする。\n$$ \\vdash (\\forall x \\exists y P(x,y)) \\to \\exists x \\forall y P(x,y) $$\n4-解答 これは成り立たない。反例は以下のように構成する。\nユニバースを ${ m,n,a,b }$ と定義する。このとき、述語 $P(x,y)$ の解釈を以下のように与える\n$$ P(m,a) = 真 \\quad P(a,m) = 偽 \\ P(n,b) = 真 \\quad P(b,n) = 偽 $$\nこれより、$\\forall x \\exists y P(x,y)$ が成り立つ。しかし、$\\exists x \\forall y P(x,y)$ は成り立たない。\nReference 自然演繹 命題論理 演繹定理 充足可能性問題 ","date":"2024-11-24T22:42:18+08:00","permalink":"https://blog.yexca.net/ja/archives/201/","title":"科学大院理工学 2020 問題二"},{"content":"問題一：この記事\n問題二： https://blog.yexca.net/ja/archives/201 問題三 (簡体字中国語)： https://blog.yexca.net/archives/200 問題四 (簡体字中国語)： https://blog.yexca.net/archives/202 問題五 (簡体字中国語)： https://blog.yexca.net/archives/203 まえがき この記事は初めて母国語じゃない言語で書いて、他の記事を参考しないので、言葉遣いがてきせつではないかも。それで、参考の答えはなくて、記事の答えが自分でできたので、正しくないかも。\n科学大とは東京工業大学の新しい名前で、略称が何か知らなくてこれを使った。\n問題の著作権は東京科学大学に帰属します。閲覧の便宜のためにのみ引用されており、営利を目的とするものではありません。\n1 以下の極限を求めよ。\na) $\\lim_{x\\to\\infty}{ \\log_e(2x+3)-\\log_e(x) }$\nb) $\\lim_{x\\to 0}\\frac{1-\\cos x}{x\\sin x}$\nc) $\\lim_{x\\to 0}\\frac{e^{3x}-\\cos x}{x}$\n回答\na\n$$ a=\\lim_{x \\to \\infty}\\log_e\\frac{2x+3}{x}=\\lim_{x\\to \\infty}\\log_e(2+\\frac{3}{x})=\\log_e2 $$\nb\n$$ \\because when \\space x \\to 0 ,\\space 1-\\cos x \\sim \\frac{1}{2}x^2 \\space and \\space sinx \\sim x \\ \\therefore \\lim_{x\\to 0}\\frac{1-\\cos x}{x\\sin x}=\\lim_{x\\to 0}\\frac{\\frac{1}{2}x^2}{x^2}=\\frac{1}{2} $$\nc ロピタルの定理を用いて\n$$ \\lim_{x\\to 0}\\frac{e^{3x}-\\cos x}{x}=\\lim_{x\\to 0}\\frac{3e^{3x}+sinx}{1}=3 $$\n2 以下の実行列の積の行列式を計算せよ。\n$$ \\begin{pmatrix} 1 \u0026amp; 0 \u0026amp; 0 \\ x \u0026amp; 2 \u0026amp; 1 \\ x^2 \u0026amp; 3 \u0026amp; 2 \\end{pmatrix} \\begin{pmatrix} 31 \u0026amp; 23 \u0026amp; 17 \\ 0 \u0026amp; 11 \u0026amp; 11 \\ 0 \u0026amp; 4 \u0026amp; 5 \\end{pmatrix} $$\n2つの行列の積の行列式は、それらの行列式の積である。\nA の場合\n$$ A=\\begin{pmatrix} 1 \u0026amp; 0 \u0026amp; 0 \\ x \u0026amp; 2 \u0026amp; 1 \\ x^2 \u0026amp; 3 \u0026amp; 2 \\end{pmatrix} $$\nA の行列式\n$$ \\det(A)=(-1)^{1+1} \\times 1 \\times \\begin{vmatrix} 2 \u0026amp; 1 \\ 3 \u0026amp; 2 \\end{vmatrix} -0+0 =1 $$\nB の場合\n$$ B=\\begin{pmatrix} 31 \u0026amp; 23 \u0026amp; 17 \\ 0 \u0026amp; 11 \u0026amp; 11 \\ 0 \u0026amp; 4 \u0026amp; 5 \\end{pmatrix} $$\nB の行列式\n$$ \\det(B)=(-1)^{1+1} \\times 31 \\times \\begin{vmatrix} 11 \u0026amp; 11 \\ 4 \u0026amp; 5 \\end{vmatrix} -0+0 = 341 $$\nだから\n$$ \\det=\\det(A) \\times \\det(B)=1 \\times 341 = 341 $$\n3 以下の確率密度関数 $f_X(x)$ に従う連続型確率変数 $X$ の分散 $V(X)$ 、累積分布関数 $F_X(x)$ を各々求めよ。ただし、$\\lim_{x \\to +0}x^n\\log_e(x)=0$ ($n$ は 1 以上の整数) とする。\n$$ F_X(x)=\\left { \\begin{matrix} -4x\\log_e(x) \u0026amp; 0 \\lt x \\le 1 \\ 0 \u0026amp; x \\le 0 \\space または \\space x \\gt 1 \\end{matrix} \\right . $$\nまずは、累積分布関数を考えて\n$x \\le 0$ $$ F_X(x) = 0 $$\n$x\\gt 1$ $$ F_X(x) = 1 $$\n$0 \\lt x \\le 1$ $$ \\begin{align} F_X(x) \u0026amp;= \\int_0^x(-4t\\log_e(t))dt \\ \\end{align} $$\n部分積分を用いて\n$$ \\begin{matrix} u = \\ln t \u0026amp; dv=4tdt \\ du = \\frac{1}{t}dt \u0026amp; v=2t^2 \\end{matrix} $$\nしたがって\n$$ \\begin{align} F_X(x) \u0026amp;=-( [2t^2\\ln t]_0^x - \\int_0^x 2t^2\\frac{1}{t}dt ) \\ \u0026amp;=-( 2x^2\\ln x - \\int_0^x 2t dt ) \\ \u0026amp;=-( 2x^2\\ln x - t^2\\mid_0^x ) \\ \u0026amp;=x^2 - 2x^2\\ln x \\end{align} $$\nこれより\n$$ F_X(x)= \\left { \\begin{matrix} 0 \u0026amp; x \\le 0 \\ x^2-2x^2\\ln x \u0026amp; 0 \\lt x \\le 1 \\ 1 \u0026amp; x \\gt 1 \\end{matrix} \\right . $$\n次に、分散を求める。分散の定義は\n$$ V(X)=E[X^2] - (E[X])^2 $$\n期待値 $E[X]$ を計算する\n$$ \\begin{align} E[X] \u0026amp;= \\int_{-\\infty}^{\\infty}xf_X(x)dx \\ \u0026amp;= \\int_0^1x(-4x\\ln x)dx \\ \u0026amp;= -\\int_0^1 4x^2\\ln xdx \\end{align} $$\n部分積分を用いて\n$$ \\begin{matrix} u=\\ln x \u0026amp; dv=4x^2dx \\ du=\\frac{1}{x} \u0026amp; v=\\frac{4}{3}x^3 \\end{matrix} $$\nしたがって\n$$ \\begin{align} E[X] \u0026amp;= -([\\frac{4}{3}x^3\\ln x]_0^1-\\int_0^1\\frac{4}{3}x^3\\frac{1}{x}dx) \\ \u0026amp;= -(-\\frac{4}{9}x^3\\mid_0^1) \\ \u0026amp;= \\frac{4}{9} \\end{align} $$\n$E[X^2]$ の計算\n$$ \\begin{align} E[X^2] \u0026amp;= \\int_{-\\infty}^{\\infty}x^2f_X(x)dx \\ \u0026amp;= \\int_0^1x^2(-4x\\ln x)dx \\ \u0026amp;= -4\\int_0^1x^3\\ln xdx \\end{align} $$\n部分積分を用いて\n$$ \\begin{matrix} u=\\ln x \u0026amp; dv=x^3dx \\ du=\\frac{1}{x} \u0026amp; v=\\frac{1}{4}x^4 \\end{matrix} $$\nしたがって\n$$ \\begin{align} E[X^2] \u0026amp;= -4 \\times ([\\frac{1}{4}x^4\\ln x]_0^1-\\int_0^1\\frac{1}{4}x^3dx) \\ \u0026amp;= -4 \\times (-\\frac{1}{16}x^4\\mid_0^1) \\ \u0026amp;= \\frac{1}{4} \\end{align} $$\nだから\n$$ \\begin{align} V(X) \u0026amp;= E[X^2] - (E[X])^2 \\ \u0026amp;= \\frac{1}{4} - (\\frac{4}{9})^2 \\ \u0026amp;= \\frac{17}{342} \\end{align} $$\n4 ある製造ラインで生産された製品は1/1000の確率で不良品である。不良品を99/100の確率で正しく不良品と判定し、かつ、不良品でないものを4/5の確率で正しく不良品ではないと判定する検査手法がある。この製造ラインにおいて、この手法が不良品と判定した製品が、不良品である確率を求めよ。\n不良品である確率：$P(A)=\\frac{1}{1000}$、不良品と判定する確率：$P(B)$\nこれより\n$$ \\begin{matrix} p(\\bar{A})=\\frac{999}{1000} \u0026amp; P(B\\mid A)=\\frac{99}{100} \u0026amp; P(B\\mid \\bar{A})=\\frac{1}{5} \\end{matrix} $$\nしたがって\n$$ P(B)=P(A)P(B\\mid A)+P(\\bar{A})P(B\\mid \\bar{A})=\\frac{20079}{100000} $$\nベイズの定理を用いると\n$$ P(A\\mid B)=\\frac{P(AB)}{P(B)}=\\frac{P(A)P(B\\mid A)}{P(B)}=\\frac{99}{20079} $$\n以上より、不良品である確率は $\\frac{99}{20079}$\n5 あるカジノで、4個のパケットA,B,C,Dに区切られたルーレットがある。カジノの説明ではそれぞれのパケットにボールが入る確率は同じであるとされている。そのルーレットを5回試行したところ、ボールはパケットAに4回入った。カジノの説明とは異なる「このルーレットはボールがポケットAにより入りやすい」という仮設を、有意水準5％で検定せよ。解答には帰無仮説 $H_0$ 、対立仮説 $H_1$ を明記すること。\n$H_0$：ポケットAにボールが入る確率は他のポケットと同じである。すなわち\n$$ P(A)=\\frac{1}{4} $$\n$H_1$ ：ポケットAにボールが入る確率は他のポケットより高い。すなわち\n$$ P(A)\\gt \\frac{1}{4} $$\nボールはポケットAに4回入る確率は\n$$ P(X=4)=(_4^5) (\\frac{1}{4})^4 \\times \\frac{3}{4}=\\frac{15}{1024} $$\nボールはポケットAに5回入る確率は\n$$ P(X=5)=(_5^5) (\\frac{1}{4})^5=\\frac{1}{1024} $$\nこれより\n$$ P(X\\ge 4)=\\frac{15}{1024}+\\frac{1}{1024}=\\frac{1}{64} $$\nこの確率は有意水準より小さいため、帰無仮説を棄却する。ゆえに、「このルーレットはボールがポケットAにより入りやすい」という仮設は統計的に有意であると言えます。\n","date":"2024-11-21T15:42:18+08:00","permalink":"https://blog.yexca.net/ja/archives/198/","title":"科学大院理工学 2020 問題一"},{"content":" 📢 この記事は ChatGPT によって翻訳されました はじめに 最近、SSD を交換したので PC をクリーンインストールすることに。\n何年も使ってなかった USB を取り出したら、中のソフトがだいぶ古くなってたし、新しい環境に対応してないものも多かった。\nこの機会に使ってるソフトを整理して記録しておくことにした。\nこの記事自体は 2024年9月16日から書き始めたけど、ちょっと色々あって、最終的に書き上げたのは 10月2日。\nシステム しばらく Win11 を使ってて、今回も Win11 を続投。\nUSB に入ってたイメージが古かったので、 MSDN itellyou から最新の ISO をダウンロード。\nインストール中に気づいたけど、最近のやつはネット接続しないと進まないんだね……。\nMS アカウントでのログインを求められて、ネットがないとスキップできない。古いバージョンか Win10 にしてアップグレードする方が楽かも (doge)\n2024.10.03\nネット接続をスキップする方法が2つあるらしい 、まだ試してないけどメモ：\nCtrl+Shift+F3 を押すとセットアップをスキップできて、ローカルユーザーも作成しない（再起動後に再設定になる） Shift+F10 でコマンドプロンプトを開いて oobe\\bypassnro.cmd を実行。再起動後に「ネット接続なし」オプションが出る ソフト構成 前に作ったインストール用 USB がかなり古かったので、不要なソフトや今は別の代替ツールを使ってるものも多かった。\n今後の自分用にメモ残しておく。どうせ次回はまた違う構成になるだろうし。\nオフィスソフト 基本の Office は必須。Office Tool を使って簡単にインストール。\n必要なのは Word、Excel、PowerPoint のみ。\nOffice Tool ダウンロード: https://otp.landian.vip/zh-cn/download.html コードでインストール実行：\n1 deploy /add O365ProPlusRetail_zh-cn /O365ProPlusRetail.exclapps Access,Bing,Groove,Lync,OneDrive,OneNote,Outlook,Publisher,Teams /channel Current /dlfirst KMS でライセンス認証：\n1 2 3 ospp /inslicid MondoVolume /sethst:kms.loli.beer /setprt:1688 /act # または kms.03k.org ospp /inslicid MondoVolume /sethst:kms.03k.org /setprt:1688 /act 参考：\nhttps://www.coolhub.top/archives/11 https://www.coolhub.top/archives/14 ダウンロード・クラウド 迅雷：古い軽量版を使用。吸血云々あるけど必要なときはある BitComet：BT 用、軽量版。qBittorrent や µTorrent も選択肢 Resilio Sync ：BT 技術をベースにしたファイル同期ツール IDM：マルチスレッド型ダウンロードマネージャ 115 : 動かない BT を落とすときに使う。他に pikpak なども 百度网盘 : プレミアムなら便利。阿里網盤や夸克網盤などは必要時に入れる チャット・SNS 使ってるのはこんな感じ：\nTencent 系\nQQ : 最近の NT バージョンはまあまあ WeChat: https://www.wechat.com/ Telegram\nhttps://desktop.telegram.org/ 解凍ツール 前の PC にはいくつか入れてたけど、実際使うのは 2 つだけ。\nBandizip : 定番の解凍ツール WinRAR：一部の RAR はこれじゃないと開けない その他候補：\n7zip ：王道の無料ツール NanaZip ：7z の UI 改良版。Win11 の右クリック統合も可 その他ツール Utools : プラグインで何でもできる超便利ランチャー。この記事も Utools の MD プラグインで書いてる\nQuickLook : ファイルプレビュー\n1Password : パスワードマネージャ。オープンソース代替は bitwarden PDF 閲覧ツールはお好みで\nFoxit PDF Wondershare PDFelement PDF XChange sandboxie : サンドボックス環境。非インストール版は管理者権限が必要\nTickTick : ToDo アプリ。最近同期が不調気味？\nQuiteRSS : RSS クライアント。古い UI だけど気に入ってる\nDuplicate Cleaner Pro：重複ファイル整理ツール。八酱のおすすめ\nPixPin : スクリーンショットツール\nコード系ツール VS Code : 必須 Typora : MD 可視化エディタ Git: https://git-scm.com/downloads/win 1 2 git config --global user.name \u0026#34;Your Name\u0026#34; git config --global user.email \u0026#34;email@example.com\u0026#34; JetBrains\nIntelliJ IDEA : Java GoLand : Go Dataflare : DB GUI ツール\nDocker 完全に Docker 中毒。\nインストール： https://docs.docker.com/desktop/install/windows-install/ エラー：WSL Update Failed → WSL 最新版をインストール → 再起動\n参考：\nhttps://forums.docker.com/t/wsl-update-failed/140473/3 https://github.com/docker/for-win/issues/13845 https://github.com/docker/for-win/issues/13580#issuecomment-1619667316 MySQL：\n1 docker pull mysql:5.7 環境変数 MYSQL_ROOT_PASSWORD を指定して起動。\nブログ環境（Jekyll） 自分のブログは Jekyll ベース。 Ruby や Node.js を使うからセットアップ面倒くさい。\n必要なツール：\nRuby: https://www.ruby-lang.org/en/downloads/ RubyGems: https://rubygems.org/pages/download Node.js: https://nodejs.org/zh-cn 1 2 gem install jekyll bundle でもいくつかの gem がどうしてもインストールできなかった…… 最終的に Docker で動かすのが正解だった。\nVS Code に Dev Containers extension を入れて、 F1 → Dev Containers: Clone Repository in Container Volume... で Git リポジトリをクローンして使う\nコンテナ内で以下を実行：\n1 2 3 4 5 sudo apt-get update sudo apt-get install ruby-full build-essential sudo gem install jekyll bundler sudo apt install nodejs sudo bundle 1 bundle exec jekyll s VS Code 経由で直接表示できる。Docker、マジ最高。\n参考：\nhttps://jekyllcn.com/docs/installation/ https://jekyllrb.com/docs/installation/windows/#installation-via-bash-on-windows-10 https://code.visualstudio.com/docs/devcontainers/containers#_quick-start-open-a-git-repository-or-github-pr-in-an-isolated-container-volume おわりに 今のところ必要なのはこのくらいかな。 使わなくなったソフトや頻度の低いやつはもう省いた。 また次回の装機タイミングでは内容が変わってるかもね。おつかれ自分。\n","date":"2024-10-02T21:35:24+08:00","permalink":"https://blog.yexca.net/ja/archives/182/","title":"2024年 PC再インストール記録"},{"content":" この記事は Google 翻訳を使用して処理されました\n問題の説明 n クイーン問題は、n 行 n 列のチェス盤に n 個のクイーンを配置し、クイーン同士が攻撃できないようにすることです。ルールは、2 個のクイーンが同じ行、列、または対角線上にないことです（つまり、 、チェスのクイーンの移動範囲）\n問題分析 n クイーン問題を解決するために、次のアイデアが提案されています。\ni 番目のクイーンは i 番目の列に置かれる\n最初のクイーンから始めて、各クイーンについて、対応する行の最初の列から試します（i番目のクイーンはi番目の行に対応します） 配置できる場合は位置を決定し、次のクイーンを検討します 前の女王と衝突する場合は、次の列を考慮する 最後の列を超えた場合は、前のクイーンの位置が再決定されます。\nすべての配置ソリューションが見つかるまでこのプロセスを繰り返します。\nC コード 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;math.h\u0026gt; #define N 4 // クイーンの数 // k 番目のクイーンの現在の位置が前のクイーンと競合するかどうかを判定する int isplace(int pos[], int k){ int i; for(i=1; i\u0026lt;k; i++){ if(pos[i]==pos[k] || fabs(i-k) == fabs(pos[i]-pos[k])) return 0; } return 1; } int main(){ int i,j; int count = 1; int pos[N+1]; // 初期化の位置 for(i=1;i\u0026lt;=N;i++) pos[i]=0; j = 1; while(j\u0026gt;=1){ pos[j]=pos[j]+1; // i 番目のクイーンを配置してみて while(pos[j]\u0026lt;=N \u0026amp;\u0026amp; !isplace(pos,j)){ pos[j]=pos[j]+1; // 配置計画を取得する } if(pos[j]\u0026lt;=N \u0026amp;\u0026amp; j==N){ printf(\u0026#34;方案 %d：\u0026#34;, count++); for(i=1;i\u0026lt;=N;i++) printf(\u0026#34;%d\u0026#34;, pos[i]); printf(\u0026#34;\\n\u0026#34;); } // 次のクイーンを考えてみよう if(pos[j]\u0026lt;=N \u0026amp;\u0026amp; j\u0026lt;N){ j+=1; }else{ // 前のクイーンについて考えるために戻る pos[j]=0; j-=1; } } return 1; } ","date":"2024-07-28T14:26:26+08:00","permalink":"https://blog.yexca.net/ja/archives/176/","title":"n-クイーン問題のアルゴリズム（バックトラッキング）"},{"content":" 📢 この記事は ChatGPT によって翻訳されました はじめに 以前 Typecho を Docker コンテナへ移行したとき、HTTPS を有効化すると管理画面にログインできなくなった。\nHTTPS を無効化すれば正常にアクセスできる。\nDocker 以前の通常構成では問題なかったので、Docker ネットワークのせいかと思ってとりあえず HTTPS を切って編集して、そのまま放置してた。\n今回改めて Typecho を使うことになり、再び同じ症状に遭遇。今後の運用のためにも原因を調査して解決策を記録しておく。\n解決方法 解決方法はめっちゃシンプル。\ndata/config.inc.php の末尾に以下のコードを追加するだけ：\n1 define(\u0026#39;__TYPECHO_SECURE__\u0026#39;, true); これでコンテナを再起動すれば OK。\n原因について 参考記事によると、ユーザーとブラウザ間の通信は HTTPS だけど、Typecho 側 (PHP) が受け取るのは Cloudflare 経由の HTTP リクエスト。 その結果、PHP が HTTP ベースでレスポンスを返してしまい、セッションエラーやログイン不可になるらしい。\n参考記事 Typecho HTTPS 无法登陆后台 ","date":"2024-07-26T22:22:22+08:00","permalink":"https://blog.yexca.net/ja/archives/175/","title":"Typecho で HTTPS 化後に管理画面へログインできない問題"},{"content":"導入 卒業論文は面倒くさいな、この記事はいつか書いたのでしょうか。ファイルは 2023-11-30 に作成されたけど、2022.09.18 に変更されて、わからなくて、ショックを受けた\nコード 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 \u0026lt;script\u0026gt; function secondToDate(second) { if (!second) { return 0; } var time = new Array(0, 0, 0, 0, 0); if (second \u0026gt;= 365 * 24 * 3600) { time[0] = parseInt(second / (365 * 24 * 3600)); second %= 365 * 24 * 3600; } if (second \u0026gt;= 24 * 3600) { time[1] = parseInt(second / (24 * 3600)); second %= 24 * 3600; } if (second \u0026gt;= 3600) { time[2] = parseInt(second / 3600); second %= 3600; } if (second \u0026gt;= 60) { time[3] = parseInt(second / 60); second %= 60; } if (second \u0026gt; 0) { time[4] = second; } return time; }\u0026lt;/script\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; language=\u0026#34;javascript\u0026#34;\u0026gt; function setTime() { var create_time = Math.round(new Date(Date.UTC(2021, 11, 06, 14, 15, 19)).getTime() / 1000); var timestamp = Math.round((new Date().getTime() + 8 * 60 * 60 * 1000) / 1000); currentTime = secondToDate((timestamp - create_time)); currentTimeHtml = \u0026#39;This Blog has running: \u0026lt;br/\u0026gt;\u0026#39; + currentTime[0] + \u0026#39; y \u0026#39; + currentTime[1] + \u0026#39; d \u0026#39; + currentTime[2] + \u0026#39; h \u0026#39; + currentTime[3] + \u0026#39; m \u0026#39; + currentTime[4] + \u0026#39; s\u0026#39;; document.getElementById(\u0026#34;htmer_time\u0026#34;).innerHTML = currentTimeHtml; } setInterval(setTime, 1000); \u0026lt;/script\u0026gt; 呼び出し 使いたいところで以下のコードを入れる\n1 \u0026lt;span id=\u0026#34;htmer_time\u0026#34; style=\u0026#34;color: pink;\u0026#34; /\u0026gt; 参考資料 个人博客添加运行时间 - 腾讯云开发者社区-腾讯云 ","date":"2024-05-14T11:08:25+08:00","permalink":"https://blog.yexca.net/ja/archives/172/","title":"ブログ実行時間"},{"content":"まずソフトウェアをインストールする必要があります。公式ウェブサイト (英語): https://nacos.io/en/ ポートは conf/application.properties ファイルで変更できます。デフォルトは 8848 です。\nサービスに登録する 親プロジェクトに管理依存関係を追加する\n1 2 3 4 5 6 7 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-alibaba-dependencies\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.6.RELEASE\u0026lt;/version\u0026gt; \u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt; \u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; Eureka の依存関係をコメントアウトし、Nacos クライアントの依存関係を追加します。\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-alibaba-nacos-discovery\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; application.yml を修正し、Nacos アドレスを追加し、Eureka アドレスをコメントします。\n1 2 3 4 spring: cloud: nacos: server-addr: localhost:8848 Nacos を始める\n1 2 startup.cmd -m standalone # 単一マシンの起動パラメータ http://localhost:8848/nacos/ にアクセスすると、ログイン アカウントとパスワードは両方とも nacos になります。\n階層型ストレージモデル サービスは複数のクラスターに分割され、各クラスターには複数のインスタンスがあり、クラスターはリージョンごとに割り当てられ、アクセス速度が向上します。\n対照的に、Eureka にはサービスインスタンスのみがあり、クラスターはありません。\nサービスを呼び出すときは、クラスター間の呼び出しの方が待機時間が長くなるため、可能な限りローカル クラスター内のサービスを選択してください。ローカルクラスタにアクセスできない場合は、他のクラスタにアクセスする\napplication.yml でクラスタを設定できます\n1 2 3 4 5 6 spring: cloud: nacos: server-addr: localhost:8848 discovery: cluster-name: Shanghai # クラスター名 次に Ribbon 戦略を Nacos に設定する\n1 2 3 4 5 # マイクロサービスの負荷分散ルールを設定します。ここでは userService サービスです。 userService: ribbon: NFLoadBalancerRuleClassName: com.alibaba.cloud.nacos.ribbon.NacosRule # NFLoadBalancerRuleClassName: com.netflix.loadbalancer.Nac # 負荷分散ルール 次に、Nacos でインスタンスの重み (0-1) を設定できます。重みが大きいほど、アクセス頻度が高くなります。\n環境隔離 Nacos のサービスストレージとデータストレージの最外層は、名前空間と呼ばれるもので、最外層の分離に使用されます。\nNacos に dev などの新しい名前空間を作成し、application.yml を修正することができます。\n1 2 3 4 5 6 7 spring: cloud: nacos: server-addr: localhost:8848 discovery: cluster-name: Shanghai # クラスター名 namespace: UUID # 名前空間のUUIDは次のとおりです 異なる名前空間内のサービスは相互に表示されず、アクセスできません。\n一時インスタンスと非一時インスタンス 一時的なインスタンスの場合、Nacos は Eukera と同じ方法で処理します。\n一時的でないインスタンスの場合、Nacos はアクティブにインスタンスが稼働中かどうかを問い合わせます。サービスが利用できない場合は削除されません。サービスが利用できない場合、Nacos は積極的に消費者に通知します。\n非一時的インスタンスの設定\n1 2 3 4 5 spring: cloud: nacos: discovery: ephemeral: false # 非一時インスタンスとして設定 Nacos 構成管理 マイクロサービスのデプロイインスタンスが増えると、一つ一つ構成を変更するのは非常に面倒です。Nacos を使用すると、構成を一元管理し、ホットアップデートを行うことができます。\nシンプルな使い方 Nacos コンソールの設定管理で、新しい設定を作成します。ここで、Data ID は、[サービス名]-[プロファイル].[サフィックス名] の形式の設定ファイルの ID です (例: userService-dev.yaml)。\n次に、設定コンテンツに設定を記述します。たとえば、\n1 2 pattern: dateformat: yyyy-MM-dd HH:mm:ss Nacos 構成管理クライアント依存関係の紹介\n1 2 3 4 5 \u0026lt;!--nacos 構成管理依存関係--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-alibaba-nacos-config\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 取得を構成する手順\nプロジェクトの起動 -\u0026gt; bootstrap.yml -\u0026gt; Nacos 構成ファイル -\u0026gt; ローカル application.yml -\u0026gt; Spring コンテナの作成 -\u0026gt; Bean のロード\nbootstrap.yml を追加する\n1 2 3 4 5 6 7 8 9 10 spring: application: name: userService # サービス名 profiles: active: dev # 開発環境、こちらが dev です cloud: nacos: server-addr: localhost:8848 # Nacos住所 config: file-extension: yaml # ファイル拡張子 テスト\n1 2 3 4 5 6 7 8 9 10 11 12 @RestController @RequestMapping(\u0026#34;/user\u0026#34;) public class UserController{ @Value(\u0026#34;${pattern.dateformat}\u0026#34;) private String dateformat; @GetMapping(\u0026#34;/now\u0026#34;) public String now(){ return LocalDateTime.now().format(DateTimeFormatter.ofPattern(dateformat)) } } 効果を確認するにはページをご覧ください\nホットアップデート これは2つの方法で達成できる\n方法1: @Value によって注入された変数が配置されているクラスにアノテーション @RefreshScope を追加する\n1 2 3 4 5 6 7 8 9 10 11 12 13 @RefreshScope // 自動更新の設定 @RestController @RequestMapping(\u0026#34;/user\u0026#34;) public class UserController{ @Value(\u0026#34;${pattern.dateformat}\u0026#34;) private String dateformat; @GetMapping(\u0026#34;/now\u0026#34;) public String now(){ return LocalDateTime.now().format(DateTimeFormatter.ofPattern(dateformat)) } } 方法 2: @ConfigurationProperties を使用する\n新しい構成クラスを作成する\n1 2 3 4 5 6 @Component @Data @ConfigurationProperties(prefix = \u0026#34;pattern\u0026#34;) public class PatternProperties { private String dateformat; } Controller クラス\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // @RefreshScope // 自動更新の設定 @RestController @RequestMapping(\u0026#34;/user\u0026#34;) public class UserController{ // @Value(\u0026#34;${pattern.dateformat}\u0026#34;) // private String dateformat; @Autowired private PatternProperties properties; @GetMapping(\u0026#34;/now\u0026#34;) public String now(){ return LocalDateTime.now().format(DateTimeFormatter.ofPattern(properties.getDateformat())) } } 共有の構成 マイクロサービスが起動すると、Nacos から複数の設定ファイルを読み取ります。\n[spring.application.name]-[spring.profiles.active].yaml，例えば：userService-dev.yaml\n[spring.application.name].yaml，例えば：userService.yaml\n2番目の [spring.application.name].yaml には環境が含まれていないため、複数の環境で共有できます。\n設定の優先順位: [spring.application.name]-[spring.profiles.active].yaml \u0026gt; [spring.application.name].yaml \u0026gt; ローカル設定\n","date":"2024-05-02T22:36:17+08:00","permalink":"https://blog.yexca.net/ja/archives/169/","title":"Nacos 登録センター"},{"content":"コンシューマによって開始されたリクエストはリボンによってインターセプトされ、リボンはユーレカからプロバイダリストを取得し、ユーレカはプロバイダリストを返し、リボンはIRuleに基づいてリクエストを開始するサーバを選択します。\n詳細なインターセプション: リクエスト -\u0026gt; DynamicServerListLoadBalancer (URL 内のサービス ID、userService を取得) -\u0026gt; DynamicServerListLoadBalancer -\u0026gt; Eureka -\u0026gt; DynamicServerListLoadBalancer -\u0026gt; IRule -\u0026gt; DynamicServerListLoadBalancer -\u0026gt; リクエストの開始\n負荷分散戦略 組み込みの負荷分散ルールクラス ルールの説明 ZoneAvoidanceRule(Eureka 默认) サーバーの選択は、その地域で利用可能なサーバーに基づいて行われます。ゾーンを使用してサーバーを分類します。このゾーンは、コンピューター ルーム、ラックなどとして理解できます。次にゾーン内の複数のサービスをポーリングします RoundRobinRule サービス リストをポーリングするだけでサーバーを選択できます。これはリボンのデフォルトの負荷分散ルールです AvailabilityFilteringRule 次の 2 種類のサーバーは無視されます: (1) デフォルトでは、このサーバーへの接続が 3 回失敗すると、サーバーは「短絡」状態に設定されます。短絡状態は30秒間続きます。接続が再度失敗すると、短絡の持続時間は指数関数的に増加します。 (2) 同時接続数が多すぎるサーバー。サーバーへの同時接続数が多すぎる場合、AvailabilityFilteringRule ルールが設定されたクライアントもそれを無視します。同時接続の上限は、クライアントの\u0026lt;clientName\u0026gt;.\u0026lt;clientConfigNameSpace\u0026gt;.ActiveConnectionsLimitプロパティで設定できます。 WeightedResponseTimeRule 各サーバーに重み値を割り当てます。サーバーの応答時間が長くなるほど、このサーバーの重みは小さくなります。このルールはサーバーをランダムに選択します。この重み値はサーバーの選択に影響します。 BestAvailableRule 短絡したサーバーを無視し、同時実行性の低いサーバーを選択する RandomRule 利用可能なサーバーをランダムに選択 RetryRule 再試行メカニズムの選択ロジック ランダム戦略の使用 負荷分散ルールは、次の 2 つの方法で IRule 実装を定義することによって変更できます。\nコードメソッド: 構成クラスで、新しい IRule（グローバル設定）を定義します。 1 2 3 4 @Bean public IRule randomRule(){ return new RandomRule(); } 設定ファイル方式: orderServer application.yml ファイルで、ルールを変更するための新しい設定を追加します。 1 2 3 userService: # マイクロサービスの負荷分散ルールを設定します。ここでは userservice サービスです ribbon: NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule # 負荷分散ルール 遅延読み込み Ribbon はデフォルトで遅延読み込みを使用します。つまり、初めてアクセスされたときにのみ LoadBalanceClient が作成され、要求時間が非常に長くなります。プロジェクトの開始時にハングリー読み込みが作成され、最初のアクセスの時間消費が短縮されます。ハングリー読み込みを有効にするには、次のように構成します。\n1 2 3 4 ribbon: eager-load: enabled: true clients: userService # userService サービスのハングリーロードを指定します ","date":"2024-04-28T15:50:15+08:00","permalink":"https://blog.yexca.net/ja/archives/168/","title":"Ribbon 負荷分散"},{"content":" この記事の一部は機械翻訳を使ったよ\nGolang シリーズ\nHello GoLang: https://blog.yexca.net/ja/archives/154 GoLang (var and const) 変数と定数: https://blog.yexca.net/ja/archives/155 GoLang (func) 関数: https://blog.yexca.net/ja/archives/156 GoLang (slice and map) スライス: https://blog.yexca.net/ja/archives/160 GoLang (OOP) オブジェクト指向: この記事\nGoLang (reflect) リフレクション: https://blog.yexca.net/ja/archives/204 GoLang (struct tag) 構造タグ: https://blog.yexca.net/ja/archives/205 GoLang (goroutine) ゴルーチン: https://blog.yexca.net/ja/archives/206 GoLang (channel) チャンネル: https://blog.yexca.net/ja/archives/207 造を使用してクラスとオブジェクトの概念を構築する\nオブジェクト指向を理解する: オブジェクト指向の基礎(簡体字中国語だけど) struct まずは、C に似た type キーワードを使用したカスタム型です。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package main import \u0026#34;fmt\u0026#34; type myType int func main() { var a myType fmt.Println(\u0026#34;a =\u0026#34;, a) fmt.Printf(\u0026#34;type of a is %T\u0026#34;, a) } /* * 出力 * a = 0 * type of a is main.myTye */ stuct を使用して型を定義する\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package main import \u0026#34;fmt\u0026#34; type Person struct { name string age int } fun main() { var zhang Person zhang.name = \u0026#34;zhangSan\u0026#34; zhang.age = 20 fmt.Print(zhang) } 関数転送は関連しており、ポインタは使用されず、値の転送です\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 package main import \u0026#34;fmt\u0026#34; type Person struct { name string age int } // 値の転送、元のデータは変更されません func changeName(person Person) { person.name = \u0026#34;liSi\u0026#34; } // 参照を渡すと元のデータが変更されます func changeAge(person *Person) { person.age = 18 } func main() { var zhang Person zhang.name = \u0026#34;zhangSan\u0026#34; zhang.age = 20 fmt.Println(zhang) changeName(zhang) fmt.Println(zhang) changeAge(\u0026amp;zhang) fmt.Println(zhang) } カプセル化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 package main import \u0026#34;fmt\u0026#34; // クラス type Person struct { // プロパティ name string age int } // クラスメソッド func (this *Person) SetName(name string) { this.name = name } func (this *Person) SetAge(age int) { this.age = age } func (this *Person) GetName() string { return this.name } func (this *Person) GetAge() int { return this.age } func main() { person := Person{name: \u0026#34;zhangSan\u0026#34;, age: 18} fmt.Println(person) } クラス名とメソッド名の最初の文字が大文字になっていることに注意してください。これは、クラスとメソッドが他のパッケージからアクセスできることを意味します (java public)。最初の文字が小文字の場合は、このパッケージからのみアクセスできます (java private) プロパティについても同様です。\n継承 次のコードは同じファイル、親クラスにあります\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 親クラス type Person struct { name string age int } // 親クラスのメソッド func (this *Person) Eat() { fmt.Println(\u0026#34;Person Eat...\u0026#34;) } func (this *Person) Walk() { fmt.Println(\u0026#34;Person Walk...\u0026#34;) } サブクラス\n1 2 3 4 5 6 7 8 9 10 11 12 13 // サブクラス type SuperMan struct { Person // 親クラスから継承 level int // サブクラス属性 } // サブクラスは親クラスのメソッドをオーバーライドします func (this *SuperMan) Walk() { fmt.Println(\u0026#34;SuperMan Walk\u0026#34;) } // サブクラス固有のメソッド func (this *SuperMan) Fly() {} main 関数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func main() { // サブクラスの属性を定義する、方法 1 superMan1 := SuperMan{Person{\u0026#34;zhangSan\u0026#34;, 18}, 4} // サブクラスの属性を定義する、方法 2 var superMan2 SuperMan superMan2.name = \u0026#34;liSi\u0026#34; // 同じパッケージ内にあるため、親クラスの属性にアクセスできます superMan2.age = 20 superMan2.level = 5 // サブクラスは親クラスのメソッドを呼び出す superMan1.Eat() // サブクラスのオーバーライドメソッド superMan1.Walk() // サブクラスメソッド superMan2.Fly() } 多態性 次のコードは同じファイルにあり、インターフェースを定義しています\n1 2 3 4 5 6 // インターフェース、基本的にはポインタ type Animal interface { Sleep() GetName() string GetType() string } 実装クラス 1\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 実装クラス 1 type Cat struct { name string kind string } // インターフェースのすべてのメソッドを実装する func (this *Cat) Sleep() { fmt.Println(\u0026#34;Cat Sleep()\u0026#34;) } func (this *Cat) GetName() string { return this.name } func (this *Cat) GetType() string { return this.kind } 実装クラス 2\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // 実装クラス 2 type Dog struct { name string kind string } // インターフェースのすべてのメソッドを実装する func (this *Dog) Sleep() { fmt.Println(\u0026#34;Cat Sleep()\u0026#34;) } func (this *Dog) GetName() string { return this.name } func (this *Dog) GetType() string { return this.kind } func ShowAnimal(animal Animal) { fmt.Println(animal) } main\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 func ShowAnimal(animal Animal) { fmt.Println(animal) } func main() { var animal Animal animal = \u0026amp;Cat{\u0026#34;cat1\u0026#34;, \u0026#34;cat\u0026#34;} animal.Sleep() animal = \u0026amp;Dog{\u0026#34;dog1\u0026#34;, \u0026#34;dog\u0026#34;} animal.Sleep() cat := Cat{\u0026#34;cat2\u0026#34;, \u0026#34;cat\u0026#34;} dog := Dog{\u0026#34;dog2\u0026#34;, \u0026#34;dog\u0026#34;} ShowAnimal(\u0026amp;cat) ShowAnimal(\u0026amp;dog) } ユニバーサル型とアサーション 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package main import \u0026#34;fmt\u0026#34; // ユニバーサルデータ型を表すために空のインターフェースを使用する func f(arg interface{}) { // 型アサーションメカニズム (つまり型変換) value, flag := arg.(string) if !flag { fmt.Println(\u0026#34;arg is not string type\u0026#34;) } else { fmt.Println(\u0026#34;arg is string type, arg =\u0026#34;, value) } } func main() { // カスタムを含む任意のデータ型を渡すことができます f(\u0026#34;abc\u0026#34;) f(123) f(3.14) } /* * 出力 * arg is string type, arg = abc * arg is not string type * arg is not string type */ ","date":"2024-03-01T15:35:38+08:00","permalink":"https://blog.yexca.net/ja/archives/162/","title":"GoLang オブジェクト指向"},{"content":"レジストリを導入する前に、プロバイダーとコンシューマーの概念を紹介します。\nプロバイダーとコンシューマー サービス プロバイダー: ビジネス内の他のマイクロサービスによって呼び出されるサービス。 (他のマイクロサービスへのインターフェースを提供する)\nサービス コンシューマー: 1 つのビジネス内の他のマイクロサービスを呼び出すサービス。 (他のマイクロサービスによって提供されるインターフェースの呼び出し)\nプロバイダーとコンシューマーは相対的です。サービスはプロバイダーとコンシューマーの両方になることができます。\nEureka プロバイダーが複数ある場合、消費者はどのようにしてプロバイダー情報を入手し、プロバイダーの健全性状態を知ることができるのでしょうか?\n起動時に、マイクロサービスは Eureka にサービス情報を登録します。コンシューマーは Eureka を通じてプロバイダー情報を取得し、それをリモートで呼び出すことができます。マイクロサービスは 30 秒ごとに Eureka にまだ稼働中であることを通知し、Eureka はサービス リスト情報を更新して、正常でないサーバーを削除します。\n複数のサービス プロバイダーがある場合、コンシューマーは負荷分散アルゴリズムを使用してサービス リストから 1 つを選択します。\n建てる 新しい Maven モジュールを作成し、依存関係を導入する\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-eureka-server\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; スタートアップクラスの作成\n1 2 3 4 5 6 7 @EnableEurekaServer @SpringBootApplication public class EurekaApplication { public static void main(String[] args) { SpringApplication.run(EurekaApplication.class,args); } } 設定ファイル\n1 2 3 4 5 6 7 8 9 server: port: 7995 spring: application: name: eureka-server eureka: client: service-url: defaultZone: http://127.0.0.1:7995/eureka サービスに登録する 依存関係の導入\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-eureka-client\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 構成の記述\n1 2 3 4 5 6 7 spring: application: name: userService eureka: client: service-url: defaultZone: http://127.0.0.1:7995/eureka サービスの利用 上記の登録例\n1 2 3 4 5 @Bean @LoadBalanced public RestTemplate restTemplate(){ return new RestTemplate(); } ドメイン名をサービス名に変更する\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 @Service public class OrderService { @Autowired private OrderMapper orderMapper; @Autowired private RestTemplate restTemplate; public Order queryOrderById(Long orderId) { // 1.注文をクエリ Order order = orderMapper.findById(orderId); // 2.ユーザーをクエリ // String url = \u0026#34;http://localhost:8081/user/\u0026#34; + order.getUserId(); String url = \u0026#34;http://userService/user/\u0026#34; + order.getUserId(); User user = restTemplate.getForObject(url, User.class); // 3.ユーザー情報をカプセル化する order.setUser(user); // 4.戻る return order; } } ","date":"2024-02-29T16:53:15+08:00","permalink":"https://blog.yexca.net/ja/archives/161/","title":"登録センター - Eureka"},{"content":" この記事の一部は機械翻訳を使ったよ\nGolang シリーズ\nHello GoLang: https://blog.yexca.net/ja/archives/154 GoLang (var and const) 変数と定数: https://blog.yexca.net/ja/archives/155 GoLang (func) 関数: https://blog.yexca.net/ja/archives/156 GoLang (slice and map) スライス: この記事\nGoLang (OOP) オブジェクト指向: https://blog.yexca.net/ja/archives/162 GoLang (reflect) リフレクション: https://blog.yexca.net/ja/archives/204 GoLang (struct tag) 構造タグ: https://blog.yexca.net/ja/archives/205 GoLang (goroutine) ゴルーチン: https://blog.yexca.net/ja/archives/206 GoLang (channel) チャンネル: https://blog.yexca.net/ja/archives/207 Go のスライスは配列の抽象化である\n配列 配列の長さは変更できません\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package main import \u0026#34;fmt\u0026#34; func main() { // 定義方法 1 var arr1 [10]int // トラバース for i := 0; i \u0026lt; len(arr1); i++ { fmt.Println(\u0026#34;arr1[\u0026#34;, i, \u0026#34;]:\u0026#34;, arr1[i]) } // 定義方法 2、代入 arr2 := [10]int{0, 1, 2, 3} // range トラバーサル for index, value := range arr2 { fmt.Println(\u0026#34;index =\u0026#34;, index, \u0026#34;value =\u0026#34;, value) } // 異なる長さを定義する var arr3 [4]int fmt.Printf(\u0026#34;type of arr1 is %T\\n\u0026#34;, arr1) // [10]int fmt.Printf(\u0026#34;type of arr1 is %T\\n\u0026#34;, arr2) // [10]int fmt.Printf(\u0026#34;type of arr1 is %T\u0026#34;, arr3) // [4]int } コンパイルして実行すると、arr3 が arr1 および arr2 とは異なる型であることがわかります。そのため、関数パラメータを定義するときにも対応する型を指定する必要があります。\n1 2 3 4 5 func test(arr [4]int) { for i := 0; i \u0026lt; len(arr); i++ { fmt.Println(\u0026#34;fmt_arr[\u0026#34;, i, \u0026#34;]:\u0026#34;, arr[i]) } } 上記の関数は arr3 を値で渡すことしかできず、値を変更しても元のデータには影響しません。\nスライスを定義する 配列と比較すると、スライスは固定長ではなく、要素を追加することができます（動的配列）。追加するとスライスの容量が増加する可能性があります。\nスライスは、サイズが指定されていない配列を宣言することによって定義できます。\n1 2 3 var name []type // 例えば var s []int または make() 関数を使用してスライスを作成する\n1 2 3 var slice []type = make([]type, len) // len はスライスの初期の長さです // 次のように省略することもできます slice := make([]type, len) オプションの capacity パラメータを使用して容量を指定できます。省略した場合は、length と同じになります。\n1 var slice []type = make([]type, length, capacity) スライスの初期化 直接初期化\n1 s := []int {1, 2, 3} 配列の値を startIndex から endIndex-1 までのスライスとして初期化します。両方の値は省略できます。\n1 s := arr[startIndex:endIndex] startIndex または endIndex を省略すると、最初の要素からインデックス付けするか、最後の要素までインデックス付けすることを意味します。\nlen() と cap() スライスはインデックス可能であり、その長さは len() 関数を使用して取得できます。\ncap() は容量を計算するメソッドであり、スライスが到達できる長さを測定できます。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package main import \u0026#34;fmt\u0026#34; // スライス渡しは参照渡しであり、関数内の変更は元のデータに影響します func printSlice(slice []int) { fmt.Printf(\u0026#34;len=%d, cap=%d, slice=%v\u0026#34;, len(slice), cap(slice), slice) } func main() { s := make([]int, 3, 5) printSlice(s) } /* * 出力 * len=3, cap=5, slice=[0 0 0] */ 空のスライス スライスは初期化前はデフォルトで nil (空のスライス) であり、その長さは 0 です。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package main import \u0026#34;fmt\u0026#34; func printSlice(slice []int) { fmt.Printf(\u0026#34;len=%d, cap=%d, slice=%v\\n\u0026#34;, len(slice), cap(slice), slice) } func main() { var s []int printSlice(s) // 空かどうか確認する if s == nil { fmt.Println(\u0026#34;slice is empty\u0026#34;) } } スライスインターセプション 上限と下限を設定してスライスをカットする\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package main import \u0026#34;fmt\u0026#34; func printSlice(slice []int) { fmt.Printf(\u0026#34;len=%d, cap=%d, slice=%v\\n\u0026#34;, len(slice), cap(slice), slice) } func main() { s := []int{0, 1, 2, 3, 4, 5, 6, 7} // 元のスライスを印刷する fmt.Println(s) // 2(含む) から 5(含まない) まで printSlice(s[2:5]) // 1 番目から 5 まで (含まない) printSlice(s[:5]) // 2 番目から最後まで printSlice(s[2:]) // この割り当てと subS の変更は s に影響します subS := s[1:6] printSlice(subS) } append() と copy() スライスの容量を増やし、スライスをコピーする\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package main import \u0026#34;fmt\u0026#34; func printSlice(slice []int) { fmt.Printf(\u0026#34;len=%d, cap=%d, slice=%v\\n\u0026#34;, len(slice), cap(slice), slice) } func main() { var s []int printSlice(s) // 要素を追加する s = append(s, 0) printSlice(s) // 複数の要素を追加する s = append(s, 1, 2, 3, 4) printSlice(s) // s の 2 倍の容量を持つ s2 を作成します s2 := make([]int, len(s), cap(s)*2) // s を s2 にコピーします。s2 を変更しても s には影響しません。 copy(s2, s) printSlice(s2) } スライス拡張: 追加された値が容量を超える場合、容量は2倍になります\nmap map を宣言する方法は 2 つあります\n1 2 3 4 5 6 7 8 9 10 11 package main import \u0026#34;fmt\u0026#34; func main() { var map1 = make(map[string]string) // データを挿入 map1[\u0026#34;one\u0026#34;] = \u0026#34;1\u0026#34; map1[\u0026#34;two\u0026#34;] = \u0026#34;2\u0026#34; fmt.Println(map1) // map[one:1 two:2] } 2 番目\n1 2 3 4 5 6 7 8 9 10 11 package main import \u0026#34;fmt\u0026#34; func main() { map1 := map[string]string{ \u0026#34;one\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;two\u0026#34;: \u0026#34;2\u0026#34;, } fmt.Println(map1) } map のネスト 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package main import \u0026#34;fmt\u0026#34; func main() { map1 := make(map[string]map[string]string) map1[\u0026#34;first\u0026#34;] = make(map[string]string, 2) map1[\u0026#34;first\u0026#34;][\u0026#34;one\u0026#34;] = \u0026#34;1\u0026#34; map1[\u0026#34;first\u0026#34;][\u0026#34;two\u0026#34;] = \u0026#34;2\u0026#34; fmt.Println(map1) } /* * 出力 * map[first:map[one:1 two:2]] */ トラバーサルを変更して削除する 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package main import \u0026#34;fmt\u0026#34; func main() { map1 := make(map[string]map[string]string) map1[\u0026#34;first\u0026#34;] = make(map[string]string, 2) map1[\u0026#34;first\u0026#34;][\u0026#34;one\u0026#34;] = \u0026#34;1\u0026#34; map1[\u0026#34;first\u0026#34;][\u0026#34;two\u0026#34;] = \u0026#34;2\u0026#34; // 改訂 map1[\u0026#34;first\u0026#34;][\u0026#34;one\u0026#34;] = \u0026#34;one\u0026#34; fmt.Println(map1) // トラバース for key, value := range map1{ fmt.println(\u0026#34;key =\u0026#34;, key, \u0026#34;value =\u0026#34;, value) } // 消去 delete(map1, \u0026#34;first\u0026#34;) fmt.Println(map1) } 特定の値があるかどうかを判定する 1 2 3 4 5 6 7 8 9 10 11 12 13 14 package main import \u0026#34;fmt\u0026#34; func main() { map1 := make(map[string]string) map1[\u0026#34;one\u0026#34;] = \u0026#34;1\u0026#34; val, key := map1[\u0026#34;one\u0026#34;] if key { fmt.Println(val) } else { fmt.Println(\u0026#34;empty\u0026#34;) } } ","date":"2024-02-27T20:00:00+08:00","permalink":"https://blog.yexca.net/ja/archives/160/","title":"GoLang スライス"},{"content":"サービスアーキテクチャ モノリシックアーキテクチャ すべてのビジネス機能を1つのプロジェクトで開発し、展開用に1つのパッケージにパッケージ化します。\n利点: シンプルなアーキテクチャ、スケーラビリティが低い、導入コストが低い、小規模プロジェクトに適している\nデメリット: 結合度が高い\n分散アーキテクチャ システムは業務機能ごとに分割されており、各業務モジュールはサービスと呼ばれる独立したプロジェクトとして開発されている。\n利点: サービスの結合を減らし、サービスのアップグレードと拡張を容易にする\nデメリット: 複雑なアーキテクチャ、使いにくい、大規模なインターネットプロジェクトに適している\nマイクロサービス マイクロサービスは、適切に設計された分散アーキテクチャ ソリューションです。マイクロサービス アーキテクチャの特徴:\n単一責任 (簡体字中国語) : マイクロサービスはより細かい粒度に分割されます。各サービスは固有のビジネス機能に対応しており、単一責任を実現し、重複したビジネス開発を回避します。 サービス指向: マイクロサービスはビジネスインターフェースを外部に公開します 自律性: チームの独立性、テクノロジーの独立性、データの独立性、展開の独立性 強力な分離: サービス呼び出しは分離され、フォールトトレラントであり、連鎖的な問題を回避するためにダウングレードされます。 マイクロサービス技術 マイクロサービス ソリューションには技術フレームワークの実装が必要です。最も一般的なものは次のとおりです。\nDubbo SpringCloud SpringCloudAlibaba 登録センター zookeeper、 Redis Eureka、 Consul Nacos、 Eureka リモートサービスコール Dubbo プロトコル Feign (http プロトコル) Dubbo、Feign 構成センター 无 SpringCloudConfig SpringCloudConfig、 Nacos サービスゲートウェイ 无 SpringCloudGateway、 Zuul SpringCloudGateway、 Zuul サービスの監視と保護 dubbo-admin，弱い機能 Hystix Sentinel マイクロサービスはビジネスモジュールに応じて分割する必要がある\n単一責任: 異なるマイクロサービスに対して同じビジネスを繰り返し開発しない データの独立性: 他のマイクロサービスのデータベースにアクセスしない サービス指向: 独自のビジネスを他のマイクロサービスが呼び出すためのインターフェースとして公開する SpringCloud SpringCloud は現在最も広く使用されているマイクロサービス フレームワークです。さまざまなマイクロサービス機能コンポーネントを統合し、SpringBoot に基づいてこれらのコンポーネントの自動アセンブリを実装します。\n公式サイト: https://spring.io/projects/spring-cloud/ サービス登録と検出: Eureka、Nacos、Consul 統合構成管理: SpringCloudConfig、Nacos リモートサービスコール: OpenFeign、Dubbo 統合ゲートウェイルーティング: SpringCloudGateway、Zuul サービスリンク監視: Zipkin、Sleuth フロー制御、劣化、保護: Hystix、Sentinel マイクロサービス呼び出し 要件: 注文 ID に基づいて注文を照会する場合、注文が属するユーザー情報を返します。\nRestTemplate を登録する 1 2 3 4 @Bean public RestTemplate restTemplate(){ return new RestTemplate(); } サービスリモート呼び出し RestTemplate 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 @Service public class OrderService { @Autowired private OrderMapper orderMapper; @Autowired private RestTemplate restTemplate; public Order queryOrderById(Long orderId) { // 1.注文をクエリ Order order = orderMapper.findById(orderId); // 2.ユーザーをクエリ String url = \u0026#34;http://localhost:8081/user/\u0026#34; + order.getUserId(); // RestTemplateのGETメソッド User user = restTemplate.getForObject(url, User.class); // 3.ユーザー情報をカプセル化する order.setUser(user); // 4.戻る return order; } } ","date":"2024-02-25T17:56:54+08:00","permalink":"https://blog.yexca.net/ja/archives/158/","title":"Hi SpringCloud"},{"content":" この記事の一部は機械翻訳を使ったよ\nGolang シリーズ\nHello GoLang: https://blog.yexca.net/ja/archives/154 GoLang (var and const) 変数と定数: https://blog.yexca.net/ja/archives/155 GoLang (func) 関数: この記事\nGoLang (slice and map) スライス: https://blog.yexca.net/ja/archives/160 GoLang (OOP) オブジェクト指向: https://blog.yexca.net/ja/archives/162 GoLang (reflect) リフレクション: https://blog.yexca.net/ja/archives/204 GoLang (struct tag) 構造タグ: https://blog.yexca.net/ja/archives/205 GoLang (goroutine) ゴルーチン: https://blog.yexca.net/ja/archives/206 GoLang (channel) チャンネル: https://blog.yexca.net/ja/archives/207 複数の戻り値 Go 関数は複数の値を返すことができる\n匿名の戻り 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package main import \u0026#34;fmt\u0026#34; func swap(a, b int) (int, int) { return b, a } func main() { var x, y = swap(10, 20) fmt.Println(x, y) } /* 出力 * 20 10 */ パラメータ名を返す 1 2 3 4 5 6 7 8 9 10 11 12 13 14 package main import \u0026#34;fmt\u0026#34; func swap(a, b int) (x int, y int) { x = b y = a return } func main() { var x, y = swap(10, 20) fmt.Println(x, y) } 上記の戻り値は同じ型であり、組み合わせることができる\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package main import \u0026#34;fmt\u0026#34; func swap(a, b int) (x, y int) { x = b y = a // 如果不给 x,y 赋值，默认为0 return } func main() { var x, y = swap(10, 20) fmt.Println(x, y) } init と main init はどのパッケージにも、あるいは同じパッケージに複数回出現することができますが、1 つだけ記述することをお勧めします。\nmain は package main 内にのみ存在でき、パッケージにはこの関数がなければなりません。\nこれら 2 つの関数は予約関数であり、定義時にパラメーターや戻り値を持つことはできません。\nGo プログラムは自動的に init() と main() を呼び出す\nプログラムの実行 プログラムの初期化と実行はすべて main パッケージから始まります。同じパッケージが複数のパッケージでインポートされた場合でも、インポートされるのは 1 回だけです。次の図は実行順序を示しています。\n例\n次の構造を想定する\n1 2 3 4 5 6 hello -- InitLib1 -- lib1.go -- InitLib2 -- lib2.go main.go 内容は以下のとおりです\nlib1.go\n1 2 3 4 5 6 7 package InitLib1 import \u0026#34;fmt\u0026#34; func init() { fmt.Println(\u0026#34;lib1 init\u0026#34;) } lib2.go\n1 2 3 4 5 6 7 package InitLib2 import \u0026#34;fmt\u0026#34; func init() { fmt.Println(\u0026#34;lib2 init\u0026#34;) } main.go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package main import ( \u0026#34;fmt\u0026#34; // ここでのアンダースコアはパッケージの別名です。別名でない場合はインポートは呼び出されず、コンパイルは成功しません。 _ \u0026#34;hello/InitLib1\u0026#34; _ \u0026#34;hello/InitLib2\u0026#34; ) func init() { fmt.Println(\u0026#34;main init\u0026#34;) } func main() { fmt.Println(\u0026#34;main\u0026#34;) } 運用結果\n1 2 3 4 lib1 init lib2 init main init main Lib1 パッケージを Lib2 にインポートすると、main コードは変更されません。\nlib1.go\n1 2 3 4 5 6 7 8 9 10 package InitLib1 import ( \u0026#34;fmt\u0026#34; _ \u0026#34;hello/InitLib2\u0026#34; ) func init() { fmt.Println(\u0026#34;lib1 init\u0026#34;) } main 結果を実行\n1 2 3 4 lib2 init lib1 init main init main lib2 は 1 回だけ出現する\n他のパッケージ関数を呼び出す 上記の例では、エイリアスとして _ を使用していますが、これは匿名であり、対応するパッケージ メソッドを呼び出すことはできません。\nlib1 に関数を追加する\nlib1.go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package InitLib1 import ( \u0026#34;fmt\u0026#34; //_ \u0026#34;hello/InitLib2\u0026#34; ) // 他のパッケージから呼び出す前に、最初の文字を大文字にする必要があります func Lib1Test() { fmt.Println(\u0026#34;lib1 test\u0026#34;) } func init() { fmt.Println(\u0026#34;lib1 init\u0026#34;) } main.go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package main import ( \u0026#34;fmt\u0026#34; // パッケージにエイリアスを付ける mylib1 \u0026#34;hello/InitLib1\u0026#34; _ \u0026#34;hello/InitLib2\u0026#34; ) func main() { // alias.method 経由で呼び出す mylib1.Lib1Test() fmt.Println(\u0026#34;main\u0026#34;) } /* * 出力 * lib1 init * lib2 init * lib1 test * main */ または . を直接使用して\nmain.go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 package main import ( \u0026#34;fmt\u0026#34; // エイリアスが . に変更されました。 . \u0026#34;hello/InitLib1\u0026#34; _ \u0026#34;hello/InitLib2\u0026#34; ) func main() { // 直接使用する Lib1Test() fmt.Println(\u0026#34;main\u0026#34;) } 推奨されません。 2 つのパッケージに同じ名前の関数がある場合、あいまいさが生じます。\nポインタ C ポインタに似ている\n数を呼び出すときにパラメータを渡す方法は、値渡しとポインタ（参照）渡しの 2 つがあります。デフォルトでは、この記事の最初のコードのように値の受け渡しが使用されます。\n変数に対応するメモリアドレスを取得するには \u0026amp; を使用します\n1 2 3 4 5 6 7 8 9 10 package main import ( \u0026#34;fmt\u0026#34; ) func main() { var a int fmt.Printf(\u0026#34;%x\u0026#34;, \u0026amp;a) } 参照渡しはメモリアドレスを関数に渡し、関数の変更は実際のパラメータに影響します。これはスワップ関数でもあり、今回はポインタを使用しています。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package main import \u0026#34;fmt\u0026#34; func swap(a, b *int) { var tmp = *a *a = *b *b = tmp } func main() { x, y := 10, 20 swap(\u0026amp;x, \u0026amp;y) fmt.Println(\u0026#34;x =\u0026#34;, x, \u0026#34;y =\u0026#34;, y) } defer defer ステートメントは、遅延関数と呼ばれる関数の呼び出しをスケジュールするために使用されます。その機能は次のとおりです。\n占有されているリソースを解放する 例外をキャッチして処理する 出力ログ try\u0026hellip;catch\u0026hellip;finally の finally に似ています\nファイルのオープン/クローズ、ロックの取得/解放、接続/切断などのペア操作を処理するためによく使用され、エラーや早期復帰が発生した場合でもリソースが適切に解放され、実行が保証されます。\n関数内に複数の defer ステートメントがある場合、それらはスタックと同様に LIFO (後入れ先出し) の順序で実行されます。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package main import \u0026#34;fmt\u0026#34; func deferDemo() { defer fmt.Println(\u0026#34;1\u0026#34;) defer fmt.Println(\u0026#34;2\u0026#34;) defer fmt.Println(\u0026#34;3\u0026#34;) defer fmt.Println(\u0026#34;4\u0026#34;) } func main() { deferDemo() } /* * 出力 * 4 * 3 * 2 * 1 */ recover ランタイム パニック例外がトリガーされると、プログラムはクラッシュします。recover は、例外をキャプチャする Java の try\u0026hellip;catch と同様に、ランタイム パニックを「インターセプト」するために使用される組み込み関数です。\nrecover は defer によって呼び出される関数内でのみ有効です\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 package main import \u0026#34;fmt\u0026#34; func deferDemo(i int) { var arr [10]int // エラーインターセプションはエラーの前に設定されます defer func() { // エラーメッセージを傍受するように recover を設定する err := recover() if err != nil { fmt.Println(err) } }() arr[i] = 10 } func main() { deferDemo(10) fmt.Println(\u0026#34;main code\u0026#34;) } /* * 出力 * runtime error: index out of range [10] with length 10 * main code */ ","date":"2024-02-22T04:47:28+08:00","permalink":"https://blog.yexca.net/ja/archives/156/","title":"GoLang 関数"},{"content":" この記事の一部は機械翻訳を使ったよ\nGolang シリーズ\nHello GoLang: https://blog.yexca.net/ja/archives/154 GoLang (var and const) 変数と定数: この記事\nGoLang (func) 関数: https://blog.yexca.net/archives/ja/156 GoLang (slice and map) スライス: https://blog.yexca.net/ja/archives/160 GoLang (OOP) オブジェクト指向: https://blog.yexca.net/ja/archives/162 GoLang (reflect) リフレクション: https://blog.yexca.net/ja/archives/204 GoLang (struct tag) 構造タグ: https://blog.yexca.net/ja/archives/205 GoLang (goroutine) ゴルーチン: https://blog.yexca.net/ja/archives/206 GoLang (channel) チャンネル: https://blog.yexca.net/ja/archives/207 変数 変数は通常 var キーワードを使用して宣言されます\n単一変数 タイプを定義する 初期値が指定されていない場合、デフォルトは 0 です。\n1 2 3 4 5 6 7 8 package main import \u0026#34;fmt\u0026#34; func main() { var a int fmt.Println(\u0026#34;a =\u0026#34;, a) } 初期値を指定します。a は 100 です。\n1 2 3 4 5 6 7 8 package main import \u0026#34;fmt\u0026#34; func main() { var a int = 100 fmt.Println(\u0026#34;a =\u0026#34;, a) } 省略タイプ 宣言時に型がわからない場合、Go は変数の型を自動的に決定します。\n1 2 3 4 5 6 7 8 9 10 11 12 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) func main() { var a = 100 fmt.Println(\u0026#34;a =\u0026#34;, a) fmt.Printf(\u0026#34;Type of a = %s\u0026#34;, reflect.TypeOf(a)) } := 省略に応じて型が自動的に決定され、:= を使用して変数を直接宣言できます。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) func main() { p := 3.14 fmt.Println(\u0026#34;p =\u0026#34;, p) fmt.Printf(\u0026#34;Type of p is %s\u0026#34;, reflect.TypeOf(p)) } /* * 出力 * p = 3.14 * Type of p is float64 */ 多変量 同じタイプ 1 2 3 4 5 6 7 8 9 package main import \u0026#34;fmt\u0026#34; func main() { var a, b int fmt.Println(\u0026#34;a =\u0026#34;, a) fmt.Println(\u0026#34;b =\u0026#34;, b) } 同じタイプの割り当て 1 2 3 4 5 6 7 8 9 package main import \u0026#34;fmt\u0026#34; func main() { var a, b int = 100, 200 fmt.Println(\u0026#34;a =\u0026#34;, a) fmt.Println(\u0026#34;b =\u0026#34;, b) } 異なるタイプ 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) func main() { var a, b = 100, 3.14 fmt.Println(\u0026#34;a =\u0026#34;, a) fmt.Printf(\u0026#34;Type of a is %s\\n\u0026#34;, reflect.TypeOf(a)) fmt.Println(\u0026#34;b =\u0026#34;, b) fmt.Printf(\u0026#34;Type of b is %s\u0026#34;, reflect.TypeOf(b)) } /* * 出力 * a = 100 * Type of a is int * b = 3.14 * Type of b is float64 */ 異なるタイプ 2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) func main() { a, b := 100, \u0026#34;Hello\u0026#34; fmt.Println(\u0026#34;a =\u0026#34;, a) fmt.Printf(\u0026#34;Type of a is %s\\n\u0026#34;, reflect.TypeOf(a)) fmt.Println(\u0026#34;b =\u0026#34;, b) fmt.Printf(\u0026#34;Type of b is %s\u0026#34;, reflect.TypeOf(b)) } Go の文字列型は、基になる配列へのポインタと長さを含む構造体です。これら 2 つの部分はそれぞれ 8 バイトなので、文字列型のサイズは 16 バイトになります。\nunsafe.Sizeof()関数を使用して、タイプ占有率が見られます。\nグローバル変数 グローバル変数は := を使用して宣言することはできません\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) var a, b int func main() { fmt.Println(\u0026#34;a =\u0026#34;, a) fmt.Printf(\u0026#34;Type of a is %s\\n\u0026#34;, reflect.TypeOf(a)) fmt.Println(\u0026#34;b =\u0026#34;, b) fmt.Printf(\u0026#34;Type of b is %s\u0026#34;, reflect.TypeOf(b)) } または、グローバル変数に一般的に使用される分解を使用します。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) var ( a int = 1 b string = \u0026#34;Go\u0026#34; ) func main() { fmt.Println(\u0026#34;a =\u0026#34;, a) fmt.Printf(\u0026#34;Type of a is %s\\n\u0026#34;, reflect.TypeOf(a)) fmt.Println(\u0026#34;b =\u0026#34;, b) fmt.Printf(\u0026#34;Type of b is %s\u0026#34;, reflect.TypeOf(b)) } 定数 定数は通常、const キーワードを使用して定義されます。\n定義 1 2 3 4 5 6 7 8 package main import \u0026#34;fmt\u0026#34; func main() { const c int = 9 fmt.Println(\u0026#34;c = \u0026#34;, c) } タイプを省略することもできます\n1 2 3 4 5 6 7 8 package main import \u0026#34;fmt\u0026#34; func main() { const c = 9 fmt.Println(\u0026#34;c = \u0026#34;, c) } 列挙 定数定義は列挙に使用できる\n1 2 3 4 5 6 7 8 9 package main func main() { const ( BEIJING = 0 SHANGHAI = 1 SHENZHEN = 2 ) } iota 自己増加 上記の列挙は 0 から始まり、増分で増加します。代わりに iota を使用できます。\n1 2 3 4 5 6 7 8 9 10 11 12 13 package main import \u0026#34;fmt\u0026#34; func main() { const ( BEIJING = iota // 0 SHANGHAI // 1 SHENZHEN // 2 ) fmt.Println(BEIJING, SHANGHAI, SHENZHEN) } iota は式の中で使用できますが、通常は自動増分に使用されます\n","date":"2024-02-20T06:41:18+08:00","permalink":"https://blog.yexca.net/ja/archives/155/","title":"GoLang 変数と定数"},{"content":" この記事の一部は機械翻訳を使ったよ\nGolang シリーズ\nHello GoLang: この記事\nGoLang (var and const) 変数と定数: https://blog.yexca.net/ja/archives/155 GoLang (func) 関数: https://blog.yexca.net/ja/archives/156 GoLang (slice and map) スライス: https://blog.yexca.net/ja/archives/160 GoLang (OOP) オブジェクト指向: https://blog.yexca.net/ja/archives/162 GoLang (reflect) リフレクション: https://blog.yexca.net/ja/archives/204 GoLang (struct tag) 構造タグ: https://blog.yexca.net/ja/archives/205 GoLang (goroutine) ゴルーチン: https://blog.yexca.net/ja/archives/206 GoLang (channel) チャンネル: https://blog.yexca.net/ja/archives/207 Go のダウンロード： https://go.dev/dl/ JetBrains GoLand： https://www.jetbrains.com/go/ Go の紹介 Go は直接コンパイルして直接実行し、デプロイできる静的型付け言語です。\n1 2 3 4 5 6 7 # 直接実行 go run hello.go # コンパイル go build hello.go # コンパイル後に実行 ./hello Go の応用例\n(1)、クラウドコンピューティングインフラ\n代表的なプロジェクト：docker、kubernetes、etcd、consul、cloudflare CDN、\u0026ldquo;七牛云存储(中国語)\u0026ldquo;など\n(2)、基本的なバックエンドソフトウェア\n代表的なプロジェクト：tidb、influxdb、cockroachdb など\n(3)、マイクロサービス\n代表的なプロジェクト：go-kit、micro、monzo bank的typhon、bilibili など\n(4)、インターネットインフラ\n代表的なプロジェクト：Ethereum、hyperledger など\nHello Go 1 2 3 4 5 6 7 8 9 10 11 package main // パッケージ名を定義する /* * ソースファイルの最初の非コメント行で、ファイルが属するパッケージを指定する必要があります。 * main は独立して実行可能なプログラムを表します。すべての Go アプリケーションには、main という名前のパッケージが含まれています。 */ import \u0026#34;fmt\u0026#34; // IO フォーマットの関数を実装するために fmt パッケージをインポートします func main(){ // 関数 fmt.println(\u0026#34;Hello Go\u0026#34;) } 一般的に、main 関数は起動後に最初に実行される関数です。init関数がある場合は、init 関数が最初に実行されます。\n関数を定義するときは { が関数名と同じ行になければなりません\n","date":"2024-02-19T07:58:37+08:00","permalink":"https://blog.yexca.net/ja/archives/154/","title":"Hello GoLang"},{"content":"SpringBoot 入門の例 要件：SpringBoot 开发一个 Web 应用，浏览器発行起 /hello 後，返字文字列 “Hello Spring” を使用します。\n最初に必要な SpringBoot 工程、段階选 web 开公開相关依赖\nその後、制御制御クラス、路線径が *Application.java に同定されています Controller/HelloController.java\n1 2 3 4 5 6 7 8 9 @RestController public class HelloController{ @RequestMapping(\u0026#34;/hello\u0026#34;) public String hello(){ String s = \u0026#34;Hello Spring\u0026#34;; System.out.println(s); return s; } } *Application.java を実行して，ブラウザで http://localhost:8080/hello にアクセスして。\nHTTP ハイパーテキスト転送プロトコルは、TCP プロトコル (接続指向、安全) と要求応答モデル (1 つの要求が 1 つの応答に対応する) に基づいています。\nHTTP プロトコルはステートレス プロトコルであり、トランザクション処理用のメモリ機能はありません。各リクエストとレスポンスは独立しているため高速ですが、複数のリクエスト間でデータを共有することはできません。\n詳細については (簡体字中国語)： https://blog.yexca.net/archives/64 ","date":"2024-01-10T17:53:18+08:00","permalink":"https://blog.yexca.net/ja/archives/142/","title":"JavaWeb 入門"},{"content":" 📢 この記事は ChatGPT によって翻訳されました 新しいディレクトリを作成し、Web ファイルを ./dict に配置する。\nプロジェクトルートに dockerfile ファイルを作成し、以下の内容を記述：\n1 2 3 4 5 6 # nginx:1.20 ベースのイメージを使用 FROM nginx:1.20 # dist フォルダの内容を nginx の静的ファイルディレクトリへコピー COPY dist/ /usr/share/nginx/html/dist/ # nginx 設定をローカルファイルで置き換える COPY nginx.conf /etc/nginx/nginx.conf nginx.conf ファイルの内容は以下の通り：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #user nobody; worker_processes 1; events { worker_connections 1024; } http { include mime.types; default_type application/octet-stream; sendfile on; #tcp_nopush on; keepalive_timeout 65; # HTTP サーバー設定 server { listen 80; server_name localhost; location / { root /usr/share/nginx/html/dist; index index.html index.htm; } error_page 500 502 503 504 /50x.html; location = /50x.html { root html; } } } 以下のコマンドでビルド：\n1 docker build -t username/imagename:v1.0 . tag でイメージ名を変更する Docker Hub にプッシュする際の命名規則：\n1 docker push ユーザー名/イメージ名 tag を変更するには：\n1 docker tag name username/imagename:v1.0 tag を付けなかった場合、デフォルトでは latest になる。 イメージのプッシュ：\n1 docker push username/imagename:v1.0 参考記事 docker: 打包h5项目的镜像 Docker镜像推送（push）到Docker Hub ","date":"2024-01-09T21:50:25+08:00","permalink":"https://blog.yexca.net/ja/archives/141/","title":"Docker で H5 イメージを作成・プッシュする"},{"content":" 📢 この記事は ChatGPT によって翻訳されました はじめに いつからか（正確な時期は忘れたけど）ASMR が好きになって、音声作品にも触れるようになった。\nでも価格が結構高いので、自然とネットで探すようになって、このサイトを知った。\nただし、このサイトはログインしないと詳細が見られず、しかも登録は年に数回の不定期オープン。\nそこで、サーバー側で登録可能かどうかを定期チェックし、登録可能なら Telegram に通知するようなツールを作った。\nGitHub: yexca/hvdb 目的 hvdb が登録可能なタイミングを監視し、登録可能であれば Telegram で通知。\n登録可能かどうかのチェック方法 灵梦广场 のスレッドによると、登録が開放されているときは login ページに register が表示されるらしい。\nならば、シンプルにそのページをクローリングして register という単語があるかどうかを確認するだけで OK。\nBot 設定 Telegram で通知を送るには、まず Bot を作成する必要がある。\nhttps://t.me/BotFather にアクセスし、/newbot と入力して手順に従い作成。\n作成した bot に hello などを送信してから、以下の URL にアクセス（TOKEN を自分のものに置き換える）：\n1 https://api.telegram.org/botTOKEN/getUpdates JSON が返ってくるので、その中から id を取得 → これが chat_id になる。\n参考： 使用Telegram Bot来实现推送通知 Python スクリプト Python でやるのが一番簡単（他言語は面倒だった）\nクローリングには requests を、通知には pyTelegramBotAPI を使用。\nファイル名は http.py や requests.py にしないこと（ライブラリと衝突する）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 import telebot import requests import time # 自分の Bot トークン bot = telebot.TeleBot(\u0026#34;TOKEN\u0026#34;, parse_mode=\u0026#34;MARKDOWN\u0026#34;) # デフォルトのパースモード def inform(): web = requests.get(\u0026#34;https://hvdb.me/\u0026#34;) str = web.text a = str.find(\u0026#34;register\u0026#34;) if a != -1: # chat_id を自分のに置き換える bot.send_message(\u0026#34;chat_id\u0026#34;, \u0026#34;[hvdb](http://hvdb.me/) register start\u0026#34;) t = 0 while True: inform() # 1時間ごとにチェック time.sleep(3600) # 実行時間をカウント t += 1 # 24時間ごとに動作報告 if t == 24: t -= 24 local_time = time.ctime(time.time()) inform_str = \u0026#34;{} 実行済み\u0026#34;.format(local_time) bot.send_message(\u0026#34;chat_id\u0026#34;, inform_str) 参考：\nAttributeError: module \u0026lsquo;requests\u0026rsquo; に関するエラー対処 requests - 廖雪峰の公式サイト Python time.sleep() - 菜鸟教程 Python 時刻・日付の使い方 Docker 化 ファイル構成：\n1 2 3 D:\\DOCKER\\HVDB Dockerfile inform.py Dockerfile：\n1 2 3 4 5 6 FROM python:3.11-alpine RUN pip install requests \\ \u0026amp;\u0026amp; pip install pyTelegramBotAPI COPY ./inform.py /app/inform.py CMD [ \u0026#34;python\u0026#34;, \u0026#34;/app/inform.py\u0026#34; ] 同じディレクトリで以下のコマンドでビルド：\n1 docker build -t hvdb:v1.0 . サーバーへ転送 Windows 側で：\n1 docker save -o hvdb:v1.0 hvdb.tar tar ができたらサーバーに転送：\n1 scp .\\hvdb.tar username@hostname:/path サーバー上で：\n1 docker load -i hvdb.tar 参考： docker load エラー「archive/tar: invalid tar header」の対処 ","date":"2023-12-02T21:23:01+08:00","permalink":"https://blog.yexca.net/ja/archives/133/","title":"hvdb 登録監視ツール"},{"content":" 📢 この記事は ChatGPT によって翻訳されました はじめに ブログを GitHub に移した後は「もう新しいサーバー買わなくていいかな〜」と思ってたけど、\nここ数ヶ月静かすぎて何かいじりたい気分になってきて、\nあと「使わないけど無いと不安」みたいな気持ちで衝動買いしちゃった。\n現在運営してるサイト（yexca.net ドメイン） 自己紹介？： http://yexca.net （まだ半分くらいしかできてない） このブログ： http://blog.yexca.net 懐かしのブログ： http://wp.yexca.net VRChatブログ： http://vrc.yexca.net VRChatドキュメント： http://vrchat.yexca.net Navidrome（自分用音楽）： http://music.yexca.net ACG関連： http://acg.yexca.net （DNSで記録見て思い出した、まだ用途未定） xlog（Web3）： http://xlog.yexca.net Docker Docker を知ってからというもの、ほぼすべてのプロジェクトを Docker で立てるようになった。マジ便利。\nDebian10 + root でログインしてまず更新：\n1 apt update 必要なパッケージをインストール：\n1 apt install curl gpg GPG鍵を追加：\n1 curl -fsSL https://download.docker.com/linux/debian/gpg | gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg Dockerのリポジトリを追加：\n1 2 3 echo \\ \u0026#34;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/debian \\ buster stable\u0026#34; | tee /etc/apt/sources.list.d/docker.list \u0026gt; /dev/null Docker をインストール：\n1 2 apt update apt install docker-ce docker-ce-cli containerd.io docker-compose Docker を起動・自動起動：\n1 2 systemctl enable docker systemctl start docker テスト用：\n1 docker run --rm hello-world 参考： 服务器用 Docker 部署记录 公開鍵ログイン 参考： SSH 公钥登录 Nginx 今回も nginx-ui プロジェクトを使った Docker デプロイ。docker-compose.yml は以下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 version: \u0026#39;3.1\u0026#39; services: nginx-ui: restart: always image: uozi/nginx-ui:latest container_name: nginx_UI volumes: - /home/nginx_ui/nginx:/etc/nginx - /home/nginx_ui/nginx-ui:/etc/nginx-ui - /home/nginx_ui/www:/www ports: - 80:80 - 443:443 DNS 側で HTTPS を有効化してる場合は、証明書の設定は不要。そうしないとブラウザからアクセス不可になっちゃう。\n自己紹介ページ 実は前のサーバーで全部 Docker 化する前から考えてた。 だから blog.yexca.xyz に変更したのも、yexca.xyz を空けたかったから。\nyexca.xyz は現在手放してる。\nフォルダ作成日を見たら 2022.03.07、最後の編集が 2022.06.29。完全に放置してた。\nこのアイデアを思いついたきっかけは他のブロガーの自己紹介ページを見たとき。たとえば https://idealclover.top/ 、 https://the.moe/ など。 中にはテンプレートを公開してる人もいて、自分の情報を入れれば紹介ページが作れるやつもあった（リンク失念\u0026hellip;）\n最終的には http://lolicon.app のようなデザインを真似ることにした（なんでだっけ\u0026hellip;）\n参考：\nCSS でスクロールバーをカスタマイズ Webサイトに favicon.ico を設定する方法 Navidrome 衝動買いのもう一つの理由が、良い音楽サイトを自分で持ちたかったから。 以前は Onedriveベースのやつ を使ってたけど、中国からだとアクセスが遅い。 ちょうど 115 がセールしてたから契約した → それが今回のトリガー。\n結論：超微妙。OneDrive より遅い。やっぱ衝動買いは良くない。 最初は気に入ったら kikoeru-express も立てようかと思ってたけど\u0026hellip;ナシだな。\nRclone（115 対応） 115をマウントするには、115対応版 rclone が必要。\nGitHub: https://github.com/gaoyb7/rclone-release 本家と同じだけど 115 対応済み。\nCookie の取得 Chrome で手動取得 115 にログイン → DevTools → Network タブ → ページ更新 cookie.js?_=[number] を探す → Request Headers 内に Cookie がある。\nChrome 拡張で取得 Get cookies.txt LOCALLY アプリ経由の Cookie Web の Cookie はすぐ期限切れになるから、App から取得した方がいい。\niOS：Stream や Quantumult X Android：抓包精灵 PC：Fiddler など すぐ出てくるからここでは省略。\nRclone の設定 コマンドで設定 1 rclone config 完了後、Windows の場合は以下に設定ファイルができる：\n1 C:\\Users\\%USERNAME%\\AppData\\Roaming\\rclone 直接編集 rclone.conf を作成：\n1 2 3 4 5 [name] type = 115 uid = your_uid cid = your_cid seid = your_seid Windows でマウント winfsp を先にインストール： https://winfsp.dev/ 1 .\\rclone.exe mount -v --read-only --vfs-read-chunk-size=4M --buffer-size=32M --network-mode 115: X: Ctrl+C で解除\nLinux Docker マウント 1 docker pull gaoyb7/rclone:latest 1 2 3 4 5 6 7 docker run --rm \\ --volume /home/rclone/config:/config/rclone \\ --volume /home/rclone/data:/data:shared \\ --volume /etc/passwd:/etc/passwd:ro --volume /etc/group:/etc/group:ro \\ --device /dev/fuse --cap-add SYS_ADMIN --security-opt apparmor:unconfined \\ gaoyb7/rclone:latest \\ mount 115:/music /data/music --allow-other --allow-non-empty --vfs-cache-mode writes \u0026amp; Navidrome の設定 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 version: \u0026#34;3.0\u0026#34; services: navidrome: image: deluan/navidrome:latest ports: - \u0026#34;8005:4533\u0026#34; restart: unless-stopped environment: ND_SCANSCHEDULE: 1h ND_LOGLEVEL: info ND_SESSIONTIMEOUT: 24h ND_BASEURL: \u0026#34;\u0026#34; ND_LASTFM_ENABLED: \u0026#34;true\u0026#34; ND_LASTFM_APIKEY: your_LASTFM_APIKEY ND_LASTFM_SECRET: your_LASTFM_SECRET ND_LASTFM_LANGUAGE: zh ND_SPOTIFY_ID: your_SPOTIFY_ID ND_SPOTIFY_SECRET: your_SPOTIFY_SECRET ND_ENABLESHARING: \u0026#34;true\u0026#34; ND_UILOGINBACKGROUNDURL: \u0026#34;https://www.loliapi.com/acg\u0026#34; ND_UIWELCOMEMESSAGE: \u0026#34;ようこそ〜\u0026#34; volumes: - \u0026#34;/home/navidrome/data:/data\u0026#34; - \u0026#34;/home/rclone/data/music:/music/115:ro\u0026#34; - \u0026#34;/home/navidrome/music:/music/server:ro\u0026#34; Blog ブログは2つあって、どちらも過去記事の手順で構築済み。もう更新する予定なし。\nWordpress yexca\u0026rsquo;Blog は画像 CDN が見れなくなってて、置換プラグイン使っても直らずそのまま放置中（背景だけ見えればいい）\nTypecho VRChat 教程 は久々に開いたらログインパス忘れてて焦ったけど、ちゃんとバックアップとってあった。新環境に構築してデータ移行完了。\n画像も上と同様、時間ができたら CDN を変えるつもり（とりあえずカバーだけ変更済み）\nWarmaTap 初音ミクの音声を Warma に置き換えたタイプ音ページ。\n電子音風 GitHub: lwd-temp/warmatap デモ： http://yexca.net/warma_tap 人間っぽい声 GitHub: MonianHello/WarmaTap デモ： http://yexca.net/warmatap MikuTap（元ネタ） GitHub: HFIProgramming/mikutap デモ： http://yexca.net/mikutap MikuTap は patatap を参考に作られたもの\n","date":"2023-11-03T15:34:01+08:00","permalink":"https://blog.yexca.net/ja/archives/131/","title":"2023年 新しいサーバー構築記録"},{"content":" 📢 この記事は ChatGPT によって翻訳されました 前にサーバー持ってたときも同じことを考えたことあったけど、\nそのときは「どうせ別サイト立てればいいじゃん」で済んだのでちゃんと調べなかった。\nでも今はブログを GitHub に移しちゃったし、\n今までみたいにサブパスへ直接リダイレクトするのはできない。\nだから改めて解決策を探すことにした。\n失敗の記録 失敗したけど、ちゃんと記録しとく。きっと使い方を間違えただけ\n昔ちょっとだけ試したときは DNS の CNAME に設定しただけで当然動かなくて放置してた。\n今回「ドメイン パス URL にリダイレクト」とかで検索してみたら、\n最初に出てきた https://cloud.tencent.com/developer/ask/sof/89340 に\n紹介されてたサービス： http://redirect.center/ を発見。\n例 https://acg.yexca.net → https://blog.yexca.net/acg にリダイレクトさせたい場合\n結果：アクセス不可\n説明通りに設定するなら、CNAME の内容は\nblog.yexca.net.opts-slash.acg.opts-https.redirect.center. にするべきらしい。\nでも実際には全然うまくいかなくて、エラーが出るだけ。\n他にもいろいろ試してみたけど全部エラー。\n諦めて他を探すことにした。\n補足：サイトの最後には自動生成機能もあるっぽい\n新しいツール 今度は「redirect center」で検索して、3番目に出てきた\nhttps://redirect.name/ というサービスを試してみた。\nこれが前のよりずっと使いやすくて、ちゃんと動いた！\n新しい例 https://twinkle.yexca.net を https://yexca.github.io/MusicPlayer-Twinkle/ にリダイレクトする。\n結果：アクセス可能！\n必要な DNS レコードは2つ：\n種類 名前 内容 CNAME twinkle alias.redirect.name TXT _redirect.acg Redirects to https://yexca.github.io/MusicPlayer-Twinkle/ コード形式で書くとこんな感じ：\n1 2 acg IN CNAME alias.redirect.name _redirect.acg IN TXT \u0026#34;https://blog.yexca.net/acg\u0026#34; ","date":"2023-08-28T15:31:01+08:00","permalink":"https://blog.yexca.net/ja/archives/116/","title":"CNAME でドメインをパス付き URL にリダイレクトする方法"},{"content":" この記事は Google 翻訳を使用して処理されました\n問題の説明 ある会社が長い鉄棒を購入し、それを切断して販売します。鉄筋を切断するコストはごくわずかで、鉄筋の長さはインチです。価格表 $p$ が与えられます。ここで、 $p_{i}(i=1,2,\\cdots,m)$ は長さ $i$ インチの鉄棒の価格を表します。今、売上収益を最大化するカット計画を見つける必要があります。\n問題分析 長い鋼棒の長さが $n$ インチで、最適な切断計画の左端の切断セグメントの長さが $i$ インチであると仮定して、残りの鋼棒の長さに対する最適な切断計画を解き続けます。 $m-1$ インチ。すべての可能な $i$ を考慮すると、最大の利益 $r_{n}$ に対応する伐採計画が最適な伐採計画となります。 $r_{n}$ の再帰定義は次のようになる。\n$$ r_{n}=max_{1\\le i \\le n}(p_{i}+r_{n-i}) $$\nC コード この問題には2つの解決策があります\n(1) 分割統治法（上から下まで） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int Top_Down_Cut_Rod(int p[], int n){ int r=0; // 最大値 int i; if(n==0){ retrun 0; } for(i=1; i\u0026lt;=n; i++){ int tmp = p[i]+Top_Down_Cut_Rod(p, n-i); r = (r\u0026gt;=tmp) ? r : tmp; } return r; } 時間計算量 $O(2^{n})$\n(2) 動的計画法（下から上まで） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int Bottom_Up_Cut_Rod(int p[], int n, int *s){ // *s:部分問題の最適な切断方法 int r[n+1]; // 部分問題の最適値 r[0]=0; for(int j=1; j\u0026lt;=n; j++){ int tmp=0; for(int i=1; i\u0026lt;=j; i++){ if(p[i]+r[j-1] \u0026gt; tmp){ tmp = p[i]+r[j-i]; s[j]=i; } } r[i]=tmp; } return r[n]; } 時間計算量 $O(n^{2})$\nその他のコンテンツ 検索プロセス中に、既存の記事を見つけました： 【基础算法】动态规划详解——钢条切割 ","date":"2023-05-27T19:37:08+08:00","permalink":"https://blog.yexca.net/ja/archives/110/","title":"アルゴリズム 鉄筋切断問題 (動的計画法 分割統治法)"},{"content":" この記事は Google 翻訳を使用して処理されました\n問題の説明 コインは $n$ 枚あり、そのうち 1 枚は偽造コインであり、偽造コインの方が軽いことが分かっています。今では残高は 1 つだけなので、できるだけ少ない比較で偽造コインを見つける必要があります。\n問題分析 $n$ 枚のコインを 2 つの等しい部分に分割します。\n$n$ が偶数の場合、最初の部分と2番目の部分、$1\\cdots\\frac{n}{2}$ と $\\frac{n}{2}+1\\cdots n$ を2つのスケールの端と端を照らします。軽い方の端に偽造コインが含まれています。同じ方法を使用して、コインの軽い部分にある偽造コインを見つけます。 $n$ が奇数の場合、最初と最後の部分 $1\\cdots\\frac{n-1}{2}$ と $\\frac{n+1}{2}+1\\cdots n$ を、天秤の軽い方の端に偽造コインがあります。同じ方法を使用して、コインの軽い部分にある偽造コインを見つけ続けます。両端の重さが同じであれば、真ん中のコインは偽造コインです。つまり、$\\frac{n+1}{2}$ 枚のコインは偽造品である。 Cコード 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 #include \u0026lt;stdio.h\u0026gt; // coins:重量配列 first,last:配列の最初と最後の添え字 int getCounterfeitCoin(int *coins, int first, int last); int main(void){ int coins[10] = {2,2,1,2,2,2,2,2,2,2}; int tmp = getCounterfeitCoin(coins, 0, 9); printf(\u0026#34;%d は偽造コインです\\n\u0026#34;,tmp+1); return 0; } int getCounterfeitCoin(int *coins, int first, int last){ int firstSum=0; int lastSum=0; int i; // 残りコインは2枚のみ if(first == last -1){ if(coins[first] \u0026lt; coins[last]) return first; return last; } // 偶数枚のコイン if ((last-first+1)%2 == 0){ for(i=first; i\u0026lt;first+(last-first)/2+1; i++){ firstSum += coins[i]; } for(i=first+(last-first)/2+1; i\u0026lt;last+1; i++){ lastSum += coins[i]; } if(firstSum \u0026lt; lastSum){ return getCounterfeitCoin(coins, first, first+(last-first)/2); }else{ return getCounterfeitCoin(coins, first+(last-first)/2+1, last); } }else{ // 奇数のコイン for(i=first; i\u0026lt;first+(last-first)/2; i++){ firstSum += coins[i]; } for(i=first+(last-first)/2+1; i\u0026lt;last+1; i++){ lastSum += coins[i]; } if(firstSum \u0026lt; lastSum){ return getCounterfeitCoin(coins, first, first+(last-first)/2-1); }else if(firstSum \u0026gt; lastSum){ return getCounterfeitCoin(coins, first+(last-first)/2+1, last); }else{ return first+(last-first)/2; } } } ","date":"2023-05-18T20:17:35+08:00","permalink":"https://blog.yexca.net/ja/archives/109/","title":"アルゴリズム偽造コイン問題 (分割統治)"},{"content":" この記事は Google 翻訳を使用して処理されました\n問題の説明 回路基板の上端と下端には n 個の端子があります。回路設計によれば、$(i, \\pi(i))$ は、上側の端子 i と下側の端子 $\\pi(i)$ の間の接続を表すために使用され、これは回路図上の i 番目の接続と呼ばれます。\n下の図に示す $\\pi(i)$ は、任意の $1 \\le i \u0026lt; j \\le n $ に対して ${8, 7, 4, 2, 5, 1, 9, 3, 10, 6}$ として配置されます。i 番目のリンクと j 番目のリンクが交差するための必要十分条件は $\\pi(i)\u0026gt;\\pi(j)$ である。\n回路基板を作るとき、これらのn本の配線を複数の絶縁層に分配する必要があり、同じ層の配線は交差しません。次に、どの配線を層に配置するかを決定する必要があります。このレイヤーで可能な限り多くのリンク、つまりリンクセット $Nets={ (i,\\pi(i)),1\\le i\\le n }$ の最大の分離サブセットを決定する。\n問題分析 $N(i,j)={ t|(t,\\pi(t))\\in Nets, t\\le i, \\pi(t) \\le j }$ とする。$N(i,j)$ の最大の分離部分集合を $MNS(i,j)$ ，$size(i,j)=|MNS(i,j)|$ とする。\n分析の結果、この問題は最適なサブ構造特性を持つことがわかりました。規模 n の回路配線問題では、次の再帰式を構築できます。\n$$ \\begin{align*} \u0026amp;(1) \\ \\ i=1\\ とする、 size(1,j)= \\begin{cases} 0, \u0026amp; \\text{j\u0026lt;$\\pi$(1)} \\ 1, \u0026amp; \\text{その他の状況} \\end{cases} \\ \u0026amp;(2) \\ \\ i\u0026gt;1\\ とする， size(i,j)= \\begin{cases} size(i-1,j), \u0026amp; \\text{j\u0026lt;$\\pi$(i)} \\ max{size(i-1,j),size(i-1,\\pi(i)-1)+1}, \u0026amp; \\text{その他の状況} \\end{cases} \\end{align*} $$\nC コード 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #define N 10 // 問題の大きさ // 分離した接続の最大数を見つける void maxNum(int pi[], int **size); // 最大分離接続セットを構築します。net[i]は、最大分離サブセット内のi番目の接続の上位端末のシリアル番号を表します。 int constructSet(int pi[], int **size, int *net); int main(void){ // 下付き文字は1から始まります int pi[N+1] = {0, 8, 7, 4, 2, 5, 1, 9, 3, 10, 6}; int net[N]; int **size; size = (int**)malloc(sizeof(int*)*(N+1)); for(int i=0;i\u0026lt;N+1;i++) size[i]=(int*)malloc(sizeof(int)*(N+1)); maxNum(pi, size); int m = constructSet(pi, size, net); printf(\u0026#34;分離接続の最大数は次のとおりです。%d\\n\u0026#34;,m); printf(\u0026#34;含まれる接続は次のとおりです。\\n\u0026#34;); for(int i=0; i\u0026lt;m; i++){ printf(\u0026#34;(%d,%d)\\n\u0026#34;, net[i], pi[net[i]]); } } void maxNum(int pi[], int **size){ // size[i][j]: 上部と下部にそれぞれ i と j の端子がある回路基板の最初の層における分離接続の最大数 int i,j; // when j\u0026lt;pi(1) for(j=0; j\u0026lt;pi[1]; j++) size[1][j]; // when j\u0026gt;=pi(1) for(j=pi[1]; j\u0026lt;=N; j++) size[1][j]; for(i=2; i\u0026lt;N; i++){ // when j\u0026lt;pi(i) for(j=0; j\u0026lt;pi[i]; j++) size[i][j] = size[i-1][j]; // when j\u0026gt;=c[i] for(j=pi[i]; j\u0026lt;=N; j++) size[i][j]=size[i-1][j]\u0026gt;=size[i-1][pi[i]-1]+1 ? size[i-1][j] : size[i-1][pi[i]-1]+1; } // 最大接続数 size[N][N] = size[N-1][N]\u0026gt;=size[N-1][pi[N]-1]+1 ? size[N-1][N] : size[N-1][pi[N]-1]+1; } // 最大分離接続セットを構築します。net[i]は、最大分離サブセット内のi番目の接続の上位端末のシリアル番号を表します。 int constructSet(int pi[], int **size, int *net){ int i; int j=N; int m=0; // 端末セット内の最大接続数を記録する for(i=N; i\u0026gt;1; i--){ // 減少 // (i,pi[i])は最大の互いに素な部分集合を結ぶ線である。 if(size[i][j] != size[i-1][j]){ net[m++]=i; // iを配列ネットに記録し、接続ラインの数を1増やす j=pi[i]-1; // 拡張リンクバー間隔を更新しました } } // when i=1 if(j\u0026gt;=pi[1]) net[m++] = 1; return m; } その他のコンテンツ 検索中に既存の記事が見つかりました： 算法设计与分析——电路布线（动态规划） 参考文献 LaTeX公式手册 Typora中使用LaTeX：多行公式左对齐 用malloc动态申请一个二维数组的三种方法 ","date":"2023-05-16T17:53:31+08:00","permalink":"https://blog.yexca.net/ja/archives/106/","title":"アルゴリズム回路配線問題（動的計画法）"},{"content":" 📢 この記事は ChatGPT によって翻訳されました Rclone を使って OneDrive 上の音楽ファイルをマウントし、Navidrome を使って音楽サイトを構築。Docker でデプロイする。\nRclone まずは Windows 環境で設定ファイルを取得して、サーバー側でインストールとマウントを行う。\nToken の取得 Windows 向け Rclone をダウンロード：\nhttps://rclone.org/downloads/ 解凍後、cmd でそのフォルダに入り、以下のコマンドを実行：\n1 rclone.exe authorize \u0026#34;onedrive\u0026#34; ブラウザでログインして認証完了すると、Token が出力される。 この Token（中括弧ごと）を控えておく。\n設定ファイルの取得 次に以下のコマンドでインタラクティブ設定を行う：\n1 rclone.exe config 手順に従って設定すると、設定ファイルが以下に生成される：\n1 C:\\Users\\%USERNAME%\\AppData\\Roaming\\rclone 設定ファイルをコピー サーバー側に以下のディレクトリを作成：\n1 2 3 4 # 設定ファイル格納用 /home/docker/rclone/config # OneDrive をマウントするローカルフォルダ /home/docker/rclone/data 作成した設定ファイルを上記フォルダに配置。\nディレクトリをマウント Rclone の Docker イメージを取得：\n1 docker pull rclone/rclone:latest 以下のコマンドでマウント：\n1 2 3 4 5 6 7 docker run --rm \\ --volume /root/rclone/config:/config/rclone \\ --volume /root/rclone/data:/data:shared \\ --volume /etc/passwd:/etc/passwd:ro --volume /etc/group:/etc/group:ro \\ --device /dev/fuse --cap-add SYS_ADMIN --security-opt apparmor:unconfined \\ rclone/rclone \\ mount music:/ /data/music --allow-other --allow-non-empty --vfs-cache-mode writes \u0026amp; \u0026amp; はバックグラウンド実行。PID が表示されるので、停止したいときは：\n1 kill PID 補足： Linux 学習 第六章 管理运行中的进程 例では OneDrive 上の music フォルダを /home/docker/rclone/data/music にマウントしている。\n参考リンク：\nhttps://rclone.org/onedrive/ https://rclone.cn/install.html LinuxでRcloneを使ってOneDriveやGoogleDriveをマウントし自動起動を設定 Navidrome のデプロイ Docker Compose を使用。まず以下のディレクトリを作成：\n1 /home/docker/navidrome docker-compose.yml を作成して、以下の内容を記入：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 version: \u0026#34;3\u0026#34; services: navidrome: image: deluan/navidrome:latest ports: - \u0026#34;8001:4533\u0026#34; restart: unless-stopped environment: ND_SCANSCHEDULE: 1h ND_LOGLEVEL: info ND_SESSIONTIMEOUT: 24h ND_BASEURL: \u0026#34;\u0026#34; volumes: - \u0026#34;/home/docker/navidrome/data:/data\u0026#34; - \u0026#34;/home/docker/rclone/data/music:/music:ro\u0026#34; 他の設定項目はこちら： Navidrome Configuration Options - Navidrome デプロイ：\n1 docker-compose up -d アクセスは IP:8001 で。\n参考：\nhttps://www.navidrome.org/docs/installation/docker/ Navidromeで自分だけの音楽プレーヤーを構築 楽曲情報の管理 曲を分類したいなら、メタ情報（タグや歌詞）を埋め込んでおく必要がある。\nおすすめの編集ツール：\nMusicTag（作者ブログ） Web 版： xhongc/music-tag-web クライアントアプリで聴く Web UI は PC だと使えるけど、スマホだとちょっと微妙…\n幸いにも Navidrome に対応したクライアントアプリがいくつか存在する：\n詳細は公式ページへ： https://www.navidrome.org/docs/overview/#apps ","date":"2023-05-02T02:27:39+08:00","permalink":"https://blog.yexca.net/ja/archives/105/","title":"個人音楽サイトの構築"},{"content":" 📢 この記事は ChatGPT によって翻訳されました 思いつきから完全に実現するまで、なんと3ヶ月かかった（主に怠けすぎただけ）\nDocker のインストール APT でインストールする方法。\nHTTPS 転送と CA 証明書用パッケージを追加： 1 2 3 4 5 6 7 8 9 10 # まずは更新 sudo apt-get update # パッケージをインストール sudo apt-get install \\ apt-transport-https \\ ca-certificates \\ curl \\ gnupg \\ lsb-release GPG 鍵を追加してパッケージの正当性を確認： 1 2 3 4 5 # 中国ミラー curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/debian/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg # 公式 curl -fsSL https://download.docker.com/linux/debian/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg ソースリストに Docker ソースを追加： Debian のバージョンを確認して、以下の $(lsb_release -cs) を置き換えること 例：Debian10 → buster、Debian11 → bullseye\n1 2 3 4 5 6 7 8 9 # 中国ミラー echo \\ \u0026#34;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://mirrors.aliyun.com/docker-ce/linux/debian \\ bullseye stable\u0026#34; | sudo tee /etc/apt/sources.list.d/docker.list \u0026gt; /dev/null # 公式 echo \\ \u0026#34;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/debian \\ bullseye stable\u0026#34; | sudo tee /etc/apt/sources.list.d/docker.list \u0026gt; /dev/null stable → test にすればテスト版も使える。\nインストール実行： 1 2 3 4 5 6 7 8 # キャッシュ更新 sudo apt-get update # Docker インストール sudo apt-get install docker-ce docker-ce-cli containerd.io # docker-compose sudo apt-get install docker-compose 一括スクリプトもある：\n1 2 3 4 5 6 7 8 9 10 11 # テスト版 curl -fsSL test.docker.com -o get-docker.sh # 安定版 curl -fsSL get.docker.com -o get-docker.sh # Aliyun ミラー sudo sh get-docker.sh --mirror Aliyun # Azure China ミラー sudo sh get-docker.sh --mirror AzureChinaCloud Docker 起動 1 2 sudo systemctl enable docker sudo systemctl start docker インストール確認：\n1 docker run --rm hello-world 出力があれば成功。\nBlog1: WordPress 例：/root/wordpress に作成。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 version: \u0026#39;3.3\u0026#39; services: db: image: mysql:5.7 volumes: - db_data:/var/lib/mysql restart: always environment: MYSQL_ROOT_PASSWORD: somewordpress MYSQL_DATABASE: wordpress MYSQL_USER: wordpress MYSQL_PASSWORD: wordpress wordpress: depends_on: - db image: wordpress:latest volumes: - /root/wordpress/uploads.ini:/usr/local/etc/php/conf.d/uploads.ini ports: - 8000:80 restart: always environment: WORDPRESS_DB_HOST: db:3306 WORDPRESS_DB_USER: wordpress WORDPRESS_DB_PASSWORD: wordpress WORDPRESS_DB_NAME: wordpress volumes: db_data: {} uploads.ini：\n1 2 3 4 5 file_uploads = On memory_limit = 256M upload_max_filesize = 10M post_max_size = 10M max_execution_time = 600 Docker 関連操作 1 2 3 4 5 6 7 8 # バックグラウンド実行 docker-compose up -d # 停止 docker-compose stop # 停止＋削除 docker-compose down Blog2: Typecho Docker Hub: 80x86/typecho 1 2 3 4 5 6 7 8 9 10 11 12 13 version: \u0026#39;3.0\u0026#39; services: typecho: image: 80x86/typecho:latest container_name: Typecho_Blog volumes: - /root/typecho/data:/data ports: - 8001:80 restart: always environment: PHP_TZ: Asia/Shanghai PHP_MAX_EXECUTION_TIME: 600 クラウドストレージ（PanIndex） GitHub: https://github.com/px-org/PanIndex Docs: https://docs.noki.icu/ 1 2 3 4 5 6 7 8 9 10 version: \u0026#34;3.0\u0026#34; services: PanIndex: restart: always image: iicm/pan-index:latest container_name: VRC_Pan volumes: - /root/pan/data:/app/data ports: - 8002:5238 Nginx + SSL GUI 管理ツール: https://github.com/0xJacky/nginx-ui 1 2 3 4 5 6 7 8 9 10 11 12 13 version: \u0026#39;3.1\u0026#39; services: nginx-ui: restart: always image: uozi/nginx-ui:latest container_name: nginx_UI volumes: - /root/nginx/nginx:/etc/nginx - /root/nginx/nginx-ui:/etc/nginx-ui - /root/nginx/www:/www ports: - 80:80 - 443:443 ホスト側 IP は 172.17.0.1 で参照できる。確認は：\n1 ip addr show docker0 コンテナに入る 1 2 3 4 5 # 一覧確認 docker container ls # 入る docker exec -i [ID] bash bash がない場合もある。\n補足：SSL 証明書 Docker: neilpang/acme.sh 1 2 3 4 5 6 7 8 9 10 11 12 version: \u0026#39;3.1\u0026#39; services: acme.sh: image: neilpang/acme.sh container_name: acme.sh command: daemon volumes: - /root/acme/acme.sh:/acme.sh - /root/acme/conf:/.acme.sh environment: - CF_Key=\u0026#34;CFのAPIキー\u0026#34; - CF_Email=\u0026#34;メールアドレス\u0026#34; DNS API 参考： https://github.com/acmesh-official/acme.sh/wiki/dnsapi 登録：\n1 docker exec acme.sh --register-account -m mail@example.com 証明書取得（Cloudflare）：\n1 docker exec acme.sh --issue --dns dns_cf -d example.com -d www.example.com cron 自動更新は省略。\nNginx (手動構築) 1 2 3 4 5 6 7 8 9 10 11 12 13 version: \u0026#39;3.1\u0026#39; services: nginx: restart: always image: nginx container_name: nginx ports: - 80:80 volumes: - /root/docker/nginx/conf.d:/etc/nginx/conf.d - /root/docker/nginx/www:/user/share/nginx/html - /root/docker/nginx/log:/var/log/nginx - /root/acme/acme.sh:/ssl conf.d/default.conf 例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 server { listen 80; listen [::]:80; server_name your_domain.com; rewrite ^(.*)$ https://$host$1 permanent; } map $http_upgrade $connection_upgrade { default upgrade; \u0026#39;\u0026#39; close; } server { listen 443 ssl http2; listen [::]:443 ssl http2; server_name your_domain.com; ssl_certificate /ssl/fullchain.cer; ssl_certificate_key /ssl/your_domain.key; location / { proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection $connection_upgrade; proxy_pass http://172.17.0.1:9000/; } } 参考資料\ndocker安装nginx并配置ssl证书，代理宿主机服务_Blueeyedboy521的博客-CSDN博客_bitwarden docker ssl Nginx 安装 SSL 配置 HTTPS 超详细完整全过程-阿里云开发者社区 (aliyun.com) 快速部署 Docker 同时发布多个网站或服务_天道酬勤~的博客-CSDN博客_docker部署 一台服务器多个系统 Let\u0026rsquo;s Encrypt 使用教程，免费的SSL证书，让你的网站拥抱 HTTPS - Diamond-Blog (diamondfsd.com) Nginx反向代理的一次使用总结 - 简书 (jianshu.com) Nginx配置反向代理隐藏服务端口 - \u0026amp;大飞 - 博客园 (cnblogs.com) 参考記事 Debian - Docker — 从入门到实践 (gitbook.io) Docker 安装 Wordpress 博客 - 腾讯云开发者社区-腾讯云 (tencent.com) Docker部署WordPress解决“上传的文件尺寸超过php.ini中定义的upload_max_filesize值”问题_neiro-DevPress官方社区 (csdn.net) let’s Encrypt 证书之安装故障 Could not bind to IPv4 or IPv6. - 料网 (liaosam.com) 基于Let\u0026rsquo;s Encrypt生成免费证书-支持多域名泛域名证书 - DevOps在路上 - 博客园 (cnblogs.com) Docker Compose-菜鸟教程 (runoob.com) Nginx配置文件详解 - 程序员自由之路 - 博客园 (cnblogs.com) Docker使用acme.sh申请ssl证书 – 萌精灵 (moeelf.com) docker安装nginx并配置ssl证书，代理宿主机服务 ","date":"2023-04-04T22:31:45+08:00","permalink":"https://blog.yexca.net/ja/archives/102/","title":"サーバーでの Docker デプロイ記録"},{"content":" 📢 この記事は ChatGPT によって翻訳されました 自分が学んだ Git の内容をまとめておくよ。\n1. インストール Windows に Git をインストール 公式サイトからダウンロード： https://git-scm.com/download/win インストール後、Git Bash を一度起動しておく。\nLinux に Git をインストール Debian: sudo apt-get install git Fedora: dnf install git CentOS: yum install git 他は公式参照： https://git-scm.com/download/linux macOS に Git をインストール Homebrew 経由でインストールするのが一般的。詳細： http://brew.sh/ または、AppStore で Xcode をインストール → Xcode を開いて\nXcode \u0026gt; Preferences \u0026gt; Downloads \u0026gt; Command Line Tools を選んでインストール。\n2. 初期設定 インストール直後、以下でユーザー情報を設定：\n1 2 git config --global user.name \u0026#34;Your Name\u0026#34; git config --global user.email \u0026#34;email@example.com\u0026#34; 3. リポジトリの作成 適当なフォルダで以下を実行：\n1 git init これで .git フォルダができ、Git 管理の対象になる。中は直接編集しないこと。\nリモートリポジトリのクローン 他人のリポジトリ 1 git clone https://github.com/yexca/typecho-theme-book.git コミット権限がないなら HTTPS で問題なし。編集・プルリクしたいなら自分のリポジトリへ fork しよう。\n自分のリポジトリ（SSH） 事前に GitHub の SSH キー設定： https://github.com/settings/keys その後：\n1 git clone git@github.com:yexca/typecho-theme-book.git 参考：\n大佬にお茶を渡す方法（GitHubでの貢献） 初めての Pull Request 4. ファイルのコミット（ローカル） ファイル変更後：\n1 2 3 git add filename # すべて追加する場合 git add . 追加後、コミット：\n1 git commit -m \u0026#34;変更内容の説明\u0026#34; .gitignore で除外ファイルを設定 例：\n1 2 3 test/ # testフォルダ *.py[cod] # .pyc, .pyo, .pyd !app.pyc # app.pycだけ除外しない 無視してても強制追加可：\n1 git add -f test.pyc .gitignore 変更時はキャッシュクリアが必要：\n1 2 3 git rm -r --cached . git add . git commit -m \u0026#34;update .gitignore\u0026#34; 5. 状態確認と取り消し 1 2 3 4 git status # 状態確認 git diff # 差分表示 git log # コミット履歴 git log --pretty=oneline バージョンを戻す 一つ前：git reset --hard HEAD^ 特定のバージョンへ： 1 git reset --hard コミットID（先頭数桁でもOK） 戻しすぎた場合は：\n1 git reflog でログを確認して戻す。\n6. GitHub にリンク GitHub 上でリポジトリを作成後：\n1 git remote add origin git@github.com:username/repo.git ローカルで編集したら：\n1 git push origin master main/master の違い VS Code は master を使うが GitHub は main。 変更したい場合：\n1 git branch -m master main 初期ブランチを main に設定：\n1 git config --global init.defaultBranch main 毎回 --set-upstream するのが面倒なら：\n1 git push --set-upstream origin main 以降は git push origin だけで OK。\nリモートの再設定 1 2 git remote -v # 確認 git remote rm origin # 削除 7. ブランチ操作 1 2 3 4 5 git branch # 一覧 git branch new_branch # 作成 git switch new_branch # 切り替え git checkout new_branch # 同上 git push origin new_branch # プッシュ ブランチ作って機能開発 → main にマージする流れ：\n1 2 3 4 5 git switch -c search # ...編集、テスト、コミット... git switch main git merge search git branch -d search 8. Git サーバー構築 参考： Gitサーバーを構築し、指定ディレクトリに同期する方法 9. その他 GitLab \u0026amp; GitHub 両方使いたい人向け：\nGit 同期設定（GitLab + GitHub） 参考資料 Git チュートリアル（廖雪峰） GitHubにローカルリポジトリを接続する方法 main ブランチへのプッシュエラー対処 .gitignore 更新後の反映方法 ","date":"2023-03-05T15:03:43+08:00","permalink":"https://blog.yexca.net/ja/archives/95/","title":"Git 学習メモ"},{"content":" この記事は Google 翻訳を使用して処理されました\n「ハードドライブに保存されていないものはあなたのものではない」という原則に従い、個人の携帯電話に保存されている写真の数が増えているため、携帯電話のメモリ危機を緩和するために、緊急に整理してハードドライブに保存する必要があるため、アーティストによるダウンロード・保存方式を採用する。そのため、便利な記録と迅速な検索および変更の方法が必要です。アーティストの数が増えると、Markdown を使用した元のリストは必然的に非常に遅くなる可能性があります。\n2 日後に振り返ってみると、何かを記録する最良の方法はデータベースを使用することです。\nダウンロードとインストール 考えた結果、MySQLを使うことにしました。ダウンロードについては、 MySQL下载与安装 - 知乎 を参照してください。一部変更されていますが、ほぼ同じ。\nインストールはデフォルトのままで完了するまでクリックし続けました （面倒すぎる）\nサービスを開始し、win+Rを押してservices.mscと入力し、サービスを見つけて開始します。\nデータベース設計 正直に言うと、ここでデザインすることはあまりありません。今のところ、主に Pixiv からアーティストをダウンロードし、いくつかは Twitter からダウンロードしているので、1 つのテーブルしか使用できないはずです。\nID name downloadDate lastDownloadID platform url アーティスト固有ID 名前 ダウンロード日 最後にダウンロードした作品ID プラットフォーム リンク このデザインはどのようなパラダイムですか? コードは次のとおりです\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 -- データベースを作成する create database hello; -- データベースを選択 use hello; -- テーブルを作成 create table pic ( ID varchar(99), name varchar(255), downloadedDate datetime, lastDownloadID varchar(255), platform varchar(50), url varchar(255), primary key(ID) ); 作品をダウンロード Pixiv Powerful Pixiv Downloader 拡張機能 Chrome App Store リンク を使用する\nGithub リンク： xuejianxianzun/PixivBatchDownloader 必ず低速クロールを有効にしてください。そうしないと、ダウンロード速度が速すぎたり、一度にダウンロードする量が多すぎたりした場合に、IP が一時的にブロックされます。\nTwitter Twitter Media Downloader 拡張機能 Chrome App Store リンク を使用する\n公式ウェブサイトのリンク： Twitter メディアダウンローダ：ユーザータイムラインの原寸画像や動画をまとめてダウンロードするユーザースクリプト(PC用Google Chrome・Firefox等対応) - 風柳メモ データ挿入 1 2 3 4 5 6 -- データベースを選択 use hello; -- データの挿入 insert into pic values (\u0026#39;6049901\u0026#39;, \u0026#39;鬼针草\u0026#39;, \u0026#39;2023-02-09\u0026#39;, \u0026#39;105176620\u0026#39;, \u0026#39;pixiv\u0026#39;, \u0026#39;https://www.pixiv.net/users/6049901\u0026#39;) 複数行のデータの場合、データは , で区切られます。\nデータの更新 1 2 3 update pic set downloadedDate = \u0026#39;2023-03-02\u0026#39;, lastDownloadID = \u0026#39;105716156\u0026#39; where ID = \u0026#39;6049901\u0026#39; 詳細： データベースの学習 3 SQL言語 – yexca\u0026rsquo;Blog データベースについてもっと知りたいですか? 私が書いた (完全に翻訳しないけど)： データベース学習 1 データベース入門 – yexca\u0026rsquo;Blog 中国語（簡体字）: SQL 教程-菜鸟教程 参照記事 MySQL常见建表选项及约束 - GeaoZhang - 博客园 ","date":"2023-03-02T10:16:38+08:00","permalink":"https://blog.yexca.net/ja/archives/94/","title":"データベースにはダウンロードされたアーティストの作品が記録されます"},{"content":" この記事は Google 翻訳を使用して処理されました\nSQL Series\nデータベース学習 1 データベース入門: https://blog.yexca.net/ja/archives/86 データベース学習 2 リレーショナル モデル: https://blog.yexca.net/archives/ja/87 データベースの学習 3 SQL言語: 本文\n以下のはまだ翻訳しないので、中国語（簡体字）のリンクだよ\n数据库学习四 关系数据库理论: https://blog.yexca.net/archives/89 数据库学习五 范式: https://blog.yexca.net/archives/90 数据库学习六 数据库设计: https://blog.yexca.net/archives/91 数据库学习七 数据库的控制功能: https://blog.yexca.net/archives/92 SQL言語の分類 DDL（データ定義言語） データベースシステムでは、データベース内の各データベース、テーブル、ビュー、インデックスなどがデータベースオブジェクトです。データベースオブジェクトを作成または削除するには、SQL 言語を使用します。 DDL には CREATE、ALTER、DROP などが含まれます。\nDML（データ操作言語） DML は、INSERT、DELETE、UPDATE など、データベース内のデータを追加、変更、削除するために使用されるステートメントを指します。\nDQL (データクエリ言語) クエリはデータベースの基本機能であり、クエリ操作は SQL データ クエリ言語を通じて実装されます。たとえば、テーブルの内容を照会するにはSELECTを使用します。\nDCL（データ制御言語） DCL には、データベース オブジェクトの権限管理やトランザクション管理などが含まれます。\n(I) DDLデータ定義言語 1. データベースを作成する 1 create database \u0026lt;データベース名\u0026gt; 2。基本テーブルを作成します 1 2 3 4 5 6 7 create table \u0026lt;テーブル名\u0026gt; ( \u0026lt;列名\u0026gt; \u0026lt;データ型\u0026gt; [列レベルの整合性制約], [···,] [テーブルレベルの整合性制約,] [···] ) \u0026lt;1\u0026gt; データタイプ INT / INTEGER : 整数 FLOAT(n): 少なくともn桁の精度を持つ浮動小数点数 NUMERIC(p, d) / DECIMAL(p, d) / DEC(p, d): p桁（符号と小数点を除く）のd桁の固定小数点数小数点以下の数字 CHAR(n): 長さnの固定長文字列 DATETIME: 日付と時刻の型 1 2 3 4 5 6 -- 例えば create table test ( f1 char(10), f2 int ) \u0026lt;2\u0026gt; ラインレベルの整合性の制約 not null: 空ではない\nunique: ユニーク\nnot null unique: 空ではなくユニーク\ndefault: デフォルト値を定義する\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 -- 例えば create table test ( f1 int not null, -- この列は空にできません f2 int unique, -- この列の値は空でも構いませんが、各行は異なる必要があります f3 int not null unique, -- 列は空ではなく、各行は異なります f4 char(5) default \u0026#39;nashi\u0026#39; -- 新しく追加された行に値が割り当てられていない場合、この列はデフォルトで「nashi」になります。 ) \u0026lt;3\u0026gt; テーブルレベルの整合性の制約 名前 条項 通信の完全性 主キー句 PRIMARY KEY エンティティの整合性 チェック条項 CHECK ユーザー定義の整合性 外部キー句 FOREIGN KEY 参照整合性 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 -- 例えば create table student ( sid int, primary key(sid) -- not null unique ) -- または create table student ( sid int primary key ) create table course ( cid int, sid int, score int, check(score \u0026gt;= 0 and score \u0026lt;= 100), foreign key(sid) references student(sid) ) 整合性の検査 アサート（通常は推奨されません） 1 2 3 4 CREATE ASSERTION \u0026lt;アサーション名\u0026gt; \u0026lt;チェック条項\u0026gt; -- チェック句は、where 句の式に似ています。 -- アサーション名を削除 DROP ASSERTION \u0026lt;断言名\u0026gt;; トリガー テーブルが追加、削除、または変更されると、トリガー内の条件がチェックされます。条件が満たされている場合はトリガー内のアクションが実行され、満たされていない場合はアクションは実行されません。\n1 2 3 4 5 6 7 8 9 10 11 12 13 CREATE TRIGGER \u0026lt;トリガー名\u0026gt; -- トリガー イベントが発生するたびに、トリガーがアクティブになります。 {BEFORE|AFTER} \u0026lt;トリガーイベント\u0026gt; ON \u0026lt;テーブル名\u0026gt; -- トリガー イベントの実行前または実行後にトリガーがアクティブ化されるかどうかを示します。 REFERERCING NEW|OLD ROW AS \u0026lt;変数\u0026gt; -- REFERENCINGは参照される変数を示す FOR EACH{ROW|STATEMENT} -- トリガーの種類を定義し、アクション本体の実行頻度を指定します。 [WHEN \u0026lt;トリガーイベント\u0026gt;] \u0026lt;トリガーアクション本体\u0026gt; -- トリガーアクションはトリガー条件が真の場合にのみ実行されます -- トリガーの削除 DROP TRIGGER \u0026lt;トリガー名\u0026gt; ON \u0026lt;テーブル名\u0026gt; 3。基本的なテーブル構造を変更します 新しい列を追加する 1 2 3 4 alter table \u0026lt;テーブル名\u0026gt; add \u0026lt;列名\u0026gt; \u0026lt;タイプ\u0026gt; -- 例えば alter table test add f3 datetime 列を変更する* 1 2 3 4 5 6 7 alter table \u0026lt;テーブル名\u0026gt; alter column \u0026lt;列名\u0026gt; \u0026lt;新しいタイプ\u0026gt; -- MySQL -- alter table \u0026lt;テーブル名\u0026gt; modify \u0026lt;列名\u0026gt; \u0026lt;新しいタイプ\u0026gt; -- 例えば alter table test alter column f3 float -- alter table test modify f3 float 列の削除 1 2 3 4 5 6 7 alter table \u0026lt;テーブル名\u0026gt; drop column \u0026lt;列名\u0026gt; -- MySQL -- alter table \u0026lt;テーブル名\u0026gt; drop \u0026lt;列名\u0026gt; -- 例えば alter table test drop column f3 -- alter table test drop f3 4。基本テーブルを削除します 1 2 3 4 drop table \u0026lt;テーブル名\u0026gt; -- 例えば drop table test (二)、DML データ操作言語 次のコンテンツの例は、これらのテーブルに基づいています\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 -- 注: 理解しやすいように中国語を使用しています。実際の開発では英語を使用してください。 -- 学生テーブル create table student ( 学号 char(5) not null unique, 姓名 char(8), 性别 char(2), 出生日期 datetime, 班号 char(5) ) -- 成績テーブル create table score ( 学号 char(5), 课程号 char(5), 分数 int ) -- 教師テーブル create table teacher ( 教师编号 char(5) not null unique, 姓名 char(8), 性别 char(2), 出生日期 datetime, 职称 char(6), 系别 char(10) ) -- コーススケジュール create table course ( 课程号 char(5) not null unique, 课程名 char(20), 任课教师编号 char(5) ) 1. INSERT ステートメントを挿入 SQL基本テーブルにデータを挿入する方法は2つあります。タプル値を直接挿入するか、クエリの結果値を挿入するかです。\nタプル値を直接挿入する 1 2 3 4 5 6 7 8 9 10 11 12 13 insert into テーブル名[(列名の順序)] values (タプル値)[, ···] -- 或者 insert into テーブル名[(列名の順序)] (table (タプル値)[, (タプル値), ···]) -- 例如 insert into student values (\u0026#39;108\u0026#39;, \u0026#39;张三\u0026#39;, \u0026#39;男\u0026#39;, \u0026#39;2000-01-01\u0026#39;, \u0026#39;09033\u0026#39;), (\u0026#39;109\u0026#39;, \u0026#39;李四\u0026#39;, \u0026#39;男\u0026#39;, \u0026#39;2000-05-05\u0026#39;, \u0026#39;09034\u0026#39;) -- 指定した列を挿入する insert into student(学号，姓名，性别，出生日期) values (110, \u0026#39;王五\u0026#39;, \u0026#39;男\u0026#39;, \u0026#39;2000-04-18\u0026#39;) クエリの結果値を挿入する 1 2 3 4 5 insert into テーブル名[(列名の順序)] select \u0026lt;クエリステートメント\u0026gt; -- 例えば insert into student select 111, \u0026#39;赵六\u0026#39;, \u0026#39;男\u0026#39;, \u0026#39;2000-03-19\u0026#39;, \u0026#39;09035\u0026#39; 2. DELETE 削除ステートメント 1 2 3 4 5 6 7 delete from \u0026lt;テーブル名\u0026gt; [where \u0026lt;条件式\u0026gt;] -- 例えば delete from student -- テーブル全体を削除する -- 生徒番号111のタプルを削除します delete from student where 学号 = 111 3. UPDATE ステートメントを修正 1 2 3 4 5 6 7 8 9 10 11 12 update \u0026lt;テーブル名\u0026gt; set \u0026lt;列名\u0026gt; = \u0026lt;価値表現\u0026gt;[, ···] [where \u0026lt;条件式\u0026gt;] -- 例えば update student set 班号 = \u0026#39;09058\u0026#39; where 学号 = 110 -- または update student set 班号 = \u0026#39;09057\u0026#39;, 性别 = \u0026#39;女\u0026#39; where 学号 = 110 and 班号 = \u0026#39;09058\u0026#39; (三)、DQL データクエリ言語 SQL データクエリ機能は SELECT 文を通じて実装されます。完全な構文は次のとおりです。\n1 2 3 4 5 6 select \u0026lt;対象テーブルの列名または列式のシーケンス\u0026gt; from \u0026lt;リレーションテーブルシーケンス\u0026gt; [where \u0026lt;行条件式\u0026gt;] [group by \u0026lt;列名の順序\u0026gt;] [having \u0026lt;グループ条件式\u0026gt;] [order by \u0026lt;列名\u0026gt; [asc|desc]] 1. 投影クエリ クエリ テーブル内の任意の列を選択するには、SELECT コマンドを使用します。複数の列がある場合は、カンマ , を使用して区切ります。 FROM句に複数のリレーショナルテーブルがある場合、各テーブルの名前を記述する必要があります。\n1 2 3 4 5 6 7 8 9 -- 例えば select 1 + 1 select 学号 * 100 from student -- 学生IDとスコアを照会する select student.学号, score.分数 from student, score -- すべての列をクエリする select * from student 重複行を削除するには DISTINCT を使用します\n1 2 3 -- 重複行を削除し、選択したコースを照会する select distinct 课程号 from score クエリ結果の列名をカスタマイズするには AS を使用します\n1 2 3 -- 例えば select 学号 as \u0026#39;sno\u0026#39; from student 2. クエリを選択 選択クエリは、クエリ条件を指定し、ソース テーブルからクエリ条件を満たすレコードのみを抽出または表示します。\n選択クエリでは通常、次の種類の操作が使用されます。\nオペレーター コード 説明する セットメンバーシップ演算子 IN\nNOT IN セット内\nセットに含まれない 文字列マッチング演算子 LIKE _ および % を使用した単一または複数の文字の一致 NULL比較演算子 IS NULL\nIS NOT NULL 空の\n空にすることはできません 算術演算子 \u0026gt;\n\u0026gt;=\n\u0026laquo;br /\u0026gt;\u0026lt;=\n=\n\u0026lt;\u0026gt; より大きい\nより大きいか等しい\n未満\n以下\n等しい\n等しくない \u0026lt;1\u0026gt; 条件式の比較演算 1 2 3 4 5 6 --- スコアが60～80のレコードを検索する select * from score where 分数 between 60 and 80 -- 60と80を含めるにはbetweenを使用します。つまり[60, 80]です。 -- スコア \u0026gt;= 60 かつスコア \u0026lt;= 80 の場合と同等 \u0026lt;2\u0026gt; 文字列マッチング操作 1 where [not] like \u0026#39;一致する文字列\u0026#39; [escape \u0026#39;一致する文字列\u0026#39;] '一致文字列' は完全な文字列にすることも、ワイルドカード文字 % と _ を含めることもできます。\n%: 任意の長さの文字を表します _ : 任意の1文字を表す \u0026lt;3\u0026gt; 集合の比較演算 1 2 3 4 -- スコアが85、86、または88のレコードをクエリします select * from score where 分数 in (85, 86, 88) \u0026lt;4\u0026gt; 論理的結合演算 1 2 3 4 -- クラス09031の女子生徒全員を照会する select * from student where 班号 = \u0026#39;09031\u0026#39; and 性别 = \u0026#39;女\u0026#39; 3. 並べ替えクエリ クエリ結果はORDER BY句を使用して並べ替えることができます。\n1 2 3 4 5 6 7 8 -- 昇順 asc (デフォルト、省略可能) select 学号, 姓名 from student order by 学号 -- 降順 desc select 学号, 姓名 from student order by 学号 desc 複数の列を指定して並べ替えることもできます。最初の列が最初に並べ替えられ、次に2番目の列が並べ替えられます。\n1 2 3 4 -- コース番号の昇順とスコアの降順で検索結果を表示します select * from score order by 课程号 asc, 分数 desc ORDER BY 句はクエリの最後に配置する必要があります。\n4. 集計関数 集計関数は、データ統計やその他の機能を実装します。一連の値を計算し、単一の値を返すために使用されます。\n通常は group by 句とともに使用される一般的な集計関数は次のとおりです。\n関数名 説明 AVG 平均値 COUNT 指定された式で選択された項目の数をカウントします\nCOUNT(*)はクエリによって出力された行数をカウントします MIN 最小値 MAX 最大値 SUM 値の合計 STDWV 指定された式のすべてのデータの標準偏差を計算します STDEVP 母集団標準偏差 集計関数の引数の一般的な形式は次のとおりです。\n1 [all|distinct] expr このうち、ALL はすべての値に対して集計関数演算を実行することを意味し、これがデフォルト値となります。また、DISTINCT は、すべての一意の値が考慮されることを指定します。 exprは式です\n1 2 3 4 -- クラス「09031」の生徒数を照会する select count(*) as \u0026#39;人数\u0026#39; from student where 班号 = \u0026#39;09031\u0026#39; 5. データのグループ化 集計関数は1つの結果しか出力しないため、列をクエリして集計関数をまとめるとエラーが報告されます。\n特定のカテゴリの集計関数の結果は、データをグループ化することで計算できます。つまり、集計関数の範囲は各グループ内のすべてのレコードになります。\n集計関数をフィルター条件として使用する場合は、それを HAVING 句の後に置く必要があります。\n1 2 3 4 5 6 -- 最低スコアが 70 を超え、最高スコアが 90 未満の学生の学生 ID を照会します。 select 学号 from score where 分数 is not null group by 学号 having min(分数) \u0026gt; 70 and max(分数) \u0026lt; 90 クエリ内に WHERE 句、GROUP BY 句、HAVING 句、および集計関数が同時に出現する場合、SELECT コマンドの実行順序は次のようになります。\nWHERE句を実行してテーブルから行を選択します 選択した行を「GROUP BY」でグループ化する 集計関数を実行する HAVING句を実行して条件を満たすグループを選択します。 1 2 3 4 -- 各コースの平均スコアを照会する select 课程号, avg(分数) from score group by 课程号 集計関数は条件として HAVING 句の後にのみ配置でき、 WHERE 句の後には配置できません。\nSELECT句が列名と集計関数で構成されている場合、すべての列名をグループ化する必要があります。\n6. テーブル接続クエリ FROM 句では結合するテーブルを指定し、WHERE 句では結合条件を指定します。\n1 2 3 select \u0026lt;列名1\u0026gt;[, ···] from \u0026lt;表1\u0026gt;[, ···] where 接続条件 2つのテーブルの共通列には、student.学号などのプレフィックスを指定する必要があります。\nSQL Server では、接続は内部接続と外部接続に分けられます。\n\u0026lt;1\u0026gt; 内部結合 Θ 結合、等価結合、自然結合\n内部結合は最も基本的な結合方法です。INNER JOIN キーワードを使用します。このキーワードを使用しない場合、デフォルトは内部結合になります。\n等接続 つまり、2つのテーブル間の接続関係は「等しい」です。\n1 2 3 4 5 6 7 8 9 -- すべての学生の名前、コース番号、スコアの列を照会する select student.姓名, score.课程号, score.分数 from student, score where student.学号 = score.学号 -- したがって select student.姓名, score.课程号, score.分数 from student inner join score on student.学号 = score.学号 入力を簡略化するために、テーブルエイリアスを使用することができます。\n1 2 3 4 -- 前の例の簡略化 select x.姓名, y.课程号, y.分数 from student x, score y where x.学号 = y.学号 非等価結合 つまり、2つのテーブル間の接続関係は「等しい」ではない。\n自己接続 同じテーブルを結合することを自己結合と呼びます。\n1 2 3 4 5 6 -- \u0026#39;3-105\u0026#39; を受験し、そのスコアが生徒 \u0026#39;109\u0026#39; のスコアより高い生徒の記録を照会します。 select x.课程号, x.学号, x.分数 from score x, score y where x.课程号 = \u0026#39;3-105\u0026#39; and x.分数 \u0026gt; y.分数 and y.学号 = \u0026#39;109\u0026#39; and y.课程号 = \u0026#39;3-105\u0026#39; order by x.分数 desc \u0026lt;2\u0026gt; 外部結合 OUTER JOIN 左外部結合: LEFT OUTER JOIN または LEFT JOIN\n右外部結合: RIGHT OUTER JOIN または RIGHT JOIN\n完全外部結合: FULL OUTER JOIN または FULL JOIN\n1 2 3 4 5 -- 左外部結合の例 -- すべてのコースの教師の名前を照会する select course.课程名, teacher.姓名 from course left join teacher on (course.任课教师编号 = teacher.教师编号) 7. サブクエリ \u0026lt;1\u0026gt; 一般的なサブクエリ あるクエリが別のクエリの条件である場合、つまり、テーブルから行を選択する条件がテーブル自体または他のテーブルの結合情報に依存する場合、サブクエリを実装する必要があります。\nサブクエリは、SELECT ステートメントの WHERE 句で最もよく使用されます。\n1 2 3 4 5 6 7 8 -- 学生番号「105」の学生と同じ年に生まれた学生を検索します select 学号, 姓名, year(出生日期) as \u0026#39;出生年份\u0026#39; from student where year(出生日期) = ( select year(出生日期) from student where 学号 = \u0026#39;105\u0026#39; ) \u0026lt;2\u0026gt; 相関サブクエリ 通常のサブクエリでは、各サブクエリは 1 回だけ実行され、返された値はメインクエリの WHERE 句で使用されます。\nメイン クエリが各行を選択するかどうかを判断するときは、サブクエリを「起動」し、メイン クエリにフィードバックする必要があります。つまり、内部条件に外部属性が含まれるサブクエリは相関サブクエリと呼ばれます。\n1 2 3 4 5 6 7 8 9 -- コースの平均スコアよりも低いスコアを持つ学生を照会する select 学号, 课程号, 分数 from score a where 分数 \u0026lt; ( select avg(分数) from score b where a.课程号 = b.课程号 and 分数 is not null ) \u0026lt;3\u0026gt; EXISTS テストを含むサブクエリ EXISTS は存在量指定子 ∃ を表し、論理真または論理偽の値のみを返します。\n1 2 3 4 5 6 7 8 -- すべての教師の名前と部門を照会する select 姓名, 系别 from teacher a where exists ( select * from course b where a.教师编号 = b.任课教师编号 ) あるいは、結果を否定する「NOT EXISTS」がある。\n8. クエリ結果の結合、交差、差の演算 次の演算子を使用して、2 つの SELECT クエリの結果に対して操作を実行できます。\nUNION : および 交差: 例外: 差異 1 2 3 4 5 6 7 8 -- ANDの例 -- すべての教師と生徒の名前、性別、生年月日を照会する select 姓名, 性别, year(出生日期) as \u0026#39;出生年份\u0026#39; from teacher union select 姓名, 性别, year(出生日期) as \u0026#39;出生年份\u0026#39; from student -- order by 生年 (四)、DCL データ制御言語 データ制御は、ユーザーのデータ保存権限を制御し、DBA（データベース管理者）によって決定されます。\nデータベースセキュリティ 不安要素:\nデータベースへの不正アクセスと破壊 データベースから重要なデータが漏洩 安全保障環境の脆弱性 セキュリティコントロール:\nユーザーID認証: 静的パスワード認証、動的パスワード認証、生体認証、スマートカード認証 アクセス制御 自律的なアクセス制御方式（ユーザーが操作権限をカスタマイズし、他のユーザーに割り当てることができる） 自律アクセス制御 DBMS（データベース管理システム）データ制御には以下の機能が必要です\nGRANTとREVOKEを通じてシステムに権限を通知し、データ辞書に保存する ユーザーがリクエストを行った場合、認可ステータスに基づいて操作リクエストを実行するかどうかを確認します。 SQL 標準には、DELETE、INSERT、SELECT、および UPDATE 権限が含まれます。 SELETE 権限は READ 権限に対応します。SQL には REFERENCES 権限も含まれており、これはリレーションを作成するときにユーザーが外部キーを定義する機能を制限するために使用されます。\n1. 認可ステートメントの形式 1 2 3 4 grant \u0026lt;権限\u0026gt;[, ···] on \u0026lt;オブジェクトタイプ\u0026gt; \u0026lt;オブジェクト名\u0026gt;[, ···] to \u0026lt;ユーザー\u0026gt;[, ···] [with grant option] 操作オブジェクトの種類によって権限は異なります。一般的な権限は次のとおりです。\nオブジェクト オブジェクトタイプ 操作権限 属性列 TABLE SELECT、INSERT、UPDATE、DELETE、\nALL PRIVILEGES (4つの権限の合計) ビュー TABLE SELECT、INSERT、UPDATE、DELETE、\nALL PRIVILEGES (4つの権限の合計) 基本テーブル TABLE SELECT、INSERT、UPDATE、DELETE、ALTER、INDEX\nALL PRIVILEGES (6つの権限の合計) データベース DATABASE CREATETAB テーブルを作成する権限。DBA が一般ユーザーに付与できます。 PUBLIC: 権限を受け取るユーザーは、単一のユーザーまたは複数の特定のユーザーです。PUBLIC パラメータは、すべてのユーザーに権限を付与できます。 GRANT OPTION付き: この句が指定されている場合、権限を取得したユーザーは他のユーザーに権限を付与することもできます。 2. 権限取り消しステートメントの形式 1 2 3 revoke \u0026lt;権限\u0026gt;[, ···] on \u0026lt;オブジェクトタイプ\u0026gt; \u0026lt;オブジェクト名\u0026gt;[, ···] from \u0026lt;ユーザー\u0026gt;[, ···] データベースの役割 役割とは、CEO、取締役、一般従業員など、人物のタイプを指します。人物のタイプを承認できます。\nキャラクター作成 1 create role \u0026lt;キャラクター名\u0026gt; ロールの承認 1 grant \u0026lt;権限\u0026gt; on \u0026lt;オブジェクトタイプ\u0026gt; \u0026lt;オブジェクト名\u0026gt; to \u0026lt;役割1\u0026gt;[, ···] 他のユーザーまたはロールにロールを付与する 1 2 grant \u0026lt;役割\u0026gt; to \u0026lt;役割\u0026gt;または\u0026lt;ユーザー名\u0026gt; [with admin option] with admin option は、このユーザーが他のロールまたはユーザーにこの権限を付与できることを意味します。\nロール権限の取り消し 1 revoke \u0026lt;権限\u0026gt; on \u0026lt;オブジェクト名\u0026gt; from \u0026lt;キャラクター名\u0026gt; ビューのメカニズム ビューは、1 つ以上の基本テーブルまたはビューから派生したテーブルです。これは仮想テーブルです。\nユーザーごとに異なるビューを定義し、ユーザーが間違いを起こさないように不要なデータを非表示にします。\nビューの作成 1 2 3 create view \u0026lt;ビュー名(リスト名)\u0026gt; as select \u0026lt;クエリ句\u0026gt; [with check option] サブクエリのSELECT文には通常、ORDER BY句とDISTINCT文を含めることはできません。 WITH CHECK OPTION は、UPDATE、INSERT、および DELETE 操作の場合、操作対象の行がビュー定義の述語条件 (つまり、サブクエリの条件式) を満たす必要があることを意味します。 ビューを構成する属性列名がすべて省略されているか、すべて指定されています。省略した場合、ビューは SELECT サブクエリのターゲット列のプライマリ属性で構成されていることが暗黙的に示されます。 1 2 3 4 5 6 7 8 -- 関係モデル：student(sno, sname, sex, SD, email) -- 「コンピュータサイエンス（CS）」の学生向けのビューを作成し、変更操作を実行する場合 -- ビュー内のコンピュータサイエンスの学生のみが影響を受けるようにする create view cs-student as select sno, sname, sex from student where SD = \u0026#39;CS\u0026#39; with check option ビューの削除 1 2 3 4 drop view \u0026lt;ビュー名\u0026gt; --例えば drop view cs-student 監査 データベースに対するすべての操作は監査ログに記録され、そのログを使用して不正な動作があるかどうかを確認できます。\n1 2 3 4 -- 「SC」データを変更する監査操作 AUDIT UPDATE ON SC; -- 「SC」テーブルのすべての監査をキャンセルします NOAUDIT UPDATE ON SC; データ暗号化 いくつかの暗号化アルゴリズムにより、プレーンテキストは暗号テキストに変換され、他の人が閲覧できなくなります。\n＃＃ 索引\nインデックスを使用すると、データベース プログラムはテーブル全体をスキャンしなくても、テーブル内の必要なデータを見つけることができます。\nデータベースのインデックスは、テーブルの 1 つ以上の列の値のコレクションと、これらの値を物理的に識別するテーブル内のデータ ページへの論理ポインターの対応するリストです。\n内部スキーマによって定義されます（内部スキーマはすべての内部レコードタイプ、インデックス、およびファイル構成を定義します）\nインデックスを作成する 1 2 create [unique] [cluster] index \u0026lt;インデックス名\u0026gt; on \u0026lt;テーブル名\u0026gt;(列名[順序], ···) 順序：オプションASC（デフォルト）または DSC\nUNIQUE ：このインデックスの各インデックス値が 1 つのデータ レコードのみに対応することを示します。\nCLUSTER ：作成されるインデックスがクラスター化インデックスであることを示します。つまり、インデックス項目の順序は、テーブル内のレコードの物理的な順序と一致します。\nインデックスの削除 1 drop index \u0026lt;インデックス\u0026gt; ","date":"2023-02-08T08:00:00+08:00","permalink":"https://blog.yexca.net/ja/archives/88/","title":"データベースの学習 3 SQL言語"},{"content":" この記事は Google 翻訳を使用して処理されました\nSQL Series\nデータベース学習 1 データベース入門: https://blog.yexca.net/ja/archives/86 データベース学習 2 リレーショナル モデル: 本文\nデータベースの学習 3 SQL言語: https://blog.yexca.net/ja/archives/88 以下のはまだ翻訳しないので、中国語（簡体字）のリンクだよ\n数据库学习四 关系数据库理论: https://blog.yexca.net/archives/89 数据库学习五 范式: https://blog.yexca.net/archives/90 数据库学习六 数据库设计: https://blog.yexca.net/archives/91 数据库学习七 数据库的控制功能: https://blog.yexca.net/archives/92 リレーショナルモデルの基本用語 リレーショナル データベース システムは、リレーショナル モデルをサポートするデータベース システムです。リレーショナル モデルに関連する基本的な用語は次のとおりです。\nリレーションシップ: リレーションシップは2次元テーブルであり、各リレーションシップにはリレーションシップ名があります。 タプル: テーブル内の行はタプルであり、ストレージファイル内のレコード値に対応します。 属性: テーブル内の列は属性と呼ばれます。各列には属性名があり、属性値はレコード内のデータ項目またはフィールド値に相当します。 ドメイン: 属性の値の範囲、つまり異なるタプル内の同じ属性の値の範囲 リレーションシップモデル: リレーションシップの説明はリレーションシップモデルと呼ばれ、リレーションシップ名とその属性セットで構成されます。リレーションシップモデルの形式は次のとおりです: リレーションシップ名(属性名 1，···，属性名 n) 通常、リレーショナルモデルはリレーショナルファイルの結果に対応する。\n候補キー: タプルを一意に識別する値を持つ属性または属性の組み合わせ 主キー: 関係には複数の候補キーが存在する場合があり、そのうちの1つが主キーとして選択されます。 主属性: 候補コード に含まれる属性は主属性と呼ばれ、候補コード に含まれない属性は非主属性と呼ばれます。 外部キー: リレーション内の属性または属性グループがリレーションのキーではないが、別のリレーションのキーである場合、その属性または属性グループをリレーションの外部キーと呼びます。 フルコード: リレーショナルスキーマのすべての属性グループは、このリレーショナルスキーマの候補コードであり、フルコードと呼ばれます。 スーパーコード（スーパーキー）：コードを含む属性のセットはスーパーコードと呼ばれます 関係モデルの定義 関係の記述はリレーショナルモデルと呼ばれ、正式には次のように表現されます: R(U, D, dom, F)\nここで、Rは関係名、Uは関係を構成する属性名のセット、Dは属性グループUの属性の由来となるドメイン、domは属性からドメインへのマッピングのセット、Fは属性データ間の依存関係のセット。\nこれは通常、R(U)またはR($A_1$, $A_2$, ···)と略記されます。ここで、Rは関係名、Uは属性名セット、$A_1$、···は個々の属性です。名前。\nリレーショナル モデルは、リレーショナル データ構造、リレーショナル操作セット、リレーショナル整合性制約の 3 つの部分で構成されます。\nリレーショナルデータ構造 リレーショナルモデルにおけるデータの論理的な関係は2次元のテーブルである\n関係演算セット リレーショナルモデルは関係を操作する機能を提供する\n一般的なリレーショナル操作には、選択、投影、接続、除算、結合、積、差などのクエリ操作、および追加操作と削除操作が含まれます。\nリレーショナル整合性制約 リレーショナル モデルの 3 つの整合性ルールは次のとおりです。\nエンティティの整合性: リレーションシップの主キーの値は空または部分的に空にすることはできません。つまり、主キーの属性、つまり主属性は空の値を取ることはできません。 参照整合性: リレーション $R_2$ の外部キーXがリレーション $R_1$ の主キーに対応する場合(基本リレーション $R_1$ と $R_2$ は必ずしも異なるリレーションではなく、同じリレーションである可能性があります)、次に、外部キー X の各値は、リレーション $R_1$ の主キーの値内に見つかる必要があります。見つからない場合は null になります。 ユーザー定義の整合性: 特定のデータに対してユーザーが指定した制約の検証を指します。 関係代数演算子 オペレーター シンボル 意味 集合演算子 ∪\n–\n∩\n× 連合\n違い\n交差点\nデカルト積 特殊な関係演算子 σ\nπ\n⋈\n÷ 選ぶ\n投影\n接続\n分割 比較演算子 ＞\n≥\n＜\n≤\n＝\n≠ より大きい\nより大きいか等しい\n未満\n以下\n等しい\n等しくない 論理演算子 ¬\n∧\n∨ 否\n及び\nまたは 従来の集合計算 専門的な関係オペレーター 接続 θ 接続、等接続と自然接続\nθ 接続：接続条件が等しくない 等価接続：接続条件は等価です 自然接続: 重複するプロパティの等価接続を削除します。最もよく使用される接続計算。 プロジェクター 投影計算は関係の垂直方向から計算を実行し、関係 R で新しい関係を構成するいくつかの属性列 A を抽出し、$π_A(R)$ を計算します。\n选择 選択計算は関係の水平方向からの計算であり、関係 R の中から所定の条件を満たす要素を選択し、$σ_F(R)$ として計算します。\n外部接続 外部接続計算は接続計算の拡張であり、接続計算によってメッセージが失われる可能性があります。\n左外部接続: 左側関係関係のすべてと右側関係関係のいずれかの要素グループが一致しない要素グループを取り出し、右側関係関係からのすべての属性を空の null で埋めます。 外部接続: 右側関係系のすべてと左側関係系のいずれかの元組が一致しない元組を取り出し、左側関係系からのすべての属性を空の null で埋めます。 ※全外部接続：左外部接続と右外部接続の操作を完了します。 除法 シンボルからSQL言語へ 関係 R：\nA B C 1 2 3 4 5 6 7 8 9 SQL言語への投影 $π_?(?)$\n1 select ? from ? $π_{A, B, C}(R)$ 或者 $π_{1, 2, 3}(R)$\n1 select A, B, C from R 注：SQL 语言不サポート列 (プロパティ) の順序番号\n選択からSQLへ $π_?(σ_?(?))$\n1 select ? from ? where ? $π_{A, B, C}(σ_{B \u0026gt;= \u0026lsquo;5\u0026rsquo;}(R))$ 或者 $π_{1, 2, 3}(σ_{2 \u0026gt;= \u0026lsquo;5\u0026rsquo;}(R))$\n1 2 3 select A, B, C from R where B \u0026gt;= \u0026#39;5\u0026#39; # または select A, B, C from R where B \u0026gt;= 5 デカルト積からSQLへ $π_{R.A, R.B, R.C, S.A, S.B, S.D}(R×S)$\n1 2 3 4 select R.A, R.B, R.C, S.A, S.B, S.D from R, S # 昇順で並べ替え order by R.A asc SQL言語への自然接続 関係 R(A, B, C) および S(B, C, D)\n$π_{R.A, R.B, R.C, S.D}(σ_{R.B = S.B ∩ R.C = S.C}(R×S))$\n1 2 3 select R.A, R.B, R.C, S.D from R, S where R.B = S.B and R.C = S.C ","date":"2023-02-07T06:00:00+08:00","permalink":"https://blog.yexca.net/ja/archives/87/","title":"データベース学習 2 リレーショナル モデル"},{"content":" この記事は Google 翻訳を使用して処理されました\nSQL Series\nデータベース学習 1 データベース入門: 本文\nデータベース学習 2 リレーショナル モデル: https://blog.yexca.net/archives/ja/87 データベースの学習 3 SQL言語: https://blog.yexca.net/ja/archives/88 以下のはまだ翻訳しないので、中国語（簡体字）のリンクだよ\n数据库学习四 关系数据库理论: https://blog.yexca.net/archives/89 数据库学习五 范式: https://blog.yexca.net/archives/90 数据库学习六 数据库设计: https://blog.yexca.net/archives/91 数据库学习七 数据库的控制功能: https://blog.yexca.net/archives/92 導入 以前のデータベースはうまく書かれていなかったので、見直して書き直しました（ただし、これもかなり乱雑です）\nデータベース4つの基本概念 データ 物事を記述する象徴的な記録\nデータベース 一般に、データベース データには、永続的な保存、整理、共有という 3 つの基本的な特性があります。\n厳密に言えば、データベースとは、長期間コンピューターに保存され、整理され、共有可能な大量のデータの集合です。データベース内のデータは、特定のデータ モデルに従って整理、記述、保存され、冗長性が低く、データの独立性が高く、スケーラビリティが容易で、さまざまなユーザーが共有できます。\nデータベース管理システム これは、ユーザーとオペレーティング システムの間に位置するデータ管理ソフトウェアのレイヤーです。オペレーティングシステムと同様に、コンピュータの基本ソフトウェアです。\n主な機能:\nデータ定義機能\nデータの整理、保存、管理\nデータ操作機能\nデータベースのトランザクション管理と運用管理\nデータベースの構築と保守機能\nその他の機能（通信機能、データ変換機能、相互アクセス・相互運用機能等）\nデータベースシステム これは、データベース、データベース管理システム (およびそのアプリケーション開発ツール)、アプリケーション、およびデータベース管理者 (DBA) で構成され、データを保存、管理、処理、および維持するシステムです。\nコンピューターデータ管理の開発 手動管理段階（1950年代半ば以前） データは保存、共有、独立していない\nファイル システム フェーズ (1950 年代後半から 1960 年代中期から後半) 保存はできるが、共有が不十分、冗長性が高く、独立性が低い\nデータベース システムの段階 (1960 年代後半から) データベースシステムの登場により、情報システムはデータ処理プログラム中心から共有データベース中心へと移行し、データ全体の構造化が実現しました。\nデータは高度に共有され、冗長性が低く、拡張が容易です。データの冗長性を大幅に削減し、ストレージスペースを節約し、データの独立性を高めることができます。\nデータモデル分類 モデル適用の目的の違いにより、モデルは2つのカテゴリまたは2つのレベルに分けられます。情報世界から抽象化されたデータモデルは概念データモデルと呼ばれ、DBMS（データベース管理システム）によってサポートされるデータモデルは情報世界から抽象化されます。コンピュータの世界では、構造データモデル（またはデータモデル）と呼ばれています。\nコンセプトデータモデル（概念モデル） 概念データモデルは、コンピュータシステムから独立したモデルです。システム内の情報の表現にはまったく関係しません。特定の組織が関心を持つ情報構造を記述するためにのみ使用されます。つまり、データをモデル化します。情報世界モデリングは、一般的にエンティティ・リレーションシップ法（E-R法）を用いて表現されます。主にデータベース設計に使用\n概念データ モデルでよく使用される用語は次のとおりです。\nエンティティ: 客観的に存在し、互いに区別できるものをエンティティと呼びます\n属性: エンティティを記述する特性を属性と呼びます。\nコード: エンティティを一意に識別する属性のセットはコードと呼ばれます。\nエンティティタイプ: エンティティ名と属性セットを使用して、類似のエンティティを抽象化し、特徴付けます。\nエンティティセット: 同じタイプのエンティティのコレクション\nドメイン: 属性の値の範囲は、属性のドメインと呼ばれます。\n関係: エンティティ間の対応する関係を関係と呼びます\n2つのエンティティ間の関係には3つの種類がある\n1対1のコンタクト 1対多の連絡 多対多の接続 実体関連法によって表現される概念データ モデルは、E-R 図と呼ばれます。エンティティは四角形で表され、属性は楕円形で表され、無向エッジはそれらを関連するエンティティに接続するために使用されます。\n構造データモデル（ロジックモデル） 構造データ モデルは、データベースの論理構造に直接関係します。すべての DBMS は構造データ モデルに基づいています。主にデータベース管理システムの実装に使用されます\n構造データモデルには主に、階層型、ネットワーク型、リレーショナル型、オブジェクト指向型などがある。\n階層モデル 階層モデルは、データ間の関係を表すために「ツリー構造」を使用します。そのデータ構造は「有向ツリー」です。\nメッシュモデル ネットワークモデルは「グラフ構造」を使用してデータ間の関係を表します。\nリレーショナルモデル リレーショナル モデルは、2 次元のテーブル構造を使用してエンティティとエンティティ間の関係を表すデータ モデルです。各 2 次元テーブルは行と列で構成され、これらは関係とも呼ばれます。リレーショナル モデルは、関係を記述したものです。したがって、リレーショナル モデルはリレーショナル パターンの集合であると言えます。\n物理モデル これはデータの抽象化の最低レベルです。システム内のデータの表現とアクセス方法、またはディスクやテープ上のデータの保存とアクセス方法を記述します。これはコンピュータシステム指向です。\nデータベースシステム構造 ストレージ構造が異なるデータベース製品は数多くあるが、アーキテクチャはすべて「3レベルモデルと2レベルイメージ」を採用しており、同じ特徴を持っている。\n3番目のレベルモード 概念モデル（基本表） スキーマまたは論理スキーマとも呼ばれ、データベース内のすべてのデータの論理構造と特性を記述したもので、すべてのユーザーに共通のデータ ビューです。\n外部モード（表示） ユーザー モードまたはサブモードとも呼ばれ、ユーザーとデータベース システム間のインターフェイスであり、ユーザーが使用するデータの説明です。\n内部モード（保存ファイル） ストレージ モードとも呼ばれ、データベースには 1 つの内部モードのみがあります。これは、データの物理的な構造と保存方法を記述したもので、データベース内でデータが整理される方法です。\n2 レベルの画像 データベース システムは、3 つのレベルのモデル間に、モデル/内部モデル マッピングと外部モデル/モデル マッピングという 2 つのレベルのマッピングを提供します。\nこれら 2 つのレベルのイメージがあるからこそ、データベース内のデータは高度な論理的独立性と物理的独立性を持つことになります。\nモード/内部モードイメージ（ストレージ） 概念レベルと内部レベルの間に存在し、概念モデルと内部モデルの相互変換を実現する\nデータベースのストレージ構造が変更された場合、データベース管理者はスキーマ/内部スキーマに対応する変更を加えてスキーマを変更しないようにできるため、アプリケーションを変更する必要がありません。データとプログラムの物理的な独立性を保証します\n外観モデル/モデルイメージ（表示） 外部レベルと概念レベルの間に存在し、外部モデルと概念モデルの相互変換を実現する\nスキーマが変更された場合、データベース管理者は各外部スキーマ/スキーマ イメージに対応する変更を加え、外部スキーマを変更せずに維持することができます。アプリケーションを変更する必要はありません。データとプログラムの論理的独立性を保証します\nデータの独立性とは、データがプログラムから独立しており、データの定義がプログラムから分離されていることを意味します。 DBMSの二次イメージング機能によりデータの独立性が確保されます。データの独立性には、データの物理的な独立性と論理的な独立性が含まれます。\nデータの物理的な独立性: ユーザーのアプリケーションとデータベース内のデータの物理的な保存は互いに独立しています。\nデータの論理的独立性: ユーザーのアプリケーションとデータベース内の論理構造は互いに独立しています。\nデータとプログラムが独立しているため、データの定義と記述をアプリケーション プログラムから分離できます。さらに、データアクセスはデータベース管理システムによって管理されるため、アプリケーションプログラムのコンパイルが簡素化され、アプリケーションプログラムの保守や修正にかかる手間が大幅に軽減されます。\nデータベースシステム構成 ハードウェアプラットフォームとデータベース 十分な大きさのメモリ、ディスクまたはディスクアレイ、その他のデバイス、データ転送速度を向上させるための高いチャネル容量\nソフトウェア データベース管理システム、データベース管理システムの動作をサポートするオペレーティングシステム、データベースインターフェースを備えた高級言語とそのコンパイルシステム、データベース管理システムを中核とするアプリケーション開発ツール、特定のアプリケーション環境向けに開発されたデータベースアプリケーションシステム\n人事 データベースを開発、管理、使用する人には、主にデータベース管理者、システムアナリスト、データベース設計者、アプリケーションプログラマー、エンドユーザーが含まれます。\nデータベース管理者の責任: データベースの情報内容と構造を決定し、データベースのストレージ構造とアクセス戦略を決定し、データのセキュリティ要件と整合性制約を定義し、データベースの使用と操作を監視し、データベースを改善および再編成します。 、データベースを再構築します。\n","date":"2023-02-06T19:57:35+08:00","permalink":"https://blog.yexca.net/ja/archives/86/","title":"データベース学習 1 データベース入門"},{"content":" 📢 この記事は ChatGPT によって翻訳されました はじめに 人間って、ある程度満足するともっと上を目指したくなるものだよね。NAS を組みたいと思いつつ、予算の都合で断念した結果、自宅 PC に Docker でアニメ・漫画・音声・入口ダッシュボードを構築してみた。\n前回の記事： 前回の記事を読む 完成図 すべて Docker でデプロイ。理論上、Docker が動く環境なら再現できるはず。\nドメインは link.start.icu に設定。本当は .icu 無しで済ませたかったけど、ブラウザでうまく解決できなかったから結局付けた（結果オーライかも？）\nスマホで開くと中央寄せ表示になるけど、若干不満あり（とはいえ使えないほどではない）\nそのうちサーバーにもデプロイしてナビページ化したいけど、タイトルの書き換えが JS 必須でちょっと面倒\n※Docker Desktop で起動してるため、今回は手順省略。デプロイ手順は 前回 を参照。\nDocker Hub ログイン Docker Hub から docker pull でイメージを取得するにはログインが必要な場合もある。\nまずは Docker Hub でアカウント作成。\n次に鍵を初期化：\n1 gpg --generate-key pub の下に出てきた文字列を pass init [pub] に入れて初期化：\n1 pass init [pub] その後、Docker Desktop にログイン。\nアニメ管理 - Jellyfin Docker Hub: jellyfin/jellyfin 公式サイト: Jellyfin 1 docker pull jellyfin/jellyfin カバー画像の管理が微妙だけど、NAS じゃないしそこまでこだわらないならこれで十分。\n参考： Jellyfin + Bangumi でアニメライブラリを快適に管理 漫画管理 - Komga Docker Hub: gotson/komga 公式サイト: Komga 1 docker pull gotson/komga ※注意：漫画が多すぎるとスキャン時に PC が重くなることあり。\n音声管理 - kikoeru-express Docker Hub: muveex/kikoeru-express GitHub: kikoeru-project/kikoeru-express 使用バージョンは v0.6.2（某サイトにそっくりかも？）\n1 docker pull muveex/kikoeru-express:v0.6.2 最初は PLEX を使おうと思ったけど、ログイン必須だし、UI は魅力的だけど ローカルファイルの読み込みに専用クライアントが必要で、権限が強すぎて怖かった（特にマウントフォルダを読めなかったのが致命的）。結局アンインストール。NAS 専用でいいや。\nホームダッシュボード - Heimdall Docker Hub: linuxserver/heimdall 公式サイト: Heimdall 1 docker pull linuxserver/heimdall 参考記事の中で「統一認証」の話が出てたけど、自分はそこまで必要ないのでスルー。 （というか設定がめちゃくちゃ複雑そうでやる気出なかった）\n最後に この経験を通じて思ったのは、NAS 専用 OS を買わなくても、PC パーツを組み合わせて Linux 入れてオープンソース使えば、わりとイイ感じの環境が作れるってこと。\nコマンド操作が苦手なら、Xfce や JWM みたいな軽量 GUI を入れるのもアリ。\n参考リンク Docker で NAS を自作する方法 - なんでもあり版 NAS で SSO（統一認証）を構築 Docker × PLEX で自宅メディアサーバー構築 Jellyfin + Bangumi アニメライブラリ構築ガイド ","date":"2022-09-16T15:00:01+08:00","permalink":"https://blog.yexca.net/ja/archives/73/","title":"個人ローカルネットワーク環境の構築"},{"content":" 📢 この記事は ChatGPT によって翻訳されました はじめに これは肖佳先生の書籍『HTTP抓包实战』を読んだ後にまとめた HTTP に関する学習メモです。主に HTTP メッセージ関連の内容を整理しました。（記録：読書＋本記事作成に5日間かかりました）\nHTTPメッセージ構造 HTTPメッセージには「リクエストメッセージ（Request）」と「レスポンスメッセージ（Response）」の2種類があります。\nHTTPリクエストメッセージ（Request） HTTPリクエストは以下の3つのパートで構成されます：\n開始行（Request line）：リクエストメソッド、URI、HTTPバージョン\n例：GET https://blog.yexca.net/ HTTP/2\nヘッダ部（Header）：追加情報や制御情報を含む\nボディ部（Body）：フォームデータやファイルなどの実データ（※省略される場合もあり）\n注意：ヘッダとボディの間には必ず空行が入ります。\nHTTPレスポンスメッセージ（Response） HTTPレスポンスも同様に3つのパートから成ります：\nステータス行（Response line）：HTTPバージョン、ステータスコード、ステータスメッセージ\n例：HTTP/2 200 OK\nヘッダ部（Header）\nボディ部（Body）\nこちらもヘッダとボディの間には空行が入ります。\nHTTPリクエストメソッドとステータスコード URLの構造 URL（Uniform Resource Locator）は、インターネット上のリソースを一意に識別するためのものです。\n基本構成：\n1 2 スキーム://ホスト\\[:ポート]/パス\\[?クエリ]\\[#アンカー] 項目 説明 スキーム http, https, ftp などの通信プロトコル ホスト ドメインまたは IP アドレス ポート番号 通常 HTTP は 80、HTTPS は 443（省略可） パス リソースのパス クエリ文字列 ?以降のパラメータ（例：?id=1\u0026amp;name=test） アンカー ページ内リンク（例：#top） 主なHTTPメソッド No. メソッド 説明 1 GET サーバーからデータを取得する 2 HEAD GETと似ているが、レスポンスボディは返されない（ヘッダのみ） 3 POST サーバーにデータを送信（例：フォーム送信、ファイルアップロードなど） 4 PUT リソースを新しく作成または完全に置き換える 5 DELETE 指定したリソースを削除する GETとPOSTの違い データの送信位置\nGET は URL の末尾（?以降）に付ける。POST はボディに含まれる。\nサイズ制限\nGET は URL 長に制限あり（ブラウザ依存）。POST は基本的に制限なし。\n取得方法\nGET は request.queryString、POST は request.form などを使う。\nHTTPステータスコード HTTPレスポンスの中に含まれる数字で、リクエストの結果を示すものです。\nコード範囲 意味 1XX 情報（処理中） 2XX 成功 3XX リダイレクト 4XX クライアントエラー 5XX サーバーエラー よく使われるステータスコード コード 説明 200 OK リクエストが成功した 301/302 恒久的/一時的リダイレクト。Location ヘッダに新しいURLが含まれる 304 コンテンツが更新されていない（キャッシュ利用可能） 401 認証が必要（Basic認証など） 403 アクセス禁止（アクセスは認識されたが拒否された） 404 リソースが見つからなかった 500 サーバー内部エラー（スクリプトエラーなど） 503 一時的にサービス利用不可（メンテ中など） 206 Partial Content（部分的コンテンツ） サーバーがリクエストされた一部のコンテンツを返した場合 動画のストリーミングやダウンロード再開などに使われる ヘッダに Range（要求）や Content-Range（応答）が含まれる 301 vs 302（リダイレクト） 301: 永続的な移動 → 検索エンジンもリンク先を更新 302: 一時的な移動 → ユーザーセッションやログイン時など 304 Not Modified（未更新） ブラウザキャッシュが最新 → サーバーは新しいデータを送らない 400 Bad Request（不正リクエスト） リクエストの構文エラー（例：クッキー不正、フォーム誤送信など） 401 Unauthorized（認証エラー） 認証ヘッダがない/不正な場合。Basic 認証などで返される 403 Forbidden（禁止） サーバーがリクエストを明示的に拒否したい時に使用（理由は非公開） 404 Not Found（見つからない） 該当リソースなし 例：非ログイン状態では一部URLが 404 を返す（実際は制限付き） 500 Internal Server Error（サーバー内部エラー） プログラムのバグ、DB接続エラー、例外など 503 Service Unavailable（サービス一時停止） 過負荷やメンテナンス時など その他のコードを見るには HTTP ステータスコード一覧 - 菜鸟教程 HTTP ヘッダー構成 ヘッダーの形式は「キー: 値」で 1 行ずつ記述され、それぞれが特定の機能を持ちます。\nキャッシュ関連ヘッダー HTTP リクエスト・レスポンスの両方にキャッシュ制御に関連するヘッダーがあります。\nHTTP キャッシュとは、同じリソースを再び取得する際にローカルのキャッシュを使用して、再ダウンロードを避ける仕組みです。\nCookie Cookie は HTTP のキャッシュ制御手段のひとつで、key=value 形式のデータです。\nブラウザ → サーバー：Cookie: ヘッダーで Cookie を送信 サーバー → ブラウザ：Set-Cookie: ヘッダーで Cookie を設定 例：ip_country=CN\nAccept Accept ヘッダーは、クライアントが受け入れ可能な MIME タイプを通知します。\n例：Accept: text/html は HTML を受信可能という意味です。\nワイルドカード（*）を使って任意タイプを表現できます。\n例：Accept: text/html, */*;q=0.8\nAccept-Encoding 圧縮方式に関するヘッダーで、クライアントが対応する圧縮形式を通知します。\n例：Accept-Encoding: gzip, deflate\nAccept-Language Accept-Language は、クライアントが受け入れられる言語の一覧を通知します。\n例：Accept-Language: en-US,en;q=0.8,zh-CN;q=0.6,zh;q=0.4,zh-TW;q=0.2\n言語（日本語、中国語など）と文字コード（UTF-8、GBK など）は別物です。\nUser-Agent User-Agent は、クライアントの環境情報（OS、CPU、ブラウザバージョンなど）を通知する文字列です。\n例：User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:103.0) Gecko/20100101 Firefox/103.0\nこれを書き換えることで、他のブラウザやデバイスを装ったリクエストも可能になります。\nReferer（リファラー） リファラーはアクセス元の URL を示し、どこから来たのかをサーバー側が判断できます。\nアクセス解析や不正リンク検出などに利用されます。\nConnection HTTP/1.1 以降は、デフォルトで Connection: Keep-Alive によって TCP 接続が継続されます。\nこの接続維持時間は Web サーバー側（Apache など）で設定可能です。\nHost Host ヘッダーは、リクエスト対象のホスト名とポート番号を明示します。HTTP/1.1 以降は必須です。\nポートが 80 の場合は省略可能です。\nHTTP キャッシュの仕組み HTTP のキャッシュは、主にブラウザやプロキシサーバーで動作します。\nキャッシュの利点 不要なデータ転送の削減 レスポンス速度の向上 サーバー負荷の軽減 キャッシュの鮮度判断方法 方法①：If-Modified-Since / Last-Modified クライアントが If-Modified-Since ヘッダーでローカルの更新日時を通知します。\nサーバーが Last-Modified ヘッダーと比較し、変更がなければ 304 Not Modified を返します。\n方法②：If-None-Match / ETag クライアントが If-None-Match で ETag（ハッシュ値）を送信し、サーバーが照合して同一なら 304 を返します。\nキャッシュ関連ヘッダー一覧 リクエスト側 ヘッダー名 説明 Cache-Control: max-age=0 キャッシュの有効期限（秒） If-Modified-Since: Tue, 28 Jun 2022 \u0026hellip; 最終更新日時 If-None-Match: \u0026ldquo;etag-value\u0026rdquo; キャッシュの ETag Cache-Control: no-cache キャッシュを使用しない Pragma: no-cache 上記と同じ（HTTP/1.0 用） レスポンス側 ヘッダー名 説明 Cache-Control: public 共有キャッシュ可（プロキシ等） Cache-Control: private ユーザー固有キャッシュ Cache-Control: no-cache 必ず再検証 Cache-Control: no-store 完全非キャッシュ（機密データ用） Cache-Control: max-age=60 相対時間での有効期限（秒） Date: Thu, 01 Sep 2022 \u0026hellip; サーバー送信日時 Expires: Thu, 01 Sep 2022 \u0026hellip; 絶対時間による有効期限 Last-Modified: Tue, 28 Jun 2022 \u0026hellip; 最終更新日時 ETag: \u0026ldquo;etag-value\u0026rdquo; キャッシュ判定用の識別子 ※ 通常は Cache-Control 優先、なければ Expires が参照されます。\nETag とは？ 「Entity Tag」の略で、ファイル内容から生成されるハッシュ文字列です 内容が変われば ETag も変わるので、更新判定が高精度 ETag は、Last-Modified では対応できない問題（ミリ秒単位の変更や内容が同じ等）を補います。\n強制再読み込みとキャッシュ Ctrl + Shift + R：強制リロード（キャッシュ無効） Ctrl + R：再読み込み（条件付き GET） アドレスバーから直接 URL 入力時は、ブラウザは「キャッシュ命中（cache hit）」としてサーバーと通信せず、ローカルキャッシュを使用します。\nパブリックとプライベートキャッシュ 種類 ヘッダー 説明 パブリック Cache-Control: public 共有可能（例：プロキシキャッシュ） プライベート Cache-Control: private 個別ユーザーのローカルキャッシュ HTTP 圧縮と URL エンコード HTTP 圧縮の概要 Web サーバーとブラウザ間で送受信される「テキストデータ」を圧縮する技術です。\n例：HTML / CSS / JavaScript など → gzip 圧縮\n圧縮とエンコードの違い HTTP ボディの「Content-Encoding」は、単にサイズ削減の gzip 圧縮だけでなく、暗号化なども可能です。\nつまり、HTTP 圧縮は HTTP エンコーディングの一種です。\n圧縮の流れ クライアントは Accept-Encoding: gzip, deflate で対応可圧縮形式を提示\nサーバー側は\n元のレスポンスを生成 ボディ部分を gzip 圧縮 Content-Encoding: gzip を付与 ブラウザへ返却 ブラウザは Content-Encoding を見てデコードし、元データを表示\n※リクエストの圧縮は一般的ではない\nContent-Encoding 種類 エンコーディング 内容 gzip GNU Gzip 形式 compress UNIX compress deflate zlib 圧縮 identity 無圧縮（指定なし時のデフォルト） gzip / deflate は一般的な可逆圧縮で、gzip のほうが効率が良く広く使われています。\nCookieメカニズムの仕組み HTTPはステートレスなプロトコルであり、同じブラウザからの複数のリクエストでもサーバー側では独立したものとして扱われ、関連性は持ちません。\nセッションとCookie サーバーがクライアントの識別を行うには、状態管理が必要になります。HTTPがステートレスであるため、クライアントとサーバーが共同で状態を管理する「セッションメカニズム」が使用されます。\nクライアントが初めてアクセスした際、サーバーはセッションIDを生成し、レスポンスに含めて返す ブラウザはセッションIDを保存し、以後のリクエストに含める サーバーはセッションIDによって同じクライアントかどうかを判別する このセッションの仕組みにCookieが使われています。\nCookieとは Cookieとは、ブラウザが少量のデータを key=value の形式で保持する仕組みです。複数のCookieは ; で区切られ、リクエスト時に自動的に送信されます。\n主に認証情報やユーザー設定の保持、または広告追跡・ターゲティングなどに利用されます。\n現在では、EUなどの国ではCookieの使用に関する法的制限があり、ユーザーの同意が必要です。\nCookieの属性 Expires\n有効期限を指定。未指定の場合、ブラウザを閉じると削除されます。\nPath\nCookieが有効なパス範囲を指定します。例：/test/ に設定すると、/test/ 配下でのみ有効。\nHttpOnly\nJavaScript からアクセス不可にする属性で、XSS対策に効果的。ログイン用Cookieには必須。\nCookieの種類と保存場所 種類 説明 セッションクッキー 一時的なCookie。ブラウザを閉じると削除される 永続クッキー 有効期限があり、再起動しても保持される ブラウザごとに保存場所は異なり、例：Linux + Firefox の場合\n~/.mozilla/firefox/xxxxxxxx.default-release/cookies.sqlite\nHTTP基本認証 HTTPはステートレスであるため、Cookieによる認証のほか、Basic認証（基本認証）も用いられます。\nクライアントは ユーザー名:パスワード をBase64でエンコードし、Authorization ヘッダーに含めて送信します。\n基本認証の流れ サーバーが 401 Unauthorized を返し、WWW-Authenticate ヘッダーで認証を要求 ブラウザがログインダイアログを表示し、認証情報を取得 入力されたユーザー名とパスワードをBase64エンコードし、リクエストに含めて送信 家庭用ルーターや一部のREST APIではこの方式がよく使われます。\n例：curl -u ユーザー名:パスワード https://example.com\n基本認証の欠点 ステートレスなので、リクエストごとに認証が必要 Base64は簡単に復号できるため、パスワードが平文で送信されるのと同等。HTTPS必須 明示的にログアウトできない（Cookieと違って期限切れの仕組みがない） リプレイ攻撃 に弱い Digest認証（要約認証） Digest認証は、基本認証のセキュリティ上の欠点を補った改良方式です。\nパスワードの代わりにハッシュ値を送信することで、平文送信を回避 サーバー側で nonce（ワンタイムトークン）を生成してリプレイ攻撃を防止 クライアントも nonce を用いることでサーバー認証が可能 コンテンツの整合性チェックにも対応 参考リンク 『図解HTTP』読書メモ HTTP ステータスコード一覧（菜鸟教程） 各ブラウザにおける Cookie の保存場所 「ログイン」と「登陆」の違い（知乎） リプレイ攻撃（Wikipedia） REST APIとは？（Red Hat） 表現層の状態遷移（Wikipedia） ","date":"2022-09-05T16:03:36+08:00","permalink":"https://blog.yexca.net/ja/archives/64/","title":"HTTP 学習メモ"},{"content":" 📢 この記事は ChatGPT によって翻訳されました はじめに Gitを使えば、友人とのコード管理や同期が簡単になります。特に静的サイトが好きな筆者にとっては、GitでWebファイルを同期できるのは非常に便利です。\nGitのインストール ROOTユーザーで以下のコマンドを順に実行：\n1 2 yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel perl-devel yum install git ユーザーの作成 Gitサービス用に専用のユーザーとグループを作成します。\n1 2 groupadd git useradd git -g git 公開鍵の取得 ローカルPC（Windows）の公開鍵は %UserProfile%/.ssh/ にある id_rsa.pub ファイルです。\nファイルが存在しない場合、cmdで以下を実行：\n1 ssh-keygen これにより鍵ペアが生成されます。\n公開鍵の登録 生成した公開鍵を /home/git/.ssh/authorized_keys に1行ずつ追加します。ファイルが存在しない場合は以下で作成：\n1 2 3 4 5 cd /home/git/ mkdir .ssh chmod 755 .ssh touch .ssh/authorized_keys chmod 644 .ssh/authorized_keys vi などで鍵を貼り付けて保存します。\nGitリポジトリの初期化 Gitリポジトリのディレクトリを /home/gitrepo/repo.git にします：\n1 2 3 4 5 cd /home mkdir gitrepo chown git:git gitrepo cd gitrepo git init --bare repo.git その後、リポジトリの所有者を変更：\n1 chown -R git:git repo.git リポジトリのクローン 1 git clone git@サーバーIP:/home/gitrepo/repo.git ディレクトリへの自動同期 Gitのhook機能を使います。\n1 2 cd /home/gitrepo/repo.git/hooks vi post-receive 以下のように記述：\n1 2 #!/bin/sh git --work-tree=/home/www/hexo --git-dir=/home/gitrepo/repo.git checkout -f ファイルに実行権限を付与：\n1 2 chmod +x post-receive chown -R git:git /home/gitrepo/repo.git コードの更新 単純にローカルコードを更新するだけなら：\n1 git pull 正式な手順：\n1 2 3 4 5 git status git checkout -- [ファイル名] git branch git checkout リモートブランチ名 git pull その他コマンド 1 2 3 4 git branch # ブランチ一覧 git checkout aaa # aaaブランチへ切り替え git branch aaa # aaaブランチ作成 git checkout -b aaa # aaaブランチ作成＆切り替え gitユーザーのシェルログインを禁止 セキュリティ上の理由から、git ユーザーのシェルログインを無効化：\n1 vi /etc/passwd 以下のように変更：\n1 2 -git:x:1004:1004::/home/git:/bin/bash +git:x:1004:1004::/home/git:/usr/bin/git-shell これでgitユーザーはSSHでGitを使用できますが、シェルにはログインできません。\n参考リンク Linux chown コマンド（菜鸟教程） Gitサーバー構築（菜鸟教程） SSHキーの生成（git-scm.com） GitにおけるSSHキーの使い方（简书） Gitサーバー構築（git-scm.com） Gitでローカルにコードを更新（CSDN） サーバー上にHexoを配置する（阿里云） Linuxパーミッションの解説 /etc/passwdファイルの詳細 ","date":"2022-08-13T10:28:50+08:00","permalink":"https://blog.yexca.net/ja/archives/57/","title":"Gitサーバーの構築と指定ディレクトリへの同期"},{"content":" この記事は Google 翻訳を使用して処理されました\n導入 コマンドラインから何かを実行して自慢したいと思わない男の子がいるでしょうか?以前から youtube-dl については知っていましたが、複雑すぎるようだったので使用していませんでした。今日試してみたところ、とても便利だとわかりました。\n環境 Python 3.7以降をインストールする Python の公式サイト でダウンロードしていい、インストールのとき、Add Python x.x to PATH をチェックしてね\nyt-dlp をインストール yt-dlp は youtube-dl に基づいて変更され、ダウンロード速度が速い\nダウンロード releases で yt-dlp.exe をダウンロードする\n構成 ダウンロードしたファイルを固定の場所に置き、マイコンピュータのプロパティを開き、システムの詳細設定 - 環境変数 - システム変数に移動し、Path を選択して編集をクリックし、新しいウィンドウで新規をクリックします。yt -dlp.exe のファイルを入力して\n次に、「はい」を 3 回クリックしてすべてのウィンドウを閉じる。\nテスト Win+R を押して「cmd」と入力し、Enter を押す。\ncmd に yt-dlp と入力します。Usage: yt-dlp [OPTIONS] URL [URL...] が表示されたら、設定は成功だ。\n更新 cmdに「yt-dlp -U」と入力するといい\n動画をダウンロード ダウンロードを開始するには、cmd に「yt-dlp」+「スペース」+「YouTube ビデオ リンク」と入力するだけです。\nデフォルトのダウンロードは720Pで、保存場所はC:/Users/%UserName%/です。\nダウンロード保存場所を変更する C:\\Users\\%UserName%\\AppData\\Roaming に新しいフォルダを作成し、yt-dlp という名前を付け、新しく作成したフォルダに入り、新しいファイル config.txt を作成します。\nファイルに次のコードを入力してください\n1 -o \u0026#39;C:/Users/%UserName%/Downloads/Video/%(title)s.%(ext)s\u0026#39; このうち、C:/Users/%UserName%/Downloads/Video/はダウンロードディレクトリです。\n%(title)s.%(ext)sは、ビデオのタイトルであるファイル名を保存する形式で、ビデオのタイトル.ビデオの拡張子名\n1080Pをダウンロード 1080P以上の動画は音声と動画が分離されているため、まずffmpegをダウンロードする必要があります。\nffmpeg 公式サイト にアクセスし、左下隅のシステムタイプを選択してから、ダウンロードを選択します。\nReleases · BtbN/FFmpeg-Builds を選択し、ffmpeg-n5.0-latest-win64-gpl-5.0.zipをダウンロードしました。\n次に、それを固定フォルダに配置し、システム変数に「bin」ファイルディレクトリを配置します。\nテスト cmd を開いて ffmpeg -version と入力します。バージョン番号が表示されれば、設定は成功です。\nクエリコマンド 現在のビデオの完全な形式を表示するには、yt-dlp -D [URL]と入力します (クエリのみ、ダウンロードは行われません)\nダウンロードコマンド 指定した形式でビデオをダウンロードするには、yt-dlp -f [ID] [URL]と入力します。ビデオとオーディオをダウンロードするには、[ID]+[ID]の組み合わせを使用できます。つまり、yt-dlp -f [ID]+[ID] [URL]はダウンロード後に自動的に結合されます\n注: 最高品質のビデオとオーディオをダウンロードします: -f \u0026quot;bv+ba/b\u0026quot;\naria2 を呼び出す ダウンロード コマンドの後に--external-downloader aria2c --external-downloader-args \u0026quot;-x 16 -k 1M\u0026quot; を追加するだけです。\n字幕をダウンロード 1 2 3 4 5 6 7 outube-dl --write-sub [url]\t//これはvtt形式の英語字幕とmkv形式の1080pビデオをダウンロードします youtube-dl --write-sub --skip-download [url] //ビデオをダウンロードせずに別の vtt 字幕ファイルをダウンロードします youtube-dl --write-sub --all-subs [url] //すべての言語の字幕をダウンロードします（ある場合） youtube-dl --write-auto-sub [url] //自動生成された字幕をダウンロードする（YouTubeのみ） ビデオリストをダウンロード 1 2 3 4 5 6 7 youtube-dl -f [format code] [palylist_url] //この方法では、指定された解像度のmp4ビデオをダウンロードできます youtube-dl [playlist_url] //ビデオ リストをダウンロードします。この方法でダウンロードされたビデオは、mkv または webm 形式である可能性があります。 youtube-dl -cit [playlist_url] //ビデオ リストをダウンロードします。この方法でダウンロードされたビデオは、mkv または webm 形式である可能性があります。 youtube-dl --yes-playlist [url] //リンクがビデオリストの場合、リスト内のビデオをダウンロードします。上記と同じですが、mkv または webm 形式である可能性があります。 視覚化 Releases · jely2002/youtube-dl-gui 参考文献 yt-dlp - Github 【备份】youtube-dl使用介绍 - 简书 一文搞懂Windows系统【目录变量】的相关知识_黑就黑到底的博客-CSDN博客_username变量 ","date":"2022-07-25T12:52:27+08:00","permalink":"https://blog.yexca.net/ja/archives/52/","title":"コマンドラインからYouTube動画をダウンロードする"},{"content":" 📢 この記事は ChatGPT によって翻訳されました はじめに 最近 Github Pages を使って個人ページを作りました（今は削除済み）。この記事では Github Pages でのサイト構築方法および独自ドメインの設定について記録します。\n本記事では CMS 等は使用せず、Markdown ファイル1つで書いた簡易なものです。\nGithub リポジトリの作成 まず Github に登録し、 新しいリポジトリを作成 します。\nこのときの Repository name は username.github.io としてください。たとえば自分のユーザー名が yexca の場合、yexca.github.io とします。\nGit 環境のインストール Windows では Git の公式サイトから インストーラをダウンロード してインストールすればOKです。\nインストール後、Git Bash を開き以下を入力します：\n1 2 git config --global user.name \u0026#34;Your Name\u0026#34; git config --global user.email \u0026#34;email@example.com\u0026#34; 自分の場合はこうです：\n1 2 git config --global user.name \u0026#34;yexca\u0026#34; git config --global user.email \u0026#34;yexca@duck.com\u0026#34; Github Desktop の利用 インストール Git 操作に慣れていればスキップしても構いません（慣れてる人はこの記事を読まない気がしますが）\nGithub Desktop 公式サイト からダウンロードしてインストールします。\nリポジトリをクローン Github Desktop を起動し、ログイン後に空フォルダを選択し、先ほど作成したリポジトリをクローンします。\nソフトウェア右側に変更履歴と各種操作が表示されます。\nここでは VS Code で開く（Open in Visual Studio Code）を選びます。\nサイトの作成 README.md を作成して Markdown で編集します（ついでに自分の Markdown ノートも見てね）。\n編集後に保存し、Github Desktop で Commit to main を押し、続けて Push origin をクリックします。\nこれで https://username.github.io にアクセスすれば自分のサイトが表示されます（しばらく反映に時間がかかることがあります）\n独自ドメインの設定 Github Pages 側設定 リポジトリページの Settings → 左側 Pages → Custom domain 欄に独自ドメインを入力し Save。\n※同画面で Jekyll テーマも選べます。\nDNS 側設定 ドメイン管理パネルにて CNAME レコードを追加し、username.github.io に向けます（username は自分の Github アカウント名）\nHTTPS の設定 Github 公式の HTTPS がうまく機能しなかったため、 Cloudflare を使用しました。\nCloudflare の DNS 管理で「プロキシを有効化」し、「SSL/TLS」→「エッジ証明書」→「常時 HTTPS」をオンにします。\n他の構築方法 私はブログ用途ではないため、Markdown 1枚の簡易ページで済ませましたが、本格的なブログを作る場合は以下のような静的サイトジェネレータを使うと便利です。\nJekyll ：Github 公式サポート VuePress 日本語 Gitbook：ドキュメント向き LOFFER Gridea ：GUI ベースの静的ブログクライアント Hexo ：高速・簡潔なブログフレームワーク Hugo ：ビルド速度最強クラス 参考リンク GitHub Pages クイックスタート - GitHub Docs GitHub Pages ブログ：独自ドメイン・HTTPS・CAA GitHub Pages 構築チュートリアル Git インストール - 廖雪峰の公式サイト ","date":"2022-05-28T15:30:43+08:00","permalink":"https://blog.yexca.net/ja/archives/44/","title":"Github Pages でのサイト構築と独自ドメインの設定"},{"content":" 📢 この記事は ChatGPT によって翻訳されました はじめに 最近、 クラウドサイト を作る過程で Markdown に触れましたが、非常に使いやすいことに気付き、学習ノートとしてまとめることにしました。\nオンラインエディタ を使いながら学んでもよいし、 ローカルエディタ を導入してもよいでしょう。\n私自身は Typora を使用しています。\n復習には Markdown チートシート をどうぞ。\n見出し # + 半角スペース + 見出し名で作成し、1～6段階（HTML の h1～h6）に対応します。\n1 2 3 4 5 6 # 見出し1 ## 見出し2 ### 見出し3 #### 見出し4 ##### 見出し5 ###### 見出し6 一般的なウェブページでは、h1 はページタイトル、h2 以下が本文になります。h4 まであれば十分です。\n改行 前の行の末尾に「半角スペースを2つ以上 + 改行」で改行できます。一部エディタでは自動的に処理されます。\n1 2 これは1行目（スペースあり） これは2行目 結果：\nこれは1行目（スペースあり） これは2行目\n斜体・太字 斜体は *テキスト*、太字は **テキスト**、両方なら ***テキスト***。\n1 2 3 *斜体* **太字** ***斜体かつ太字*** 結果：\n斜体 太字 斜体かつ太字\n引用 行頭に \u0026gt; を付けます。\n1 2 3 \u0026gt; 引用レベル1 \u0026gt;\u0026gt; 引用レベル2 \u0026gt;\u0026gt;\u0026gt; 引用レベル3 結果：\n引用レベル1\n引用レベル2\n引用レベル3\nリスト 番号付きリスト 数字. 半角スペース 内容\n1 2 3 1. 項目1 2. 項目2 3. 項目3 箇条書きリスト -、+、* のいずれかを使用（統一推奨）、インデントで階層化。\n1 2 3 4 5 - 第一項目 - 子項目1 - 子項目2 - 孫項目 - 第二項目 コード インラインコード `コード` で囲みます。\n1 2 `コード` ``これは \\` を含むコードです`` ブロックコード 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ```c #include\u0026lt;stdio.h\u0026gt; int main() { printf(\u0026#34;Hello World\u0026#34;); } ``` ``` 結果： ```c #include\u0026lt;stdio.h\u0026gt; int main() { printf(\u0026#34;Hello World\u0026#34;); } 水平線 3つ以上の *、-、_ のみを使って改行。\n1 *** 結果：\nリンク 簡易リンク 1 2 \u0026lt;https://yexca.net\u0026gt; \u0026lt;yexca@duck.com\u0026gt; 結果：\nhttps://yexca.net yexca@duck.com テキスト付きリンク 1 2 [ブログ](https://blog.yexca.net) [ブログ](https://blog.yexca.net \u0026#34;実は Hiyoung と共同\u0026#34;) 参照型リンク 1 2 3 4 [blog]: https://blog.yexca.net [contact]: \u0026lt;mailto:yexca@duck.com\u0026gt; これは [ブログ][blog] です。連絡は [こちら][contact] 画像 1 ![alt](画像URL \u0026#34;タイトル\u0026#34;) 例：\n1 ![背景](https://cdn.statically.io/gh/yexca/picx-images-hosting@master/2023/04-网站背景/blog-background.2p10z489pjc0.webp \u0026#34;背景画像\u0026#34;) 画像 + リンク：\n1 [![画像](URL)](リンク先) エスケープ Markdown の記号をそのまま表示したい時は \\ をつけます。\n1 2 これは * 斜体になります これは \\* そのまま表示 HTML挿入 1 2 3 4 \u0026lt;details\u0026gt; \u0026lt;summary\u0026gt;クリックで展開\u0026lt;/summary\u0026gt; 本文です \u0026lt;/details\u0026gt; Hugoテーマによっては HTML を正しく表示できないことがあります。\n表 1 2 3 | ヘッダ | 内容 | 備考 | |:------|:----:|----:| | 左寄せ | 中央 | 右寄せ | 結果：\nヘッダ 内容 備考 左寄せ 中央 右寄せ 打ち消し線 1 私は ~~戦争文学博士~~ Warma が好き 結果：\n私は 戦争文学博士 Warma が好き\nチェックリスト 1 2 - [ ] 未完了 - [x] 完了 結果：\n未完了 完了 絵文字 コピー貼り付け Emojipedia から絵文字をコピーして貼るだけ。\nショートコード : で囲みます（要対応環境）\n1 :blush: :smiley: 結果：\n😊 😃\n脚注 1 2 3 4 5 参考[^1]、GitHub[^2]、ユーザー[^yexca] [^1]: 注釈テキスト [^2]: [GitHub](https://github.com/yexca) [^yexca]: [プロフィール](https://lit.link/yexca) 参考リンク Markdown公式ガイド Markdown学習資料 ","date":"2022-05-28T00:59:23+08:00","permalink":"https://blog.yexca.net/ja/archives/43/","title":"Markdown 概要（学習ノート）"},{"content":" 📢 この記事は ChatGPT によって翻訳されました はじめに Beat Saber や VRChat などの VR ゲームをプレイしたあと、I社の一部ゲームが VR に対応していることを思い出し、一番好きな「恋活（Koikatu）」を試してみたところ、いくつか問題に直面しました。本記事はその記録です。なお、VR 版にはストーリーがなく、筆者は無改造のオリジナル版を使用しているため、発生する問題は少なめです。\n前提条件 以下の画像と一部の説明は Oculus 公式サポートページ から引用しています。翻訳は筆者によるものなので、正確な内容は公式を参照してください。\nケーブル要件 Oculus Link には、データ転送と給電の両方に対応した高品質な USB ケーブルが必要です。快適にプレイするには、長さ 3m（10フィート）以上が推奨されています。\nPC 推奨スペック パーツ 推奨構成 CPU Intel i5-4590 / AMD Ryzen 5 1500X 以上 GPU 対応表を参照 メモリ 8GB 以上 OS Windows 10 USB ポート 1つ必要 Oculus Link 対応 GPU NVIDIA GPU スポット スポットではない NVIDIA Titan Z X NVIDIA Titan X X NVIDIA GeForce GTX 970 X NVIDIA GeForce GTX 1060 Desktop, 3GB X NVIDIA GeForce GTX 1060 Desktop, 6GB X NVIDIA GeForce GTX 1060M X NVIDIA GeForce GTX 1070(all) X NVIDIA GeForce GTX 1080(all) X NVIDIA GeForce GTX 1650 X NVIDIA GeForce GTX 1650 Super X NVIDIA GeForce GTX 1660 X NVIDIA GeForce GTX 1660 TI X NVIDIA GeForce RTX 20-series (all) X NVIDIA GeForce RTX 30-series (all) X AMD GPU スポット スポットではない AMD 200 Series X AMD 300 Series X AMD 400 Series X AMD 500 Series X AMD 5000 Series X AMD 6000 Series X AMD Vega Series X 詳しくは 公式互換ページ をご確認ください。\n一、ゲーム起動について Koikatu VR を起動するには、KoikatuVR.exe を直接実行してください。Steam のストリーミング機能を使っている場合は、事前に SteamVR を立ち上げておくとスムーズです。\n問題1：SteamVR に入れない 1. 必要ソフトの確認 SteamVR のインストール Steam を開いた状態で Win+R を押し、steam://run/250820 を入力して Enter を押すと自動でインストールが開始されます。\nOculus ソフトのインストール 公式サイト からダウンロード＆インストール。初回起動時にアカウントログインが必要です。支払い方法の入力を求められた場合、「スキップ」可能です。\nログインが終わらない・ずっと読み込み中 hosts ファイルを編集することで解決可能です。火絨（Huorong）などのツールが便利ですが、手動でも以下を追加してください。\n1 2 3 4 157.240.11.49 graph.oculus.com 157.240.11.49 www2.oculus.com 157.240.8.49 scontent.oculuscdn.com 157.240.8.49 securecdn.oculus.com ファイル：C:\\Windows\\System32\\drivers\\etc\\hosts をメモ帳で開き、末尾に追加。\n2. Link ケーブルが正常か確認 Oculus ソフトで「Quest2 および Touch - USB 接続のテスト」を実行してください。接続時のポップアップでも確認可能です。\n3. 設定が正しいか確認 Quest2 本体のポップアップ → 「データへのアクセスを許可」は「拒否」を選択\nOculus ソフトの「設定 \u0026gt; 一般 \u0026gt; 不明なソースを許可」をオンにする\n4. それでもダメなら別ルートで起動 Quest2 側で「Oculus Link を有効化」→「有効にする」 SteamVR を手動で起動（Steam ライブラリ内にあります） 二、ゲーム開始 KoikatuVR.exe をダブルクリックすると自動で SteamVR が起動します。Oculus Link 接続後に直接起動すれば OK。\n注意：ゲーム画面がデスクトップにもウィンドウ表示されます。Win+D などで最小化可能ですが、HMD を一度外すと再表示される場合があります。\n問題2：ゲームが開始できない / 操作方法が不明 一部ネット上では「対応デバイスのみ有効」といった情報がありますが、実際には次のように操作可能です：\n「スティック押し込み」で選択レーザー表示、「トリガー」で決定。\n詳細操作は次項で紹介します。\n問題3：白画面のまま開始できない、PC 側で読み込みが止まる コイカツ！DL 版の公式ページ 下部から「コイカツ VR パッチ」をダウンロードしてください：\n直リンク： vr_patch.zip 解凍後、setup フォルダの中身をゲームフォルダに上書きしてください。\n注：この方法では「体位数が3つに制限される」可能性があります。\n回避策：ストーリーモードで体位をすべて実行 → 夜にセーブ → VR モードでロードすれば、すべて解放されます。\n参考スレッド： 兄弟们有没有玩了 vr 的 三、基本操作 筆者がプレイして確認した範囲の操作を以下に記載します。\n1）ゲーム起動後の選択 「スタート（Start）」「エンド（End）」の2つがあります。\nスティック押し込み：レーザー表示 前側トリガー：決定 2）プレイ中の操作 両手コントローラーの手首あたりに表示が出ます。\n日本語 英語 内容 操作 アクション Action 行動 前トリガー：メニュー表示・実行、側面トリガー：詳細 システム System 設定 前トリガー：位置リセット 移動 Move 移動 前トリガー押しっぱなしで視点変更 ※「アクション」中のみスティック押し込みで選択可能\n参考リンク Oculus Link 公式ページ 兄弟们有没有玩了 vr 的 Oculus クライアントがログインできない時の対処法 ","date":"2022-03-18T16:54:23+08:00","permalink":"https://blog.yexca.net/ja/archives/30/","title":"Quest2 でコイカツを VR プレイする際の問題とその解決"},{"content":"WordPress へようこそ。これが最初の投稿です。編集または削除して書き込みを始めてください。\n","date":"2021-11-06T14:15:19+08:00","permalink":"https://blog.yexca.net/ja/archives/1/","title":"Hello World！"}]