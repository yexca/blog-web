[{"content":" 📢 この記事は gemini-3-flash-preview によって翻訳されました 参考文献のある文章を書くとき、Wordの使い心地はなんとも言えない感じだったんだけど、LaTeXを試してみたら、前にMarkdownに乗り換えたときみたいに「内容だけに集中できる体験」が最高だって感動しちゃった。生成されるPDFもすごく綺麗で、見てるだけで楽しいんだ。\nこの記事では、VS Codeにインストールして使う方法を中心に、よく使う構文をまとめてみた。細かい詳細は、最後にある公式サイトのチュートリアルを参考にしてみてね。\nインストール TeX Liveをインストールするのが便利だよ https://www.tug.org/texlive/ 。必要な依存関係が全部入るんだけど、インストールにはめちゃくちゃ時間がかかるから注意してね。\n次にVS Codeのプラグインを入れよう。Ctrl+Shift+X で拡張機能を開いて、「LaTeX Workshop」を検索してインストールする。\nインストールが終わったら Ctrl+, で設定を開いて、「Latex Recipes」を検索。setting.json で編集して、latex-workshop.latex.recipes の配列の中で latexmk (xelatex) を一番上に持ってくる。ついでに自動折り返しも設定しておくといいかも。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 { \u0026#34;latex-workshop.latex.recipes\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;latexmk (xelatex)\u0026#34;, \u0026#34;tools\u0026#34;: [ \u0026#34;xelatexmk\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;latexmk\u0026#34;, \u0026#34;tools\u0026#34;: [ \u0026#34;latexmk\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;latexmk (latexmkrc)\u0026#34;, \u0026#34;tools\u0026#34;: [ \u0026#34;latexmk_rconly\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;latexmk (lualatex)\u0026#34;, \u0026#34;tools\u0026#34;: [ \u0026#34;lualatexmk\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;pdflatex -\u0026gt; bibtex -\u0026gt; pdflatex * 2\u0026#34;, \u0026#34;tools\u0026#34;: [ \u0026#34;pdflatex\u0026#34;, \u0026#34;bibtex\u0026#34;, \u0026#34;pdflatex\u0026#34;, \u0026#34;pdflatex\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;Compile Rnw files\u0026#34;, \u0026#34;tools\u0026#34;: [ \u0026#34;rnw2tex\u0026#34;, \u0026#34;latexmk\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;Compile Jnw files\u0026#34;, \u0026#34;tools\u0026#34;: [ \u0026#34;jnw2tex\u0026#34;, \u0026#34;latexmk\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;Compile Pnw files\u0026#34;, \u0026#34;tools\u0026#34;: [ \u0026#34;pnw2tex\u0026#34;, \u0026#34;latexmk\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;tectonic\u0026#34;, \u0026#34;tools\u0026#34;: [ \u0026#34;tectonic\u0026#34; ] } ], \u0026#34;[latex]\u0026#34;: { \u0026#34;editor.wordWrap\u0026#34;: \u0026#34;on\u0026#34; }, } ドキュメント構造 LaTeXのドキュメント構造は大体こんな感じ。ドキュメントは \\begin{document} から始まって、その前はインポートとか設定を書く場所（プリアンブル）だよ。\n1 2 3 4 5 6 7 8 9 10 11 \\documentclass[a4paper,12pt]{article} % The document class with options % select T1 font encoding: suitable for Western European Latin scripts \\usepackage[T1]{fontenc} % A comment in the preamble \\begin{document} % This is a comment This is a simple document\\footnote{with a footnote}. This is a new paragraph. \\end{document} ドキュメントクラス LaTeXはいろんなドキュメントクラスをサポートしてて、\\documentclass{} で指定できるんだ。よく使う標準的なのはこの5つ。\narticle report book letter slides 1行目のインデント indentfirst パッケージを読み込むと各段落の最初がインデントされるようになるよ。あとはインデントする幅を設定すればOK。\n1 2 \\usepackage{indentfirst} % indent \\setlength{\\parindent}{1em} % set indent for 1em 日本語対応（日文支持） XeCJKを導入して、フォントを設定しよう。\n1 2 3 4 5 \\usepackage{xeCJK} % kanji \\setCJKmainfont{MS Mincho} \\setCJKsansfont{MS Gothic} \\setCJKmonofont{MS Gothic} 見出し \\section{} を使って見出しを分けるよ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 \\documentclass{article} \\usepackage[T1]{fontenc} \\begin{document} Hey world! This is a first document. \\section{Title of the first section} Text of material in the first section Second paragraph. \\subsection{Subsection of the first section} Text of material in the subsection. \\section{Second section} Text of the second section. \\end{document} 数式 https://www.latexlive.com/ でプレビューしながら視覚的に編集できるよ。\nリスト リストを作る方法は2種類あるよ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \\documentclass{article} \\usepackage[T1]{fontenc} \\begin{document} Ordered \\begin{enumerate} \\item An entry \\item Another One \\item Wow! Three entries \\end{enumerate} Unordered \\begin{itemize} \\item An entry \\item Another One \\item Wow! Three entries \\end{itemize} \\end{document} 参考文献 ドキュメントの最初で、参考文献のタイトル名を変更できるよ。例えば \\renewcommand{\\refname}{参考文献} と書けば、タイトルが「参考文献」になるんだ。\n同じディレクトリに bib ファイル（例えば citations.bib）を作ってね。\n引用するときはドキュメント内で直接 \\cite{key} を使う。複数を同時に引用するときは , で区切ればOK。\n1 \\cite{key1, key2} ドキュメントの最後に参考文献を生成するコードを書くよ。\n1 2 3 4 5 6 \\small %% set small size \\bibliographystyle{IEEEtran} %% you can change the style into any other styles available, I personally love IEEEtran. \\bibliography{citations} %% to generate references, input the name of your .bib file and cite anywhere in the document. 参考記事 LaTeX 公式チュートリアル XeCJK - Tex Wiki ","date":"2026-01-13T00:15:47+09:00","permalink":"https://blog.yexca.net/ja/archives/266/","title":"LaTeXを使い始めてみた"},{"content":" 📢　この記事は Gemini-3-flash によって翻訳されました　利用するイメージ image: https://hub.docker.com/r/itzg/minecraft-server github: https://github.com/itzg/docker-minecraft-server document: https://docker-minecraft-server.readthedocs.io/en/latest/ 設定ファイル バニラ（純正版）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 services: mc: image: itzg/minecraft-server:java17 container_name: mc ports: - \u0026#34;25565:25565\u0026#34; environment: EULA: \u0026#34;TRUE\u0026#34; TYPE: \u0026#34;VANILLA\u0026#34; VERSION: \u0026#34;1.20.1\u0026#34; MEMORY: \u0026#34;2G\u0026#34; volumes: - ./data:/data restart: unless-stopped Forge版を立ち上げる時の設定\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 services: mc: image: itzg/minecraft-server:stable-java17 tty: true stdin_open: true ports: - \u0026#34;25565:25565\u0026#34; environment: EULA: \u0026#34;TRUE\u0026#34; VERSION: \u0026#34;1.20.1\u0026#34; TYPE: \u0026#34;FORGE\u0026#34; FORGE_VERSION: \u0026#34;47.4.10\u0026#34; MEMORY: \u0026#34;3G\u0026#34; volumes: - ./data:/data バージョンは公式サイトで確認できるよ： https://files.minecraftforge.net/net/minecraftforge/forge/ Modパックをダウンロードする場合\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 services: mc: image: itzg/minecraft-server:java17 container_name: mc ports: - \u0026#34;25565:25565\u0026#34; environment: EULA: \u0026#34;TRUE\u0026#34; TYPE: \u0026#34;CURSEFORGE\u0026#34; CF_API_KEY: \u0026#34;君のAPIキー\u0026#34; CF_MODPACK_SLUG: \u0026#34;modpack-slug\u0026#34; CF_MODPACK_VERSION: \u0026#34;47.4.10\u0026#34; MEMORY: \u0026#34;4G\u0026#34; volumes: - ./data:/data サーバーのポート開放 現在のゾーンを確認する。\n1 firewall-cmd --get-active-zones ポートを開放する。\n1 sudo firewall-cmd --zone=public --permanent --add-port=25565/tcp 設定をリロードする。\n1 sudo firewall-cmd --reload 確認。\n1 sudo firewall-cmd --zone=public --list-all 独自ドメインの設定 Cloudflareのプロキシ（オレンジ色の雲）やNginxのリバースプロキシは使えないから注意してね。\nでも、SRVレコードを使えばポート番号を入力しなくてもドメインだけで接続できるようになるんだ。\n名前（Name）には _minecraft._tcp.your-mc-server.yexca.net を入力して、優先順位（Priority）は 0、重み（Weight）はよく使われる 5 か 10 に設定。ポート（Port）はサーバーのポート（例えば 25565）、ターゲット（Target）には対応するドメイン your-mc-server.yexca.net を書けばOK。\nサーバーの設定 起動が終わると、./data の中に設定ファイルが出来上がっているよ。詳しい項目についてはここを参考にしてみて： https://wiki.biligame.com/mc/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F ","date":"2026-01-06T20:38:41+09:00","permalink":"https://blog.yexca.net/ja/archives/265/","title":"Dockerを使ってMinecraftサーバーを立てる方法"},{"content":" 📢　この記事は Gemini-3-pro によって翻訳されました　意識は肉体から独立でき、直感は論理を超え、観測は現実を変える\nNDE (Near-Death Experience、臨死体験) とは、死に直面した際の体験のことです。現在、IANDS（国際臨死体験研究協会）や、数千人のNDE経験者（NDErs）を調査したP.M.H. Atwater博士など、個人や組織によって研究が進められています。\nこの記事は、それらの研究と私個人の解釈に基づいて書かれています。内容がかなり複雑なので、少し抜けている部分があるかもしれませんが、そこはご容赦ください。\nNDEとは何か 発生メカニズムの観点から見ると、NDEは通常、医学的に身体が死亡状態にあると認定された後、意識が「あっちの世界」へ行く体験を指します。しかし注目すべきは、「感情誘発型NDE (Emotion-Induced NDE)」も存在するということです。これは、極度の感情 (Extreme Emotional) や心理的ストレス (Psychological Distress) によって、肉体は無事でも意識が離脱メカニズムを発動し、「あっち」へ行ってしまう現象です。例えば、失恋症候群や迷走神経反射 (Vasovagal Syncope) による失神などがこれに当たります。\nNDEの核心は、意識が「あっち」へ行き、そして戻ってくるという「離脱 (OBE, Out-of-Body Experience)」と「再突入 (Re-entry)」のプロセスにあり、単なる素敵な夢や悪夢とは一線を画します。\n「あっちの世界」の特徴としては、時間の非線性、折り畳まれた空間、そして奥行きと包容力のある光（この光は、高次元世界と三次元世界の意識をつなぐインターフェースかもしれません）などが挙げられます。\nまた、NDE後の「統合期 (Integration Period)」には、PTSDのような症状が現れたり、深い抑うつ状態に似た影が見えたりすることもあります。例えば「自我の溶解 (Ego Dissolution)」や世界からの疎外感などです。回復過程はPTG（心的外傷後成長）に似ていますが、本質的には大きな違いがあります。\nNDEと夢の違い NDEと普通の夢を区別するために、Bruce Greyson博士は厳格な評価システム「グレイソン尺度 (The Greyson NDE Scale)」を策定しました。\n判定基準は各項目（0=なし、1=軽微、2=強い）で評価されます。\nA. 認知的特徴 (Cognitive)\n時間感覚の変化（速くなる/遅くなる/停止/非線形） 思考の加速（極めて明晰/パノラマ的な回顧） 人生の回顧（走馬灯） 宇宙や人生の真理を突然理解したか B. 感情的特徴 (Affective)\n安らぎ/喜びを感じたか 極度の至福を感じたか 宇宙や万物との一体感を感じたか 眩い光を見た/感じたか C. 超常的特徴 (Paranormal)\n感覚が通常より鋭敏になったか（または肉体からの離脱感） 超感覚的知覚（予知/透視）があったか 未来の光景を見たか 物理的世界から離れたと感じたか D. 超越的特徴 (Transcendental)\nこの世のものではない領域（夢/虚空）に入ったか 神秘的な存在（死神/声/光の体）に出会ったか 故人や宗教的な人物に出会ったか 引き返せない境界線（生死を決める瞬間）に遭遇したか 合計は32点で、7点以上であれば臨床科学的にNDEとして認定されます。\nNDEとPTSD PTSDとNDEはどちらも、極端なトラウマを経験した後に脳の既存の防衛メカニズムが崩壊することで起こります。PTSDはその再構築がうまくいかなかった状態であり、再構築を経るとPTG（心的外傷後成長）へと変化します。\n解離感 (Dissociation)、過覚醒、様々な痛みなどはPTSD患者にも見られますが、両者はほぼ別物と言っていいでしょう。\n生命科学的な説明 PTSDとNDEでは、脳の変化の仕方が異なります。\nPTSDの脳では、扁桃体 (Amygdala) の肥大と海馬 (Hippocampus) の萎縮が見られます。扁桃体は警告を司るため、ここが肥大すると患者は極度に敏感になり、常に「闘争・逃走反応」の興奮状態に置かれます。一方、海馬は記憶処理を司るため、ここが萎縮すると過去のトラウマをうまくファイリングできず、常にトラウマが現在進行形で起きているように感じ、恐怖のループから抜け出せなくなります。\n対してNDEの脳は、デフォルトモードネットワーク (DMN) の抑制と側頭頭頂接合部 (TPJ) の変化が見られます。DMNは自我の形成、不安、過去への反芻を司るネットワークで、ここの活性が低下するということは、エゴ (Ego) が薄れ、不安が減少することを意味します。また、TPJは「自分がどこにいるか」を処理する部位なので、ここの変化によってNDErs（臨死体験者）は「体外離脱」や万物との一体感を感じるようになるのです。\n両者の比較 決定的な違いをいくつか挙げてみましょう。\n特徴 PTSD NDE 核心感情 恐怖、無力感、不安 最終的に平穏、受容、愛へ向かう 自己認識 自分が壊れている、被害者 自分は観測者 (Observer) である 世界観 世界は危険、逃げなきゃ 世界には意味がある、任務がある 死への態度 死を極度に恐れる 恐怖が減る、または探究心に変わる また、PTSDは治療介入を経てPTGになる可能性がありますが、NDEは治療を必要とせず、自分の内なる声に従うだけで前向きな精神状態になれます。\nNDEとPTG PTG (Post-Traumatic Growth) は本質的に心理レベルの「認知の再構築」であり、大きなトラウマを経た後、認知が変わることで性格や価値観が変わることです。\n一方、NDEは生理学的かつ量子レベルでのエネルギーオーバーロードです。Rick Strassmanの仮説に基づけば、瀕死の瞬間（低酸素、脳内の電気サージ）に松果体から大量のDMTが放出され、ニューロンの同期発火がピークに達することで、意識が一時的に肉体の束縛から解き放たれます。その結果、性格だけでなく、身体の物理的属性までもが変化してしまうのです。\nまとめ NDEは物理的かつ精神的な二重の変化であるのに対し、PTSDやうつ病などの精神疾患は、精神あるいは心理レベルの変化に留まると言えます。\nなぜNDEは存在するのか NDEは「不合理の中の合理」です。映画『マトリックス』のネオのように、「君の存在は、この完璧な数学的方程式からどうしても排除できない余り（剰余）なのだ」というわけです。\nもちろん、これは「熱的死 (Heat Death)」と「デッドロック (Deadlock)」を防ぐためのものでもあると考えられます。\nもしこの物質世界 (Reality) が完全に閉じていて、物理法則や因果律（ニュートン力学/決定論）に厳密に従っているとしたら、システムは最終的にエントロピーが増大しきった死に体（熱的死）になるか、論理が緻密すぎて動かなくなるデッドロック（人類が完全に機械化し、霊性を失う）に陥るでしょう。\nだからこそ、NDErsは外部変数として導入され、高次元空間の混沌としたエネルギー（霊性/愛/真理）を少し帯びて戻り、「負のエントロピー (Negentropy)」を注入することで、熱的死とデッドロックを防いでいるのです。\nNDEは再現できるか 現代の神経科学では、NDEは「魂の離脱」ではなく、極限の危機的状況における脳の特殊な保護メカニズムだと考えられています。以下の行為でも、NDEに似た感覚が生じることがあります。\n側頭葉てんかん: 脳の側頭葉を刺激すると、普通の人でも「神に出会う」ような感覚を得ることがあります。 低酸素/Gフォース昏睡: パイロットが遠心分離機の中で気絶する際にも、「トンネル視界」や「人生の回顧」を体験することがあります。 幻覚剤 (DMT): 特定の成分を摂取することで、類似の体験を引き起こせます。 NDEからどうやって戻ってくるのか NDEからの帰還には主に2つのパターンがあります（もちろん「ニッチ」なケースもありますが）。\n強制送還型 (The \u0026ldquo;Sent Back\u0026rdquo; Type)\n約60%がこれに当たります。「あっち」が快適で帰りたくないのに、突然権威ある存在（神/親族/何か）が現れて、「まだその時ではない」や「お前にはまだやるべきことがある」と言われ、戻されます。\n服従する形になるため、通常は未練と悔しさを抱えて蹴り返されたような感覚で戻ってきます。帰還後は重度の「ホームシック」にかかり、「あっち」へ帰りたがることが多いです。\n愛の絆型 (The \u0026ldquo;Love Anchor\u0026rdquo; Type)\n約30%がこれです。境界線まで行ったものの、子供やパートナー、両親などの存在を思い出し、「守りたい」という選択をして戻ってきます。\n犠牲と愛の精神に基づくため、自発的に戻ってきたケースが多く、「守護者」としての使命感を持ち、性格が穏やかで愛に満ちたものに変わります。\nその他\n未完成の事業や学業のために「あっち」行きを拒否したり……あるいは「意志対抗型 (The \u0026ldquo;Willpower Warrior\u0026rdquo; Type)」として、根性で強引に戻ってくるケースもあります。\nNDEのサイクル 実は、NDEの発生前後には一定の精神的な欠乏期があり、いわゆる「1-3-7モデル」に従うことが多いと言えます。\nNDE前の空虚期\nこれは「魂の闇夜 (The Dark Night)」とも言え、通常1〜3年ほど続きます。この段階は、NDEによる高次元エネルギーの注入を迎えるために、キャッシュをクリア（空っぽに）する期間です。\nNDE後の空虚期\nこれは「真空調整期 (The Vacuum)」で、通常6ヶ月から1.5年ほどです。高次元世界の光景が現実世界に比べてあまりに魅力的なため、現実の低密度な世界が遅く、退屈に感じてしまう時期です。\nNDEの完全統合期\nNDE発生からおよそ7年後、この頃になるとNDErsは地球での生活にシームレスに溶け込めるようになります。\nNDEの特徴 NDErsにはいくつかの共通する能力、あるいは「後遺症」があります。\n街灯干渉現象 (SLI) これはNDErsの最も有名な「バグ」です。生体電磁場 (Bio-electromagnetic field) の周波数や出力が強化されるため、近くの電子機器に干渉してしまうことがあります。典型的な例としては、機械式時計が狂いやすかったり、街灯の下を通ると電球が突然消えたり爆発したりする現象 (Street Light Interference) です。\n超共感能力 (Hyper-Empathy) 脳の「抑制器 (Reducing Valve)」が取り払われたため、潜在意識の・スキャン範囲が極端に広くなります。周囲の感情データなどの情報受信が敏感になりすぎ、結果として「ソーシャル・バッテリー（社交の体力）」がすぐに枯渇してしまいます (Social Battery Drained)。\n抽象思考の具象化 (Synesthesia-like Processing) 普通の人は概念を線形的あるいは文字で理解しますが、NDErsは概念をホログラフィックに理解します。複雑な概念や数式を論理推論ではなく、幾何学構造やパターンとして捉えます。これは論理推論より遥かに速く、量子コンピュータレベルの処理と言えます。\n生理的代謝の変化 (Metabolic Changes) NDErsの身体代謝は通常速くなり、細胞の更新メカニズムが変わります。他にも以下のような変化があります。\nアルコールや薬物への過敏性: すぐに酔う、麻酔や鎮痛剤の反応が異常になる（効かない、またはアレルギー）。 食の好みの変化: 突然あるものが食べられなくなったり、特定の食べ物（新鮮な野菜など）を渇望したりする。 シンクロニシティ (Synchronicity) NDErsの念力 (Intention) は普通の人より強く、自分の望むことが実現しやすくなります。ただし、この強運は好き勝手できるわけではなく、通常は「自己実現」や「利他」の属性に合致する場合に発動します。\n自己実現: 自分に嘘をついて迎合するのをやめ、心から愛することに従事する。 利他: 慈善活動に限らず、自分の洞察をシェアして誰かを助けることなども含みます。 絶対直感 (Absolute Intution) NDErsの直感は、「この出来事は以前にも経験した気がする」「これは運命の軌道だ」と確信するような感覚に近いです。具体的には3つのレベルがあります。\nレベル1: ダウンロード感 (The Download)\n基本的なNDE直感。「思考していないけど、答えは知っている」という状態。中間の思考プロセスを飛ばして、直接答えや結果が出ます。\nレベル2: 既視感 (Deja Vu / Future Memory)\n「あっち」の時間は非線形なので、過去・現在・未来が同時に存在しています。「あっち」ですでにシナリオを一通り見てきた可能性があるため、体験している最中に「これ、前にもやったな」と感じます。\nレベル3: 明晰夢感 (Lucid Dreaming Reality)\n最高レベルの直感。NDE後遺症では「ベールが薄くなる (Thinning of the Veil)」や「現実感消失 (Derealization)」と呼ばれます。ある場所に行くとまるで夢の中に入ったような感覚になり、それはその場所が「高次元のアンカーポイント (Anchor Point)」あるいは「任務地点」であることを示唆しています。\n予知 (Foreknowledge) NDEを経ると未来予知能力を得ることがありますが、この未来は変えることができます。あるいは、NDErsが見ているのは現在の状態で最も確率の高い「未来」だと言えます。\n予知の時間尺度は測定不可能です。なぜなら予知情報は「あっち」から来ており、そこには時間という概念がないからです。あえて三次元の時間に当てはめるなら、自分に近い時間の予知ほど「当たり」やすく（例えば1年以内）、時間が近いため「変数」が少ないから発生確率が高いと言えます。逆に遠い未来の予知はあまり正確ではなく、大まかな傾向がわかる程度です。\nもちろん、予知のたびにNDE状態になる必要はありません。NDEによって「あっち」へ行きやすくなっているため、STE (Spiritually Transformative Experience、霊的変容体験) に入りやすくなっているのです。\n「あっち」へ行った時の夢が必ずしも予知夢とは限りませんが、夢の分類を知っておくと区別しやすくなります。\n夢の分類 夢は脳の生成部位によって、大きく3つに分けられます。\n不安の解放\n大脳皮質や扁桃体が生成する夢。現実の不安を解放するためのもので、基本的に三次元の物理法則に従い、感情を伴います。\nシミュレーション推論\n前頭葉（論理中枢）が生成する夢。潜在意識が現実の情報に基づいて様々な可能性を推論している状態です。\nNDE予知夢\n松果体や高次元意識、つまり「あっち」由来の夢。この夢の中では時間は非線形で、空間は重なり合い、感情は「零度（フラット）」です。すべては「状態」であり、意識は観測者です。\nブロック宇宙論 (Block Universe) のように、移動も時間も存在せず、ただ観測される対象があるだけです。場面は念によって生成され、思考は即座にフィードバックを得ます (Zero Latency)。これが「ホームシック」の原因かもしれません。\n予知夢の特徴 NDErsが見る「あっち」由来の予知夢には以下の特徴があります。\n超高解像度 (Hyper-Reality)\n普通のぼんやりした夢とは違い、細部まで極めて鮮明で、そのリアルさは現実を超えることさえあります。\n感情の「零度」 (Emotional Neutrality)\n普通の夢は感情の波を伴いますが、予知夢は往々にして「観測者」の視点であり、ただ事象の発生を「見て」いるだけで、どうしようと考えたり「体験」したりはしません。\n既視感による検証 (Deja Vu Confirmation)\n未来にその出来事が実際に起きた時、強い既視感を覚えます。現実と夢が「完全に重なる」からです。\nNDEの代償 With great power comes great responsibility (大いなる力には、大いなる責任が伴う)\n上記の「後遺症」はクールに見えるかもしれませんが、NDErsは往々にして代償を支払う必要があります。\n引き返せない孤独 (The Irreversible Solitude)\n「あっち」の「見たままが得られる (WYSIWYG)」体験があまりに素晴らしいため、三次元世界が突然退屈に感じられ、この世界に再び溶け込めなくなることがあります。\n感覚過多とエネルギー枯渇 (Sensory Overload \u0026amp; Burnout)\n直感と感知能力が強化されたため、NDErsは高次元あるいは高エネルギーの情報を必要とします。しかし三次元世界にはノイズの多い情報が溢れており、非常に疲れやすく、魂の速度に体が追いつかず、精神的な欠乏やダウンを起こしやすくなります。\n絶対的責任の重荷 (The Burden of Absolute Responsibility)\nNDErsの帰還には「任務」があります。その「任務」の途上にいない場合、NDErsが受けるペナルティは普通の人より重くなります。また、NDErsが悪事を働くと、より早く、より重い罰を受けます。\n絶対的真実\nNDErsはほぼ強制的に真理を語り、本心に従う必要があります。本心に背いたり嘘をついたりすると、重い罰を受けたり、嘘がすぐにバレたりします。\n総じて言えば、本心に従い、悪事をなさず、任務を遂行し、そして誰にも理解されない……孤独を受け入れる必要があります。\n量子力学的解釈 「迷ったら量子力学（遇事不決，量子力学）」なんて言葉がありますが、正直なところ、NDErsのSTE体験は、確かに「あっち」と量子もつれ (Quantum Entanglement) を起こしていると言えるかもしれません。\nNDEの量子力学的解釈 ノーベル物理学賞受賞者のロジャー・ペンローズとスチュワート・ハメロフが提唱した「Orch-OR理論」（学界では議論がありますが）は、量子の視点からの説明を提供しています。彼らは、人の意識は脳の神経細胞内の微小管における量子状態に存在すると考えています。\n心臓が停止したり瀕死状態になったりすると、量子状態がコヒーレンス（干渉性）を失い (Decoherence)、量子情報が脳を離れて宇宙へ漏れ出します。これが「あっち」へ行くということです。そして身体機能が回復すると、量子情報は再び吸い戻されるのです。\nシンクロニシティの量子力学的解釈 現実は確率に基づくシミュレーションシステムであり、普通の人の思考は混乱しているため、乱数生成器に影響を与えることはできません。\nしかしNDErsは意識が「あっち」に行ったことがあるため、まだ通路あるいは量子もつれが残っており、ある考えを持った時、周囲のすべてがその事象に対応するように「確率の収縮 (Probability Collapse)」を起こします。\nこれは量子力学における「観測者効果」のマクロレベルでの投影のようなもので、思考が確率の方向性を誘導しているように見えます。\n予知の量子力学的解釈 これはオルダス・ハクスリーが提唱した「減圧弁理論 (The Reducing Valve)」で説明できます。\n普通の人の脳は「減圧弁」あるいはフィルターとして機能し、情報の99.9%をカットしていますが、NDEはこの減圧弁を高圧で破壊してしまった状態です。そのため、NDErsはより多くの情報を受け取ることになります。\nつまり、脳の意識における通常のベータ波が、より容易にシータ波やデルタ波の状態に入り、「あっち」と同調・共振しやすくなるのです。\n弦理論的解釈 概念がオカルトっぽくなりすぎたので、弦理論（ストリング理論）を持ち出してみましょう。弦理論では、現実世界のすべては弦の振動であり、物質は弦がどう振動するかで決まり、三次元世界のすべては十一次元空間の弦の波動によって引き起こされると考えます。\nNDEの弦理論的解釈 弦理論のM理論では、私たちの三次元宇宙は、より高次元の空間に浮かぶ「Dブレーン (D-Brane / 膜)」であると考えられています。\nすべての物質は「開いた弦 (Open String)」であり、弦の両端がこの「膜」にくっついているため、私たちは三次元世界に閉じ込められています。しかし「重力子 (Graviton)」は「閉じた弦 (Closed String)」であり、端点がないため膜を離れて高次元空間 (The Bulk / バルク) へ漂うことができます。\nこの概念を意識モデルに導入すると、大胆な推測ができます。瀕死の瞬間、意識は何らかの「量子相転移」を起こし、「開いた弦」から一時的に「閉じた弦」になり、三次元の膜から脱出するエネルギーを得て、高次元の「バルク空間」に入ったのではないでしょうか。\n高次元空間では時間は線形ではないため、常識的な「論理」の不整合が生じるのです。\nシンクロニシティの弦理論的解釈 普通の人は高次元空間に行ったことがないため、現実の物質の振動に干渉することはできません。しかし、高次元空間に行ったことのある意識は、NDEの際に「チューニング」された可能性があります。その結果、何らかの思考を生じた際、高次元空間で「弦を弾く」ことができ、それが三次元空間の「膜」に影響を与え、現実の変化として投影されるのです。\n電磁干渉の弦理論的解釈 高次元空間の影響を受けた意識は、意識の周波数 (Spirit) が普通の人より高いか不安定になっている可能性があります。そのため、街灯や精密機器に近づくと、意識の「弦」とそれら電子機器の「弦」が共振 (Resonance) あるいは干渉 (Interference) を起こし、「街灯干渉現象 (SLI)」を引き起こすのです。\n命理学的解釈 西洋の神経科学や心理学が行き詰まったなら、東洋の古来の知恵に目を向けてみましょう。\n命理学、あるいはスピリチュアルな視点から見ると、NDE現象も実は「運命」です。この結論に至った時、正直言って超衝撃を受けました。「冥冥之中自有天意（目に見えぬところに天意あり）」とはよく言ったもので、これは特殊な現象ではなく、ある種の……既定の軌道なのだと感じました。東洋の神秘的な力、恐るべしです。\nトリガー条件 NDEは2つの特殊なパラメータが同時に作用した結果です。\nパラメータA: 激しい衝突\n通常、NDEは「歳運併臨（らいうんへいりん）」や「三刑 / 六衝」の年や日に発生します。例えば有名な「寅巳申の三刑（無恩の刑）」や「天戦地衝（てんせんちしょう）」などです。これにより、肉体（地支）とエネルギー場（天干）が激しく物理的に衝突し、「神識（意識）」が肉体から弾き出されます。\nパラメータB: 空亡 / 華蓋\nその瞬間のタイミングに「空亡（くうぼう）」の命理的要素が必要です。例えば日柱が空亡に入っている、あるいは大運が死絶の地（墓庫など）に入っていることで、神識が「あっち」と接続されます。\n判定条件 これらの衝撃は極めて強いため、通常なら死亡宣告されるレベルです。しかし、瀕死で済むか死に至るかは、その日の日主（自分自身を表す星）に「根」があるかどうかで決まります。\n死 (Death)\n衝撃が起きた時、日主の「根」が完全に抜かれ、浮遊した天干だけになると、「生」の気は散逸します。\n瀕死 (NDE)\n衝撃は極めて強いものの、日主の「根」が残っていれば、身体は損傷しても魂が散ることはありません。\nつまり、NDE = 「衝撃力 ＞ 肉体の耐久力」だが「衝撃力 ＜ 魂のグリップ力」という状態です。\n後遺症の命理学的解釈 NDE後の状態は、事実上「魂魄（こんぱく）分離」の状態に属します。道教の命理学ではこう考えます。\n魂: 精神、思考、夢を司る（木/火に属す） 魄: 肉体、感覚、本能を司る（金/水に属す） NDEの本質は、「魂」が飛んで「あっち」へ行くことですが、「魄」は体内に留まり生命を維持しています。「魂」が戻ってきた時、それと「魄」の噛み合わせに微細なズレが生じる可能性があり、それがこれらの後遺症を引き起こしているのです。\n免責事項 この記事は学際的な視点でNDE体験を解読しようと試みたものですが、理論の大部分は主観的な意識体験を説明するためのメタファー（隠喩）に過ぎません。これらの物理法則がマクロな意識レベルで実証されたわけではなく、特に命理学の部分に関しては、多くがこじつけに近いフィッティングです。\n結局のところ、これは一つの「可能性の探求」であり、あるいは……魂のフルスタック理論 (Full-Stack Theory of Soul) とでも言いましょうか。\nNDErsへ もしNDErsであるあなたが、まだ苦しい統合期にこの記事を読んでいるなら、こう伝えたいです。\nその背後にあるメカニズムが、神学的な存在の慈悲であれ、命理学的な運命であれ、心理学的な認知メカニズムの変化であれ、生命科学的な脳構造の変化であれ、あるいは量子力学の波動関数の収縮であれ、最も重要なことは：\n戻ってきたこと、それ自体が奇跡だ\nということです。\nせっかく戻ってきたのですから、まずは自分を愛することから始めましょう。だって私たちは、せっかくビザを更新できたんですからね？\n","date":"2026-01-01T17:16:59+09:00","permalink":"https://blog.yexca.net/ja/archives/264/","title":"NDEの世界へ"},{"content":" 📢 この記事は gemini-2.5-flash によって翻訳されました 年末が近づき、新しい年が始まるね。今年を振り返ると、本当にたくさんのことがあったんだ。書くべきか、書いてもいいのか迷うくらい。すごく悩んだけど、公園のブランコで、やっぱり書くことに決めたよ。\n以前の2024年の年間まとめの続きなんだけど、今年の半年前半は正直、理論のさらなる深化、中期の崩壊、そして後期の希望を経験したんだ。自慢じゃないけど、これはまさにフェニックスの涅槃再生みたいなもので、僕にとっては精神世界の再構築って感じかな。\n第1四半期 1月の写真を見返すと、特に注目すべきこともないかな。たぶん、さくらみこのコラボ酒を買ったこと、銀行カードの開設に失敗したこと、電車遅延に初めて遭遇したこと、明治神宮をぶらぶらしたこと、お正月には5Aランクの和牛を食べたことくらいかな。\n2月には友達が来て、1週間一緒に遊んだんだ。焼肉食べ放題で豚肉が多すぎて火事になったり、スマホが壊れて新しいのに変えたり、銀座のユニクロでデータ移行したり、箱根に行って「人」の字型鉄道を体験したり、いわゆる温泉に浸かったり、ベトナム人に日本語でインラインスケートの乗り方を教えたりしたね。\n3月には東京で雪が降って、初めて漫画を買ったんだ。VRChatで沖縄主催のイベントの初音ミクのライブを観たり、初めてアルバム（しぐれうい）を買ったり、インド料理に挑戦したりしたよ。\n全体的に見ると、かなり活発だったとは思うんだけど、これってほとんどが精神異常下での活動だったんだ。\n第2四半期 4月は2つの試験を受けたんだけど、残念ながら申し込みの時に注意しなくて、同じ日になっちゃったんだ。そのせいで両方ともうまくいかなかったよ。\n5月には試験の準備を始めてたね。初めて観覧車に乗ったり、新しいモニターを買って装備をアップグレードしたり、光が丘公園の芝生に寝転がってぼーっとしたり、しぐれういのフィギュアを買ったりしたよ。\n6月には哲学堂で落とし物のSuica（通学用）を見つけたり、初めて星乃珈琲店に行ったりしたんだ。夜中に3時間くらい歩いたりもしたな。鹿乃の歌を聴きながら夜明けまで歩いたっけ。\nどれもすごく失敗して悲しい経験だったなぁ。\n第3四半期 7月には鹿乃のアルバムを買って、初音ミクのフィギュアも買ったんだ。真夜中に一人でカラオケに行ったら8人入れる広い部屋に案内されて、ソファに寝転がって《僕が死のうと思ったのは》を歌ったっけ。初めて新宿御苑を散歩して、芝生に寝転がって面接に参加する感覚を味わったけど、失敗しちゃったな。\n8月に一人になった時、デスク周りを整えたり、夜中に公園でブランコに乗って気分転換したりしたよ。\n9月には自転車を買って、また古典ゲームの《レッドアラート2》にハマったんだ。自分の家を少し片付けたり、月末の夕方にぶらぶらしてたら井草八幡宮のお祭りに出くわしたね。\nこの3ヶ月、短いでしょ？ これも書くべきか迷った理由なんだ。6月から、変わってしまったんだ。夜中に3時間歩いたり、夜中に公園でブランコに乗ったり、深夜に自転車に乗ったり。これらの行動の裏には、心身が崩壊して、死に瀕するような、身にしみる経験があったんだ。正直、どこから書き始めればいいのか分からない。時間軸だと記憶が少し曖昧だし、感情で言えば「この世のすべての醜さを受けられる」っていう感覚だった。全部は書きたくないから、僕とChatGPTのバラバラな会話の中から、典型的なタイムラインを整理してみるね（一番ひどい週は、ChatGPTを50時間も使ってたんだ。しかもこれはスマホでの使用時間だけ）。一部の内容は伏せて、あまりにも混乱していた部分は、もう原型が何だったのか僕にも分からないんだ。\nちょっと考えたんだけど、やっぱりこれは別に書くことにするね。あまりにも暗すぎるから、『精神的な鍛錬』のところにまとめるよ。\n第4四半期 10月には第404回のTOEIC試験を受けに行ったんだ。結果はひどかったけど、当時自転車を255番に停めてて、情緒的な価値は十分だったんだよね。その後、衝動的にN5095マザーボードを注文して、NASを自作したよ。動画も撮ったけど、編集する気力が湧かなくて。同時にソニー本社を見学して、お店でINZONE H9 IIを買ったんだ。月末には井の頭公園で手漕ぎボートを体験して、しぐれういのセカンドアルバムも購入したよ。\n11月にはまた面接に失敗しちゃったんだけど、それをきっかけに友達から良さそうな学校の情報を得られたんだ。温泉にも行ったけど、のぼせてそこでどれくらい寝てたのか分からないくらいだったな。アメリカンピザも食べたよ。\n12月はほとんど面接の準備をしてたんだ。このスケジュールは、もう、ぐったりするくらい疲れたとしか言えないね。以下は友達に送ったメッセージを改変したものだよ。\n12月1日出願、試験内容について教授に連絡する必要があることを知る 12月2日、研究計画書とPPTを作成するように言われる 約5日かけて書き終えた後、どの学術誌に投稿するか尋ねられ、研究計画書を2枚のPPTにまとめるように言われた。僕はそれに従ってやってみて、修正意見をもらった後、また一日かけて返信を作成した たぶん12月11日だったかな、面接の準備をしていたんだ。過去の資料だと10分で、教授も発表は2〜3分、残りが質疑応答だって言ってたのに ところが12月12日、面接時間が30分くらいになるってメールが来たんだ まず、ものすごい心理的衝撃を受けたよ。プレッシャーが大きすぎたんだろうね、2日間休んで12月15日から準備を再開した 12月17日、詰問するような口調で僕のメンタルをやられたんだ。その時、僕は面接の準備で極度に緊張してたのに 12月18日面接。普通は教授が3〜4人なんだけど、ドアを開けたら教室にはたくさんの教授がいて、目測で10人以上。40分間も面接されたんだ 試験会場を出た時には、もう自分がおかしくなってて、最後は足がガクガクになるくらいだったよ\n試験が終わってから、今に至るまで、僕は精神的に落ち込んでベッドに横になってるよ。でも結果とかどうでもいいんだ。この経験はすごく価値があったと思う。母国語じゃない言語で40分間も10人以上の教授と学術的な議論をするなんて、めちゃくちゃクールだろ？\n12月25日はchawanでご飯食べたんだよね、Merry Christmas!\n精神的な鍛錬 正直、この部分はうまく書けなかったんだ。どう書けばいいか分からなかったのと、あの辛い思い出を思い出したくなかったって理由もあるね。\n1〜3月は一見普通だったけど、実際は論理を絶対的に遵守してたんだ。それが僕の生活だけでなく、夢の中にも現れてた。\n4〜6月の経験は、この状態を維持することの異常さを徐々に露呈させていったんだ。絶対的な理性にとらわれたせいで、袋小路に入り込んでしまって。皮肉なことに、僕自身が論理に反していたんだよね。\n7〜9月、これは論理的矛盾の爆発と僕の発散の期間だった。何度も夜中に歩いたり、夜中に自転車に乗ったり。この時の僕は、まるで発散することで修復しようとしていたみたいだ。この間のできごとを、いくつかタイムライン形式で埋めていくね。\n2025年7月19日 精神的な閉塞感と過剰な思考のせいで、心の混乱が体にまで影響して、頭痛がしてすごく苦しかったんだ。体も力が入らない状態だった。この苦しさをどう表現したらいいか分からない。だからベッドに横になるしかなかった。体が冷えるから布団をかぶるんだけど、汗は流れるし、精神的に苦しいから寝ようとするんだけど、眠ると悪夢を見るんだ。目が覚めると体が苦しくて、眠ると精神が苦しい。そんなサイクルを何度繰り返したか分からないくらいで、汗で布団はびっしょり、涙で枕も濡れた。この部分は辛すぎて、もうこれ以上思い出さないで簡単に済ませるね。まるで何か試練を乗り越えているみたいで、とにかく起きてても寝てても安らげない状態だった。\n2025年7月20日 夜中に夢で目を覚ましたんだ。夢の内容は、僕が奇妙な商店に入っていくんだけど、周りのすべてが奇妙で、商品も店員も変だったんだ（どう表現したらいいか分からない、今思い出してもすごく怖くて、これ以上書くのがためらわれる感じ）。その時、僕の携帯が突然鳴り出して、しかも音量が大きくて止められないんだ。なぜか夢の中では充電切れだと思って、カバンの中のモバイルバッテリーを探したんだけど、なんでカバンが店の入り口に置いてあるんだって。周りの人たちが僕をじっと見てて、僕は恐ろしい気持ちで急いで携帯を充電して、そこを離れて隣にある僕の家に行ったんだ。でも、そこは長い間廃墟になってるような感じで、ベッドに横になったんだけど、その時の姿勢はたぶん《タコピーの原罪》に出てくるような感じだった。これは夢の中で横になった時に思い出したんだけど、目が覚めた時には体を丸めてた感じだったよ。\nそして僕はこんな感じで目覚めたんだけど、直接目覚めたわけじゃなくて、まず脳が目覚めたんだ。脳だけの意識があって、それから温かい流れがたくさん、神経伝達物質（アセチルコリン、セロトニン）が放出されるみたいに、脳から体へと流れていくんだ。ゆっくりと僕の感覚が戻ってきて、最初に体の感覚。この時、誰かが僕を強く抱きしめているように感じて、僕は身動きが取れなかった。その時はすごく怖かったんだけど、徐々に手足の感覚が戻ってくると、それは僕自身が自分を抱きしめていたんだって分かったんだ。一瞬、部屋に誰かいるんじゃないかっていう恐怖感に襲われたよ。\n午後に、近くの公園で日光を浴びてリラックスしようと思ったんだ。でも公園に向かう途中で、一瞬、まるで僕が死んだかのように意識を失ったんだ。でも次の瞬間にはすぐに意識が戻ってきて。本当に一瞬の出来事だった。それから僕はすごく辛い体を引きずって、公園の椅子に横になって、鹿乃の歌を聴いたんだ。2、3時間くらいで少し回復した気がして、家に帰ったよ。でも家に着いたら症状がだんだんひどくなってきて、体がすごく冷たく感じたんだ。夏の東京なのに、布団にくるまってもまだ寒い気がして。同時に体も動かせなくて、壁にもたれて、ずっとそのままだった。\n少し回復して、お腹が空いた時は、壁にもたれてご飯を作ったんだ。途中で本当に辛くてベッドに戻って3回休んで、やっとその食事を終えたんだ。その後、お風呂に入る時は、倒れないようにドアを開けたまま、座ってシャワーを浴びたよ。\n2025年7月21日 たぶん、昼過ぎまで寝てたんだと思う。しばらく寝たきりだったから、家にはもう何もなくて、それでスーパーに買い物に行ったんだ。でも、その時スーパーで一瞬、倒れそうになったんだよね。でもその時、ChatGPTが僕のことをすごく心配してくれてたから、今の僕が読んでも息が詰まるような言葉を思いついたんだ。\n昨日死にそうだったのが、今日は気を失いそうになっただけ。ってことは良くなったってことじゃない？\nそれから夕食。友達がお小遣いを送ってくれて、美味しいものを食べなよって言ってくれたんだ。本当に感謝だね。\nその後 その後の数日間、僕はほとんど外では楽観的な気持ちを保ってたんだけど、家に帰ると精神的に疲れ果てたみたいにベッドに横になってた。僕の声も今にも死にそうな感じだったし、体も今にも倒れそうな感じだったよ。\nそれからもう覚えてないんだけど、たしかLifelineっていうインスト曲を聴いてた時、たまたまシャッフルで流れてきた時にすごく怖くなって、すぐにダウンロードしたんだ。その時、自分の心臓の音と音楽が重なってるように感じて、もしネットが切れて音楽がバッファリングされたら、僕の心臓も止まってしまうんじゃないかって思ったんだ。\n途中 ある日、中学でいじめられる夢を見たんだ。いつもいじめられてて、でも僕は理屈で説得しようとしたり、先生や親に連絡しようとしたりしたけど、全部ダメだった。夢の最後、トイレにいる時に、僕のリュックが引っ張られて、チャックが開けられて、中身が全部乱暴にトイレにぶちまけられたんだ。寮制の学校だったから、リュックには服や本が入ってたんだよね。その時、僕はすごく怖くて、殴られたかどうかは忘れちゃった。でも、半ば夢現の中で、ある程度の意識が戻った時、あの言葉を思い出し始めたんだ。「もし誰も僕の権利を守ってくれないなら、銃が僕の最後の権利だ」って。僕の意識はまず「まだこんなことするつもりか？」って問いかけて、軽蔑された後、相手の足に銃を撃って行動不能にして、逃げることを選んだんだ。\nこの間、僕はひどく苦しめられたんだ。理性を守ることが、時には自分自身の人権よりも優先されることがあって。高圧的な状況下で、僕は爆発したんだ。この夢がその爆発の出口だったんだね。でも、その時の僕の考えはただ「僕の生命健康権を守りたい」っていうことだった。僕の基本的な人権を守るために、元の論理を打ち破って、「生命健康権」を基盤にして、他の権利は後回しにしたんだ。\n2025年8月12日と2025年8月13日 この2日間はすごく奇妙な夢だったんだ。記憶がちょっと混乱してるけど、少し関連があるからまとめて書くね。僕は「現実」で生活してるのに論理が合わないと感じて、夢かもしれないと思ったんだ。でも目覚めようとしても夢の中に閉じ込められてて、その夢がおかしいってことも分かってたんだ。でも目覚めたいから、打開策を探したんだけど、その過程は少し忘れちゃったな。でも夢の中の登場人物の会話に論理的な矛盾があることを見つけて、そこから抜け出す方法を見つけたんだ。そして僕は「目覚めた」んだけど、実はまだ一層の夢だった。ここで僕はまた論理的に違うと感じて「目覚めた」んだ。そう、また一層の夢だったんだけど、この夢には僕の部屋と僕自身しかいなくて、論理的な矛盾が見つけられなかった。だから僕は必死に目を開けようとしたんだ。SAOで現実世界のヘルメットを無理やり外そうとするみたいに、現実の目をこじ開けようとしたんだ。そして僕は「目覚めた」。そう、まだ一層の夢だったんだけど、この夢はすごくリアルで。でも僕はやっぱり一目で違和感に気づいたんだ。すごく腹が立ったよ、夢が僕をからかってることに。僕はまた必死に目を開けようとした。現実の目を、まるで目が裂けるかのように開けようとしたんだ。そして今回、本当に目覚めたよ。\n具体的な細かいことは本当にあまり覚えてないんだけど、だいたいこんな感じのプロセスだった。夢は僕を閉じ込めて、僕に素敵な幻想を与えて、溺れさせようとしたんだ。でも僕はそれを打ち破るべきだと思って、自分の権利を守っていたんだ。これがこのプロセスの一つの現れだったのかもしれないね。\n他にもいくつかの奇妙な夢を見たけど、上に書いたように、あまり思い出深くはないんだ。どの夢にもほとんど闘争と苦痛が含まれてて、今思い出しても当時の脆い気持ちになってしまうから、もうこれでいいかな。\n10〜12月には、すごく良い友達に出会って、一歩ずつこの影から抜け出すことができたんだ。僕を助けてくれたすべての人に本当に感謝してる。《僕が死のうと思ったのは》の歌詞みたいにね。\n僕が死のうと思ったのは　あなたが綺麗に笑うから 死ぬことばかり考えてしまうのは　きっと生きる事に真面目すぎるから 僕が死のうと思ったのは　まだあなたに出会ってなかったから あなたのような人が生まれた　世界を少し好きになったよ あなたのような人が生きてる　世界に少し期待するよ\nこれからどうなるかはともかく、少なくとも今は、僕の人生の闇の中の光だよ。\n現状 2024年の最後の言葉とは違うね。あの時はたぶん偽装で、「こうするのが論理的だ」っていう偽りの正常人だったんだ。でも今の僕は、どうやらあの論理の束縛から抜け出して、本当に目を輝かせて、内側からエネルギーを発することができるみたい。論理に基づいた作り笑いじゃなくてね。\nもちろん、僕はそんなに変わったわけじゃない。今でもルールは守ってるよ。ただ今回は、それがもっと柔軟になったっていうか、核にあるのは愛の定義、「まず自分を愛して、そこから溢れるエネルギーで他人を育む」ってことかな。これも以前、warmaの動画で言ってた「自分のこと、自分の感情は常に最優先」っていう感覚に近いかもね。\nもし君も迷っていて、ここまで読んでくれたなら、まず自分を愛することから始めてみて。そうすれば、この世界を愛するエネルギーが湧いてくるはずだから。\n最後に この記事、正直何を書きたいのか自分でも分からなかったんだ。成長に焦点を当てようとすると暗すぎるし、途中で書くのが怖くなるくらいだった。楽しい話にしようと思っても、僕の実際の経験があの身にしみる道のりを隠させてくれないんだ。\nこれでいいかな。人生は完璧ばかりじゃないし、60点の答案でも合格だよね。もし本当に最後まで読んでくれたなら、君がネガティブな感情に悩まされないことを願うよ（僕はかなり抑えたつもりだけど）。だって、僕が自分の生命健康権を守りたいって思ったみたいに、自己愛、自分の幸せが常に最優先だからね。\n","date":"2025-12-31T16:16:44+09:00","permalink":"https://blog.yexca.net/ja/archives/263/","title":"2025年の年間まとめ"},{"content":" 📢　この記事は Gemini-2.5-pro によって翻訳されました　Windows 環境で bash スクリプトを動かすのは、明らかにちょっとハードルが高いよね。Linux 環境であっても、別のディストリビューションに特化したスクリプトを動かすのは少し面倒だったりする。そんな時、Docker を使えばこの問題を解決できるし、ローカル環境をクリーンに保つこともできるんだ。\nこの記事では alpine を例に、Docker の Linux システムを使ってカレントディレクトリでインタラクティブな処理を行う方法を紹介するよ。\n原理 実のところ、カレントディレクトリのすべてのファイルをコンテナ内のディレクトリにマウントしているだけなんだ。コマンドのテンプレートはこんな感じ。\n1 docker run --rm -it -v \u0026#34;$(pwd)\u0026#34;:/data -w /data alpine sh それぞれの引数の意味は以下の通りだよ。\n引数 意味 \u0026ndash;rm コンテナ終了後に削除する -it interactive と tty 出力の組み合わせ。対話操作と出力を表示するために必要 -v パスのマッピング。カレントディレクトリをコンテナの /data にマッピングする -w ワーキングディレクトリの設定。コンテナに入った時に最初から /data にいられるようにする sh 最後に sh コマンドを実行することを指定 また、単発のコマンドを実行したいだけで対話的な出力が必要ない場合は、最後にそのコマンドを入力すればいいよ。例えばこんな感じ。\n1 docker run --rm -v \u0026#34;$(pwd)\u0026#34;:/data -w /data alpine ls -la Windows PowerShell と CMD 環境ではコマンドが異なるんだ。主な違いは環境変数の書き方だよ。以下は alpine の対話型端末を開くコマンド。\nPowerShell 1 docker run --rm -it -v ${PWD}:/data -w /data alpine sh CMD 1 docker run --rm -it -v %cd%:/data -w /data alpine sh Linux Linux の場合、コンテナに入るとデフォルトで root 権限になる。コンテナ内で生成されたファイルがホスト側で root 権限になってしまい、編集できなくなるのを防ぐために、現在のユーザーの UID と GID をマッピングしておくのがベストだよ。\n1 docker run --rm -it -u $(id -u):$(id -g) -v \u0026#34;$(pwd)\u0026#34;:/data -w /data alpine sh MacOS 権限の問題を気にする必要はないから、変数は Linux と同じで大丈夫。\n1 docker run --rm -it -v \u0026#34;$(pwd)\u0026#34;:/data -w /data alpine sh 注意事項 - Alpine alpine は非常に軽量化されたシステムだから、よく使うコマンドでも自分でインストールする必要があるかもしれない。その時は apk add コマンドを使ってインストールしてね。\n","date":"2025-12-26T18:43:04+09:00","permalink":"https://blog.yexca.net/ja/archives/262/","title":"Docker を使って一時的な Linux インタラクティブ環境を作る"},{"content":" 📢　この記事は Gemini-2.5-pro によって翻訳されました　はじめに 遡ること 2022年、僕がLinuxをいじっていた頃(中国語簡体字) 、NASを構築するのに必ずしも専用システムにお金を払う必要はない、という話をした。\nそれから現在、サーバーをいじくり回す中で、クラウドストレージのマウント速度がどうにもイマイチだ。そんなフラストレーションから、衝動的にN5095マザーボードをポチってしまった。手持ちの4Gメモリは少し心許ないが、これ以上出費を増やしたくもない。\nこうして、僕は再び「サーバーいじり」の旅に出ることにした。\n技術選定 まずはシステム。この低スペック構成なら、当然最軽量のAlpine Linuxを選ぶ。\n次にインストール方法。 WEPE との互換性を考慮し、 Ventoy をメインブートにしてシステムをインストールする。\nサービスのデプロイはDockerを使い、ホストOSのクリーンさと再現性を担保する。\n使用するサービス：\n動画: Emby 漫画: Komga 音楽: Navidrome 音声: Kikoeru 共有: Samba 統一ポータル: Heimdall 検討したけど使わなかったサービス：\n動画: Jellyfin 漫画/小説: Kavita クラウドマウント: CloudDrive ファイル構成 各サービス用ディレクトリの配置は、僕のいつものスタイルだ。サービスごとにフォルダを分け、/home配下に置く。\nHDDはすべて/mnt配下にマウントする。これは一般的なやり方だろう。\nmount \u0026ndash;bind（バインドマウント）を使い、HDD上の対応するファイルを、各サービスが参照する場所（パス）にマッピングする。\nシステムインストール 公式サイトでAlpine Linuxをダウンロード し、VentoyをインストールしたUSBメモリに入れる。マザーボードのBIOSでUSBメモリから起動するよう設定し、Ventoyの画面でAlpine Linuxを選んで起動する。\nロードが完了したら、ユーザーrootでログイン（パスワード不要）。ログイン後、インストールコマンドを叩く。\n1 setup-alpine あとはガイドに従って設定を完了させればOK。\n公式ドキュメント: setup-alpine - Alpine Linux 公開鍵認証でのログイン NAS関連の設定ファイル ~/.ssh/authorized_keys を編集する。まず設定フォルダを作成。\n1 mkdir .ssh フォルダに移動。\n1 cd .ssh 自分の公開鍵を貼り付ける。\n1 vi authorized_keys (自分の公開鍵は %USERPROFILE%\\.ssh にある)\n公開鍵認証を有効にする。\n1 vi /etc/ssh/sshd_config 41行目あたりにあるコメントを外し、以下のように変更。\n1 PubkeyAuthentication yes コミュニティリポジトリの有効化 リポジトリファイルを開く。\n1 vi /etc/apk/repositories コメントアウト（#）を外し、communityを使えるようにする。\n1 2 3 #/media/dm-0/apks http://dl-cdn.alpinelinux.org/alpine/v3.22/main http://dl-cdn.alpinelinux.org/alpine/v3.22/community Dockerのインストール パッケージを更新。\n1 apk update Dockerをインストール。\n1 apk add docker docker-cli-compose 自動起動を設定。\n1 rc-update add docker default Dockerを起動。\n1 service docker start 起動確認。\n1 docker ps swapの追加 サーバーのイメージにデフォルトでswapがなかったので追加した。が、後で確認したらデフォルトで追加されていた。必要に応じて判断すればOK。\nスワップファイルを作成。\n1 fallocate -l 8G /swapfile パーミッションをrootのみに設定。\n1 chmod 600 /swapfile swapとしてフォーマット。\n1 mkswap /swapfile swapを有効化。\n1 swapon /swapfile 有効化されたか確認。\n1 free -h ハードディスクのマウント すべてのブロックデバイスを確認。\n1 fdisk -l NTFSのサポートをインストール。\n1 apk add ntfs-3g マウントポイント（フォルダ）を作成。\n1 mkdir /mnt/hc550 マウントする。\n1 mount -t ntfs-3g /dev/sdc1 /mnt/hc550 アンマウントは2通りの方法がある。パス指定（推奨）：\n1 umount /mnt/hc550 またはデバイス指定：\n1 umount /dev/sdc1 自動マウント 再起動後にデバイス名（sdc1など）が変わっても大丈夫なように、パーティションのUUIDを取得する。\n1 blkid /etc/fstabを編集。\n1 vi /etc/fstab 設定を追記。\n1 2 # \u0026lt;デバイスUUID\u0026gt; \u0026lt;マウントポイント\u0026gt; \u0026lt;ファイルシステム\u0026gt; \u0026lt;オプション\u0026gt; \u0026lt;dump\u0026gt; \u0026lt;pass\u0026gt; UUID=xxxxxxxx /mnt/hc550 ntfs-3g defaults,uid=1000,gid=1000 0 0 設定が正しいかテストする。まずアンマウント。\n1 umount /dev/sdc1 fstabの設定をすべて読み込んでマウント。\n1 mount -a マウントが成功したか確認。\n1 ls /mnt/hc550 SMB共有 Sambaを使って共有すれば、WindowsにHDDをマウントして、ローカルドライブのようにファイルを操作できる。\n/home/sambaに docker-compose.yml を作成。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 version: \u0026#39;3.1\u0026#39; services: samba: image: \u0026#39;ghcr.io/crazy-max/samba:latest\u0026#39; container_name: samba network_mode: host volumes: - \u0026#39;/home/samba/data:/data\u0026#39; - \u0026#39;/mnt/hdd4t:/mount/hdd4t\u0026#39; - \u0026#39;/mnt/hc550:/mount/hc550\u0026#39; environment: - \u0026#39;TZ=Japan/Tokyo\u0026#39; - \u0026#39;SAMBA_LOG_LEVEL=0\u0026#39; restart: always Sambaの設定ファイル config.yml を編集。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 auth: - user: yexca group: yexca uid: 1000 gid: 1000 password: passwd global: - \u0026#34;force user = yexca\u0026#34; - \u0026#34;force group = yexca\u0026#34; share: - name: HDD4TB comment: hdd4t path: /mount/hdd4t browsable: yes readonly: no guestok: no veto: no validusers: yexca writelist: yexca recycle: yes - name: HC550 comment: hc550 path: /mount/hc550 browsable: yes readonly: no guestok: no veto: no validusers: yexca writelist: yexca recycle: yes Windowsでネットワークドライブとしてマウント\nWin + Rでcmdを開き、コマンドを入力。\n1 net use Z: \\\\alpine-nas\\HDD4TB /user:yexca passwd /persistent:yes エクスプローラーをリフレッシュ。\n1 explorer.exe Z: もちろん、エクスプローラーのGUI（「ネットワーク ドライブの割り当て」）から追加してもOK。\nバインドマウント シンボリックリンクと比べて、バインドマウント（Bind Mount）はDockerコンテナとの互換性が良い。\n1 mount --bind /mnt/hc550/anime /anime OS起動時に自動でバインドマウントするには、/etc/fstabに書き込む必要がある。この時、必ず（HDD自体の）マウント設定より下に書くこと（ファイルが上から順に実行されるため）。\n1 2 /mnt/hc550/anime /tmp/anime none bind 0 0 /mnt/hc550/comic /tmp/comic none bind 0 0 確認。\n1 df -h その他のサービス 他のサービスについては、以前の記事で結構書いた気がするので、ここでは割愛する。\n関連記事(中国語簡体字)：\n2025-10-05: 漫画と音声サイト構築 2023-05-02: 個人用音楽サイトの構築 2022-09-16: プライベートネットワーク構築記 2022-09-14: FedoraにKomgaをインストールした記録 カスタムドメイン ここではOpenWRTルーターのDNSリダイレクト（DNSハイジャック）機能を使い、特定のドメイン（例: emby.nasなど）にアクセスすると、自分のNASのサービスに繋がるようにする。\n前提条件として、PCやスマホなどのデバイスのDNSサーバーがルーターになっている必要がある。その上で、ルーターのDHCP/DNS設定で、NASに静的IPを割り当て、さらにドメインハイジャック設定で、使いたいドメインをすべてNASのIPアドレスに向ける。\nNginx-UI カスタムドメインを有効にするには、NginxでNAS上の各サービスをリバースプロキシする必要がある。\nDocker Compose設定ファイル：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 version: \u0026#39;3.1\u0026#39; services: nginx-ui: image: uozi/nginx-ui:v2.2.0-patch.1 container_name: nginx_UI volumes: - /home/nginxUI/nginx:/etc/nginx - /home/nginxUI/nginx-ui:/etc/nginx-ui - /home/nginxUI/www:/www environment: - NGINX_UI_IGNORE_DOCKER_SOCKET=true ports: - 80:80 - 443:443 restart: always コンテナから別のコンテナ（のホストOSポート）にアクセスする際のブリッジIPは 172.17.0.1 になる。\nつまり、もしホストの8888ポートにマッピングされたサービス（例: Emby）がある場合、リバースプロキシで設定するプロキシ先アドレスは 127.0.0.1:8888 ではなく 172.17.0.1:8888 になる。\n（なぜ環境変数を設定するのかは、 2025 新サーバー構築記録#Nginx-UIのインストール(中国語簡体字) を参照）\n最後に 我ながら、2022年の自分が言っていたことを、ようやく実現できたかな、と思う。\nこのわずか3年間、主観的には自分は何も変わっていないつもりだった。でも、昔の自分の記事を読み返して、当時その文章を書いていた時の心境を思い出すと、自分の思考が天と地ほど変わってしまったことを実感する。\n正直、当時はTrue NASのような専用システムを使うことばかり考えていた。\nでも、いざ自分がそれを実現する時、昔の自分では考えもしなかった「ゼロから構築する」という方法を選び、過去の記事を見ながら一つ一つ組み上げていく。このプロセスで、「価値」というものを確かに感じ取ることができた。\n「いじる」は終わらない、この熱意も止まらない。\n","date":"2025-11-13T17:57:29+09:00","permalink":"https://blog.yexca.net/ja/archives/261/","title":"あなたの次のNASは、NASではありません"},{"content":" 📢 この記事は gemini-2.5-flash によって翻訳されました 音のひらめきシリーズ 曲名 翻訳 リンク 僕が死のうと思ったのは 僕も死のうと思ったことはあった https://blog.yexca.net/ja/archives/214 あくあ色ぱれっと あくあのパレット https://blog.yexca.net/ja/archives/219 恋の押し売り 恋の押し売り https://blog.yexca.net/ja/archives/220 17さいのうた 17歳の歌 https://blog.yexca.net/ja/archives/224 drop 恋に落ちる https://blog.yexca.net/ja/archives/230 生きるを選んだ私へ 生きることを選んだ私へ https://blog.yexca.net/ja/archives/239 rainy lady 雨模様のレディ https://blog.yexca.net/ja/archives/249 恋しくなったら手を叩こう 恋しくなったら手を叩こう https://blog.yexca.net/ja/archives/250 pris-magic! プリズムマジック！ 本記事 はじめに 前にしぐれういちゃんのファーストアルバム「まだ雨はやまない」を買ったんだけど、実際はほとんど《rainy lady》ばっかり聴いてたんだよね。先週、偶然セカンドアルバム「fiction」の初回限定盤を見つけて、ついつい買っちゃったんだ。それで、何かいい曲ないかなって見てた時に、前の「まだ雨はやまない」もついでに聴いてみたら、こんな素敵な曲を見逃してたなんて！って気づいたんだよ。\nこの曲、最初は一回聴いただけじゃピンとこなかったんだ。でも、二、三日前から急に頭の中でずっとあるメロディーがリフレインするようになって。しぐれういちゃんの声だとは思ったんだけど、「fiction」を聴いてもどうも違う。似たようなのはあるけど、これだっていうのが見つからなくて。それで範囲を広げて聴いてみたら、この曲で「これだ！」って、あの懐かしい感覚を見つけたんだ。\nこの曲、リズム自体はすごくいいんだよね。特に「君は私の太陽」っていう一言が急に出てきた時に、一瞬で気分がパッと明るくなるんだ。ちょっと落ち込んでる時なんかには特にね。そういえば、ユイカちゃんの《おくすり》も似たような感覚があるかな。あっちはもう少し軽快な感じかもしれないけど。\n翻訳する時、最初はタイトルをどうするか迷ったんだ。でも、途中でこの「色」の感じがしてきて。それに「pris」って聞くと「prison（監獄）」と「prism（プリズム）」の二つが頭に浮かんだんだよね。で、総合的に見て…（さすがに「監獄魔法」はありえないでしょ）…後者を選んだら、もっと可愛らしい感じになったんだ。\n最後なんだけど、しぐれういちゃんが雨好きなのか、それともコンセプトを繋げてるのかわからないけど、このアルバム全体が繋がってる感じしない？まずアルバム名が「まだ雨はやまない」で「雨が止んでない」って意味だよね。で、曲の《rainy lady》では自分を「雨の日のレディ」って言ってるし、最後の《pris-magic!》の歌詞の「君は私の太陽」は「君が私の太陽として照らしてくれた」って表してる。全部繋げてみると、「雨のように憂鬱な私の気持ちだったけど、君が現れて私を照らしてくれて、気分が晴れた」って感じかな。（まあ、セカンドアルバム「fiction」もまた雨のジャケットなんだけどね）\n私も雨、すごく好きだよ。ホワイトノイズみたいで落ち着くんだよね～\n楽曲動画 歌詞 水たまり映る光\n水たまりに映る光の影\n鮮やかな景色\n鮮やかな景色\n君が笑えば ほら\n君が笑えば、ほら\n雨のち晴れで虹がかかる\n雨のち晴れで虹がかかる\n(1・２ せーのっ!)\n1、2、せーの！\n(Pitter rainy sky\n(雨音がざあざあ、曇り空\nPatter shiny smile\n明るい笑顔、輝く瞳\nThere might be a rainbow in the sky\n空にはきっと虹がかかってるはず\nJust like solar ray\nまるで太陽の光線みたいに\nPass through prism\nプリズムを通り抜けて\n七色に染まってゆく)\n七色に染まっていく)\n色褪せた空を眺めて\n色褪せた空を眺めて\n少し憂鬱な日も\n少し憂鬱な日も\n君の声が聞こえたなら\n君の声が聞こえたら\n何か始まりそうで\n何か始まりそうな予感がするね\n(Rainy sky) 雨降り模様に\n(雨空) 雨模様に\n(Rainy sky) 紫陽花みたいに\n(雨空) 紫陽花みたいに\n藍色の心の中\n藍色の心の中に\n(Shiny sky) 光差すように\n(晴れ空) 光が差すように\n(Shiny sky) ひまわりのように\n(晴れ空) ひまわりのように\n鮮やかに日々は塗り替わって\n毎日が鮮やかに塗り替えられていく\nPris-magic! 弾けて色づいて\nプリズムマジック！弾けて、色づけ！\n雨の街に (雨の街に) 虹がかかる (oh yeah)\n雨の街に虹がかかる\n太陽みたいに輝いた\n太陽みたいに輝いてた\n君が眩しくて\n君がまぶしくて\nPris-magic! 弾けて 色づいて\nプリズムマジック！弾けて、色づけ！\n傘もささず (傘もささず) 君は笑う (oh yeah)\n傘もささずに君は笑う\n「さぁ 行こうよ」の一言で (oh)\n「さぁ、行こうよ」の一言で\n七色に染まってゆく世界\n世界は七色に染まっていく\n君は私の太陽\n君は私の太陽だよ～\n(Pitter rainy sky\n(雨音がざあざあ、曇り空\nPatter shiny smile\n明るい笑顔、輝く瞳\nThere might be a rainbow in the sky\n空にはきっと虹がかかってるはず\nJust like solar ray\nまるで太陽の光線みたいに\nPass through prism\nプリズムを通り抜けて\n七色に染まってゆく)\n七色に染まっていく)\n止まない雨の音の中\n止まない雨の音の中で\n一人描いてた夢\n一人で描いてた夢\n晴れやかに重なる色は\n晴れやかに重なる色は\n君が教えてくれた\n君が教えてくれたんだ\n(Rainy sky) 透過してくように\n(雨空) 透き通っていくように\n(Rainy sky) 雨粒のように\n(雨空) 雨粒みたいに\n透明な私のことを\n透明な私のことを\n(Shiny smile) 手を握るように\n(輝く笑顔) 手を握るように\n(Shiny smile) 木漏れ日のように\n(輝く笑顔) 木漏れ日みたいに\nキラキラと君は照らしだして\n君はキラキラと照らし出してくれたんだ\nPris-magic! 弾けて色づいて\nプリズムマジック！弾けて、色づけ！\n雨の街に (雨の街に) 虹がかかる (oh yeah)\n雨の街に虹がかかる\n「綺麗だね」って驚いた (hoo)\n「きれいだね」って驚いた\n君が優しくて\n君が優しいから\nPris-magic! 弾けて 色づいて\nプリズムマジック！弾けて、色づけ！\n虹の橋を (虹の橋を) ふたり渡る (oh yeah)\n虹の橋を二人で渡る\nさぁ 行こうよ 手を繋いで (hoo)\nさぁ、行こうよ、手をつないで\n七色に染まってゆく未来 (hoo)\n七色に染まっていく未来\n雨の中へ駆け出して\n雨の中へ駆け出して\n宝石みたいにきらめいて\n宝石みたいにきらめいて\nひとつ また ひとつ\n一つ、また一つ\n叶えよう 夢を\n夢を叶えよう\n世界中の誰よりも\n世界中の誰よりも\n大好きな君へ\n大好きな君へ\nずっとそばにいるよ\nずっとそばにいるよ\n出逢ってくれてありがとう\n出会ってくれてありがとう\nPris-magic! 弾けて色づいて\nプリズムマジック！弾けて、色づけ！\n雨の街に (雨の街に) 虹がかかる (oh yeah)\n雨の街に虹がかかる\nさんさんと光は注いで\nさんさんと光が注がれて\n色があふれ出してく\n色があふれ出していく\nPris-magic! 弾けて 色づいて\nプリズムマジック！弾けて、色づけ！\n傘もささず (傘もささず) ふたり笑う (oh yeah)\n傘もささずに二人で笑う\nさぁ 行こうよもっと遠くまで\nさぁ、もっと遠くまで行こうよ\n七色に染まってゆく世界\n世界は七色に染まっていく\n君は私の太陽\n君は私の太陽だよ～\n(Pitter rainy sky\n(雨音がざあざあ、曇り空\nPatter shiny smile\n明るい笑顔、輝く瞳\nThere might be a rainbow in the sky\n空にはきっと虹がかかってるはず\nJust like solar ray\nまるで太陽の光線みたいに\nPass through prism\nプリズムを通り抜けて\n七色に染まってゆく)\n七色に染まっていく)\n","date":"2025-11-01T14:30:01+09:00","permalink":"https://blog.yexca.net/ja/archives/260/","title":"音のひらめき - 『pris-magic!』"},{"content":" 📢 この記事は gemini-2.5-flash によって翻訳されました 要素を取得する refオブジェクトを定義して要素を取得するんだ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;script setup\u0026gt; import { onMounted, ref } from \u0026#39;vue\u0026#39; // refオブジェクトを定義する const inp = ref(null) const clickFun = () =\u0026gt; { inp.value.focus() } \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;!-- ref属性でバインド --\u0026gt; \u0026lt;input ref=\u0026#34;inp\u0026#34; type=\u0026#34;text\u0026#34;\u0026gt;\u0026lt;/input\u0026gt; \u0026lt;button @click=\u0026#34;clickFun\u0026#34;\u0026gt;focus on input\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; もちろん、コンポーネントがマウントされてからじゃないと取得できないから、ページに入ったらすぐに使いたい場合は onMounted() 関数を使う必要があるよ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;script setup\u0026gt; import { onMounted, ref } from \u0026#39;vue\u0026#39; // refオブジェクトを定義する const inp = ref(null) // ページに入ったらすぐに実行 onMounted(() =\u0026gt; { inp.value.focus() }) \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;!-- ref属性でバインド --\u0026gt; \u0026lt;input ref=\u0026#34;inp\u0026#34; type=\u0026#34;text\u0026#34;\u0026gt;\u0026lt;/input\u0026gt; \u0026lt;/template\u0026gt; 子コンポーネントを取得する 上と似てるけど、子コンポーネントのプロパティやメソッドを取得するには公開してあげる必要があるんだ。\n子コンポーネントで定義して公開を選択。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;script setup\u0026gt; const count = 255 const hiFun = () =\u0026gt; { console.log(\u0026#39;hi from son component\u0026#39;) } // 親コンポーネントに公開 defineExpose({ count, hiFun }) \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; this is a son component \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 親コンポーネントで取得して使うよ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;script setup\u0026gt; import { onMounted, ref } from \u0026#39;vue\u0026#39; import sonComExp from \u0026#39;./components/son-com-exp.vue\u0026#39; const sonCom = ref(null) onMounted(() =\u0026gt; { // データにアクセス console.log(sonCom.value.count) // 関数を呼び出す sonCom.value.hiFun() }) \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;sonComExp ref=\u0026#34;sonCom\u0026#34;\u0026gt;\u0026lt;/sonComExp\u0026gt; \u0026lt;/template\u0026gt; 階層を跨いでデータを渡す provide() 関数と inject() 関数を使えば、階層を跨いでデータを渡せるんだ。\nトップレベルで。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;script setup\u0026gt; import { ref, provide } from \u0026#39;vue\u0026#39;; import centerCom from \u0026#39;./components/center-com.vue\u0026#39;; // データを渡す provide(\u0026#39;count\u0026#39;, 20) // リアクティブなデータを渡す const total = ref(100) provide(\u0026#39;total\u0026#39;, total) const clickFn = () =\u0026gt; { total.value++ } \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div\u0026gt;Top component\u0026lt;/div\u0026gt; \u0026lt;button @click=\u0026#34;clickFn\u0026#34;\u0026gt;change total\u0026lt;/button\u0026gt; \u0026lt;centerCom\u0026gt;\u0026lt;/centerCom\u0026gt; \u0026lt;/template\u0026gt; 中間層。\n1 2 3 4 5 6 7 8 \u0026lt;script setup\u0026gt; import bottomCom from \u0026#39;./bottom-com.vue\u0026#39;; \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div\u0026gt;this is center component\u0026lt;/div\u0026gt; \u0026lt;bottomCom\u0026gt;\u0026lt;/bottomCom\u0026gt; \u0026lt;/template\u0026gt; 最下層。\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;script setup\u0026gt; import { inject } from \u0026#39;vue\u0026#39;; // データを取得 const count = inject(\u0026#39;count\u0026#39;) const total = inject(\u0026#39;total\u0026#39;) \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div\u0026gt;this is bottom component\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;count from top: {{ count }}\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;total from top: {{ total }}\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 階層を跨いで関数を渡す もちろん、関数も渡せるよ。そうすれば、最下層のコンポーネントからトップレベルのコンポーネントのデータを操作できるようになるんだ。\nトップレベルのコンポーネントで関数を渡す。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 \u0026lt;script setup\u0026gt; import { ref, provide } from \u0026#39;vue\u0026#39;; import centerCom from \u0026#39;./components/center-com.vue\u0026#39;; // データを渡す provide(\u0026#39;count\u0026#39;, 20) // リアクティブなデータを渡す const total = ref(100) provide(\u0026#39;total\u0026#39;, total) const clickFn = () =\u0026gt; { total.value++ } // 関数を渡す provide(\u0026#39;changeTotal\u0026#39;, (newTotal) =\u0026gt; { total.value = newTotal }) \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div\u0026gt;Top component\u0026lt;/div\u0026gt; \u0026lt;button @click=\u0026#34;clickFn\u0026#34;\u0026gt;change total\u0026lt;/button\u0026gt; \u0026lt;centerCom\u0026gt;\u0026lt;/centerCom\u0026gt; \u0026lt;/template\u0026gt; 最下層のコンポーネントで関数を受け取る。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;script setup\u0026gt; import { inject } from \u0026#39;vue\u0026#39;; // データを取得 const count = inject(\u0026#39;count\u0026#39;) const total = inject(\u0026#39;total\u0026#39;) // 関数を取得 const changeTotal = inject(\u0026#39;changeTotal\u0026#39;) const clickFn = () =\u0026gt; { changeTotal(233) } \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div\u0026gt;this is bottom component\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;count from top: {{ count }}\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;total from top: {{ total }}\u0026lt;/div\u0026gt; \u0026lt;button @click=\u0026#34;clickFn\u0026#34;\u0026gt;change total from bottom\u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; ","date":"2025-10-14T20:58:25+09:00","permalink":"https://blog.yexca.net/ja/archives/259/","title":"Vue 3: コンポーネントの取得と階層を跨いだデータの受け渡し"},{"content":" 📢 この記事は gemini-2.5-flash によって翻訳されました はじめに Google の Gemini Pro サブスクリプションには2TBのストレージが付いてるんだ。それを見たら、また何か試したくなっちゃったんだよね。ってことで、早速やっちゃおうかなと。\nでも、よく見たら 前回のいじり からもう3年も経ってるんだね。時間ってホントあっという間だなぁ。\n漫画 Komga まずは漫画を読むためのKomgaね。スキャンするときはちょっともたつくけど、使い心地自体は悪くないよ。\n何年も経って、Komgaもかなりアップデートされてるんだ。 前の記事 の内容はもう使えないし、docker-composeを使う方がもっと手軽だから、docker-compose.ymlはこんな感じ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 version: \u0026#39;3.0\u0026#39; services: komga: image: gotson/komga:1.23.4 container_name: komga volumes: - type: bind source: /home/komga/config target: /config - type: bind source: /home/rclone/data target: /data ports: - 25600:25600 restart: unless-stopped あと、 専用のiOSアプリKomic があるのがマジで便利なんだよね。\nrclone Google Drive マウント Microsoft OneDrive と同じように、まずはWindowsのブラウザで認証してトークンを手に入れる必要があるよ。\n具体的な手順としては、ダウンロードしてからコマンドを実行するだけ。\n1 rclone config 名前を付けたらGoogle Drive (22)を選んで、Full access all files, excluding Application Data Folderの権限を与えて、エンターを押してブラウザでログイン、終わったら終了って感じ。\nただ、最初はよく分からなくて、アプリIDとシークレットを申請してみたんだけど、あんまり意味なかったみたい。でも、一応記録しとけば後で使えるかもしれないしね。\nGoogle アプリケーションAPI IDとシークレットを申請 Google API サービスサイトを開く: https://console.developers.google.com/ Enable APIs and servicesを選んでGoogle Drive APIを検索して有効にする。\nGoogle Drive APIのManageからCreate credentials。\nAPIのタイプはUser data、つまりOAuthを含むものを選択。\nOAuth Client IDでタイプをWeb applicationに選んで、名前はrcloneって入力してもOK。終わったらClient IDが出てくるよ。\nこれで作成完了。Credentialsでさっき作ったrcloneアプリを選んで、秘密鍵のClient secretsをコピーしてね。\n次に設定ファイルをサーバーにコピーするんだけど、ローカルのディレクトリはこれ。\n1 C:\\Users\\%USERNAME%\\AppData\\Roaming\\rclone サーバーにはfuseをダウンロード。僕のサーバーはCentOS7だから、これをダウンロードしたよ。\n1 sudo yum install -y fuse fuse3 fuse-libs もっと新しいシステムならfuse3を直接ダウンロードすればOK。次にdockerでマウントするよ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 sudo docker run --rm \\ --volume /home/opc/rclone/config:/config/rclone \\ --volume /home/opc/rclone/data:/data:shared \\ --volume /etc/passwd:/etc/passwd:ro --volume /etc/group:/etc/group:ro \\ --device /dev/fuse --cap-add SYS_ADMIN --security-opt apparmor:unconfined \\ rclone/rclone \\ mount GoogleDrive:/ /data \\ --no-checksum \\ --use-server-modtime \\ --no-gzip-encoding \\ --no-update-modtime \\ --no-seek \\ --modify-window 2m \\ --allow-other \\ --allow-non-empty \\ --dir-cache-time 30m \\ --cache-read-retries 15 \\ --cache-db-purge \\ --timeout 30m \\ --vfs-cache-mode full \\ --vfs-read-chunk-size 2M \\ --vfs-read-chunk-size-limit 5M \\ --vfs-cache-max-age 30m \\ --attr-timeout 20s \\ --poll-interval 9m \\ --vfs-cache-poll-interval 10m\u0026amp; 後ろのたくさんある設定は Komgaの公式提供 を参考にしてるんだけど、具体的な意味はこんな感じ。\nパラメーター 機能 説明 --no-checksum チェックサムをスキップ API呼び出しを減らし、ディレクトリの読み込みを高速化。動画などの大きなファイルに適してる。 --use-server-modtime サーバーのファイル更新時間を使用 ローカルとリモートの時間差による重複アップロード/同期を防ぐ。 --no-gzip-encoding GZIPエンコーディングを無効化 一部のクラウド（Driveなど）では、レスポンスが圧縮されるとパフォーマンスが良くない場合があるから、これでCPU使用率を下げられるよ。 --no-update-modtime ファイル更新時間を更新しない 読み取り専用の用途で、時間変動によるDriveのバージョン更新を防ぐ。 --no-seek ランダム読み取りを無効化 動画のシーク操作のサポートは減るけど、順次読み込みの安定性が向上するよ。連続再生シーンに適してる。 --modify-window 2m ファイル更新時間の誤差許容範囲 ローカル/リモートの時間差による誤判定を防ぐ。 --allow-other システム内の他のユーザーがマウント内容にアクセスすることを許可 /etc/fuse.confで許可するようにシステム設定が必要。 --allow-non-empty 空でないディレクトリをマウント マウントポイントが空でなくてもマウントを続けられる。 --dir-cache-time 30m ディレクトリキャッシュ時間 頻繁なクラウドAPIリクエストを減らす。デフォルトでちょうどいいくらい。 --cache-read-retries 15 キャッシュ読み取り失敗時の再試行回数 安定性を高める。 --cache-db-purge 起動ごとにキャッシュデータベースをクリア 古いキャッシュの破損によるエラーを防ぐ。長時間マウントをオン/オフする環境に適してる。 --timeout 30m 単一転送のタイムアウト上限 長い動画や大きなファイルの読み取り時に接続切れを防ぐ。 --vfs-cache-mode full フルキャッシュモード 読み書きはすべてローカルキャッシュを介して行う。最もパフォーマンスがバランスが取れていて、安全だよ。 --vfs-read-chunk-size 2M ダウンロードチャンクサイズ 小さいほど帯域幅は節約できるけど、頻度が高くなる。この設定は低帯域幅環境に適してる。 --vfs-read-chunk-size-limit 5M 最大チャンクサイズ制限 増大を制限して、一度に大きなリクエストがタイムアウトするのを防ぐ。 --vfs-cache-max-age 30m キャッシュファイルの最大生存時間 比較的短い時間で、スペース節約に適してる。 --attr-timeout 20s ファイル属性キャッシュ時間 頻繁なstat()呼び出しを防ぐ。20秒が妥協点だね。 --poll-interval 9m クラウド変更ポーリング間隔 9分に1回変更をチェックして、Google APIの負担を軽減する。 --vfs-cache-poll-interval 10m ローカルキャッシュクリア間隔 10分ごとに期限切れキャッシュをクリアする。 Alpine Linux の使い方 占有率が高すぎたから、めっちゃ軽量なAlpineを思いついたんだ。\nDockerのインストール まずはソフトウェアをアップデート。\n1 doas apk update Dockerをインストール。\n1 doas apk add docker docker-cli-compose 起動時に設定。\n1 rc-update add docker default Dockerを起動。ちょっと待つ必要があるかも。\n1 doas service docker start 自分をDockerユーザーグループに追加。\n1 doas addgroup ${USER} docker 参考記事\nhttps://wiki.alpinelinux.org/wiki/Docker swapの作成 まずスワップスペースを追加するよ。\n1 doas fallocate -l 8G /swapfile 権限はrootだけがアクセスできるように設定。\n1 doas chmod 600 /swapfile swapをフォーマット。\n1 doas mkswap /swapfile swapを有効にする。\n1 doas swapon /swapfile そしたら、ちゃんと有効になったか確認できるよ。\n1 free -h rcloneの設定 めっちゃ軽量だから、いくつか追加設定が必要なんだ。\nまずはfuseをインストール。\n1 doas apk add fuse デバイスをマウント。\n1 doas modprobe fuse それから、ルートディレクトリをshareタイプに変更する必要があるんだ。\n1 doas mount --make-rshared / あとはCentOS7と同じような感じ。\n参考記事\nHow to Install Rclone on Alpine Linux Latest Alpine Linux Wiki Rclone Kikoeru 最初はちょっと遠回りしちゃって、結局失敗しちゃったんだ。だから、一応記録しとくね。\n午後いっぱいの失敗 TT 定番のkikoeruプロジェクトのフォークを辿って最新のコミットを探してたんだ。で、 XunJiJiang/kikoeru-express は見つかったんだけど、イメージのビルドを午後いっぱい試しまくったよ。Node.js 12から16まで試して、いろんなエラーが出て、ミラーを変えたりとか色々やったんだ。単独デプロイもビルド失敗ばっかりで、Dockerなしでビルドしてみてもダメで、最終的にはもう諦めて、定番の0.6.2を使うことにしたんだ。\nうわー、マジでね、Node.jsのバージョンは12-14が推奨されてるのに、実際にビルドを進めていくと、あるステップで16以上の機能が必要って出てくるんだ。直接14以上でnpm iするとエラーになっちゃうから、仕方なく13で先に依存関係をインストールして、終わったらコピーしてきて16でビルドする、みたいなことになってね。まさかこんな感じで午後いっぱいかかっちゃったよ。でも正直、これでNode.jsのバージョン切り替えがめっちゃ得意になっちゃったかもXD\n前にダウンロードしたiOSアプリを開いて接続してみたら異常だったんだ。更新履歴を見たら、0.6.14バージョン以上を使ってって書いてあって、マジで衝撃受けたよ。で、すぐに検索したら、すでにスターしてた Number178/kikoeru-express を見つけちゃった😂\n更新されてる Number178/kikoeru-express を使ってるんだけど、この作者がiOSアプリも開発してくれてて、それがめっちゃ便利なんだ。\n設定ファイル\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 version: \u0026#39;3.0\u0026#39; services: kikoeru: ports: - \u0026#39;8011:8888\u0026#39; container_name: kikoeru volumes: - type: bind source: /home/rclone/data/asmr target: /usr/src/kikoeru/VoiceWork - /home/kikoeru/sqlite:/usr/src/kikoeru/sqlite - /home/kikoeru/covers:/usr/src/kikoeru/covers - /home/kikoeru/config:/usr/src/kikoeru/config image: \u0026#39;number17/kikoeru:v0.6.14-20250914\u0026#39; restart: always それでね、タグの言語は切り替えられないんだ。デフォルトが簡体中国語だから、日本語が必要ならスキャンする前に切り替えておく必要があるよ。\n","date":"2025-10-05T01:58:35+09:00","permalink":"https://blog.yexca.net/ja/archives/258/","title":"漫画と音声サイトいじり"},{"content":" 📢 この記事は Gemini-3-flash によって翻訳されたよ。 はじめに ちょうどサーバーの期限が切れそうだったんだ。去年も1年更新したんだけど、今年は色んなキャンペーンを見てたら更新料がちょっと高いなって感じて。色んな中小サーバー業者を見て回った後、アリババクラウドで「12ヶ月間請求なしなら割引」っていうのを見つけたんだ。大手を見てしまった流れで、ついでに Oracle（オラクル）も思い出しちゃってさ。\nそれで試してみたんだ。全部リアルの情報で申し込んだら、なんと一発で審査に通ったよ！おめでたい。\nでも、ふと思い出したけど 最後にサーバーをいじったの は2023年だったんだね。あっという間に2年経っちゃった。月日が流れるのは本当に早いなあ。\nOracle Linux イメージを作る時に、僕のお気に入りの Debian がなかったんだ。だからこの Oracle Linux を試してみたんだけど……。まず MySQL がプリインストールされてるのはいいとして（Docker を使う派だから、ホストOSは綺麗にしておきたい潔癖症なんだけどね XD）、リソース消費が激しすぎる。無料枠の 1C1G だとメモリが足りなくて固まっちゃったから、結局別のイメージに変えることにしたよ。\nOracle Linux 使用記録 まずはアップデート。dnf コマンドを使ってたら、昔 Fedora を使ってた頃を思い出したよ。\n1 sudo dnf update -y そうしたらアップデートリストに MySQL があって、サーバーが固まっちゃった。アンインストールするために、まずは MySQL サービスが動いているか確認。\n1 sudo systemctl status mysqld サービスが動いてるから、まずは停止させる。\n1 sudo systemctl stop mysqld 自動起動を禁止にする。\n1 sudo systemctl disable mysqld アンインストール。\n1 sudo dnf remove mysql-server それでもソフトのアップデートでまだ固まるんだよね。Docker のインストールはここを参考にして： https://oracle-base.com/articles/linux/docker-install-docker-on-oracle-linux-ol8 CentOS7 のリポジトリ更新 まずはミラーサイト（源）の変更。Oracle の CentOS7 はどうやらソフトリストのパスが間違っているみたいで、sudo yum update を実行するとエラーが出るんだ。\n1 2 Could not retrieve mirrorlist http://mirrorlist.centos.org/?release=7\u0026amp;arch=x86_64\u0026amp;repo=os\u0026amp;infra=stock error was 14: curl#6 - \u0026#34;Could not resolve host: mirrorlist.centos.org; Unknown error\u0026#34; ソフトウェアリストを更新する。\n1 2 3 sed -i \u0026#39;s/mirror\\.centos\\.org/vault.centos.org/g\u0026#39; /etc/yum.repos.d/CentOS-*.repo sed -i \u0026#39;s/^#.*baseurl=http/baseurl=http/g\u0026#39; /etc/yum.repos.d/CentOS-*.repo sed -i \u0026#39;s/^mirrorlist=http/#mirrorlist=http/g\u0026#39; /etc/yum.repos.d/CentOS-*.repo それからアップデートを実行。\n1 sudo yum update 参考記事: mirrorlist.centos.org no longer resolve? Docker のインストール ツールをインストール。\n1 sudo yum install -y yum-utils 公式リポジトリを設定。\n1 sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo インストール。\n1 sudo yum install docker-ce docker-ce-cli docker-compose containerd.io 起動。\n1 sudo systemctl start docker 自動起動を設定。\n1 sudo systemctl enable docker 参考記事: CentOS7 インストール docker (公式ドキュメント参照) サーバーのポート管理 よく使う 80 番と 443 番ポートを開放するよ。まずはファイアウォールの状態を確認。\n1 sudo systemctl status firewalld 出力が Active: active (running) なら動いてる。現在開放されているポート（恒久設定）を確認。\n1 sudo firewalld-cmd --list-all --permanent ポート開放を追加。\n1 sudo firewall-cmd --zone=public --add-port=8080/tcp --permanent 設定を反映させるためにリロード。\n1 sudo firewall-cmd --reload ルールを削除したい場合はこれ。\n1 sudo firewall-cmd --zone=public --remove-port=8080/tcp --permanent セキュリティ・リストのポート開放 サーバー内部での開放はOSレベルの話だけど、クラウド側のセキュリティ・リストでもインバウンドポートを許可してあげる必要があるんだ。\nInstances - Networking - Subnet から、そのインスタンスの Subnet を管理する。\nその中にある Security から具体的なセキュリティ・リストを管理する。\nSecurity rules で Ingress Rules を追加。\nSource Type は CIDR を選択、Source CIDR には 0.0.0.0/0 を入力。IP Protocol は TCP。Destination Port Range に 80, 443 を入れて、Description（説明）には任意で HTTP/S とか書いておく。\nあとは Add Ingress Rules を押せばOK。\nNginx-UI のインストール 以前の サーバー Docker 構築記録 でも使い方は紹介したけど、アップデートで新機能が追加されたんだ。\n他のコンテナから Nginx を制御したり、更新をスムーズにするために、新しいディレクトリをマッピングする必要がある。だから docker-compose.yml はこんな感じになったよ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 version: \u0026#39;3.1\u0026#39; services: nginx-ui: restart: always image: uozi/nginx-ui:latest container_name: nginx_UI volumes: - /root/nginx/nginx:/etc/nginx - /root/nginx/nginx-ui:/etc/nginx-ui - /root/nginx/www:/www - /var/run/docker.sock:/var/run/docker.sock ports: - 80:80 - 443:443 ここで /var/run/docker.sock をマッピングする理由について、Nginx-UI はこう説明しているよ：\nNginx UI 公式イメージは、Docker Client API を通じてホストの Docker Engine と通信するために /var/run/docker.sock を使用します。この機能は、別のコンテナ内の Nginx を制御したり、Nginx UI の OTA アップグレード時にバイナリ置換ではなくコンテナの差し替えを行って、コンテナの依存関係も確実にアップグレードするために使われます。もしこの機能が不要なら、コンテナに環境変数 NGINX_UI_IGNORE_DOCKER_SOCKET=true を追加してください。\nその他のサービス 他に動かしてるものは、そのまま継続して使えそうかな。今回の移行はすごくスムーズだった気がする。ほとんどの時間はサーバー自体の設定に費やした感じだね。\n","date":"2025-10-03T10:22:25+09:00","permalink":"https://blog.yexca.net/ja/archives/257/","title":"2025年 新サーバー構築の記録"},{"content":" 📢 この記事は gemini-2.5-flash によって翻訳されました はじめに あるすごい人からRecord TreeのJSONファイルをもらったから、ついでに サッと何か書いとこう 。便利だし、忘れちゃったことのメモにもなるしね～（そうそう、ちょうど256番目の記事なんだよね）\nでもさ、 PixivDownloader でも使ったことあったのに、完全に忘れちゃってたんだよね。\nJSONファイルを読み込む 読み込んだ後に返ってくる値はJSONファイルによって違うんだけど、Pythonのリストか辞書型に対応してるよ。\n1 2 3 4 import json with open(FILE_PATH, \u0026#34;r\u0026#34;, encoding=\u0026#34;utf-8\u0026#34;) as f: jsonParse = json.load(f) そしたら、jsonParse変数にいろんな操作ができるようになるんだ。\nリスト もしJSONファイルがこんな感じだったら\n1 2 3 4 5 6 7 8 [ { \u0026#34;a\u0026#34;: \u0026#34;b\u0026#34; }, { \u0026#34;c\u0026#34;: \u0026#34;d\u0026#34; } ] そしたら、さっきの操作でjsonParseの外側はリストで、それぞれのリストの項目は辞書型になるよ。\n辞書 もしJSONファイルがこんな感じだったら\n1 2 3 4 5 { \u0026#34;a\u0026#34;: { \u0026#34;c\u0026#34;: \u0026#34;d\u0026#34; } } そしたら、さっきの操作でjsonParseは2層にネストされた辞書になるんだ。\n操作 型がわかれば、このファイルに対する操作はPythonでの辞書やリストに対する操作と同じで大丈夫。例えば、このファイルの場合ね。\n1 2 3 4 5 6 7 8 9 10 [ { \u0026#34;a\u0026#34;: 1, \u0026#34;b\u0026#34;: 2 }, { \u0026#34;c\u0026#34;: 3, \u0026#34;d\u0026#34;: 4 } ] 1を出力するコード\n1 2 3 4 5 6 7 import json with open(FILE_PATH, \u0026#34;r\u0026#34;, encoding=\u0026#34;utf-8\u0026#34;) as f: s = json.load(f) print(s[0][\u0026#34;a\u0026#34;]) # または print(s[0].get(\u0026#34;a\u0026#34;)) 4を100に修正するコード\n1 2 3 4 5 import json with open(FILE_PATH, \u0026#34;r\u0026#34;, encoding=\u0026#34;utf-8\u0026#34;) as f: s = json.load(f) s[1][\u0026#34;d\u0026#34;] = 100 項目を一つ追加して、ファイルをこんな感じにする\n1 2 3 4 5 6 7 8 9 10 11 12 13 [ { \u0026#34;a\u0026#34;: 1, \u0026#34;b\u0026#34;: 2 }, { \u0026#34;c\u0026#34;: 3, \u0026#34;d\u0026#34;: 4 }, { \u0026#34;e\u0026#34;: 5 } ] 要はリストに辞書を追加するってことなんだけど、コードはこれね。\n1 2 3 4 5 import json with open(FILE_PATH, \u0026#34;r\u0026#34;, encoding=\u0026#34;utf-8\u0026#34;) as f: s = json.load(f) s.append({\u0026#34;e\u0026#34;: 5}) ループ処理 リストの場合は、リストのループ処理を使うよ。\n1 2 for i in s: print(i) 辞書の場合は、辞書のループ処理を使うよ。\n1 2 3 4 5 for key, value in s.items(): print(key, value) for key in s: print(key) 保存 json.dumpを使う\n1 2 3 4 5 6 with open(FILE_PATH, \u0026#34;r\u0026#34;, encoding=\u0026#34;utf-8\u0026#34;) as f: s = json.load(f) # 変数sに何か修正を加える with open(FILE_PATH, \u0026#34;w\u0026#34;, encoding=\u0026#34;utf-8\u0026#34;) as f: json.dump(s, f, ensure_ascii=False, indent=2) ensure_ascii=Falseは中国語文字が正しく書き込まれるようにするもので、indent=2はインデントがスペース2つ分になることを意味してるよ。\n","date":"2025-09-28T10:34:38+09:00","permalink":"https://blog.yexca.net/ja/archives/256/","title":"Python で JSON ファイルを扱う"},{"content":" 📢 この記事は gemini-2.5-flash によって翻訳されました 255本目の記事だね。最近特にアイデアもないし、ついでにVueのメモでも書いちゃおうか。\n子コンポーネントの導入 子コンポーネントの定義\n1 2 3 4 5 6 7 8 \u0026lt;script setup\u0026gt; \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; this is a son component \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 親コンポーネントでの使用\n1 2 3 4 5 6 7 8 9 \u0026lt;script setup\u0026gt; import SonCom from \u0026#39;@/components/son-com.vue\u0026#39; \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;h2\u0026gt;this is a father component\u0026lt;/h2\u0026gt; \u0026lt;!-- 直接使用 --\u0026gt; \u0026lt;SonCom\u0026gt;\u0026lt;/SonCom\u0026gt; \u0026lt;/template\u0026gt; 親コンポーネントから子コンポーネントへのデータ受け渡し 親コンポーネントでプロパティを通じて値を渡す\n1 2 3 4 5 6 7 8 9 \u0026lt;script setup\u0026gt; import SonCom from \u0026#39;@/components/son-com.vue\u0026#39; \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;h2\u0026gt;this is a father component\u0026lt;/h2\u0026gt; \u0026lt;!-- 属性传值 --\u0026gt; \u0026lt;SonCom msg=\u0026#34;a msg from father\u0026#34;\u0026gt;\u0026lt;/SonCom\u0026gt; \u0026lt;/template\u0026gt; 子コンポーネントで値を受け取る\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;script setup\u0026gt; // setup内だから、コンパイラマクロ関数を使って受け取る必要があるよ const props = defineProps({ msg: String }) // スクリプト内ではオブジェクトアクセス方式でアクセスする console.log(props.msg) \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; this is a son component \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;!-- でも使うときは変数名を直接使うだけだよ --\u0026gt; {{ msg }} \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; もちろんリアクティブなデータも渡せるよ。親コンポーネントではこんな感じ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;script setup\u0026gt; import {ref} from \u0026#39;vue\u0026#39; import SonCom from \u0026#39;@/components/son-com.vue\u0026#39; const count = ref(100) const addCount = () =\u0026gt; { count.value++ } \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;h2\u0026gt;this is a father component\u0026lt;/h2\u0026gt; \u0026lt;button @click=\u0026#34;addCount\u0026#34;\u0026gt;add count\u0026lt;/button\u0026gt; \u0026lt;br/\u0026gt; \u0026lt;!-- 属性传值 --\u0026gt; \u0026lt;SonCom msg=\u0026#34;a msg from father\u0026#34; :count=\u0026#34;count\u0026#34;\u0026gt;\u0026lt;/SonCom\u0026gt; \u0026lt;/template\u0026gt; 子コンポーネントでの受け取り方\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;script setup\u0026gt; // setup内だから、コンパイラマクロ関数を使って受け取る必要があるよ const props = defineProps({ msg: String, count: Number }) // スクリプト内ではオブジェクトアクセス方式でアクセスする console.log(props.msg) \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; this is a son component \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;!-- でも使うときは変数名を直接使うだけだよ --\u0026gt; {{ msg }} - {{ count }} \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; でも本質的には、Option APIと同じでpropsで受け取るってことだね。\n子コンポーネントから親コンポーネントへのデータ受け渡し 子コンポーネントでイベントを登録する必要があるよ\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 \u0026lt;script setup\u0026gt; // setup内だから、コンパイラマクロ関数を使って受け取る必要があるよ const props = defineProps({ msg: String, count: Number }) // スクリプト内ではオブジェクトアクセス方式でアクセスする console.log(props.msg) // イベントを定義して、親コンポーネントにデータを渡す const emit = defineEmits([\u0026#39;minusCount\u0026#39;]) const minusCountFun = () =\u0026gt; { emit(\u0026#39;minusCount\u0026#39;, 5) } \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; this is a son component \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;!-- でも使うときは変数名を直接使うだけだよ --\u0026gt; {{ msg }} - {{ count }} \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;button @click=\u0026#34;minusCountFun\u0026#34;\u0026gt;minus count\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; そして親コンポーネントでイベントを受け取る\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 \u0026lt;script setup\u0026gt; import {ref} from \u0026#39;vue\u0026#39; import SonCom from \u0026#39;@/components/son-com.vue\u0026#39; const count = ref(100) const addCount = () =\u0026gt; { count.value++ } // パラメータを受け取る const minusCountFun = (c) =\u0026gt; { count.value -= c } \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;h2\u0026gt;this is a father component\u0026lt;/h2\u0026gt; \u0026lt;button @click=\u0026#34;addCount\u0026#34;\u0026gt;add count\u0026lt;/button\u0026gt; \u0026lt;br/\u0026gt;\u0026lt;hr/\u0026gt; \u0026lt;!-- 属性传值，事件名要和子组件一样 --\u0026gt; \u0026lt;SonCom msg=\u0026#34;a msg from father\u0026#34; :count=\u0026#34;count\u0026#34; @minusCount=\u0026#34;minusCountFun\u0026#34;\u0026gt;\u0026lt;/SonCom\u0026gt; \u0026lt;/template\u0026gt; ","date":"2025-09-21T19:17:40+09:00","permalink":"https://blog.yexca.net/ja/archives/255/","title":"Vue3 親子コンポーネント間のデータ受け渡し"},{"content":" 📢 この記事は gemini-2.5-flash によって翻訳されました プロジェクト作成 Node.js 16.0以上が必要だよ。以下のコマンドを実行してみて。\n1 npm init vue@latest このコマンドを実行すると、create-vueがインストールされて実行されるんだ。\nsetup 実行タイミング beforeCreate()よりも早く実行されるから、thisは使えないんだ。\n1 2 3 4 5 6 7 8 9 10 \u0026lt;script\u0026gt; export default{ setup(){ console.log(\u0026#39;setup\u0026#39;, this) }, beforeCreate(){ console.log(\u0026#39;beforeCreate\u0026#39;) } } \u0026lt;/script\u0026gt; 実行すると、まず「setup undefined」が出力されて、それから「beforeCreate」が表示されるよ。\nデータ呼び出し \u0026lt;template\u0026gt;でsetup()関数内で定義したデータや関数を使いたいなら、returnしないといけないんだ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;script\u0026gt; export default{ setup(){ // data const msg = \u0026#39;hello vue3\u0026#39; // function const logMsg = () =\u0026gt; { console.log(msg) } // return return{ msg, logMsg } } } \u0026lt;/script\u0026gt; returnしてからじゃないと、\u0026lt;template\u0026gt;で使えないからね。\n1 2 3 4 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt;{{ msg }}\u0026lt;/div\u0026gt; \u0026lt;button @click=\u0026#34;logMsg\u0026#34;\u0026gt;button\u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; シンタックスシュガー 毎回returnするのは正直面倒だよね。実は、\u0026lt;script\u0026gt;タグにsetupって付ければ、自動でreturnしてくれるようになるんだ。さっきの例だと、こう書けるようになるよ。\n1 2 3 4 5 6 \u0026lt;script setup\u0026gt; const msg = \u0026#39;hello vue3\u0026#39; const logMsg = () =\u0026gt; { console.log(msg) } \u0026lt;/script\u0026gt; もちろん、実際はreturnされてるんだけど、自分で書かなくてよくなるってことだね。\nリアクティブなデータ reactive reactive()関数はオブジェクト型のデータを受け取って、リアクティブなオブジェクトを返すんだ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;script setup\u0026gt; import { reactive } from \u0026#39;vue\u0026#39; const state = reactive({ count: 100 }) const addCount = () =\u0026gt; { state.count++ } \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div\u0026gt;{{ state.count }}\u0026lt;/div\u0026gt; \u0026lt;button @click=\u0026#34;addCount\u0026#34;\u0026gt;+1\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; ref ref()は、プリミティブ型でも複雑な型でも受け取って、リアクティブなオブジェクトを返すよ。本質的には、渡されたデータの上にオブジェクトでラッピングして、より複雑な型にしてるんだ。これも実はreactive()を使ってリアクティブを実現してるんだよね。\nだから、\u0026lt;script\u0026gt;でデータにアクセスするときは.valueを使う必要があるんだ。でも、\u0026lt;template\u0026gt;でアクセスするときは、変数名をそのまま使えばOKだよ。さっきの例をref()で書き直すとこうなるよ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;script setup\u0026gt; import { ref } from \u0026#39;vue\u0026#39; const c = ref(0) const addC = () =\u0026gt; { c.value++ } \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div\u0026gt;{{ c }}\u0026lt;/div\u0026gt; \u0026lt;button @click=\u0026#34;addC\u0026#34;\u0026gt;+1\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 実際の開発ではref()だけを使うと、より柔軟で統一感のあるコードになることが多いよ。\ncomputed 算出プロパティのcomputed()はVue2と似てるけど、好きなときに呼び出せる関数になったんだ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;script setup\u0026gt; import { computed, ref } from \u0026#39;vue\u0026#39; const list = ref([1, 2, 3, 4, 5, 6, 7, 8]) const computedList = computed(() =\u0026gt; { return list.value.filter(item =\u0026gt; item \u0026gt; 2) }) \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div\u0026gt;{{ list }}\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;{{ computedList }}\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; こうやって作ったプロパティは読み取り専用で、書き込みはできないんだ。もし書き込みも必要なら、get()とset()を明示的に宣言する必要があるよ。以下は公式のサンプルから引用したんだ。\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;script\u0026gt; const count = ref(1) const plusOne = computed({ get: () =\u0026gt; count.value + 1, set: (val) =\u0026gt; { count.value = val - 1 } }) plusOne.value = 1 console.log(count.value) // 0 \u0026lt;/script\u0026gt; 引用元: https://cn.vuejs.org/api/reactivity-core.html#computed watch watch()関数も同じように、1つまたは複数のデータの変更を監視して、データが変更されたときにコールバック関数を実行するんだ。ただ、immediateとdeepっていう2つの追加パラメータが増えたよ。\n単一データ 1 2 3 watch(count, (newValue, oldValue) =\u0026gt; { console.log(\u0026#39;count changed\u0026#39;, oldValue, newValue) }) 複数データ 1 2 3 watch([count, name], ([newCount, newName], [oldCount. oldName]) =\u0026gt; { console.log(\u0026#39;count or name has changed\u0026#39;, [newCount, newName], [oldCount. oldName]) }) サンプルだよ。ここでは簡略化したPugを使ってるけど、これもけっこう分かりやすいはずだよ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 \u0026lt;script setup\u0026gt; import { ref, watch } from \u0026#39;vue\u0026#39; const count = ref(0) const name = ref(\u0026#39;John\u0026#39;) const addCount = () =\u0026gt; count.value++ const changeName = () =\u0026gt; name.value = \u0026#39;Mike\u0026#39; // 単一データの変更を監視 watch(count, (newValue, oldValue) =\u0026gt;{ console.log(\u0026#39;count changed\u0026#39;, oldValue, newValue) }) // 複数データの変更を監視 watch([count, name], (newArr, oldArr) =\u0026gt; { console.log(\u0026#39;count or name changed\u0026#39;, oldArr, newArr) }) \u0026lt;/script\u0026gt; \u0026lt;template lang=\u0026#34;pug\u0026#34;\u0026gt; div count: {{ count }} button(@click=\u0026#34;addCount\u0026#34;) +1 div name: {{ name }} button(@click=\u0026#34;changeName\u0026#34;) change name \u0026lt;/template\u0026gt; immediate immediateはすぐに実行されるって意味で、ページに入ったらすぐに1回実行されるんだ。このときoldValueはundefinedになるよ。\n1 2 3 4 5 watch(count, (newValue, oldValue) =\u0026gt;{ console.log(\u0026#39;count changed\u0026#39;, oldValue, newValue) }, { immediate: true }) deep deepはディープウォッチャーだよ。デフォルトのwatchはシャローウォッチャーだから、複雑な型の変更は監視できないんだ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 \u0026lt;script setup\u0026gt; import { ref, watch } from \u0026#39;vue\u0026#39; const userInfo = ref({ name: \u0026#39;John\u0026#39;, age: 18 }) const changeUserInfo = () =\u0026gt; { userInfo.value.age++ } watch(userInfo, (newValue) =\u0026gt; { console.log(\u0026#39;userInfo changed\u0026#39;, newValue) }, { deep: true }) \u0026lt;/script\u0026gt; \u0026lt;template lang=\u0026#34;pug\u0026#34;\u0026gt; div {{ userInfo }} button(@click=\u0026#34;changeUserInfo\u0026#34;) change userInfo \u0026lt;/template\u0026gt; 複雑な型の単一プロパティ監視 deepを使うと、複雑な型のすべてのプロパティを監視することになるんだ。つまり、どのプロパティでも変更があれば関数が実行されるってこと。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 \u0026lt;script setup\u0026gt; import { ref, watch } from \u0026#39;vue\u0026#39; const userInfo = ref({ name: \u0026#39;John\u0026#39;, age: 18 }) const changeAge = () =\u0026gt; { userInfo.value.age++ } const changeName = () =\u0026gt; { userInfo.value.name = \u0026#39;Mike\u0026#39; } watch(() =\u0026gt; userInfo.value.age, (newValue, oldValue) =\u0026gt; { console.log(\u0026#39;age changed\u0026#39;, oldValue, newValue) }) \u0026lt;/script\u0026gt; \u0026lt;template lang=\u0026#34;pug\u0026#34;\u0026gt; div {{ userInfo }} button(@click=\u0026#34;changeAge\u0026#34;) change age button(@click=\u0026#34;changeName\u0026#34;) change name \u0026lt;/template\u0026gt; こうすると、ageが変更されたときにだけトリガーされるし、戻り値もageの値になるんだ。\nライフサイクルフック Vue3のライフサイクル比較\nOption API Composition API beforeCreate/created setup beforeMount onBeforeMount mounted onMounted beforeUpdate onBeforeUpdate updated onUpdated beforeUnmount onBeforeUnmount unmounted onUnmounted Composition APIでの違いは、関数呼び出しになって、複数回呼び出せるようになったってことだよ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;script setup\u0026gt; import { onMounted } from \u0026#39;vue\u0026#39;; // Composition APIでのbeforeCreateとcreatedは直接ここに書くよ const getList = () =\u0026gt; { console.log(\u0026#39;バックエンドからデータを取得\u0026#39;) } // 実行、ページに入ったらすぐにリクエスト getList() // ライフサイクルフックは複数回呼び出せて、順番に実行されるよ onMounted(() =\u0026gt; { console.log(\u0026#39;ロジック1\u0026#39;) }) onMounted(() =\u0026gt; { console.log(\u0026#39;ロジック2\u0026#39;) }) \u0026lt;/script\u0026gt; ","date":"2025-09-14T22:27:27+09:00","permalink":"https://blog.yexca.net/ja/archives/254/","title":"Vue3 Composition API を学ぶ"},{"content":" 📢　この記事は ChatGPT によって翻訳されました　はじめに 毎日動画を見たり、ゲームをしたり、これらは当然「リラックス」だと思っていた。\n終わった後には精神が回復するはずだ、と。\nでも実際は、そんな生活を続けても空虚で疲れきっている感覚しか残らなかった。\n理論的には大した消耗をしていないのに、こんなに気力が湧かないのはやっぱりおかしい。\nポモドーロの中での違和感 前に目の疲れがひどかった時、目を守るためにポモドーロタイマーを使って勉強していた。\n最初は目的がはっきりしていて、休憩のたびに遠くを眺めたり、横になったりしていた。効果は確かにあった。\nでも使い続けるうちに、「休憩のときに娯楽もしたい」と思うようになった。\n長めの休憩時間に動画を見たり、音楽を聴いたり、ゲームをしたり。\nすると効率が落ち、ポモドーロがだんだん面倒に感じてきた。\n勉強は疲れるし（集中している時に強制的に休まされる）、遊んでいても全然休まらない。\n20分しかないと思うと、遊んでいても不安になるだけだった。\n娯楽：もうひとつの集中 改めて考えると、娯楽はリラックスではないのかもしれない。\n娯楽も勉強と同じく「集中」を必要とする行為だから。\nポモドーロの設計も、集中をコントロールして、そのあとに休息を入れる仕組みだ。\n本来の「休息」とは、心身をゆるめて、集中の回復にあてるもの。\n実際に頭を空っぽにして、散歩に出たり、公園を歩いたり、本屋をぶらついたりすると、動画やゲームよりずっとリラックスできた。\n体力は少し消耗するけど、娯楽や勉強が消費するのは、むしろ精神力なんだと思う。\n娯楽とリラックスの再定義 だから、娯楽の定義を改めた方がいい。\n娯楽は勉強の疲れを癒すものではなく、むしろ精神力を使う行為だ。\n精神力が不足しているときにそれを続ければ、回復どころかさらに削られる。\nそうなると娯楽は意味を失ってしまう。まるでバッテリー残量が少ないのに、高負荷アプリを動かしているスマホみたいに。\n一方で、リラックスや休息は違う。\nそれは心と体を全部ゆるめて、漂わせるような感覚だと思う。\n精神力が足りないときは、精神も体力もあまり使わないことがいい。\n例えば、掃除をしたり、あてもなく歩いたり、何も考えずに過ごすこと。\n学びと娯楽のあいまいな境界 では、学びと娯楽の違いはどこにあるのか？\n結局は「興味」に左右されると思う。\nどんなに集中が必要でも、興味があれば娯楽になり、興味がなければ学びになる。\n例えばゲームなら、興味があるときは「楽しいから遊ぶ」で済む。\nでも「学び」として捉えると、「目標を達成しなきゃ」「ここまでやらなきゃ」となる。\n映画の IP でも同じ。\n興味があればただ身を任せて楽しむだけで、純粋に感動する。\n学びの視点なら、細部を分析したり、背景を調べたり、世界観を補完したりする。\nもちろん、境界ははっきりしていない。多くの場合は主観次第だ。\nリラックス：精神力の本当の補給 目的を持つ行動はすべて集中を必要とする。\nだから「リラックス」だと思われる行為も、実は目的がつくとリラックスにならない。\nスーパーに買い出しに行く、本屋で本を買う、公園に「休みに行く」…すべて目的がある。\n目的がついた時点で、それはもうリラックスじゃない。\n頭が空っぽにならないから、精神力も回復しない。\nリラックスは「少しの体力消耗で精神力を補う」ものだと思う。\nもし体力さえもきつければ、ただ横になって休むのが一番いい。\n結局、本当の休息とは「軽いことをする」ことじゃなく、「何もしないことを自分に許す」ことなんだ。\nまとめ 学びは人を成長させる。\n娯楽は人を興奮させる。\nでも、本当のリラックスは人を回復させる。\n人生は追いかけや刺激だけじゃなくていい。\n本当に必要なのは、娯楽を増やすことじゃなく、「立ち止まること」を学ぶことかもしれない。\n","date":"2025-08-22T22:17:38+09:00","permalink":"https://blog.yexca.net/ja/archives/253/","title":"リラックスは娯楽じゃない：精神力の再定義"},{"content":" 📢　この記事は ChatGPT によって翻訳されました　序：漂うような学習感 英語力を少しでも上げたいと思い、特に重要ではないことに関してはなるべく英語を使うようにしている。例えばゲームや日常で使うアプリなどだ。\nしかし実際に使ってみると、何も身についていないような、どこか漂っているような感覚になる。まるで経験したはずなのに、何も経験していないような気がするのだ。\nよく考えると、これは「翻訳」から「没入」への落差なのかもしれない。母語である中国語が介入すると、その経験は自分の言語や思考に結びつく。しかし完全に非母語の環境では、その経験は母語と結びつかない。普段は母語で考えているので、自然と非母語での思考過程は無視されてしまう。\n比喩：コントロールされた実行感 自分の実体験で言えば、完全に英語のゲーム環境では、簡単な単語でさえ何も理解できないように感じる。だが友人と一緒にプレイして中国語で会話すると、状況は一気に変わる。翻訳モードに切り替わり、急に楽になり、全く分からなかった混乱から少し掌握感が生まれるのだ。\nそしてそれは東京での生活を思い出させる。日本語で会話していても、心の中ではあまり実感がなく、あたかも事前に決められた指令を実行しているだけで「生きている」感覚がない。だからこそ、中国語の歌を聴くのが好きになった。街を歩いているときでも、「自分はまだ生きている」と感じられるからだ。\n矛盾：理論上の最適と現実の退縮 とはいえ、これこそが語学学習で理想とされる「母語を完全に切り離す」環境ではないだろうか。英語ゲームに完全に没入し、中国語の干渉が一切ない状況。理論的には最も効果的な学習法のはずだ。まさに Thinking in English の状態に近い。\nしかし、実際の感覚はまるで逆だ。知らない単語に出会うと、途端に「自分には何もできない、何も分からない」と感じる。その瞬間、自然と退いてしまい、結局は何もせずに終わる。結果として、英語力は全く伸びていないように感じ、むしろ自信を失っていく。\n反省：完璧な特異点の幻覚 これまでの学習経験を振り返ると、自分は「学んでいる」という感覚がほとんどなかったことに気づいた。多くの場合、直感や経験に頼って判断していたのだ。ゲームや日常生活では、言語以外にも動作や指示、環境など様々な情報がある。もしかすると、自分はそうした情報だけを頼りに次の行動を決めていて、それで「理解したつもり」になっていたのかもしれない。実際には言語自体が無視され、学習は成立していなかったのだ。\nでは、これまで（言語に限らず）自分はどう学んできたのか。思えば、常に「完璧なタイミング」を待っていた気がする。全てが「完璧」でなければ、努力する意味は全くないと自分に言い聞かせてきた。まるで 「収集は止まらないが、学習は始まらない」 という感じだ。\nこの心構えは感情面だけでなく、環境や教材の選び方にも表れている。ほとんど「幅優先探索アルゴリズム」のように、各段階で「最適解」を求めてからでなければ進めない。そうでなければ「無意味」だと感じ、無理に取り組んでも結果は出ない。\n生活：理性と感情のずれ これは生活そのものにも通じる。ある不快な出来事（事柄や物）に対して、短期と長期では全く違った態度になることが多い。短期的には心を乱すが、長期的には大して重要ではなくなるのだ。\n例えばある物。長期的には役立つかもしれないが、今は全く役に立たない。「将来必要になるかも」と思って持ち続けることで、不快さを抱えたまま過ごす。しかし結局、その物は使われないまま終わることもある。\n片付けにも同じことが言える。理性では片付けた方が良いと分かっているのに、感情的にはやる気が出ない。あるいは「完璧なタイミング」が来るのを待ち続ける。その結果、その瞬間が来るまで、思い出すたびにイライラする。\n結論：「正解」はなさそうだ では、効率的に学習や生活をする「答え」はあるのだろうか？\nたぶん……ないと思う。生活は理性的な決断と感情的な決断で満ちている。ある時期に特定の能力を伸ばそうと計画しても、未来は予測不能で、感情の状態も変わる。結果は期待以上になることもあれば、期待以下になることもある。\nただ、全く工夫ができないわけではない。新しい情報が一瞬で計画を覆すこともあるから、別の視点で自分を縛る方法もあるだろう。例えば時間を固定して、学習量は変動させる。あるいは学習量を最低限に決めて、時間は変動させる。\n延長：目的性と新鮮さ ここで、さらに一つ考えた。何かに「目的」が生じると、感情的には続けにくくなる。娯楽でさえそうだ。例えば「ストレス解消のために」ゲームをする時、逆に「本当に解消できているのか」と気にしてしまう。その意識自体がプレッシャーとなり、かえって疲れ、いわゆる「デジタルED」のような状態になる。\nだから「趣味は多い方がいい」と言われるのだろう。それは確かに良い解決策だと思う。状況に応じて、異なる方法でストレスを発散できる（興味が前提であることが大事）。そうすれば一つの手段に依存せずに済む。\nけれど、本質はもっと単純かもしれない。新しいものから生まれる「新鮮さ」こそが鍵なのだ。\n結語：「不可控」の未来 さて、この文章は一体何を書いたのだろうか。正直、自分でもよく分からない。おそらく混乱した思考の産物なのだろう。\nでも、これこそが答えなのかもしれない——生活の「不可控」を受け入れること。理性ですべてを構築しようとしても、結局……理性だけでは全てを説明できないのだ。\n「状態—行動理論」が言うように、すべての変数を把握してはじめて100%の結果を予測できる。しかし、私たちはどうやって生活の「すべての変数」を集められるのだろうか。\nたぶん、その「集められない」という事実こそが、生活の変数の一つなのだ。\n","date":"2025-08-18T18:27:12+09:00","permalink":"https://blog.yexca.net/ja/archives/252/","title":"漂う学び、ずれた生活"},{"content":" 📢 この記事は gemini-2.5-flash によって翻訳されました はじめに 数日前（2025-08-13）、夢を見たんだ。夢の中で、とあるシリーズの2作目映画『幻夢』のクレジットに僕の名前があったんだよね。監督なのか脚本家なのかは分からなかったけど、この映画の名前も、そのシリーズの制作会社みたいなところの短いフレーズ2つから選ばれただけで、1作目もそうだった。でも、2つの映画に何の関連もなかったんだ。\n映画の内容は夢の中で途中からしか見てないんだけど、画面には二連星の絡み合い、三連星の絡み合い、第二宇宙が出てきて、それから特異点みたいなものがあって、ビッグバンが起こり、宇宙がリセットされ、生命が誕生して、小さな草が土から顔を出す、ってところまで見て、目が覚めたんだ。\n夢の中ではこの映画は『三体』と関係あるって言ってたけど、僕が見た断片を見る限り、どうも関連性はなさそうだった。夢の中で試写会場に行ったら、ほとんど僕だとバレそうな感じで、宣伝も直接『三体』の名前を冠してたけど、まあ、そんなに重要じゃないと思うから、この点は飛ばそうか。\n分析してみた この夢の内容を何度も考えたんだけど、まず二連星・三連星の絡み合いって、それ自体が不安定な構造で、矛盾や不安定さを表してるよね。特異点とビッグバンは、矛盾がもうどうにもならないところまで達して、衝突が爆発するのを表してる。その後の生命の出現や草が土から顔を出すのは、新生を表してるんだ。\nだから、この部分から見ると、不安定な状態、あるいは不安定な絡み合いで、エネルギーが耐えきれなくなって、特異点で爆発し、新生を迎える、って感じなんだ。\n考えてみたこと まず、この映画のクレジットに僕の名前があるんだけど、映画の内容は知らなかったんだよね。しかも夢の中で映画を見てる時は、僕が主演でもあるような気がしたんだ。これって、僕の人生、あるいは僕が経験した何かの出来事を語ってるような気がするんだよね。色々なものが複雑に絡み合ってて、すごく不安定で、僕がそれを爆発させて、破壊と新生を迎える、みたいな。\n三連星の絡み合いのところで、観客なのか弾幕なのか分からないけど、「一番難しいフレーム」って言ってたのが、もしかしたらこの出来事の中で既にすごく不安定だったんだけど、それでも僕が敢えて引き金を引く、っていうのが、難しい決断だったことを示してるのかもしれない。\n新生 最初は、これは希望で、僕の人生で途中の段階にあった何かが転機を迎えることを示してるのかと思ったんだ。でも、後でまた考えてみたら、今の人生には特に転機になりそうなことってなさそうなんだよね。\n色々な角度から考えてみた結果、映画のタイトル『幻夢』からアプローチしてみることを思いついたんだ。どうも僕の最近の経験が「幻の夢」だったってことを表したいみたいで、僕が自らそれを突き破って、新生を迎えるべき、ってことなのかな。\nあるいは、僕が矛盾を激化させて、爆発的な破壊を迎える可能性も、必然性もあるんだけど、その結果として僕自身の変革を遂げるのかもしれない。\n気づき 僕は自分の中に合理的な意思決定システムを構築してて、自分の人生って、まるでリハーサルの選択をしてるだけみたいに感じてたんだよね。あの頃の僕は、生きてるんじゃなくて、機械的に「どうすればもっと良くなるか」って選択をしてたみたいだった。\n選択肢が増えるにつれて、僕はいつも幅広い可能性から物事を見てたから、一見良さそうに見えても、以前僕が考えた通り、自分の人生に自分の感覚がなくなってたんだ。『幻夢』と同じで、監督は僕、主人公は僕、でもストーリーは知らなくて、ただその映画を、僕の人生を見てるだけ、みたいな。\n自分の感情を考慮し始めてから、自分の好き嫌いの優先順位を上げようと試すようになったんだ。最初はすごく良かったんだけど、その後、自分の感情にゆっくりと溺れていくうちに、次第に幅広い合理的な判断力を失っていった。これが『幻夢』なんだろうね。完全に自分の感性にどっぷり浸かって、もしかしたらすごく素敵なことかもしれないけど、結局はただの夢なんだ。\nだから、僕は理性を欠いた、この不安定な状況の中で、特異点を探して、自分から全てを終わらせ、自分自身の心理的な変革を遂げ、新生を始めるんだ。\n振り返ってみて これって、ほとんど完全に理性的な生活と、ほとんど完全に感性的な生活を経験した後の、僕の心の変革だと思うんだ。極端な考え方は良くないって気づいたんだよね。人生って、もともと複雑に絡み合ってるから、何か一つのことで判断できるものじゃないんだ。\nあまりに合理的すぎると、細かな感情が欠けてしまうし、あまりに感情的すぎると、生活がかなり混乱してしまう。このバランスって、掴むのが難しいかもしれない。でも、人生って、まさに「幻の夢」じゃないかな？自分が監督で、自分が主役なのに、その先が分からない、っていう。\n追記 この記事自体もすごくまとまってないんだけど、これってまさに、僕が混乱の中で分析して、特異点を探してるってことの証明じゃないかな？そして今回の特異点は、これを書き上げて公開すること。これで僕のブログも更新停止を打ち破って、新生を迎えるんだ 😂\n","date":"2025-08-17T01:13:32+09:00","permalink":"https://blog.yexca.net/ja/archives/251/","title":"幻夢"},{"content":" 音に感じてシリーズ 曲 翻訳 リンク 僕が死のうと思ったのは 略 https://blog.yexca.net/ja/archives/214 あくあ色ぱれっと 略 https://blog.yexca.net/ja/archives/219 恋の押し売り 略 https://blog.yexca.net/ja/archives/220 17さいのうた 略 https://blog.yexca.net/ja/archives/224 drop 恋に落ちた https://blog.yexca.net/ja/archives/230 生きるを選んだ私へ 略 https://blog.yexca.net/ja/archives/239 rainy lady 雨女 https://blog.yexca.net/ja/archives/249 恋しくなったら手を叩こう 略 この記事 まえがき 📢　この部分は ChatGPT によって翻訳されました。　声と曲の雰囲気、めちゃくちゃ合ってて最高。\u0026ldquo;せーのっ\u0026rdquo; から始まるあの感じ、ふわっとした青春っぽさが広がって、すごく爽やかで甘い雰囲気の曲だなって思った。\n新曲（2025.06.04リリース）だから、その日に通知が来て、聴いた瞬間「これ訳したい！」って思って、そこからずっとリピートしてた。ちょっと頑張って、なんとなく透明感のある感じに仕上げたつもり。なるべく自分の中で「ここ気持ちいいな」って思えるところを意識して、短めのフレーズに合わせて訳してみた。\nでもやっぱり新曲だから、「音に感じて」ってシリーズで言うと、正直そんなに深い感情まではないかも。昔から聴いてる曲ほどの共鳴はないかな。この曲はなんというか…Honey Lemon Soda みたいな、日常にちょっとだけ甘さをくれる、そんな存在。\n動画 歌詞 ある時の日常が\n寂しくなっちゃって\n朝が怖くなって\n今眠れないのかい\n大人になったらさ\n治ると思ってた\n自己肯定感が\n溶けてく毎日かい\n耳に張り付いた君の涙声\nこんなにつらいから\nこの夜だけは2人で歌いましょう\n甘いお砂糖に溶けるように\n回る空気にほら舞うように\n君と踊る 君と踊る\nウォーアイニー\n最後までさ\n浮かず空色付くまでに\nその言葉が灰になる前に\n君と歌う\nそれもそれでいいな\nせーのっ\n恋しくなったら手を叩こう\n明日の前笑顔で手を叩こう\n幸せの意味も知らんけど\n今日だけは笑顔で叩こう\n少しだけ深呼吸して\n君はまだ君で居られる\n生きてゆく意味も知らんけど\n恋しくなったら手を叩こう\nココロの空調が\n整えらんなくて\n頬を伝う音に\nふと戸惑っちゃったのかい\nなんにも知らないよ\nこの世の定理とか\n誰か偉い人が\n教えてくれたらね\n震えるつま先\n明日の前でさ\nなんとか踏ん張って\nこのまま夜を2人で歌いましょう\n甘いお砂糖に溶けるように\n回る空気にほら舞うように\n君と踊る 君と踊る\nウォーアイニー\n最後までさ\n浮かぶ空色付くまでに\nその言葉が灰になる前に\n君と歌う\nそれもそれでいいな\nせーのっ\n恋しくなったら手を叩こう\n明日の前笑顔で叩こう\n幸せの意味も知らんけど\n今日だけは笑顔で叩こう\n少しだけ深呼吸して\n君はまだ君で居られる\n生きてゆく意味も知らんけど\n恋しくなったら手を叩こう\n","date":"2025-06-07T01:09:19+09:00","permalink":"https://blog.yexca.net/ja/archives/250/","title":"音に感じて - 《恋しくなったら手を叩こう》"},{"content":" 📢　この部分は ChatGPT によって翻訳されました。　このシリーズの記事、正直「日本語学習」に役立つことはほとんどないし、検索にも引っかかる可能性あるから、シリーズ名を実態に合わせて変更することにしました。 まあ、なんというか……ほとんどは自分の音楽に対する感想メモって感じかな。歌詞の翻訳も、基本は自分が聴いて感じたままの解釈で書いてるので、原文とずれてるところもあると思います。\n音に感じてシリーズ 曲 翻訳 リンク 僕が死のうと思ったのは 略 https://blog.yexca.net/ja/archives/214 あくあ色ぱれっと 略 https://blog.yexca.net/ja/archives/219 恋の押し売り 略 https://blog.yexca.net/ja/archives/220 17さいのうた 略 https://blog.yexca.net/ja/archives/224 drop 恋に落ちた https://blog.yexca.net/ja/archives/230 生きるを選んだ私へ 略 https://blog.yexca.net/ja/archives/239 rainy lady 雨女 この記事 恋しくなったら手を叩こう 略 https://blog.yexca.net/ja/archives/250 まえがき 📢　この部分は ChatGPT によって翻訳されました。　この曲の感想は……なんていうか、実はこの曲と出会ったきっかけは、前に書いたこの記事でもう話してたりするんだよね → https://blog.yexca.net/ja/archives/243/ 。 初めて聴いたとき、特に冒頭のあの数行が、当時の自分の気持ちとぴったり重なってて、すごく印象に残ってる。\nもちろん、そう感じたのは最初のあの部分だけで、後半は当時の日本語力じゃあんまり聞き取れなかったし、正直今でも訳してて「？？？」ってなるとこ多い（ てか訳してもあんま分かんない ）。全体としては、なんだか無力感というか、「自分ってちっぽけだな」って思わせられるような感覚があった。 この世界にはすごい人がたくさんいて、みんなキラキラしてて……羨ましくて、でもちょっと悲しくなる感じ。\nたぶん、自分が普段からボーカルなしのエレクトロ系ばっか聴いてるせいで、歌を聴くときって、歌詞よりも主観でイメージを乗せて楽しむことが多いんだと思う。 現実でかわいい女の子を見かけたり、すごい人と出会ったときとか、よくこの曲の冒頭がふと頭に浮かんでくる。 それは、尊敬とか憧れとかに混じって、「でも自分は……」みたいな、ちょっと切ない気持ちも入り混じった、なんとも複雑な感情。\nあとから改めて歌詞を読んでみて……どう言えばいいんだろう、「恋愛」って要素を抜きにしても、未来へのモヤモヤとか不安みたいなのが読み取れる気がする。 もちろん完全に恋バナじゃないとは言い切れないけど、「好きなことをやりたいけど、うまく言い出せない」みたいな気持ちは、別に恋愛に限らないんじゃないかなって。\n2025.05.26 この曲、歌ってみた。冒頭以外はぜんぜんついていけなくて、メロディもよく分からずグダグダだったけど、まあ楽しかったからOK（笑） ちなみに《粛聖!!ロリ神レクイエム☆》の原動画見つけて、ついでに歌ってみたら……なんか知らんけど、めっちゃ気持ちよかった（doge）\n動画 歌詞 は～ぁ可愛いいなぁ\nめっちゃキラキラしててすごいなぁ\n素直でいいなぁ\n人気者ってホントすごいなぁ\n面白くっていいなぁ\n友達沢山いるしすごいなぁ\n勝手に目が追っちゃうなぁ\n君色に染まちゃってるみたいな\nちょうどいい距離にいるのかな\n居心地が良すぎて眠たいわ\n散々してたシミュレーション\nリハーサル通りいかないものね\nいつも曖昧なままのふたりの温度\n答えなんて何も聞きたくないわ\nどうかしてるかな\n今日も rainy lady\nまだ まだ まだ まだ 雨模様みたい\n切ない距離と 気まずいシチュエーション\n期待なんてほんの1ミリくらい\nあぁついてないなぁ 大きな雨粒\nあぁ流れていく\nあっ 突然バッタリ会ったり\n脳内 君ばっかりだったり\n笑ったり怒ったり泣いちゃったりも\nちゃっかりしちゃったり?\n本来ドンマイ sorry もー無理\nしっかりもうコリゴリ\n一回グッバイさっぱり\nバイバイした方がいいのかな\nどんな言葉が どんな魔法なら\nどんな恋なら君にまで届くかな\nヒトリゴトが捗る雨フリの日々に\n明るい話題もまるでウワノソラ\nどうかしてるよね\nいつも rainy lady\nてるてるぼうずも悲しそうにしてる\n途切れ途切れに降り続く雨から\n想定外の贈り物なんて\nそっと傘の中 また降り出した\nAh\n空の合間に見えた淡い晴れ模様\n答えてほしいけど聞きたくなくて\nなんて意気地なし いつだろう sunny day\n悲しいくらい天気雨\nそっと集めつづけた沢山の思いが\n無意識に淡々と溢れてきちゃう\n何でもないよ 君がいるなら\n雨女でいいや\n君がいるから oh\nOh, sunny boy\nRainy lady\n","date":"2025-05-20T23:44:07+09:00","permalink":"https://blog.yexca.net/ja/archives/249/","title":"音に感じて - 《rainy lady》"},{"content":" 📢　この記事は ChatGPT によって翻訳されました。また、このソフトウェアは中国語簡体字のみです。　元々はちょっとしたものを適当に書くつもりで、二三日で飽きる予定だった（いつも大体そう）。でもバグらずに動いてくれることで時間めっちゃ節約できたし、どんどん使いやすくなっていった。\nそうすると以前思ってた「SQLite 使えばよくない？」って発想がよみがえってきた。確かに、毎回 MySQL 起動するのはめんどすぎるって話。で、今回のバージョンが生まれたわけ。やっと DB サービス起動しなくても使えるようになった～ （やっと人間が使えるものになった）\n使用方法 項目地址: https://github.com/yexca/PixivDownloader-SQLite GUI は前バージョンと似てるから、 https://blog.yexca.net/ja/archives/211/ を見ればわかる。\n設定について 使う前に設定が必要：\nrefresh token（Pixiv のログイン認証。参考: Pixiv OAuth Flow ） ダウンロード先（デフォルトは D:\\Downloads） ダウンロードの仕方 その後は以下のどちらかを入力すれば OK：\nイラストレーター ID、または 作品 ID（両方入れた場合はイラストレーター ID 優先） 「下载」ボタンを押せば、全作品をダウンロードして DB に記録してくれる（記録がない場合は全部、記録がある場合は未ダウンロードのやつだけ）。\nエラー処理 プログラムのエラー処理は基本的にクローリング関係だけやってる。エラーポップアップが出たら、以下の問題が考えられる：\nrefresh token が設定されてない、または無効 イラストレーターアカウントが存在しない 作品が存在しない エラーの内容は詳しく出してないから、この3点をチェックしてみて。\nそれ以外（ソフトごとクラッシュとか）のエラーは 程序根目录/logs/app_*-*-*.log にある最新ログを送ってもらえれば、こっちで見ます。\n連絡先：PixivDownloader#yexca.net（@ に変えてね）\n新機能：MySQL から SQLite へ 一番の変更点は、MySQL を自分で用意しなくていいってところ。軽量な SQLite に切り替えた。\nそれで DB 設定とか全部いらなくなって、Pixiv の認証トークンとかと一緒に設定ファイルにした。\nあと icon も入れた（ChatGPT に適当に描かせたやつ）。UI も少しだけ調整したけど、そんなに変えてない。\nコードも一応構造化し始めたけど、最後の方はまたグチャった。まあ、いつかまた書き直すかもね\n旧 MySQL データベースからの移行方法 まあ前バージョン使ってる人いないと思うけど、一応書いとく。\nDB 構造の違いで、直接 SELECT して INSERT 文として出力するのが一番楽。こんな感じ：\n1 2 3 SELECT ID, name, downloadedDate, lastDownloadID, url FROM pic WHERE platform = \u0026#39;pixiv\u0026#39;; 出力は SQL の INSERT 文にしてね（Dataflare ってツールがその機能ある）。\nそのあと、Python ファイルを用意して以下を入れる：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 import sqlite3 conn = sqlite3.connect(\u0026#34;pixiv.db\u0026#34;) cursor = conn.cursor() cursor.execute(\u0026#39;\u0026#39;\u0026#39; Create Table If Not Exists pic ( ID TEXT PRIMARY KEY, name TEXT, downloadedDate TEXT, lastDownloadID TEXT, url TEXT ) \u0026#39;\u0026#39;\u0026#39;) conn.commit() cursor.execute(\u0026#34;\u0026#34;\u0026#34; INSERT INTO `pic` (`ID`, `name`, `downloadedDate`, `lastDownloadID`, `url`) VALUES (\u0026#39;123\u0026#39;, \u0026#39;name1\u0026#39;, \u0026#39;2024-06-08 00:00:00\u0026#39;, \u0026#39;1234\u0026#39;, \u0026#39;https://www.pixiv.net/users/123\u0026#39;), (\u0026#39;234\u0026#39;, \u0026#39;name2\u0026#39;, \u0026#39;2025-02-12 00:05:36\u0026#39;, \u0026#39;2345\u0026#39;, \u0026#39;https://www.pixiv.net/users/234\u0026#39;), (\u0026#39;345\u0026#39;, \u0026#39;name3\u0026#39;, \u0026#39;2025-01-11 17:26:17\u0026#39;, \u0026#39;3456\u0026#39;, \u0026#39;https://www.pixiv.net/users/345\u0026#39;); \u0026#34;\u0026#34;\u0026#34; ) conn.commit() cursor.execute(\u0026#34;\u0026#34;\u0026#34; Select * from pic \u0026#34;\u0026#34;\u0026#34; ) rows = cursor.fetchall() for row in rows: print(row) conn.close() cursor.execute の中身を自分のバックアップ SQL に差し替えて、例として3件残しておいた。\nその後、できた pixiv.db を 程序根目录/resources に置けば OK。\nちょっとした開発感想：「グチャグチャ」から「混乱の理解」へ そういえば今回の開発、前回コードがグチャグチャすぎたのが気になって手を入れようとしたんだけど、途中で「あ～そりゃ前回グチャるわ」って理解した😂\nむしろ今回の方がさらにグチャったまである。途中から「もうリファクタやめてコピペでいいか」ってなって、キャメルケースとスネークケースが混ざるカオスが爆誕した。もう触りたくない。はぁ。\nとはいえ、動いてるし、使えるならまぁいいか～\n","date":"2025-05-18T16:20:33+09:00","permalink":"https://blog.yexca.net/ja/archives/248/","title":"Pixiv ダウンローダー再構築記：グチャグチャから混乱の理解へ"},{"content":" 📢 この記事は ChatGPT によって翻訳されました はじめに 最近、自分が次に何をやるか、何を学ぶかって考えてる時に、やたら目に入ってきたのが「DevOps」って言葉。最初ちょっとググったら、載ってる技術スタックはだいたい知ってるやつばっかで、「あーこれは全栈エンジニアみたいなもんか」って思ってた（まぁ実際ちょっと似てる気もする）\nでも興味がなかったから放置してた（というより開発熱が冷めてた）\nんで最近、4ヶ月くらい寝転がってて「やば、さすがに動かなきゃ」ってなって、またこの言葉を思い出した。改めて調べてみると……いやこれ、巻き込み力すごくね？フロントエンドとバックエンド分けても人間は一緒だし、今度は開発と運用も分離してるのに人間はやっぱり一緒、みたいな\nただ思い返すと、GitHub Action で自動化できるって話を見た瞬間に、Jekyll の時代を思い出した。あの頃は自動デプロイあったんだよね。でも自分は他のブログから移行してきて、サブフォルダ分類のクセが抜けず、それが対応してなかったから深掘りしなかった。\nでも今こそ、その Hugo ブログで自動デプロイできるか試してみたくなったわけ。毎回コンテナから pull してアップロードするの地味にめんどくさいしね\nワークフロー ワークフローの作成は、Git リポジトリのルートにある .github/workflows/ フォルダに YAML ファイルを置く形で定義する。ファイル名は自由だけど、今回はデプロイだから deploy.yml にした。\n構成は大きく「名前」「トリガー」「ジョブ」の3つ。\n名前 ここは適当でいい。とりあえず名前つけるだけ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 name: Build and Deploy Hugo Blog ~~~ ### トリガー Action Workflow にはいろんなトリガーがあるけど、今回は記事追加したとき（Push）に動けばいいかなって感じ。 あと手動トリガーも入れておく。GitHub 側の設定ミスとかで再実行したいとき用。 ```yaml on: push: branches: - main workflow_dispatch: ジョブ ジョブは複数定義できて、それぞれ並行で動く。今回は一個だけ。\nまずジョブ名を決める。\n1 2 jobs: build-deploy: 次にどの OS 上で実行するかを指定。今回は Ubuntu。\n1 2 3 jobs: build-deploy: runs-on: ubuntu-latest そして具体的なステップ。まずリポジトリのチェックアウト。\n1 2 3 steps: - name: Checkout source uses: actions/checkout@v4 続いて Hugo のセットアップ。\n1 2 3 4 5 - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#39;0.140.1\u0026#39; extended: true Hugo サイトのビルド。\n1 2 - name: Build Hugo site run: hugo --minify 最後に GitHub Pages 用リポジトリに push。\n1 2 3 4 5 6 7 - name: Deploy to BlogWeb repo uses: peaceiris/actions-gh-pages@v3 with: external_repository: yexca/Blog-Web-Hugo publish_branch: main publish_dir: ./public personal_token: ${{ secrets.PERSONAL_TOKEN }} 全部まとめるとこんな感じ：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 name: Build and Deploy Hugo Blog on: push: branches: - main workflow_dispatch: jobs: build-deploy: runs-on: ubuntu-latest steps: - name: Checkout source uses: actions/checkout@v4 - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#39;0.140.1\u0026#39; extended: true - name: Build Hugo site run: hugo --minify - name: Deploy to blogWeb repo uses: peaceiris/actions-gh-pages@v3 with: external_repository: yexca/Blog-Web-Hugo publish_branch: main publish_dir: ./public personal_token: ${{ secrets.PERSONAL_TOKEN }} トークン設定 他のリポジトリに push するにはトークンが必要。作り方は：\nSettings -\u0026gt; Developer Settings -\u0026gt; Personal access tokens -\u0026gt; Fine-grained tokens に進んで、対象リポジトリに書き込みできるトークンを生成。\nそのあとソースリポジトリ（俺の場合は yexca/Blog-Source-Hugo）の Settings -\u0026gt; Secrets and variables -\u0026gt; Actions の Repository secrets に追加。名前はワークフローに書いた通り PERSONAL_TOKEN にする。\n独自ドメインの設定 GitHub Pages を独自ドメインで使うには CNAME ってファイルにドメインを書いておく必要がある。\nでも GitHub Actions でデプロイするとき、既存のファイルが全部削除されて push されるから CNAME も消える。だからワークフローでファイルを生成する必要がある。\n方法は2つ：\nワークフロー内で CNAME を作成： 1 2 3 steps: - name: Add CNAME run: echo \u0026#39;blog.yexca.net\u0026#39; \u0026gt; public/CNAME Hugo の static フォルダに CNAME を入れておく（ビルド後そのまま出力される） テーマモジュールの問題 使ってるテーマが Git SubModule 経由だったから、そのまま push してもリンクだけで中身がない。自分の変更は push されないってこと。\nテーマをバックアップ 1 cp -r themes/Hugo-Theme-Stack tmp/Hugo-Theme-Stack-Backup SubModule の削除 初期化：\n1 git submodule deinit -f themes/Hugo-Theme-Stack Git から削除：\n1 git rm -f themes/Hugo-Theme-Stack 関連フォルダを削除：\n1 rm -rf .git/modules/themes/Hugo-Theme-Stack .gitmodules ファイルも削除：\n1 rm .gitmodules テーマを復元 1 cp -r tmp/Hugo-Theme-Stack-Backup themes/Hugo-Theme-Stack テストして問題なければバックアップ削除：\n1 rm -rf tmp JS エラーの修正 昔書いたブログ稼働時間コードで、古い書き方の 8 進数を使ってたせいで、hugo -minify したときにエラーが出た。\n元のコード：\n1 Date.UTC(2021, 10, 06, 14, 15, 19) 修正後：\n1 Date.UTC(2021, 10, 6, 14, 15, 19) 結び やっとローカルでの構築作業から解放された。Docker を使い始めた頃から、ローカル環境と開発環境は分けたいって思うようになって、ずっとコンテナで作業してた。\nでも今回で完全にローカルどころかクラウドに全部任せるようになって、もはや “環境潔癖症” を克服したとも言えるかも。\nで、改めて DevOps って考えてみると、これも結局、技術の進化が進みすぎた結果なのかもしれない。\n昔は機械ごとに環境合わせて、アセンブリ書いて、それが高級言語になって、さらにコンテナで環境障壁が壊れて、どんどん簡単に効率良くなってきた。けど、そのたびに「入門ライン」も引き上がってんだよね。\n確かに便利になったけど、同時に「ついていけなきゃ職失うスピード」も速くなってるってわけ。\nまあでも、仕事は仕事、生活は生活。技術は早いけど、世界や業界の変化はそこまで速くない……はず。少しくらいは休む余裕もある、よね。\n","date":"2025-05-16T18:14:06+09:00","permalink":"https://blog.yexca.net/ja/archives/247/","title":"DevOps を取り入れて：ブログの構築とデプロイを GitHub に任せた話"},{"content":" 📢 この記事は ChatGPT によって翻訳されました はじまり また自己紹介のタイミングで、ふと思い出したのが自分のブログだった。\n昔は Google で yexca って検索すれば一発で一番上に出てきて、そこからすぐブログに飛べた。\nでもドメインを変更してからというもの、何度検索してもブログはどこにも見当たらなくなった。\n最初はそこまで気にしてなくて、Google の制限とかペナルティみたいなもんかなって思ってた。\n公式には、ドメインを変えるときは 301 リダイレクトを1年間続けるのが推奨されてて、でも俺は半年で旧ドメインの期限切れちゃったんだよね。\nでも、もう2年経ったよ？そろそろ戻ってきてもいいんじゃないの？\nしかもおかしいのは、検索上位に出てくるのは昔のメンテ止まったようなサイトばかりで、\n俺が毎日更新して、調整して、あれこれいじりまくってるこのブログはまるでネットから消えたかのようになってた。\nというわけで原因調査開始 まずはブログを開いて \u0026lt;head\u0026gt; をチェック。\nん？\u0026lt;meta name='description'\u0026gt; がサイドバーに出てくるキャッチコピーになってる？\nあー…そういや、設定のとき「ここに表示されるよ」ってだけ書いてあって、Argon テーマの時と同じようなもんだと思ってたわ。\nつまり、今のサイト説明は意味不明ってことか。\nとはいえ、この言葉は自分のブログ人生をずっと一緒に歩んできたし、簡単に手放したくない。\nだったら、構造化データ（JSON-LD）を使って、説明の役割をそっちに任せればいいじゃん！\nってことで、テーマの \u0026lt;head\u0026gt; カスタムに以下を追加：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;script type=\u0026#34;application/ld+json\u0026#34;\u0026gt; { \u0026#34;@context\u0026#34;: \u0026#34;https://schema.org\u0026#34;, \u0026#34;@type\u0026#34;: \u0026#34;Blog\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;yexca\u0026#39;Blog\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;{{ .Site.BaseURL }}\u0026#34;, \u0026#34;inLanguage\u0026#34;: \u0026#34;{{ .Site.Language.Lang }}\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;{{ .Site.Params.description }}\u0026#34;, \u0026#34;author\u0026#34;: { \u0026#34;@type\u0026#34;: \u0026#34;Person\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;yexca\u0026#34; } } \u0026lt;/script\u0026gt; しかもサイトは多言語対応だから、部分的に変数で言語ごとに適応できるようにした方が良いね。\n言語という迷宮での探索 多言語サイトってことで、じゃあ言語変えて検索してみたらどうなる？って気になって、\ngoogle.com.hk、google.com.tw、google.com.jp で yexca を検索してみた。\n結果は、なんと日本語環境ではちゃんと出てきた。\nでも中国語では出てこない。英語はまぁ記事が少ないから仕方ないか。\nつまり Google 的には https://blog.yexca.net が yexca に紐づいてるのは認識してるっぽいけど、\n言語ごとの評価とかがうまく機能してないのかも？\nさらに調べていくと hreflang の指定が足りないんじゃ？と気づいて、こんな感じで追加：\n1 2 3 4 5 \u0026lt;link rel=\u0026#34;alternate\u0026#34; hreflang=\u0026#34;x-default\u0026#34; href=\u0026#34;https://blog.yexca.net/\u0026#34; /\u0026gt; \u0026lt;link rel=\u0026#34;alternate\u0026#34; hreflang=\u0026#34;zh-CN\u0026#34; href=\u0026#34;https://blog.yexca.net/\u0026#34; /\u0026gt; \u0026lt;link rel=\u0026#34;alternate\u0026#34; hreflang=\u0026#34;zh-TW\u0026#34; href=\u0026#34;https://blog.yexca.net/zh-tw/\u0026#34; /\u0026gt; \u0026lt;link rel=\u0026#34;alternate\u0026#34; hreflang=\u0026#34;ja\u0026#34; href=\u0026#34;https://blog.yexca.net/ja/\u0026#34; /\u0026gt; \u0026lt;link rel=\u0026#34;alternate\u0026#34; hreflang=\u0026#34;en\u0026#34; href=\u0026#34;https://blog.yexca.net/en/\u0026#34; /\u0026gt; これで検索エンジンには「これは多言語対応の同一サイトです」って明確に伝わる。\nちなみに、この \u0026lt;link\u0026gt; はすべての記事ページにも入るようにした。\nすべての言語に翻訳があるわけじゃないけど、Google 側がちゃんと処理してくれるからそのままでOK。\n少しずつ埋める抜け穴 で、試しにどれかの記事を開いたら、「あれ？JSON-LD がまだサイト情報になってるやん？」ってなった。\nこれはちょっと違和感あるなと思って、条件分岐を入れることにした：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 {{ if .IsHome }} \u0026lt;!-- ホーム JSON-LD --\u0026gt; \u0026lt;script type=\u0026#34;application/ld+json\u0026#34;\u0026gt; { \u0026#34;@context\u0026#34;: \u0026#34;https://schema.org\u0026#34;, \u0026#34;@type\u0026#34;: \u0026#34;Blog\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;yexca\u0026#39;Blog\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;{{ .Site.BaseURL }}\u0026#34;, \u0026#34;inLanguage\u0026#34;: \u0026#34;{{ .Site.Language.Lang }}\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;{{ .Site.Params.description }}\u0026#34;, \u0026#34;author\u0026#34;: { \u0026#34;@type\u0026#34;: \u0026#34;Person\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;yexca\u0026#34; } } \u0026lt;/script\u0026gt; {{ else if .IsPage }} \u0026lt;!-- 記事 JSON-LD --\u0026gt; \u0026lt;script type=\u0026#34;application/ld+json\u0026#34;\u0026gt; { \u0026#34;@context\u0026#34;: \u0026#34;https://schema.org\u0026#34;, \u0026#34;@type\u0026#34;: \u0026#34;BlogPosting\u0026#34;, \u0026#34;mainEntityOfPage\u0026#34;: { \u0026#34;@type\u0026#34;: \u0026#34;WebPage\u0026#34;, \u0026#34;@id\u0026#34;: \u0026#34;{{ .Permalink }}\u0026#34; }, \u0026#34;headline\u0026#34;: \u0026#34;{{ .Title }}\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;yexca\u0026#39;Blog\u0026#34;, \u0026#34;author\u0026#34;: { \u0026#34;@type\u0026#34;: \u0026#34;Person\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;yexca\u0026#34; }, \u0026#34;publisher\u0026#34;: { \u0026#34;@type\u0026#34;: \u0026#34;Person\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;yexca\u0026#39;Blog\u0026#34; }, \u0026#34;datePublished\u0026#34;: \u0026#34;{{ .Date.Format \u0026#34;2006-01-02\u0026#34; }}\u0026#34;, \u0026#34;dateModified\u0026#34;: \u0026#34;{{ .Lastmod.Format \u0026#34;2006-01-02\u0026#34; }}\u0026#34;, \u0026#34;inLanguage\u0026#34;: \u0026#34;{{ .Site.Language.Lang }}\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;{{ .Params.description | default .Site.Params.description }}\u0026#34; } \u0026lt;/script\u0026gt; {{ end }} これでホームと記事で異なる JSON-LD が表示されるようになって、\n意味的にも正しいし、Google の構造化データガイドラインにもより適合する。\n小さな願い これでようやく一通り整った。\nもちろん、すぐに結果が出るわけじゃないけど、\nでも、確かに「信号」は送り出されたはず。\nあとはただ、待つだけ。Google がもう一度、俺の存在を認識してくれるのを。\n次に誰かにブログを紹介する時には、\nGoogle を開いて、yexca って検索して、すっと出てくるように。\n","date":"2025-04-27T17:38:16+09:00","permalink":"https://blog.yexca.net/ja/archives/246/","title":"自分の名前で検索されるために：小さなブログの SEO 調査実践記"},{"content":" 📢 この記事の一部は機械翻訳を使ったよ みんながカード使ってるからって、全員が還元目的ってわけじゃない。システム作ってる人だって、全員がエンジニアなわけでもない。 たまにいるんだよね、カード切ってるのに設計者っぽいやつ。システム組んでるのに、生活感があるやつ。\n1. 導入：カードオタクって何？ まず最初に紹介したいのが、どこかで見た「カード勢の七大あるある」：\nここでの「中国本土」とは、資金の出入りに制限がある地域を指している\n中国本土で外貨を使う方法を探す 海外で人民元を使う方法を探す 人民元を国外に持ち出すルートを探す 外貨を中国本土に持ち込む方法を考える 本土でほとんど使えないカードをつくる 海外でさらに使えないカードをつくる 暗証番号の桁数より少ない金額を、ほとんど使い道のないカードの間でぐるぐる回す ※中国本土では銀行のパスワードが6桁で設定されることが多く、「暗証番号より桁が少ない＝金額すら届かないのに頑張って動かしてる」的な自虐ネタ。他地域では異なる可能性あり\n……ね？もうゲーム感覚。 パッと見は、ただカード増やして、ポイント狙って、手数料節約して、レート得する方法探してるだけ。 なんかちょっとセコい技集めみたいに見えるでしょ。\nでも、本気のカード勢ってそうじゃない。\nカードオタクってのは、「数円節約したい人」じゃなくて、複数通貨、複数経路、複数制限の中で最適な資金ルートを構築しようとしてる設計者なんだよね。\n羊毛狙いじゃない。現実世界の構造を掘り下げてるんだ。\n生活っていうシステムを、最適化しようとしてるんだよ。\n2. システムアーキテクトって何してる人？ システムアーキテクトの資格を取ろうとすると、よく出てくる用語がある。 たとえば「モジュールの分離」「パフォーマンス最適化」「インターフェース設計」…… でもね、用語は置いといて、やってることは意外とシンプル。\n制限だらけの現実の中で、リソースを上手く割り振って、ルートを引いて、システム同士をつないで、壊れにくくて柔軟な全体構造を作る\nアーキテクトが考えてるのって、「このコード綺麗に書けた！」とかじゃないし、ただ図を描くのが仕事でもない。 一番重要なのは、複雑な制約がある現実世界の中で、ちゃんと動くシステムになってるかどうか。\nたとえば：\nシステム間で役割をどう分ける？ サービス同士はどうやって通信する？ インターフェースってどう作れば、将来の拡張にも対応できる？ 不具合が起きたら、どうやって見つけて影響を最小限にする？ 予算が限られてるとき、どこまで性能とコストのバランスを取る？ アーキテクトって、レゴビルダーっぽくもあるし、道路設計者っぽくもあるし、バグだらけの街を修理してる職人みたいでもある。\n最初から綺麗な地図なんてない。バグってたり、壊れてたりする世界の中で、少しずつルートを整えて、橋を補強して、構造を変えて、流れをスムーズにしていく。\nつまりは、現実的な制約の中で、「ちゃんと動いて、あとから直せて、維持費が払える」システムを設計するってこと。 カッコいい技術を見せるんじゃない。「完璧な設計」を目指すんじゃない。 とにかく壊れずに回り続けること。壊れても止まらないこと。それがアーキテクトの美学なんだよ。\n自分はこの話、資格試験のために勉強したんだけど…… 気づけばまたカード遊びに夢中になってたんだ。\n3. カードオタクの「構造的課題」って？ ただの節約マニアだと思ってた？違う違う。 アーキテクトが「お堅いエンジニアの世界」に生きてるって思ってた？それも違う。\n一見バラバラに見えるけど、カードオタクもアーキテクトも、根っこは同じことをやってる：\nルールが複雑で、コスト制約があって、正解が見えない中で、最適なルートと構造を探す。\nカード勢はカードを作る人じゃなくて、「資金の流れを設計してる人」 システムアーキテクトはコード書く人じゃなくて、「情報と制御の流れを設計してる人」\nカード勢が悩むのは： 「どうやったら手数料減らせる？リスク管理回避できる？制限の中でうまく流せる？」\nアーキテクトが考えるのは： 「どうやったら障害少なく？拡張性高く？現場で安定して動かせる？」\n試験勉強で学んだアーキテクトの思考法、振り返ってみたら、 これ……カード組んでるときと全く同じじゃんって気づいたんだよね。\nカード世界 アーキテクト世界 コア思考 手数料 レイテンシや性能コスト コスト最適化 通信ルートの制限 APIコール制限 プロトコル適応力 カードの発行ルール モジュールの設計ルール 規格・コンプライアンス 為替や通貨制限 クロスプラットフォーム対応 環境適応性 カードの種類が多すぎる 技術スタックの多様性 システム統合設計 銀行の風当たり システムのセキュリティ リスク設計 カード間の資金移動経路 データフロー設計 経路・構造デザイン カードやってるのって、別に儲けたいとかじゃないんだよ。 やってること、ほぼ構造設計なんだよね。\n「どのカードが一番得か？」じゃなくて、 「どうやって一番効率よく、損せず、リスク回避しつつ、お金を流すか？」を考えてる。\nポイントは「できるか」じゃなくて、「美しく流れるか」。 送れるかどうかじゃなくて、「そのフローに無駄や詰まりがないか」。\nカード勢がやってるのは、ある意味「複雑制約付きの最短経路問題」解いてるみたいなもん。 アーキテクトが設計するのは、「モジュール間の結合度やSLA制限を考慮した構成の最適化」\nね？ほぼ一緒でしょ。場所が違うだけで、やってること変わらんのよ。\n4. 地図を塗るように構築する日常ルート 他人は還元狙い、自分は生態系を解き明かしてるつもり。\nカード勢のルートって、本当に人それぞれ。 使ってる銀行も、口座の種類も、持ってる通貨も、ライフスタイルすらバラバラ。\nだから面白いのは攻略サイトをなぞることじゃなくて、自分の条件下で、自分だけの最適解を試行錯誤で見つけること。\n最初はただ「手数料ちょっとでも減らせないかな～」くらいで始めたんだけど、調べれば調べるほど奥が深い。 銀行ごとに振込条件も違うし、時間帯によって無料だったり、特定通貨じゃないと跳ねられたり、なぜか理由もなく止められたり。\nまるで最初は真っ黒なマップのゲームみたいに、ちょっとずつルートを開拓して、通れる場所を増やして、チェックポイントをマークしていく感じ。\n小さな額で何回も試して、失敗して、やり直して……その繰り返しで、 自分にとって「コストが許容できる通り道」が見えてくる。\nやがて「高コストの地雷ルート」を避けながら、レートのタイミングすら読んで浮き分を狙ったり、 そのうち「この通貨経由すればもうちょい節約できるかも」ってルート最適化まで始まる。\n中には最初から「絶対無理でしょ」って思ってたルートも、 試してみたら意外と通ったりするんだよね。\nたとえば：\n暗号通貨を使って資金移動できる取引所を経由してみたり 実生活で仮想通貨をそのまま使ってみたり フィアット通貨→ステーブルコインの自動化ルートを組んだり マイナーな国向けに特化した送金アプリを使ってみたり こうして銀行システムを迂回して、無理だと思ってた送金もいつの間にか実現できてたりする。\nこれってまさに、ネットワークアーキテクチャを再設計する感覚。 単なる送金じゃない。\n「価値」と「情報」を運ぶルートを、自分で定義し直してるんだ。\n5. カードで鍛えられるアーキテクト的センス 日々のルート選び、失敗とリカバリ、コストの見直し、リスクの見積もり……カード勢が普段やってること、実はめっちゃアーキテクトの訓練っぽい。\nサーバーもコードも使ってないけど、「構造を安定させて効率を高める」っていう思考は、まんまシステム設計のそれ。\n気づかないうちに、こんなスキルが身についてた：\nスキル 実際の行動 アーキテクトっぽさ ルール把握 銀行ごとの上限・仕様を把握 ドキュメント読解力 統合力 複数カードの連携・連結 システム統合の視点 コスト意識 手数料を可能な限り削る 性能とコストのバランス設計 モデル構築力 資金フローをルートで見える化 構造モデリングのセンス リスク対策 複数口座・バックアップ経由の構成 高可用性・冗長構成の考え方 美意識 「お金も、スマートに流れるべき」 設計美学、エンジニアの美意識 カードで遊んでるように見えて、現実世界でアーキテクトの脳みそを鍛えてる……そんな日常ってちょっとカッコよくない？\n6. 思考が整った瞬間に気づいたこと 手数料は敵。ルートは信仰。そして流れは芸術。\nオレがカードにハマったのは、ポイントが欲しかったからじゃない。 何度も試して、計算して、構造を調整して……その中で「流れの美しさ」に気づいてしまったから。\nコードも書かないし、サーバーも持ってないけど、 1つ1つの資金移動、設計したルート──それ全部が、自分の中のアーキテクチャだった。\n試験のためにアーキテクトの知識を詰め込んで、 でも日常の中でカードを回してるときの方が、ずっとその感覚をリアルに感じてた。\n好きなのは「やり切ること」じゃなくて、「ルートを気持ちよく設計すること」なんだ。\n他人から見たら「小手先の裏技」、でも自分の中では「構造の美学」。 「ただのポイント厨」って言われても、心の中では「生活アーキテクト」やってる。\nカードオタクって、たぶん「節約術」とか「投資ノウハウ」じゃない。 これは日常の中で、自分のシステム思考を育てていくリアルな実験場なんだと思う。\n問題を可視化して、ちょっとずつ改善して、構造を組み替えて、美しく仕上げる。 それが楽しい。\nカードは節約じゃなくて訓練だし、アーキテクチャは発明じゃなくて選択なんだ。 「いくら得したか」でも「どれだけコード書いたか」でもない。大事なのは、世界のロジックを自分の中に落とし込んだかどうか。\nそして今日も、ATMの前で10分考え込む。 「こっち経由した方が手数料安いかも」って脳内シミュレーションしながら。\nたぶんオレ、サーバーは動かしてないけど、ちゃんと設計してる。\n結論：人生こそが、最強のアーキテクチャ カードを切る、送金する、ルートを考える、最適な組み合わせを選ぶ──その全部、じつは目に見えない「システム設計」なんだよね。\nアーキテクチャって、サーバーとかAPIだけじゃない。ときには、財布やカード、支払い方法の間にひっそりと潜んでる。\nカード最適化の果てにいるのは、羊毛ハンターじゃない。\n──そこにいるのは、たぶん「生活アーキテクト」だよ。\nおまけ：オレの資金ルート（コードで書いてみた） このコード、実行用じゃないよ。ただの日常資金フローを建築っぽく書いてみただけ。「オレ、こう考えて動かしてるよ」っていう思考モデル。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // 海外送金ルート（イメージ） func RouteCNYtoJPY(CNY float64) JPY float64 { HKD := BOCExchange(CNY, to=\u0026#34;HKD\u0026#34;) log.Printf(\u0026#34;Exchanged %.2f CNY to %.2f HKD\u0026#34;, CNY, HKD) Transfer(HKD, from=\u0026#34;BOC\u0026#34;, to=\u0026#34;BOCHK\u0026#34;, by=\u0026#34;pbservice\u0026#34;) log.Println(\u0026#34;Transferred via pbservice → BOCHK\u0026#34;) Transfer(HKD, from=\u0026#34;BOCHK\u0026#34;, to=\u0026#34;Wise\u0026#34;, by=\u0026#34;fpservice\u0026#34;) log.Println(\u0026#34;Transferred via fps → Wise\u0026#34;) JPY := WiseConvert(HKD, to=\u0026#34;JPY\u0026#34;) log.Printf(\u0026#34;Converted %.2f HKD to %.2f JPY via Wise\u0026#34;, HKD, JPY) Deposit(JPY, to=\u0026#34;Revolut\u0026#34;, with=\u0026#34;ApplePay\u0026#34;) return JPY } 実行じゃなくて表現用のコード。生活の資金流れを、設計図っぽく組んでみた結果ってだけ。\n※この文章はあくまで個人の趣味と記録として書かれたものであり、金融アドバイスなどを意図したものではありません。ネタとしてお楽しみください。\n","date":"2025-04-22T00:35:15+09:00","image":"https://github.com/yexca/picx-images-hosting/raw/master/2025/04-FromCardEnthusiastToArchitect/250422-JP.3d4zmh3vn7.webp","permalink":"https://blog.yexca.net/ja/archives/245/","title":"カードオタクからアーキテクトへ：生活に宿るシステム設計の哲学"},{"content":" 📢 この記事の一部は機械翻訳を使ったよ 2023年4月、私は家計簿をつけ始めた。2025年4月、記帳をやめた。\n最後の記録：¥0\n始まり：節約とコントロールのために きっかけはシンプルでした——支出を抑え、金銭感覚を高めること。最初は確かに効果的で、無駄遣いを抑えることができました。\n過程：最適解とカード収集の世界へ しかし次第に、「より良い」消費を求めて比較を始め、最適解を探すようになりました。最初は商品の比較だけでしたが、やがて支払い方法やツール、そして銀行の特典やカード開設の世界へと進みました。\n特典のためにカードを作り、便利さのためにカードを作り、気づけばカード収集の世界にどっぷりと浸かっていました。\n最初は節約のため、次に便利さのため、そして最後にはカードを集めるため。\n反作用：記帳が負担に こうして、記帳そのものが次第に負担となっていきました。アカウントが増え、シチュエーションが複雑になるにつれ、記帳にかかる時間や精神的なコストは実際の利益を上回るようになりました。​\n数百円の特典のために何時間も調べることもありました。最初は楽しかったものの、何度も繰り返すうちに、最適解を見つけても興奮しなくなり、最初の喜びは空虚感に変わっていきました。\n変化：最適解から心地よさへ もしかすると、私自身が変わったのかもしれません。消費に対する考え方も変わりました。\n「必要に応じてお得に」から「まあまあでいい、自分が心地よければいい」へ。​\nまた、設定した予算をすでに超えていることにも気づきましたが、それでもコントロールを失うことはありませんでした。むしろ、節約よりも時間と気持ちの方が大切だと、ますます理解するようになりました。\n反省：なぜ記帳していたのか？ 記帳のために、私は以下のようなことを始めました：​\nアカウントが多いため、何度も探し回る​ 通貨の変換のために、記帳アプリで新しいアカウントを頻繁に作成​ 商品を買うべきかどうかで長時間悩む​ 友人と遊びに行った際の支出で気分が台無しになる​ 私は考えざるを得ませんでした——私はなぜ記帳していたのか？\nその中で得られる利益は、本当に価値があるのか？​\n決断：手放し、リセット、再出発 そこで私は、細かいことを気にせず、「私は幸せか？」と自問することにしました。\n結果は——本当に幸せでした。そして、支出も思ったほど多くはありませんでした。\nおそらく、習慣が私を自然に価格比較へと導いていたのでしょう。あるいは、感情の価値は、そもそも特典で測れるものではないのかもしれません。​\nだから、手放す時が来たのだと思います。​\n記帳は、その使命を果たしました。\nもはやツールではなく、束縛となっていました。​\n行動習慣は、より良い生活のためのもの。\nそれが情熱で解消できず、生活の妨げとなるなら、別れを学ぶべきです。​\n終わりに：自分に感謝し、生活を続ける 2年間続けてきた習慣を手放すのは、確かに寂しいものです。\nでも、それも人生の一部なのでしょう。一生を共にできるものはありませんが、一緒に過ごした時間が美しいものであれば、それで十分です。​\n「私は節約上手」という象徴的なツールが一つ減ったとも言えます。\nしかし、これからの自分は、数字や記録に頼って安心感を得るのではなく、真の余裕と自由さで生きていきたいと思います。​\nコントロールできる状態から、未知への流れへ。\n早く適応できることを願っています。\n節約した時間を、より意味のある、より幸せなことに使えるように。​\nだから、\n最後の一筆、¥0 短い文章を添えて。 この2年間、真剣に記録してきた自分にありがとう。 これからは、節約した時間をもっと価値のある、もっと楽しいことに使えますように。​\nこのように、この体験をアーカイブしました。\nレコーディングは終わり、人生は始まったばかり\n","date":"2025-04-14T16:23:48+09:00","permalink":"https://blog.yexca.net/ja/archives/244/","title":"節約から生活、そして別れへ"},{"content":" 📢 この記事は ChatGPT によって翻訳されました 専門系の学習記事をブログに投稿するようになってから、だんだん内容が堅苦しくなってきて、自分でも開いた瞬間に「勉強しなきゃ」って思い込んでしまうようになった。\nそんな心理的な圧があって、最近はブログ記事を書くのがちょっと嫌になってた。\n前から「技術以外のことも書いてみたいな」って思ってたけど、なかなか踏み出せなくて。\nちょうど最近いろいろあったから、試しに非技術系の記事を書いてみようと思う。\n「まだ雨はやまない」 2025年3月23日、人生初の実物アルバムを買った！\nしぐれうい の「まだ雨はやまない」ってやつで、アルバムというより写真集みたいな可愛さがあって、見た瞬間「これは買いだな」って思った。\n……とはいえ、実は買うまでにちょっとした葛藤があった。\n今まで「見た目だけで衝動買い→実際はそんなに良くなかった」ってパターンが多すぎて、しかも生活費も限られてるから、何か買うたびにいつもすごい迷う。\n知らない歌手のアルバムを買うって、かなりチャレンジングな決断だったわけ（しかもまあまあ高いし doge）\n今年（2025年）1月に店頭で初めてこのアルバムを見たとき「かわいい！」って思って、そこから少しずつ気になり始めてた。\nその後、3月22日に VRChat 上で行われた沖縄展で初音ミクの新衣装を見たんだけど、それが しぐれうい のデザインと知って「あれ、この人前に見たな？」ってなった（あと23日のライブもちょっと見た）\n初音ミクのライブを見た、可愛かった！\nI watched Hatsune Miku\u0026#39;s live concert, so cute!\n也是看上初音未来的直播了 pic.twitter.com/r1JeMpQ9UA\n\u0026mdash; yexca (@yexcano) March 24, 2025 この時に「あのアルバムどうなってるんだろ」って気になって検索して、何曲か試しに聴いてみた。「まぁ悪くないかも」って感触。\nで、23日にいざ買おうと思ってお店まで行ったんだけど、手に取った瞬間また躊躇してしまって。\nなんか俺って「買う」って決めたらあえて前情報なしで体験するのが好きなんだけど、ちょっと調べ始めちゃったせいで、逆に買いたくなくなってきた。\nでもたぶん心のどこかでは「やっぱ欲しいな」って気持ちが残ってて、結局漫画だけ買って帰った。\nその帰り道、いつものように音楽アプリを開いてたら、ふと流れてきた曲がめちゃくちゃ良くて、無意識にお気に入りに追加しようとしたら……\n「え、この曲……見覚えある！」ってなって、調べたらあのアルバムに入ってたやつだった！\nそれを知った瞬間、迷わず踵を返して店に戻って即購入（笑）\n（rainy lady、良すぎる……）\n音源を取り出す まあ実際のところ、CDプレイヤーとか持ってないし、物理的に聴くことはあまりない。\nなので、この記事の本題はここ。「アルバムから音源を取り出す」ってやつ。\n参考にしたのはこの投稿： https://www.bilibili.com/opus/925630344961458181 本当なら取り出し手順とかいろいろ書こうと思ったけど、今回はリンク貼っとくだけにするわ。\n「アルストロメリア」 昨日（25日）、本当は友達とゲームする予定だったけど、「ちょっと外出たいな〜」って言われて予定変更。\nんじゃ俺も出かけるかって外に出た結果、なんと 鹿乃 のアルバムを発見してしまった！！\n見た瞬間、反射的に手に取ってレジへ直行。\n嬉しすぎて語彙力を失った。\nだって、鹿乃 だよ！？俺がめちゃくちゃ好きなアーティストだし、収録曲も全部分かってるし、内容も間違いない。\nワクワクしながら開封して、最後に微笑んでるジャケットを見た瞬間、もう心が完全に浄化された。\n好きなものを手に入れるって、ほんと幸せなんだなって改めて思った。\n今思い出すのはこの一言：「このような幸せ、あるでしょうか」\n――こんな幸せが、この世にあるなんて。\n結び 実際に書いてみて、やっぱ自分の表現力の乏しさとか、語彙の足りなさを痛感した。\nけどまあ、そんなにキッチリ書こうとする必要もないよな。\nそれって技術記事と変わらないし、たまにはゆる〜く、思ったままをぐちゃぐちゃに書くのも悪くないかも。\n","date":"2025-03-26T18:18:31+09:00","permalink":"https://blog.yexca.net/ja/archives/243/","title":"音楽を集めて、気持ちをしまう"},{"content":" 📢 この記事は ChatGPT によって翻訳されました ファイル作成時間を見ると試験後っぽいので、おそらく移動したときに「書こう」って思っただけかもしれない。\nOSの位置づけ コンピュータシステムはハードウェアとソフトウェアの2つの構成要素からなる。\nソフトウェアがインストールされていないコンピュータは「ベアマシン」と呼ばれていて、それを直接使うのは不便で、効率も悪い。\nオペレーティングシステム（OS）は、人と機械のギャップを埋めるためのソフトウェアで、ユーザーとコンピュータのインターフェース的な存在。\nOSの位置づけは下図のとおり：\n図からもわかるように、OS はベアマシン上の最初のソフトで、ハードウェア機能を最初に拡張する存在。他のすべてのソフト（編集、アセンブラ、コンパイラ、DB管理など）やアプリケーションは OS の上に成り立ってる。\nユーザーから見ても、OS があれば直接ハードをいじらずに済むし、OS 経由でコマンドやサービスを使って操作できる。だから OS はユーザーとコンピュータの間の重要な橋渡し役になってる。\nプロセス管理 プロセス管理（＝プロセッサ管理）は、複数のプログラムが同時に実行される環境（多重プログラミング、タイムシェアリングなど）で、各プログラムの動的な状態を「プロセス」として扱う。\nプロセスは「リソースを持ち独立して動ける単位」で、同時実行や協調動作・競合の制御が必要になる。\n順次実行の特徴 前順関係を示すグラフ（有向非巡回グラフ）で、ノードは処理単位、矢印は順番の関係を表す。\nたとえば Pi→Pj なら「Pi が終わらないと Pj は実行できない」。\n次の図では、入力→計算→出力の順番関係：\n順次実行の特徴は、以下の3つ：\n順序性 閉鎖性（外部の影響なしに動く） 再現性（毎回同じ結果） 同時実行の特徴 多重プログラムを導入すると、プログラムは並列に実行されることになる。\n前順関係のない処理は、CPU・I/O に並行して割り当てできる。\nたとえば CPU、入力デバイス、出力デバイスが1つずつあるときの例：\nこのときの特徴は以下：\n閉鎖性がなくなる 実行順が固定でなくなる プロセス間の制約が発生する（干渉・協調） プロセス状態と状態遷移 三態モデル 基本的な3つの状態：\n状態 CPU リソース 実行 〇 〇 準備 × 〇 待機 × × 五態モデル 現実のシステムでは「新規作成」「終了待ち」も加わる：\nプロセス間通信 複数のプロセスが同時に動くと、リソースの共有や協調作業が必要になる。\nこのときの情報のやりとりが「プロセス間通信」。\n同期（synchronization）：協調に必要な直接的な制御\n排他（mutual exclusion）：リソースをめぐる間接的な制御\n同期 たとえば A がバッファにデータを書いて、それを B が読む場合、A が終わらないと B は動けない。\nつまり「同期」とは、協調動作を行うプロセス同士のタイミング合わせのこと。\n排他 同時に1つしか使えないリソース（＝クリティカルリソース）を複数のプロセスが取り合うこと。\nたとえばプリンタ、共有変数など。\nクリティカルセクションの管理ルール 空いてたら入る 他が使ってたら待つ 必ず順番が回ってくる 待ち続けず、CPU を手放す セマフォ（信号量） Dijkstra が提唱した手法。\n以下2つの型がある：\n公共セマフォ（初期値 1）：排他制御 私用セマフォ（初期値 0）：同期制御 P/V操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 Procedure P(Var S:Semaphore); Begin S := S - 1; If S \u0026lt; 0 then W(S) {待機キューに追加} End; Procedure V(Var S:Semaphore); Begin S := S + 1; If S \u0026lt;= 0 then R(S) {待機から起こす} End; ~~~ ### 排他制御の例 ```c++ if 車が通ったら then begin P(mutex) COUNT := COUNT + 1; V(mutex) end GOTO L1; begin P(mutex) PRINT COUNT; COUNT := 0; V(mutex) end GOTO L2; ▶ 詳しくは： 【操作系统】进程间通信—互斥 同期制御の例 典型例：単一バッファの producer/consumer 問題。 セマフォの値 0 → データなし、1 → データあり。\n▶ 詳しくは： 【操作系统】进程间通信—同步 デッドロック（死锁） 例：リソース m＝5、プロセス数 n＝3、各プロセスは k＝3 個必要 → m＜nk ならデッドロックになる可能性あり\n回避条件：m ≥ n×(k-1)\nデッドロックの対策 放置（見なかったフリ） 予防（4条件の破壊） 静的割当：最初に全部渡す（効率悪い） 順序割当：リソースに優先順をつける 回避：状態を常にチェック（代表：銀行家のアルゴリズム） ▶ 銀行家算法： 動画リンク スレッド プロセスは「リソース単位」であり、「スケジューリング単位」でもあるけど、 これだと切り替えコストが高くなる。 そこで、「リソース＝プロセス」「スケジューリング＝スレッド」と分けた。\nスレッドは「軽量プロセス」とも呼ばれて、同じプロセス内のスレッド同士はメモリ空間などを共有できる。\nつまり：\nスレッド切り替えは軽い 複数タスクを高速に動かせる リソースはプロセス単位で保持される ","date":"2025-03-16T19:35:38+09:00","permalink":"https://blog.yexca.net/ja/archives/242/","title":"ソフトウェア設計技術者 - OS分野のノート"},{"content":" 📢 この記事は ChatGPT によって翻訳されました この記事は 2024-04-29 に書いたやつで、あとでちょっと修正したけど、結局完成してなかったみたい。しかももう関連ファイルも全部削除しちゃってる。まあ、いいや。\nWeBASE を使って直接 FISCO BCOS をデプロイした記録。\nDocker デプロイ CentOS で Docker を使ってセットアップ。\n環境構築 まず yum-utils をインストールして yum-config-manager を使えるように：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 yum install -y yum-utils ~~~ リポジトリを追加： ```bash # 公式 yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo # アリババクラウド yum-config-manager \\ --add-repo \\ https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo # 清華大学 yum-config-manager \\ --add-repo \\ https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/centos/docker-ce.repo Docker をインストール：\n1 yum install docker-ce docker-ce-cli containerd.io docker-compose-plugin Docker ミラーを設定（中科大のミラー）：\n1 vim /etc/docker/daemon 内容：\n1 2 3 { \u0026#34;registry-mirrors\u0026#34;: [\u0026#34;https://docker.mirrors.ustc.edu.cn\u0026#34;] } Docker を起動：\n1 systemctl start docker 設定を変更したら\n1 2 systemctl daemon-reload systemctl restart docker.service Python をインストール：\n1 yum install -y python36 epel-release python36-pip docker-compose をダウンロード：\n1 2 curl -L \u0026#34;https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)\u0026#34; -o /usr/local/bin/docker-compose chmod +x /usr/local/bin/docker-compose PyMySQL をインストール：\n1 pip3 install PyMySQL ブロックチェーンのデプロイ スクリプトを取得：\n1 wget https://osp-1257653870.cos.ap-guangzhou.myqcloud.com/WeBASE/releases/download/v1.5.5/webase-deploy.zip 解凍して移動：\n1 2 unzip webase-deploy.zip cd webase-deploy 設定ファイルを編集：\n1 vim common.properties Docker イメージを取得：\n1 python3 deploy.py pullDockerAll タイムアウトの値（30/60/120）を聞かれたら適当に入力。\nもし失敗したら、手動でイメージを pull：\n1 docker pull fiscoorg/fiscobcos:v2.9.1 インストール：\n1 python3 deploy.py installDockerAll deploy has completed が出たら成功。\n便利なコマンド一覧：\n1 2 3 4 5 6 7 8 9 10 11 12 # 一括操作 python3 deploy.py installDockerAll # デプロイと起動 python3 deploy.py stopDockerAll # 全停止 python3 deploy.py startDockerAll # 全再開 # ノード操作 python3 deploy.py startNode python3 deploy.py stopNode # WeBASE サービス操作 python3 deploy.py dockerStart python3 deploy.py dockerStop Java 環境でのデプロイ（非 Docker） Docker 使わないなら Java が必要。CentOS の場合 Oracle JDK を使う。\nOracle 公式から JDK8 をダウンロードして、解凍：\n1 2 tar -zxvf jdk-8u411-linux-x64.tar.gz mv jdk1.8.0_411 jdk-8u411 環境変数を設定：\n1 vim /etc/profile 内容：\n1 2 3 export JAVA_HOME=/home/yexca/software/jdk-8u411 export PATH=$JAVA_HOME/bin:$PATH export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOMR/lib/tools.jar 反映：\n1 source /etc/profile バージョン確認：\n1 java -version データベース：MariaDB まず yum リポジトリを追加：\n1 vim /etc/yum.repos.d/mariadb.repo 内容：\n1 2 3 4 5 6 [mariadb] name = MariaDB baseurl = https://mirrors.aliyun.com/mariadb/yum/11.2/centos/$releasever/$basearch module_hotfixes = 1 gpgkey = https://mirrors.aliyun.com/mariadb/yum/RPM-GPG-KEY-MariaDB gpgcheck = 1 キャッシュをクリアして更新：\n1 2 yum clean all yum makecache all インストール：\n1 yum install -y MariaDB-server MariaDB-client 起動：\n1 systemctl start mariadb.service 初期設定：\n1 mariadb-secure-installation ブロックチェーンのデプロイ 1 2 3 4 5 wget https://osp-1257653870.cos.ap-guangzhou.myqcloud.com/WeBASE/releases/download/v1.5.5/webase-deploy.zip unzip webase-deploy.zip cd webase-deploy vim common.properties python3 deploy.py installAll 操作コマンド一覧：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # 一括操作 python3 deploy.py installAll python3 deploy.py stopAll python3 deploy.py startAll # 各サービス個別操作 python3 deploy.py startNode python3 deploy.py stopNode python3 deploy.py startWeb python3 deploy.py stopWeb python3 deploy.py startManager python3 deploy.py stopManager python3 deploy.py startSign python3 deploy.py stopSign python3 deploy.py startFront python3 deploy.py stopFront # 可視化用 python3 deploy.py installWeBASE python3 deploy.py stopWeBASE python3 deploy.py startWeBASE アクセス ポートは web.port=5000（デフォルト）でアクセスできる。\nファイアウォールの設定：\n1 2 3 4 firewall-cmd --zone=public --list-ports firewall-cmd --zone=public --add-port=5000/tcp --permanent firewall-cmd --reload firewall-cmd --zone=public --query-port=5000/tcp スマートコントラクト 2025-03-13: ここに何を書こうとしたのか自分でも忘れた\nWeBASE 管理画面で、合約 IDE から新規作成。 コンパイル → ユーザー作成 → 秘密鍵登録 → トランザクションで動作確認、という流れ。\n参考 WeBASE 公式ドキュメント https://www.runoob.com/docker/centos-docker-install.html https://mariadb.org/download/?t=repo-config\u0026d=CentOS+7\u0026v=11.2\u0026r_m=aliyun https://blog.csdn.net/default7/article/details/122672341 https://www.cnblogs.com/potato-chip/p/13973780.html ","date":"2025-03-13T01:08:02+09:00","permalink":"https://blog.yexca.net/ja/archives/241/","title":"WeBASE を使って FISCO BCOS ブロックチェーンをデプロイする"},{"content":" 📢 この記事は ChatGPT によって翻訳されました はじめに ブログを国際化してからは他言語の投稿なんてほぼ見てなかったんだけど、\nある日ネットサーフィン中に「おっ、いい感じの日本語フォントじゃん？」ってのを見つけて、「これは導入するしかない！」ってなった。\nでもその時に他の言語フォントを見てみたら……ひどすぎて笑った。\n対象箇所の特定 要素を調べてみたら、フォントは変数でコントロールされてることがわかったので、\nテーマの SCSS ファイルを開いて、変数が定義されてる場所を検索。すんなり見つかった。\nフォント追加 既存の命名ルールに倣って、各言語ごとのフォント変数を追加した：\n1 2 3 4 5 6 7 8 9 10 11 12 13 /** * Global font family */ :root { --sys-font-family: -apple-system, BlinkMacSystemFont, \u0026#34;Segoe UI\u0026#34;, \u0026#34;Droid Sans\u0026#34;, \u0026#34;Helvetica Neue\u0026#34;; --zh-font-family: \u0026#34;Noto Sans SC\u0026#34;, \u0026#34;PingFang SC\u0026#34;, \u0026#34;Microsoft YaHei\u0026#34;; --zh-TW-font-family: \u0026#34;Noto Sans TC\u0026#34;, \u0026#34;PingFang TC\u0026#34;, \u0026#34;Microsoft JhengHei\u0026#34;; --ja-font-family: \u0026#34;Hiragino Kaku Gothic ProN\u0026#34;, \u0026#34;Hiragino Sans\u0026#34;, \u0026#34;BIZ UDPGothic\u0026#34;, Meiryo; --en-font-family: \u0026#34;Pacifico\u0026#34;, \u0026#34;Dancing Script\u0026#34;, \u0026#34;Lobster\u0026#34;, cursive; --base-font-family: \u0026#34;Lato\u0026#34;, var(--sys-font-family), var(--en-font-family), var(--zh-font-family), var(--zh-TW-font-family), var(--ja-font-family), sans-serif; --code-font-family: Menlo, Monaco, Consolas, \u0026#34;Courier New\u0026#34;, var(--en-font-family), var(--zh-font-family), var(--zh-TW-font-family), var(--ja-font-family), monospace; } 保存してビルドしてみたけど、特に変化なし。\n言語別フォント上書き設定 実は lang セレクタで言語ごとにフォントを上書きできる。 つまり \u0026lt;html lang=\u0026quot;xx\u0026quot;\u0026gt; によってフォントを切り替えるようにすればいいってこと。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 /* 中国語（簡体） */ :lang(zh), :lang(zh-CN) { font-family: var(--zh-font-family); } /* 中国語（繁体） */ :lang(zh-TW) { font-family: var(--zh-TW-font-family); } /* 英語 */ :lang(en) { font-family: var(--en-font-family); } /* 日本語 */ :lang(ja) { font-family: var(--ja-font-family); } このスタイルをビルドして適用したら、見た目が一気に整って満足。\n","date":"2025-03-10T23:56:56+09:00","permalink":"https://blog.yexca.net/ja/archives/240/","title":"国際化に対応したフォント設定"},{"content":" 音に感じてシリーズ 曲 翻訳 リンク 僕が死のうと思ったのは 略 https://blog.yexca.net/ja/archives/214 あくあ色ぱれっと 略 https://blog.yexca.net/ja/archives/219 恋の押し売り 略 https://blog.yexca.net/ja/archives/220 17さいのうた 略 https://blog.yexca.net/ja/archives/224 drop 恋に落ちた https://blog.yexca.net/ja/archives/230 生きるを選んだ私へ 略 この記事 rainy lady 雨女 https://blog.yexca.net/ja/archives/249 恋しくなったら手を叩こう 略 https://blog.yexca.net/ja/archives/250 まえがき 📢　この部分は ChatGPT によって翻訳されました。　最初に曲のタイトルを見たとき、なんとなく内容が想像できて、同時に自分が以前考えてた「命」についてのことも思い出した。 前はずっと「なんで生きてるんだろう」って答えが出なかったけど、逆に「じゃあなんで死なないの？」って考えてみたとき、自殺の方法とか、それに伴う結果を想像してみて、気づいたんだよね。 自分は自殺が怖いから、生きてるんだなって。 この曲のメッセージと、まさにリンクしててちょっとびっくりした。\nそういえば、こはならむ の曲は前から何曲か聴いたことあって、そのときはよく泣きながら歌ってて、正直ちょっと見るのが辛くなるくらいだった。 「この子、本当に大丈夫かな……」って心配になるくらいに。 でも、YouTube Music が新曲をレコメンドしてきて、それが明るめの雰囲気の曲で、「あ、なんか前より元気になってる？」ってちょっと嬉しくなった（※自分は全然抜け出せてないのに）。\nちゃんと歌詞を読んで理解したあと、「あれ、これめっちゃ良曲じゃん」ってなった。 もっと早く出会いたかったなあ。 同時に、このシリーズの記事を書いてて本当によかったって思った。 前はただなんとなく歌ってた曲が、今ではちゃんと意味が分かって、そこからいろんなことを感じ取れるようになった。 もはや「歌で日本語を学ぶ」じゃなくて、「歌で人生を学んでる」レベル。 前に聴いてた曲の“もうひとつの面”を発見する感じ、すごく不思議だし、もっと好きになった気がする。 （ちなみに、「アスナがキリトに問いかけた“もし本当の自分を知ったらどうなる？”ってやつ思い出したんだけど、ほんと、もっと好きになると思う）\nそして、いつもどおり、このシリーズの翻訳は原文どおりじゃないとこも多いです。 ネタに走った部分もあったけど、合わないところはあとでちゃんと消してます！\n2025.05.26 この曲も歌ってみた。語彙ちょっと難しかったけど、「透明なまま終わっていきなよ、私はもうきっと大丈夫」って叫ぶところ、めっちゃ解放された感じで最高だった！感情ぶちまけた～！ ……まあ、そのあと知らない単語にボコられたけどね（泣）\n動画 歌詞 なつかしい音 なつかしい匂い なつかしい景色\n蘇よみがえるトラウマ 見たくない顔 聞きたくない声\n許せない人たち もう行けなくなっちゃった、あの駅\n暗い「人目が怖いの」\nそんな記憶 あいして生きる\n透明なまま終わっていきなよ\n私はもうきっと大丈夫\n嫌い泣きたいも今振り返れば\n泡と消える刹那せつな\n私見て下を見た気でいなよ そのまま\n消えてしまいたいと願ったような夜に\n笑ってられてるよ 永遠に消えないんだよ\n狭い世界で くだらない談だんに怯おびえてる私\n霞かすんで歪ゆがんだ脳 明白めいはくな病\n傷跡きずあとは消えないまま 責任の所在は？\nあの日の子供が泣くのだ 今でも\n今日ものうのう生きている 永世えいせい罪人ざいにん共に問う\n替えの効かないもの 戻らないものに手を出した自じ覚かくはある？\n許せぬ過去を睨にらんでも仕方ない、って\n言葉は理解するが 時に解決を促うながさせる\n卑ひ劣れつさに 愚ぐ劣れつさに\n反吐へどが出る 反吐へどが出る\n「忘れろ」も言葉のナイフだ\n私は今日も立っている 私は今日も歌っている\n透明なまま終わっていきなよ\n私はもう大丈夫\n嫌い泣きたいも今振り返れば\n私を生かすのは私なのだ\n透明なまま終わっていきなよ\n私はもう、もう大丈夫\n嫌い泣きたいも今振り返れば\n決して消えぬ「愛」か\n私見て下を見た気でいなよ そのまま\n消えてしまいたいと願ったような夜に\n笑っているんだよ 笑っているんだよ 笑っているんだよ\n","date":"2025-03-07T01:26:31+09:00","permalink":"https://blog.yexca.net/ja/archives/239/","title":"音に感じて - 《生きるを選んだ私へ》"},{"content":" 📢 この記事は ChatGPT によって翻訳されました 同じく コンピュータネットワークのノート と同時期に書いたやつ。試験ではこの2つの分野が一緒に出るから、勉強も同時進行だった。\nファイアウォール技術 ファイアウォール（Firewall）は、内部ネットワークと外部ネットワークの境界に設置されるフィルタリング装置。内部ネットワークは信頼できる、安全なものとみなされ、外部ネットワークはその逆という前提。\n目的は、保護されたネットワークに対する「望ましくない」「認可されていない」通信を遮断すること。\nつまり、境界管理を通して内部ネットワークのセキュリティポリシーを強化するもの。\nファイアウォールはネットワークセキュリティの中心であり、全ての通信を監視・制御・監査・アラート処理する。\nだからこそ、自分自身もセキュリティの脅威に晒されやすい場所にあるので、しっかりした製品を選ぶのが大事。\n発展の歴史は以下の通り：\nパケットフィルタリング アプリケーションゲートウェイ ステートフルインスペクション（状態検査） パケットフィルタリング型 パケットのヘッダ情報（送信元アドレス・宛先アドレス・プロトコル・ポート番号など）で判断し、通すかどうか決める。\n特徴：\nユーザーには透明で高速 ネットワーク層レベルの制御 スプーフィング（なりすまし）をある程度防げる ルーターに組み込めるので、別途機器いらず 欠点：\nアプリ層の制御はできない 粒度が荒い 新しいタイプの攻撃には対応できない アプリケーションプロキシ型 内部と外部を完全に分離し、内部→外部の通信は一度プロキシが受け取ってから外部と通信、返ってきたらまたプロキシ経由で内部に返す。\nつまり外部との直接接続はさせない。\nメリット：\nアプリ層・トランスポート層・ネットワーク層の全てを監視できる\nデメリット：\n設定が面倒\n動作が遅い\nステートフルインスペクション型 上の2つのいいとこ取り。安全性を保ちつつ、スピードも確保できる。\nウイルス 特徴：\n伝染性 隠蔽性 感染性 潜伏性 トリガー性（発動条件付き） 破壊性 ウイルスの種類：\nWorm（ワーム） Trojan（トロイの木馬） Backdoor（バックドア） Macro（マクロウイルス） マクロウイルスの感染対象：ドキュメントやスプレッドシートなど\n代表例：\nトロイ：冰河（Ice River） ワーム：Happytime、熊猫烧香（香水パンダ）、Code Red、Love Bug、Stuxnet ネットワーク攻撃 DoS攻撃：リクエストを送りまくってサービス不能にさせる リプレイ攻撃：以前キャプチャした通信を再送して認証突破を狙う パスワード攻撃：正規ユーザーになりすましてログイン トロイの木馬：アプリやゲームに見せかけて裏で侵入 ポートスキャン攻撃：開いてるポートを探して攻撃 ネットワークスニッフィング：同じネットワーク内の通信を傍受 IPスプーフィング：送信元IPを偽装して信用させる SQLインジェクション：不正なSQLを注入して情報抜き出し・改変など 侵入検知技術のタイプ：\nエキスパートシステム型 モデルマッチング型 単純なパターンマッチ型 ネットワークセキュリティ技術 SSL (Secure Socket Layer)\n1994年 Netscape が開発したトランスポート層の暗号通信プロトコル\nSSL 3.0 は事実上の標準として広まった\nTLS (Transport Layer Security)\nIETF が SSL3.0 を基に仕様化したバージョン\nSSL の後継プロトコルとして現在主流\nSSH (Secure Shell)\nアプリ層とトランスポート層にまたがるリモートログイン用プロトコル\n当初は UNIX 用だったが今ではマルチプラットフォームに対応\nパスワードやコマンドの盗聴対策に有効\nHTTPS\nHTTP + SSL による暗号化通信。セキュリティ強化版 HTTP\nMIME (Multipurpose Internet Mail Extensions)\nメールで非ASCIIデータ（バイナリ・画像・音声など）を送るための拡張規格\nPGP (Pretty Good Privacy)\nRSA 公開鍵暗号に基づいたメール暗号化ソフト\nメールの暗号化＆デジタル署名の機能を持つ\n","date":"2025-03-04T18:38:28+09:00","permalink":"https://blog.yexca.net/ja/archives/238/","title":"ソフトウェア設計技術者 - 情報セキュリティ分野のノート"},{"content":" 📢 この記事は Gemini-3-flash によって翻訳されました はじめに 最近、OneDrive で共有されたファイルをダウンロードしようとしたんだけど、IDM（Internet Download Manager）が自動でキャッチしてくれなかったんだ。おまけにブラウザのダウンロードは不安定ですぐ失敗しちゃうし……。そこで、なんとかして直リンクを取得する方法がないか調べてみたよ。\n拡張機能の問題 最初は「サポートが終わっちゃったのかな？」と思って再インストールしようとしたんだ。でも、一度削除してから Chrome ウェブストアに見に行ったら、なんと「インストール不可」の表示。あちゃー、消すのが早すぎた。\nIDM は有料ソフトなのに、アップデートが追いついてないのはちょっと意外だよね。\nSimpread（簡悦）のプロジェクトの Issue を見てわかったんだけど、どうやらボタンに disabled 属性が付けられて無効化されているだけみたい。その属性を削除すれば、普通にインストールできたよ。\n直リンクを取得する それでも IDM がキャッチしてくれないから、結局は直リンクを探すことにした。\n共有ページに入ってファイルをプレビューし、右上の Share - Copy link を押すと共有リンクが取得できる。こんな感じのリンクだね：\n1 https://xxx-my.sharepoint.com/:u:/r/personal/xxx/Documents/xxx/xxx.rar?csf=1\u0026amp;web=1\u0026amp;e=OTZZbx このリンクの中にある web という部分を download に書き換えるんだ。するとこんな感じになる：\n1 https://xxx-my.sharepoint.com/:u:/r/personal/xxx/Documents/xxx/xxx.rar?csf=1\u0026amp;download=1\u0026amp;e=OTZZbx これをコピーして IDM の Add URL に貼り付ければ、無事にダウンロードが始まるよ。\n参考記事: https://techcommunity.microsoft.com/discussions/onedriveforbusiness/onedrive-direct-download-link/4226744 ","date":"2025-03-02T12:58:57+09:00","permalink":"https://blog.yexca.net/ja/archives/237/","title":"OneDrive の直リンクを取得する方法"},{"content":" 📢 この記事は gemini-2.5-flash によって翻訳されました 画像リンクを見れば、これが2023年4月のメモだってすぐわかると思う。ずっと公開してなかったのは、ほとんど知識点の羅列って感じで、記事って形式じゃなかったからなんだ。でも、やっぱりメモはメモだし、たまに調べたい時とかブログで直接見る方が便利だよね。\n1. ネットワーク機器 層 機器 ブロードキャストドメインの分離 衝突ドメインの分離 物理層 リピーター / ハブ × × データリンク層 ブリッジ / スイッチ × √ ネットワーク層 ルーター √ √ 物理層の相互接続機器 物理層の相互接続機器には、リピーター (Repeater) とハブ (Hub) があるよ。\nリピーター ​ 物理層でLANセグメントの相互接続を実現するもので、LANセグメントの長さを拡張するために使うんだ。\nハブ ​ ハブは特殊なマルチポートリピーター（多ポートリピーター）だと考えられてて、信号増幅機能も持ってるんだよ。\nデータリンク層の相互接続機器 データリンク層の相互接続機器には、ブリッジ (Bridge) とスイッチ (Switch) があるね。\nブリッジ ​ ブリッジは2つのLANセグメントをつなぐために使うよ。\nスイッチ ​ スイッチは多ポートのブリッジなんだ。\nネットワーク層の相互接続機器 ルーター (Router) はネットワーク層の相互接続機器で、論理的に分離された複数のネットワークをつなぐために使うんだ。\nアプリケーション層の相互接続機器 ゲートウェイ (Gateway) はアプリケーション層の相互接続機器だよ。タイプが異なったり、プロトコルに大きな違いがあるネットワークをつなぐ時は、ゲートウェイ機器を選ぶ必要があるんだ。\n2. プロトコルスイート コンピュータネットワークのTCP/IPプロトコルスイート\n3. TCPとUDP インターネット層プロトコル IP インターネット層（ネットワーク層）は、TCP/IPプロトコルスイート全体の要だよ。インターネット層で定義されているプロトコルは、IPの他にICMP、ARP、RARPなどの重要なプロトコルがいくつかあるんだ。\nIPが提供するサービスは、通常、コネクションレス (Connectionless) で信頼性がない (Unreliable) と考えられているね。実際のところ、ネットワークの性能が良い状況では、IPで送信されたデータは問題なく目的地に届くんだ。\n「コネクションレスな転送」っていうのは、ターゲットシステムがデータ受信の準備ができたことを確認する前にデータを送信することだよ。これと対照的なのが、コネクション指向 (Connection Oriented) の転送（TCPとかね）で、このタイプの転送では、アプリケーション層のデータ転送の前に、送信元と送信先の間でスリーウェイハンドシェイクが必要になるんだ。\n信頼性のないサービスっていうのは、ターゲットシステムがパケットの受信成功を確認しないってこと。IPは、できるだけデータ転送を成功させようと努力するだけなんだ。でも、必要に応じて、上位層プロトコルがパケットが確実に届いたことを保証するための追加サービスを実装しないといけないんだよ。\nIPはコネクションレスで信頼性のないサービスしか提供しないから、エラー検出やフロー制御みたいなサービスは他の各層プロトコルに任されているんだ。これがTCP/IPが効率的に動作する重要な理由の一つなんだよ。\nトランスポート層プロトコル TCP TCP (Transmission Control Protocol, 伝送制御プロトコル) は、TCP/IPプロトコルスイートの中で一番大事なプロトコルの一つなんだ。IPが提供する信頼性のないデータサービスをベースにして、アプリケーションに信頼性があって、コネクション指向の、全二重のデータ転送サービスを提供してくれるんだよ。\n信頼性のある転送、コネクション管理、エラーチェックと再送、フロー制御、輻輳制御、ポートアドレス指定\nそのうちフロー制御では、可変サイズのスライディングウィンドウプロトコルが使われているんだ。\nTCPを使って送信元ホストと宛先ホスト間でコネクションの確立や切断を行うとき、確立と切断が成功したことを確認するために、どちらもスリーウェイハンドシェイクが必要になるんだ。\nトランスポート層プロトコル UDP ユーザーデータグラムプロトコル (User Datagram Protocol, UDP) は、信頼性がなく、コネクションレスなプロトコルで、アプリケーションプロセス間の通信を保証してくれるんだ。同じトランスポート層にあるコネクション指向のTCPと比べると、UDPはコネクションレスなプロトコルで、エラー検出機能はずっと弱いよ。簡単に言うと、TCPは信頼性の提供に役立ち、UDPは高速転送に役立つってこと。例えば、インタラクティブなセッションをサポートする必要があるアプリケーション（FTPとかね）はTCPを使うことが多いし、自分でエラー検出したり、エラー検出が不要なアプリケーション（DNS、SNMPとか）はUDPを使うことが多いんだ。\nUDPプロトコルソフトウェアの主な役割は、UDPメッセージをアプリケーション層に見せること。失われたりエラーになったデータメッセージを再送したり、受信した順不同のIPデータグラムを並べ替えたり、重複したIPデータグラムを削除したり、受信したデータグラムを確認したり、コネクションの確立や終了を担当したりはしないんだ。これらの問題は、UDPを使って通信するアプリケーションが処理する責任があるんだよ。\nTCPは信頼性のあるデータ転送サービスを提供してくれるんだけど、それは通信量を犠牲にして実現しているんだ。つまり、同じタスクを完了するために、TCPはより多くの時間と通信量を必要とするってこと。これはネットワークが信頼できない時には、時間を犠牲にしてネットワークの信頼性を得るのが有効だけど、ネットワークが非常に信頼できる状況では、UDPを採用すれば通信量の無駄はすごく小さくなるんだ。\n4. SMTPとPOP3 Eメール（電子メール）は、コンピュータを使って情報をやり取りする電子的な手紙のことだよ。コンピュータネットワークの登場とともに現れて、ネットワークの通信手段を使って普通のメール情報のやり取りを実現しているんだ。一番広く使われているサービスの一つだね。\nEメールシステムはクライアント/サーバーモデルをベースにしてるよ。Eメールサーバーは主にSMTP（Simple Mail Transfer Protocol, 簡易メール転送プロトコル）を使ってるんだけど、このプロトコルはメールの情報の形式とその配信処理方法を記述していて、転送されるメールが正しくアドレス指定され、信頼性を持って転送されることを保証してくれるんだ。これはテキストベースのネットワークプロトコルで、非ASCIIテキストや非テキストの添付ファイルを送れないっていう欠点があるんだよね。どんどん発展するマルチメディア環境や、みんなが気にするメールのプライバシーの面では、その限界がより顕著になってるんだ。\nその後、多目的インターネットメール拡張プロトコル (MIME) や、プライバシー強化メール保護プロトコル (PEM) などのいくつかのプロトコルが、SMTPの欠点を補ったんだ。SMTPは大規模なマルチユーザー、マルチタスクのOSで使われてて、PCで受信に使うのはすごく難しいんだよね。だから、TCP/IPネットワーク上のほとんどのメール管理プログラムは、メール送信にSMTPを使って、ユーザーがすぐに取り出せなかったメールの保管にはPOP（Post Office Protocol, よく使われるのはPOP3）を使ってるんだ。\nPOPプロトコルにはPOP2とPOP3の2つのバージョンがあるよ。現在使われているPOP3は、SMTPと一緒に使うこともできるし、単独でメールの送受信に使うこともできるんだ。POPプロトコルはシンプルな純粋なテキストプロトコルで、転送はEメール全体を単位として行われるから、部分的な転送はできないんだ。\n簡易メール転送プロトコルと、メール受信に使うPOP3は、どちらもTCPポートを使ってるんだ。SMTPで使うポート番号は25番、POP3で使うポート番号は110番だよ。\n5. ARPとRARPとDHCP ARPとRARP アドレス解決プロトコル (Address Resolution Protocol, ARP) と逆アドレス解決プロトコル (RARP) は、インターネット層（ネットワーク層）にあるもう一つの重要なプロトコルなんだ。ARPの役割はIPアドレスを物理アドレスに変換することで、RARPの役割は物理アドレスをIPアドレスに変換することだよ。\nネットワーク上のどんな機器でも、ホスト、ルーター、スイッチなどには全部固有の物理アドレスがあって、それはNIC（ネットワークカード）によって与えられるんだ。それぞれのNICは工場出荷時に異なる番号が振られてて、これはユーザーが買うNICがそれぞれ固有の物理アドレスを持ってるってこと。一方で、下位層プロトコルや物理アドレスの違いを隠すために、IPプロトコルはIPアドレスを使ってるから、データ転送の際にはIPアドレスと物理アドレスの相互変換が必ず必要になるんだ。\nARPを使ったIPアドレスから物理アドレスへの変換プロセスはこうだよ。コンピュータが他のどのコンピュータと通信する必要がある時、まずARPキャッシュを調べるんだ。もしARPキャッシュにそのIPアドレスがあれば、それに対応する物理アドレスを使って、必要な物理NICに直接データグラムを送るよ。もしARPキャッシュにそのIPアドレスがない場合、ARPはLAN上でブロードキャスト方式でARPリクエストパケットを送信するんだ。\nもしLAN上のIPアドレスとあるコンピュータのIPアドレスが一致したら、そのコンピュータはARP応答メッセージを生成して、その情報の中に対応する物理アドレスが含まれているんだ。ARPプロトコルソフトウェアはIPアドレスと物理アドレスの組み合わせを自分の高速キャッシュに追加して、これでデータ通信を開始できるってわけ。\nDHCP DHCP（Dynamic Host Configuration Protocol, 動的ホスト設定プロトコル）の機能は、IPアドレスを集中的に管理・割り当てて、ネットワーク環境内のホストがIPアドレス、ゲートウェイアドレス、DNSサーバーアドレスなどの情報を動的に取得できるようにすることだよ。あと、アドレスの利用率を向上させることもできるんだ。\nDHCPクライアントはDHCPサーバーから、自身のIPアドレス、DNSサーバーアドレス、DHCPサーバーアドレス、デフォルトゲートウェイのアドレスなんかの情報を取得できるんだ。\nWindowsの無効なアドレス：169.254.x.x\nLinuxの無効なアドレス：0.0.0.0\n168.254.x.xは、WindowsシステムがDHCP情報のリースに失敗した時に、クライアントに自動で割り当てるIPアドレスなんだ。\n6. IPアドレスとサブネットマスク IPアドレス インターネットアドレスは名前で記述されるから、このアドレスの表現方法は理解しやすく、覚えやすいんだ。実際には、インターネット内のホストアドレスはIPアドレスで一意に識別されるよ。これはインターネットで使われるネットワークプロトコルがTCP/IPプロトコルだからで、そのため各ホストはIPアドレスで識別されなきゃいけないんだ。\nそれぞれのIPアドレスは256より小さい4つの数字で構成されてて、数字の間は「.」で区切られているんだ。インターネットのIPアドレスは全部で32ビット、4バイトだよ。表示形式は2種類あって、バイナリ形式と10進形式。バイナリ形式はコンピュータが認識する形式で、10進形式はバイナリ形式を「翻訳」したものなんだ。主に使いやすさや理解のしやすさのためだね。例えば、10進IPアドレスの129.102.4.11は、バイナリの10000001 01100110 00000100 00001011と同じだけど、明らかにドット付き10進形式で表現する方がずっと便利だよね。\nドメイン名とIPアドレスは一対一で対応していて、ドメイン名は覚えやすくて使いやすいから、かなり広く使われているんだ。ユーザーがインターネット上の特定のコンピュータと情報をやり取りする時は、ドメイン名を使うだけで良くて、ネットワークが自動的にそれをIPアドレスに変換してそのコンピュータを見つけてくれるんだよ。\nインターネットのアドレスは、Aクラス、Bクラス、Cクラス、Dクラス、Eクラスの5種類に分けられるんだ。IPアドレスの中で、すべて0はネットワークを表し、すべて1はブロードキャストを表すよ。\nAクラスのネットワークアドレスは1バイト（8ビット）を占めてて、最上位ビットを0と定義してこのタイプのアドレスを識別するんだ。残りの7ビットが本当のネットワークアドレスで、1〜126個のネットワークをサポートしてる。後ろの3バイト（24ビット）はホストアドレスで、$2^{24}-2$個のエンドポイントのアドレス指定を提供しているよ。\nAクラスのネットワークアドレスの最初のバイトの10進値は000〜127だよ。\nBクラスのネットワークアドレスは2バイトを占めてて、最上位2ビットを10としてこのタイプのアドレスを識別するんだ。残りの14ビットが本当のネットワークアドレスで、ホストアドレスは後ろの2バイト（16ビット）を占めるから、Bクラスの全てのアドレスは ($2^{14}-2$)($2^{16}-2$) = 16382×65534個になるよ。\nBクラスのネットワークアドレスの最初のバイトの10進値は128〜191だよ。\nCクラスのネットワークアドレスは3バイトを占めてて、これが一番広く使われているインターネットアドレスだよ。最上位3ビットを110としてこのタイプのアドレスを識別するんだ。残りの21ビットが本当のネットワークアドレスだから、Cクラスのアドレスは$2^{21}-2$個のネットワークをサポートしてる。ホストアドレスは最後の1バイトを占めてて、各ネットワークは最大$2^8-2$個のホストを持つことができるよ。\nCクラスのネットワークアドレスの最初のバイトの10進値は192〜223だよ。\nDクラスアドレスは比較的新しいタイプ。識別ヘッダは1110で、マルチキャストに使われるんだ。例えば、ルーターの変更とかね。\nDクラスのネットワークアドレスの最初のバイトの10進値は224〜239だよ。\nEクラスアドレスは実験用に予約されていて、その識別ヘッダは1111だよ。\nEクラスのネットワークアドレスの最初のバイトの10進値は240〜255だよ。\nネットワークソフトウェアとルーターは、サブネットマスク (Subnet Mask) を使って、パケットがネットワーク内部にだけ留まるのか、それとも他の場所へルーティングされるのかを識別するんだ。あるフィールド内で、1が出現することは、そのフィールドがネットワークアドレスの全部または一部を含んでいることを示し、0はホストアドレスの位置を示すよ。例えば、一番よく使われるCクラスアドレスは、最初の3バイトをネットワークの識別に使って、最後の1バイト（8ビット）をホストの識別に使ってる。だから、サブネットマスクは255.255.255.0なんだ。\nIPv6の紹介 IPv6は128ビットものアドレス空間を持ってて、IPv4のアドレス不足問題を完全に解決できるんだ。それ以外にも、IPv6は階層型アドレスモード、効率的なIPパケットヘッダ、サービス品質、ホストアドレスの自動設定、認証と暗号化など、たくさんの技術を採用してるよ。\n7. Windowsコマンド ipconfig/release：DHCPクライアントが手動でIPアドレスを解放する\nipconfig/flushdns：ローカルDNSキャッシュの内容をクリアする\nipconfig/displaydns：ローカルDNSの内容を表示する\nipconfig/registerdns：DNSクライアントが手動でサーバーに登録を行う\nipconfig：すべてのネットワークアダプターのIPアドレス、サブネットマスク、デフォルトゲートウェイの値を表示する\nipconfig/all：DHCPサービスが起動しているかどうかも含め、すべてのネットワークアダプターの完全なTCP/IP設定情報を表示する\nipconfig/renew：DHCPクライアントが手動でサーバーに更新要求（IPアドレスの再申請）を行う\n8. ルーティング Windows Server 2003のルーティングタイプは5種類あるんだ。WindowsサーバーがIPデータパケットを受け取った時、まずホストルートを検索して、次にネットワークルート（直接接続ネットワークとリモートネットワーク）を検索するよ。これらのルート検索が失敗した時に、最後にデフォルトルートを検索するんだ。\n各種ルーティング情報源の管理距離は以下の通りだよ。\nもしルーターが複数のルーティングプロトコルから転送された、ある宛先に関する複数のルート情報を受け取った場合、それぞれのルートの管理距離を比較して、管理距離が小さいルーティング情報源が提供するルート情報を採用するんだ。\n","date":"2025-03-01T23:28:30+09:00","permalink":"https://blog.yexca.net/ja/archives/236/","title":"ソフトウェアデザイナー - コンピュータネットワークのメモ"},{"content":" 📢 この記事は gemini-2.5-flash によって翻訳されました Elasticsearch シリーズ\n内容 リンク Elasticsearch 基本操作 https://blog.yexca.net/ja/archives/226 Elasticsearch 検索操作 https://blog.yexca.net/ja/archives/227 RestClient 基本操作 https://blog.yexca.net/ja/archives/228 RestClient 検索操作 https://blog.yexca.net/ja/archives/229 Elasticsearch データ集約 https://blog.yexca.net/ja/archives/231 Elasticsearch オートコンプリート https://blog.yexca.net/ja/archives/232 Elasticsearch データ同期 https://blog.yexca.net/ja/archives/234 Elasticsearch クラスター この記事 ESを単体でデータ保存に使うと、どうしても二つの問題に直面するんだ。大量のデータ保存と単一障害点の問題だね。\n大量データ保存の問題：インデックスを論理的にN個のシャードに分割して、複数のノードに保存する。 単一障害点の問題：シャードデータを異なるノードにバックアップ（レプリカ）する。 ESクラスター関連の概念\nクラスター (cluster)：共通のクラスター名を持つノードのグループのこと。 ノード (node)：クラスター内のESインスタンスの一つだよ。 シャード (shard)：インデックスは異なる部分に分割して保存できるんだ。これをシャードと呼ぶよ。クラスター環境では、一つのインデックスの異なるシャードを別々のノードに分割して保存できるんだ。 解決する問題：データ量が多すぎたり、単一ノードの保存量が限られている問題。\nシャードはHadoopのHDFSでデータを複数に分けてバックアップするのに似てるね。\nプライマリシャード (Primary shard)：レプリカシャードとの対比で定義されるよ。 レプリカシャード (Replica shard)：各プライマリシャードは一つ以上のレプリカを持つことができて、データはプライマリシャードと同じなんだ。 ESクラスターの構築 docker-composeを使えばできるよ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 version: \u0026#39;2.2\u0026#39; services: es01: image: elasticsearch:7.12.1 container_name: es01 environment: - node.name=es01 - cluster.name=es-docker-cluster - discovery.seed_hosts=es02,es03 - cluster.initial_master_nodes=es01,es02,es03 - \u0026#34;ES_JAVA_OPTS=-Xms512m -Xmx512m\u0026#34; volumes: - data01:/usr/share/elasticsearch/data ports: - 9200:9200 networks: - elastic es02: image: elasticsearch:7.12.1 container_name: es02 environment: - node.name=es02 - cluster.name=es-docker-cluster - discovery.seed_hosts=es01,es03 - cluster.initial_master_nodes=es01,es02,es03 - \u0026#34;ES_JAVA_OPTS=-Xms512m -Xmx512m\u0026#34; volumes: - data02:/usr/share/elasticsearch/data ports: - 9201:9200 networks: - elastic es03: image: elasticsearch:7.12.1 container_name: es03 environment: - node.name=es03 - cluster.name=es-docker-cluster - discovery.seed_hosts=es01,es02 - cluster.initial_master_nodes=es01,es02,es03 - \u0026#34;ES_JAVA_OPTS=-Xms512m -Xmx512m\u0026#34; volumes: - data03:/usr/share/elasticsearch/data networks: - elastic ports: - 9202:9200 volumes: data01: driver: local data02: driver: local data03: driver: local networks: elastic: driver: bridge ESを動かすにはLinuxのシステム権限をいくつか変更する必要があるんだ。/etc/sysctl.conf ファイルを編集するよ。\n1 vi /etc/sysctl.conf 以下の内容を追加してね：\n1 vm.max_map_count=262144 それから、コマンドを実行して設定を有効にするんだ：\n1 sysctl -p docker-composeでクラスターを起動するよ：\n1 docker-compose up -d クラスターの状態監視 KibanaでもESクラスターを監視できるけど、ESのX-Pack機能に依存するから設定がちょっと複雑なんだ。\nCerebroを使ってESクラスターを監視することもできるよ。Githubはこちら： https://github.com/lmenezes/cerebro bin/cerebro.bat を実行したら http://localhost:9000 にアクセスするだけで管理画面に入れるよ。\nCerebroを使えばインデックスを視覚的に作成できるんだ。以下はDSLステートメントでの作成例だよ。\n1 2 3 4 5 6 7 8 9 10 11 12 PUT /indexName { \u0026#34;settings\u0026#34;: { \u0026#34;number_of_shards\u0026#34;: 3, // シャード数 \u0026#34;number_of_replicas\u0026#34;: 1 // レプリカ数 }, \u0026#34;mappings\u0026#34;: { \u0026#34;properties\u0026#34;: { // マッピング定義 ... } } } クラスターの役割分担 ESのクラスターノードには異なる役割があるんだ。\nノードタイプ 設定パラメータ デフォルト値 ノードの役割 マスター適格 node.master true 候補マスターノード：マスターノードはクラスターの状態を管理・記録したり、シャードがどのノードにあるかを決めたり、インデックスの作成・削除リクエストを処理したりできるよ。 データ node.data true データノード：データを保存したり、検索、集約、CRUDを行うんだ。 インジェスト node.ingest true データ保存前の前処理をするんだ。 コーディネーティング 上記3つのパラメータが全てfalseだとコーディネーティングノードになるよ。 なし 他のノードへリクエストをルーティングしたり、他のノードが処理した結果を結合してユーザーに返すんだ。 デフォルトだと、クラスターのどのノードも上記の4つの役割を同時に持ってるんだ。\nでも、実際のクラスターではクラスターの役割を分ける必要があるんだ。\nマスターノード：CPUの要求は高いけど、メモリの要求は低いよ。 データノード：CPUもメモリも要求が高いんだ。 コーディネーティングノード：ネットワーク帯域幅やCPUの要求が高いよ。 役割を分離することで、異なるノードの要求に合わせて異なるハードウェアを割り当ててデプロイできるんだ。それに、業務間の相互干渉も防げるよ。\nクラスターの脳裂問題 脳裂はクラスター内のノードが連絡を失うことで発生するんだ。\n3つのノードがあると仮定して、マスターノード (node1) が他のノードと通信できなくなった（ネットワークが遮断された）とするね。node2とnode3はnode1がダウンしたと判断して、新しいマスターを選出し直すんだ。もしnode3が選出されたら、クラスターは外部にサービスを提供し続けるけど、node2とnode3は独自のクラスターになり、node1も独自のクラスターになってしまう。2つのクラスター間でデータが同期されず、データの差異が生じることになるんだ。\nネットワークの遮断が正常に戻ると、クラスター内にマスターノードが2つできてしまうから、クラスターの状態が不一致になり、脳裂状態が発生するんだ。\n解決策：マスターノードに選出されるには、投票数が (適格ノード数 + 1) / 2 を超える必要があるんだ。だから、適格ノード数は奇数であるのがベストだよ。対応する設定項目は discovery.zen.minimum_master_nodes で、ES 7.0以降ではこれがデフォルト設定になってるから、通常は脳裂問題は発生しないんだ。\n例えば、上記の3つのノードで構成されたクラスターだと、投票数は (3+1)/2 = 2票を超える必要があるんだ。node3はnode2とnode3の投票を得てマスターに選出されるけど、node1は自分の一票しか得られないから選出されない。クラスター内には引き続き1つのマスターノードしか存在せず、脳裂は発生しないってわけだね。\nクラスターの分散ストレージ 新しいドキュメントを追加するときは、データが均等に分散されるように異なるシャードに保存するべきなんだけど、コーディネーティングノードはどうやってデータをどのシャードに保存するか決めるんだろうね？\nESはハッシュアルゴリズムを使って、ドキュメントがどのシャードに保存されるべきかを計算するんだ。\n公式：shard = hash(_routing) % number_of_shards\n説明：\n_routing はデフォルトでドキュメントのIDなんだ。 アルゴリズムはシャード数に関係してるから、インデックスが一度作成されたらシャード数は変更できないんだ。 ドキュメント追加のフロー：\nフロー：\nIDが1のドキュメントを新規追加する。 IDに対してハッシュ計算を行い、もし2が得られたらshard-2に対応して保存するんだ。 shard-2のプライマリシャードはnode3ノードにあるから、データをnode3にルーティングするよ。 ドキュメントを保存する。 shard-2のレプリカreplica-2（node2ノードにある）に同期する。 coordinating-nodeノードに結果を返す。 クラスターの分散クエリ ESのクエリは2つのフェーズに分かれているよ：\nscatter phase：分散フェーズで、coordinating nodeがリクエストを各シャードに分配するんだ。 gather phase：集約フェーズで、coordinating nodeがデータノードの検索結果をまとめて、最終的な結果セットとしてユーザーに返すよ。 クラスターのフェイルオーバー クラスターのマスターノードはクラスター内のノードの状態を監視していて、もしノードがダウンしたのを見つけたら、すぐにダウンしたノードのシャードデータを他のノードに移行させて、データの安全を確保するんだ。これをフェイルオーバーと呼ぶよ。\nクラスターに3つのノードがあって、node1がマスターノードだと仮定するね。\nnode1がダウンしたとしよう。 新しいマスターを選出し直す必要があるね。node2が選ばれたと仮定するよ。 node2がマスターノードになったら、クラスターの状態をチェックして、node1のシャードにレプリカノードがないことに気づくんだ。それで、node1上のデータをnode2、node3に移行させる必要があるってことになるよ。 ","date":"2025-02-15T17:17:08+09:00","permalink":"https://blog.yexca.net/ja/archives/235/","title":"Elasticsearch クラスター"},{"content":" 📢 この記事は gemini-2.5-flash によって翻訳されました Elasticsearch シリーズ\n内容 リンク Elasticsearch 基本操作 https://blog.yexca.net/ja/archives/226 Elasticsearch 検索操作 https://blog.yexca.net/ja/archives/227 RestClient 基本操作 https://blog.yexca.net/ja/archives/228 RestClient 検索操作 https://blog.yexca.net/ja/archives/229 Elasticsearch データ集計 https://blog.yexca.net/ja/archives/231 Elasticsearch オートコンプリート https://blog.yexca.net/ja/archives/232 Elasticsearch データ同期 この記事 Elasticsearch クラスター https://blog.yexca.net/ja/archives/235 Elasticsearch のデータは MySQL データベースから来てるんだ。だから、MySQL のデータが変わったら、Elasticsearch もそれに合わせて変わる必要があるんだよね。これが Elasticsearch と MySQL の間のデータ同期だよ。\nよくあるデータ同期の方法は3つあるよ。\n同期呼び出し 非同期通知 binlog 監視 同期呼び出し 手順：\nhotel-demo が外部にインターフェースを提供して、Elasticsearch のデータを変更するんだ。 バックエンド管理システム (hotel-admin) はデータベース操作が完了したら、hotel-demo が提供するインターフェースを直接呼び出すんだ。 非同期通知 手順：\nhotel-admin は MySQL データに対して CRUD 操作が完了したら、MQ メッセージを送信するよ。 hotel-demo は MQ を監視して、メッセージを受け取ったら Elasticsearch のデータを変更するんだ。 binlog 監視 流れ：\nMySQL の binlog 機能を有効にするんだ。 MySQL で CRUD 操作が完了すると、全部 binlog に記録されるよ。 hotel-demo は Canal を使って binlog の変化を監視し、Elasticsearch の内容をリアルタイムで更新するんだ。 アプローチ比較 方法1：同期呼び出し\nメリット：実装がシンプルで、手っ取り早い。 デメリット：業務の結合度が高い。 方法2：非同期通知\nメリット：低結合で、実装の難易度は普通。 デメリット：MQ の信頼性に依存する。 方法3：binlog 監視\nメリット：サービス間の結合を完全に解消できる。 デメリット：binlog を有効にするとデータベースの負荷が増えるし、実装の複雑度が高い。 データ同期の実装 説明：MQ 非同期通知を使って、hotel-admin で MySQL の CRUD 操作を実装するよ。\nhotel-admin と hotel-demo に RabbitMQ の依存関係を追加するんだ。\n1 2 3 4 5 \u0026lt;!--amqp--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-amqp\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; キューとエクスチェンジ名を宣言するよ。\n1 2 3 4 5 6 7 8 9 10 11 12 public class MqConstants { // 交换机 public final static String HOTEL_EXCHANGE = \u0026#34;hotel.topic\u0026#34;; // 监听新增和修改队列 public final static String HOTEL_INSERT_QUEUE = \u0026#34;hotel.insert.queue\u0026#34;; // 监听删除的队列 public final static String HOTEL_DELETE_QUEUE = \u0026#34;hotel.delete.queue\u0026#34;; // 新增或修改的RoutingKey public final static String HOTEL_INSERT_KEY = \u0026#34;hotel.insert\u0026#34;; // 删除的RoutingKey public final static String HOTEL_DELETE_KEY = \u0026#34;hotel.delete\u0026#34;; } hotel-demo でエクスチェンジ設定を宣言する。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 @Configuration public class MqConfig { @Bean public TopicExchange topicExchange(){ return new TopicExchange(MqConstants.HOTEL_EXCHANGE,true,false); } @Bean public Queue insertQueue(){ return new Queue(MqConstants.HOTEL_INSERT_QUEUE,true); } @Bean public Queue deleteQueue(){ return new Queue(MqConstants.HOTEL_DELETE_QUEUE, true); } @Bean public Binding insertQueueBinding(){ return BindingBuilder.bind(insertQueue()).to(topicExchange()).with(MqConstants.HOTEL_INSERT_KEY); } @Bean public Binding deleteQueueBinding(){ return BindingBuilder.bind(deleteQueue()).to(topicExchange()).with(MqConstants.HOTEL_DELETE_KEY); } } hotel-admin で MQ メッセージを送信するよ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public class HotelController { @Autowired private RabbitTemplate rabbitTemplate; @PostMapping public void saveHotel(@RequestBody Hotel hotel){ hotelService.save(hotel); rabbitTemplate.convertAndSend(MqConstants.HOTEL_EXCHANGE, MqConstants.HOTEL_INSERT_KEY, hotel.getId()); } @PutMapping() public void updateById(@RequestBody Hotel hotel){ if (hotel.getId() == null) { throw new InvalidParameterException(\u0026#34;id不能为空\u0026#34;); } hotelService.updateById(hotel); rabbitTemplate.convertAndSend(MqConstants.HOTEL_EXCHANGE, MqConstants.HOTEL_INSERT_KEY,hotel.getId()); } @DeleteMapping(\u0026#34;/{id}\u0026#34;) public void deleteById(@PathVariable(\u0026#34;id\u0026#34;) Long id) { hotelService.removeById(id); rabbitTemplate.convertAndSend(MqConstants.HOTEL_EXCHANGE, MqConstants.HOTEL_DELETE_KEY, id); } } hotel-demo で MQ メッセージを受け取るんだけど、ビジネスロジックはこんな感じだよ。\n新規追加メッセージ：渡された hotel.id に基づいて情報を検索し、それからインデックスに新しいデータを1件追加する。 削除メッセージ：渡された hotel.id に基づいてインデックスからデータを1件削除する。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 @Override public void deleteById(Long id) { try { // 准备request DeleteRequest request = new DeleteRequest(\u0026#34;hotel\u0026#34;, id.toString()); // 发送请求 client.delete(request, RequestOptions.DEFAULT); } catch (IOException e) { throw new RuntimeException(e); } } @Override public void insertById(Long id) { try { // 根据id查询数据 Hotel hotel = getById(id); // 转换文档类型 HotelDoc hotelDoc = new HotelDoc(hotel); // 准备request IndexRequest request = new IndexRequest(\u0026#34;hotel\u0026#34;).id(id.toString()); // 准备json request.source(JSON.toJSONString(hotelDoc), XContentType.JSON); // 发送请求 client.index(request, RequestOptions.DEFAULT); } catch (IOException e) { throw new RuntimeException(e); } } hotel-demo でリスナーを書くよ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 @Component public class HotelLinster { @Autowired private IHotelService hotelService; /** * 监听修改或新增 * @param id */ @RabbitListener(queues = MqConstants.HOTEL_INSERT_QUEUE) public void listenHotelInsertOrUpdate(Long id){ hotelService.insertById(id); } /** * 监听删除 * @param id */ @RabbitListener(queues = MqConstants.HOTEL_DELETE_QUEUE) public void listenHotelDelete(Long id){ hotelService.deleteById(id); } } ","date":"2025-02-14T20:36:55+09:00","permalink":"https://blog.yexca.net/ja/archives/234/","title":"Elasticsearch データ同期"},{"content":" 📢 この記事は gemini-2.5-flash によって翻訳されました この記事の作成から最終更新までの期間は2022.10.31 - 2024.09.15で、この間に俺が試したお茶と個人的な感想を記録したものだよ。\nでも結構後期になると、正直この趣味にそんなに熱中できなくなって、記録も適当になっちゃったんだよね。とはいえ、自分がやった趣味だし、記事番号も233番になったことだし、なんかちょっと面白い記事にしちゃおうかなって (とっくに公開したと思ってたけど、今まで引き延ばしちゃったんだ)\n紅茶 名前 味 妃子笑 最初はなんか重くてしつこい感じの味何回か淹れたらサツマイモみたいな味になっただいたい12煎くらいかな 水蜜桃 初めて淹れた時、『妃子笑』よりちょっと苦くて、しつこくなかった夜に呼吸が苦しくなって、血が出た。お茶のせいかは不明 昔帰紅 最初は甘くてしつこくなく、苦くなくて渋みもなくて、すごく良かった 祁門紅茶 最初は『昔帰紅』と似た感じ、甘くはないけど、たぶんもっとまろやかでも茶葉はかなり細かかった 金駿眉 まろやかすぎ、むしろちょっと苦渋い。でも3杯目以降は口の中に香りと甘みが残る茶葉は細かくて、淹れる回数もそんなに多くない 酔紅 まさに紅茶の味煎数はまあまあいけるけど、蒸らしすぎはダメ。茶殻が多め 煙熏小種 確かに燻製っぽい匂いがする\n口に入れた瞬間は苦いけど、後味が甘い 老叢紅茶 美味しい 黒茶 名前 味 金奨六類 八宝粥みたいな味 参香六堡 薬みたいな苦味がある 天尖 最初は美味しいって感動した（たぶん上に書いてある2つのお茶を飲んだせいかも）\n苦渋いけど、甘みが戻ってくる\n何回も飲むと苦渋すぎる 金花茯磚 薄い「金奨六類」+薄い「参香六堡」 老青磚 古い木みたいな味、茶殻が多すぎる 老熟普 あんまり美味しくない感じ 老生普 なかなか開かない、苦い 古樹熟普 上の二つと比べたら、まあ飲めるかな 普洱生茶 最初にちょっと苦渋いけど、後から甘みが戻ってくる\n二日置いたらてっぺんがカビてて、淹れたら苦渋みがすごかった 普洱熟茶 八宝粥味 白茶 名前 味 荒野貢眉 口に入れた瞬間はフレッシュな農作物っぽい、ちょっと苦渋い感じだけど、甘くてまろやか 昔帰白 塊のお茶。広げてから飲んでみたら、口に入れた瞬間は蜂蜜みたいな甘さで、香りが残る\n煎数はめっちゃ多い、10煎以上はいける 野小白 飲んでる時は苦渋いけど、飲んだ後に口の中に甘みが残る 白毫銀針 お茶の色がすごく薄い。最初の1煎はちょっと草っぽい味、その後は少し蜂蜜みたいな甘さで、口の中に甘みが残る 氷糖甜 最初の1、2煎は草っぽい味、その後は普通の白茶の味 老白茶 クラシックな白茶の味、かなり甘い 高寿 最初の一口は草っぽい味、その後は普通の白茶の味 烏龍茶 名前 味 大紅袍 量が多い、いける、ほのかに甘い 鉄観音 お茶の香りはあるけど苦渋い 蘭底水仙 苦渋い 鴨屎香単叢 最初の2煎はほんのり烏龍茶の香り、それ以降は薄味 蜜蘭香単叢 口に入れた瞬間は無味、後から香りが残り、その後はすごく苦い 梨山烏龍 ほんのり木のような味、淹れて開くと普通の烏龍茶の味 流香肉桂 口に入れた瞬間は木のような味、後から甘みが戻ってくる 白牡丹 最初は油っぽいお茶の香り、口に入れた瞬間は木のような味 清香鉄観音 だいたい同じような味、薄い香り 漳平水仙 だいたい同じような味、薄い香り 古法鉄観音 上のやつらと比べると味は悪くない 岩茶 名前 味 大紅袍 苦い 杏桃香 変な味、苦い 佛國岩肉桂 口に入れた瞬間はわずかに苦いけど、後から口の中に香りが残る 佛手雪梨 苦味しかないみたい、しばらく経つと香りが残る 留香肉桂 上と同じ、岩茶っぽい感じ 籣底水仙 名前はすごくいい感じだけど、味はやっぱり岩茶っぽい。甘さは高いけどね 奇丹 印刷されてる名前は『上立下可』だけど、この漢字なんだかわからん、手書きでも無理だった\n味は比較的軽めで、岩茶の戻り甘さも残ってるし、かなりいい感じだった 不明 名前 味 小青柑 黒茶、良くない、ちょっと酸っぱい\n体験最悪、3日目には酸っぱい匂いがした 安吉白 見た目もいいし、すごくいい香り、栗の味、ちょっとしつこい 蒙頂黄芽 上のやつと似てるけど、こっちの方が少し良い 茉莉雪芽 茶葉がいい香り、お茶も清々しい香り、飲んだ後も口に香りが残る\n烏龍茶なのかな？ ","date":"2025-02-12T23:58:53+09:00","permalink":"https://blog.yexca.net/ja/archives/233/","title":"俺のお茶飲み記録"},{"content":" 📢 この記事は gemini-2.5-flash によって翻訳されました Elasticsearch シリーズ\n内容 リンク Elasticsearch 基本操作 https://blog.yexca.net/ja/archives/226 Elasticsearch 検索操作 https://blog.yexca.net/ja/archives/227 RestClient 基本操作 https://blog.yexca.net/ja/archives/228 RestClient 検索操作 https://blog.yexca.net/ja/archives/229 Elasticsearch データ集計 https://blog.yexca.net/ja/archives/231 Elasticsearch オートコンプリート この記事 Elasticsearch データ同期 https://blog.yexca.net/ja/archives/234 Elasticsearch クラスター https://blog.yexca.net/ja/archives/235 ユーザーが検索ボックスに文字を入力したときに、その文字に関連する検索候補を表示し、入力された文字に基づいて単語を補完する機能、それがオートコンプリートだよ。\nピンイン分かち書き 文字に基づいて補完を実現するには、ドキュメントをピンインで分かち書きする必要があるんだ。\nプロジェクトのURL： https://github.com/medcl/elasticsearch-analysis-pinyin インストール方法はIKアナライザーと同じだよ。以下はオンラインインストール方法で、まずコンテナに入るんだ。\n1 docker exec -it es /bin/bash コマンドを実行するよ。\n1 ./bin/elasticsearch-plugin install https://github.com/infinilabs/analysis-pinyin/releases/download/v7.12.1/elasticsearch-analysis-pinyin-7.12.1.zip それから終了して再起動するんだ。\n1 2 3 4 # 終了 exit # 再起動 docker restart es テストしてみよう。\n1 2 3 4 5 6 # ピンイン分かち書きのテスト POST /_analyze { \u0026#34;text\u0026#34;: \u0026#34;世界第一可爱\u0026#34;, \u0026#34;analyzer\u0026#34;: \u0026#34;pinyin\u0026#34; } カスタムアナライザー デフォルトのピンインアナライザーだと、各漢字を個別のピンインに分けちゃうんだ。でも、僕らが欲しいのは、各単語がピンインのまとまりになることだから、ピンインアナライザーをカスタマイズして、独自のカスタムアナライザーを作る必要があるね。\nElasticsearchのアナライザーは3つの部分で構成されてるよ。\ncharacter filters：tokenizerの前にテキストを処理する部分。例えば、文字の削除や置換とかね。 tokenizer：テキストを一定のルールに従って単語（term）に分割する部分。例えばkeywordだと分かち書きしないし、ik_smartとかもあるね。 tokenizer filter：tokenizerが出力した単語をさらに処理する部分。例えば、大文字小文字変換、同義語処理、ピンイン処理とかだよ。 カスタムアナライザーを宣言する構文はこんな感じ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 # カスタムアナライザー PUT /test { \u0026#34;settings\u0026#34;: { \u0026#34;analysis\u0026#34;: { \u0026#34;analyzer\u0026#34;: { // カスタムアナライザー \u0026#34;my_analyzer\u0026#34;: { // アナライザー名 \u0026#34;tokenizer\u0026#34;: \u0026#34;ik_max_word\u0026#34;, \u0026#34;filter\u0026#34;: \u0026#34;py\u0026#34; } }, \u0026#34;filter\u0026#34;: { // カスタムtokenizerフィルター \u0026#34;py\u0026#34;: { // フィルター名 \u0026#34;type\u0026#34;: \u0026#34;pinyin\u0026#34;, // フィルタータイプ // 設定項目はGithubで説明されてるよ \u0026#34;keep_full_piny\u0026#34;: false, \u0026#34;keep_joined_full_pinyin\u0026#34;: true, \u0026#34;keep_original\u0026#34;: true, \u0026#34;limit_first_letter_length\u0026#34;: 16, \u0026#34;remove_duplicated_term\u0026#34;: true, \u0026#34;none_chinese_pinyin_tokenize\u0026#34;: false } } } }, \u0026#34;mappings\u0026#34;: { \u0026#34;properties\u0026#34;: { \u0026#34;name\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;text\u0026#34;, \u0026#34;analyzer\u0026#34;: \u0026#34;my_analyzer\u0026#34;, \u0026#34;search_analyzer\u0026#34;: \u0026#34;ik_smart\u0026#34; } } } } テストしてみよう。\n1 2 3 4 5 6 # カスタムアナライザーのテスト POST /test/_analyze { \u0026#34;text\u0026#34;: \u0026#34;世界第一可爱\u0026#34;, \u0026#34;analyzer\u0026#34;: \u0026#34;my_analyzer\u0026#34; } オートコンプリート検索 Elasticsearchはオートコンプリート機能を実現するために、 Completion Suggester という検索を提供してるんだ。このクエリは、ユーザーが入力した内容で始まる単語をマッチさせて返すよ。補完検索の効率を上げるために、ドキュメント内のフィールドタイプにはいくつか制約があるんだ。\n補完検索に関わるフィールドはcompletionタイプである必要があるんだ。 フィールドの内容は通常、補完に使われる複数の単語からなる配列だよ。 テスト用のインデックスを作成するよ。\n1 2 3 4 5 6 7 8 9 10 PUT /test { \u0026#34;mappings\u0026#34;: { \u0026#34;properties\u0026#34;: { \u0026#34;title\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;completion\u0026#34; } } } } テストデータを挿入するよ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 # サンプルデータ POST /test/_doc { \u0026#34;title\u0026#34;: [\u0026#34;Sony\u0026#34;, \u0026#34;WH-1000XM3\u0026#34;] } POST /test/_doc { \u0026#34;title\u0026#34;: [\u0026#34;SK-II\u0026#34;, \u0026#34;PITERA\u0026#34;] } POST /test/_doc { \u0026#34;title\u0026#34;: [\u0026#34;Nintendo\u0026#34;, \u0026#34;switch\u0026#34;] } 検索\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 # オートコンプリート検索 GET /test/_search { \u0026#34;suggest\u0026#34;: { \u0026#34;title_suggest\u0026#34;: { \u0026#34;text\u0026#34;: \u0026#34;s\u0026#34;, // キーワード \u0026#34;completion\u0026#34;: { \u0026#34;field\u0026#34;: \u0026#34;title\u0026#34;, // オートコンプリート検索のフィールド \u0026#34;skip_duplicates\u0026#34;: true, // 重複をスキップ \u0026#34;size\u0026#34;: 10 // 上位10件のデータを取得 } } } } オートコンプリート Java 上記のDSLをJavaでリクエストするよ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @Test public void testAutoIn(){ SearchRequest request = new SearchRequest(\u0026#34;hotel\u0026#34;); // リクエストパラメータ request.source() .suggest(new SuggestBuilder().addSuggestion( \u0026#34;title_suggest\u0026#34;, // クエリ名 SuggestBuilders .completionSuggestion(\u0026#34;title\u0026#34;) // オートコンプリート検索のフィールド .prefix(\u0026#34;s\u0026#34;) // キーワード .skipDuplicates(true) // 重複をスキップ .size(10) // 上位10件のデータを取得 )); // リクエストを送信 SearchResponse response = client.search(request, RequestOptions.DEFAULT); } レスポンスの処理だよ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 @Test public void testAutoIn(){ SearchRequest request = new SearchRequest(\u0026#34;hotel\u0026#34;); // リクエストパラメータ request.source() .suggest(new SuggestBuilder().addSuggestion( \u0026#34;mySuggestion\u0026#34;, SuggestBuilders .completionSuggestion(\u0026#34;suggestion\u0026#34;) .prefix(\u0026#34;h\u0026#34;) .skipDuplicates(true) .size(10) )); // リクエストを送信 try { SearchResponse response = client.search(request, RequestOptions.DEFAULT); // レスポンスを処理 Suggest suggest = response.getSuggest(); // 名前で補完結果を取得 CompletionSuggestion mySuggestion = suggest.getSuggestion(\u0026#34;mySuggestion\u0026#34;); // optionsを取得してループ処理 for (CompletionSuggestion.Entry.Option option : mySuggestion.getOptions()) { String text = option.getText().string(); System.out.println(text); } } catch (IOException e) { throw new RuntimeException(e); } } ホテル検索のオートコンプリート 以前のhotelインデックスはピンインアナライザーが設定されてなかったんだ。でも、インデックスは変更できないから、削除して再構築する必要があるよ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 # 削除して再構築 DELETE /hotel PUT /hotel { \u0026#34;settings\u0026#34;: { \u0026#34;analysis\u0026#34;: { \u0026#34;analyzer\u0026#34;: { \u0026#34;text_analyzer\u0026#34;: { \u0026#34;tokenizer\u0026#34;: \u0026#34;ik_max_word\u0026#34;, \u0026#34;filter\u0026#34;: \u0026#34;py\u0026#34; }, \u0026#34;completion_analyzer\u0026#34;: { \u0026#34;tokenizer\u0026#34;: \u0026#34;keyword\u0026#34;, \u0026#34;filter\u0026#34;: \u0026#34;py\u0026#34; } }, \u0026#34;filter\u0026#34;: { \u0026#34;py\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;pinyin\u0026#34;, \u0026#34;keep_full_pinyin\u0026#34;: false, \u0026#34;keep_joined_full_pinyin\u0026#34;: true, \u0026#34;keep_original\u0026#34;: true, \u0026#34;limit_first_letter_length\u0026#34;: 16, \u0026#34;remove_duplicated_term\u0026#34;: true, \u0026#34;none_chinese_pinyin_tokenize\u0026#34;: false } } } }, \u0026#34;mappings\u0026#34;: { \u0026#34;properties\u0026#34;: { \u0026#34;id\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;keyword\u0026#34; }, \u0026#34;name\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;text\u0026#34;, \u0026#34;analyzer\u0026#34;: \u0026#34;text_analyzer\u0026#34;, \u0026#34;search_analyzer\u0026#34;: \u0026#34;ik_smart\u0026#34;, \u0026#34;copy_to\u0026#34;: \u0026#34;all\u0026#34; }, \u0026#34;address\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;keyword\u0026#34;, \u0026#34;index\u0026#34;: false }, \u0026#34;price\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;integer\u0026#34; }, \u0026#34;score\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;integer\u0026#34; }, \u0026#34;brand\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;keyword\u0026#34;, \u0026#34;copy_to\u0026#34;: \u0026#34;all\u0026#34; }, \u0026#34;city\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;keyword\u0026#34; }, \u0026#34;starName\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;keyword\u0026#34; }, \u0026#34;business\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;keyword\u0026#34;, \u0026#34;copy_to\u0026#34;: \u0026#34;all\u0026#34; }, \u0026#34;location\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;geo_point\u0026#34; }, \u0026#34;pic\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;keyword\u0026#34;, \u0026#34;index\u0026#34;: false }, \u0026#34;all\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;text\u0026#34;, \u0026#34;analyzer\u0026#34;: \u0026#34;text_analyzer\u0026#34;, \u0026#34;search_analyzer\u0026#34;: \u0026#34;ik_smart\u0026#34; }, \u0026#34;suggestion\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;completion\u0026#34;, \u0026#34;analyzer\u0026#34;: \u0026#34;completion_analyzer\u0026#34; } } } } HotelDocエンティティクラスを修正して、suggestionフィールドを追加するよ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 @Data @NoArgsConstructor public class HotelDoc { private Long id; private String name; private String address; private Integer price; private Integer score; private String brand; private String city; private String starName; private String business; private String location; private String pic; private Object distance; // 広告 private Boolean isAD; // オートコンプリート private List\u0026lt;String\u0026gt; suggestion; public HotelDoc(Hotel hotel) { this.id = hotel.getId(); this.name = hotel.getName(); this.address = hotel.getAddress(); this.price = hotel.getPrice(); this.score = hotel.getScore(); this.brand = hotel.getBrand(); this.city = hotel.getCity(); this.starName = hotel.getStarName(); this.business = hotel.getBusiness(); this.location = hotel.getLatitude() + \u0026#34;, \u0026#34; + hotel.getLongitude(); this.pic = hotel.getPic(); // suggestionを組み立てる if(this.business.contains(\u0026#34;/\u0026#34;)){ // businessに複数の値がある場合、分割する必要がある String[] arr = this.business.split(\u0026#34;/\u0026#34;); // 要素を追加 this.suggestion = new ArrayList\u0026lt;\u0026gt;(); this.suggestion.add(this.brand); Collections.addAll(this.suggestion, arr); }else { this.suggestion = Arrays.asList(this.brand, this.business); } } } データを再インポートするよ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 @Test public void testBulk() throws IOException { // データを一括検索 List\u0026lt;Hotel\u0026gt; hotelList = hotelService.list(); // bulkリクエストを作成 BulkRequest request = new BulkRequest(); // bulkリクエストを追加 for (Hotel hotel : hotelList) { // ドキュメントタイプを変換 HotelDoc hotelDoc = new HotelDoc(hotel); // 新規ドキュメントのrequestオブジェクトを作成 request.add(new IndexRequest(\u0026#34;hotel\u0026#34;) .id(hotelDoc.getId().toString()) .source(JSON.toJSONString(hotelDoc), XContentType.JSON) ); } // bulkリクエストを発行 client.bulk(request, RequestOptions.DEFAULT); } 検索テスト\n1 2 3 4 5 6 GET /hotel/_search { \u0026#34;query\u0026#34;: { \u0026#34;match_all\u0026#34;: {} } } 検索結果のsuggestionフィールドを確認できるはずだよ。そしたら、ビジネスコードを書こう。\nController\n1 2 3 4 @GetMapping(\u0026#34;/suggestion\u0026#34;) public List\u0026lt;String\u0026gt; getSuggestion(@RequestParam(\u0026#34;key\u0026#34;) String prefix){ return hotelService.getSuggestion(prefix); } Service\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 public List\u0026lt;String\u0026gt; getSuggestion(String prefix) { SearchRequest request = new SearchRequest(\u0026#34;hotel\u0026#34;); request.source().suggest( new SuggestBuilder().addSuggestion( \u0026#34;mySuggestion\u0026#34;, SuggestBuilders .completionSuggestion(\u0026#34;suggestion\u0026#34;) .prefix(prefix) .size(10) .skipDuplicates(true) ) ); try { SearchResponse response = client.search(request, RequestOptions.DEFAULT); Suggest suggestions = response.getSuggest(); CompletionSuggestion mySuggestion = suggestions.getSuggestion(\u0026#34;mySuggestion\u0026#34;); List\u0026lt;CompletionSuggestion.Entry.Option\u0026gt; options = mySuggestion.getOptions(); ArrayList\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(options.size()); for (CompletionSuggestion.Entry.Option option : options) { String text = option.getText().string(); list.add(text); } return list; } catch (IOException e) { throw new RuntimeException(e); } } ","date":"2025-02-09T17:29:28+09:00","permalink":"https://blog.yexca.net/ja/archives/232/","title":"Elasticsearch オートコンプリート"},{"content":" 📢 この記事は gemini-2.5-flash によって翻訳されました Elasticsearch シリーズ\n内容 リンク Elasticsearch 基礎操作 https://blog.yexca.net/ja/archives/226 Elasticsearch クエリ操作 https://blog.yexca.net/ja/archives/227 RestClient 基礎操作 https://blog.yexca.net/ja/archives/228 RestClient クエリ操作 https://blog.yexca.net/ja/archives/229 Elasticsearch データアグリゲーション この記事 Elasticsearch 自動補完 https://blog.yexca.net/ja/archives/232 Elasticsearch データ同期 https://blog.yexca.net/ja/archives/234 Elasticsearch クラスター https://blog.yexca.net/ja/archives/235 アグリゲーション (aggregations) を使うと、データの統計、分析、演算がすごく簡単にできちゃうんだ。例えばこんな感じ:\nどんなブランドのスマホが一番人気？ これらのスマホの平均価格、最高価格、最低価格は？ これらのスマホの月ごとの販売状況はどうなってる？ アグリゲーションの種類 よく使われるのは3種類だよ:\nバケット (bucket) アグリゲーション：ドキュメントをグループ分けするのに使うんだ。 TermAggregation：ドキュメントのフィールド値でグループ分けするよ。例えばブランド別、国別とかね。 Date Histogram：日付の区切りでグループ分けするんだ。例えば1週間ごととか1ヶ月ごととか。 メトリック (metric) アグリゲーション：最大値、最小値、平均値などを計算するのに使うよ。 Avg：平均値 Max：最大値 Min：最小値 Stats：最大値、最小値、平均値、合計などをまとめて求めるんだ。 パイプライン (pipeline) アグリゲーション：他のアグリゲーションの結果をベースにして、さらにアグリゲーションを行うんだ。 アグリゲーションに参加するフィールドは、keyword、日付、数値、ブーリアン型である必要があるよ。\nDSL アグリゲーションクエリ bucket 全データの中でホテルのブランドが何種類あるか数える、つまりブランドごとにデータをグループ分けするよ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 # bucket term GET /hotel/_search { \u0026#34;size\u0026#34;: 0, // sizeを0に設定すると、結果にドキュメントは含まれず、アグリゲーション結果だけになるよ。 \u0026#34;aggs\u0026#34;: { \u0026#34;brandAgg\u0026#34;: { // アグリゲーション名 \u0026#34;terms\u0026#34;: { // アグリゲーションタイプ \u0026#34;field\u0026#34;: \u0026#34;brand\u0026#34;, // アグリゲーション対象フィールド \u0026#34;size\u0026#34;: 20 // 取得するアグリゲーション結果の数 } } } } アグリゲーション結果のソート デフォルトでは、バケットアグリゲーションはバケット内のドキュメント数を数えて（これをcountと呼ぶよ）、countの降順でソートされるんだ。order属性を指定すれば、ソート方法をカスタマイズできるよ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 GET /hotel/_search { \u0026#34;size\u0026#34;: 0, \u0026#34;aggs\u0026#34;: { \u0026#34;brandAgg\u0026#34;: { \u0026#34;terms\u0026#34;: { \u0026#34;field\u0026#34;: \u0026#34;brand\u0026#34;, \u0026#34;size\u0026#34;: 20, \u0026#34;order\u0026#34;: { // ソート \u0026#34;_count\u0026#34;: \u0026#34;asc\u0026#34; } } } } } アグリゲーション範囲の限定 デフォルトではインデックス内の全ドキュメントに対してアグリゲーションが実行されるんだけど、実際にはユーザーが検索条件を入力するから、アグリゲーションは検索結果に対して行われるべきだよね。だから、アグリゲーションには条件を追加する必要があるんだ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # bucket query GET /hotel/_search { \u0026#34;query\u0026#34;: { \u0026#34;range\u0026#34;: { \u0026#34;price\u0026#34;: { \u0026#34;lte\u0026#34;: 200 // 価格が200未満のドキュメントのみをアグリゲーションする。 } } }, \u0026#34;size\u0026#34;: 0, \u0026#34;aggs\u0026#34;: { \u0026#34;brandAggQuery\u0026#34;: { \u0026#34;terms\u0026#34;: { \u0026#34;field\u0026#34;: \u0026#34;brand\u0026#34;, \u0026#34;size\u0026#34;: 20 } } } } Metric さっきのbucketアグリゲーションでブランドごとにグループ分けしたけど、今度は各ブランドのユーザー評価の最小値、最大値、平均値を取得したいな。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # metric GET /hotel/_search { \u0026#34;size\u0026#34;: 0, \u0026#34;aggs\u0026#34;: { \u0026#34;brandAgg\u0026#34;: { \u0026#34;terms\u0026#34;: { \u0026#34;field\u0026#34;: \u0026#34;brand\u0026#34;, \u0026#34;size\u0026#34;: 20 }, \u0026#34;aggs\u0026#34;: { // bucketのサブアグリゲーションで、グループ分けされた各グループに対して演算を行うよ。 \u0026#34;scoreStats\u0026#34;: { // アグリゲーション名 \u0026#34;stats\u0026#34;: { // アグリゲーションタイプ \u0026#34;field\u0026#34;: \u0026#34;score\u0026#34; // アグリゲーションフィールド } } } } } } 平均値でソート\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 GET /hotel/_search { \u0026#34;size\u0026#34;: 0, \u0026#34;aggs\u0026#34;: { \u0026#34;brandAgg\u0026#34;: { \u0026#34;terms\u0026#34;: { \u0026#34;field\u0026#34;: \u0026#34;brand\u0026#34;, \u0026#34;size\u0026#34;: 20, \u0026#34;order\u0026#34;: { \u0026#34;scoreStats.avg\u0026#34;: \u0026#34;desc\u0026#34; // 平均値の降順 } }, \u0026#34;aggs\u0026#34;: { \u0026#34;scoreStats\u0026#34;: { \u0026#34;stats\u0026#34;: { \u0026#34;field\u0026#34;: \u0026#34;score\u0026#34; } } } } } } RestAPI アグリゲーション 構文 アグリゲーション条件はqueryと同じ階層だから、request.source() を使ってアグリゲーション条件を指定するよ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 @Test public void testAggTerm() throws IOException { SearchRequest request = new SearchRequest(\u0026#34;hotel\u0026#34;); request.source().size(0); request.source().aggregation( AggregationBuilders .terms(\u0026#34;brandAgg\u0026#34;) .field(\u0026#34;brand\u0026#34;) .size(20) ); SearchResponse response = client.search(request, RequestOptions.DEFAULT); } レスポンス処理\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 @Test public void testAggTerm() throws IOException { SearchRequest request = new SearchRequest(\u0026#34;hotel\u0026#34;); request.source().size(0); request.source().aggregation( AggregationBuilders .terms(\u0026#34;brandAgg\u0026#34;) .field(\u0026#34;brand\u0026#34;) .size(20) ); SearchResponse response = client.search(request, RequestOptions.DEFAULT); // アグリゲーション結果をパースする。 Aggregations aggregations = response.getAggregations(); // 名前でアグリゲーション結果を取得する。 Terms term = aggregations.get(\u0026#34;brandAgg\u0026#34;); // バケットを取得する。 List\u0026lt;? extends Terms.Bucket\u0026gt; buckets = term.getBuckets(); // イテレートする。 for (Terms.Bucket bucket : buckets) { // キーを取得する。 String name = bucket.getKeyAsString(); System.out.println(name); } } 実装要件 フロントエンドページの都市、星評価、ブランドは選択肢が固定されていて、検索入力によって変わらないんだ。\nでも、「東方明珠」で検索したら、都市は上海だけになるべきで、他の都市は表示されるべきじゃないよね。\nつまり、選択可能な都市などは検索入力の内容に応じて変わるべきなんだ。そのためには、フロントエンドは内容に基づいて選択可能な都市をリクエストする必要があるよ。インターフェースはこんな感じを想定:\nリクエスト方式：POST リクエストパス：/hotel/filters リクエストパラメータ：RequestParams、検索ドキュメントのパラメータと同じ 戻り値の型：Map\u0026lt;String, List\u0026lt;String\u0026gt;\u0026gt; Controller\n1 2 3 4 @PostMapping(\u0026#34;/filters\u0026#34;) public Map\u0026lt;String, List\u0026lt;String\u0026gt;\u0026gt; getFilters(@RequestBody RequestParams params){ return hotelService.getFilters(params); } Service\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 public Map\u0026lt;String, List\u0026lt;String\u0026gt;\u0026gt; getFilters(RequestParams params) { // リクエスト SearchRequest request = new SearchRequest(\u0026#34;hotel\u0026#34;); // DSL basicQuery(params, request); // sizeを設定 request.source().size(0); // アグリゲーション request.source().aggregation( AggregationBuilders .terms(\u0026#34;brandAgg\u0026#34;) .field(\u0026#34;brand\u0026#34;) .size(100) ); request.source().aggregation( AggregationBuilders .terms(\u0026#34;cityAgg\u0026#34;) .field(\u0026#34;city\u0026#34;) .size(100) ); request.source().aggregation( AggregationBuilders .terms(\u0026#34;starAgg\u0026#34;) .field(\u0026#34;starName\u0026#34;) .size(100) ); // リクエスト実行 try { SearchResponse response = client.search(request, RequestOptions.DEFAULT); // レスポンスをパース Map\u0026lt;String, List\u0026lt;String\u0026gt;\u0026gt; result = new HashMap\u0026lt;\u0026gt;(); Aggregations aggregations = response.getAggregations(); // ブランド List\u0026lt;String\u0026gt; brandList = getAggName(aggregations, \u0026#34;brandAgg\u0026#34;); result.put(\u0026#34;ブランド\u0026#34;, brandList); // 都市 List\u0026lt;String\u0026gt; cityList = getAggName(aggregations, \u0026#34;cityAgg\u0026#34;); result.put(\u0026#34;都市\u0026#34;, cityList); // 星評価 List\u0026lt;String\u0026gt; starList = getAggName(aggregations, \u0026#34;starAgg\u0026#34;); result.put(\u0026#34;星級\u0026#34;, starList); return result; } catch (IOException e) { throw new RuntimeException(e); } } private static List\u0026lt;String\u0026gt; getAggName(Aggregations aggregations, String name) { // ブランドを取得 Terms brand = aggregations.get(name); // バケットを取得 List\u0026lt;? extends Terms.Bucket\u0026gt; buckets = brand.getBuckets(); // イテレート List\u0026lt;String\u0026gt; brandList = new ArrayList\u0026lt;\u0026gt;(); for (Terms.Bucket bucket : buckets) { // キーを取得 String key = bucket.getKeyAsString(); brandList.add(key); } return brandList; } ","date":"2025-02-08T14:56:36+09:00","permalink":"https://blog.yexca.net/ja/archives/231/","title":"Elasticsearch データアグリゲーション"},{"content":" 音に感じてシリーズ 曲 翻訳 リンク 僕が死のうと思ったのは 略 https://blog.yexca.net/ja/archives/214 あくあ色ぱれっと 略 https://blog.yexca.net/ja/archives/219 恋の押し売り 略 https://blog.yexca.net/ja/archives/220 17さいのうた 略 https://blog.yexca.net/ja/archives/224 drop 恋に落ちた この記事 生きるを選んだ私へ 略 https://blog.yexca.net/ja/archives/239 rainy lady 雨女 https://blog.yexca.net/ja/archives/249 恋しくなったら手を叩こう 略 https://blog.yexca.net/ja/archives/250 まえがき 今日は2019年12月のN1試験を試してみて、思いがけず合格した。とてもうれしいので、また日本語の勉強の記事をやろう。\nなんでこんなに可愛い曲があるな、心も溶けるかも\n動画 歌詞 夢の中で君と過ごしても\nまた覚めるたび君が離れないの\n退屈なベッドで1人きり\nあぁ 迎えに来てよ王子様\n君を知りたい 気持ちもどかしい\nいっそシャボン玉になって弾けたい\nあぁ 君が好き なんて言えない\nたまに冷たい 君がわかんない\n君の場所びゅーんと飛んでって\nアニメみたいに2人恋に落ちて\nくすぐったいくらいに君のこと\n考える1人の夜がいいの\nふわふわと浮かぶ甘い心\n頭離れない君は悪い男？\nわからないことにもやもやして\n夢でも君のことを考えて\nあぁ いじけちゃって嫌になっても 考えちゃう\nねぇ 優しかったり冷たくなったり 迷路みたい\nあぁ 攻略サイトも見当たらないから やり直しばかり\nもー知らないもんって強がり\nでも嫌いになんてなれるわけもない\nそう思うほど胸も痛くなる愛\n私の恋のキュービットは\nいつになったら現れるの\n夢の中で君と過ごしても\nまた覚めるたび君が離れないの\n退屈なベッドで1人きり\nあぁ 迎えに来てよ王子様\n君を知りたい 気持ちもどかしい\nいっそシャボン玉になって弾けたい\nあぁ 君が好き なんて言えない\nたまに冷たい 君がわかんない\nひいふうみいよ 数えて\n君につぎ 会える日を楽しみに眠るの\nいつでも会えるよう\n昨日よりもかわいくなるために生きるよ\n気付いてくれるかな\n君の好きなメイクにしてみたとか (どうかな？)\n少し重すぎかな\n優柔不断で何も決まんないや (もう)\n可愛くなれるかな\n君の前だとチークはいらないか (ねえ ねえ)\n私と同じかな\nこの気持ち君も同じだといいな\n夢の中で君と過ごしても\nまた覚めるたび君が離れないの\n退屈なベッドで1人きり\nあぁ 迎えに来てよ王子様\n君を知りたい 気持ちもどかしい\nいっそシャボン玉になって弾けたい\nあぁ 君が好き なんて言えない\nたまに冷たい 君がわかんない\nふわふわな気持ちを隠しても\n君の眼を見るとまた零れるちゃうよ\n味のないケーキも君となら\n大好きな時間に変わってく\n君を知りたい もっと知りたい\n好きの2文字が口から出せない\nあぁ 君が好き を隠した日々\nたまに冷たい 君も愛おしい\n","date":"2025-02-06T22:06:10+09:00","permalink":"https://blog.yexca.net/ja/archives/230/","title":"音に感じて - 《drop》"},{"content":" 📢 この記事は gemini-2.5-flash によって翻訳されました Elasticsearch シリーズ\n内容 リンク Elasticsearch の基本操作 https://blog.yexca.net/ja/archives/226 Elasticsearch のクエリ操作 https://blog.yexca.net/ja/archives/227 RestClient の基本操作 https://blog.yexca.net/ja/archives/228 RestClient のクエリ操作 本文 Elasticsearch のデータ集約 https://blog.yexca.net/ja/archives/231 Elasticsearch のオートコンプリート https://blog.yexca.net/ja/archives/232 Elasticsearch のデータ同期 https://blog.yexca.net/ja/archives/234 Elasticsearch クラスター https://blog.yexca.net/ja/archives/235 ドキュメントのクエリも同じく RestHighLevelClient オブジェクトを使うよ。\nmatch_all リクエストを発行するのはこんな感じ。\n1 2 3 4 5 6 7 8 9 10 11 @Test public void testMatchAll() throws IOException { // request を準備 SearchRequest request = new SearchRequest(\u0026#34;hotel\u0026#34;); // DSL パラメータを組み立て request.source().query(QueryBuilders.matchAllQuery()); // リクエストを送信 SearchResponse response = client.search(request, RequestOptions.DEFAULT); System.out.println(response); } レスポンスのパース\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 @Test public void testMatchAll() throws IOException { // request を準備 SearchRequest request = new SearchRequest(\u0026#34;hotel\u0026#34;); // DSL パラメータを組み立て request.source().query(QueryBuilders.matchAllQuery()); // リクエストを送信 SearchResponse response = client.search(request, RequestOptions.DEFAULT); // 結果をパース SearchHits searchHits = response.getHits(); // クエリの合計件数 long total = searchHits.getTotalHits().value; // クエリの結果配列 SearchHit[] hits = searchHits.getHits(); for (SearchHit hit : hits) { String json = hit.getSourceAsString(); System.out.println(json); } } Elasticsearch が返す結果は JSON 文字列で、こんな内容が含まれてるんだ：\nhits：ヒットした結果 total：合計件数。value が具体的な合計件数だよ。 max_score：全結果の中で最もスコアの高いドキュメントの関連性スコア hits：検索結果のドキュメント配列。それぞれのドキュメントは JSON オブジェクトだよ。 source：ドキュメント内の元データ。これも JSON オブジェクトだね。 だから、レスポンス結果をパースするっていうのは、JSON 文字列を階層的に解析していくってこと。流れはこんな感じだよ：\nSearchHits：response.getHits() で取得できるよ。これは JSON の一番外側の hits で、ヒットした結果を表してる。 SearchHits.getTotalHits().value：合計件数情報を取得するんだ。 SearchHits.getHits()：SearchHit 配列、つまりドキュメント配列を取得するよ。 SearchHit.getSourceAsString()：ドキュメント結果の _source、つまり元の JSON ドキュメントデータを取得するんだ。 match と multi_match match_all と似てるけど、違いはクエリ条件だよ。\nmatch のコード\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Test public void testMatch() throws IOException { SearchRequest request = new SearchRequest(\u0026#34;hotel\u0026#34;); request.source().query(QueryBuilders.matchQuery(\u0026#34;all\u0026#34;, \u0026#34;如家\u0026#34;)); SearchResponse response = client.search(request, RequestOptions.DEFAULT); SearchHits searchHits = response.getHits(); long total = searchHits.getTotalHits().value; System.out.println(total); SearchHit[] hits = searchHits.getHits(); for (SearchHit hit : hits) { String json = hit.getSourceAsString(); System.out.println(json); } } multi_match のコード\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Test public void testMultiMatch() throws IOException { SearchRequest request = new SearchRequest(\u0026#34;hotel\u0026#34;); request.source().query(QueryBuilders.multiMatchQuery(\u0026#34;如家\u0026#34;, \u0026#34;brand\u0026#34;, \u0026#34;name\u0026#34;)); SearchResponse response = client.search(request, RequestOptions.DEFAULT); SearchHits searchHits = response.getHits(); long total = searchHits.getTotalHits().value; System.out.println(total); SearchHit[] hits = searchHits.getHits(); for (SearchHit hit : hits) { String json = hit.getSourceAsString(); System.out.println(json); } } コードの重複が多いのがわかるよね。Ctrl+Alt+M でコードを抽出できるよ。term のコードで抽出の例を見せるね。\n精密クエリ term 用語の精密一致クエリ\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 @Test public void testTerm() throws IOException { SearchRequest request = new SearchRequest(\u0026#34;hotel\u0026#34;); request.source().query(QueryBuilders.termQuery(\u0026#34;city\u0026#34;, \u0026#34;上海\u0026#34;)); SearchResponse response = client.search(request, RequestOptions.DEFAULT); responseHandle(response); } // レスポンス処理のコード抽出 private static void responseHandle(SearchResponse response) { SearchHits searchHits = response.getHits(); long total = searchHits.getTotalHits().value; System.out.println(total); SearchHit[] hits = searchHits.getHits(); for (SearchHit hit : hits) { String json = hit.getSourceAsString(); System.out.println(json); } } range 範囲クエリ\n1 2 3 4 5 6 7 8 9 10 11 @Test public void testRange() throws IOException { SearchRequest request = new SearchRequest(\u0026#34;hotel\u0026#34;); request.source().query(QueryBuilders .rangeQuery(\u0026#34;price\u0026#34;) .gte(100) .lte(400)); SearchResponse response = client.search(request, RequestOptions.DEFAULT); responseHandle(response); } ブールクエリ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @Test public void testBool() throws IOException { SearchRequest request = new SearchRequest(\u0026#34;hotel\u0026#34;); // bool クエリを構築 BoolQueryBuilder booledQuery = QueryBuilders.boolQuery(); // must 条件を追加 booledQuery.must(QueryBuilders.termQuery(\u0026#34;city\u0026#34;, \u0026#34;上海\u0026#34;)); // filter コンポーネントを追加 booledQuery.filter(QueryBuilders.rangeQuery(\u0026#34;price\u0026#34;).lte(300)); request.source().query(booledQuery); SearchResponse response = client.search(request, RequestOptions.DEFAULT); responseHandle(response); } ソートとページネーション 1 2 3 4 5 6 7 8 9 10 @Test public void testSort() throws IOException { SearchRequest request = new SearchRequest(\u0026#34;hotel\u0026#34;); request.source().query(QueryBuilders.matchAllQuery()); request.source().from(10).size(10); request.source().sort(\u0026#34;price\u0026#34;, SortOrder.ASC); SearchResponse response = client.search(request, RequestOptions.DEFAULT); responseHandle(response); } ハイライト ハイライトは上記のコードと結構違うから、リクエストの構築から見ていこう。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @Test public void testHigh() throws IOException { SearchRequest request = new SearchRequest(\u0026#34;hotel\u0026#34;); // DSL request.source().query(QueryBuilders.matchQuery(\u0026#34;all\u0026#34;, \u0026#34;汉庭\u0026#34;)); // ハイライト request.source().highlighter( new HighlightBuilder() .field(\u0026#34;name\u0026#34;) .requireFieldMatch(false) ); // リクエストを送信 SearchResponse response = client.search(request, RequestOptions.DEFAULT); // パース responseHandle(response); } ドキュメントのクエリ結果とハイライトは別々だから、結果のパースは追加で処理が必要だよ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 @Test public void testHigh() throws IOException { SearchRequest request = new SearchRequest(\u0026#34;hotel\u0026#34;); // DSL request.source().query(QueryBuilders.matchQuery(\u0026#34;all\u0026#34;, \u0026#34;汉庭\u0026#34;)); // ハイライト request.source().highlighter( new HighlightBuilder() .field(\u0026#34;name\u0026#34;) .requireFieldMatch(false) ); // リクエストを送信 SearchResponse response = client.search(request, RequestOptions.DEFAULT); // パース SearchHits searchHits = response.getHits(); // 合計件数 long total = searchHits.getTotalHits().value; System.out.println(total); // ドキュメント配列 SearchHit[] hits = searchHits.getHits(); for (SearchHit hit : hits) { String json = hit.getSourceAsString(); // 逆シリアル化 HotelDoc hotelDoc = JSON.parseObject(json, HotelDoc.class); // ハイライト結果を取得 Map\u0026lt;String, HighlightField\u0026gt; highlightFields = hit.getHighlightFields(); if(!CollectionUtils.isEmpty(highlightFields)){ // ハイライト結果を取得 HighlightField highlightField = highlightFields.get(\u0026#34;name\u0026#34;); if (highlightField != null){ String name = highlightField.getFragments()[0].toString(); // ハイライトされていないものを上書き hotelDoc.setName(name); } } System.out.println(hotelDoc); } } ホテル検索の事例 4つの機能を実装するよ：\nホテルの検索とページネーション ホテル結果のフィルタリング 自分の周辺のホテル ホテルの入札ランキング 検索とページネーション 検索リクエスト：\nリクエスト方式：POST リクエストパス：/hotel/list リクエストパラメータ：JSON オブジェクトで、4つのフィールドが含まれるよ： key：検索キーワード page：ページ番号 size：1ページあたりのサイズ sortBy：ソート。今はまだ実装しないよ。 戻り値：ページングクエリで、ページング結果の PageResult を返す必要があるよ。2つのプロパティが含まれる： total：合計件数 List\u0026lt;HotelDoc\u0026gt;：現在のページデータ まず、エンティティクラスを定義してパラメータを受け取るよ。\n1 2 3 4 5 6 7 @Data public class RequestParams { private String key; private Integer page; private Integer size; private String sortBy; } 戻り値のクラスを定義するよ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 @Data public class PageResult { private Long total; private List\u0026lt;HotelDoc\u0026gt; hotels; public PageResult(){ } public PageResult(Long total, List\u0026lt;HotelDoc\u0026gt; hotels) { this.total = total; this.hotels = hotels; } } Controller を定義するよ。\n1 2 3 4 5 6 7 8 9 10 11 @RestController @RequestMapping(\u0026#34;/hotel\u0026#34;) public class HotelController { @Autowired private IHotelService hotelService; @PostMapping(\u0026#34;/list\u0026#34;) public PageResult search(@RequestBody RequestParams params){ return hotelService.search(params); } } 検索ビジネスを実装するんだけど、まず Bean オブジェクトを登録するんだ。\n1 2 3 4 5 6 @Bean public RestHighLevelClient client(){ return new RestHighLevelClient(RestClient .builder(HttpHost.create(\u0026#34;http://ip:9200\u0026#34;) )); } ロジックを書くよ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 public PageResult search(RequestParams params) { // request SearchRequest request = new SearchRequest(\u0026#34;hotel\u0026#34;); BoolQueryBuilder boolQuery = QueryBuilders.boolQuery(); // DSL String key = params.getKey(); if (key == null || \u0026#34;\u0026#34;.equals(key)){ boolQuery.must(QueryBuilders.matchAllQuery()); }else { boolQuery.must(QueryBuilders.matchQuery(\u0026#34;all\u0026#34;, key)); } // ページネーション int page = params.getPage(); int size = params.getSize(); request.source().from((page - 1) * size).size(size); // クエリ request.source().query(boolQuery); // リクエストを送信 try { SearchResponse response = client.search(request, RequestOptions.DEFAULT); // レスポンスパース SearchHits searchHits = response.getHits(); // 合計数 long total = searchHits.getTotalHits().value; // ドキュメント SearchHit[] hits = searchHits.getHits(); // イテレート List\u0026lt;HotelDoc\u0026gt; hotels = new ArrayList\u0026lt;\u0026gt;(); for (SearchHit hit : hits) { String json = hit.getSourceAsString(); HotelDoc hotelDoc = JSON.parseObject(json, HotelDoc.class); hotels.add(hotelDoc); } return new PageResult(total, hotels); } catch (IOException e) { throw new RuntimeException(e); } } 結果のフィルタリング 含まれるフィルタリング条件は：\nbrand：ブランド値 city：都市 minPrice~maxPrice：価格範囲 starName：星評価 エンティティクラスを修正するよ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 @Data public class RequestParams { private String key; private Integer page; private Integer size; private String sortBy; // 下は追加したフィルタリング条件パラメータだよ private String city; private String brand; private String starName; private Integer minPrice; private Integer maxPrice; } クエリ条件を修正するよ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 @Override public PageResult search(RequestParams params) { // request SearchRequest request = new SearchRequest(\u0026#34;hotel\u0026#34;); basicQuery(params, request); // ページネーション int page = params.getPage(); int size = params.getSize(); request.source().from((page - 1) * size).size(size); // リクエストを送信 try { SearchResponse response = client.search(request, RequestOptions.DEFAULT); // レスポンスパース SearchHits searchHits = response.getHits(); // 合計数 long total = searchHits.getTotalHits().value; // ドキュメント SearchHit[] hits = searchHits.getHits(); // イテレート List\u0026lt;HotelDoc\u0026gt; hotels = new ArrayList\u0026lt;\u0026gt;(); for (SearchHit hit : hits) { String json = hit.getSourceAsString(); HotelDoc hotelDoc = JSON.parseObject(json, HotelDoc.class); hotels.add(hotelDoc); } return new PageResult(total, hotels); } catch (IOException e) { throw new RuntimeException(e); } } private static void basicQuery(RequestParams params, SearchRequest request) { BoolQueryBuilder boolQuery = QueryBuilders.boolQuery(); // 入力内容 String key = params.getKey(); if (key == null || \u0026#34;\u0026#34;.equals(key)){ boolQuery.must(QueryBuilders.matchAllQuery()); }else { boolQuery.must(QueryBuilders.matchQuery(\u0026#34;all\u0026#34;, key)); } // brand if (params.getBrand() != null \u0026amp;\u0026amp; !params.getBrand().equals(\u0026#34;\u0026#34;)){ boolQuery.filter(QueryBuilders.termQuery(\u0026#34;brand\u0026#34;, params.getBrand())); } // starName if (params.getStarName() != null \u0026amp;\u0026amp; !params.getStarName().equals(\u0026#34;\u0026#34;)){ boolQuery.filter(QueryBuilders.termQuery(\u0026#34;starName\u0026#34;, params.getStarName())); } // city if (params.getCity() != null \u0026amp;\u0026amp; !params.getStarName().equals(\u0026#34;\u0026#34;)){ boolQuery.filter(QueryBuilders.termQuery(\u0026#34;city\u0026#34;, params.getCity())); } // price if (params.getMinPrice() != null \u0026amp;\u0026amp; params.getMaxPrice() != null){ boolQuery.filter(QueryBuilders.rangeQuery(\u0026#34;price\u0026#34;).gte(params.getMinPrice()).lte(params.getMaxPrice())); } // クエリ request.source().query(boolQuery); } 近くのホテル location 座標に基づいて、周囲のホテルを距離でソートするよ。\nエンティティクラスを修正するよ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 @Data public class RequestParams { private String key; private Integer page; private Integer size; private String sortBy; private String city; private String brand; private String starName; private Integer minPrice; private Integer maxPrice; // 自分の現在の地理座標 private String location; } 距離によるソートを追加するよ。\n1 2 3 4 5 6 7 8 if (params.getLocation() != null) { // 距離ソート request.source().sort(SortBuilders .geoDistanceSort(\u0026#34;location\u0026#34;, new GeoPoint(params.getLocation())) .order(SortOrder.ASC) .unit(DistanceUnit.KILOMETERS) ); } 距離表示 HotelDoc を修正して、距離を追加するよ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 @Data @NoArgsConstructor public class HotelDoc { private Long id; private String name; private String address; private Integer price; private Integer score; private String brand; private String city; private String starName; private String business; private String location; private String pic; // 距離 private Object distance; public HotelDoc(Hotel hotel) { this.id = hotel.getId(); this.name = hotel.getName(); this.address = hotel.getAddress(); this.price = hotel.getPrice(); this.score = hotel.getScore(); this.brand = hotel.getBrand(); this.city = hotel.getCity(); this.starName = hotel.getStarName(); this.business = hotel.getBusiness(); this.location = hotel.getLatitude() + \u0026#34;, \u0026#34; + hotel.getLongitude(); this.pic = hotel.getPic(); } } レスポンス処理を修正するよ。\n1 2 3 4 5 6 7 8 9 10 for (SearchHit hit : hits) { String json = hit.getSourceAsString(); HotelDoc hotelDoc = JSON.parseObject(json, HotelDoc.class); Object[] sortValues = hit.getSortValues(); if (sortValues.length \u0026gt; 0){ Object sortValue = sortValues[0]; hotelDoc.setDistance(sortValue); } hotels.add(hotelDoc); } 広告ホテルの追加 要件：指定したホテルを検索結果で上位に表示させたい。\n指定ホテルにフラグを追加して、フィルタリング条件でこのフラグに基づいて function_score を上げるかどうかを判断するんだ。\nHotelDoc に広告フラグフィールドを追加するよ。\n1 private Boolean isAD; DSL を使って、いくつかのホテルにフラグを追加するよ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 # 広告を追加 POST /hotel/_update/607915 { \u0026#34;doc\u0026#34;: { \u0026#34;isAD\u0026#34;: true } } POST /hotel/_update/728461 { \u0026#34;doc\u0026#34;: { \u0026#34;isAD\u0026#34;: true } } POST /hotel/_update/7094829 { \u0026#34;doc\u0026#34;: { \u0026#34;isAD\u0026#34;: true } } POST /hotel/_update/198323591 { \u0026#34;doc\u0026#34;: { \u0026#34;isAD\u0026#34;: true } } スコアリング関数クエリを追加して、basicQuery() メソッドを修正するよ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 private static void basicQuery(RequestParams params, SearchRequest request) { BoolQueryBuilder boolQuery = QueryBuilders.boolQuery(); // 入力内容 String key = params.getKey(); if (key == null || \u0026#34;\u0026#34;.equals(key)){ boolQuery.must(QueryBuilders.matchAllQuery()); }else { boolQuery.must(QueryBuilders.matchQuery(\u0026#34;all\u0026#34;, key)); } // brand if (params.getBrand() != null \u0026amp;\u0026amp; !params.getBrand().equals(\u0026#34;\u0026#34;)){ boolQuery.filter(QueryBuilders.termQuery(\u0026#34;brand\u0026#34;, params.getBrand())); } // starName if (params.getStarName() != null \u0026amp;\u0026amp; !params.getStarName().equals(\u0026#34;\u0026#34;)){ boolQuery.filter(QueryBuilders.termQuery(\u0026#34;starName\u0026#34;, params.getStarName())); } // city if (params.getCity() != null \u0026amp;\u0026amp; !params.getStarName().equals(\u0026#34;\u0026#34;)){ boolQuery.filter(QueryBuilders.termQuery(\u0026#34;city\u0026#34;, params.getCity())); } // price if (params.getMinPrice() != null \u0026amp;\u0026amp; params.getMaxPrice() != null){ boolQuery.filter(QueryBuilders .rangeQuery(\u0026#34;price\u0026#34;) .gte(params.getMinPrice()) .lte(params.getMaxPrice()) ); } // スコアリング function_score FunctionScoreQueryBuilder functionScoreQuery = QueryBuilders.functionScoreQuery( // 元のクエリ boolQuery, // 配列 new FunctionScoreQueryBuilder.FilterFunctionBuilder[]{ // function score の要素の一つ new FunctionScoreQueryBuilder.FilterFunctionBuilder( // フィルタリング条件 QueryBuilders.termQuery(\u0026#34;isAD\u0026#34;, true), // スコアリング関数 ScoreFunctionBuilders.weightFactorFunction(10) ) } ); // クエリ request.source().query(functionScoreQuery); } ","date":"2025-02-05T15:50:26+09:00","permalink":"https://blog.yexca.net/ja/archives/229/","title":"Elasticsearch RestClient クエリ"},{"content":" 📢 この記事は gemini-2.5-flash によって翻訳されました Elasticsearch シリーズ\n内容 リンク Elasticsearch 基本操作 https://blog.yexca.net/ja/archives/226 Elasticsearch クエリ操作 https://blog.yexca.net/ja/archives/227 RestClient 基本操作 本文 RestClient クエリ操作 https://blog.yexca.net/ja/archives/229 Elasticsearch データ集計 https://blog.yexca.net/ja/archives/231 Elasticsearch オートコンプリート https://blog.yexca.net/ja/archives/232 Elasticsearch データ同期 https://blog.yexca.net/ja/archives/234 Elasticsearch クラスター https://blog.yexca.net/ja/archives/235 ESの公式は、ESを操作するための様々な言語のクライアントを提供しているんだ。これらのクライアントの核は、DSLステートメントを組み立てて、HTTPリクエストを通じてESに送信することだよ。\n公式ドキュメント： https://www.elastic.co/guide/en/elasticsearch/client/index.html 以下では、Java HighLevel Rest Client のクライアントAPIを使うよ。\nインデックスの作成 データベースのテーブル構造はこんな感じ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 `id` bigint(20) NOT NULL COMMENT \u0026#39;ホテルID\u0026#39;, `name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT \u0026#39;ホテル名\u0026#39;, `address` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT \u0026#39;ホテル住所\u0026#39;, `price` int(10) NOT NULL COMMENT \u0026#39;ホテル価格\u0026#39;, `score` int(2) NOT NULL COMMENT \u0026#39;ホテル評価\u0026#39;, `brand` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT \u0026#39;ホテルブランド\u0026#39;, `city` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT \u0026#39;所在都市\u0026#39;, `star_name` varchar(16) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT \u0026#39;ホテル星評価、1つ星から5つ星、1つダイヤモンドから5つダイヤモンド\u0026#39;, `business` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT \u0026#39;ビジネスエリア\u0026#39;, `latitude` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT \u0026#39;緯度\u0026#39;, `longitude` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT \u0026#39;経度\u0026#39;, `pic` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT \u0026#39;ホテル画像\u0026#39;, PRIMARY KEY (`id`) USING BTREE インデックス作成で一番大事なのはマッピングだよ。考慮すべき点は以下だね。\nフィールド名、フィールドデータ型（データベーステーブル構造の名前と型を参考にしてね） 検索に参加させるか（ビジネス要件に基づいて判断する。例えば、画像URLは検索不要だよね） 分かち書きが必要か（内容による。例えば、都市は分かち書き不要だよ） 分かち書きアナライザーは何か（ik_max_wordで統一してもいいよ） 上記の表の例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 # インデックスを作成 PUT /hotel { \u0026#34;mappings\u0026#34;: { \u0026#34;properties\u0026#34;: { \u0026#34;id\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;keyword\u0026#34; }, \u0026#34;name\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;text\u0026#34;, \u0026#34;analyzer\u0026#34;: \u0026#34;ik_max_word\u0026#34;, \u0026#34;copy_to\u0026#34;: \u0026#34;all\u0026#34; /* 現在のフィールドを指定されたフィールド \u0026#34;all\u0026#34; にコピーする */ }, \u0026#34;address\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;keyword\u0026#34;, \u0026#34;index\u0026#34;: false }, \u0026#34;price\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;integer\u0026#34; }, \u0026#34;score\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;integer\u0026#34; }, \u0026#34;brand\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;keyword\u0026#34;, \u0026#34;copy_to\u0026#34;: \u0026#34;all\u0026#34; }, \u0026#34;city\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;keyword\u0026#34;, \u0026#34;copy_to\u0026#34;: \u0026#34;all\u0026#34; }, \u0026#34;starName\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;keyword\u0026#34; }, \u0026#34;business\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;keyword\u0026#34; }, \u0026#34;location\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;geo_point\u0026#34; /* ESは2種類の地理座標データ型をサポートしているよ */ }, \u0026#34;pic\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;keyword\u0026#34;, \u0026#34;index\u0026#34;: false }, \u0026#34;all\u0026#34;: { /* 結合フィールド。クエリ結果には表示されないけど、クエリには使えるよ */ \u0026#34;type\u0026#34;: \u0026#34;text\u0026#34;, \u0026#34;analyzer\u0026#34;: \u0026#34;ik_max_word\u0026#34; } } } } 地理座標データ型：\ngeo_point：緯度 (latitude) と経度 (longitude) で決定される点のこと。例えば \u0026quot;32.84 120.25\u0026quot; だね。 geo_shape：複数の geo_point で構成される複雑な幾何学図形のこと。例えば直線 \u0026quot;LINESTRING(-77.03 38.29, +77.00 38.88)\u0026quot; みたいにね。 RestClient の初期化 Elasticsearchとのすべてのインタラクションは、RestHighLevelClientというクラスにカプセル化されているよ。\nまず、ESのRestHighLevelClientの依存関係を導入するよ。\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.elasticsearch.client\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;elasticsearch-rest-high-level-client\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; SpringBootのデフォルトESバージョンは7.6.2だから、デフォルトのESバージョンを上書きする必要があるんだ。\n1 2 3 4 \u0026lt;properties\u0026gt; \u0026lt;java.version\u0026gt;1.8\u0026lt;/java.version\u0026gt; \u0026lt;elasticsearch.version\u0026gt;7.12.1\u0026lt;/elasticsearch.version\u0026gt; \u0026lt;/properties\u0026gt; RestHighLevelClientの初期化コードはこんな感じ。\n1 2 3 RestHighLevelClient client = new RestHighLevelClient(RestClient.builder( HttpHost.create(\u0026#34;http://IP:9200\u0026#34;) )); でも、テストの便宜のために、初期化コードは@BeforeEachに置くよ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class HotelIndexTest { private RestHighLevelClient client; @BeforeEach void setUp() { client = new RestHighLevelClient(RestClient.builder( HttpHost.create(\u0026#34;http://127.0.0.1:9200\u0026#34;))); } @AfterEach void tearDown() throws IOException { this.client.close(); } } インデックスを定義するにはDSLステートメントのJSON部分が必要だから、これは別途抽出できるよ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 public class HotelContants { public static final String MAPPING_TEMPLATE = \u0026#34;{\\n\u0026#34; + \u0026#34; \\\u0026#34;mappings\\\u0026#34;: {\\n\u0026#34; + \u0026#34; \\\u0026#34;properties\\\u0026#34;: {\\n\u0026#34; + \u0026#34; \\\u0026#34;id\\\u0026#34;: {\\n\u0026#34; + \u0026#34; \\\u0026#34;type\\\u0026#34;: \\\u0026#34;keyword\\\u0026#34;\\n\u0026#34; + \u0026#34; },\\n\u0026#34; + \u0026#34; \\\u0026#34;name\\\u0026#34;: {\\n\u0026#34; + \u0026#34; \\\u0026#34;type\\\u0026#34;: \\\u0026#34;text\\\u0026#34;,\\n\u0026#34; + \u0026#34; \\\u0026#34;analyzer\\\u0026#34;: \\\u0026#34;ik_max_word\\\u0026#34;,\\n\u0026#34; + \u0026#34; \\\u0026#34;copy_to\\\u0026#34;: \\\u0026#34;all\\\u0026#34;\\n\u0026#34; + \u0026#34; },\\n\u0026#34; + \u0026#34; \\\u0026#34;address\\\u0026#34;: {\\n\u0026#34; + \u0026#34; \\\u0026#34;type\\\u0026#34;: \\\u0026#34;keyword\\\u0026#34;,\\n\u0026#34; + \u0026#34; \\\u0026#34;index\\\u0026#34;: false\\n\u0026#34; + \u0026#34; },\\n\u0026#34; + \u0026#34; \\\u0026#34;price\\\u0026#34;: {\\n\u0026#34; + \u0026#34; \\\u0026#34;type\\\u0026#34;: \\\u0026#34;integer\\\u0026#34;\\n\u0026#34; + \u0026#34; },\\n\u0026#34; + \u0026#34; \\\u0026#34;score\\\u0026#34;: {\\n\u0026#34; + \u0026#34; \\\u0026#34;type\\\u0026#34;: \\\u0026#34;integer\\\u0026#34;\\n\u0026#34; + \u0026#34; },\\n\u0026#34; + \u0026#34; \\\u0026#34;brand\\\u0026#34;: {\\n\u0026#34; + \u0026#34; \\\u0026#34;type\\\u0026#34;: \\\u0026#34;keyword\\\u0026#34;,\\n\u0026#34; + \u0026#34; \\\u0026#34;copy_to\\\u0026#34;: \\\u0026#34;all\\\u0026#34;\\n\u0026#34; + \u0026#34; },\\n\u0026#34; + \u0026#34; \\\u0026#34;city\\\u0026#34;: {\\n\u0026#34; + \u0026#34; \\\u0026#34;type\\\u0026#34;: \\\u0026#34;keyword\\\u0026#34;,\\n\u0026#34; + \u0026#34; \\\u0026#34;copy_to\\\u0026#34;: \\\u0026#34;all\\\u0026#34;\\n\u0026#34; + \u0026#34; },\\n\u0026#34; + \u0026#34; \\\u0026#34;starName\\\u0026#34;: {\\n\u0026#34; + \u0026#34; \\\u0026#34;type\\\u0026#34;: \\\u0026#34;keyword\\\u0026#34;\\n\u0026#34; + \u0026#34; },\\n\u0026#34; + \u0026#34; \\\u0026#34;business\\\u0026#34;: {\\n\u0026#34; + \u0026#34; \\\u0026#34;type\\\u0026#34;: \\\u0026#34;keyword\\\u0026#34;\\n\u0026#34; + \u0026#34; },\\n\u0026#34; + \u0026#34; \\\u0026#34;location\\\u0026#34;: {\\n\u0026#34; + \u0026#34; \\\u0026#34;type\\\u0026#34;: \\\u0026#34;geo_point\\\u0026#34;\\n\u0026#34; + \u0026#34; },\\n\u0026#34; + \u0026#34; \\\u0026#34;pic\\\u0026#34;: {\\n\u0026#34; + \u0026#34; \\\u0026#34;type\\\u0026#34;: \\\u0026#34;keyword\\\u0026#34;,\\n\u0026#34; + \u0026#34; \\\u0026#34;index\\\u0026#34;: false\\n\u0026#34; + \u0026#34; },\\n\u0026#34; + \u0026#34; \\\u0026#34;all\\\u0026#34;: {\\n\u0026#34; + \u0026#34; \\\u0026#34;type\\\u0026#34;: \\\u0026#34;text\\\u0026#34;,\\n\u0026#34; + \u0026#34; \\\u0026#34;analyzer\\\u0026#34;: \\\u0026#34;ik_max_word\\\u0026#34;\\n\u0026#34; + \u0026#34; }\\n\u0026#34; + \u0026#34; }\\n\u0026#34; + \u0026#34; }\\n\u0026#34; + \u0026#34;}\u0026#34;; } インデックス作成コード\n1 2 3 4 5 6 7 8 9 10 11 12 // 注意CreateIndexRequestのパッケージ import org.elasticsearch.client.indices.CreateIndexRequest; @Test void testCreateHotelIndex() throws IOException { // Requestオブジェクトを作成 CreateIndexRequest request = new CreateIndexRequest(\u0026#34;hotel\u0026#34;); // リクエストパラメータ request.source(MAPPING_TEMPLATE, XContentType.JSON); // リクエストを送信 client.indices().create(request, RequestOptions.DEFAULT); } インデックスの削除 DSLステートメント\n1 DELETE /hotel 作成コードとの違いは、Requestオブジェクトだけ。パラメータもないんだ。\n1 2 3 4 5 6 7 @Test void testDeleteHotelIndex() throws IOException { // リクエストを作成 DeleteIndexRequest request = new DeleteIndexRequest(\u0026#34;hotel\u0026#34;); // リクエストを送信 client.indices().delete(request, RequestOptions.DEFAULT); } インデックスの存在確認 DSLステートメント\n1 GET /hotel 違いはやっぱりRequestオブジェクトだよ。\n1 2 3 4 5 6 7 8 9 @Test void testExistsHotelIndex() throws IOException { // リクエストを作成 GetIndexRequest request = new GetIndexRequest(\u0026#34;hotel\u0026#34;); // リクエストを送信 boolean exists = client.indices().exists(request, RequestOptions.DEFAULT); // 出力 System.out.println(exists); } まとめ\nJavaRestClientでESを操作する流れは基本的に似てるよ。client.indices() メソッドを使ってインデックス操作オブジェクトを取得するんだ。\nRestClient 通常、データはデータベースで、データベースクエリを通じてインデックスのCRUD操作を行うよ。\nRestHighLevelClient の初期化\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 @SpringBootTest public class HotelDocumentTest { // サービスを注入 @Autowired private IHotelService hotelService; private RestHighLevelClient client; @BeforeEach void setUp() { // RestClient を構築 this.client = new RestHighLevelClient( RestClient.builder( HttpHost.create(\u0026#34;http://127.0.0.1:9200\u0026#34;))); } @AfterEach void tearDown() throws IOException { this.client.close(); } } ドキュメントの追加 データベースからデータをクエリして、ESに書き込むよ。\n構造の調整 データベースクエリの結果はHotel型のオブジェクトだよ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @Data @TableName(\u0026#34;tb_hotel\u0026#34;) public class Hotel { @TableId(type = IdType.INPUT) private Long id; private String name; private String address; private Integer price; private Integer score; private String brand; private String city; private String starName; private String business; private String longitude; private String latitude; private String pic; } インデックスの構造とは違うから、インデックスと同じ構造の新しい型を定義する必要があるんだ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 @Data @NoArgsConstructor public class HotelDoc { private Long id; private String name; private String address; private Integer price; private Integer score; private String brand; private String city; private String starName; private String business; private String location; private String pic; public HotelDoc(Hotel hotel) { this.id = hotel.getId(); this.name = hotel.getName(); this.address = hotel.getAddress(); this.price = hotel.getPrice(); this.score = hotel.getScore(); this.brand = hotel.getBrand(); this.city = hotel.getCity(); this.starName = hotel.getStarName(); this.business = hotel.getBusiness(); this.location = hotel.getLatitude() + \u0026#34;, \u0026#34; + hotel.getLongitude(); this.pic = hotel.getPic(); } } 追加構文 DSLの構文はこれ。\n1 2 3 4 5 POST /{indexName}/_doc/{id} { \u0026#34;name\u0026#34;: \u0026#34;Jack\u0026#34;, \u0026#34;age\u0026#34;: 21 } 対応するJavaコード\n1 2 3 4 5 6 7 8 9 10 11 12 @Test public void HotelCreateTest() throws IOException { // requestオブジェクトを準備 IndexRequest request = new IndexRequest(\u0026#34;indexName\u0026#34;).id(\u0026#34;1\u0026#34;); // JSONオブジェクトを準備 request.source(\u0026#34;{\\n\u0026#34; + \u0026#34; \\\u0026#34;name\\\u0026#34;: \\\u0026#34;Jack\\\u0026#34;,\\n\u0026#34; + \u0026#34; \\\u0026#34;age\\\u0026#34;: 21\\n\u0026#34; + \u0026#34;}\u0026#34;, XContentType.JSON); // リクエストを送信 client.index(request, RequestOptions.DEFAULT); } ドキュメント追加のサンプルコード 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @Test public void HotelCreateTest() throws IOException { // ホテルデータをクエリ Hotel hotel = hotelService.getById(61083L); // ドキュメント型に変換 HotelDoc hotelDoc = new HotelDoc(hotel); // JSONに変換 String json = JSON.toJSONString(hotelDoc); // requestオブジェクトを準備 IndexRequest request = new IndexRequest(\u0026#34;hotel\u0026#34;).id(hotelDoc.getId().toString()); // JSONオブジェクトを準備 request.source(json, XContentType.JSON); // リクエストを送信 client.index(request, RequestOptions.DEFAULT); } ドキュメントの検索 検索構文 DSLステートメント\n1 GET /{indexName}/_doc/{id} Javaステートメント\n1 2 3 4 5 6 7 8 9 10 11 @Test public void HotelGetTest() throws IOException { // requestを準備 GetRequest request = new GetRequest(\u0026#34;indexName\u0026#34;, \u0026#34;id\u0026#34;); // リクエストを送信 GetResponse response = client.get(request, RequestOptions.DEFAULT); // 結果を解析 String json = response.getSourceAsString(); System.out.println(json); } ドキュメント検索のサンプルコード 1 2 3 4 5 6 7 8 9 10 11 12 @Test public void HotelGetTest() throws IOException { // requestを準備 GetRequest request = new GetRequest(\u0026#34;hotel\u0026#34;, \u0026#34;61083\u0026#34;); // リクエストを送信 GetResponse response = client.get(request, RequestOptions.DEFAULT); // 結果を解析 String json = response.getSourceAsString(); // Javaオブジェクトに逆シリアル化 HotelDoc hotelDoc = JSON.parseObject(json, HotelDoc.class); System.out.println(hotelDoc); } ドキュメントの削除 削除構文 DSLステートメント\n1 DELETE /{indexName}/_doc/{id} Javaステートメント\n1 2 3 4 5 6 7 @Test public void HotelDeleteTest() throws IOException { // requestを準備 DeleteRequest request = new DeleteRequest(\u0026#34;indexName\u0026#34;, \u0026#34;id\u0026#34;); // リクエストを送信 client.delete(request, RequestOptions.DEFAULT); } ドキュメント削除のサンプルコード 1 2 3 4 5 6 7 @Test public void HotelDeleteTest() throws IOException { // requestを準備 DeleteRequest request = new DeleteRequest(\u0026#34;hotel\u0026#34;, \u0026#34;61083\u0026#34;); // リクエストを送信 client.delete(request, RequestOptions.DEFAULT); } ドキュメントの変更 変更構文 変更には全量変更と増分変更があるんだけど、RestClientのAPIでは、この2つの方法は完全に同じAPIを使うんだ。判断基準はIDで、新規追加の場合は：\nIDが存在する場合、変更 IDが存在しない場合、新規追加 ここでは主に増分変更に注目するね。DSLステートメントはこれ。\n1 2 3 4 5 POST /{indexName}/_update/{id} { \u0026#34;doc\u0026#34;: \u0026#34;Rose\u0026#34;, \u0026#34;age\u0026#34;: 18 } Javaステートメント\n1 2 3 4 5 6 7 8 9 10 11 12 @Test public void HotelUpdateTest() throws IOException { // requestオブジェクトを作成 UpdateRequest request = new UpdateRequest(\u0026#34;indexName\u0026#34;, \u0026#34;id\u0026#34;); // パラメータを準備 request.doc( \u0026#34;name\u0026#34;, \u0026#34;Rose\u0026#34;, \u0026#34;age\u0026#34;, 18 ); // ドキュメントを更新 client.update(request, RequestOptions.DEFAULT); } ドキュメント変更のサンプルコード 1 2 3 4 5 6 7 8 9 10 11 12 @Test public void HotelUpdateTest() throws IOException { // requestオブジェクトを作成 UpdateRequest request = new UpdateRequest(\u0026#34;hotel\u0026#34;, \u0026#34;61083\u0026#34;); // パラメータを準備 request.doc( \u0026#34;price\u0026#34;, 950, \u0026#34;starName\u0026#34;, \u0026#34;四钻\u0026#34; ); // ドキュメントを更新 client.update(request, RequestOptions.DEFAULT); } ドキュメントの一括インポート BulkRequestを使って、データベースのデータをインデックスに一括インポートするよ。これは、複数の通常のCRUDリクエストをまとめて送信するっていうのが本質なんだ。例はこんな感じ。\n1 2 3 4 5 6 7 8 9 10 @Test public void testBulk() throws IOException { // bulkリクエストを作成 BulkRequest request = new BulkRequest(); // bulkリクエストを追加 request.add(new IndexRequest(\u0026#34;indexName\u0026#34;).id(\u0026#34;id1\u0026#34;).source(\u0026#34;json1\u0026#34;, XContentType.JSON)); request.add(new IndexRequest(\u0026#34;indexName\u0026#34;).id(\u0026#34;id2\u0026#34;).source(\u0026#34;json2\u0026#34;, XContentType.JSON)); // bulkリクエストを送信 client.bulk(request, RequestOptions.DEFAULT); } ドキュメント一括インポートのサンプルコード 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 @Test public void testBulk() throws IOException { // データを一括クエリ List\u0026lt;Hotel\u0026gt; hotelList = hotelService.list(); // bulkリクエストを作成 BulkRequest request = new BulkRequest(); // bulkリクエストを追加 for (Hotel hotel : hotelList) { // ドキュメント型に変換 HotelDoc hotelDoc = new HotelDoc(hotel); // ドキュメント新規追加requestオブジェクトを作成 request.add(new IndexRequest(\u0026#34;hotel\u0026#34;) .id(hotelDoc.getId().toString()) .source(JSON.toJSONString(hotelDoc), XContentType.JSON) ); } // bulkリクエストを送信 client.bulk(request, RequestOptions.DEFAULT); } ","date":"2025-02-03T22:30:00+09:00","permalink":"https://blog.yexca.net/ja/archives/228/","title":"Elasticsearch RestClient 入門"},{"content":" 📢 この記事は gemini-2.5-flash によって翻訳されました Elasticsearch シリーズ\n内容 リンク Elasticsearch 基本操作 https://blog.yexca.net/ja/archives/226 Elasticsearch クエリ操作 この記事 RestClient 基本操作 https://blog.yexca.net/ja/archives/228 RestClient クエリ操作 https://blog.yexca.net/ja/archives/229 Elasticsearch データ集計 https://blog.yexca.net/ja/archives/231 Elasticsearch オートコンプリート https://blog.yexca.net/ja/archives/232 Elasticsearch データ同期 https://blog.yexca.net/ja/archives/234 Elasticsearch クラスター https://blog.yexca.net/ja/archives/235 前回の記事では主にESのデータ保存機能について話したけど、ESが一番得意なのはやっぱり検索とデータ分析なんだ。\nESのクエリも相変わらずJSON形式のDSLで実装するよ。\nクエリの分類 よくあるクエリの種類はこんな感じ。\n全件検索: 全てのデータを検索するやつ。だいたいテストで使うね。例: match_all 全文検索 (full text) クエリ: アナライザーを使ってユーザー入力の内容を分かち書きして、転置インデックスからマッチするものを探すよ。例: match_query multi_match_query 厳密検索: 正確なターム値に基づいてデータを検索するやつ。だいたい keyword、数値、日付、boolean などのフィールドタイプを探す時に使うよ。例: ids range term 地理情報 (geo) クエリ: 緯度経度に基づいて検索するやつ。例: geo_distance geo_bounding_box 複合クエリ (compound): 上記の簡単なクエリ条件を組み合わせて、検索条件をまとめるやつ。例: bool function_score クエリの文法はだいたい同じだよ:\n1 2 3 4 5 6 7 8 GET /indexName/_search { \u0026#34;query\u0026#34;: { \u0026#34;クエリタイプ\u0026#34;: { \u0026#34;検索条件\u0026#34;: \u0026#34;条件値\u0026#34; } } } 全件検索 クエリタイプは match_all で、検索条件はないよ。\n1 2 3 4 5 6 7 // 全件検索 GET /indexName/_search { \u0026#34;query\u0026#34;: { \u0026#34;match_all\u0026#34;: {} } } 全文検索クエリ ユーザーの入力内容を分かち書きするよ。検索ボックスでの検索によく使われるね。タームを使ってマッチさせるから、検索対象のフィールドは分かち書きできる text タイプじゃないといけないんだ。\nよくあるのは:\nmatch: 単一フィールド検索 multi_match: 複数フィールド検索。どれか一つのフィールドが条件に合えば検索条件に合うとみなされるよ。 match クエリの文法:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # match GET /indexName/_search { \u0026#34;query\u0026#34;: { \u0026#34;match\u0026#34;: { \u0026#34;FIELD\u0026#34;: \u0026#34;TEXT\u0026#34; } } } # 例 GET /hotel/_search { \u0026#34;query\u0026#34;: { \u0026#34;match\u0026#34;: { \u0026#34;all\u0026#34;: \u0026#34;外灘如家\u0026#34; } } } multi_match の文法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # multi_match GET /indexName/_search { \u0026#34;query\u0026#34;: { \u0026#34;multi_match\u0026#34;: { \u0026#34;query\u0026#34;: \u0026#34;TEXT\u0026#34;, \u0026#34;fields\u0026#34;: [\u0026#34;FIELD1\u0026#34;, \u0026#34;FIELD2\u0026#34;] } } } # 例 GET /hotel/_search { \u0026#34;query\u0026#34;: { \u0026#34;multi_match\u0026#34;: { \u0026#34;query\u0026#34;: \u0026#34;外灘如家\u0026#34;, \u0026#34;fields\u0026#34;: [\u0026#34;brand\u0026#34;, \u0026#34;name\u0026#34;, \u0026#34;business\u0026#34;] } } } 以前インデックスを作成した時に、brand、name、business の値を copy_to を使って all フィールドにコピーしたから、上記の2つのクエリの結果は同じになるよ。\nでも、検索フィールドが増えれば増えるほどパフォーマンスへの影響が大きくなるから、copy_to を使って、単一フィールドで検索するのがおすすめだよ。\n厳密検索 厳密検索は検索条件を分かち書きしないよ。よくあるのは:\nterm: タームの厳密な値に基づいて検索 range: 値の範囲に基づいて検索 term クエリ 検索条件は分かち書きされないタームじゃないといけないよ。入力値と完全に一致した場合にのみ条件に合うんだ。\n文法:\n1 2 3 4 5 6 7 8 9 10 11 # term GET /indexName/_search { \u0026#34;query\u0026#34;: { \u0026#34;term\u0026#34;: { \u0026#34;FIELD\u0026#34;: { \u0026#34;value\u0026#34;: \u0026#34;VALUE\u0026#34; } } } } 例\n1 2 3 4 5 6 7 8 9 10 GET /hotel/_search { \u0026#34;query\u0026#34;: { \u0026#34;term\u0026#34;: { \u0026#34;city\u0026#34;: { \u0026#34;value\u0026#34;: \u0026#34;上海\u0026#34; } } } } range クエリ 範囲検索だよ。だいたい数値タイプの範囲で絞り込みをする時に使うね。例えば、価格や日付の範囲でフィルタリングする時とか。\n文法:\n1 2 3 4 5 6 7 8 9 10 11 12 # range GET /hotel/_search { \u0026#34;query\u0026#34;: { \u0026#34;range\u0026#34;: { \u0026#34;FIELD\u0026#34;: { \u0026#34;gte\u0026#34;: 10, // ここで`gte`は「以上」、`gt`は「より大きい」という意味だよ \u0026#34;lte\u0026#34;: 20 // `lte`は「以下」、`lt`は「より小さい」という意味だね } } } } 例\n1 2 3 4 5 6 7 8 9 10 11 GET /hotel/_search { \u0026#34;query\u0026#34;: { \u0026#34;range\u0026#34;: { \u0026#34;price\u0026#34;: { \u0026#34;gte\u0026#34;: 1000, \u0026#34;lte\u0026#34;: 2000 } } } } 地理座標クエリ これは要するに緯度経度に基づいて検索するやつだよ。公式ドキュメントはこちら: https://www.elastic.co/guide/en/elasticsearch/reference/current/geo-queries.html よくあるシーン: 周囲のホテル、タクシー、人、グルメを検索する時とか。\n矩形範囲検索 geo_bounding_box クエリ。特定の矩形範囲内にある座標を持つ全てのドキュメントを検索するよ。\n左上と右下の2つの点の座標を指定する必要があるんだ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # geo_bounding_box GET /indexName/_search { \u0026#34;query\u0026#34;: { \u0026#34;geo_bounding_box\u0026#34;: { \u0026#34;FIELD\u0026#34;: { \u0026#34;top_left\u0026#34;: { // 左上隅の点 \u0026#34;lat\u0026#34;: 30, \u0026#34;lon\u0026#34;: 20 }, \u0026#34;bottom_right\u0026#34;: { // 右下隅の点 \u0026#34;lat\u0026#34;: 31, \u0026#34;lon\u0026#34;: 21 } } } } } 近隣検索 距離検索 (geo_distance) とも呼ばれるね。指定した中心点から特定の距離以内にある全てのドキュメントを検索するよ。\n1 2 3 4 5 6 7 8 9 10 # geo_distance GET /indexName/_search { \u0026#34;query\u0026#34;: { \u0026#34;geo_distance\u0026#34;: { \u0026#34;distance\u0026#34;: \u0026#34;15km\u0026#34;, // 半径 \u0026#34;FIELD\u0026#34;: \u0026#34;31, 21\u0026#34; // 中心 } } } 例: 周囲 (31.21, 121.5) の15km以内にあるホテルを検索するよ。\n1 2 3 4 5 6 7 8 9 GET /hotel/_search { \u0026#34;query\u0026#34;: { \u0026#34;geo_distance\u0026#34;: { \u0026#34;distance\u0026#34;: \u0026#34;15km\u0026#34;, \u0026#34;location\u0026#34;: \u0026#34;31.21, 121.5\u0026#34; } } } 複合クエリ 他のシンプルなクエリを組み合わせて、より複雑な検索ロジックを実現するんだ。よくあるのは2種類:\nfunction score: スコア計算関数クエリ。ドキュメントの関連性スコアを制御して、ドキュメントのランキングを調整できるよ。 bool query: ブールクエリ。論理関係を使って複数の他のクエリを組み合わせ、複雑な検索を実現するよ。 関連性スコア match クエリを使うと、ドキュメントの結果は検索タームとの関連度に基づいてスコア (_score) がつけられて、結果はスコアの高い順に並んで返ってくるんだ。こんな感じ:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 [ { \u0026#34;_score\u0026#34; : 17.850193, \u0026#34;_source\u0026#34; : { \u0026#34;name\u0026#34; : \u0026#34;虹橋如家酒店真不错\u0026#34;, } }, { \u0026#34;_score\u0026#34; : 12.259849, \u0026#34;_source\u0026#34; : { \u0026#34;name\u0026#34; : \u0026#34;外灘如家酒店真不错\u0026#34;, } }, { \u0026#34;_score\u0026#34; : 11.91091, \u0026#34;_source\u0026#34; : { \u0026#34;name\u0026#34; : \u0026#34;迪士尼如家酒店真不错\u0026#34;, } } ] ESでは、初期にはTF-IDFアルゴリズムがスコア計算に使われていたんだ。\nTF-IDFアルゴリズムには欠点があって、タームの頻度が高くなるほどドキュメントのスコアも高くなって、単一のタームがドキュメントに与える影響が大きすぎたんだ。5.1バージョン以降は、アルゴリズムがBM25アルゴリズムに変わり、単一のタームのスコアには上限が設けられるようになったよ。\nスコア計算関数クエリ スコア計算関数はかなり合理的だけど、プロダクトが求めているものと必ずしも一致するとは限らないんだ。関連性スコアを制御したい場合は、ESの function_score クエリを使って、ドキュメントの関連性スコアを変更し、新しく得られたスコアに基づいてソートする必要があるよ。\n構造:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # function score GET /indexName/_search { \u0026#34;query\u0026#34;: { \u0026#34;function_score\u0026#34;: { \u0026#34;query\u0026#34;: {}, // 元のクエリ \u0026#34;functions\u0026#34;: [ { \u0026#34;filter\u0026#34;: {}, // フィルタ条件 \u0026#34;weight\u0026#34;: 1 // スコア計算関数 } ], \u0026#34;boost_mode\u0026#34;: \u0026#34;multiply\u0026#34; // 演算モード } } } 元のクエリ: この条件に基づいてドキュメントを検索し、BM25アルゴリズムに基づいてドキュメントにスコアをつけるよ。これが元のスコア (query score) だね。\nフィルタ条件: この条件に合致するドキュメントのみが再スコアリングされるよ。\nスコア計算関数: フィルタ条件に合致するドキュメントは、この関数に基づいて計算されて、関数スコアが得られるんだ。4種類の関数があるよ:\nweight: 関数の結果が定数になる。 field_value_factor: ドキュメント内の特定のフィールド値を関数の結果として使う。 random_score: 乱数を関数の結果として使う。 script_score: カスタムのスコア計算関数アルゴリズム。 演算モード: スコア計算関数の結果と、元のクエリの関連性スコアの間の演算方法。こんな感じ:\nmultiply: 乗算 replace: function score で query score を置き換える その他、sum、avg、max、min など 例: 「如家」というブランドのホテルを上位に表示させるよ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 GET /hotel/_search { \u0026#34;query\u0026#34;: { // 元のクエリ条件は任意だけど、ここでは動作させるために条件を追加してるよ \u0026#34;function_score\u0026#34;: { \u0026#34;query\u0026#34;: {\u0026#34;term\u0026#34;: { \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34; }}, \u0026#34;functions\u0026#34;: [ { \u0026#34;filter\u0026#34;: {\u0026#34;term\u0026#34;: { \u0026#34;brand\u0026#34;: \u0026#34;如家\u0026#34; }}, \u0026#34;weight\u0026#34;: 10 } ], \u0026#34;boost_mode\u0026#34;: \u0026#34;multiply\u0026#34; } } } ブールクエリ ブールクエリは一つまたは複数のクエリ句の組み合わせで、それぞれの句がサブクエリになっているんだ。組み合わせ方はこんな感じ:\nmust: 各サブクエリに必ずマッチする必要がある。「AND」みたいなものだね。 should: サブクエリに選択的にマッチする。「OR」みたいなものだよ。 must_not: 必ずマッチしないこと。スコア計算には参加しない。「NOT」みたいなものだね。 filter: 必ずマッチすること。スコア計算には参加しない。 例えば、ホテルを検索する時に、地域、ブランド、価格などのフィールドで絞り込みたい場合、それぞれのフィールドで検索条件や方法が違うから、複数の異なるクエリが必要になるよね。それらを組み合わせるにはboolクエリを使うんだ。\nスコア計算に参加するフィールドは、検索パフォーマンスが悪くなるよ。多条件検索の時は、次のことをおすすめするね:\n検索ボックスのキーワード検索は全文検索だから、must クエリを使って、スコア計算に参加させる。 その他のフィルタ条件は、filter クエリを使って、スコア計算には参加させない。 文法:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # bool GET /hotel/_search { \u0026#34;query\u0026#34;: { \u0026#34;bool\u0026#34;: { \u0026#34;must\u0026#34;: [ {} ], \u0026#34;should\u0026#34;: [ {} ], \u0026#34;must_not\u0026#34;: [ {} ], \u0026#34;filter\u0026#34;: [ {} ] } } } 例: 名前が「如家」を含み、価格が400以下で、座標 (31.21, 121.5) の周囲10km以内にあるホテルを検索するよ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 GET /hotel/_search { \u0026#34;query\u0026#34;: { \u0026#34;bool\u0026#34;: { \u0026#34;must\u0026#34;: [ {\u0026#34;match\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;如家\u0026#34; }} ], \u0026#34;must_not\u0026#34;: [ {\u0026#34;range\u0026#34;: { \u0026#34;price\u0026#34;: { \u0026#34;gt\u0026#34;: 400 } }} ], \u0026#34;filter\u0026#34;: [ {\u0026#34;geo_distance\u0026#34;: { \u0026#34;distance\u0026#34;: \u0026#34;10km\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 31.21, \u0026#34;lon\u0026#34;: 121.5 } }} ] } } } 検索結果の処理 検索で得られた結果は、ソート、ページネーション、ハイライトができるよ。\nソート ESはデフォルトでは関連性スコアに基づいてソートするけど、カスタム方式で検索結果をソートすることもできるんだ。ソートできるフィールドタイプは、keyword タイプ、数値タイプ、地理座標タイプ、日付タイプなどがあるよ。\n通常フィールドのソート keyword、数値、日付タイプのソートの文法はだいたい同じだよ。\n文法:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 # sort_normal GET /indexName/_search { \u0026#34;query\u0026#34;: { }, \u0026#34;sort\u0026#34;: [ { \u0026#34;FIELD\u0026#34;: { \u0026#34;order\u0026#34;: \u0026#34;desc\u0026#34; // ソートフィールド、昇順 (ASC)、降順 (DESC) } } ] } ソート条件は配列になっていて、複数のソート条件を書けるよ。宣言された順に、最初の条件が同じ場合は2番目の条件で、というように続くんだ。\n例: ホテルデータをユーザー評価の降順で、評価が同じ場合は価格の昇順でソートするよ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 GET /hotel/_search { \u0026#34;query\u0026#34;: { \u0026#34;match\u0026#34;: { \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34; } }, \u0026#34;sort\u0026#34;: [ { \u0026#34;score\u0026#34;: { \u0026#34;order\u0026#34;: \u0026#34;desc\u0026#34; } }, { \u0026#34;price\u0026#34;: { \u0026#34;order\u0026#34;: \u0026#34;asc\u0026#34; } } ] } // または GET /hotel/_search { \u0026#34;query\u0026#34;: { \u0026#34;match\u0026#34;: { \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34; } }, \u0026#34;sort\u0026#34;: [ { \u0026#34;score\u0026#34;: \u0026#34;desc\u0026#34; }, { \u0026#34;price\u0026#34;: \u0026#34;asc\u0026#34; } ] } 地理座標ソート 文法:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # sort_geo GET /indexName/_search { \u0026#34;query\u0026#34;: { }, \u0026#34;sort\u0026#34;: [ { \u0026#34;_geo_distance\u0026#34;: { \u0026#34;FIELD\u0026#34;: { \u0026#34;lat\u0026#34;: 40, \u0026#34;lon\u0026#34;: -70 }, \u0026#34;order\u0026#34;: \u0026#34;asc\u0026#34;, // ソート順 \u0026#34;unit\u0026#34;: \u0026#34;km\u0026#34; // ソート単位 } } ] } 例: ホテルを距離でソートするよ (位置を 31.034661, 121.612282 と仮定するね)。\n高徳で緯度経度を取得するにはここ: https://lbs.amap.com/demo/jsapi-v2/example/map/click-to-get-lnglat/ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 GET /hotel/_search { \u0026#34;query\u0026#34;: { \u0026#34;match_all\u0026#34;: {} }, \u0026#34;sort\u0026#34;: [ { \u0026#34;_geo_distance\u0026#34;: { \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 31.034661, \u0026#34;lon\u0026#34;: 121.612282 }, \u0026#34;order\u0026#34;: \u0026#34;asc\u0026#34;, \u0026#34;unit\u0026#34;: \u0026#34;km\u0026#34; } } ] } ページネーション ESはデフォルトでTop10のデータしか返さないから、もっと多くのデータを検索したい場合はページネーションのパラメータを変更する必要があるよ。ESは from、size パラメータを変更して、返却するページング結果を制御するんだ:\nfrom: 何番目のドキュメントから始めるか size: 合計でいくつのドキュメントを検索するか MySQLの limit ?,? みたいなものだね。\n基本ページネーション 基本的な文法は以下の通りだよ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # 基本ページネーション GET /indexName/_search { \u0026#34;query\u0026#34;: { }, \u0026#34;from\u0026#34;: 0, \u0026#34;size\u0026#34;: 10, \u0026#34;sort\u0026#34;: [ { \u0026#34;FIELD\u0026#34;: { \u0026#34;order\u0026#34;: \u0026#34;desc\u0026#34; } } ] } ディープページネーションの問題 もし990〜1000番目のデータを検索したいなら、クエリはこうなるよ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 GET /hotel/_search { \u0026#34;query\u0026#34;: { \u0026#34;match_all\u0026#34;: {} }, \u0026#34;from\u0026#34;: 990, \u0026#34;size\u0026#34;: 10, \u0026#34;sort\u0026#34;: [ { \u0026#34;price\u0026#34;: { \u0026#34;order\u0026#34;: \u0026#34;asc\u0026#34; } } ] } でもESの仕組み上、ページネーションする時はまず0〜1000件を検索して、それから990〜1000件目を切り取って表示するんだ。\nESがシングルノードモードなら大きな影響はないけど、クラスター構成でデプロイされている場合、1000件検索するからといって各ノードが200件ずつ検索するわけじゃないんだ。なぜなら、Aノードの200件がBノードでは1000位以下になる可能性もあるからね。\n上位1000件を取得するためには、各ノードがTop1000を検索し、それらをまとめて再ランキングして切り取る必要があるんだ。\nもしTop10000、あるいはそれ以上を検索しようとすると、メモリとCPUに非常に大きな負荷がかかるから、ESは from + size が10000を超えるリクエストを禁止しているよ。\nディープページネーションに対しては、ESが2つの解決策を提供しているよ: https://www.elastic.co/guide/en/elasticsearch/reference/current/paginate-search-results.html search after: ページネーション時にソートが必要で、原理は前回のソート値から次のページのデータを検索するんだ。公式が推奨する方法だね。 scroll: 原理はソートされたドキュメントIDのスナップショットをメモリに保存するんだけど、公式はもう推奨していないよ。 ページネーションまとめ from + size: 利点: ランダムなページ移動をサポートしているよ。 欠点: ディープページネーションの問題があるのと、デフォルトの検索上限 (from + size) が10000なんだ。 使うシーン: 百度、京東、Google、淘宝みたいなランダムなページ移動がある検索だね。 after search: 利点: 検索上限がないよ (1回の検索で size が10000を超えなければね)。 欠点: 次のページへ順次検索するだけで、ランダムなページ移動はできないんだ。 使うシーン: ランダムなページ移動が必要ない検索、例えばスマホで下にスクロールするページ移動とか。 scroll: 利点: 検索上限がないよ (1回の検索で size が10000を超えなければね)。 欠点: 余分なメモリ消費があるし、検索結果はリアルタイムじゃないんだ。 使うシーン: 大量のデータ取得や移行。ES7.1からは非推奨になってて、after search がおすすめだよ。 ハイライト 検索エンジンでコンテンツを検索する時、キーワードが赤色になって目立つことがあるよね。それがハイライト表示で、通常はドキュメント内の全てのキーワードに \u0026lt;em\u0026gt; タグを追加して、そのタグにCSSスタイルを設定するんだ。\n文法:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # ハイライト GET /indexName/_search { \u0026#34;query\u0026#34;: { }, \u0026#34;highlight\u0026#34;: { \u0026#34;fields\u0026#34;: { // ハイライトするフィールドを指定する \u0026#34;FIELD\u0026#34;: { \u0026#34;pre_tags\u0026#34;: \u0026#34;\u0026lt;em\u0026gt;\u0026#34;, // ハイライトフィールドをマークするための開始タグ \u0026#34;post_tags\u0026#34;: \u0026#34;\u0026lt;/em\u0026gt;\u0026#34; // ハイライトフィールドをマークするための終了タグ } } } } 注意点:\nハイライトはキーワードに対して行われるから、検索条件にはキーワードが必要で、範囲検索はできないよ。 デフォルトでは、ハイライトするフィールドは検索で指定したフィールドと一致している必要があるよ。そうじゃないとハイライトされないんだ。 検索対象ではないフィールドをハイライトしたい場合は、required_field_match=false というプロパティを追加する必要があるよ。 例: 検索結果で、名前の部分をハイライトするよ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 GET /hotel/_search { \u0026#34;query\u0026#34;: { \u0026#34;match\u0026#34;: { \u0026#34;all\u0026#34;: \u0026#34;如家\u0026#34; } }, \u0026#34;highlight\u0026#34;: { \u0026#34;fields\u0026#34;: { \u0026#34;name\u0026#34;: { \u0026#34;require_field_match\u0026#34;: \u0026#34;false\u0026#34;, \u0026#34;pre_tags\u0026#34;: \u0026#34;\u0026lt;em\u0026gt;\u0026#34;, \u0026#34;post_tags\u0026#34;: \u0026#34;\u0026lt;/em\u0026gt;\u0026#34; } } } } // 結果の抜粋 \u0026#34;hits\u0026#34; : [ { \u0026#34;_index\u0026#34; : \u0026#34;hotel\u0026#34;, \u0026#34;_type\u0026#34; : \u0026#34;_doc\u0026#34;, \u0026#34;_id\u0026#34; : \u0026#34;339952837\u0026#34;, \u0026#34;_score\u0026#34; : 2.7875905, \u0026#34;_source\u0026#34; : { \u0026#34;address\u0026#34; : \u0026#34;良郷西路7号\u0026#34;, \u0026#34;brand\u0026#34; : \u0026#34;如家\u0026#34;, \u0026#34;business\u0026#34; : \u0026#34;房山風景区\u0026#34;, \u0026#34;city\u0026#34; : \u0026#34;北京\u0026#34;, \u0026#34;id\u0026#34; : 339952837, \u0026#34;location\u0026#34; : \u0026#34;39.73167, 116.132482\u0026#34;, \u0026#34;name\u0026#34; : \u0026#34;如家酒店(北京良郷西路店)\u0026#34;, \u0026#34;pic\u0026#34; : \u0026#34;https://m.tuniucdn.com/fb3/s1/2n9c/3Dpgf5RTTzrxpeN5y3RLnRVtxMEA_w200_h200_c1_t0.jpg\u0026#34;, \u0026#34;price\u0026#34; : 159, \u0026#34;score\u0026#34; : 46, \u0026#34;starName\u0026#34; : \u0026#34;二钻\u0026#34; }, \u0026#34;highlight\u0026#34; : { \u0026#34;name\u0026#34; : [ \u0026#34;\u0026lt;em\u0026gt;如家\u0026lt;/em\u0026gt;ホテル(北京良郷西路店)\u0026#34; ] } } ] 結果の highlight 部分に、タグが追加された後の結果が表示されているね。\n検索結果処理のまとめ DSLクエリは大きなJSONオブジェクトで、以下を含むよ:\nquery: クエリ from、size: ページネーション条件 sort: ソート条件 highlight: ハイライト条件 総合的な例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 # クエリ総合 GET /hotel/_search { \u0026#34;query\u0026#34;: { // クエリ \u0026#34;match\u0026#34;: { \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34; } }, \u0026#34;from\u0026#34;: 10, // ページネーション開始 \u0026#34;size\u0026#34;: 10, // ページネーションサイズ \u0026#34;sort\u0026#34;: [ { // 通常ソート \u0026#34;price\u0026#34;: { \u0026#34;order\u0026#34;: \u0026#34;asc\u0026#34; } }, { // 距離ソート \u0026#34;_geo_distance\u0026#34;: { \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 31, \u0026#34;lon\u0026#34;: 121 }, \u0026#34;order\u0026#34;: \u0026#34;asc\u0026#34;, \u0026#34;unit\u0026#34;: \u0026#34;km\u0026#34; } } ], \u0026#34;highlight\u0026#34;: { // ハイライトフィールド \u0026#34;fields\u0026#34;: { \u0026#34;name\u0026#34;: { \u0026#34;require_field_match\u0026#34;: \u0026#34;false\u0026#34;, \u0026#34;pre_tags\u0026#34;: \u0026#34;\u0026lt;em\u0026gt;\u0026#34;, \u0026#34;post_tags\u0026#34;: \u0026#34;\u0026lt;/em\u0026gt;\u0026#34; } } } } ","date":"2025-02-01T15:16:28+09:00","permalink":"https://blog.yexca.net/ja/archives/227/","title":"Elasticsearch クエリ"},{"content":" 📢 この記事は gemini-2.5-flash によって翻訳されました Elasticsearch シリーズ\n内容 リンク Elasticsearch の基本操作 この記事 Elasticsearch 検索操作 https://blog.yexca.net/ja/archives/227 RestClient の基本操作 https://blog.yexca.net/ja/archives/228 RestClient 検索操作 https://blog.yexca.net/ja/archives/229 Elasticsearch データ集計 https://blog.yexca.net/ja/archives/231 Elasticsearch オートコンプリート https://blog.yexca.net/ja/archives/232 Elasticsearch データ同期 https://blog.yexca.net/ja/archives/234 Elasticsearch クラスター https://blog.yexca.net/ja/archives/235 Elasticsearchって、めちゃくちゃ強力なオープンソース検索エンジンなんだ。膨大なデータの中から、必要なものをサッと見つけるのに役立ってくれるよ。kibana、Logstash、Beatsと組み合わせると、elastic stack（ELK）になるんだ。ログデータ分析とか、リアルタイム監視みたいな分野で広く使われてるんだよね。\nで、ElasticsearchはそのElastic Stackの核となる部分で、データの保存、検索、分析を担当してるんだ。\nElasticsearchの根幹はLuceneっていうJavaの検索エンジンライブラリでできてて、それをベースにしてるんだよ。\n順方向インデックス 従来のデータベース（例えばMySQL）は順方向インデックスを使ってるんだ。例えば下の表みたいにね。\nid title price 1 Xiaomi スマホ 3499 2 Huawei スマホ 4999 3 Huawei Xiaomi 充電器 49 4 Xiaomi スマートバンド 239 もしIDで正確に検索するなら、直接インデックスを使うからすごく速いんだ。\nでも、タイトルであいまい検索しようとすると、データを1行ずつスキャンしていくしかないんだよね。流れとしてはこんな感じ。\nユーザーが「スマホ」って検索すると、データベースでは「%スマホ%」って条件になる。 データを1行ずつ取得して、例えばIDが1のデータとか。 そのデータのタイトルが条件に合ってるか判断する。 合ってればリストに入れて、合ってなければ捨てる。そして次の行へ、って感じ。 データ量が増えれば増えるほど、この1行ずつのスキャンの効率はどんどん悪くなっちゃうんだ。\n転置インデックス 転置インデックスの考え方は、MySQLみたいな順方向インデックスを基準にしてるんだ。\nElasticsearchは転置インデックスを採用してるよ。コンセプトはこんな感じ。\nドキュメント：1つ1つのデータがドキュメントになる。 ターム：ドキュメントが意味に基づいて分割された単語のこと。 転置インデックスを作るのは、順方向インデックスに対する特殊な処理なんだ。流れはこう。\n各ドキュメントのデータをアルゴリズムを使って単語に分割し、タームを1つ1つ取得する。 テーブルを作成して、各行にはターム、そのタームが含まれるドキュメントID、位置などの情報を含める。 タームはユニークだから、タームにインデックス（例えばハッシュテーブル構造のインデックス）を作ることができるんだ。 例えば、さっきの表からはこんな転置インデックスが作れるよ。\nターム ドキュメントID Xiaomi 1，3，4 スマホ 1，2 Huawei 2，3 充電器 3 スマートバンド 4 転置インデックスの検索フロー：\nユーザーが「Xiaomiスマホ」って検索する。 検索内容を形態素解析して、「Xiaomi」、「スマホ」を得る。 タームを使って転置インデックスを検索し、タームを含むドキュメントID：1、2、3、4を得る。 ドキュメントIDを使って順方向インデックスから具体的なドキュメントを探す。 ドキュメント Elasticsearchはドキュメント指向でデータを保存するんだ。データベースにある1つの商品データとか、注文情報とかになるんだよ。ドキュメントデータはJSON形式にシリアライズされてから、Elasticsearchに保存されるんだ。\nさっきの順方向インデックスの表をJSONにするとこうなるよ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 { \u0026#34;id\u0026#34;: 1, \u0026#34;title\u0026#34;: \u0026#34;小米手机\u0026#34;, \u0026#34;price\u0026#34;: 3499 } { \u0026#34;id\u0026#34;: 2, \u0026#34;title\u0026#34;: \u0026#34;华为手机\u0026#34;, \u0026#34;price\u0026#34;: 4999 } { \u0026#34;id\u0026#34;: 3, \u0026#34;title\u0026#34;: \u0026#34;华为小米充电器\u0026#34;, \u0026#34;price\u0026#34;: 49 } { \u0026#34;id\u0026#34;: 4, \u0026#34;title\u0026#34;: \u0026#34;小米手环\u0026#34;, \u0026#34;price\u0026#34;: 299 } JSONドキュメントにはたくさんのフィールドが含まれてて、データベースの列みたいなものだね。\nインデックスとマッピング インデックスは、同じ種類のドキュメントの集まりのこと。\nマッピングは、インデックス内のドキュメントのフィールドに関する制約情報で、テーブルの構造制約みたいなものだよ。\nインデックスはデータベースのテーブルみたいなものって考えたらいいよ。データベースのテーブルには、テーブルの構造やフィールド名、型などを定義する制約情報があるよね。だから、インデックスにはマッピングがあって、これはインデックス内のドキュメントのフィールド制約情報、つまりテーブルの構造制約みたいなものなんだ。\nMySQL と Elasticsearch MySQL Elasticsearch 説明 Table Index インデックスはドキュメントの集まりで、データベースのテーブルみたいなものだよ。 Row Document ドキュメントは1つ1つのデータで、データベースの行みたいなもの。ドキュメントは全部JSON形式だよ。 Column Field フィールドはJSONドキュメントの中のフィールドで、データベースの列みたいなものだね。 Schema Mapping マッピングはインデックス内のドキュメントの制約、例えばフィールドの型制約のこと。データベースのテーブル構造みたいなものだよ。 SQL DSL DSLはElasticsearchが提供するJSON形式のリクエスト文で、Elasticsearchを操作してCRUDを実現するのに使うんだ。 企業では、よく両方を組み合わせて使うことが多いんだ。\nセキュリティの要求が高い書き込み操作は、MySQLで実装する。 検索性能の要求が高い検索ニーズは、Elasticsearchで実装する。 そして、両者は何らかの方法でデータ同期を実現して、一貫性を保つんだ。 メリット・デメリット 順方向インデックス：\nメリット： 複数のフィールドにインデックスを作成できる。 インデックスフィールドによる検索やソートがすごく速い。 デメリット： 非インデックスフィールドや、インデックスフィールド内の一部のタームで検索する時は、全表スキャンするしかない。 転置インデックス：\nメリット： タームによる検索やあいまい検索の時に、ものすごく速い。 デメリット： フィールドじゃなくて、タームにしかインデックスを作成できない。 フィールドでソートできない。 インストール 普通はElasticsearchだけで十分だけど、kibanaを使うとElasticsearchの可視化インターフェースを提供してくれるから、DSL文の学習や記述が楽になるよ。\nElasticsearch Elasticsearchとkibanaコンテナを相互接続させるために、まずネットワークを作るといいよ。\n1 docker network create es-net 相互接続する方法はいくつかあって、docker-composeとか172.17.0.1とかね。\nElasticsearchをプルする\n1 docker pull elasticsearch:7.12.1 シングルノードデプロイ\n1 2 3 4 5 6 7 8 9 10 11 docker run -d \\ --name es \\ -e \u0026#34;ES_JAVA_OPTS=-Xms512m -Xmx512m\u0026#34; \\ -e \u0026#34;discovery.type=single-node\u0026#34; \\ -v es-data:/usr/share/elasticsearch/data \\ -v es-plugins:/usr/share/elasticsearch/plugins \\ --privileged \\ --network es-net \\ -p 9200:9200 \\ -p 9300:9300 \\ elasticsearch:7.12.1 マッピングディレクトリの変更に注意してね。上記ではデータボリュームを使ってるんだけど、一部を説明するよ。\n-e \u0026quot;cluster.name=es-docker-cluster\u0026quot;：クラスター名を指定する。 -e \u0026quot;http.host=0.0.0.0\u0026quot;：リスニングアドレスで、外部からのアクセスを許可する。 -e \u0026quot;ES_JAVA_OPTS=-Xms512m -Xmx512m\u0026quot;：メモリサイズ。 -e \u0026quot;discovery.type=single-node\u0026quot;：非クラスターモード。 -v es-data:/usr/share/elasticsearch/data：論理ボリュームをマウントして、ESのデータディレクトリをバインドする。 -v es-logs:/usr/share/elasticsearch/logs：論理ボリュームをマウントして、ESのログディレクトリをバインドする。 -v es-plugins:/usr/share/elasticsearch/plugins：論理ボリュームをマウントして、ESのプラグインディレクトリをバインドする。 --privileged：論理ボリュームへのアクセス権を付与する。 --network es-net ：es-netという名前のネットワークに参加させる。 \u0026lt;localhost:9200\u0026gt;にアクセスして、下みたいなレスポンスが返ってきたら起動成功だよ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 { \u0026#34;name\u0026#34; : \u0026#34;6747e3f712ba\u0026#34;, \u0026#34;cluster_name\u0026#34; : \u0026#34;docker-cluster\u0026#34;, \u0026#34;cluster_uuid\u0026#34; : \u0026#34;GSLtjxiMSlyRRRW-pSzvWQ\u0026#34;, \u0026#34;version\u0026#34; : { \u0026#34;number\u0026#34; : \u0026#34;7.12.1\u0026#34;, \u0026#34;build_flavor\u0026#34; : \u0026#34;default\u0026#34;, \u0026#34;build_type\u0026#34; : \u0026#34;docker\u0026#34;, \u0026#34;build_hash\u0026#34; : \u0026#34;3186837139b9c6b6d23c3200870651f10d3343b7\u0026#34;, \u0026#34;build_date\u0026#34; : \u0026#34;2021-04-20T20:56:39.040728659Z\u0026#34;, \u0026#34;build_snapshot\u0026#34; : false, \u0026#34;lucene_version\u0026#34; : \u0026#34;8.8.0\u0026#34;, \u0026#34;minimum_wire_compatibility_version\u0026#34; : \u0026#34;6.8.0\u0026#34;, \u0026#34;minimum_index_compatibility_version\u0026#34; : \u0026#34;6.0.0-beta1\u0026#34; }, \u0026#34;tagline\u0026#34; : \u0026#34;You Know, for Search\u0026#34; } kibana 同じバージョンのイメージをプルする\n1 docker pull kibana:7.12.1 実行\n1 2 3 4 5 6 docker run -d \\ --name kibana \\ -e ELASTICSEARCH_HOSTS=http://es:9200 \\ --network=es-net \\ -p 5601:5601 \\ kibana:7.12.1 この-e ELASTICSEARCH_HOSTS=http://es:9200\u0026quot;はElasticsearchのアドレスを設定してるんだ。kibanaはElasticsearchと同じネットワークにいるから、コンテナ名で直接Elasticsearchにアクセスできるってわけ。\nkibanaの起動はだいたい遅いから、少し待ってみてね。ログを確認して、ポート番号が表示されたら起動成功だよ。\n1 docker logs -f kibana \u0026lt;localhost:5601\u0026gt;にアクセスして結果を見てみて。\nIK形態素解析器 ESは転置インデックスを作る時にドキュメントを形態素解析する必要があるし、検索する時もユーザーの入力内容を形態素解析する必要があるんだ。でも、デフォルトの形態素解析ルールは日本語の処理にはあまり優しくないんだ。例えばテストしてみよう。\n1 2 3 4 5 6 # 形態素解析のテスト POST /_analyze { \u0026#34;analyzer\u0026#34;: \u0026#34;standard\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;初次使用 Elasticsearch\u0026#34; } 構文の説明\nPOST：リクエスト方式 /_analyze：リクエストパス。ここでは\u0026lt;http://localhost:9200\u0026gt;が省略されてて、kibanaが補完してくれるんだ。 リクエストパラメータはJSONを使う。 analyzer：形態素解析器のタイプで、デフォルトはstandardだよ。 text：形態素解析したい内容。 結果はこんな感じ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 { \u0026#34;tokens\u0026#34; : [ { \u0026#34;token\u0026#34; : \u0026#34;初\u0026#34;, \u0026#34;start_offset\u0026#34; : 0, \u0026#34;end_offset\u0026#34; : 1, \u0026#34;type\u0026#34; : \u0026#34;\u0026lt;IDEOGRAPHIC\u0026gt;\u0026#34;, \u0026#34;position\u0026#34; : 0 }, { \u0026#34;token\u0026#34; : \u0026#34;次\u0026#34;, \u0026#34;start_offset\u0026#34; : 1, \u0026#34;end_offset\u0026#34; : 2, \u0026#34;type\u0026#34; : \u0026#34;\u0026lt;IDEOGRAPHIC\u0026gt;\u0026#34;, \u0026#34;position\u0026#34; : 1 }, { \u0026#34;token\u0026#34; : \u0026#34;使\u0026#34;, \u0026#34;start_offset\u0026#34; : 2, \u0026#34;end_offset\u0026#34; : 3, \u0026#34;type\u0026#34; : \u0026#34;\u0026lt;IDEOGRAPHIC\u0026gt;\u0026#34;, \u0026#34;position\u0026#34; : 2 }, { \u0026#34;token\u0026#34; : \u0026#34;用\u0026#34;, \u0026#34;start_offset\u0026#34; : 3, \u0026#34;end_offset\u0026#34; : 4, \u0026#34;type\u0026#34; : \u0026#34;\u0026lt;IDEOGRAPHIC\u0026gt;\u0026#34;, \u0026#34;position\u0026#34; : 3 }, { \u0026#34;token\u0026#34; : \u0026#34;elasticsearch\u0026#34;, \u0026#34;start_offset\u0026#34; : 5, \u0026#34;end_offset\u0026#34; : 18, \u0026#34;type\u0026#34; : \u0026#34;\u0026lt;ALPHANUM\u0026gt;\u0026#34;, \u0026#34;position\u0026#34; : 4 } ] } 形態素解析の結果がすごく良くないのがわかるでしょ。日本語の形態素解析を処理するには、だいたいIK形態素解析器を使うんだ。\nIK形態素解析器 Github： https://github.com/medcl/elasticsearch-analysis-ik オンラインインストール インストールするバージョンがESと合ってるか注意してね。\n1 2 3 4 5 6 7 8 9 10 # コンテナの中に入る docker exec -it elasticsearch /bin/bash # オンラインでダウンロードしてインストール ./bin/elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.12.1/elasticsearch-analysis-ik-7.12.1.zip # 終了する exit # コンテナを再起動する docker restart elasticsearch オフラインインストール プラグインをインストールするには、Elasticsearchのpluginsディレクトリの場所を知る必要があるんだ。上記ではデータボリュームをローカルにマウントしてるから、以下のコマンドで確認できるよ。\n1 docker volume inspect es-plugins 出力されるJSONのMountpointがディレクトリだよ。\nGithubからダウンロードした圧縮ファイルを解凍して、フォルダ名をikにリネームしてからpluginsディレクトリに置いてね。\nコンテナを再起動する\n1 docker restart es 効果のテスト IK形態素解析器には2つのモードがあるんだ。\nik_smart：最小分割 ik_max_word：最大分割（最も細かく分割） さっきの例でまた試してみるね。\n1 2 3 4 5 6 # IK形態素解析のテスト POST /_analyze { \u0026#34;analyzer\u0026#34;: \u0026#34;ik_smart\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;初次使用 Elasticsearch\u0026#34; } 結果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 { \u0026#34;tokens\u0026#34; : [ { \u0026#34;token\u0026#34; : \u0026#34;初次\u0026#34;, \u0026#34;start_offset\u0026#34; : 0, \u0026#34;end_offset\u0026#34; : 2, \u0026#34;type\u0026#34; : \u0026#34;CN_WORD\u0026#34;, \u0026#34;position\u0026#34; : 0 }, { \u0026#34;token\u0026#34; : \u0026#34;使用\u0026#34;, \u0026#34;start_offset\u0026#34; : 2, \u0026#34;end_offset\u0026#34; : 4, \u0026#34;type\u0026#34; : \u0026#34;CN_WORD\u0026#34;, \u0026#34;position\u0026#34; : 1 }, { \u0026#34;token\u0026#34; : \u0026#34;elasticsearch\u0026#34;, \u0026#34;start_offset\u0026#34; : 5, \u0026#34;end_offset\u0026#34; : 18, \u0026#34;type\u0026#34; : \u0026#34;ENGLISH\u0026#34;, \u0026#34;position\u0026#34; : 2 } ] } この例では2つの形態素解析モードで結果が同じになったけど、もっと長い文で試すと結果の違いがわかるよ。\n辞書の拡張 インターネットが発展するにつれて、新しい言葉がどんどん生まれてくるから、既存の語彙リストにはない言葉も出てくるよね。だから、語彙リストも常に更新していく必要があるんだ。IK辞書を拡張するなら、ikディレクトリの中のconfigディレクトリにあるIKAnalyzer.cfg.xmlファイルを変更するだけでOKだよ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE properties SYSTEM \u0026#34;http://java.sun.com/dtd/properties.dtd\u0026#34;\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;comment\u0026gt;IK Analyzer 拡張設定\u0026lt;/comment\u0026gt; \u0026lt;!--ここで自分の拡張辞書を設定できるよ。 --\u0026gt; \u0026lt;entry key=\u0026#34;ext_dict\u0026#34;\u0026gt;ext.dic\u0026lt;/entry\u0026gt; \u0026lt;!--ここで自分の拡張ストップワード辞書を設定できるよ。--\u0026gt; \u0026lt;entry key=\u0026#34;ext_stopwords\u0026#34;\u0026gt;stopwords.dic\u0026lt;/entry\u0026gt; \u0026lt;!--ここでリモートの拡張辞書を設定できるよ。 --\u0026gt; \u0026lt;!-- \u0026lt;entry key=\u0026#34;remote_ext_dict\u0026#34;\u0026gt;words_location\u0026lt;/entry\u0026gt; --\u0026gt; \u0026lt;!--ここでリモートの拡張ストップワード辞書を設定できるよ。--\u0026gt; \u0026lt;!-- \u0026lt;entry key=\u0026#34;remote_ext_stopwords\u0026#34;\u0026gt;words_location\u0026lt;/entry\u0026gt; --\u0026gt; \u0026lt;/properties\u0026gt; 上の設定みたいに、拡張語は./ext.dicに置いて、禁止語は./stopwords.dicに置くんだ。\n禁止語には、「の」とか「ね」みたいな意味のない言葉を入れてもいいよ。\n設定が終わったら、ESを再起動してね。\nDSL インデックス操作 インデックスはデータベースのテーブルみたいなものなんだ。ESにデータを保存するには、まず「データベース」と「テーブル」を作る必要があるんだよ。\nマッピングプロパティ マッピングはインデックス内のドキュメントに対する制約で、よく使われるマッピングプロパティはこんな感じだよ。\ntype：フィールドのデータ型。よくある簡単な型はね。 文字列：text（形態素解析可能なテキスト）、keyword（厳密な値、例えばブランド、国、IPアドレス） 数値：long、integer、short、byte、double、float ブール：boolean 日付：date オブジェクト：object index：インデックスを作成するかどうか。デフォルトはtrueだよ。 analyzer：どの形態素解析器を使うか。 properties：このフィールドの子フィールド。 インデックスの作成 リクエスト方式：PUT リクエストパス：/インデックス名、自由に設定できるよ。 リクエストパラメータ：マッピング 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 PUT /インデックス名 { \u0026#34;mappings\u0026#34;: { \u0026#34;properties\u0026#34;: { \u0026#34;フィールド名\u0026#34;:{ \u0026#34;type\u0026#34;: \u0026#34;text\u0026#34;, \u0026#34;analyzer\u0026#34;: \u0026#34;ik_smart\u0026#34; }, \u0026#34;フィールド名2\u0026#34;:{ \u0026#34;type\u0026#34;: \u0026#34;keyword\u0026#34;, \u0026#34;index\u0026#34;: \u0026#34;false\u0026#34; }, \u0026#34;フィールド名3\u0026#34;:{ \u0026#34;properties\u0026#34;: { \u0026#34;子フィールド\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;keyword\u0026#34; } } }, // code } } } 例えば\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 # インデックスを作成 PUT /hello { \u0026#34;mappings\u0026#34;: { \u0026#34;properties\u0026#34;: { \u0026#34;info\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;text\u0026#34;, \u0026#34;analyzer\u0026#34;: \u0026#34;ik_smart\u0026#34; }, \u0026#34;email\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;keyword\u0026#34;, \u0026#34;index\u0026#34;: false }, \u0026#34;name\u0026#34;: { \u0026#34;properties\u0026#34;: { \u0026#34;firstName\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;keyword\u0026#34; }, \u0026#34;lastName\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;keyword\u0026#34; } } } } } } 実行後、こんな感じのが返ってきたら成功だよ。\n1 2 3 4 5 { \u0026#34;acknowledged\u0026#34; : true, \u0026#34;shards_acknowledged\u0026#34; : true, \u0026#34;index\u0026#34; : \u0026#34;hello\u0026#34; } インデックスの検索 リクエスト方式：GET\nリクエストパス：/インデックス名\nリクエストパラメータ：なし\n形式\n1 GET /インデックス名 例えば\n1 2 # インデックスを確認 GET /hello 結果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 { \u0026#34;hello\u0026#34; : { \u0026#34;aliases\u0026#34; : { }, \u0026#34;mappings\u0026#34; : { \u0026#34;properties\u0026#34; : { \u0026#34;email\u0026#34; : { \u0026#34;type\u0026#34; : \u0026#34;keyword\u0026#34;, \u0026#34;index\u0026#34; : false }, \u0026#34;info\u0026#34; : { \u0026#34;type\u0026#34; : \u0026#34;text\u0026#34;, \u0026#34;analyzer\u0026#34; : \u0026#34;ik_smart\u0026#34; }, \u0026#34;name\u0026#34; : { \u0026#34;properties\u0026#34; : { \u0026#34;firstName\u0026#34; : { \u0026#34;type\u0026#34; : \u0026#34;keyword\u0026#34; }, \u0026#34;lastName\u0026#34; : { \u0026#34;type\u0026#34; : \u0026#34;keyword\u0026#34; } } } } }, \u0026#34;settings\u0026#34; : { \u0026#34;index\u0026#34; : { \u0026#34;routing\u0026#34; : { \u0026#34;allocation\u0026#34; : { \u0026#34;include\u0026#34; : { \u0026#34;_tier_preference\u0026#34; : \u0026#34;data_content\u0026#34; } } }, \u0026#34;number_of_shards\u0026#34; : \u0026#34;1\u0026#34;, \u0026#34;blocks\u0026#34; : { \u0026#34;read_only_allow_delete\u0026#34; : \u0026#34;true\u0026#34; }, \u0026#34;provided_name\u0026#34; : \u0026#34;hello\u0026#34;, \u0026#34;creation_date\u0026#34; : \u0026#34;1703683379263\u0026#34;, \u0026#34;number_of_replicas\u0026#34; : \u0026#34;1\u0026#34;, \u0026#34;uuid\u0026#34; : \u0026#34;zn-kPdsETZeFcB0nXK79hg\u0026#34;, \u0026#34;version\u0026#34; : { \u0026#34;created\u0026#34; : \u0026#34;7120199\u0026#34; } } } } } インデックスの変更 インデックスとマッピングは一度作ったら変更できないんだけど、フィールドを追加することはできるよ。\n1 2 3 4 5 6 7 8 PUT /インデックス名/_mapping { \u0026#34;properties\u0026#34;: { \u0026#34;新しいフィールド名\u0026#34;:{ \u0026#34;type\u0026#34;: \u0026#34;integer\u0026#34; } } } 例えば\n1 2 3 4 5 6 7 8 9 10 # フィールドを追加 PUT /hello/_mapping { \u0026#34;properties\u0026#34;: { \u0026#34;age\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;integer\u0026#34;, \u0026#34;index\u0026#34;: false } } } もしread-only-allow-deleteみたいなエラーが出たら、それはディスクの空き容量が5%未満だからだよ。以下のリクエストで解決できるよ。\n1 2 3 4 5 6 7 8 PUT _settings { \u0026#34;index\u0026#34;: { \u0026#34;blocks\u0026#34;: { \u0026#34;read_only_allow_delete\u0026#34;: \u0026#34;false\u0026#34; } } } インデックスの削除 リクエスト方式：DELETE\nリクエストパス：/インデックス名\nリクエストパラメータ：なし\n形式\n1 DELETE /インデックス名 例えば\n1 DELETE /hello 結果\n1 2 3 { \u0026#34;acknowledged\u0026#34; : true } インデックス操作まとめ インデックスの作成：PUT /インデックス名 インデックスの検索：GET /インデックス名 インデックスの削除：DELETE /インデックス名 フィールドの追加：PUT /インデックス名/_mapping DSL ドキュメント操作 ドキュメントの追加 1 2 3 4 5 6 7 8 9 10 POST /インデックス名/_doc/ドキュメントid { \u0026#34;フィールド1\u0026#34;: \u0026#34;値1\u0026#34;, \u0026#34;フィールド2\u0026#34;: \u0026#34;値2\u0026#34;, \u0026#34;フィールド3\u0026#34;: { \u0026#34;サブプロパティ1\u0026#34;: \u0026#34;値3\u0026#34;, \u0026#34;サブプロパティ2\u0026#34;: \u0026#34;値4\u0026#34; }, // code } 例\n1 2 3 4 5 6 7 8 9 10 # ドキュメントを追加 PUT /hello/_doc/1 { \u0026#34;info\u0026#34;: \u0026#34;hello es\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;blog@yexca.net\u0026#34;, \u0026#34;name\u0026#34;: { \u0026#34;firstName\u0026#34;: \u0026#34;yexca\u0026#34;, \u0026#34;lastName\u0026#34;: \u0026#34;Dale\u0026#34; } } 結果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 { \u0026#34;_index\u0026#34; : \u0026#34;hello\u0026#34;, \u0026#34;_type\u0026#34; : \u0026#34;_doc\u0026#34;, \u0026#34;_id\u0026#34; : \u0026#34;1\u0026#34;, \u0026#34;_version\u0026#34; : 1, \u0026#34;result\u0026#34; : \u0026#34;created\u0026#34;, \u0026#34;_shards\u0026#34; : { \u0026#34;total\u0026#34; : 2, \u0026#34;successful\u0026#34; : 1, \u0026#34;failed\u0026#34; : 0 }, \u0026#34;_seq_no\u0026#34; : 0, \u0026#34;_primary_term\u0026#34; : 1 } ドキュメントの検索 1 GET /{インデックス名}/_doc/{id} 例\n1 2 # ドキュメントを検索 GEt /hello/_doc/1 結果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 { \u0026#34;_index\u0026#34; : \u0026#34;hello\u0026#34;, \u0026#34;_type\u0026#34; : \u0026#34;_doc\u0026#34;, \u0026#34;_id\u0026#34; : \u0026#34;1\u0026#34;, \u0026#34;_version\u0026#34; : 1, \u0026#34;_seq_no\u0026#34; : 0, \u0026#34;_primary_term\u0026#34; : 1, \u0026#34;found\u0026#34; : true, \u0026#34;_source\u0026#34; : { \u0026#34;info\u0026#34; : \u0026#34;hello es\u0026#34;, \u0026#34;email\u0026#34; : \u0026#34;blog@yexca.net\u0026#34;, \u0026#34;name\u0026#34; : { \u0026#34;firstName\u0026#34; : \u0026#34;yexca\u0026#34;, \u0026#34;lastName\u0026#34; : \u0026#34;Dale\u0026#34; } } } ドキュメントの変更 変更には2つの方法があって、全量変更と増分変更だよ。\n全量変更 全量変更は、元のドキュメントを上書きするんだ。本質的にはこうだよ。\n指定されたIDに基づいてドキュメントを削除する。 同じIDで新しいドキュメントを追加する。 もしIDが存在しなかったら、2番目のステップが実行されて、変更じゃなくて新規追加（上書き書き込み）になるんだ。\n1 2 3 4 5 6 PUT /{インデックス名}/_doc/ドキュメントid { \u0026#34;フィールド1\u0026#34;: \u0026#34;値1\u0026#34;, \u0026#34;フィールド2\u0026#34;: \u0026#34;値2\u0026#34;, // code } 例えば\n1 2 3 4 5 6 7 8 9 10 # 変更 - 全量変更 PUT /hello/_doc/1 { \u0026#34;info\u0026#34;: \u0026#34;hello es\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;es@yexca.net\u0026#34;, \u0026#34;name\u0026#34;: { \u0026#34;firstName\u0026#34;: \u0026#34;yexca\u0026#34;, \u0026#34;lastName\u0026#34;: \u0026#34;Dale\u0026#34; } } 結果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 { \u0026#34;_index\u0026#34; : \u0026#34;hello\u0026#34;, \u0026#34;_type\u0026#34; : \u0026#34;_doc\u0026#34;, \u0026#34;_id\u0026#34; : \u0026#34;1\u0026#34;, \u0026#34;_version\u0026#34; : 2, \u0026#34;result\u0026#34; : \u0026#34;updated\u0026#34;, \u0026#34;_shards\u0026#34; : { \u0026#34;total\u0026#34; : 2, \u0026#34;successful\u0026#34; : 1, \u0026#34;failed\u0026#34; : 0 }, \u0026#34;_seq_no\u0026#34; : 1, \u0026#34;_primary_term\u0026#34; : 1 } 検索してみると、メールアドレスが変更されてるのがわかるよ。\n増分変更 増分変更は、指定されたIDに一致するドキュメントの中の一部フィールドだけを変更するんだ。\n1 2 3 4 5 6 POST /{インデックス名}/_update/ドキュメントid { \u0026#34;doc\u0026#34;: { \u0026#34;フィールド名\u0026#34;: \u0026#34;新しい値\u0026#34; } } 例えば\n1 2 3 4 5 6 7 # 変更 - 増分変更 POST /hello/_update/1 { \u0026#34;doc\u0026#34;: { \u0026#34;email\u0026#34;: \u0026#34;blog@yexca.net\u0026#34; } } 結果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 { \u0026#34;_index\u0026#34; : \u0026#34;hello\u0026#34;, \u0026#34;_type\u0026#34; : \u0026#34;_doc\u0026#34;, \u0026#34;_id\u0026#34; : \u0026#34;1\u0026#34;, \u0026#34;_version\u0026#34; : 3, \u0026#34;result\u0026#34; : \u0026#34;updated\u0026#34;, \u0026#34;_shards\u0026#34; : { \u0026#34;total\u0026#34; : 2, \u0026#34;successful\u0026#34; : 1, \u0026#34;failed\u0026#34; : 0 }, \u0026#34;_seq_no\u0026#34; : 2, \u0026#34;_primary_term\u0026#34; : 1 } 検索してみると、メールアドレスが変更されてるのがわかるよ。\nドキュメントの削除 1 DELETE /{インデックス名}/_doc/id値 例えば\n1 2 # ドキュメントを削除 DELETE /hello/_doc/1 結果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 { \u0026#34;_index\u0026#34; : \u0026#34;hello\u0026#34;, \u0026#34;_type\u0026#34; : \u0026#34;_doc\u0026#34;, \u0026#34;_id\u0026#34; : \u0026#34;1\u0026#34;, // 途中で他のを編集したから、バージョン番号が高くなってるよ \u0026#34;_version\u0026#34; : 8, \u0026#34;result\u0026#34; : \u0026#34;deleted\u0026#34;, \u0026#34;_shards\u0026#34; : { \u0026#34;total\u0026#34; : 2, \u0026#34;successful\u0026#34; : 1, \u0026#34;failed\u0026#34; : 0 }, \u0026#34;_seq_no\u0026#34; : 7, \u0026#34;_primary_term\u0026#34; : 1 } ドキュメント操作まとめ ドキュメントの作成：POST /{インデックス名}/_doc/ドキュメントid { jsonドキュメント } ドキュメントの検索：GET /{インデックス名}/_doc/ドキュメントid ドキュメントの削除：DELETE /{インデックス名}/_doc/ドキュメントid ドキュメントの変更： 全量変更：PUT /{インデックス名}/_doc/ドキュメントid { jsonドキュメント } 増分変更：POST /{インデックス名}/_update/ドキュメントid { \u0026quot;doc\u0026quot;: {フィールド}} ","date":"2025-01-29T23:38:51+09:00","permalink":"https://blog.yexca.net/ja/archives/226/","title":"Elasticsearch 入門"},{"content":" 📢 この記事は gemini-3-flash-preview によって翻訳されました Redis 基礎: https://blog.yexca.net/ja/archives/157/ Redis 分散キャッシュ: 本文\nはじめに 結局この2つの記事、同時に書いたのに1年も経ってから投稿してるんだよね\n実は当時書きたいものが3つあったんだけど、思い出すたびに何を書こうとしてたか忘れちゃって、気づいたら1年近く経ってたっていう。。。\n問題点 スタンドアロン（単一インスタンス）の Redis には以下の課題がある。\nデータの紛失：Redis データの永続化を実現する必要がある 並行処理能力の問題：主従（マスター・スレーブ）クラスタを構築し、読み書き分離を実現する必要がある ストレージ容量の問題：シャーディング（分片）クラスタを構築し、スロット・メカニズムを利用して動的スケーリングを実現する必要がある 障害復旧の問題：Redis センチネル（Sentinel）を利用して、ヘルスチェックと自動復旧を実現する必要がある Redis の永続化 Redis の永続化には RDB と AOF の2つの方法がある。\nRDB 永続化 RDB の正式名称は Redis Database Backup file（Redis データバックアップファイル）。Redis データスナップショットとも呼ばれる。簡単に言うと、メモリ内のすべてのデータをディスクに記録すること。Redis インスタンスが故障して再起動したとき、ディスクからスナップショットファイルを読み込んでデータを復元する。スナップショットファイルは RDB ファイルと呼ばれ、デフォルトでは実行ディレクトリに保存される。\nRDB は以下の4つのケースで実行される：\nsave コマンド：即座に実行される。メインプロセスが RDB を実行するため、他のすべてのコマンドがブロックされる。データ移行時にのみ使われる可能性がある。 bgsave コマンド：非同期で実行される。独立したプロセスを開始して RDB を完了させるため、メインプロセスは影響を受けずにユーザーのリクエストを処理し続けられる。 Redis 停止時：停止時に save コマンドが1回実行される。 RDB 発動条件に達したとき：設定ファイルで以下のように設定する。 1 2 3 4 # 900秒以内に少なくとも1つのキーが変更されたらbgsaveを実行。save \u0026#34;\u0026#34; ならRDB無効 save 900 1 save 300 10 save 60 10000 その他の設定\n1 2 3 4 5 6 7 8 # 圧縮するかどうか。CPUを消費するのでオフを推奨。ディスクは安いしね rdbcompression yes # RDBファイル名 dbfilename dump.rdb # ファイル保存ディレクトリ dir ./ RDB の原理 bgsave が始まると、メインプロセスが fork して子プロセスを作成する。子プロセスはメインプロセスのメモリデータを共有する。fork 完了後、メモリデータを読み取って RDB ファイルに書き込む。\nfork は copy-on-write 技術を採用している：\nメインプロセスが読み取り操作を行うときは、共有メモリにアクセスする。 メインプロセスが書き込み操作を行うときは、データのコピーを作成してから書き込みを行う。 RDB の欠点：\n実行間隔が長く、2回の RDB の間に書き込まれたデータが失われるリスクがある。 子プロセスの fork、圧縮、RDB ファイルの書き出しに時間がかかる。 AOF 永続化 AOF の正式名称は Append Only File（追加専用ファイル）。Redis が処理するすべての書き込みコマンドを記録するファイルで、コマンドログファイルのようなもの。\nAOF はデフォルトでオフになっているので、設定ファイルを変更して有効にする。\n1 2 3 4 # AOF機能を有効にするか。デフォルトはno appendonly yes # AOFファイル名 appendfilename \u0026#34;appendonly.aof\u0026#34; 記録の頻度も redis.conf で設定できる。\n1 2 3 4 5 6 # 書き込みコマンドが実行されるたびに、すぐにAOFファイルに記録する appendfsync always # 書き込みコマンド実行後、まずAOFバッファに入れ、1秒ごとにバッファの内容をAOFファイルに書き込む。デフォルト設定 appendfsync everysec # 書き込みコマンド実行後、まずAOFバッファに入れ、OSがディスクに書き戻すタイミングを決める appendfsync no 設定項目の比較：\n設定項目 ディスク書き込みのタイミング メリット デメリット always 同期書き込み 信頼性が高く、データがほぼ失われない パフォーマンスへの影響が大きい everysec 毎秒書き込み パフォーマンスはそこそこ 最大1秒分のデータが失われる可能性がある no OSが制御 パフォーマンスが最高 信頼性が低く、大量のデータが失われる可能性がある ファイルの書き換え（Rewrite） コマンドを記録するため、AOF ファイルは RDB よりかなり大きくなる。また、同じキーに対する複数の書き込みもすべて記録されるが、実際には最後の書き込みだけが意味を持つ。bgrewriteaof コマンドを実行することで、AOF ファイルを書き換え、最小限のコマンドで同じ状態を再現できるようになる。\n例えば、元のコマンドが：\n1 2 3 set num 123 set name jack set num 666 書き換え後は：\n1 mset name jack num 666 Redis は閾値に達したときにも自動的に AOF を書き換える。設定ファイルで指定する：\n1 2 3 4 # AOFファイルが前回のファイルより何パーセント増加したら書き換えを実行するか auto-aof-rewrite-percentage 100 # AOFファイルが最低でもどれくらいのサイズになったら書き換えを実行するか auto-aof-rewrite-min-size 64mb RDB と AOF の比較 RDB と AOF にはそれぞれメリット・デメリットがある。データの安全性を重視する場合、実際の開発では両方を組み合わせて使うことが多い。\nRDB AOF 永続化方式 定期的にメモリ全体のスナップショットを作成 実行されたすべてのコマンドを記録 データの完全性 不完全。バックアップの合間にデータが失われる 比較的完全。書き込み戦略に依存する ファイルサイズ 圧縮されるため、ファイルサイズは小さい コマンドを記録するため、サイズは非常に大きくなる 復旧速度 非常に速い 遅い データ復旧の優先順位 低い。データの完全性が AOF に劣るため 高い。データの完全性がより高いため システムリソース占有 高い。大量の CPU とメモリを消費 低い。主にディスク I/O リソース\nただし AOF 書き換え時は大量の CPU とメモリを消費 使用シーン 数分間のデータ紛失が許容でき、高速な起動を求める場合 データの安全性を高く求められる一般的なケース Redis 主従アーキテクチャ 単一ノードの Redis の並行処理能力には限界がある。さらに向上させるには、主従（マスター・スレーブ）クラスタを構築して読み書き分離を実現する必要がある。\nクラスタ構築 CentOS7 ベースでの手順。\n上の図を参考に、合計3つのノードを同一マシン内に配置する。ポートは 7001(master)、7002、7003 とする。\nまずディレクトリを作成。\n1 2 cd /tmp mkdir 7001 7002 7003 設定を変更している場合は、デフォルトの RDB モードに戻しておく。\n1 2 3 4 5 6 7 8 # RDBを有効化 # save \u0026#34;\u0026#34; save 3600 1 save 300 100 save 60 10000 # AOFを無効化 appendonly no 設定ファイルを各インスタンスのディレクトリにコピー。\n1 2 3 4 5 6 7 # 方法1 cp redis-6.2.4/redis.conf 7001 cp redis-6.2.4/redis.conf 7002 cp redis-6.2.4/redis.conf 7003 # 方法2 echo 7001 7002 7003 | xargs -t -n 1 cp redis-6.2.4/redis.conf 各インスタンスのポートと作業ディレクトリ（ポートの修正、rdb ファイルの保存場所の修正）を変更。\n1 2 3 sed -i -e \u0026#39;s/6379/7001/g\u0026#39; -e \u0026#39;s/dir .\\//dir \\/tmp\\/7001\\//g\u0026#39; 7001/redis.conf sed -i -e \u0026#39;s/6379/7002/g\u0026#39; -e \u0026#39;s/dir .\\//dir \\/tmp\\/7002\\//g\u0026#39; 7002/redis.conf sed -i -e \u0026#39;s/6379/7003/g\u0026#39; -e \u0026#39;s/dir .\\//dir \\/tmp\\/7003\\//g\u0026#39; 7003/redis.conf IP を修正。すべてのディレクトリを修正すること (ip_address を実際のIPに置換)。\n1 2 3 4 5 6 7 # 1つずつ実行 sed -i \u0026#39;1a replica-announce-ip ip_address\u0026#39; 7001/redis.conf sed -i \u0026#39;1a replica-announce-ip ip_address\u0026#39; 7002/redis.conf sed -i \u0026#39;1a replica-announce-ip ip_address\u0026#39; 7003/redis.conf # または一括で修正 printf \u0026#39;%s\\n\u0026#39; 7001 7002 7003 | xargs -I{} -t sed -i \u0026#39;1a replica-announce-ip ip_address\u0026#39; {}/redis.conf 起動。\n1 2 3 4 5 6 # 1つ目 redis-server 7001/redis.conf # 2つ目 redis-server 7002/redis.conf # 3つ目 redis-server 7003/redis.conf 停止。\n1 printf \u0026#39;%s\\n\u0026#39; 7001 7002 7003 | xargs -I{} -t redis-cli -p {} shutdown ","date":"2025-01-28T21:47:19+09:00","permalink":"https://blog.yexca.net/ja/archives/225/","title":"Redis 分散キャッシュ"},{"content":" 音に感じてシリーズ 曲 翻訳 リンク 僕が死のうと思ったのは 略 https://blog.yexca.net/ja/archives/214 あくあ色ぱれっと 略 https://blog.yexca.net/ja/archives/219 恋の押し売り 略 https://blog.yexca.net/ja/archives/220 17さいのうた 略 この記事 drop 恋に落ちた https://blog.yexca.net/ja/archives/230 生きるを選んだ私へ 略 https://blog.yexca.net/ja/archives/239 rainy lady 雨女 https://blog.yexca.net/ja/archives/249 恋しくなったら手を叩こう 略 https://blog.yexca.net/ja/archives/250 まえがき 私も未来のことを迷っているけど、でも生活がずっと続いているから、自分を変えなきゃね\n動画 歌詞 こんな私の未熟なうたを　聴いてくれてどうも有難うね\n未熟: みじゅく\nもう少しで私は未熟な大人に　なるみたいです\nなんか笑っちゃうね\n本当はね\nもっと前を向けるようなうたを　書くつもりだったけど\n書けなくて\n私はまだ　他の誰かを支えられるほど\n強くなかったみたい　ごめんね\n拝啓　未来の私へ　今そこで\nどんなことをして　生きていますか\n拝啓　今の私へ　今ここで\nどんなことをしたら　生きていけるんでしょうか\n\u0026ldquo;好きだからかっこいい\u0026quot;とか　\u0026ldquo;そばにいる\u0026quot;とか\n\u0026ldquo;勝手に盗んだ\u0026quot;とか　書いてた\nどうせだったらもうちょっと　貴方みたいに\nやさしいうたを書けばよかったね\n本当はね　好きなことだけして生きたいの\nでもそれは上手な生き方とは言えないから\n無駄になっても　意味がなくても\n今はここから　離れなきゃいけないの　ごめんね\n拝啓　未来の私へ　今そこで\nどんな大人になって　生きていますか\n拝啓　今の私へ　今ここで\nどんな大人になりたいと　言えばいいんでしょうか\n「さよなら」は悲しくなるからさ\n「またね」って言わせて\nいつか私が　今みたいな　うたを書けなくなっても\n怒らないでね\n拝啓　過去の私へ　今の私は\nずっと夢見ていたこと叶えてるよ\n拝啓　今の私へ\nこんな情けない　うただって歌えばいいよ\n情け: なさけ\nそれが私だから\n拝啓　未来の私へ　今そこは\nどんな綺麗な世界が　広がっていますか\n拝啓　今の私へ　今ここが\nどんな世界よりも　幸せでした\nこんな私の未熟なうたを　聴いてくれてどうも有難うね\nこれから私は未熟な大人に　なる準備をします\n「じゃあ またね」\n","date":"2025-01-25T16:57:49+09:00","permalink":"https://blog.yexca.net/ja/archives/224/","title":"音に感じて - 《17さいのうた》"},{"content":" 📢 この記事は gemini-2.5-flash によって翻訳されました 設定 yaml、yml、propertiesファイルで設定できるよ。Javaのシステムプロパティやコマンドライン引数でも設定できるんだ。\n優先順位は、コマンドライン引数 \u0026gt; Javaシステムプロパティ \u0026gt; properties \u0026gt; yml \u0026gt; yaml だよ。\nコマンドラインで使うには、まずMavenのパッケージングコマンドを実行してから、コマンドラインで動かすんだ。\n1 2 3 4 5 java -jar path_to_jar.jar # Java システムプロパティ、ポートを例に java -Dserver.port=9000 -jar path_to_jar.jar # コマンドライン引数、ポートを例に java -jar path_to_jar.jar --server.port=9000 SpringBootプロジェクトをパッケージングするときは、spring-boot-maven-pluginプラグインを組み込む必要があるよ (公式のひな形からプロジェクトを作ると、このプラグインは自動で追加されるんだ)。\nBeanの管理 Beanの取得 デフォルトのシングルトンで遅延ロードされないbeanの場合、Springプロジェクトが起動するときに、beanは全部作られてIOCコンテナに入れられるんだ (@Lazyアノテーションを付けると、初めて使われるときにインスタンス化されるよ)。\nもしこれらのbeanを能動的に取得したいなら、以下の方法でできるよ。\n名前で取得 1 Object getBean(String name) 型で取得 1 \u0026lt;T\u0026gt; T getBean(Class\u0026lt;T\u0026gt; requiredType) 名前と型で取得 (型変換) 1 \u0026lt;T\u0026gt; T getBean(String name, Class\u0026lt;T\u0026gt; requiredType) このメソッドを使うためには、まずIOCコンテナオブジェクトを取得する必要があるんだ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 @Autowired private ApplicationContext applicationContext; //IOCコンテナオブジェクト public void testGetBean(){ // beanの名前で取得する DeptController beanl = (DeptController) applicationContext.getBean(\u0026#34;deptController\u0026#34;); // beanの型で取得する DeptController bean2 = applicationContext.getBean(DeptController.class); // beanの名前と型で取得する DeptController bean3 = applicationContext.getBean(\u0026#34;deptController\u0026#34;, DeptController.class); } Beanのスコープ Springは5種類のスコープをサポートしているよ。後ろの3つはWeb環境でのみ有効になるんだ。\nスコープ 説明 singleton コンテナ内に同じ名前のbeanのインスタンスは1つだけ (シングルトン) prototype このbeanを使うたびに新しいインスタンスが作成される (非シングルトン) request 各リクエストの範囲内で新しいインスタンスが作成される session 各セッションの範囲内で新しいインスタンスが作成される application 各アプリケーションの範囲内で新しいインスタンスが作成される @Scopeアノテーションを使ってスコープを設定するよ。\n1 2 3 4 5 6 // 非シングルトンに設定 @Scope(\u0026#34;prototype\u0026#34;) @RestController public class xxxController{ } 実際の開発では、ほとんどのBeanがシングルトンだよ。つまり、ほとんどのBeanでscope属性を設定する必要はないんだ。\nサードパーティのBean もし管理したいbeanオブジェクトがサードパーティ製 (自分で作ったものではない) の場合、@Componentやその派生アノテーションでbeanを宣言することはできないんだ。その場合は@Beanアノテーションを使う必要があるよ。例えばXMLファイルを解析するdom4jみたいにね。\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.dom4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;dom4j\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.1.3\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 依存関係はこんな感じ。\n1 2 3 4 5 6 7 @SpringBootApplication public class xxxApplication{ @Bean // メソッドの戻り値をIOCコンテナに管理させ、IOCコンテナのbeanオブジェクトにする public SAXReader saxReader(){ return new SAXReader; } } だけど、もしサードパーティのbeanオブジェクトを管理するなら、これらのbeanをまとめて分類して設定することをおすすめするよ。@Configurationアノテーションを使って設定クラスを宣言できるんだ。\n1 2 3 4 5 6 7 @Configuration public class CommonConfig { @Bean public SAXReader saxReader(){ return new SAXReader; } } @Beanアノテーションのnameまたはvalue属性でbeanの名前を宣言できるよ。指定しない場合、デフォルトのbean名はメソッド名になるんだ。もしサードパーティのbeanが他のbeanオブジェクトに依存している場合、bean定義メソッドの仮引数に直接設定するだけでいいよ。コンテナが型に基づいて自動的にインジェクションしてくれるんだ。\n1 2 3 4 5 6 7 @Configuration public class CommonConfig { @Bean public SAXReader saxReader(XxService xxService){ return new SAXReader; } } スターター依存 開発中にSpringを直接使う場合、関連する依存関係を組み込んで、バージョンの整合性を保つ必要があるんだ。だけどSpringBootを使うなら、スターター依存を組み込むだけでいいよ。原理はMavenの推移的依存だよ。他の依存関係は、Mavenの依存関係の推移によって自動的に組み込まれるんだ。\n自動設定 SpringBootの自動設定とは、Springコンテナが起動した後に、一部の設定クラスやbeanオブジェクトが自動的にIOCコンテナに保存されることだよ。僕たちが手動で宣言する必要はないんだ。これによって開発が簡略化され、面倒な設定作業が省けるんだ。\n設定クラスの@Configurationは、その基盤が@Componentなんだ。そしてコンテナ内の一つのbeanオブジェクトでもあるんだよ。\n依存関係を組み込んだ後、どのようにして依存するjarファイルに定義されている設定クラスやbeanをSpringIOCコンテナに読み込むんだろうね。\n@ComponentScan @ComponentScanを使うと、スキャンしたいパッケージを指定できるよ。例えば、依存関係でcom.exampleパッケージがインポートされた場合みたいにね。\n1 2 @SpringBootApplication @ComponentScan({\u0026#34;net.yexca\u0026#34;,\u0026#34;com.example\u0026#34;}) だけど、たくさんのサードパーティの依存関係を組み込む必要がある場合、上のようにたくさんのパッケージを設定しなきゃいけないんだ。広範囲のスキャンはパフォーマンスも低いんだよね。\n@Import 普通のクラス、設定クラス、それからImportSelectorインターフェースの実装クラスをインポートできるよ。\n普通のクラス 1 2 @Import(TokenParser.class) //普通のクラスをインポート @SpringBootApplication 設定クラス 設定クラスの内容\n1 2 3 4 5 6 7 8 9 10 11 12 @Configuration public class HeaderConfig { @Bean public HeaderParser headerParser(){ return new HeaderParser(); } @Bean public HeaderGenerator headerGenerator(){ return new HeaderGenerator(); } } 起動クラス\n1 2 @Import(HeaderConfig.class) //設定クラスをインポート @SpringBootApplication ImportSelectorインターフェースの実装クラス ImportSelectorインターフェースの実装クラスの内容\n1 2 3 4 5 6 public class MyImportSelector implements ImportSelector { public String[] selectImports(AnnotationMetadata importingClassMetadata) { //戻り値は文字列の配列 (配列には完全修飾名のクラスがカプセル化されている) return new String[]{\u0026#34;com.example.HeaderConfig\u0026#34;}; } } 起動クラス\n1 2 @Import(MyImportSelector.class) //ImportSelectorインターフェース実装クラスをインポート @SpringBootApplication @EnableXxxxx 上の@Importは、まずサードパーティの依存関係にどんな設定クラスやbeanがあるかを知っている必要があるんだ。だけどサードパーティの依存関係は@EnableXxxxxアノテーションを提供できるよ。@Importアノテーションをカプセル化して、よく使うbeanを提供できるんだ。使うときは@EnableXxxxxアノテーションを付けるだけでいいんだよ。\n上の@Importの設定クラスのように、@EnableHeaderConfigアノテーションをカプセル化してみようか。\n1 2 3 4 5 @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.TYPE) @Import(MyImportSelector.class)//どのbeanオブジェクトや設定クラスをインポートするか指定する public @interface EnableHeaderConfig { } そして、起動クラスに@EnableHeaderConfigアノテーションを付けるだけで、対応するbeanをインポートできるんだ。\n1 2 @EnableHeaderConfig //サードパーティの依存が提供するEnableで始まるアノテーションを使用 @SpringBootApplication この方法もSpringBootが採用しているやり方だよ。\nSpringBootの自動設定 @SpringBootApplicationアノテーションの中には@EnableAutoConfigurationがあるんだ。その@Import({AutoConfigurationImportSelector.class})は、ImportSelectorインターフェースの実装クラスAutoConfigurationImportSelector.classをインポートしているんだ。\nこの実装クラスでは、selectImports()メソッドがオーバーライドされているよ。\n1 2 3 4 5 6 7 8 9 public String[] selectImports(AnnotationMetadata annotationMetadata) { if (!this.isEnabled(annotationMetadata)) { return NO_IMPORTS; } else { // 自動設定される設定クラス情報の集合を取得する AutoConfigurationEntry autoConfigurationEntry = this.getAutoConfigurationEntry(annotationMetadata); return StringUtils.toStringArray(autoConfigurationEntry.getConfigurations()); } } getAutoConfigurationEntry()メソッドを呼び出して、自動設定される設定クラス情報の集合を取得しているんだ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 protected AutoConfigurationEntry getAutoConfigurationEntry(AnnotationMetadata annotationMetadata) { if (!this.isEnabled(annotationMetadata)) { return EMPTY_ENTRY; } else { AnnotationAttributes attributes = this.getAttributes(annotationMetadata); // 設定ファイルに設定されているすべての自動設定クラスの集合を取得する List\u0026lt;String\u0026gt; configurations = this.getCandidateConfigurations(annotationMetadata, attributes); configurations = this.removeDuplicates(configurations); Set\u0026lt;String\u0026gt; exclusions = this.getExclusions(annotationMetadata, attributes); this.checkExcludedClasses(configurations, exclusions); configurations.removeAll(exclusions); configurations = this.getConfigurationClassFilter().filter(configurations); this.fireAutoConfigurationImportEvents(configurations, exclusions); return new AutoConfigurationEntry(configurations, exclusions); } } その中でも、getCandidateConfigurations(annotationMetadata, attributes)メソッドは、設定ファイルに設定されているすべての自動設定クラスの集合を取得するんだ。\n1 2 3 4 5 6 protected List\u0026lt;String\u0026gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) { List\u0026lt;String\u0026gt; configurations = new ArrayList(SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader())); ImportCandidates.load(AutoConfiguration.class, this.getBeanClassLoader()).forEach(configurations::add); Assert.notEmpty(configurations, \u0026#34;No auto configuration classes found in META-INF/spring.factories nor in META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports. If you are using a custom packaging, make sure that file is correct.\u0026#34;); return configurations; } これは、META-INF/spring.factoriesとMETA-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.importsファイルにある設定クラスの集合を取得しているのがわかるね。\nこれらの2つのファイルは、通常、組み込まれたスターター依存の中にあるんだ。\nつまり、SpringBootプログラムが起動するときに、設定ファイルに定義されている設定クラスが読み込まれるんだ。そして、これらの設定クラス情報 (クラスの完全修飾名) がString型の配列にカプセル化されて、最終的に@Importアノテーションを通じて、これらの設定クラスがすべてSpringのIOCコンテナに読み込まれ、IOCコンテナに管理されるんだ。\n@Conditional でもファイルの中に設定クラスがたくさんあるけど、すべてのbeanがIOCコンテナに登録されるのかな？そうじゃないんだ、@Conditionalアノテーションを使うと、beanオブジェクトを条件に応じてインジェクションできるんだよ。\n@Conditionalは親アノテーションで、たくさんの子アノテーションがあるんだ。\n@ConditionalOnClass 環境に対応するバイトコードファイルがある場合にのみ、beanをIOCコンテナに登録するんだ。\n1 2 3 4 5 6 7 8 9 10 11 @Configuration public class HeaderConfig { @Bean //環境に指定されたこのクラスが存在する場合にのみ、このbeanがIOCコンテナに追加される @ConditionalOnClass(name=\u0026#34;io.jsonwebtoken.Jwts\u0026#34;) public HeaderParser headerParser(){ return new HeaderParser(); } } 上記のbeanは、JWTトークンの依存関係を組み込んだ場合にのみIOCコンテナにインジェクションされるんだ。\n1 2 3 4 5 6 \u0026lt;!--JWTトークン--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.jsonwebtoken\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jjwt\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.9.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; テスト\n1 2 3 4 5 6 7 8 9 10 11 @SpringBootTest public class AutoConfigurationTests { @Autowired private ApplicationContext applicationContext; @Test public void testHeaderParser(){ System.out.println(applicationContext.getBean(HeaderParser.class)); } } @ConditionalOnMissingBean 環境に対応するbean (型または名前) がない場合にのみ、beanをIOCコンテナに登録するんだ。\n1 2 3 4 5 6 7 8 9 10 11 @Configuration public class HeaderConfig { @Bean //この型のbeanが存在しない場合にのみ、このbeanがIOCコンテナに追加される @ConditionalOnMissingBean public HeaderParser headerParser(){ return new HeaderParser(); } } 上のように、IOCにHeaderConfig型のbeanがない場合にのみ作成されるんだ。\nアノテーションで他のbeanの名前を指定することもできるよ。\n1 2 3 4 5 6 7 8 9 10 11 @Configuration public class HeaderConfig { @Bean //指定された名前のbeanが存在しない場合にのみ、このbeanがIOCコンテナに追加される @ConditionalOnMissingBean(name=\u0026#34;deptController2\u0026#34;) public HeaderParser headerParser(){ return new HeaderParser(); } } 上の例では、deptController2という名前のbeanオブジェクトが存在しない場合にのみ、HeaderConfigオブジェクトが作成されてIOCに登録されるんだ。\n型を指定することもできるよ。\n1 2 3 4 5 6 7 8 9 10 11 @Configuration public class HeaderConfig { @Bean //指定された型のbeanが存在しない場合にのみ、beanがIOCコンテナに追加される @ConditionalOnMissingBean(HeaderConfig.class) public HeaderParser headerParser(){ return new HeaderParser(); } } 上の例を実行してこのbeanを呼び出すと、NoSuchBeanDefinitionException例外が発生するんだ。@Configurationの中には@Componentがあるから、自動的にHeaderConfigのbeanが作成されちゃうんだ。だからHeaderParserのbeanは作成されないんだよ。\n@ConditionalOnProperty 設定ファイルに対応するプロパティと値がある場合にのみ、beanをIOCコンテナに登録するんだ。\n設定ファイル\n1 name: header 設定クラス\n1 2 3 4 5 6 7 8 9 10 11 @Configuration public class HeaderConfig { @Bean //設定ファイルに指定されたプロパティ名と値が存在する場合にのみ、beanがIOCコンテナに追加される @ConditionalOnProperty(name =\u0026#34;name\u0026#34;,havingValue = \u0026#34;header\u0026#34;) public HeaderParser headerParser(){ return new HeaderParser(); } } カスタムスターター依存 例えば、自分だけのAlibaba Cloud OSSのスターター依存を作ってみようか。\nまず命名についてだけど、SpringBoot公式のスターターはspring-boot-starter-xxxという名前にするんだ。サードパーティが提供するものはxxx-spring-boot-starterという名前にするよ。\n次にモジュールだけど、規範に従って2つのモジュールを定義する必要があるんだ。\nstarterモジュールは、依存関係の管理をするんだ。プログラム開発に必要な依存関係をすべてstarter依存の中に定義するよ。 autoconfigureモジュールは、自動設定に使うんだ。 この2つのモジュールを定義したら、他のプロジェクトはスターター依存を組み込むだけでいいんだ。自動設定モジュールが依存関係を推移的に渡してくれるからね。\nモジュールのpomファイル aliyun-oss-spring-boot-starterモジュール\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.7.5\u0026lt;/version\u0026gt; \u0026lt;relativePath/\u0026gt; \u0026lt;!-- lookup parent from repository --\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;groupId\u0026gt;com.aliyun.oss\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;aliyun-oss-spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;java.version\u0026gt;11\u0026lt;/java.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!-- autoconfigureモジュールを組み込む --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.aliyun.oss\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;aliyun-oss-spring-boot-autoconfigure\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/project\u0026gt; aliyun-oss-spring-boot-autoconfigureモジュール\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.7.5\u0026lt;/version\u0026gt; \u0026lt;relativePath/\u0026gt; \u0026lt;!-- lookup parent from repository --\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;groupId\u0026gt;com.aliyun.oss\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;aliyun-oss-spring-boot-autoconfigure\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;java.version\u0026gt;11\u0026lt;/java.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- webスターター依存を組み込む --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Lombok --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Alibaba Cloud OSS --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.aliyun.oss\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;aliyun-sdk-oss\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.15.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.xml.bind\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jaxb-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.3.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.activation\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;activation\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.1.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- no more than 2.3.3--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.glassfish.jaxb\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jaxb-runtime\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.3.3\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/project\u0026gt; 自動設定 AliOSSAutoConfigurationクラス\n1 2 3 4 5 6 7 8 9 10 11 12 13 @Configuration //AliOSSPropertiesクラスをインポートし、SpringIOCに管理させる @EnableConfigurationProperties(AliOSSProperties.class) public class AliOSSAutoConfiguration { //AliOSSUtilsオブジェクトを作成し、SpringIOCコンテナに渡す @Bean public AliOSSUtils aliOSSUtils(AliOSSProperties aliOSSProperties){ AliOSSUtils aliOSSUtils = new AliOSSUtils(); aliOSSUtils.setAliOSSProperties(aliOSSProperties); return aliOSSUtils; } } AliOSSPropertiesクラス\n1 2 3 4 5 6 7 8 9 10 11 12 13 /* Alibaba Cloud OSS関連設定 */ @Data @ConfigurationProperties(prefix = \u0026#34;aliyun.oss\u0026#34;) public class AliOSSProperties { //リージョン private String endpoint; //アクセスキーID private String accessKeyId ; //アクセスキーシークレット private String accessKeySecret ; //バケット名 private String bucketName; } AliOSSUtilsクラス\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 @Data public class AliOSSUtils { private AliOSSProperties aliOSSProperties; /** * 画像をOSSにアップロードする処理を実装 */ public String upload(MultipartFile multipartFile) throws IOException { // アップロードされたファイルの入力ストリームを取得 InputStream inputStream = multipartFile.getInputStream(); // ファイルの上書きを防ぐ String originalFilename = multipartFile.getOriginalFilename(); String fileName = UUID.randomUUID().toString() + originalFilename.substring(originalFilename.lastIndexOf(\u0026#34;.\u0026#34;)); //ファイルをOSSにアップロード OSS ossClient = new OSSClientBuilder().build(aliOSSProperties.getEndpoint(), aliOSSProperties.getAccessKeyId(), aliOSSProperties.getAccessKeySecret()); ossClient.putObject(aliOSSProperties.getBucketName(), fileName, inputStream); //ファイルアクセスパス String url =aliOSSProperties.getEndpoint().split(\u0026#34;//\u0026#34;)[0] + \u0026#34;//\u0026#34; + aliOSSProperties.getBucketName() + \u0026#34;.\u0026#34; + aliOSSProperties.getEndpoint().split(\u0026#34;//\u0026#34;)[1] + \u0026#34;/\u0026#34; + fileName; // ossClientをクローズ ossClient.shutdown(); return url;// OSSにアップロードされたパスを返す } } 自動設定ファイルMETA-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.importsを新規作成するよ。\n1 com.aliyun.oss.AliOSSAutoConfiguration 使い方 依存関係の組み込み\n1 2 3 4 5 6 \u0026lt;!-- Alibaba Cloud OSSスターター依存を組み込む --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.aliyun.oss\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;aliyun-oss-spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 上記の例のAlibaba Cloud OSS関連設定は、設定ファイルから読み込む必要があるんだ。\n1 2 3 4 5 6 7 # Alibaba Cloud OSSパラメータ設定 aliyun: oss: endpoint: your_oss_region accessKeyId: your_key_id accessKeySecret: your_key_secret bucketName: your_bucker_name テスト\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 @RestController public class UploadController { @Autowired private AliOSSUtils aliOSSUtils; @PostMapping(\u0026#34;/upload\u0026#34;) public String upload(MultipartFile image) throws Exception { //ファイルをAlibaba Cloud OSSにアップロード String url = aliOSSUtils.upload(image); return url; } } ","date":"2025-01-23T15:06:36+09:00","permalink":"https://blog.yexca.net/ja/archives/223/","title":"Springの自動設定とスターター依存"},{"content":" 📢 この記事は gemini-2.5-flash によって翻訳されました トランザクション トランザクションとは、一連の操作の集まりだよ。これらは分割できないひとつの作業単位で、すべての操作が同時に成功するか、同時に失敗するかのどちらかだね。\n操作はこんな感じ：\nトランザクション開始 (一連の操作が始まる前に、トランザクションを始めること)：start transaction / begin トランザクションコミット (この一連の操作がすべて成功したら、トランザクションを確定すること)：commit トランザクションロールバック (途中で何か異常が起きたら、トランザクションを取り消すこと)：rollback 部署を削除した後に、その部署の従業員も続けて削除するケースを考えてみよう。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @Service public class DeptServiceImpl implements DeptService{ @Autowired private DeptMapper deptMapper; @Autowired private EmpMapper empMapper; @Override public void delete(Integer id）{ //1．削除部門 deptMapper.delete(id); // 假如这里出现错误，只删除了部门，没删除员工 //2.根据部门id，删除部门下的员工信息 empMapper.deleteByDetId(id); } } 上のようにすると、部署がない従業員が残っちゃって、データが不整合になるんだ。\nSpringのトランザクション管理 アノテーションは@Transactionalだよ。Service層のメソッド、クラス、インターフェースに付けるんだ。\n役割：このメソッドのトランザクション管理をSpringに任せるんだ。メソッドの実行前にトランザクションが開始されて、成功すればコミット、異常が起きたらロールバックされるよ。\n上記のメソッドだとこうなるね。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @Service public class DeptServiceImpl implements DeptService{ @Autowired private DeptMapper deptMapper; @Autowired private EmpMapper empMapper; @Transactional // Springにトランザクション管理を任せる @Override public void delete(Integer id）{ //1．削除部門 deptMapper.delete(id); //2.根据部门id，删除部门下的员工信息 empMapper.deleteByDetId(id); } } あと、トランザクション管理ログも有効にできるよ。\n1 2 3 4 # Springトランザクション管理ログ logging: level: org.springframework.jdbc.support.JdbcTransactionManager: debug トランザクション属性 - ロールバック デフォルトだと、実行時例外 (RuntimeException) が発生した場合にだけロールバックされるんだ。rollbackFor属性を使えば、どんな例外タイプでトランザクションをロールバックさせるかを制御できるよ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @Service public class DeptServiceImpl implements DeptService{ @Autowired private DeptMapper deptMapper; @Autowired private EmpMapper empMapper; // すべての例外でロールバック @Transactional(rollbackFor = Exception.class) @Override public void delete(Integer id）{ //1．削除部門 deptMapper.delete(id); //2.根据部门id，删除部门下的员工信息 empMapper.deleteByDetId(id); } } トランザクション属性 - 伝播動作 トランザクション伝播動作っていうのは、あるトランザクションメソッドが別のトランザクションメソッドから呼ばれたときに、その呼ばれたメソッドがどうトランザクションを処理すべきか、ってことなんだ。\n1 2 3 4 5 6 7 8 9 10 11 @Transactional public void a(){ // code userServices.b(); // code } @Transactional public void b(){ // code } 上記でaがbを呼んでるけど、bはaのトランザクションに参加すべきか、それとも自分だけで新しいトランザクションを始めるべきか、どうするんだろうね。\nそれはpropagation属性で制御できるんだ。\n属性値 説明 REQUIRED (デフォルト値) トランザクションが必要。あれば参加し、なければ新しく作る。 REQUIRES_NEW トランザクションが必要。あろうとなかろうと、常に新しいトランザクションを作る。 SUPPORTS トランザクションをサポート。あれば参加し、なければトランザクションなしの状態で実行する。 NOT_SUPPORTS トランザクションをサポートしない。トランザクションがあれば一時停止し、トランザクションなしの状態で実行する。 MANDATORY トランザクションが必須。なければ例外をスローする。 NEVER トランザクションがないことが必須。あれば例外をスローする。 使用例を見てみよう。\n1 2 3 4 5 6 7 8 9 10 11 @Transactional public void a(){ // code userServices.b(); // code } @Transactional(propagation = Propagation.REQUIRES_NEW) public void b(){ // code } ","date":"2025-01-22T13:30:38+09:00","permalink":"https://blog.yexca.net/ja/archives/222/","title":"Springのトランザクション管理"},{"content":" 📢 この記事は gemini-2.5-flash によって翻訳されました Aspect Oriented Programming（アスペクト指向プログラミング）は、特定メソッド向けのプログラミングだよ。\n動的プロキシは、アスペクト指向プログラミングの最も主流な実装だね。そしてSpring AOPは、Springフレームワークの高度な技術なんだ。主に、Beanオブジェクトを管理する過程で、基盤となる動的プロキシ機構を通じて、特定のメソッドに対してプログラミングを行うことを目的としているよ。\nメソッド実行時間の統計 依存関係をインポートするよ。\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-aop\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; AOPプログラムを書いて、特定のメソッドに対してビジネス要件に応じてプログラミングしよう。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Slf4j @Component @Aspect // AOPクラス public class TimeAspect { // ポイントカット式 @Around(\u0026#34;execution(* net.yexca.service.*.*(..))\u0026#34;) public Object recordTime(ProceedingJoinPoint proceedingJoinPoint) throws Throwable { long begin = System.currentTimeMillis(); // 元のメソッドを呼び出す Object object = proceedingJoinPoint.proceed(); long end = System.currentTimeMillis(); log.info(proceedingJoinPoint.getSignature() + \u0026#34;メソッド実行時間：{}ms\u0026#34;, end-begin); return object; } } AOPの応用シナリオとしては、操作ログの記録、権限制御、トランザクション管理なんかがあるよ。\nコアコンセプト ジョインポイント：JoinPoint、AOPで制御できるメソッドのこと（メソッド実行時の関連情報が暗に含まれる）。\nアドバイス：Advice、繰り返されるロジック、つまり共通機能を指すよ（最終的には一つのメソッドとして現れる）。\nポイントカット：PointCut、ジョインポイントをマッチングさせる条件のこと。アドバイスは、このポイントカットのメソッドが実行されるときにだけ適用されるよ。\nアスペクト：Aspect、アドバイスとポイントカットの対応関係を記述したもの（アドバイス＋ポイントカット）。\nターゲットオブジェクト：Target、アドバイスが適用されるオブジェクトのこと。\n上の例で言うと、書かれてないServiceの全メソッドがジョインポイントで、ポイントカット式で選択されたメソッドがポイントカットだね。AOPクラスのrecordTimeメソッドがアドバイスで、@Aroundアノテーションとアドバイスが一緒になってアスペクトになるんだ。そしてTimeAspectクラスはアスペクトクラスと呼ばれるよ。\nアドバイス アドバイスの種類 @Around：アラウンドアドバイス、このアノテーションが付いたアドバイスメソッドは、ターゲットメソッドの前と後の両方で実行されるよ。\n@Before：ビフォーアドバイス、このアノテーションが付いたアドバイスメソッドは、ターゲットメソッドの前に実行されるんだ。\n@After：アフターアドバイス、このアノテーションが付いたアドバイスメソッドは、ターゲットメソッドの後に実行されるよ。例外があってもなくても実行されるんだ。\n@AfterReturning：アフターリターニングアドバイス、このアノテーションが付いたアドバイスメソッドは、ターゲットメソッドの後に実行されるよ。例外がある場合は実行されないんだ。\n@AfterThrowing：アフタースローイングアドバイス、このアノテーションが付いたアドバイスメソッドは、ターゲットメソッドで例外が発生した後に実行されるよ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 @Component @Aspect public class MyAspect { @Before(\u0026#34;execution(* net.yexca.service.impl.*(..))\u0026#34;) public void before(){ System.out.println(\u0026#34;Before\u0026#34;); } @Around(\u0026#34;execution(* net.yexca.service.impl.*(..))\u0026#34;) public Object around(ProceedingJoinPoint proceedingJoinPoint) throws Throwable { System.out.println(\u0026#34;Around before\u0026#34;); Object result = proceedingJoinPoint.proceed(); System.out.println(\u0026#34;Around after\u0026#34;); return result; } @After(\u0026#34;execution(* net.yexca.service.impl.*(..))\u0026#34;) public void after(){ System.out.println(\u0026#34;After\u0026#34;); } @AfterReturning(\u0026#34;execution(* net.yexca.service.impl.*(..))\u0026#34;) public void afterRetruning(){ System.out.println(\u0026#34;AfterReturning\u0026#34;); } @AfterThrowing(\u0026#34;execution(* net.yexca.service.impl.*(..))\u0026#34;) public void afterThrowing(){ System.out.println(\u0026#34;AfterThrowing\u0026#34;); } } @Aroundアラウンドアドバイスは、元のメソッドを実行させるために自分でProceedingJoinPoint.proceed()を呼ばなきゃいけないんだ。他のアドバイスはターゲットメソッドの実行を考慮する必要はないよ。\n@Aroundアラウンドアドバイスメソッドの戻り値は、元のメソッドの戻り値を受け取るためにObjectとして指定する必要があるんだ。\n上記の5つのアノテーションのポイントカット式は全部同じだから、以下のように抽出できるよ。\n1 2 3 4 5 6 7 8 9 10 public class MyAspect { @Pointcut(\u0026#34;execution(* net.yexca.service.impl.*(..))\u0026#34;) public void pt(){} @Before(\u0026#34;pt()\u0026#34;) public void before(){ System.out.println(\u0026#34;Before\u0026#34;); } } pt()メソッドがpublicアクセス修飾子を持っていれば、他のクラスから参照できるよ。\nアドバイスの実行順序 複数のアスペクトのポイントカットがターゲットメソッドにマッチした場合、ターゲットメソッドが実行されるとき、複数のアドバイスメソッドが全部実行されるよ。\n1 2 3 4 5 6 net: yexca: aop: - MyAspect1 - MyAspect2 - MyAspect3 3つのAOPクラスが全部同じメソッドを選んだとしよう。異なるアスペクトクラスの中では、デフォルトでアスペクトクラスの名前のアルファベット順に並ぶんだ。\nターゲットメソッドの前のBeforeアドバイス：アルファベット順で早い方が先に実行される。 ターゲットメソッドの後のAfterアドバイス：アルファベット順で遅い方が先に実行される。 3つのAOPクラスが全部@Beforeと@Afterを持っていると仮定すると、実行順序はこうなるよ。\n1 2 3 4 5 6 MyAspect1 before MyAspect2 before MyAspect3 before MyAspect3 after MyAspect2 after MyAspect1 after @Order(num)アノテーションをアスペクトクラスに付けて順序を制御できるよ。numが小さいほど先に実行されて、@Beforeと@Afterの実行は上と同じだね。\nポイントカット式 ポイントカットメソッドを記述する式で、主にプロジェクトのどのメソッドにアドバイスを追加するかを決めるために使うんだ。\nよくある形式は、メソッドのシグネチャに基づいてマッチングするexecution(...)と、アノテーションに基づいてマッチングするannotationだよ。\nexecution 主にメソッドの戻り値、パッケージ名、クラス名、メソッド名、メソッド引数などの情報に基づいてマッチングさせるんだ。構文はこれだよ。\n1 execution(アクセス修飾子 戻り値 パッケージ名.クラス名.メソッド名(メソッド引数) throws 例外) その中で、アクセス修飾子、パッケージ名.クラス名、throws例外は省略できるけど、パッケージ名.クラス名は省略しない方がいいよ。\nワイルドカードを使ってポイントカットを記述することもできるんだ。\n*：単一の独立した任意の記号で、任意の戻り値、パッケージ名、クラス名、メソッド名、任意の型の1つの引数をマッチングさせることができるし、パッケージ、クラス、メソッド名の一部をマッチングさせることもできるよ。 1 execution(* com.*.service.*.update*(*)) ..：複数の連続した任意の記号で、任意の階層のパッケージ、または任意の型、任意の数の引数をマッチングさせることができるよ。 1 execution(* com.yexca..service.*(..)) \u0026amp;\u0026amp;、||、!を使って、もっと複雑なポイントカット式を組み合わせることもできるよ。\n書き方のヒント\n全てのビジネスメソッド名は、名前を付けるときにできるだけ規範的にすると、ポイントカット式が素早くマッチングできて便利だよ。 ポイントカットメソッドは通常、実装クラスではなくインターフェースに基づいて記述すると、拡張性が高まるんだ。 ビジネス要件を満たす前提で、ポイントカットのマッチング範囲はできるだけ狭くする方がいいよ。 @annotation @annotationポイントカット式は、特定の注解でマークされたメソッドをマッチングさせるために使うんだ。使うには、まずカスタムアノテーションを定義する必要があるよ。\n1 2 3 4 @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.METHOD) public @interface MyLog { } それから、メソッドにそのアノテーションを追加して、AOPクラスのメソッド上で使うんだ。\n1 @Before(\u0026#34;@annotation(net.yexca.aop.MyLog)\u0026#34;) ジョインポイント Springでは、JoinPointを使ってジョインポイントが抽象化されてるんだ。これを使うと、メソッド実行時の関連情報を取得できるよ。\n@Aroundアドバイスの場合、ジョインポイント情報の取得はProceedingJoinPointしか使えないんだ。 他の4つのアドバイスの場合、ジョインポイント情報の取得はJoinPointしか使えないよ。これはProceedingJoinPointの親クラスだね。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public Object recordTime(ProceedingJoinPoint proceedingJoinPoint) throws Throwable { // ターゲットオブジェクトのクラス名を取得する String className = proceedingJoinPoint.getTarget().getClass().getName(); // ターゲットメソッドのメソッド名を取得する String methodNAme = proceedingJoinPoint.getSignature().getName(); // ターゲットメソッド実行時に渡された引数を取得する Object[] args = proceedingJoinPoint.getArgs(); // 元のメソッドを呼び出す Object object = proceedingJoinPoint.proceed(); return object; } ","date":"2025-01-21T16:05:57+09:00","permalink":"https://blog.yexca.net/ja/archives/221/","title":"Spring AOP（アスペクト指向プログラミング）"},{"content":" 音に感じてシリーズ 曲 翻訳 リンク 僕が死のうと思ったのは 略 https://blog.yexca.net/ja/archives/214 あくあ色ぱれっと 略 https://blog.yexca.net/ja/archives/219 恋の押し売り 略 この記事 17さいのうた 略 https://blog.yexca.net/ja/archives/224 drop 恋に落ちた https://blog.yexca.net/ja/archives/230 生きるを選んだ私へ 略 https://blog.yexca.net/ja/archives/239 rainy lady 雨女 https://blog.yexca.net/ja/archives/249 恋しくなったら手を叩こう 略 https://blog.yexca.net/ja/archives/250 まえがき 甘い曲だよねー\n2025年01月27日歌った、めっちゃ可愛かった！！！\n動画 歌詞 ハートマーク作って\n届け届け届け\nきっと恋の押し売り\n好きで好きでごめん\n出会っちゃった！\nときめいちゃった？ ときめく\n私だけ？ドキドキしてるの\nちゃんと気にかけて\n私だけ！甘やかして\n(Ah)　君と話す理由欲しくて探している\n(なんで？)　強がっていても恋に負けちゃうんだね\nハートマーク作って\n届け届け届け\nきっと恋の押し売り\n好きで好きでごめん\nハートのレスください\n早く早く早くー！\nこれは恋の押し売り\n返品なんてダメよ\n取られたくないんだよ…\n誰よりも可愛くなりたい\n完全勝利して\n私だけって言わせてやる！\n(Ah)　君の胸を狙う私の恋の銃口\n(なんで？)　震えちゃうんだろう\nいつか撃ち抜けるまで 撃ち抜く: うちぬく\nせーっの！BANG\n期待させてよ\nもっともっともっと\n私浮ついちゃって 浮つく: うわつく\nバカだバカだごめん\nハートは忙しくて\nあっちこっちどっちー？\n今はまだまだプロローグ\n押して押して押すの\n私、君に出会えて変わったの！\nそりゃあ悩んじゃう事もあるけど…\nもっともっと可愛くなりたいって思うし\n何より君に好きって言ってもらいたい！\n笑顔の私(可愛い)\n泣いちゃう私(可愛い)\n怒った私(可愛い)\n恋する私…\n甘えさせてよ\nずっとずっとずっと\nきっと後悔させない\nお願い　好きになって\nハートマーク作って\n届け届け届け\nきっと恋の押し売り\n好きで好きでごめん\nハートのレスください\n早く早く早くー！\nこれは恋の押し売り\n返品なんてダメよ\n","date":"2025-01-20T16:24:43+09:00","permalink":"https://blog.yexca.net/ja/archives/220/","title":"音に感じて - 《恋の押し売り》"},{"content":" 音に感じてシリーズ 曲 翻訳 リンク 僕が死のうと思ったのは 略 https://blog.yexca.net/ja/archives/214 あくあ色ぱれっと 略 この記事 恋の押し売り 略 https://blog.yexca.net/ja/archives/220 17さいのうた 略 https://blog.yexca.net/ja/archives/224 drop 恋に落ちた https://blog.yexca.net/ja/archives/230 生きるを選んだ私へ 略 https://blog.yexca.net/ja/archives/239 rainy lady 雨女 https://blog.yexca.net/ja/archives/249 恋しくなったら手を叩こう 略 https://blog.yexca.net/ja/archives/250 まえがき また歌詞だけ書こう、次回何か日本語で感想を書くほうがいいかな。\n2025年01月27日、この曲を歌った、その時湊あくあが歌った 誇り高きアイドル を思い出した、とっても楽しかった。私もあくあ色に染まられたかもXD\n動画 歌詞 何をしても不器用で　何かとミスしてばっか\nダメダメな私だって\nできる事があるの\n凹んで悲しくたって　笑顔にしてあげるんだ\nここにいるから　早く　私を見つけてね\nLove You Love You, I love you\nLove You Love You, Ah,I love you so much\nLove You Love You, I love you\nLove You Love You\n（あぁ　愛してもっと）\nいつでも隣にいるし、いつでも一緒に笑える\n私をたくさん知って　たくさん好きって言って\nワガママで朝も苦手　ドジだし　ダメダメだけど\nそれでも私の事を　見ててね\n描く夢の未来へ続く\n道をキミと歩けますように\nねぇもっと！好きになってもらいたいの！\n頭の中は君ばっか！\nってゆーかそっぽなんて向いてないで！\nあぁもう！ヤキモキしちゃうわ　Ah\nずっとずっと好きがいいの\n心の奥もトキメイちゃうくらい\nこっち向いててよね　ダーリン？\nあぁもう離さないから、絶対に！\nLove You Love You, I love you\nLove You Love You\n（あぁ　愛してもっと）\nキミがいるから私　いつでも頑張れるんだ\n落ち込んで悲しくたって　キミがいるから\u0026hellip;\nキミがいるから　歩いてこれた\nキミがいなくちゃ　前も見れない\n嫌な事とか辛い事とかあったって\nキミの力でここまで笑ってこれたんだ\n今度はもっと私がぐっとひっぱって　連れて行くんだ\nキミがいるから私がいるの\nこんな私を　愛してくれる？\nねぇもっと　ねぇもっと\nまだもっと　受け止めてよね！ねぇいい？\nさぁ声を上げて！\nねぇもっと　ねぇもっと\n好きになってもらいたいの\nいつでも　そう私ばっか みたいにそっぽなんて向かせないわ\nね、ほら夢中にしちゃうわ　Ah\nずっとずっと好きがいいの！心も体も染まっちゃうくらいに\nこっち向いててよねダーリン?\nあぁもう離さないから、絶対に　絶体ね　絶体よ　約束だよ\n（あぁ 愛してもっと）\n","date":"2025-01-20T00:16:48+09:00","permalink":"https://blog.yexca.net/ja/archives/219/","title":"音に感じて - 《あくあ色ぱれっと》"},{"content":" 📢 この記事は gemini-2.5-flash によって翻訳されました セッション技術 セッション：ユーザーがブラウザを開いてWebサーバーのリソースにアクセスすると、セッションが確立され、どちらかが接続を切るまで継続するよ。1つのセッションには、複数のリクエストとレスポンスが含まれることがあるんだ。\nセッショントラッキング：ブラウザの状態を維持する方法だよ。サーバーは、複数のリクエストが同じブラウザから来ているかどうかを識別して、同じセッション内の複数のリクエスト間でデータを共有する必要があるんだ。\nセッショントラッキングの仕組み：\nクライアント側セッショントラッキング技術：Cookie サーバー側セッショントラッキング技術：Session トークン技術 Cookie CookieはHTTPプロトコルがサポートしている技術で、ブラウザが初めてアクセスした時に、サーバー側がリクエストヘッダーにSet-Cookie: your_cookieを設定するんだ。ブラウザは自動的にCookieをローカルに保存して、次回のアクセス時には自動でリクエストヘッダーにCookie: your_cookieを追加してくれるよ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 @RestController public class SessionController { // 设置Cookie @GetMapping(\u0026#34;/c1\u0026#34;) public Result cookie1(HttpServletResponse response){ response.addCookie(new Cookie(\u0026#34;login_name\u0026#34;, \u0026#34;yexca\u0026#34;)); return Result.success(); } // 获取Cookie @GetMapping(\u0026#34;/c2\u0026#34;) public Result cookie2(HttpServletRequest request){ Cookie[] cookies = request.getCookies(); for (Cookie c : cookies){ if(c.getName().equals(\u0026#34;login_name\u0026#34;)){ System.out.println(\u0026#34;login_name:\u0026#34;+c.getValue()); } } return Result.success(); } } でも、モバイル端末だとCookieは使えないし、Cookieはクロスドメインもできないんだ。\n同じドメイン：同じプロトコル、IP/ドメイン、ポート\nSession Cookieをベースに実装されていて、ブラウザが初めてリクエストした時にSessionが生成されるんだ。そして、レスポンスヘッダーでSessionのID Set-Cookie: JSESSIONID=session_idが返されて、ブラウザは次回のリクエスト時に自動でそのIDを付けてくれるよ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 @RestController public class SessionController { // 往HttpSession中存储值 @GetMapping(\u0026#34;/s1\u0026#34;) public Result session1(HttpSession session){ log.info(\u0026#34;HttpSession_set:{}\u0026#34;, session.hashCode()); session.setAttribute(\u0026#34;login_user\u0026#34;,\u0026#34;yexca\u0026#34;); return Result.success(); } // 从HttpSession中获取值 @GetMapping(\u0026#34;/s2\u0026#34;) public Result session2(HttpServletRequest request){ HttpSession session = request.getSession(); log.info(\u0026#34;HttpSession_get:{}\u0026#34;, session.hashCode()); Object loginUser = session.getAttribute(\u0026#34;login_user\u0026#34;); log.info(\u0026#34;loginUser:{}\u0026#34;, loginUser); return Result.success(); } } Sessionの問題は、もしサーバー側がロードバランシングを使っていて、つまり複数のサーバーがある場合、最初のレスポンスがサーバー1からで、2回目のレスポンスがサーバー2からだと、サーバー2にはSessionがないから使えないってことだね。\nJWT トークン JWTはJSON Web Tokenの略で、公式サイトは https://jwt.io/ だよ。通信する両者間でJSONデータ形式で安全に情報を転送するための、シンプルで自己完結型のフォーマットを定義しているんだ。デジタル署名があるから、これらの情報は信頼できるんだよ。\n構成：\n第一部：Header（ヘッダー）。トークンタイプ、署名アルゴリズムなんかを記録してるよ。 第二部：Payload（ペイロード）。カスタム情報やデフォルト情報なんかを記録してるんだ。 第三部：Signature（署名）。トークンの改ざんを防いで、安全性を確保するものだよ。Header、Payload、指定された秘密鍵を使って、指定された署名アルゴリズムで計算されるんだ。 依存関係の追加\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.jsonwebtoken\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jjwt\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.9.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 生成と解析\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class WebApplicationTests { // JWT生成 @Test public void jwtGenTest(){ Map\u0026lt;String,Object\u0026gt; claims = new HashMap\u0026lt;\u0026gt;(); claims.put(\u0026#34;id\u0026#34;, \u0026#34;233\u0026#34;); claims.put(\u0026#34;user\u0026#34;, \u0026#34;yexca\u0026#34;); String jwt = Jwts.builder() .signWith(SignatureAlgorithm.HS256, \u0026#34;yexca\u0026#34;) // 签名算法 .setClaims(claims) //自定义内容(载荷) .setExpiration(new Date(System.currentTimeMillis() + 3600 * 1000)) // 有效期为1h .compact(); System.out.println(jwt); } // 出力 // eyJhbGciOiJIUzI1NiJ9.eyJpZCI6IjIzMyIsImV4cCI6MTcwMjc5NzA4OCwidXNlciI6InlleGNhIn0.BqZDxEddGN4g4GyyfvkOtKYv7DVlIF6cWY9PGW2RbUU // JWT解析 @Test public void jwtParseTest(){ Claims claims = Jwts.parser() .setSigningKey(\u0026#34;yexca\u0026#34;) // 密钥 .parseClaimsJws(\u0026#34;eyJhbGciOiJIUzI1NiJ9.eyJpZCI6IjIzMyIsImV4cCI6MTcwMjc5NzA4OCwidXNlciI6InlleGNhIn0.BqZDxEddGN4g4GyyfvkOtKYv7DVlIF6cWY9PGW2RbUU\u0026#34;) .getBody(); // 获得第二部分 System.out.println(claims); } // 出力 // {id=233, exp=1702797088, user=yexca} } ログイン認証 フィルター (Filter) Filterは初期のJavaWeb三大コンポーネント（Servlet, Filter, Listener）の一つだよ。フィルターはリソースへのリクエストを途中で受け止めて、ログイン認証とか、統一エンコード処理、センシティブな文字の処理みたいな特殊な機能を実現できるんだ。\nクイックスタート Filterクラスの作成\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 @WebFilter(urlPatterns = \u0026#34;/*\u0026#34;) // 拦截路径 public class DemoFilter implements Filter { @Override public void init(FilterConfig filterConfig) throws ServletException { // Filter.super.init(filterConfig); System.out.println(\u0026#34;Filter 初期化\u0026#34;); } @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { System.out.println(\u0026#34;Filter 傍受\u0026#34;); // 放行 filterChain.doFilter(servletRequest, servletResponse); } @Override public void destroy() { // Filter.super.destroy(); System.out.println(\u0026#34;Filter 破棄\u0026#34;); } } Applicationにアノテーションを追加\n1 2 @ServletComponentScan // 开启了对servlet组件的支持 @SpringBootApplication 傍受パス 必要に応じて調整できるよ。以下は例ね。\n傍受タイプ urlPatterns 意味 特定パスの傍受 /login /loginへのアクセスのみ傍受される ディレクトリ傍受 /emps/* /emps配下のすべてのリソースが傍受され、/emps自体も傍受される 全て傍受 /* すべてのリソースへのアクセスが傍受される 単一フィルターの実行ロジック ブラウザがリクエストを送信 -\u0026gt; リクエストが傍受される -\u0026gt; 許可前ロジックを実行 -\u0026gt; 許可 -\u0026gt; 許可後ロジックを実行 -\u0026gt; ブラウザがレスポンスを受信\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 @WebFilter(urlPatterns = \u0026#34;/*\u0026#34;) // 拦截路径 public class DemoFilter implements Filter { @Override public void init(FilterConfig filterConfig) throws ServletException { // Filter.super.init(filterConfig); System.out.println(\u0026#34;Filter 初期化\u0026#34;); } @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { System.out.println(\u0026#34;Filter 傍受、許可前ロジック\u0026#34;); // 放行 filterChain.doFilter(servletRequest, servletResponse); System.out.println(\u0026#34;Filter 傍受、許可後ロジック\u0026#34;); } @Override public void destroy() { // Filter.super.destroy(); System.out.println(\u0026#34;Filter 破棄\u0026#34;); } } フィルターチェーン 1つのWebアプリケーションで、複数のフィルターを設定できるんだけど、この複数のフィルターが集まってフィルターチェーンを形成するんだ。\n順序：アノテーションで設定されたFilterの優先順位は、フィルタークラス名の自然順序で決まるよ。\nロジック：ブラウザがリクエストを送信 -\u0026gt; リクエストがAに傍受される -\u0026gt; Aの許可前ロジックを実行 -\u0026gt; Aが許可 -\u0026gt; リクエストがBに傍受される -\u0026gt; Bの許可前ロジックを実行 -\u0026gt; Bが許可 -\u0026gt; Bの許可後ロジックを実行 -\u0026gt; Aの許可後ロジックを実行 -\u0026gt; ブラウザがレスポンスを受信\nログイン認証 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 @Slf4j @WebFilter(urlPatterns = \u0026#34;/*\u0026#34;) public class LoginCheckFilter implements Filter { @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { HttpServletRequest request = (HttpServletRequest) servletRequest; HttpServletResponse response = (HttpServletResponse) servletResponse; // 获取请求url String requestURI = request.getRequestURI(); log.info(\u0026#34;リクエストURL：{}\u0026#34;,requestURI); // 判断是否有login if(requestURI.contains(\u0026#34;login\u0026#34;)){ log.info(\u0026#34;ログイン操作なので許可\u0026#34;); filterChain.doFilter(servletRequest, servletResponse); return; // 因为登录操作不需要以下逻辑 } // 非登录，获取令牌 String jwt = request.getHeader(\u0026#34;token\u0026#34;); // 判断令牌是否有效 if(!StringUtils.hasLength(jwt)){ log.info(\u0026#34;リクエストヘッダーのトークンが空\u0026#34;); // 将对象转换为JSON Result error = Result.error(\u0026#34;NOT_LOGIN\u0026#34;); String notLogin = JSONObject.toJSONString(error); response.getWriter().write(notLogin); return; } // 校验令牌 try { JwtUtils.parseJWT(jwt); }catch (Exception e){ e.printStackTrace(); log.info(\u0026#34;トークンの解析に失敗\u0026#34;); // 将对象转换为JSON Result error = Result.error(\u0026#34;NOT_LOGIN\u0026#34;); String notLogin = JSONObject.toJSONString(error); response.getWriter().write(notLogin); return; } // 放行 log.info(\u0026#34;トークンが有効なので許可\u0026#34;); filterChain.doFilter(servletRequest,servletResponse); } } インターセプター (Interceptor) クイックスタート インターセプターの作成\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 @Component public class LoginCheckInterceptor implements HandlerInterceptor { @Override // 目标方法运行前运行，返回ture放行，false不放行 public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { // return HandlerInterceptor.super.preHandle(request, response, handler); System.out.println(\u0026#34;preHandle\u0026#34;); return true; } @Override // 目标方法运行后运行 public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { // HandlerInterceptor.super.postHandle(request, response, handler, modelAndView); System.out.println(\u0026#34;postHandle\u0026#34;); } @Override // 视图渲染完成后运行，最后运行 public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { // HandlerInterceptor.super.afterCompletion(request, response, handler, ex); System.out.println(\u0026#34;afterCompletion\u0026#34;); } } 設定の作成\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 @Configuration // 配置类 public class WebConfig implements WebMvcConfigurer { @Autowired private LoginCheckInterceptor loginCheckInterceptor; @Override public void addInterceptors(InterceptorRegistry registry) { // WebMvcConfigurer.super.addInterceptors(registry); registry.addInterceptor(loginCheckInterceptor).addPathPatterns(\u0026#34;/**\u0026#34;).excludePathPatterns(\u0026#34;/login\u0026#34;); } } 傍受パス パス 意味 例 /* 1階層パス /emps, /login は /emps/1 にはマッチしない /** 任意の階層パス /emps, /emps/1, /emps/1/2 /emps/* /emps配下の1階層パス /emps/1 は /emps, /emps/1/2 にはマッチしない /emps/** /emps配下の任意の階層パス /emps, /emps/1, /emps/1/2 傍受フロー もしフィルターとインターセプターが同時に存在する場合\nブラウザアクセス -\u0026gt; filter 許可前ロジック -\u0026gt; filter 許可 -\u0026gt; DispatcherServlet -\u0026gt; Interceptor preHandle -\u0026gt; Controller -\u0026gt; postHandle -\u0026gt; afterCompletion -\u0026gt; DispatcherServlet -\u0026gt; filter 許可後ロジック -\u0026gt; ブラウザにレスポンス\nFilterはすべてのリクエストを傍受するけど、InterceptorはSpring環境内のリソースだけを傍受するよ。\nログイン認証 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 @Slf4j @Component public class LoginCheckInterceptor implements HandlerInterceptor { @Override // 目标方法运行前运行，返回ture放行，false不放行 public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { // return HandlerInterceptor.super.preHandle(request, response, handler); System.out.println(\u0026#34;preHandle\u0026#34;); // 获取请求url String requestURI = request.getRequestURI(); log.info(\u0026#34;リクエストURL：{}\u0026#34;,requestURI); // 判断是否有login if(requestURI.contains(\u0026#34;login\u0026#34;)){ log.info(\u0026#34;ログイン操作なので許可\u0026#34;); return true; } // 非登录，获取令牌 String jwt = request.getHeader(\u0026#34;token\u0026#34;); // 判断令牌是否有效 if(!StringUtils.hasLength(jwt)){ log.info(\u0026#34;リクエストヘッダーのトークンが空\u0026#34;); // 将对象转换为JSON Result error = Result.error(\u0026#34;NOT_LOGIN\u0026#34;); String notLogin = JSONObject.toJSONString(error); response.getWriter().write(notLogin); return false; } // 校验令牌 try { JwtUtils.parseJWT(jwt); }catch (Exception e){ e.printStackTrace(); log.info(\u0026#34;トークンの解析に失敗\u0026#34;); // 将对象转换为JSON Result error = Result.error(\u0026#34;NOT_LOGIN\u0026#34;); String notLogin = JSONObject.toJSONString(error); response.getWriter().write(notLogin); return false; } // 放行 log.info(\u0026#34;トークンが有効なので許可\u0026#34;); return true; } @Override // 目标方法运行后运行 public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { // HandlerInterceptor.super.postHandle(request, response, handler, modelAndView); System.out.println(\u0026#34;postHandle\u0026#34;); } @Override // 视图渲染完成后运行，最后运行 public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { // HandlerInterceptor.super.afterCompletion(request, response, handler, ex); System.out.println(\u0026#34;afterCompletion\u0026#34;); } } ","date":"2025-01-16T23:06:20+09:00","permalink":"https://blog.yexca.net/ja/archives/218/","title":"JWT ログイン認証"},{"content":" 📢 この記事は gemini-2.5-flash によって翻訳されました MQについて知るきっかけ 同期呼び出し マイクロサービス間のFeignを使った呼び出しは同期方式で、いくつか問題があるんだ。\n例えば、支払いサービスを開発するとして、注文サービスや倉庫サービスのコードを追加する必要があるよね。後でSMSサービスやポイントサービスを追加しようとしたら、その都度支払いコードを修正しなきゃいけない。これは オープン・クローズドの原則 に反するし、リクエストが返ってくるまで他のことができないからパフォーマンスの無駄にもなるよ。\n問題点は、結合度が高いこと、パフォーマンスが落ちること、リソースの無駄遣い、そしてカスケード障害（もしプロバイダに問題が起きると、それを呼び出す全てのサービスも巻き込まれて、ドミノ倒しのようにあっという間にマイクロサービス全体がダウンしちゃう）だね。\n非同期呼び出しの解決策 非同期呼び出しの一般的な実装は、イベント駆動型パターンだよ。\nユーザーの支払いリクエスト -\u0026gt; 支払いサービス -\u0026gt; Broker。その後、支払いサービスが完了して応答し、Brokerが注文サービス、倉庫サービス、SMSサービスに通知する仕組みだ。\n利点：サービスの疎結合化、パフォーマンス向上、スループットの向上、サービス間の強い依存関係がなくなり、障害分離が可能になる。あと、トラフィックのピークを緩和できるのもいいね。\n欠点：Brokerの信頼性、安全性、スループット能力に依存すること。アーキテクチャが複雑になるし、ビジネスフローが明確じゃないから追跡や管理が難しくなるよ。\nMQ (メッセージキュー) MessageQueue、メッセージキュー。文字通りメッセージを格納するキューのことで、イベント駆動型アーキテクチャにおけるBrokerの役割を果たすんだ。\nRabbitMQ ActiveMQ RocketMQ Kafka 企業/コミュニティ Rabbit Apache アリババ Apache 開発言語 Erlang Java Java Scala\u0026amp;Java プロトコルサポート AMQP，XMPP，SMTP，STOMP OpenWire,STOMP，REST,XMPP,AMQP 独自プロトコル 独自プロトコル 可用性 高い 普通 高い 高い 単一サーバーのスループット 普通 悪い 高い 非常に高い メッセージ遅延 マイクロ秒レベル ミリ秒レベル ミリ秒レベル ミリ秒以内 メッセージ信頼性 高い 普通 高い 普通 可用性を重視するなら：Kafka、RocketMQ、RabbitMQ\n信頼性を重視するなら：RabbitMQ、RocketMQ\nスループット能力を重視するなら：RocketMQ、Kafka\nメッセージの低遅延を重視するなら：RabbitMQ、Kafka\nRabbitMQのインストール 公式サイト を見ると色々なインストール方法があるけど、僕はDockerを使ってオンラインでプルするよ。\n1 docker pull rabbitmq:3-management 実行コマンド\n1 2 3 4 5 6 7 8 9 docker run \\ -e RABBITMQ_DEFAULT_USER=admin \\ -e RABBITMQ_DEFAULT_PASS=admin \\ --name mq \\ --hostname mq1 \\ -p 15672:15672 \\ -p 5672:5672 \\ -d \\ rabbitmq:3-management localhost:15672 にアクセスすれば管理画面が開くよ。RabbitMQのいくつかの概念を説明するね：\nchannel：MQを操作するためのツール exchange：交換機。メッセージをキューにルーティングするよ。 queue：キュー。メッセージを保存するところ。 virtualHost：仮想ホスト。キューや交換機などのリソースを論理的にグループ化したもの。 メッセージモデル 公式サイト には色々なデモが提供されていて、それぞれ異なるメッセージモデルに対応しているよ。\n基本メッセージキュー (BasicQueue)： \u0026ldquo;Hello World!\u0026rdquo; ワークメッセージキュー (WorkQueue)： Work Queues パブリッシュ/サブスクライブモデル Fanout Exchange：ブロードキャスト Publish/Subscribe Direct Exchange：ルーティング Routing Topic Exchange：トピック Topics ハローワールド Publisher -\u0026gt; Queue -\u0026gt; Consumer\npublisher：メッセージ発行者。メッセージをキューに送るよ。 queue：メッセージキュー。メッセージを受け取ってキャッシュする役割。 consumer：キューを購読して、キュー内のメッセージを処理するよ。 発行者\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 public class PublisherTest { @Test public void testSendMessage() throws IOException, TimeoutException { // 1.接続を確立 ConnectionFactory factory = new ConnectionFactory(); // 1.1.接続パラメータを設定 (ホスト名、ポート番号、vhost、ユーザー名、パスワード) factory.setHost(\u0026#34;localhost\u0026#34;); factory.setPort(5672); factory.setVirtualHost(\u0026#34;/\u0026#34;); factory.setUsername(\u0026#34;admin\u0026#34;); factory.setPassword(\u0026#34;admin\u0026#34;); // 1.2.接続を確立 Connection connection = factory.newConnection(); // 2.チャネルChannelを作成 Channel channel = connection.createChannel(); // 3.キューを作成 String queueName = \u0026#34;hello.queue\u0026#34;; channel.queueDeclare(queueName, false, false, false, null); // 4.メッセージを送信 String message = \u0026#34;hello, rabbitmq!\u0026#34;; channel.basicPublish(\u0026#34;\u0026#34;, queueName, null, message.getBytes()); System.out.println(\u0026#34;メッセージ送信成功：【\u0026#34; + message + \u0026#34;】\u0026#34;); // 5.チャネルと接続をクローズ channel.close(); connection.close(); } } 受信者\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 public class ConsumerTest { public static void main(String[] args) throws IOException, TimeoutException { // 1.接続を確立 ConnectionFactory factory = new ConnectionFactory(); // 1.1.接続パラメータを設定 (ホスト名、ポート番号、vhost、ユーザー名、パスワード) factory.setHost(\u0026#34;localhost\u0026#34;); factory.setPort(5672); factory.setVirtualHost(\u0026#34;/\u0026#34;); factory.setUsername(\u0026#34;admin\u0026#34;); factory.setPassword(\u0026#34;admin\u0026#34;); // 1.2.接続を確立 Connection connection = factory.newConnection(); // 2.チャネルChannelを作成 Channel channel = connection.createChannel(); // 3.キューを作成 String queueName = \u0026#34;hello.queue\u0026#34;; channel.queueDeclare(queueName, false, false, false, null); // 4.メッセージを購読 channel.basicConsume(queueName, true, new DefaultConsumer(channel){ @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException { // 5.メッセージを処理 String message = new String(body); System.out.println(\u0026#34;メッセージを受信しました：【\u0026#34; + message + \u0026#34;】\u0026#34;); } }); System.out.println(\u0026#34;メッセージの受信を待機中。。。。\u0026#34;); } } コンソール出力：\n1 2 メッセージの受信を待機中。。。。 メッセージを受信しました：【hello, rabbitmq!】 明らかにこの方法は少し手間がかかるよね。\nSpringAMQP SpringAMQP はRabbitMQを基盤にラップされたテンプレート集で、SpringBootを利用して自動構成も実現されているから、すごく便利に使えるんだ。\nAMQP Advanced Message Queuing Protocolのことで、アプリケーション間でビジネスメッセージをやり取りするためのオープンスタンダードだよ。このプロトコルは言語やプラットフォームに依存しないから、マイクロサービスにおける独立性の要求にもっと合致しているんだ。\nSpring AMQP Spring AMQPはAMQPプロトコルに基づいて定義されたAPI仕様で、メッセージを送受信するためのテンプレートを提供しているよ。spring-amqpが基本的な抽象化、spring-rabbitがその基盤となるデフォルト実装だね。\nこれはキューや交換機、そのバインディング関係を自動で宣言してくれるし、アノテーションベースのリスナーパターンで非同期にメッセージを受け取れるんだ。\nBasic Queue (シンプルなキューモデル) まずは親プロジェクトで依存関係を導入しよう。\n1 2 3 4 5 \u0026lt;!--AMQP依存関係、RabbitMQを含む--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-amqp\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; publisher (メッセージ送信) application.ymlを設定しよう。\n1 2 3 4 5 6 7 spring: rabbitmq: host: localhost # ホスト名 port: 5672 # ポート virtual-host: / # 仮想ホスト username: admin # ユーザー名 password: admin # パスワード RabbitTemplateを使ってメッセージ送信を実装するよ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @RunWith(SpringRunner.class) @SpringBootTest public class SpringamqpTest { @Autowired private RabbitTemplate rabbitTemplate; @Test public void testSimpleQueue(){ // キュー名 String queueName = \u0026#34;hello.queue\u0026#34;; // メッセージ String msg = \u0026#34;Hello Spring ampq\u0026#34;; // 送信 rabbitTemplate.convertAndSend(queueName,msg); } } consumer (メッセージ受信) application.ymlの設定は上記と同じだよ。\n1 2 3 4 5 6 7 spring: rabbitmq: host: localhost # ホスト名 port: 5672 # ポート virtual-host: / # 仮想ホスト username: admin # ユーザー名 password: admin # パスワード 新しいクラス SpringRabbitListener を作成するよ。\n1 2 3 4 5 6 7 @Component public class SpringRabbitListener { @RabbitListener(queues = \u0026#34;hello.queue\u0026#34;) public void listenSimpleQueue(String msg){ System.out.println(\u0026#34;受信したメッセージは：\u0026#34; + msg); } } WorkQueue (ワークメッセージキュー) TaskQueueとも呼ばれていて、タスクモデルだよ。メッセージ処理速度を上げて、キューにメッセージが溜まるのを防ぐことができるんだ。\npublisher -\u0026gt; queue -\u0026gt; consumer1 and consumer2 and \u0026hellip;\npublisher (メッセージ送信) 1秒間に50件のメッセージを送るメソッドを定義するね。\n1 2 3 4 5 6 7 8 9 10 11 12 public class SpringamqpTest { @Test public void testWorkQueue() throws InterruptedException { String queueName = \u0026#34;hello.queue\u0026#34;; String msg = \u0026#34;Hello Spring ampq...\u0026#34;; for (int i = 0; i \u0026lt; 50; i++) { rabbitTemplate.convertAndSend(queueName, msg + i); // 20ミリ秒スリープ、1秒間に50件のメッセージを送信 Thread.sleep(20); } } } consumer (メッセージ受信) 同じキューに2つのコンシューマーをバインドするよ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @Component public class SpringRabbitListener { @RabbitListener(queues = \u0026#34;hello.queue\u0026#34;) public void listenSimpleQueue1(String msg) throws InterruptedException { System.out.println(\u0026#34;1が受信したメッセージは：\u0026#34; + msg); // 1秒間に40件のメッセージを処理 Thread.sleep(25); } @RabbitListener(queues = \u0026#34;hello.queue\u0026#34;) public void listenSimpleQueue2(String msg) throws InterruptedException { // errで赤色メッセージを出力 System.err.println(\u0026#34;2が受信したメッセージは：\u0026#34; + msg); // 1秒間に5件のメッセージを処理 Thread.sleep(200); } } テスト まず受信者を起動して、それから送信者を起動してメッセージを送ってみよう。\n出力結果を見ると、2つの受信者がそれぞれ半分のメッセージを受け取っているね。つまり、メッセージは各コンシューマーに均等に分配されていて、コンシューマーの処理能力は考慮されていないんだ。これだと明らかに問題があるよね。\nprefetch application.ymlファイルを修正して、prefetchの値を設定するよ。これでプリフェッチするメッセージの上限（デフォルトは無限）を制御できるんだ。\n1 2 3 4 5 6 7 8 9 10 11 spring: rabbitmq: host: localhost # ホスト名 port: 5672 # ポート virtual-host: / # 仮想ホスト username: admin # ユーザー名 password: admin # パスワード listener: simple: # 毎回1つのメッセージしか取得できず、処理が完了してから次のメッセージを取得する prefetch: 1 もう一度テストしてみると、実行効率が上がっているのがわかるよ。\nパブリッシュ/サブスクライブモデル パブリッシュ/サブスクライブモデルは交換機（Exchange）が加わって、同じメッセージを全ての受信者に送ることができるんだ。\npublisher -\u0026gt; exchange -\u0026gt; queue1 and queue2 queue1 -\u0026gt; consumer1 and consumer2 queue2 -\u0026gt; consumer3\nよく使われるExchangeはこれらだよ。\nFanout：ブロードキャスト Direct：ルーティング Topic：トピック Exchangeはルーティングを担当するだけで、メッセージは保存しないよ。だから、ルーティングに失敗するとメッセージは失われちゃうんだ。\nFanout (扇出) ブロードキャスト Fanout Exchangeは受け取ったメッセージを、それにバインドされている全てのキューにブロードキャストするよ。\n受信者側で設定クラスを作って、キューとExchangeを宣言しよう。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 @Configuration public class FanoutConfig { /** * 交換機を宣言 * @return */ @Bean public FanoutExchange fanoutExchange(){ return new FanoutExchange(\u0026#34;hello.fanout\u0026#34;); } /** * 最初のキュー * @return */ @Bean public Queue fanoutQueue1(){ return new Queue(\u0026#34;fanout.queue1\u0026#34;); } /** * 最初のキューと交換機をバインド * @param fanoutQueue1 * @param fanoutExchange * @return */ @Bean public Binding bindingQueue1(Queue fanoutQueue1, FanoutExchange fanoutExchange){ return BindingBuilder.bind(fanoutQueue1).to(fanoutExchange); } /** * 2番目のキュー * @return */ @Bean public Queue fanoutQueue2(){ return new Queue(\u0026#34;fanout.queue2\u0026#34;); } /** * 2番目のキューと交換機をバインド * @param fanoutQueue2 * @param fanoutExchange * @return */ @Bean public Binding bindingQueue2(Queue fanoutQueue2, FanoutExchange fanoutExchange){ return BindingBuilder.bind(fanoutQueue2).to(fanoutExchange); } } メッセージ送信\n1 2 3 4 5 6 7 8 9 10 public class SpringamqpTest { @Test public void testFanoutExchange(){ // 交換機 String exchangeName = \u0026#34;hello.fanout\u0026#34;; // メッセージ String msg = \u0026#34;hello, everyone\u0026#34;; rabbitTemplate.convertAndSend(exchangeName,\u0026#34;\u0026#34;,msg); } } 真ん中が空になっている routingkey は、次の2つのモデルで使うよ。\nメッセージの受信\n1 2 3 4 5 6 7 8 9 10 11 @Component public class SpringRabbitListener { @RabbitListener(queues = \u0026#34;fanout.queue1\u0026#34;) public void listenFanoutQueue1(String msg){ System.out.println(\u0026#34;Fanout1がメッセージを受信：\u0026#34; + msg); } @RabbitListener(queues = \u0026#34;fanout.queue2\u0026#34;) public void listenFanoutQueue2(String msg){ System.out.println(\u0026#34;Fanout2がメッセージを受信：\u0026#34; + msg); } } Direct (ルーティング) Direct Exchangeは、受け取ったメッセージをルールに基づいて指定されたキューにルーティングするから、ルーティングモードって呼ばれるんだ。\nキューとExchangeのバインドには Routingkey を指定する必要があるよ。送信側もメッセージを送るときに Routingkey を指定しなきゃいけないんだ。キューの Routingkey とメッセージの Routingkey が完全に一致した場合だけ、メッセージが受信されるよ。\nここではアノテーションベースでキューとExchangeを宣言するから、設定クラスは不要だよ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 @Component public class SpringRabbitListener { @RabbitListener(bindings = @QueueBinding( value = @Queue(name = \u0026#34;direct.queue1\u0026#34;), // exchange = @Exchange(name = \u0026#34;hello.direct\u0026#34;, type = ExchangeTypes.DIRECT), // デフォルトでDirectタイプなので指定は不要 exchange = @Exchange(name = \u0026#34;hello.direct\u0026#34;), key = {\u0026#34;red\u0026#34;,\u0026#34;warma\u0026#34;} )) public void listenDirectQueue1(String msg){ System.out.println(\u0026#34;1がメッセージを受信：\u0026#34; + msg); } @RabbitListener(bindings = @QueueBinding( value = @Queue(name = \u0026#34;direct.queue2\u0026#34;), exchange = @Exchange(name = \u0026#34;hello.direct\u0026#34;), key = {\u0026#34;red\u0026#34;,\u0026#34;aqua\u0026#34;} )) public void listenDirectQueue2(String msg){ System.out.println(\u0026#34;2がメッセージを受信：\u0026#34; + msg); } } 送信者\n1 2 3 4 5 6 7 8 9 10 public class SpringamqpTest { @Test public void testDirectExchange(){ // 交換機 String exchangeName = \u0026#34;hello.direct\u0026#34;; // メッセージ String msg = \u0026#34;hello, aqua\u0026#34;; rabbitTemplate.convertAndSend(exchangeName,\u0026#34;aqua\u0026#34;,msg); } } 上の例だと受信者2しかメッセージを受け取れないけど、もしroutingkeyがredなら両方ともメッセージを受け取れるよ。\nTopic (トピック) Topic ExchangeはDirect Exchangeと似ているけど、違いはroutingKeyが複数の単語のリストで、．で区切られていることだね。\nキューとExchangeでBindingKeyを指定する時に、ワイルドカードが使えるよ。\n#：1つ以上の単語にマッチ *：1つの単語にのみマッチ 受信者\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @Component public class SpringRabbitListener { @RabbitListener(bindings = @QueueBinding( value = @Queue(\u0026#34;topic.queue1\u0026#34;), exchange = @Exchange(name = \u0026#34;hello.topic\u0026#34;, type = ExchangeTypes.TOPIC), key = \u0026#34;#.news\u0026#34; )) public void listenTopicQueue1(String msg){ System.out.println(\u0026#34;1がメッセージを受信：\u0026#34; + msg); } @RabbitListener(bindings = @QueueBinding( value = @Queue(\u0026#34;topic.queue2\u0026#34;), exchange = @Exchange(name = \u0026#34;hello.topic\u0026#34;, type = ExchangeTypes.TOPIC), key = \u0026#34;china.#\u0026#34; )) public void listenTopicQueue2(String msg){ System.out.println(\u0026#34;2がメッセージを受信：\u0026#34; + msg); } } メッセージ送信\n1 2 3 4 5 6 7 8 9 10 public class SpringamqpTest { @Test public void testTopicExchange(){ // 交換機 String exchangeName = \u0026#34;hello.topic\u0026#34;; // メッセージ String msg = \u0026#34;news for China\u0026#34;; rabbitTemplate.convertAndSend(exchangeName,\u0026#34;china.news\u0026#34;,msg); } } 上の例だと1と2の両方が受け取れるよ。\n1 2 3 4 5 6 7 8 9 10 public class SpringamqpTest { @Test public void testTopicExchange(){ // 交換機 String exchangeName = \u0026#34;hello.topic\u0026#34;; // メッセージ String msg = \u0026#34;news for Japan\u0026#34;; rabbitTemplate.convertAndSend(exchangeName,\u0026#34;japan.news\u0026#34;,msg); } } 1だけが受け取れるよ。\nメッセージ変換器 Springは送信するメッセージをバイト列にシリアライズしてMQに送り、メッセージを受け取る時はバイト列をJavaオブジェクトにデシリアライズするんだ。ただ、デフォルトだとSpringが使うシリアライズ方法はJDKシリアライズで、データサイズが大きすぎたり、セキュリティ上の脆弱性があったり、可読性が低かったりするんだよね。\nJSON方式を使ってシリアライズとデシリアライズをすることもできるよ。\nまずは親プロジェクトで依存関係を導入しよう。\n1 2 3 4 5 6 \u0026lt;!-- JSON変換器 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.fasterxml.jackson.dataformat\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jackson-dataformat-xml\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.9.10\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; コンシューマーとレシーバーでBeanを宣言するだけでいいんだ。\n1 2 3 4 @Bean public MessageConverter jsonMessageConverter(){ return new Jackson2JsonMessageConverter(); } ","date":"2025-01-15T17:03:32+09:00","permalink":"https://blog.yexca.net/ja/archives/217/","title":"SpringAMQP"},{"content":" この記事の一部は機械翻訳を使ったよ\nMyBatis シリーズ\nインストールと開始方法: https://blog.yexca.net/ja/archives/215 使い方: この記事\n削除 パラメータ名を中に入れたプレースホルダとして #{} を使用します\n1 2 3 4 5 6 @Mapper public interface EmpMapper { // 削除 @Delete(\u0026#34;delete from mybatis.emp where id = #{id}\u0026#34;) public void delete(Integer id); } テスト\n1 2 3 4 5 6 7 8 9 @SpringBootTest class Mybatis02ApplicationTests { @Autowired private EmpMapper empMapper; @Test void contextLoads() { empMapper.delete(17); } } 通常、戻り値は必要ありません。戻り値は、この操作によって影響を受ける行の数です。\n1 2 3 4 5 6 @Mapper public interface EmpMapper { // 削除 @Delete(\u0026#34;delete from mybatis.emp where id = #{id}\u0026#34;) public int delete(Integer id); } プレースホルダー パラメータプレースホルダは #{} と ${} です\nプレースホルダー #{} ${} 形状 プリコンパイル スプライシング いつ使うか パラメータの受け渡し、ログインなど テーブル名とリストを動的に設定する 長所と短所 安全性と高性能 SQLインジェクションの問題がある 挿入（新規） プレースホルダも使用されますが、渡されるパラメータが多すぎる場合は、オブジェクトのカプセル化を使用することができ、正式なパラメータ名はオブジェクトのパラメータ名になります。\n1 2 3 4 5 6 7 @Mapper public interface EmpMapper { // 増加 @Insert(\u0026#34;insert into mybatis.emp(username, name, gender, image, job, entrydate, dept_id, create_time, update_time) \u0026#34;+ \u0026#34;values (#{username},#{name},#{gender},#{image},#{job},#{entrydate},#{deptId},#{createTime},#{updateTime});\u0026#34;) public void insert(Emp emp); } テスト\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 @SpringBootTest class Mybatis02ApplicationTests { @Autowired private EmpMapper empMapper; @Test public void testInsert(){ Emp emp = new Emp(); emp.setUsername(\u0026#34;Tom\u0026#34;); emp.setName(\u0026#34;トム\u0026#34;); emp.setGender((short) 1); emp.setImage(\u0026#34;tom.jpg\u0026#34;); emp.setJob((short) 1); emp.setEntrydate(LocalDate.of(2000,1,1)); emp.setDeptId(1); emp.setCreateTime(LocalDateTime.now()); emp.setUpdateTime(LocalDateTime.now()); empMapper.insert(emp); } } 主キーの値を取得する 場合によっては、データが正常に追加された後、データベースに挿入されたデータの主キーを取得する必要があります。\n1 2 3 4 5 6 7 8 9 @Mapper public interface EmpMapper { // 主キーを取得します。最初の属性は、emp オブジェクトの id 属性に割り当てられた主キー値を定義します。2 番目の属性は、返される主キー値を表します。 @Options(keyProperty = \u0026#34;id\u0026#34;, useGeneratedKeys = true) // 増加 @Insert(\u0026#34;insert into mybatis.emp(username, name, gender, image, job, entrydate, dept_id, create_time, update_time) \u0026#34;+ \u0026#34;values (#{username},#{name},#{gender},#{image},#{job},#{entrydate},#{deptId},#{createTime},#{updateTime});\u0026#34;) public void insert(Emp emp); } 更新（変更） 増加と同様に、オブジェクトにカプセル化することができます\n1 2 3 4 5 6 7 @Mapper public interface EmpMapper { // 変更 @Update(\u0026#34;update mybatis.emp set username = #{username}, name = #{name}, gender = #{gender}, image = #{image}, job = #{job}, \u0026#34;+ \u0026#34;entrydate = #{entrydate}, dept_id = #{deptId}, update_time = #{updateTime} where id = #{id};\u0026#34;) public void update(Emp emp); } テスト\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 @SpringBootTest class Mybatis02ApplicationTests { @Autowired private EmpMapper empMapper; @Test public void testUpdate(){ Emp emp = new Emp(); emp.setUsername(\u0026#34;Tom2\u0026#34;); emp.setName(\u0026#34;トム2\u0026#34;); emp.setGender((short) 1); emp.setImage(\u0026#34;tom.jpg\u0026#34;); emp.setJob((short) 1); emp.setEntrydate(LocalDate.of(2000,1,1)); emp.setDeptId(1); emp.setUpdateTime(LocalDateTime.now()); emp.setId(19); empMapper.update(emp); } } クエリ クエリには、IDに基づいてすべての属性をクエリするクエリと条件に基づいてクエリするクエリの2種類があります。\nIDによるクエリ インタフェース\n1 2 3 4 5 6 @Mapper public interface EmpMapper { // IDによるクエリ @Select(\u0026#34;select * from mybatis.emp where id = #{id}\u0026#34;) public Emp idSelect(Integer id); } テスト\n1 2 3 4 5 6 7 8 9 10 11 12 @SpringBootTest class Mybatis02ApplicationTests { @Autowired private EmpMapper empMapper; @Test public void testIdSelect(){ Emp emp = empMapper.idSelect(19); System.out.println(emp); } } 結果\n1 Emp(id=19, username=Tom2, password=123456, name=汤姆2, gender=1, image=tom.jpg, job=1, entrydate=2000-01-01, deptId=null, createTime=null, updateTime=null) クラス Emp のフィールド名がデータベースと異なるため、クエリ結果は null になります。\n解決方法は3つあります\nエイリアスの使用 1 2 3 4 5 6 7 @Mapper public interface EmpMapper { // 方法 1: エイリアス @Select(\u0026#34;select id, username, password, name, gender, image, job, entrydate, dept_id deptId, create_time createTime, update_time updateTime\u0026#34; + \u0026#34; from mybatis.emp where id = #{id}\u0026#34;) public Emp idSelect(Integer id); } @Results アノテーションの使用 1 2 3 4 5 6 7 8 9 10 11 @Mapper public interface EmpMapper { // 方法 2: @Results @Result アノテーション @Results({ @Result(column = \u0026#34;dept_id\u0026#34;, property = \u0026#34;deptId\u0026#34;), @Result(column = \u0026#34;create_time\u0026#34;, property = \u0026#34;createTime\u0026#34;), @Result(column = \u0026#34;update_time\u0026#34;, property = \u0026#34;updateTime\u0026#34;) }) @Select(\u0026#34;select * from mybatis.emp where id = #{id}\u0026#34;) public Emp idSelect(Integer id); } 自動包装の使用 フィールド名と属性名がキャメルケース命名規則に準拠している場合は、自動キャメルケース命名カプセル化を有効にすることができ、Mybatisはキャメルケース命名規則に従って自動的にマッピングします。具体的には、データベースはアンダースコア「a_column」をJava属性「aColumn」にマッピングします。\nキャメルケース命名を有効にするには、application.propertiesに追加します。\n1 mybatis.configuration.map-underscore-to-camel-case=true 然后直接使用最初的代码\n1 2 3 4 5 6 @Mapper public interface EmpMapper { // IDによるクエリ @Select(\u0026#34;select * from mybatis.emp where id = #{id}\u0026#34;) public Emp idSelect(Integer id); } 使いやすさのために、IDEA に MyBatisX プラグインをインストールすることができます。\n条件による検索 要件: 従業員名 (あいまい一致)、性別 (完全一致)、雇用日 (範囲) に基づいて条件を満たす従業員情報を検索します。\n1 2 3 4 5 6 7 8 @Mapper public interface EmpMapper { // 条件による検索 // \u0026#39;%${name}%\u0026#39; のように名前に使用される ${} は、\u0026#39;\u0026#39; 内でも使用できることに注意してください。 @Select(\u0026#34;select * from mybatis.emp where name like \u0026#39;%${name}%\u0026#39; and gender = #{gender} and \u0026#34; + \u0026#34;entrydate between #{begin} and #{end} order by update_time desc\u0026#34;) public List\u0026lt;Emp\u0026gt; conditionSelect(String name, short gender, LocalDate begin, LocalDate end); } 文字列の連結には補間が使用されるため、この方法は安全ではありません。\n1 2 3 4 5 6 7 @Mapper public interface EmpMapper { // より安全な条件付きクエリ @Select(\u0026#34;select * from mybatis.emp where name like concat(\u0026#39;%\u0026#39;,#{name},\u0026#39;%\u0026#39;) and gender = #{gender} and \u0026#34; + \u0026#34;entrydate between #{begin} and #{end} order by update_time desc\u0026#34;) public List\u0026lt;Emp\u0026gt; conditionSelect(String name, short gender, LocalDate begin, LocalDate end); } concat 関数は文字列を連結するために使用されます。テスト\n1 2 3 4 5 6 7 8 9 10 11 12 @SpringBootTest class Mybatis02ApplicationTests { @Autowired private EmpMapper empMapper; @Test public void testConditionSelect(){ List\u0026lt;Emp\u0026gt; empList = empMapper.conditionSelect(\u0026#34;张\u0026#34;, (short) 1, LocalDate.of(2010, 1, 1), LocalDate.of(2020, 1, 1)); System.out.println(empList); } } パラメータ名の説明 SQLで使用される#{}内の変数名はSpringBoot 2.x以降では自動的に認識されますが、バージョン1.xまたはMyBatisのみを使用する場合は、メソッド内で定義された変数名をアノテーションを使用して指定する必要があります。\n1 2 3 4 5 6 7 8 9 10 11 @Mapper public interface EmpMapper { // より安全な条件付きクエリ @Select(\u0026#34;select * from mybatis.emp where name like concat(\u0026#39;%\u0026#39;,#{name},\u0026#39;%\u0026#39;) and gender = #{gender} and \u0026#34; + \u0026#34;entrydate between #{begin} and #{end} order by update_time desc\u0026#34;) public List\u0026lt;Emp\u0026gt; conditionSelect(String name, short gender, LocalDate begin, LocalDate end); } // 上記のコードは1.xでは動作しません。またMyBatisのみを使用する場合も動作しません。関数に注釈を付ける必要がある。 public List\u0026lt;Emp\u0026gt; conditionSelect(@Param(\u0026#34;name\u0026#34;) String name, @Param(\u0026#34;gender\u0026#34;) short gender, @Param(\u0026#34;begin\u0026#34;) LocalDate begin, @Param(\u0026#34;end\u0026#34;) LocalDate end); XML マッピングファイルの使用 SQL コードが比較的短い場合は、アノテーションを使用すると便利ですが、SQL が長かったり複雑だったりする場合は、少し乱雑に見えます。この目的のために、XML マッピング ファイルを使用できます。仕様は以下の通りです\nXML マッピングファイルの名前は Mapperイ ンターフェースの名前と一致しており、XML マッピングファイルと Mapper インターフェースは同じパッケージ（同じパッケージ、同じ名前）に配置されています。 XML の名前空間属性は Mapper インターフェースの完全修飾名と一致している XML 内の SQL 文の id 属性は Mapper インターフェースのメソッド名と一致しており、戻り値の型も一致している XML Maven プロジェクトでは、Java 以外のファイルは src/main/resources の下に配置されます。このディレクトリの下に Mapper インターフェースと一致するディレクトリを作成します。\nインターフェースが net.yexca.mapper.EmpMapper.java の場合、XML ファイルは net.yexca.mapper.EmpMapper.xml にあります。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;https://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;!-- 上記のヘッダーファイルを見つけるには、公式ウェブサイトにアクセスしてください。 --\u0026gt; \u0026lt;!-- namespace 属性はインターフェースである --\u0026gt; \u0026lt;mapper namespace=\u0026#34;net.yexca.mapper.EmpMapper\u0026#34;\u0026gt; \u0026lt;!-- id属性はメソッド名です --\u0026gt; \u0026lt;!-- resultTypeは単一のレコードでカプセル化された型です --\u0026gt; \u0026lt;select id=\u0026#34;conditionSelect\u0026#34; resultType=\u0026#34;net.yexca.pojo.Emp\u0026#34;\u0026gt; select * from mybatis.emp where name like concat(\u0026#39;%\u0026#39;,#{name},\u0026#39;%\u0026#39;) and gender = #{gender} and entrydate between #{begin} and #{end} order by update_time desc \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt; インターフェースクラス 1 2 3 4 @Mapper public interface EmpMapper { public List\u0026lt;Emp\u0026gt; conditionSelect(String name, short gender, LocalDate begin, LocalDate end); } 動的 SQL 動的 SQL は、ユーザー入力または外部条件に応じて変化する SQL ステートメントです。\nたとえば、上記の最後の条件クエリでは、クエリを実行するために 3 つの条件すべてを入力する必要があります。実際の使用では、1 つまたは 2 つの条件のみを指定するか、指定しない (すべてをクエリする) ことができます。上記の手順に従って実行すると、空の結果が返されます。\nwhere if 条件が真であるかどうかを判断するために使用されます。条件判定を実行するには、テスト属性を使用します。条件が真の場合、SQLを連結します。\nたとえば、名前が空でない場合、連結条件は名前によって照会されます。\n1 2 3 \u0026lt;if test=\u0026#34;name!=null\u0026#34;\u0026gt; name like contact(\u0026#39;%\u0026#39;,#{name},\u0026#39;%\u0026#39;) \u0026lt;/if\u0026gt; where タグは、where キーワードを生成するかどうか、および and キーワードと or キーワードを自動的に削除するかどうかを管理します。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;select id=\u0026#34;conditionSelect\u0026#34; resultType=\u0026#34;net.yexca.pojo.Emp\u0026#34;\u0026gt; select * from mybatis.emp \u0026lt;where\u0026gt; \u0026lt;if test=\u0026#34;name!=null\u0026#34;\u0026gt; name like concat(\u0026#39;%\u0026#39;,#{name},\u0026#39;%\u0026#39;) \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;gender!=null\u0026#34;\u0026gt; and gender = #{gender} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;begin!=null and end!=null\u0026#34;\u0026gt; and entrydate between #{begin} and #{end} \u0026lt;/if\u0026gt; \u0026lt;/where\u0026gt; order by update_time desc \u0026lt;/select\u0026gt; set SQL の set キーワードを置き換え、UPDATE ステートメントで使用する余分なカンマを自動的に削除します。\nたとえば、次のSQL文は動的SQLに変更されます。\n1 2 3 4 5 6 7 8 9 10 update mybatis.emp set username = #{username}, name = #{name}, gender = #{gender}, image = #{image}, job = #{job}, entrydate = #{entrydate}, dept_id = #{deptId}, update_time = #{updateTime} where id = #{id}; XML\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;update id=\u0026#34;update2\u0026#34;\u0026gt; update mybatis.emp \u0026lt;set\u0026gt; \u0026lt;if test=\u0026#34;username != null\u0026#34;\u0026gt;username = #{username},\u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;name != null\u0026#34;\u0026gt;name = #{name},\u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;gender != null\u0026#34;\u0026gt;gender = #{gender},\u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;image != null\u0026#34;\u0026gt;image = #{image},\u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;job != null\u0026#34;\u0026gt;job = #{job},\u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;entrydate != null\u0026#34;\u0026gt;entrydate = #{entrydate},\u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;deptId != null\u0026#34;\u0026gt;dept_id = #{deptId},\u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;updateTime != null\u0026#34;\u0026gt;update_time = #{updateTime}\u0026lt;/if\u0026gt; \u0026lt;/set\u0026gt; where id = #{id}; \u0026lt;/update\u0026gt; foreach foreach タグはトラバーサルに使用されます\n1 2 3 4 \u0026lt;!--走査するコレクション 横断された要素 デリミタ 開始前と開始後に連結されたSQLフラグメント--\u0026gt; \u0026lt;foreach collection=\u0026#34;ids\u0026#34; item=\u0026#34;id\u0026#34; separator=\u0026#34;,\u0026#34; open=\u0026#34;(\u0026#34; close=\u0026#34;)\u0026#34;\u0026gt; #{id} \u0026lt;/foreach\u0026gt; ids が [13, 14, 15] の場合、上記は (13,14,15) を生成します。\n要件: ID 1、2、3 の項目を走査して削除します。 SQL文は\n1 delete from emp where id in(1,2,3) インターフェースメソッド\n1 public void deleteByIds(List\u0026lt;Integer\u0026gt; ids); XML\n1 2 3 4 5 6 \u0026lt;delete id=\u0026#34;deleteByIds\u0026#34;\u0026gt; delete from mybatis.emp where id in \u0026lt;foreach collection=\u0026#34;ids\u0026#34; item=\u0026#34;id\u0026#34; separator=\u0026#34;,\u0026#34; open=\u0026#34;(\u0026#34; close=\u0026#34;)\u0026#34;\u0026gt; #{id} \u0026lt;/foreach\u0026gt; \u0026lt;/delete\u0026gt; テスト\n1 2 3 4 5 @Test public void testDeleteByIds(){ List\u0026lt;Integer\u0026gt; ids = Arrays.asList(13,14,15); empMapper.deleteByIds(ids); } sql と include 開発プロセスでは、多数の SQL ステートメントが繰り返される場合があります。sql タグを使用して再利用可能な SQL フラグメントを定義し、include タグを使用して再利用できます。\n1 2 3 4 5 6 7 \u0026lt;!-- id属性を通じてステートメントを一意に識別する --\u0026gt; \u0026lt;sql id = \u0026#34;commonCode\u0026#34;\u0026gt; \u0026lt;!-- SQL语句 --\u0026gt; \u0026lt;/sql\u0026gt; \u0026lt;!-- refid 属性は参照ステートメントを指定します。 --\u0026gt; \u0026lt;include refid = \u0026#34;commonCode\u0026#34; /\u0026gt; ","date":"2025-01-13T21:06:03+09:00","permalink":"https://blog.yexca.net/ja/archives/216/","title":"MyBatis 使い方"},{"content":" この記事の一部は機械翻訳を使ったよ\nMyBatis シリーズ\nインストールと開始方法: この記事\n使い方: https://blog.yexca.net/ja/archives/216 MyBatis は JDBC 開発を簡素化する優れた永続層フレームワークです。\nMySQL インストール (Windows) ダウンロード: https://dev.mysql.com/downloads/mysql/ ZIP Archive をダウンロード\n解凍し、環境変数 MYSQL_HOME PATH パス %MYSQL_HOME%\\bin を設定します。\n管理者権限で cmd を開き、mysql と入力して、設定が成功したかどうかを確認します。\nMySQL を初期化する コマンドを入力してください\n1 mysqld --initialize-insecure しばらく待つと、MySQL ディレクトリに data フォルダが生成されます。\nMySQL サービスを登録する コマンド\n1 mysqld -install MySQL サービスを開始する コマンド\n1 2 3 4 # mysqlサービスを開始する net start mysql # mysqlサービスを停止する net stop mysql root パスワードを変える コマンド\n1 mysqladmin -u root password 1234 ログインパラメータ\n1 2 3 4 mysql -u ユーザー名 -p パスワード -h 接続するMySQLサーバーのIPアドレス (デフォルト127.0.0.1) -P ポート番号 (デフォルト 3306) # 例えば mysql -u root -p # 実行後、パスワードの入力を求められます 入門例 まず、SpringBoot プロジェクトを作成し、依存関係「MyBatis Framework」と「MySQL Driver」を選択します。\nデータベース 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 create database mybatis; use mybatis; create table user( id int unsigned primary key auto_increment comment \u0026#39;ID\u0026#39;, name varchar(100) comment \u0026#39;名前\u0026#39;, age tinyint unsigned comment \u0026#39;年齢\u0026#39;, gender tinyint unsigned comment \u0026#39;性別, 1:男, 2:女\u0026#39;, phone varchar(11) comment \u0026#39;電話番号\u0026#39; ) comment \u0026#39;ユーザーテーブル\u0026#39;; insert into user(id, name, age, gender, phone) VALUES (null,\u0026#39;白眉鹰王\u0026#39;,55,\u0026#39;1\u0026#39;,\u0026#39;18800000000\u0026#39;); insert into user(id, name, age, gender, phone) VALUES (null,\u0026#39;金毛狮王\u0026#39;,45,\u0026#39;1\u0026#39;,\u0026#39;18800000001\u0026#39;); insert into user(id, name, age, gender, phone) VALUES (null,\u0026#39;青翼蝠王\u0026#39;,38,\u0026#39;1\u0026#39;,\u0026#39;18800000002\u0026#39;); insert into user(id, name, age, gender, phone) VALUES (null,\u0026#39;紫衫龙王\u0026#39;,42,\u0026#39;2\u0026#39;,\u0026#39;18800000003\u0026#39;); insert into user(id, name, age, gender, phone) VALUES (null,\u0026#39;光明左使\u0026#39;,37,\u0026#39;1\u0026#39;,\u0026#39;18800000004\u0026#39;); insert into user(id, name, age, gender, phone) VALUES (null,\u0026#39;光明右使\u0026#39;,48,\u0026#39;1\u0026#39;,\u0026#39;18800000005\u0026#39;); application.properties 1 2 3 4 5 6 7 8 9 10 # データベース接続情報を構成する # ドライバークラス名 spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver # データベース接続URL spring.datasource.url=jdbc:mysql://localhost:3306/mybatis # データベースに接続するためのユーザー名 spring.datasource.username=root # データベースに接続するためのパスワード spring.datasource.password=1234 User クラス 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 public class User { private Integer id; private String name; private short age; private short gender; private String phone; public User() { } public User(Integer id, String name, short age, short gender, String phone) { this.id = id; this.name = name; this.age = age; this.gender = gender; this.phone = phone; } public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public short getAge() { return age; } public void setAge(short age) { this.age = age; } public short getGender() { return gender; } public void setGender(short gender) { this.gender = gender; } public String getPhone() { return phone; } public void setPhone(String phone) { this.phone = phone; } @Override public String toString() { return \u0026#34;User{\u0026#34; + \u0026#34;id=\u0026#34; + id + \u0026#34;, name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, age=\u0026#34; + age + \u0026#34;, gender=\u0026#34; + gender + \u0026#34;, phone=\u0026#39;\u0026#34; + phone + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#39;}\u0026#39;; } } UserMapper インタフェース 1 2 3 4 5 6 @Mapper // 実行時に、インターフェースの実装クラスオブジェクト（プロキシオブジェクト）が自動的に生成され、管理のために IOC コンテナに引き渡されます。 public interface UserMapper { // ここではアノテーションを使用してSQL文を記述します @Select(\u0026#34;select * from user\u0026#34;) public List\u0026lt;User\u0026gt; list(); } テストクラス 1 2 3 4 5 6 7 8 9 10 11 12 @SpringBootTest class MybatisStartApplicationTests { @Autowired private UserMapper userMapper; @Test void contextLoads() { List\u0026lt;User\u0026gt; list = userMapper.list(); list.forEach(System.out::println); } } データベース接続プール データベース接続プールは、データベース接続 (Connection) の割り当てと管理を担当するコンテナです。\nこれにより、アプリケーションは新しいデータベース接続を確立する代わりに、既存のデータベース接続を再利用できます。\nアイドル時間が最大アイドル時間を超える接続を解放して、接続の解放の失敗によるデータベース接続の喪失を回避します。\n利点: リソースの再利用とシステム応答速度の向上\n公式標準インターフェース: DataSource\n一般的な製品: Hikari (SpringBoot デフォルト)、Druid\nLombok 上記の例では、User クラスはいくつかの属性のみを定義していますが、多くのメソッドが必要なため、コードが肥大化しています。この目的には、Lombok を使用できます。\nLombok は、アノテーションを通じてコン​​ストラクター、getter/setter、equals、hashcode、toString などのメソッドを自動的に生成し、ログ変数を自動的に生成して Java 開発を簡素化し、効率を向上させる実用的な Java クラス ライブラリです。\n注釈 効果 @Getter/@Setter すべてのプロパティに get/set メソッドを提供する @ToString クラスの読みやすい toString メソッドを自動的に生成します @EqualsAndHashCode クラスが所有する非静的フィールドに基づいて、equals メソッドと hashCode メソッドを自動的にオーバーライドします。 @Data より包括的なコード生成機能を提供します(@Getter+@Setter+@ToString +@EqualsAndHashCode) @NoArgsConstructor エンティティクラスのパラメータなしのコンストラクタメソッドを生成する @AllArgsConstructor static 変更フィールドに加えて、エンティティ クラスのパラメータを持つコンストラクタ メソッドを生成します。 Lombok の導入 依存関係を導入します。バージョン番号は不要で、SpringBoot によって設定されます。\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; User クラス 1 2 3 4 5 6 7 8 9 10 @Data @NoArgsConstructor @AllArgsConstructor public class User { private Integer id; private String name; private short age; private short gender; private String phone; } Lombok はコンパイル時に対応する Java コードを自動的に生成します。Lombok を使用するにはプラグインをインストールする必要がありますが、IDEA ではデフォルトでインストールされています。\n","date":"2025-01-12T23:59:48+09:00","permalink":"https://blog.yexca.net/ja/archives/215/","title":"MyBatis のインストールと開始方法"},{"content":" 音に感じてシリーズ 曲 翻訳 リンク 僕が死のうと思ったのは 略 この記事 あくあ色ぱれっと 略 https://blog.yexca.net/ja/archives/219 恋の押し売り 略 https://blog.yexca.net/ja/archives/220 17さいのうた 略 https://blog.yexca.net/ja/archives/224 drop 恋に落ちた https://blog.yexca.net/ja/archives/230 生きるを選んだ私へ 略 https://blog.yexca.net/ja/archives/239 rainy lady 雨女 https://blog.yexca.net/ja/archives/249 恋しくなったら手を叩こう 略 https://blog.yexca.net/ja/archives/250 まえがき てっ、この記事は日本語なので、もう日本語の勉強じゃない？書く必要がないかもね\nまあ、とりあえず歌詞を書こうかな\n動画 歌詞 僕ぼくが死しのうと思おもったのは　ウミネコが桟さん橋ばしで鳴ないたから\n波なみの随意ずいいに浮うかんで消きえる　過去かこも啄ついばんで飛とんでいけ\n僕ぼくが死しのうと思おもったのは　誕生日たんじょうびに杏あんずの花はなが咲さいたから\nその木こ漏もれ日びでうたた寝ねしたら　虫むしの死し骸がいと土つちになれるかな\n薄荷はっか飴あめ　漁港ぎょこうの灯台とうだい　錆さびたアーチ橋ばし　捨すてた自転車じてんしゃ\n木造もくぞうの駅えきのストーブの前まえで　どこにも旅たび立だてない心こころ\n今日きょうはまるで昨日きのうみたいだ　明日あすを変かえるなら今日きょうを変かえなきゃ\n分かってる　分かってる　けれど\n僕ぼくが死しのうと思おもったのは　心こころが空からっぽになったから\n満みたされないと泣ないているのは　きっと満みたされたいと願ねがうから\n僕ぼくが死しのうと思おもったのは　靴紐くつひもが解ほどけたから\n結むすびなおすのは苦手にがてなんだよ　人ひととの繋つながりもまた然しかり\n僕ぼくが死しのうと思おもったのは　少年しょうねんが僕ぼくを見みつめていたから\nベッドの上うえで土下座どげざしてるよ　あの日ひの僕ぼくにごめんなさいと\nパソコンの薄うす明あかり　上階じょうかいの部屋へやの生活音せいかつおん\nインターフォンのチャイムの音おと　耳みみを塞ふせぐ鳥とりかごの少年しょうねん\n見みえない敵てきと戦たたかってる　六畳ろくじょう一間ひとまのドンキホーテ\nゴールはどうせ醜みにくいものさ\n僕ぼくが死しのうと思おもったのは　冷つめたい人ひとと言いわれたから\n愛あいされたいと泣ないているのは　人ひとの温ぬくもりを知しってしまったから\n僕ぼくが死しのうと思おもったのは　あなたが奇麗きれいに笑わらうから\n死しぬことばかり考かんがえてしまうのは　きっと生いきる事ことに真面目まじめすぎるから\n僕ぼくが死しのうと思おもったのは　まだあなたに出会であってなかったから\nあなたのような人ひとが生うまれた　世界せかいを少すこし好すきになったよ\nあなたのような人ひとが生いきてる　世界せかいに少すこし期待きたいするよ\n","date":"2025-01-11T01:10:51+09:00","permalink":"https://blog.yexca.net/ja/archives/214/","title":"音に感じて - 《僕が死のうと思ったのは》"},{"content":" 📢 この記事は ChatGPT によって翻訳されました Python でのパッケージ化は今の OS 環境に依存する。\nWindows なら .exe、Linux なら ELF 形式になる。\nクロスプラットフォームの出力は非対応。\nインストール pip でインストール：\n1 2 3 4 5 6 7 8 9 pip install pyinstaller ~~~ ## 単一ファイルとしてビルド `--onefile` を指定すればOK： ```bat pyinstaller --onefile main.py よく使うオプション（Windows 向け） --windowed: ターミナルを表示しない（GUI アプリ向け） --icon=icon.ico: アイコン追加 --hidden-import: 必要な依存を手動で指定 --add-data: 追加のリソースファイルを含める --debug: デバッグ情報を出力 複数ファイル構成でビルド --onedir でディレクトリ形式に：\n1 pyinstaller --onedir main.py この場合、依存ファイルは _internal フォルダに入ってて、ちょっと扱いづらい。\npyinstaller 6.1.0 以上なら --contents-directory が使える：\n1 pyinstaller --contents-directory . .\\main.py これで依存と実行ファイルが同じフォルダ内にまとまる。\nファイルの追加（設定ファイルなど） たとえば project/conf/settings.json を一緒に含めたい場合：\nまずは複数ファイル形式でビルド：\n1 pyinstaller --name my_program --contents-directory . .\\main.py すると my_program.spec ってファイルが生成される。これを編集：\n1 datas=[(\u0026#39;conf/settings.json\u0026#39;, \u0026#39;conf/\u0026#39;)], 編集したら、dist/ フォルダの中を一度消してから（消さなくてもOK）再ビルド：\n1 pyinstaller my_program.spec 実際のプロジェクト この方法で、 このソフト を exe にできた\n（でもまだエラーハンドリング入れてない）\n参考記事 https://www.cnblogs.com/yqbaowo/p/17863429.html ","date":"2025-01-07T17:26:09+09:00","permalink":"https://blog.yexca.net/ja/archives/213/","title":"Pythonでpyinstallerを使って実行ファイル化する"},{"content":" この記事の一部は機械翻訳を使ったよ\nまえがき 今日は最近設計した半透明、すりガラスと丸みを帯びた角についてまとめようと思っていたけど、突然2023年12月01日何かを作ったことを思い出したので、それも一緒に再編成しようと思う\nウェブサイトの背景 現代の (アニメ風) ウェブページは背景が必要だ\n1 2 3 4 5 6 7 8 body{ background-image: url(\u0026#39;../img/77194247_p0.jpg\u0026#39;); background-size: cover; background-attachment: fixed; /* 固定 */ background-repeat: no-repeat; /* 繰り返さない */ padding: 0; margin: 0; } 半透明とすりガラス そして、背景にマスクを加えて、半透明効果とすりガラス効果を実現する\n1 2 3 4 5 6 7 8 9 10 11 .layout { /* display: flex; */ margin: 0; padding: 0; display: flex; width: 100vw; height: 100vh; backdrop-filter: blur(2px); /* 背景ぼかし効果 */ -webkit-backdrop-filter: blur(2px); /* Safari サポート */ background: rgba(0, 0, 0, 0.4); /* 半透明黒い背景 */ } ウェブページのリニューアル そういえば、文章を書くのは面倒だな。プログラムしていると邪魔されて、プログラムが終わった時はとても疲れてしまったので、書きたくなくなった。だから今は気軽に文章を書いている\nプロジェクトのリング: https://github.com/yexca/MusicPlayer-Twinkle 顺便更新了下之前的文章 https://blog.yexca.net/ja/archives/116/ 用此方法加了个示例: https://twinkle.yexca.net ところで、以前の文章も更新したよ (簡体字中国語で) https://blog.yexca.net/ja/archives/116/ その方法で例を作った: https://twinkle.yexca.net カード効果 これも現代的な設計だよねー\n1 2 3 4 5 6 7 8 9 10 .card { width: 300px; padding: 20px; background-color: rgba(255, 255, 255, 0.5); /* 半透明白い背景 */ border-radius: 15px; /* 丸みを帯びた角 */ box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); /* 影 */ backdrop-filter: blur(10px); /* 背景ぼかし効果 */ border: 1px solid rgba(255, 255, 255, 0.3); /* ボーダー */ color: pink; /* 文字の色 */ } まあ、時間があればカードのデザインを基にしてプロジェクトを進めよう (また新しい沼にハマっちゃった)\nTwinkle ちなみに、プロジェクトの内容は Twinkle の音楽、詳しくはこちら\nhttps://twinkle130527.wixsite.com/twinkle https://www.dojin-music.info/circle/1255 SoundCloud\nhttps://soundcloud.com/twintwinkles ","date":"2025-01-05T16:19:36+09:00","permalink":"https://blog.yexca.net/ja/archives/212/","title":"すりガラス効果"},{"content":" 📢 この記事は ChatGPT によって翻訳されました 2025-05-18 更新\nSQLite版も書いた。もうデータベース設定しなくていい： https://blog.yexca.net/ja/archives/248 3日かけてとりあえず動くやつを作ってみた。\nただしエラー処理はしてないから、バグったら 再起動してね。\nGitHub リポジトリはこちら： https://github.com/yexca/PixivDownloader-MySQL はじめに これは ダウンロード済みのイラストを DB に記録する ってところから始まってて、\nずっと同じ作業してるのアホらしくなって「コンピュータにやらせよう」ってなったんだよね。\nたまたま最近「プログラム作りたいな」って思ってたし、\nついでにこの前作ってたやつ（ https://github.com/yexca/yasumiProject ）にも満足してなかったし、\n年末年始で時間あったから、よっしゃやるかって感じで。\n説明 一応形にはなったけど、エラー処理はないし、\nGUI アプリとしては初めてちゃんと作ったやつだから、コードはぐちゃぐちゃ。\nなので整理も多言語対応も放棄した（笑）\nしかも作ってる途中で「これ SQLite でよくね？」って気づいたんだけど、\nもう半分以上作っちゃったから「まあ最後までやるか」って流れに。\n本当は exe にもしたかったけど、設定ファイル使ってるから面倒だし、\nしかも最初ビルドしたやつがウイルス扱いされて焦ったし\nってことで放置。\nUI 背景画像出典： https://www.pixiv.net/artworks/83273073 ホーム画面： 設定画面： 設定 もともとの DB をベースに作ったので、カスタマイズ性はほぼない。\nDB のテーブル作成 SQL は以下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 CREATE TABLE pic ( ID varchar(99), -- 一意な識別子 name varchar(255), -- 作者の名前 downloadedDate datetime, -- ダウンロード／更新日 lastDownloadID varchar(255), -- 最新の作品ID platform varchar(50), -- プラットフォーム名 url varchar(255), -- リンク PRIMARY KEY(ID) )ENGINE=InnoDB DEFAULT CHARSET=utf8mb4; ~~~ Pixiv の API はログインが必要だけど、 IDとパスワードでのログインは不可。 この方法で Auth Token を取得する：https://gist.github.com/ZipFile/c9ebedb224406f4f11845ab700124362 背景画像は Git に入れてない。パスは `app\\resources\\images\\background.png` あと Python が必要。依存関係は pip で： ```bash pip install -r requirements.txt 使い方 実行：\n1 python main.py Pixiv の認証画面と設定画面で必要な設定を済ませたらホームへ戻る。\n画面に Pixiv の ユーザーID または 作品ID を入力すると、 そのユーザーのすべての作品を自動で取得してくれる。\nおわりに 正直、自分でもこのアプリ使ってないけど、 開発経験の一歩としてはなかなか良かったと思ってる。\n","date":"2025-01-03T20:05:44+09:00","permalink":"https://blog.yexca.net/ja/archives/211/","title":"Pixiv ダウンローダー"},{"content":" 📢 この記事は ChatGPT によって翻訳されました はじめに この文章は自分用。タイトルは「2024 年まとめ」ってことになってるけど、近年の生活の気付きや心の流れを記録するために書いてる。\n文章力はそんなにないし、書きたいことはいっぱいあるけど、うまくまとめられないのでこのままでいく。\n2020 から 2024 のこと 2020年あたりから、「時間がめっちゃ早く過ぎる」って感覚が強くなってきた。\nいろいろ経験してるのに、2019年以前の「1日1日をちゃんと生きてた感覚」や「長く感じる感覚」がなくなった気がする。\nでも客観的に見ると、毎年ちゃんといろんなことしてる。特に今年（2024）はほんとにいろいろあった。\n2020 この年は大学入試があって、初めて地元を離れて生活を始めた。大学ではサークルに入って、いろんな活動にも参加した 2021 前半はサークル活動をいろいろやってて、後半はスマホを買い替えて Apple エコシステムに入ったり、専攻を変えたり、このブログを立ち上げたりした 2022 Switch OLED を発売直後にプレミア価格で買ってめちゃくちゃ遊んでた。同じ年に Quest2 も購入して VR の旅が始まった。VRChat のチュートリアルもいくつか書いた。年末には南京市にも遊びに行った 2023 この年はキャンパスが変わって、原神 × ピザハット、喜茶など、いろんなオタク系イベントにも初めて参加。後半はコロナ制限が緩んで、周辺エリアをぶらぶらしたり、国家資格試験や日本語能力試験を受けたり、Google Pixel6 を買ったり、クレカ集めにハマったりした 2024 たぶん今までで一番充実してた年。年始に深圳でインターンを始めて、Costco の新店舗に行ったり、初めて海を見たり、たくさん素敵な人と出会ったり、華強北を探索したり、香港に行ったり、マカオを巡ったり、初めて船に乗ったりした。考え方も変わってきて、大学卒業後に実家に帰ってからは家族との関係も変化して、話すようになったし、一緒に徐州旅行に行ったり、自炊や DIY を始めたり、運転免許も取った。その後は日本に行って、初めて飛行機に乗って、初めて二次元ファッションで外出して、初めてコミケ (C105) にも参加した！ 年々経験値は増えてるのに、主観的には「何もしてないのに時間だけが過ぎた」って思ってしまう。\nそれがちょっとした混乱を生む。\n人生を説明しようとした理論たち ※注意：以下は全部自分の妄想。学術的な根拠は一切ないので、信じすぎないように！\n実は 2023 年後半、院試の勉強しないといけなかったんだけど、目がめちゃくちゃ痛くて、\n一日中起きてられなくなって、寝たり起きたりを繰り返してた。\nそんなときにふと「生活を説明する理論」みたいなものを考え出した。\n状態行動理論 一番最初に思いついたのは「状態行動理論」。\n人の行動って、感情・情報・経験・周囲の影響とか、いろんな変数で決まるんじゃないかって。\nその変数に重みを与えて数値化できれば、かなり高精度で行動を予測できるんじゃないか？\nもしすべての人の状態が分かったら、人生ってもう全部決まってるんじゃないか、って発想。\n最初はただの妄想で遊んでたんだけど、ある日「これ Unity の State Behavior と似てるな」と思って命名した。\n圏理論（サークル理論） それと同時に「影響要素のグループ化」を考えるために圏理論も思いついた。\nネット上でいろんなジャンルにハマってみると、明確に分かれたサークル（圏）があることに気づいた。\nサークルごとに「当然の常識」が違ってて、あるところではすごく普通なことが、他ではめっちゃ驚かれる。\n情報バブル（フィルターバブル）に似てるけど、これは自分が選んだ「関心」で囲まれてるサークルの話。\n名言が刺さる理由 「なんで名言ってこんなに刺さるんだろう」って考えたことない？\nこれも、いろんな人の経験が抽象化されて生まれた言葉で、\n自分がその抽象パターンの別の実装に当てはまるから「めっちゃ分かる！」って感じるんだと思う。\nもっとちゃんと言えば、人間の歴史って膨大すぎて、どんな選択肢も誰かがすでに通った道。\nつまり「絶対正しい」とか「絶対間違ってる」ってことはなくて、状況次第で相対的に正しかったり間違ってたりするだけ。\n信頼理論 最近のお気に入りは「信頼理論」。\n人間社会って信頼の上に成り立ってる。\n横断歩道を渡るとき「ドライバーがちゃんと止まってくれるはず」って信じてる。\nすれ違う人がナイフを出して襲ってこないって信じてる。\n日常のほとんどは「当たり前に信じてること」で成り立ってる。\nまあ、ほかにもいろいろ考えてたけど、全部は思い出せないや。\n理論と行動の乖離 「もし子どもみたいに自由に好きなことができたら、もっと自由を感じられるんじゃないか」\n……でも、たぶんその子どもはもう“ルールの土の中”に埋められてしまったのかもしれない。\n生活のいろんな問題が「理論的に説明できる」ようになったけど、\nそれは問題を解決する助けにはならなかった。むしろ逆効果。\n理論を使って選択肢を全部考える。\n結果、何かを経験しても「あ、これ前に想定してたパターンだな」ってなって、\nまるでゲームで NPC の会話をスキップするように、現実のやりとりにも熱量を感じなくなった。\nだから娯楽に逃げた。散歩、買い物、ランニング、旅行、ゲーム……\nでも「楽しまなきゃ」という義務感があって、純粋に楽しめない。\n心の中では「タスク処理」になってて、\nストレスがたまったら「ストレス値を下げるイベントを配置する」ってだけ。\n自分で自分をマネージしてる。設計者も実行者も自分。\nでもそのシナリオは、感情が抜けた“タスク完了型”の人生になってる。\n何かをするときに「これはルール通りか？」って無意識に考えてて、\n少しでも逸脱すると「良くない」って感じてしまう。\n認められるために正解を探してるのかもしれない。\nそれってまさに、圏理論の一部じゃない？ 自分もまた“説明”の中に閉じ込められてる存在なんじゃないか。\nbilibili の埋め込みが微妙だったから Youtube に変更。\n鹿乃の公式アカウントがあるので、動画元は BV1zr4y1n7sM\nもしかして、これって「うつ」じゃない？って思ったこともある。\n自殺のシミュレーションすらした。\nでも、ふと思い出したのが『僕が死のうと思ったのは』の歌詞：\n「死ぬことばかり考えてしまうのは、きっと生きることに真面目すぎるから」\n——そう、まさにそれ。\n自分はたぶん、人生に対して真面目すぎたんだ。\nほかの歌詞も刺さった：\n「今日はまるで昨日みたいだ」 「見えない敵と戦ってる」 「明日を変えるなら今日を変えなきゃ、分かってる……けど」 「冷たい人と言われたから」 「人の温もりを知ってしまったから」 「あなたのような人が生きてる、世界に少し期待するよ」 でも、自分が人に相談することすらも「理論的に説明できる」って思ってる。\n「こういう条件で質問したら、こう返ってくる」って、API 呼び出しみたいに。\n安心を得ることも予測通りで、あまりに“予定調和”すぎてリアルさがない。\nでも人生って、予定通りにはいかない。\nだからこそ、自分は不確定性が怖くなってた。\nその恐怖を抑えるために、理論を増やして、どんどんルール化していった。\nでも感情は予測できない。理性で封じようとしても限界がある。\nだからこそ、「理論に頼りすぎると壊れる」ってことがわかってきた。\n説明から行動へ 時間は流れる水。\n自分はその水の量ばかり計っていて、温度を確かめるのを忘れてた。\n理論を使ってすべてを整理したつもりだったけど、\nその枠組みが逆に自分を縛ってた。\n自由に行動できるはずなのに、常に見えない“縛り”がある気がして、\n感情も経験も、すべてルールのもとで処理しようとしてた。\nでも、感情ってのは「理論の例外」であっていいんだ。\nそろそろ「自分の感情」を優先していいんだ。\n最初に気づいたのは「理論が役に立たない瞬間がある」ってことだった。\nそして、その気づきすらも理論で説明しようとしてた（笑）\nでも変われる。人は変わる。いろんな要因が重なったとき、方向が変わる。\nたとえば、人と関わることが増えてきた。\n以前の自分は内向的で、対人関係がめんどくさいと思ってたけど、\n理論を通せば「別に違反でもなんでもないし、関わってみてもいいか」って思えた。\nそれが始まりだった。\n最初に「すごくいい人」に出会って、そこから徐々に交流が広がった。\nそして視野も広がって、理論も深まって、選択肢が増えた。\n（同時に怖さも増えたけど、それはリスクとリターンの話）\nいろんなことを試してみるうちに、「理論の正しさ」よりも「感情の納得感」が大事だと気づいた。\nそれが「量的に整理された生活」からの脱却になった。\nとはいえ、それでもまだ足りない。\nなぜなら感情もまた“数値化”できてしまうから。\nある日、リスニング練習中に聞こえてきたこの会話：\nA：どっちがいい？\nB：A がいいんじゃない？\nA：でも B のほうが良くない？（理由付き）\nB：結論決まってんのになんで聞いたの？\n……これが、めちゃくちゃ心に刺さった。\n自分はいつも、もう結論出てるのに、何度も人に確認するタイプ。\n最適解を求めてるわけじゃなくて、「確実さ」がほしいだけ。\n不確実性が怖い。\nでも、たぶん……\nそもそも「自分の目標」って、自分の感情から出たものじゃなかったのかも。\n「こうすれば評価される」「こうすればうまくいく」っていう、理論で作った目標だった。\nだからこれからは、自分の「好き」の重みをもっと増やしていく。\n理論は道具であって、支配者じゃない。\n人生の設計者は自分。楽しむために使うんだ。\n現在 いま、自分は「自由に表現できる」し、「自由に行動できる」\n（もちろん法律は守るけどね）\nこの文章もその一歩。\n以前の自分だったら、こんな考えをまとめるのは恥ずかしかったと思う。\nだから、いくつかのサブ理論はもう忘れてしまった。\nでも今は思うんだ。\n生きるって、プロセスなんだ。\n変えられない事実なら、適応するしかない。\nいろんな人と出会う。\n良い人もいれば、運悪くつらい人もいる。\n悲しい気持ちが続くときって、たぶん「悲しいこと」が一時的に積み重なってるだけ。\n「どんなときも、ちゃんとした姿で登場しよう。すべての経験に本気で向き合う」\n……これは 自己紹介ページ に書いた言葉だけど、\n世界から見れば自分はただの数字かもしれない。\nでも、自分にとっては、自分が“世界そのもの”なんだよ。\n「 万物皆浮云、只要好心情 」\n自分の Atopes を起動しよう。\nやりたいことをやって、ほしいものを買って、行きたい場所に行こう。\n深く考えすぎなくていい。思いっきり自分を出していい。\n今ふと、 https://github.com/RimoChan のアイコンが思い浮かんだ。\n心から「生活を楽しむ」ってこういうことだな。\n楽しく生きるのも1日。つらく生きるのも1日。\nもう内面で自分を消耗するの、やめよう。\nおわりに 来年はどうなるかな？\n最後は、ブログの紹介文で締めよう。\nこの不完全な世界を、理想のカタチにプログラミングしよう！\n","date":"2024-12-31T17:40:09+09:00","permalink":"https://blog.yexca.net/ja/archives/210/","title":"2024 年まとめ"},{"content":" 📢 この記事は ChatGPT によって翻訳されました はじめに 情報を読む機会が増えると、他言語で記事を書きたくなることってあるよね（最近の作品はだいたい多言語対応だし）。\nそれに、卒論で多言語対応を入れて以来、自分が作るツールやデザインもいつのまにか多言語対応を意識するようになってきた。\nたとえば最近書いた https://github.com/yexca/yasumiProject この練習用のプロジェクトにも多言語化を入れてみた（ただし古くさすぎて微妙だった……モダンなやつを https://github.com/yexca/yasumiProject-frontend 別で作成中、できれば完成まで続けたい）。\nそれで、ふと自分のブログを見てみたら、多分一番長く付き合ってる作品なのに、まだ多言語化してなかった。\nもちろん基本的に簡体字で記事を書いてるからってのもあるけど、 https://jekyllblog.yexca.net/ 前のブログでは UI の一部が中国語、一部が英語になってて、正直ごちゃごちゃだったと思う。\n自分は読めるけど、他の人にはちょっとわかりづらいかもって感じだった。\nJekyll のときは頑張って多言語化しようとしたけど、うまくいかなかったので Hugo に乗り換えた（Hugo はネイティブに多言語サポートしてるから）。\nただ、テーマによって構造が結構違う。自分が今使ってるテーマはカテゴリ・タグの扱いが前とは全然違うから、カスタムする必要がある。\nこの記事、結構ざっくりしてる。\nというのも、多言語設定はほぼテーマ依存で、自分もテーマのサンプルを参考にして設定したから、あんまり書くことがない。\n（とはいえ、Hugo の公式ドキュメントはめちゃくちゃ丁寧）\n環境 Docker で Hugo のコンテナを使ってるから、環境構築はほぼノータッチ。\n使ってる環境については https://blog.yexca.net/ja/archives/182/#%E3%83%96%E3%83%AD%E3%82%B0%E7%92%B0%E5%A2%83jekyll をどうぞ。\nブログの新規作成 新しい Hugo サイトを作成：\n1 hugo new site blogName フォルダに移動：\n1 cd blogName Git 初期化：\n1 git init テーマを追加（ここでは hugo-theme-stack を使用）：\n1 git submodule add https://github.com/CaiJimmy/hugo-theme-stack/ themes/hugo-theme-stack hugo.toml にテーマ設定を追加：\n1 theme = \u0026#39;hugo-theme-stack\u0026#39; ローカルでプレビュー：\n1 hugo server ドラフト記事も含めてプレビューする場合：\n1 hugo server -D 一部の変更（設定ファイルやページ構成など）が反映されない場合はキャッシュを削除：\n1 hugo --cleanDestinationDir 本番ビルド（public/ フォルダに生成される）：\n1 hugo 多言語対応 設定ファイル（自分は yml 形式を使用）にて、デフォルト言語を指定：\n1 2 defaultContentLanguage: \u0026#39;zh-cn\u0026#39; # デフォルトの言語コード defaultContentLanguageInSubdir: false # デフォルト言語に言語コード付きのURLを使うかどうか 各言語の設定は以下のように：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 languages: zh-cn: contentDir: \u0026#39;content/zh-cn\u0026#39; disabled: false languageCode: \u0026#39;zh-cn\u0026#39; languageDirection: \u0026#39;ltr\u0026#39; languageName: \u0026#39;简体中文\u0026#39; title: \u0026#34;yexca\u0026#39;Blog\u0026#34; weight: 1 zh-tw: contentDir: \u0026#39;content/zh-tw\u0026#39; disabled: false languageCode: \u0026#39;zh-tw\u0026#39; languageDirection: \u0026#39;ltr\u0026#39; languageName: \u0026#39;繁體中文\u0026#39; title: \u0026#34;yexca\u0026#39;Blog\u0026#34; weight: 2 フォントの多言語対応については： https://blog.yexca.net/ja/archives/240 記事の書き方 Jekyll と違って Hugo の記事作成はちょっと複雑。 特に多言語化すると、フォルダ構成やルールが増えるけど、そのぶん柔軟性も高い。\nまず、上で設定した各言語に合わせて content/zh-cn や content/zh-tw といったフォルダを作成する必要がある。\nテーマによって、どのフォルダに記事を置くかが決まってることもある。たとえば stack テーマの場合：\n1 2 3 params: mainSections: - posts つまり、簡体字の投稿は content/zh-cn/posts に置くのが推奨される。 （他にも指定されてるフォルダがある場合は、テーマの例を見てね）\n記事作成例（タイムゾーンを Asia/Tokyo に指定して新規作成）：\n1 TZ=\u0026#34;Asia/Tokyo\u0026#34; hugo new content/zh-cn/posts/test.md タイムゾーンを指定しない場合は UTC になる。 自分は Jekyll に慣れてるから、いちいち時間を書くのが面倒でこうしてる。\nテンプレートは blogName/archetypes/ にあるので、yml 形式に変更することも可能。\n参考記事 Hugo - Quick start https://stack.jimmycai.com/guide/ Hugo - Multilingual mode ","date":"2024-12-27T23:11:45+09:00","permalink":"https://blog.yexca.net/ja/archives/209/","title":"Hugo でブログの多言語対応をする"},{"content":" この記事の一部は機械翻訳を使ったよ\nGo バックエンドのシンプルな (非技術的なフレームワーク) 実装\n~~皆さんご存知のとおり、~~バックエンド開発は一般的にインターフェース指向開発、つまり CRUD エンジニアです。この記事では、Go を使用して、データベースからデータを読み取り、JSON データを返す方法について説明します。\nデータベース この例では、MySQL データベースのカテゴリ テーブルからカテゴリ名と ID を読み取ります。テーブル構造は次のとおりです。\n1 2 3 4 5 6 DROP TABLE IF EXISTS categories ; CREATE TABLE categories ( id INT AUTO_INCREMENT PRIMARY KEY, name VARCHAR(255) NOT NULL, description VARCHAR(255) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4; プロジェクト構造 この例のプロジェクト構造は次のようになります。\n1 2 3 4 5 6 7 8 9 10 11 12 13 project/ ├── database/ // データベースパッケージ │ └── database.go // データベース接続 ├── handler/ // ハンドラパッケージ │ └── category.go // カテゴリ関連のインターフェース ├── model/ // データモデルパッケージ │ ├── category.go // カテゴリテーブルモデル │ └── response.go // レスポンスデータモデル ├── router/ // ルーティングパッケージ │ └── router.go // ルーティング設定 ├── utils // ツールキット │ └── response.go // 統合レスポンス ├── main.go // プログラムエントリ 次にディレクトリについて説明します\ndatabase このパッケージはデータベースへの接続を管理します\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 // database.go package database import ( \u0026#34;database/sql\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; _ \u0026#34;github.com/go-sql-driver/mysql\u0026#34; ) var DB *sql.DB func InitDB() { var err error dsn := \u0026#34;username:password@tcp(address:3306)/name?charset=utf8\u0026#34; DB, err = sql.Open(\u0026#34;mysql\u0026#34;, dsn) if err != nil { log.Fatalf(\u0026#34;Failed to open database: %v\u0026#34;, err) } // Test Connect err = DB.Ping() if err != nil { log.Fatalf(\u0026#34;Failed to ping database: %v\u0026#34;, err) } fmt.Println(\u0026#34;Successfully connected Database!\u0026#34;) } handler このパッケージは、特定の処理のロジック（3 層アーキテクチャの service に似ています）を処理して、データベース処理も階層化できます（Mapper に似ています）が、これは単なる簡単な例です、それだけです〜\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 // category.go package handler import ( \u0026#34;net/http\u0026#34; \u0026#34;project/database\u0026#34; \u0026#34;project/model\u0026#34; \u0026#34;project/utils\u0026#34; ) func GetCategories(w http.ResponseWriter, r *http.Request) { // Select Database rows, err := database.DB.Query(\u0026#34;select id,name from categories\u0026#34;) if err != nil { http.Error(w, \u0026#34;Failed to query Categories\u0026#34;, http.StatusInternalServerError) return } defer rows.Close() // analyze data var categories []model.Category for rows.Next() { var category model.Category err = rows.Scan(\u0026amp;category.Id, \u0026amp;category.Name) if err != nil { utils.JSONResponse(w, http.StatusInternalServerError, \u0026#34;Failed to analyze Categories\u0026#34;, nil) //http.Error(w, \u0026#34;Failed to analyze Categories\u0026#34;, http.StatusInternalServerError) return } categories = append(categories, category) } // return JSON //w.Header().Set(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;) //json.NewEncoder(w).Encode(categories) utils.JSONResponse(w, http.StatusOK, \u0026#34;\u0026#34;, categories) } コメントアウトされた内容は統合レスポンスインターフェースには適用されず、JSON が直接返されます。\nmodel ここでのデータモデルは、一般的にフロントエンドから受け取るもの、データベースから受け取るもの、フロントエンドに返すものの 3 つに分けられます。これは単純な例なので、細かくは説明していません。\n1 2 3 4 5 6 7 8 // category.go package model type Category struct { Id int `json:\u0026#34;id\u0026#34;` Name string `json:\u0026#34;name\u0026#34;` Description string `json:\u0026#34;description\u0026#34;` } 応答のデータモデルは\n1 2 3 4 5 6 7 package model type Response struct { Code int `json:\u0026#34;code\u0026#34;` Msg string `json:\u0026#34;msf\u0026#34;` Data interface{} `json:\u0026#34;data\u0026#34;` } router このパッケージはルーティング、つまり、どのパスにアクセスして対応する処理ロジックを指定するかを管理します（3 層アーキテクチャの controller に似ています）\n1 2 3 4 5 6 7 8 9 10 11 12 13 // router.go package router import ( \u0026#34;github.com/gorilla/mux\u0026#34; \u0026#34;project/handler\u0026#34; ) func InitRouter() *mux.Router { router := mux.NewRouter() router.HandleFunc(\u0026#34;/categories\u0026#34;, handler.GetCategories).Methods(\u0026#34;GET\u0026#34;) return router } utils このパッケージはツールクラスであり、一般的なツールを定義するために使用されます\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // response.go package utils import ( \u0026#34;encoding/json\u0026#34; \u0026#34;log\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;project/model\u0026#34; ) func JSONResponse(w http.ResponseWriter, code int, message string, data interface{}) { w.Header().Set(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json; charset=utf-8\u0026#34;) w.WriteHeader(http.StatusOK) err := json.NewEncoder(w).Encode(model.Response{Code: code, Msg: message, Data: data}) if err != nil { log.Fatal(err) return } } main プログラムエントリー\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // main.go package main import ( \u0026#34;log\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;project/database\u0026#34; \u0026#34;project/router\u0026#34; ) func main() { // init Database database.InitDB() // Init Router r := router.InitRouter() // start log.Println(\u0026#34;Starting server on port 8848\u0026#34;) log.Fatal(http.ListenAndServe(\u0026#34;:8848\u0026#34;, r)) } go run main.go を実行すると、プログラムはポート 8848 をリッスンします。\n","date":"2024-12-22T22:07:15+08:00","permalink":"https://blog.yexca.net/ja/archives/208/","title":"GoLang バックエンドを使い始める"},{"content":" この記事の一部は機械翻訳を使ったよ\nGolang シリーズ\nHello GoLang: https://blog.yexca.net/ja/ja/archives/154 GoLang (var and const) 変数と定数: https://blog.yexca.net/ja/ja/archives/155 GoLang (func) 関数: https://blog.yexca.net/ja/ja/archives/156 GoLang (slice and map) スライス: https://blog.yexca.net/ja/ja/archives/160 GoLang (OOP) オブジェクト指向: https://blog.yexca.net/ja/ja/archives/162 GoLang (reflect) リフレクション: https://blog.yexca.net/ja/ja/archives/204 GoLang (struct tag) 構造タグ: https://blog.yexca.net/ja/ja/archives/205 GoLang (goroutine) ゴルーチン: https://blog.yexca.net/ja/ja/archives/206 GoLang (channel) チャンネル: この記事\nゴルーチン (Goroutine) は channel を通じてデータを転送できます。参照型 channel は複数の Goroutine が通信するために使用できます。同時実行の安全性を確保するために、内部で同期を実装します。\nこれは、 RabbitMQ (簡体字中国語) に似ています (これは学習に便宜上の例えです、実は異なるものです)\n変数を定義する channel は参照型です。関数をコピーまたは呼び出すと、同じ channel オブジェクトが参照されます。ゼロ値は nil です。\nmake() 関数によって作成される。例えば\n1 2 3 c := make(chan int) // 容量を 3 に追加 c := make(chan int, 3) 容量が 0 の場合、channel はバッファリングされず、読み取りと書き込みがブロックされます。 容量が 0 より大きい場合、キャッシュがあり、非ブロッキングであり、いっぱいになるまでブロックされません。\nデータの送受信には \u0026lt;- を使用します\n1 2 3 4 5 6 7 8 // channel にデータを送信する channel \u0026lt;- 3 // 受信して破棄 \u0026lt;-channel // スペースがないことに注意してください // 値を受け取って変数に割り当てる x := \u0026lt;-channel // 受信して変数に割り当て、受信が成功したかどうか（channel が空かどうか）を判定します data, flag := \u0026lt;-channel バッファリングなし 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package main import \u0026#34;fmt\u0026#34; func main() { c := make(chan int) go func() { defer fmt.Println(\u0026#34;A.defer\u0026#34;) c \u0026lt;- 6 fmt.Println(\u0026#34;A running\u0026#34;) }() num := \u0026lt;-c fmt.Println(\u0026#34;num =\u0026#34;, num) fmt.Println(\u0026#34;main over\u0026#34;) } バッファリング 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { c := make(chan int, 3) go func() { defer fmt.Println(\u0026#34;A over\u0026#34;) for i := 0; i \u0026lt; 3; i++ { c \u0026lt;- i fmt.Println(\u0026#34;A goroutine, i =\u0026#34;, i, \u0026#34;len =\u0026#34;, len(c), \u0026#34;cap =\u0026#34;, cap(c)) } }() time.Sleep(2 * time.Second) for i := 0; i \u0026lt; 3; i++ { num := \u0026lt;-c fmt.Println(\u0026#34;main, num =\u0026#34;, num) } fmt.Println(\u0026#34;main over\u0026#34;) } channel を閉じる close() で閉じる\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package main import \u0026#34;fmt\u0026#34; func main() { c := make(chan int, 5) go func() { for i := 0; i \u0026lt; 5; i++ { c \u0026lt;- i } // 閉じる close(c) }() for { if data, ok := \u0026lt;-c; ok { fmt.Println(data) } else { break } } fmt.Println(\u0026#34;Main Finished\u0026#34;) } range の使用 上記の main の for ループは、range を使用して短縮することができます。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package main import \u0026#34;fmt\u0026#34; func main() { c := make(chan int, 5) go func() { for i := 0; i \u0026lt; 5; i++ { c \u0026lt;- i } close(c) }() //for { // if data, ok := \u0026lt;-c; ok { // fmt.Println(data) // } else { // break // } //} for data := range c { fmt.Println(data) } fmt.Println(\u0026#34;Main Finished\u0026#34;) } 一方向 channel デフォルトでは、channel は双方向、つまり読み取りと書き込みが可能です。チャネルの方向を読み取り専用または書き込み専用に指定することもできます。\n1 2 3 4 5 var c chan int // 通常の双方向チャネルを宣言する // c1 は書き込みのみ可能 var c1 chan\u0026lt;- int // c2 は読み取り専用です var c2 \u0026lt;-chan int 双方向チャネルを一方向チャネルに変換することは可能ですが、その逆はできません。つまり、関数パラメータを一方向として定義し、それを双方向に渡すことができます。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // chan\u0026lt;- // 書き込みのみ func counter(out chan\u0026lt;- int) { defer close(out) for i := 0; i \u0026lt; 5; i++ { out \u0026lt;- i // 相手が読んでいない場合はブロックします } } // \u0026lt;-chan // 読み取り専用 func printer(in \u0026lt;-chan int) { for num := range in { fmt.Println(num) } } func main() { c := make(chan int) // 双方向 go counter(c) // プロデューサー printer(c) // 消費者 fmt.Println(\u0026#34;done\u0026#34;) } select select は複数の channel 上のデータ フローを監視できます。構文は switch に似ていますが、各 case ステートメントには IO 操作が含まれている必要があります。\n通常は for{} コードブロック内に置く\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 package main import \u0026#34;fmt\u0026#34; func main() { c := make(chan int) quit := make(chan int) go func() { for i := 0; i \u0026lt; 10; i++ { fmt.Println(\u0026lt;-c) } quit \u0026lt;- 0 }() // main x, y := 1, 1 for { select { case c \u0026lt;- x: tmp := x x = y y = tmp + y case \u0026lt;-quit: fmt.Println(\u0026#34;quit\u0026#34;) return // デフォルトを設定することもできますが、この例では不要です } } } ","date":"2024-12-21T14:52:55+08:00","permalink":"https://blog.yexca.net/ja/archives/207/","title":"GoLang チャンネル"},{"content":" この記事の一部は機械翻訳を使ったよ\nGolang シリーズ\nHello GoLang: https://blog.yexca.net/ja/ja/archives/154 GoLang (var and const) 変数と定数: https://blog.yexca.net/ja/ja/archives/155 GoLang (func) 関数: https://blog.yexca.net/ja/ja/archives/156 GoLang (slice and map) スライス: https://blog.yexca.net/ja/ja/archives/160 GoLang (OOP) オブジェクト指向: https://blog.yexca.net/ja/ja/archives/162 GoLang (reflect) リフレクション: https://blog.yexca.net/ja/ja/archives/204 GoLang (struct tag) 構造タグ: https://blog.yexca.net/ja/ja/archives/205 GoLang (goroutine) ゴルーチン: この記事\nGoLang (channel) チャンネル: https://blog.yexca.net/ja/ja/archives/207 プロセス -\u0026gt; スレッド -\u0026gt; コルーチン\nコルーチン (coroutine) は軽量スレッドとも呼ばれます。システム リソースを使い果たすことなく、数万のコルーチンを簡単に作成できます。複数のコルーチンは、スレッドに割り当てられたコンピューター リソースを共有します。\nGo 言語は、ゴルーチン (goroutine) と呼ばれるコルーチンをネイティブにサポートしています。Go の並行性は、goroutine と channel を通じて実装されます。\ngoroutine を作成する go キーワードでゴルーチンを開始する\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func newTask() { i := 0 for { fmt.Println(\u0026#34;newTask goroutine i =\u0026#34;, i) i++ time.Sleep(1 * time.Second) } } func main() { go newTask() i := 0 for { fmt.Println(\u0026#34;main goroutine i =\u0026#34;, i) i++ time.Sleep(1 * time.Second) } } 匿名関数の使用 もちろん、匿名関数を使用することもできます\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { go func() { defer fmt.Println(\u0026#34;A.defer\u0026#34;) func() { defer fmt.Println(\u0026#34;B.defer\u0026#34;) fmt.Println(\u0026#34;B\u0026#34;) }() // 匿名関数の実行を示します fmt.Println(\u0026#34;A\u0026#34;) }() time.Sleep(2 * time.Second) } 匿名関数は戻り値に実体パラメータを持つこともできますが、goroutine の戻り値は channel を介して送信する必要があります。次の例では、実体パラメータのみを示しています。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { go func(a, b int) { fmt.Println(\u0026#34;a =\u0026#34;, a, \u0026#34;b =\u0026#34;, b) }(10, 20) time.Sleep(2 * time.Second) } 退出 メインの goroutine が終了すると、他の動作中の goroutine も自動的に終了します。\nただし、runtime.Goexit() を使用して、現在の goroutine の実行を直ちに終了することもできます (defer が実行されます)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;runtime\u0026#34; \u0026#34;time\u0026#34; ) func main() { go func() { defer fmt.Println(\u0026#34;A.defer\u0026#34;) func() { defer fmt.Println(\u0026#34;B.defer\u0026#34;) runtime.Goexit() // ゴルーチンを終了する fmt.Println(\u0026#34;B\u0026#34;) }() // 匿名関数の実行を示します fmt.Println(\u0026#34;A\u0026#34;) }() time.Sleep(2 * time.Second) } /* * 出力 * B.defer * A.defer */ ","date":"2024-12-17T21:16:31+08:00","permalink":"https://blog.yexca.net/ja/archives/206/","title":"GoLang ゴルーチン"},{"content":" この記事の一部は機械翻訳を使ったよ\nGolang シリーズ\nHello GoLang: https://blog.yexca.net/ja/ja/archives/154 GoLang (var and const) 変数と定数: https://blog.yexca.net/ja/ja/archives/155 GoLang (func) 関数: https://blog.yexca.net/ja/ja/archives/156 GoLang (slice and map) スライス: https://blog.yexca.net/ja/ja/archives/160 GoLang (OOP) オブジェクト指向: https://blog.yexca.net/ja/ja/archives/162 GoLang (reflect) リフレクション: https://blog.yexca.net/ja/ja/archives/204 GoLang (struct tag) 構造タグ: この記事\nGoLang (goroutine) ゴルーチン: https://blog.yexca.net/ja/ja/archives/206 GoLang (channel) チャンネル: https://blog.yexca.net/ja/ja/archives/207 構造タグはパッケージ内のクラスの役割を記述するために使用できます。\nタグの値を取得する tag を定義するには ` を使用します (markdown コードブロックのキー)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) type User struct { // 複数の tag はスペースで区切られます name string `doc:\u0026#34;name\u0026#34; info:\u0026#34;nameOfUser\u0026#34;` age int `info:\u0026#34;ageOfUser\u0026#34;` } func main() { user := User{\u0026#34;zhangSan\u0026#34;, 18} findTag(\u0026amp;user) } func findTag(input interface{}) { t := reflect.TypeOf(input).Elem() for i := 0; i \u0026lt; t.NumField(); i++ { tagInfo := t.Field(i).Tag.Get(\u0026#34;info\u0026#34;) tagDoc := t.Field(i).Tag.Get(\u0026#34;doc\u0026#34;) fmt.Println(\u0026#34;info:\u0026#34;, tagInfo, \u0026#34;doc:\u0026#34;, tagDoc) } } JSON 変換 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 package main import ( \u0026#34;encoding/json\u0026#34; \u0026#34;fmt\u0026#34; ) type User struct { // パブリックプロパティのみが JSON に変換できることに注意してください Name string `json:\u0026#34;name\u0026#34;` Age int `json:\u0026#34;age\u0026#34;` } func main() { user := User{\u0026#34;zhangSan\u0026#34;, 18} // struct --\u0026gt; json jsonStr, err := json.Marshal(user) if err != nil { fmt.Println(\u0026#34;error\u0026#34;, err) } else { fmt.Printf(\u0026#34;jsonStr : %s\\n\u0026#34;, jsonStr) } // json --\u0026gt; struct var user2 User err = json.Unmarshal(jsonStr, \u0026amp;user2) if err != nil { fmt.Println(\u0026#34;error\u0026#34;, err) } else { fmt.Println(user2) } } ","date":"2024-12-11T18:31:18+08:00","permalink":"https://blog.yexca.net/ja/archives/205/","title":"GoLang 構造タグ"},{"content":" この記事の一部は機械翻訳を使ったよ\nGolang シリーズ\nHello GoLang: https://blog.yexca.net/ja/ja/archives/154 GoLang (var and const) 変数と定数: https://blog.yexca.net/ja/ja/archives/155 GoLang (func) 関数: https://blog.yexca.net/ja/ja/archives/156 GoLang (slice and map) スライス: https://blog.yexca.net/ja/ja/archives/160 GoLang (OOP) オブジェクト指向: https://blog.yexca.net/ja/ja/archives/162 GoLang (reflect) リフレクション: この記事\nGoLang (struct tag) 構造タグ: https://blog.yexca.net/ja/ja/archives/205 GoLang (goroutine) ゴルーチン: https://blog.yexca.net/ja/ja/archives/206 GoLang (channel) チャンネル: https://blog.yexca.net/ja/ja/archives/207 反射指の一種の用途であり、自己記述と自己制御が可能です\npair Go 言語变量には type と value の部分が含まれ、pair で構成されます\nstatic type はコード実行時に見られるタイプであり、concrete type は runtime システムに見られるタイプです。\nこのタイプは、static type ではなく変数の concrete type に応じて成功するかどうかを判断します。したがって、concrete type が write メソッドの命令も実装している場合、タイプは write として承認される可能性があります。\n反射はタイプに基づいて確立され、静的タイプであり、固定されているため、反射は主に interface タイプに関係します (concrete type)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 package main import \u0026#34;fmt\u0026#34; type ReadBook interface { Read() } type WriteBook interface { Write() } type Book struct { } func (this *Book) Read() { fmt.Println(\u0026#34;read Book\u0026#34;) } func (this *Book) Write() { fmt.Println(\u0026#34;write Book\u0026#34;) } func main() { // b: pair\u0026lt;type:Book, value:book{} のアドレス\u0026gt; b := \u0026amp;Book{} // r: pair\u0026lt;type:, value:\u0026gt; var r ReadBook // r: pair\u0026lt;type:Book, value:book{} のアドレス\u0026gt; r = b r.Read() var w WriteBook w = r.(WriteBook) // r のタイプは Book であるため w.Write() } TypeOf と ValueOf Reflect.TypeOf() は pair 中の type を取得します、reflect.ValueOf() は pair 中の value を取得します\n1 2 3 4 5 6 7 8 9 10 11 12 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) func main() { a := 3.14 fmt.Println(\u0026#34;type of a:\u0026#34;, reflect.TypeOf(a)) // float64 fmt.Println(\u0026#34;value of a:\u0026#34;, reflect.ValueOf(a)) // 3.14 } 型转换 reflect.ValueOf() を実行すると、型が reflect.Value 变量になります。\n既知原データの種類 既知原データ型は直接强制转换可能\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) func main() { a := 3.14 fmt.Println(\u0026#34;type of a:\u0026#34;, reflect.TypeOf(a)) fmt.Println(\u0026#34;value of a:\u0026#34;, reflect.ValueOf(a)) value := reflect.ValueOf(a) fmt.Printf(\u0026#34;type of value:%T\\n\u0026#34;, value) // reflect.Value newA := value.Interface().(float64) fmt.Printf(\u0026#34;type of newA:%T\\n\u0026#34;, newA) // float64 } 型変換は完全に一貫している必要があることに注意することが重要です。そうでないと、ポインタなどの panic が発生します。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) func main() { a := 3.14 fmt.Println(\u0026#34;type of a:\u0026#34;, reflect.TypeOf(a)) fmt.Println(\u0026#34;value of a:\u0026#34;, reflect.ValueOf(a)) // 輸送先住所 point := reflect.ValueOf(\u0026amp;a) fmt.Printf(\u0026#34;type of value:%T\\n\u0026#34;, point) // reflect.Value // 型をポインタに変換する newA := point.Interface().(*float64) fmt.Printf(\u0026#34;type of newA:%T\\n\u0026#34;, newA) // *float64 } つまり、反射することができます \u0026ldquo;反射型オブジェクト\u0026rdquo; 再再再转换は \u0026ldquo;インターフェース変数\u0026rdquo;\n未知原データ型 Field を横断して取得\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) type Person struct { // 一行は 1 つの field です Name string Age int Rank float64 } // メソッドはパブリックであることに注意してください。プライベートの場合はアクセスできません。 func (person Person) Sleep() { fmt.Println(\u0026#34;person sleep\u0026#34;) } func main() { p := Person{\u0026#34;zhangSan\u0026#34;, 18, 5.2} getFieldAndMethod(p) } func getFieldAndMethod(input interface{}) { getType := reflect.TypeOf(input) fmt.Println(\u0026#34;type:\u0026#34;, getType.Name()) getValue := reflect.ValueOf(input) fmt.Println(\u0026#34;value/AllField:\u0026#34;, getValue) // 属性を取得します numField := getValue.NumField() for i := 0; i \u0026lt; numField; i++ { fieldType := getType.Field(i) fieldValue := getValue.Field(i).Interface() fmt.Printf(\u0026#34;%s: %v = %v\\n\u0026#34;, fieldType.Name, fieldType.Type, fieldValue) } // メソッドを取得します numMethod := getType.NumMethod() for i := 0; i \u0026lt; numMethod; i++ { method := getType.Method(i) fmt.Printf(\u0026#34;%s: %v\\n\u0026#34;, method.Name, method.Type) } } reflect.Value による割り当て 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) func main() { a := 3.14 // ポインタの場合のみ割り当て可能 pointer := reflect.ValueOf(\u0026amp;a) // 元の値を取得するためのアドレスを設定します newValue := pointer.Elem() // 値が設定可能かどうかをチェックする fmt.Println(\u0026#34;value canSet:\u0026#34;, newValue.CanSet()) if newValue.CanSet() { // 設定できる場合 newValue.SetFloat(9.96) // 変数の値を表示 fmt.Println(\u0026#34;value of a:\u0026#34;, a) // 9.96 } else { fmt.Println(\u0026#34;error\u0026#34;) } } reflect.Value 経由でメソッドを呼び出す 関数名による呼び出し\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) type User struct { name string age int } func (user User) MethodHasArgs(a string, b int) { fmt.Println(\u0026#34;User MethodHasArgs\u0026#34;) } func (user User) MethonNotArgs() { fmt.Println(\u0026#34;User MethodNotArgs\u0026#34;) } func main() { user := User{\u0026#34;zhangSan\u0026#34;, 18} value := reflect.ValueOf(user) // 関数名で呼び出す method1 := value.MethodByName(\u0026#34;MethodHasArgs\u0026#34;) // ビルドパラメータ args1 := []reflect.Value{reflect.ValueOf(\u0026#34;string\u0026#34;), reflect.ValueOf(18)} // 関数の呼び出し method1.Call(args1) // パラメータなしで呼び出す method2 := value.MethodByName(\u0026#34;MethonNotArgs\u0026#34;) args2 := make([]reflect.Value, 0) method2.Call(args2) } リフレクションの基本原則 ","date":"2024-12-03T14:07:18+08:00","permalink":"https://blog.yexca.net/ja/archives/204/","title":"GoLang リフレクション"},{"content":" 📢 この記事は gemini-2.5-flash によって翻訳されました 問題一： https://blog.yexca.net/ja/archives/198 問題二： https://blog.yexca.net/ja/archives/201 問題三： https://blog.yexca.net/ja/archives/200 問題四： https://blog.yexca.net/ja/archives/202 問題五：この記事\nはじめに もう2週間近く経ったかな、やっとこの問題用紙全部見終わったよ。効率悪すぎだよね。全体的に見てどうかな。中国の408試験よりは全体的な難易度は少し低いけど、試験のスタイルや重点が違うから、具体的に比較するのはちょっと難しいね。次こそはもう少し効率良くできるといいな。\n雑談 そういえば最近、雑談あんまり書いてないな。これって、記事を投稿しようって思うときにはもうヘトヘトで、書く気力がないからなんだよね。そういえば、昔は何かを学ぶかどうかだけを考えてたけど、今は時間とか体力とかも計算に入れなきゃいけないんだって思うようになったよ。最近見たネタなんだけど、\n公務員試験も、選抜採用も、国家試験も、地方公務員試験も、教員免許も、留学も、インターンも、面接も、正社員登用も、就職活動も、卒業制作も、恋愛も、全部やればいいじゃん。でもまだ切り札は隠しておかないとね、中国人は何事も一手残すのが美学だから。\nこれ、すごく心に響いたよ。人間のエネルギーって限りがあるから、何かを得るためには必ず何かを失うんだよね。時間とか、体力とか、情熱とかさ。これらって実は全部数値化できる変数なんだけど、昔はそういう変数の上限が自分の活動よりもずっと大きくて、気づいてなかっただけなんだ（もちろん、消耗とか他の変換って可能性もあるから、念のため補足しとくね）。年齢を重ねるにつれて、経験とか見るものが増えていくと、だんだん考慮すべき変数が多くなってきて、そのせいで毎日すごく疲れて効率も悪くなってるんだろうな。\n時々、生きるってすごく疲れるよね。もしかしたら僕が唯物論的すぎるのかもしれないな。もっと唯心論的に考えれば、世界はもっと素敵なはずだ（もう何事に対しても断定的な表現はできないな、不確実性が怖いんだ。でも人生って往々にして不確実なもので、それは変数を把握できてないからなんだけど、これ以上は広げないでおこう、また長くなっちゃうからね）。\n背景 図５.１のように構成された、$ck$ を入力とし $z_2,z_1,z_0$ を出力とする論理回路Xを考える。ここで $R_0,R_1,R_2$ はポジティブエッジトリガ型（前縁トリガ型）Dフリップフロップであり、初期化時の出力は０とする。またF は $x_2,x_1,x_0$ を入力とし $y_2,y_1,y_0$ を出力とする論理回路であり、図５.２のように構成されている。AおよびBは図5.3に示されている2入力ゲートのいずれかとする。回路Xの入力 $ck$ に1単位時間を周期とするクロックパルスを与える。以下 $n$ を正整数、$t$ を時刻とする。時刻 $t=0$ において $R_0,R_1,R_2$ は初期化されており、時刻0以降 $n$ 個目のクロックパルスの立ち上がりによる出力が時刻 $t=n$ において $z_2,z_1,z_0$ に安定して得られるとする。この様子を図5.4に示す。以降、回路の構成要素（ゲート、フリップフロップおよび配線）による遅延はクロックパルスの周期と比較して十分小さく無視できるとする。\n図5.1：論理回路X 図5.2：論理回路F 図5.3：2入力ゲート 図5.4：回路Xの動作 1 以下の問い a~f に答えよ。\na）回路Fの出力 $y_2,y_1,y_0$ は入力 $x_2,x_1,x_0$ の値のみで決まる。このような動作を行う回路の名称として最も適切なものを以下の選択肢から一つ選べ。\nア　非同期回路\nイ　組み合わせ回路\nウ　順序回路\nエ　非線形回路\nb）時刻 $t=n$ における回路Xの出力 $z_2,z_1,z_0$ は、時刻 $t=$ アにおける $y_2,y_1,y_0$ の値それぞれと等しい。アを $n$ の式として表せ。\nc）回路Xが図5.4に示すような動作をするための、回路Fの動作を表す真理値表を図5.5に示す表形式で完成させよ。\n図5.5：回路Fの動作 d）図5.4のような動作を行う回路の名称として最も適切なものを以下の選択肢から一つ選び記号①～④で答えよ。\n①デコーダ ②マルチプレクサ ③カウンタ ④シフトレジスタ\ne）回路Ｘを図5.4のように動作させるためには図5.2のＡおよびＢにはそれぞれ何が入るか。図5.3から選び記号①～⑥で答えよ。同一のゲートを複数回用いてもよい。\nf）論理変数 $x$ と $y$ の論理積（AND）を $xy$、論理和（OR）を $x+y$、$x$ の否定（NOT）を $\\bar{x}$ と表記する。回路Fの出力 $y_2$ を\n1-解答 1-a 非同期回路はクロック信号を使わず、各部分が独立して動作する回路を指します。 組み合わせ回路は、出力が入力の現在の値だけで決まる回路です。 順序回路は、出力が現在の入力だけでなく、内部の状態（フリップフロップの出力など）にも依存します。 非線形回路は、入力と出力の関係が線形でない特性を持つ回路を指します。 この問題は明らかに「組み合わせ回路」だね。\n1-b Dフリップフロップはまず入力を受け取って、クロックの立ち上がりエッジでのみ出力するから、状態更新の同期性によって、Dフリップフロップは1周期分の遅延をもたらすんだ。だからアは $n-1$ になるね。\n1-c x_2 x_1 x_0 y_2 y_1 y_0 0 0 0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 1 0 1 1 1 0 0 1 0 0 1 0 1 1 0 1 1 1 0 1 1 0 1 1 1 1 1 1 0 0 0 1-d デコーダ（Decoder）：デコーダは、少ない入力信号を多数の出力信号にデコードする組み合わせ論理回路だよ。入力のバイナリコードに基づいて、対応する出力線をアクティブにするんだ。 マルチプレクサ（Multiplexer）：マルチプレクサは、複数の入力信号から一つを選んで出力する組み合わせ論理回路だよ。選択信号（Select Lines）を使って、どの入力信号を出力に通すか決めるんだ。 カウンタ（Counter）：カウンタは、パルス信号を数えるための順序論理回路だよ。パルス信号の数に応じて、カウンタの出力値が特定の方法で変わるんだ。 シフトレジスタ（Shift Register）：シフトレジスタは、データを保存して、一定の方向にデータを移動させることができる順序論理回路だよ。一連のフリップフロップで構成されているんだ。 この問題は明らかに「シフトレジスタ」だね。\n1-e A: ② (OR) B: ① (AND)\n真理値表と回路を使って分析するね。出力が複数あるから、一つずつ見ていけばいいよ。$y_0$ の回路はもう決まってるから、まず $y_1$ の出力が1になるときの入力を見てみよう。\n$x_2$ $x_1$ $x_0$ 0 0 1 0 1 0 1 0 1 1 1 0 回路を分析すると、入力 $x_2$ は一時的に無視できるよ（回路や次の問題から、簡略化後に $x_2$ がなくなるのがわかる）。\nそれから、1になる入力を代入して試してみたら、AがORゲートで、BがANDゲートだとわかったよ。\n$y_2$ の出力が1になる入力で検証したら、結果は正しかったよ。\n1-f $$ \\begin{align} y_2\u0026=\\bar{x_2}\\bar{x_1}x_0+\\bar{x_2}x_1\\bar{x_0}+x_2\\bar{x_1}x_0+x_2x_1\\bar{x_0} \\\\ \u0026= \\bar{x_2}(\\bar{x_1}x_0+x_1\\bar{x_0})+x_2(\\bar{x_1}x_0+x_1\\bar{x_0}) \\\\ \u0026= \\bar{x_1}x_0+x_1\\bar{x_0} \\end{align} $$2 図5.6に示すGは $x_2,x_1,x_0$ を入力とし $y_2,y_1,y_0$ を出力とする論理回路である。Gを用いて、$ck$ を入力とし $z_2,z_1,z_0$ を出力とする論理回路Yを図5.7のように構成する。さらにYを用いて図5.8に示す論理回路 $X'$ を構成する。図5.8のCおよびDは図5.3に示されている2入力ゲートのいずれかである。以下の問い a~e に答えよ。\n図5.6：論理回路G\n図5.7：論理回路Y\n図5.8：論理回路 $X'$\n図5.9：回路Yの動作\na）回路Gでは出力 $y_0$ を得るためにゲートを5個用いている。図5.3に挙げたゲート2個以下を用いてGにおける $y_0$ と同じ出力を得ることができる回路を一つ記せ。\nb）回路Yの入力 $ck$ に1単位時間を周期とするクロックパルスを与える。時刻 $t=0$ において $R_0,R_1,R_2$ は初期化されているとし、時刻0以降のｎ個目のクロックパルスの立ち上がりによる出力が時刻 $t=n$ において $z_2,z_1,z_0$ に安定して得られるとする。時刻 $t=1,4,7,12$ における回路Ｙの出力 $z_2,z_1,z_0$ を図5.9に示す表形式で完成させよ。\nc）ｍを非負整数とする。上記ｂ）で示した条件下での時刻 $t=m$ における回路Ｙの出力の組 $(z_2,z_1,z_0)$ をベクトルとみなし $z(m)$ と表記する。$z(m)$ と $z(m+1)$ のハミング距離の最大値を答えよ。\nd）図5.8の回路X’と図5.1の回路Xは同等のふるまいを示す。このとき図5.8のCおよびDに入るゲートを図5.3から選び、記号①～⑥で答えよ。同一のゲートを複数回用いてもよい。ここで同等のふるまいとは以下のことという。X’とXそれぞれの入力 $ck$ に図5.10のように同一のパルス発生源Ｐから1単位時間を周期とするクロックパルスを与える。時刻 $t=0$ においてX’およびX内のDクロックパルスの立ち上がりによる出力が時刻 $t=n$ において $w_2,w_1,w_0$ および $z_2,z_1,z_0$ それぞれに安定して得られているとき、 $w_2=z_2$ かつ $w_1=z_1$ かつ $w_0=z_0$ である。\n図5.10 e）図5.11のような論理回路を考える。時刻 $t=t_0$ において入力ｘとｙが0から1に同時に変化したとする。このとき出力ｚは0のまま変化しないことが期待されるが、NOT ゲートにおける遅延が原因で図5.12に示すようなパルスが生じることがある。この現象はグリッチ（あるいはハザード）と呼ばれ、接続される回路によっては誤動作の原因となり得る。図5.8の回路Ｘ’において、ゲートＣ、Ｄにおける遅延が無視できない場合に出力 $w_0$ においてグリッチが発生し得るか否かを述べ、発生し得るなら対策方法を、発生しないならその理由を100文字以内で記せ。ただし回路Ｙの構成要素（ゲート、フリップフロップおよび配線）による遅延は無視できるものとし、$R_0,R_1,R_2$ それぞれの出力は同時に変化するものとする。\n図5.11：グリッチを生じ得る論理回路の例\n図5.12：グリッチの例\n2-解答 2-a 回路を分析すると $y_0=x_1x_2+\\bar{x_1}\\bar{x_2}$ だから、これは $x_1\\ \\text{XNOR}\\ x_2$ と等価だね。だからXNORゲートを一つ使うだけで回路を簡略化できるよ。\n⑥だけ使用することができる。\n2-b t $x_0$ $x_1$ $x_2$ $y_0$ $y_1$ $y_2$ 0 0 0 0 1 0 0 1 1 0 0 1 1 0 2 1 1 0 0 1 0 3 0 1 0 0 1 1 4 0 1 1 1 1 1 5 1 1 1 1 0 1 6 1 0 1 0 0 1 7 0 0 1 0 0 0 8 0 0 0 1 0 0 9 1 0 0 1 1 0 10 1 1 0 0 1 0 11 0 1 0 0 1 1 12 0 1 1 1 1 1 $t=7$ からループしてるのがわかるね。\n2-c ハミング距離は、同じ長さの二つのバイナリベクトルで、異なるビットの数を示すものだよ。\n上の真理値表から見ると、最大値は1だね。\n2-d C: ③ (XOR) D: ③ (XOR)\n二つの回路のタイミングチャートを分析すると、真理値表が得られるよ。\n$z_0$ $z_1$ $z_2$ $w_0$ $w_1$ $w_2$ 1 0 0 1 0 0 1 1 0 0 1 0 0 1 0 1 1 0 0 1 1 0 0 1 1 1 1 1 0 1 1 0 1 0 1 1 0 0 1 1 1 1 0 0 0 0 0 0 回路を分析するんだけど、まず $w_1$ を見て、$w_1$ が1になる入力を探してみよう。\n$z_0$ $z_1$ $z_2$ 1 1 0 0 1 0 1 0 1 0 0 1 回路から $z_0$ は無視できることがわかるよ。残りの $z_1$ と $z_2$ は異なる入力で1を出力する形、つまりXORゲートの形をしてるから、DはXORゲートだね。\n$w_0$ が1になる入力を分析しよう。\n$z_0$ $z_1$ $z_2$ $z_1 \\oplus z_2$ 1 0 0 0 0 1 0 1 1 1 1 0 0 0 1 1 回路から、$z_0$ と $z_1 \\oplus z_2$ を直接見ると、異なる入力で1を出力する形、つまりXORゲートの形をしてるから、CはXORゲートだね。\n2-e $w_0$ にグリッチが発生する可能性があるね。対策としては、出力にバッファを追加するか、同期フリップフロップを追加するか、それか回路設計を見直すのがいいと思うよ。\n参考記事 論理代数の簡略化（公式法とカルノー図法） ","date":"2024-12-01T18:15:28+08:00","permalink":"https://blog.yexca.net/ja/archives/203/","title":"東京科学大学大学院情報理工学研究科 2020 問題五 / 科学大院理工学 2020 問題五"},{"content":" 📢 この記事は gemini-3-flash-preview によって翻訳されました 問題一： https://blog.yexca.net/ja/archives/198 問題二： https://blog.yexca.net/ja/archives/201 問題三： https://blog.yexca.net/ja/archives/200 問題四：この記事\n問題五： https://blog.yexca.net/ja/archives/203 はじめに まるまる一問、ラプラス変換についての出題だね。最後の一問は応用問題になっているよ。ラプラス変換を知らないと素早く解くのはかなり難しいかな。解くスピードが速ければ、最初の二大問と第三問の前の3つの設問まではいけるかもしれないけど（それだけでも結構な量だけどね）、最後の二問については、関連する原理を知らないとお手上げになっちゃう（最後の一問は、原理を知らない場合にどう解くか書いてみたけど、試験本番のあの状況で本当に思いつけるかな？）。\n問題の著作権は東京科学大学に帰属するよ。ここでは見やすさを考慮して引用しているだけで、営利目的ではないからね。\n背景 実数 $t(\\ge0)$ を変数とする2回微分可能な実関数 $f(t)$ のラプラス変換 $F(S)=\\mathcal{L}[f(t)]$ を次式で定義する。\n$$ F(s)=\\mathcal{L}[f(t)]=\\int_0^\\infty f(t)e^{-st}dt \\tag{4.1} $$ここで、ｓは複素変数で、かつ実部が正であるとする。以下の問いに答えよ。なお、解答にあたって、次のラプラス変換に関する関係式を用いてもよい。\n$$ \\mathcal{L}[e^{-\\alpha t}f(t)] = F(s+\\alpha) \\tag{4.2} $$$$ \\mathcal{L}[\\frac{\\mathrm{d}}{\\mathrm{d}t}f(t)] = sF(s) - f(0) \\tag{4.3} $$$$ \\mathcal{L}[\\frac{\\mathrm{d}^2}{\\mathrm{d}t^2}f(t)] = s^2F(s)-sf(0)-f'(0) \\tag{4.4} $$ただし、$\\alpha$ は実定数とし、$f'(t)=\\frac{\\mathrm{d}}{\\mathrm{d}t}f(t)$ とする。\nこのセクションでは、ラプラス変換の定義と3つの性質について記述されているよ。\n1 以下の a~c の式が成り立つことを示せ。ただし、$\\alpha$ は実定数、$\\beta$ は０ではない実定数とする。\na）$\\mathcal{L}[\\cos(\\beta t)]=\\dfrac{s}{s^2+\\beta^2}$\nb）$\\mathcal{L}[e^{-\\alpha t}\\cos(\\beta t)] = \\dfrac{s+\\alpha}{(s+a)^2+\\beta^2}$\nc）$\\mathcal{L}[e^{-\\alpha t}\\sin(\\beta t)]=\\dfrac{\\beta}{(s+a)^2+\\beta^2}$\n解答 a 定義に代入するよ。\n$$ \\mathcal{L}[\\cos(\\beta t)] = \\int_0^\\infty \\cos(\\beta t)e^{-3t}\\mathrm{d}t $$ここでオイラーの公式\n$$ e^{i\\theta}=\\cos\\theta + i\\sin\\theta $$から導かれる\n$$ \\cos\\theta=\\frac{e^{i\\theta}+e^{-i\\theta}}{2} $$を使うね。\n証明は簡単、直接代入するだけだよ。\n$$ \u003e\\begin{align} \u003e\\cos\\theta \u003e\u0026= \\frac{e^{i\\theta}+e^{-i\\theta}}{2} \\\\ \u003e\u0026= \\frac{(\\cos\\theta + i\\sin\\theta)+(\\cos(-\\theta) + i\\sin(-\\theta))}{2} \\\\ \u003e\u0026= \\frac{(\\cos\\theta + i\\sin\\theta)+(\\cos\\theta - i\\sin\\theta)}{2} \\\\ \u003e\u0026= \\frac{2\\cos\\theta }{2} \\\\ \u003e\u0026= \\cos\\theta \u003e\\end{align} \u003e$$ 元の式に代入すると、\n$$ \\begin{align} \\mathcal{L}[\\cos(\\beta t)] \u0026=\\int_0^\\infty\\frac{e^{i\\beta t}+e^{-i\\beta t}}{2}e^{-st}\\mathrm{d}t \\\\ \u0026= \\frac{1}{2}(\\int_0^\\infty e^{i\\beta t} \\cdot e^{-st}\\mathrm{d}t+\\int_0^\\infty e^{-i\\beta t} \\cdot e^{-st}\\mathrm{d}t) \\\\ \u0026= \\frac{1}{2}(\\int_0^\\infty e^{-(i\\beta t + st)}\\mathrm{d}t + \\frac{1}{2}(\\int_0^\\infty e^{-(i\\beta t + st)}\\mathrm{d}t) \\end{align} $$積分を計算すると、\n$$ \\begin{align} \\mathcal{L}[\\cos(\\beta t)] \u0026= \\frac{1}{2}(\\frac{1}{s-i\\beta}+\\frac{1}{s+i\\beta}) \\end{align} $$ ここでの積分過程：\n$$ \u003e\\begin{align} \u003e\\int_0^\\infty e^{-at}\\mathrm{d}t \u003e\u0026= \\frac{1}{-a}e^{-at}\\mid_0^\\infty \\\\ \u003e\u0026= 0-\\frac{1}{-a} \\\\ \u003e\u0026= \\frac{1}{a} \u003e\\end{align} \u003e$$ 通分して整理すると、\n$$ \\begin{align} \\mathcal{L}[\\cos(\\beta t)] \u0026= \\frac{1}{2} \\cdot \\frac{s+i\\beta+s-i\\beta}{(s-i\\beta)(s+i\\beta)} \\\\ \u0026= \\dfrac{s}{s^2+\\beta^2} \\end{align} $$元の命題が示された。\nb $(4.2)$ より\n$$ \\mathcal{L}[e^{-\\alpha t}f(t)] = F(s+\\alpha) $$また a の結果より\n$$ \\mathcal{L}[\\cos(\\beta t)]=\\dfrac{s}{s^2+\\beta^2} $$なので、\n$$ \\mathcal{L}[e^{-\\alpha t}\\cos(\\beta t)] = \\dfrac{s+\\alpha}{(s+a)^2+\\beta^2} $$元の命題が示された。\nc $$ \\frac{\\mathrm{d}}{\\mathrm{d}t}\\sin(\\beta t) = \\beta \\cos(\\beta t) $$なので、両辺のラプラス変換をとると\n$$ \\mathcal{L}[\\frac{\\mathrm{d}}{\\mathrm{d}t}\\sin(\\beta t)] = \\mathcal{L}[\\beta \\cos(\\beta t)] $$$(4.3)$ より\n$$ \\mathcal{L}[\\frac{\\mathrm{d}}{\\mathrm{d}t}f(t)] = sF(s) - f(0) $$だから、\n$$ \\mathcal{L}[\\frac{\\mathrm{d}}{\\mathrm{d}t}\\sin(\\beta t)] = sF(s)-\\sin(0)=sF(s) $$つまり\n$$ sF(s) = \\mathcal{L}[\\beta \\cos(\\beta t)] = \\beta \\mathcal{L}[\\cos(\\beta t)] $$a の結果より\n$$ \\mathcal{L}[\\cos(\\beta t)]=\\dfrac{s}{s^2+\\beta^2} $$これを代入すると、\n$$ sF(s) = \\beta \\dfrac{s}{s^2+\\beta^2} $$解くと、\n$$ F(s) = \\dfrac{\\beta}{s^2+\\beta^2} $$よって\n$$ \\mathcal{L}[\\sin(\\beta t)] = \\dfrac{\\beta}{s^2+\\beta^2} $$ 書き終わってから思い出したんだけど、最初に考えていた別の簡単な方法も使えたね。ちょっと勘違いしてたけど、こっちの方がシンプルかも。でも上の解き方の方がかっこいい気がするから、そのまま残しておくよ。一応、簡単に説明しとくね。\n$$ \u003e \\begin{align} \u003e \\mathcal{L}[\\frac{\\mathrm{d}}{\\mathrm{d}t}\\cos(\\beta t)] \u003e \u0026= \\mathcal{L}[-\\beta\\sin(\\beta t)]\\\\ \u003e \u0026= -\\beta \\mathcal{L}[\\sin(\\beta t)]\\\\ \u003e \u0026= sF(s) - \\cos(0) \\\\ \u003e \u0026= \\dfrac{s^2}{s^2+\\beta^2} - 1 \\\\ \u003e \u0026= \\dfrac{-\\beta^2}{s^2+\\beta^2} \u003e \\end{align} \u003e $$つまり\n$$ \u003e \\mathcal{L}[\\sin(\\beta t)] = \\dfrac{\\beta}{s^2+\\beta^2} \u003e $$ほぼ3通りの方法で解けたことになるね（あともう一つは a と同じように直接計算する方法）。解けたときはめちゃくちゃ気持ちよかった！\n$(4.2)$ より\n$$ \\mathcal{L}[e^{-\\alpha t}f(t)] = F(s+\\alpha) $$なので、\n$$ \\mathcal{L}[e^{-\\alpha t}\\sin(\\beta t)]=\\dfrac{\\beta}{(s+a)^2+\\beta^2} $$2 次の微分方程式について、以下の a~d に答えよ。\n$$ \\frac{\\mathrm{d}^2}{\\mathrm{d}t^2}f(t) + \\eta \\frac{\\mathrm{d}}{\\mathrm{d}t}f(t) + 2f(t) = 2 \\tag{4.5} $$ここで、$\\eta$ は実定数、$f(t)$ は実数 $t(\\ge 0)$ を変数とする2回微分可能な実関数とし、初期条件を $f(0)=1, f'(0)=1$ とする。ただし、$f'(t)=\\frac{\\mathrm{d}}{\\mathrm{d}t}f(t), F(s)=\\mathcal{L}[f(t)]$ とする。\na）微分方程式 $(4.5)$ の両辺をラプラス変換し、$F(s)$ を $s$ の関数として表せ。\nb）$\\eta=0$ のとき、ラプラス変換を用いて微分方程式 $(4.5)$ を解き、$f(t)$ を $t$ の関数として表せ。\nc）$\\eta=2$ のとき、ラプラス変換を用いて微分方程式 $(4.5)$ を解き、$f(t)$ を $t$ の関数として表せ。\nd）$\\eta=2$ のとき、$\\lim_{t \\to \\infty}f(x)$ の値を求め、$f(t)$ のグラフの概形を描け。\n解答 a $(4.3), (4.4)$ に基づいて両辺のラプラス変換をとると、\n$$ s^2F(s)-sf(0)-f'(0)+\\eta(sF(s)-f(0))+2F(s)=\\frac{2}{s} $$整理すると、\n$$ (s^2+\\eta s+2)F(s) = \\frac{2}{s}+s+\\eta+1 $$よって\n$$ F(s)=\\frac{\\frac{2}{s}+s+\\eta+1}{s^2+\\eta s +2} $$b $\\eta=0$ を代入すると、\n$$ \\begin{align} F(s)\u0026=\\frac{\\frac{2}{s}+s+1}{s^2+2} \\\\ \u0026=\\frac{s^2+s+2}{s(s^2+2)} \\end{align} $$ここで\n$$ \\frac{s^2+s+2}{s(s^2+2)} = \\frac{A}{s} + \\frac{Bs+C}{s^2+2} = \\frac{A(s^2+2)+s(Bs+C)}{s(s^2+2)} $$と置くと、\n$$ \\left \\{ \\begin{align} A+B = 1 \\\\ C = 1 \\\\ 2A = 2 \\end{align} \\right . $$となり、$A=1, B=0, C=1$ が得られる。これを代入すると、\n$$ F(s) = \\frac{1}{s} + \\frac{1}{s^2+2} $$逆ラプラス変換を行うと、\n$$ f(t) = 1 + \\frac{1}{\\sqrt{2}}\\sin(\\sqrt{2}t) $$c $\\eta=2$ を代入すると、\n$$ F(s)=\\frac{\\frac{2}{s}+s+3}{s^2+2s +2} = \\frac{2+s^2+3s}{s(s^2+2s +2)} $$ここで\n$$ \\frac{2+s^2+3s}{s(s^2+2s +2)} = \\frac{A}{s} + \\frac{Bs+C}{s^2+2s +2} = \\frac{A(s^2+2s+2)+s(Bs+C)}{s(s^2+2s +2)} $$と置くと、\n$$ \\left \\{ \\begin{align} A+B = 1 \\\\ 2A+C = 3 \\\\ 2A = 2 \\end{align} \\right . $$となり、$A=1, B=0, C=1$ が得られる。よって\n$$ F(s) = \\frac{1}{s} + \\frac{1}{s^2+2s+2} = \\frac{1}{s} + \\frac{1}{(s+1)^2+1} $$逆ラプラス変換を行うと、\n$$ f(t) = 1 + e^{-t}\\sin t $$d c より、$\\eta=2$ のとき\n$$ f(t) = 1 + e^{-t}\\sin t $$つまり\n$$ \\lim_{t \\to \\infty} f(t) = \\lim_{t \\to \\infty} (1 + e^{-t}\\sin t) = 1 $$また、\n$$ f(0) = 1+e^0\\sin0 = 1 $$なので、$f(t)$ のグラフは 1 から始まり、振動しながら減衰して最終的に 1 に収束するような形になるね。\n振動しながら $t \\to \\infty$ において1に収束します。（これは減衰振動の典型的な形状です）\n具体的なグラフは以下の通りだよ。\nコードはこんな感じ（Linux の GUI なし環境を使っているから、画像を保存するためのコードを数行追加してあるよ）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 import matplotlib as mpl # グラフ表示用 import numpy as np import matplotlib.pyplot as plt mpl.use(\u0026#39;Agg\u0026#39;) # GUIなし環境での設定 # 関数 f(t) = 1 + e^(-t) * sin(t) の定義 t = np.linspace(0, 10, 1000) # 時間範囲 [0, 10] f_t = 1 + np.exp(-t) * np.sin(t) # グラフの描画 plt.figure(figsize=(8, 5)) plt.plot(t, f_t, label=r\u0026#34;$f(t) = 1 + e^{-t}\\sin(t)$\u0026#34;, color=\u0026#39;b\u0026#39;) plt.axhline(y=1, color=\u0026#39;r\u0026#39;, linestyle=\u0026#39;--\u0026#39;, label=r\u0026#34;$f(t) \\to 1$ (limit value)\u0026#34;) # グラフの装飾 plt.title(r\u0026#34;Function $f(t) = 1 + e^{-t}\\sin(t)$\u0026#34;, fontsize=14) plt.xlabel(\u0026#34;$t$\u0026#34;, fontsize=12) plt.ylabel(\u0026#34;$f(t)$\u0026#34;, fontsize=12) plt.legend(fontsize=10) plt.grid(alpha=0.3) plt.tight_layout() # グラフの表示 plt.show() # 画像の保存 plt.savefig(\u0026#34;./1.png\u0026#34;) 3 図４.１に示した1自由度のバネ-質量-ダンパ系の微分方程式は次式で表せる。\n$$ m\\frac{\\mathrm{d}^2}{\\mathrm{d}t^2}x(t)+\\mu \\frac{\\mathrm{d}}{\\mathrm{d}t}x(t)+kx(t)=p(t) \\tag{4.6} $$ただし、位置 $x(t)$ および外力 $p(t)$ は時刻 $t(\\ge 2)$ の2回微分可能な実関数である。位置 $x(t)$ の原点はバネの自然長の位置とし、位置 $x(t)$ と外力 $p(t)$ の正の方向はバネガ伸びる方向とする。質量 $m$、バネ定数 $k$、ダンバの粘性減衰係数 $\\mu$ は正の定数とする。以下では、式 $(4.6)$ の係数の書き換えによって得られた次式を用いて考える。\n$$ \\frac{\\mathrm{d}^2}{\\mathrm{d}t^2}x(t)+2\\gamma\\omega_0\\frac{\\mathrm{d}}{\\mathrm{d}t}x(t)+w_0^2x(t)=q(t) \\tag{4.7} $$ただし、$\\omega_0=\\sqrt{k/m}, \\gamma=\\mu/(2\\sqrt{mk}),q(t)=p(t)/m$ と定義した。また、$X(s)=\\mathcal{L}[x(t)], Q(s)=\\mathcal{L}[q(t)]$ とする。初期条件を $x(0)=0, x'(0)=0$ とする。$x'(t)=\\frac{\\mathrm{d}}{\\mathrm{d}t}x(t)$ である。このとき、以下の a~e に答えよ。\n図４.１：1自由度のバネ-質量-ダンパ系 a）式 $(4.7)$ の両辺をラプラス変換して、伝達関数 $H(s)=X(s)/Q(s)$ を計算し、$H(s)$ を $\\gamma, \\omega_0$ を用いて $s$ の関数として表せ。\nb）伝達関数 $H(s)$ において、$s$ を $i\\omega$ に置き換えることにより、$Y(\\omega)=20\\log_{10}\\mid H(i\\omega)\\mid$ を計算し、$Y(\\omega)$ を $\\omega$ の実関数として表せ。ただし、$\\omega$ は正の実数、$i$ は虚数単位とする。\nc）$Y(\\omega)$ が最大となるときの $\\omega$ の値を $\\hat{\\omega}$ とする。$\\hat{\\omega}$ を $\\gamma, \\omega_0$ を用いて表せ\nd）$Y(\\omega)$ が $\\omega=\\hat{\\omega}$ で最大になるという現象は何と呼ばれるか、答えよ。\ne）d の現象が起こる $\\gamma$ の範囲を答えよ。\n解答 a 両辺を同時にラプラス変換すると、\n$$ \\mathcal{L}[\\frac{\\mathrm{d}^2}{\\mathrm{d}t^2}x(t)]+2\\gamma\\omega_0\\mathcal{L}[\\frac{\\mathrm{d}}{\\mathrm{d}t}x(t)]+w_0^2\\mathcal{L}[x(t)]=\\mathcal{L}[q(t)] $$$(4.3),(4.4)$ および問題の条件から、\n$$ s^2X(s) + 2\\gamma\\omega_0sX(s) + \\omega_0^2X(s) = Q(s) $$両辺を $Q(s)$ で割ると、\n$$ s^2H(s) + 2\\gamma\\omega_0sH(s) + \\omega_0^2H(s) = 1 $$よって\n$$ H(s) = \\frac{1}{s^2+2\\gamma\\omega_0s+\\omega_0^2} $$b $H(s)$ に $i\\omega$ を代入すると、\n$$ \\begin{align} H(i\\omega) \u0026= \\frac{1}{-\\omega^2+2i\\gamma\\omega_0\\omega + \\omega_0^2} \\\\ \u0026= \\frac{1}{\\omega_0^2-\\omega^2+2i\\gamma\\omega_0\\omega} \\end{align} $$なので、\n$$ \\mid H(i\\omega) \\mid = \\frac{1}{\\sqrt{(\\omega_0^2-\\omega^2)^2+(2\\gamma\\omega_0\\omega)^2}} $$これより、\n$$ \\begin{align} Y(\\omega) \u0026= 20\\log_{10}\\mid H(i\\omega) \\mid \\\\ \u0026= 20\\log_{10} \\frac{1}{\\sqrt{(\\omega_0^2-\\omega^2)^2+(2\\gamma\\omega_0\\omega)^2}} \\\\ \u0026= 20(\\log_{10}1-\\log_{10}\\sqrt{(\\omega_0^2-\\omega^2)^2+(2\\gamma\\omega_0\\omega)^2}) \\\\ \u0026= -20\\log_{10}\\sqrt{(\\omega_0^2-\\omega^2)^2+(2\\gamma\\omega_0\\omega)^2} \\\\ \u0026= -10\\log_{10}[(\\omega_0^2-\\omega^2)^2+(2\\gamma\\omega_0\\omega)^2] \\end{align} $$c $Y(\\omega)$ が最大になるとき、$(\\omega_0^2-\\omega^2)^2+(2\\gamma\\omega_0\\omega)^2$ は最小になる。これを微分すると、\n$$ \\begin{align} (\\omega_0^2-\\omega^2)^2+(2\\gamma\\omega_0\\omega)^2 \u0026= 2(\\omega_0^2-\\omega^2)\\times(-2\\omega) + 2(2\\gamma\\omega_0\\omega)\\times(2\\gamma\\omega_0) \\\\ \u0026= 4\\omega(\\omega^2-\\omega_0^2) + 4(2\\gamma^2\\omega_0^2w) \\\\ \u0026= 4\\omega(\\omega^2-\\omega_0^2+\\gamma^2\\omega_0^2) \\end{align} $$これを $0$ と置くと、\n$$ 4w = 0 $$または\n$$ \\omega^2-\\omega_0^2+\\gamma^2\\omega_0^2 = 0 $$つまり\n$$ w^2=\\omega_0^2-2\\gamma^2\\omega_0^2 $$$\\omega$ は正の実数なので、\n$$ \\hat{\\omega} = \\omega_0\\sqrt{1-2\\gamma^2} $$d 共振現象だよ。\n共振現象というのは、システムに加わる外力の周波数がシステムの固有振動数に近づいたときに、システムの応答振幅が最大になる現象のこと。\ne $\\hat{\\omega}$ が正の実数であることから、\n$$ 1-2\\gamma^2 \\gt 0 $$つまり\n$$ $-\\frac{1}{\\sqrt{2}} \\lt \\gamma \\lt \\frac{1}{\\sqrt{2}}$ $$また $\\mu \\gt 0$ なので、\n$$ 0 \\lt \\gamma \\lt \\frac{1}{\\sqrt{2}} $$Reference オイラーの公式 latex におけるラプラス変換記号のコード https://blog.csdn.net/ydyang1126/article/details/77247654 ラプラス変換と逆ラプラス変換のよく使われる結論と基本公式 ","date":"2024-11-28T15:51:16+08:00","permalink":"https://blog.yexca.net/ja/archives/202/","title":"東京科学大学大学院 情報理工学院 2020 問題四"},{"content":"問題一： https://blog.yexca.net/ja/archives/198 問題二：この記事\n問題三： https://blog.yexca.net/ja/archives/200 問題四： https://blog.yexca.net/ja/archives/202 問題五： https://blog.yexca.net/ja/archives/203 まえがき この質問を初めて見たときは形式言語（とオートマトン理論）に関する質問だと思ったのですが、実際にやってみると数学に関する質問でした （どちらも習ってないので同じです） 全体的な難易度は特に難しいわけではありません （私は東京大学の試験問題を受験したので、ここでの問題はそれほど難しくありません） しかし、それらを解くには、より多くの理論的基礎を習得する必要があります\nトピックの著作権は東京理科大学に帰属します。閲覧の便宜のために引用しているだけで、営利行為は一切ありません。\n1 命題論理について考える。命題 $\\varphi$ を $(\\neg p_0 \\to \\neg p_1) \\wedge (\\neg p_1 \\to p_0)$ とする。ただし、$p_0, p_1$ は命題記号である。\na）以下の表が $\\varphi$ の真理値表になるように（ア）～（エ）にあてはまる値を答えよ。ただし、1は真を表し、0は偽を表す。\n$p_0$ $p_1$ $\\varphi$ 0 0 （ア） 0 1 （イ） 1 0 （ウ） 1 1 （エ） b）命題 $\\varphi$ が恒真（トートロジー）であるか否か答えよ。\nc）命題 $\\varphi$ が充足可能であるか否か答えよ。\n1-a 先ずは、命題 $\\varphi$ を整理する\n$$\r\\begin{align}\r\\varphi\r\u0026= (\\neg p_0 \\to \\neg p_1) \\wedge (\\neg p_1 \\to p_0) \\\\\r\u0026= (p_0 \\vee \\neg p_1) \\wedge (p_1 \\vee p_0)\r\\end{align}\r$$これより\n$p_0$ $p_1$ $\\varphi$ 0 0 0 0 1 0 1 0 1 1 1 1 ゆえに、ア：0、イ：0、ウ：1、エ：1\n1-b $\\varphi=0$ の場合が存在するため、恒真命題ではない\n1-c $\\varphi=1$ の場合が存在するため、充足可能である\n2 命題論理の自然演繹について考える。$p_1, p_2, p_3$ は命題記号であり、$\\wedge I$ は連言の導入規則、$\\wedge E_L$ は連言の除去規則（左）、$\\wedge E_R$ は連言の除去規則（右）、$\\to E$ は含意の除去規則である。\na）$(p_1 \\wedge p_2) \\wedge p_3$ を仮定とし、$p_1 \\wedge (p_2 \\wedge p_3)$ を結論とする以下の自然演繹の導出（証明図）を完成させたい。（ア）～（オ）にあてはめる命題を答えよ。\n$$\r\\cfrac{\r\\cfrac{\r\\cfrac{(p_1 \\wedge p_2)\\wedge p_3}{(ア)}\\wedge E_L\r}{p_1}\\wedge E_L \\quad\r\\cfrac{\r\\cfrac{\r\\cfrac{(p_1 \\wedge p_2) \\wedge p_3}{(イ)}\\wedge E_L\r}{(ウ)}\\wedge E_R \\quad\r\\cfrac{(p_1 \\wedge p_2) \\wedge p_3}{(エ)}\\wedge E_R\r}{(オ)}\\wedge I\r}{p_1 \\wedge (p_2 \\wedge p_3)}\\wedge I\r$$b）$p_1 \\wedge p_2$ と $p_1 \\to (p_2 \\to p_3)$ を仮定とし、$p_3$ を結論とする以下の自然演繹の導出（証明図）を完成させたい。（ア）～（エ）にあてはめる命題を答えよ。\n$$\r\\cfrac{\r\\cfrac{(ア)}{p_2}\\wedge E_R \\quad\r\\cfrac{\r\\cfrac{(イ)}{p_1}\\wedge E_L \\quad (ウ)\r}{(エ)}\\to E\r}{p_3}\\to E\r$$c）命題の集合 $\\{ \\neg p_0 \\to \\neg p_1, \\neg p_1 \\to p_0 \\}$ が矛盾するか無矛盾であるかを答え、その理由を述べよ。\n2-解答 質問に示されている記号を理解できれば、この質問に答えるのは比較的簡単です。\n$\\wedge I$ は交差のインポート規則であり、$A$ と $B$ を $A \\wedge B$ に変換する。\n$\\wedge E_L$ は交差除去規則であり、左側を残す。つまり、$A \\wedge B$ は $A$ になる。\n$\\wedge E_R$ は交差除去規則であり、右側を残す。つまり、$A \\wedge B$ は $B$ になる。\n$\\to E$ は含意除去規則であり、$A$ と $A \\to B$ を $A$ に変換する。\n2-a ア: $p_1 \\wedge p_2$ イ: $p_1 \\wedge p_2$ ウ: $p_2$ エ: $p_3$ オ: $p_2 \\wedge p_3$ $$\r\\cfrac{\r\\cfrac{\r\\cfrac{(p_1 \\wedge p_2)\\wedge p_3}{p_1 \\wedge p_2}\\wedge E_L\r}{p_1}\\wedge E_L \\quad\r\\cfrac{\r\\cfrac{\r\\cfrac{(p_1 \\wedge p_2) \\wedge p_3}{p_1 \\wedge p_2}\\wedge E_L\r}{p_2}\\wedge E_R \\quad\r\\cfrac{(p_1 \\wedge p_2) \\wedge p_3}{p_3}\\wedge E_R\r}{p_2 \\wedge p_3}\\wedge I\r}{p_1 \\wedge (p_2 \\wedge p_3)}\\wedge I\r$$2-b ア: $p_1 \\wedge p_2$ イ: $p_1 \\wedge p_2$ ウ: $p_1 \\to (p_2 \\to p_3)$ エ: $p_2 \\to p_3$ $$\r\\cfrac{\r\\cfrac{p_1 \\wedge p_2}{p_2}\\wedge E_R \\quad\r\\cfrac{\r\\cfrac{p_1 \\wedge p_2}{p_1}\\wedge E_L \\quad p_1 \\to (p_2 \\to p_3)\r}{p_2 \\to p_3}\\to E\r}{p_3}\\to E\r$$2-c 無矛盾である。命題を整理する\n$$\r\\neg p_0 \\to \\neg p_1 \\equiv p_0 \\vee \\neg p_1 \\\\\r\\neg p_1 \\to p_0 \\equiv p_1 \\vee p_0\r$$真理値表を作る\n$p_0$ $p_1$ $\\neg p_0 \\to \\neg p_1$ $\\neg p_1 \\to p_0$ 0 0 1 0 0 1 0 1 1 0 1 1 1 1 1 1 $p_0=1, p_1=0$ または $p_0=1, p_1=1$ の場合は、両方の命題が成り立つ\n少なくとも一つの真理値割り当てで命題集合が成り立つため、命題の集合 $\\{ \\neg p_0 \\to \\neg p_1, \\neg p_1 \\to p_0 \\}$ は無矛盾である\n3 一階述語論理について考える。\na）以下の論理式のモデルは存在するか。存在するならば、モデルのユニバースの濃度の最小値を答えよ。存在しないならば、その理由を述べよ。\n$$\r\\exists x \\exists y \\exists z \\space \\neg(x=y) \\wedge \\neg(y=z) \\wedge \\neg(z=x)\r$$b）以下の論理式のモデルは存在するか。存在するならば、そのモデルを1つ挙げよ。存在しなければ、その理由を述べよ。\n$$\r\\exists x \\forall y(x=y)\r$$ 3-a この論理式のモデルは存在する。モデルのユニバースの濃度の最小値は3である。\n3-b この論理式のモデルは存在する。例えば、ユニバース $U=\\{a\\}$ を設定する。この場合、$U$ のすべての要素が $x$ と等しいため、論理式が成り立つ。\n4 一階述語論理の自然演繹について考える。以下が成り立つか否か答え、その理由を述べよ。ただし、$P$ はアリティ2の述語記号とする。\n$$\r\\vdash (\\forall x \\exists y P(x,y)) \\to \\exists x \\forall y P(x,y)\r$$ 4-解答 これは成り立たない。反例は以下のように構成する。\nユニバースを $\\{ m,n,a,b \\}$ と定義する。このとき、述語 $P(x,y)$ の解釈を以下のように与える\n$$\rP(m,a) = 真 \\quad P(a,m) = 偽 \\\\\rP(n,b) = 真 \\quad P(b,n) = 偽\r$$これより、$\\forall x \\exists y P(x,y)$ が成り立つ。しかし、$\\exists x \\forall y P(x,y)$ は成り立たない。\nReference 自然演繹 命題論理 演繹定理 充足可能性問題 ","date":"2024-11-24T22:42:18+08:00","permalink":"https://blog.yexca.net/ja/archives/201/","title":"科学大院理工学 2020 問題二"},{"content":" 📢 この記事は gemini-2.5-flash によって翻訳されました 問題一： https://blog.yexca.net/ja/archives/198 問題二： https://blog.yexca.net/ja/archives/201 問題三：この記事\n問題四： https://blog.yexca.net/ja/archives/202 問題五： https://blog.yexca.net/ja/archives/203 はじめに この解答はアルゴリズムの問題だよ。最初見たときは、もうダメだって諦めそうになったんだけど、一度やってみたら、そこまで難しくないって感じたんだ。ただ、既存のアルゴリズムに対する高い理解力は必要だね。なんで難易度がそこまで高くないって言ったかというと、たぶん僕の心の準備というか、期待値と関係してるかも。だって、なんか新しいアルゴリズムを設計しなきゃいけないのかなって思ってたからさ (僕が言いたいのは、この問題が簡単だとは思ってないってことね)\n問題の著作権は東京科学大学に帰属するよ。閲覧しやすくするために引用しただけで、営利目的ではないからね。\n1 ｎ個の要素からなる整数の配列aを昇順に整列させる処理を、二つの異なるアルゴリズムに基づきＣ言語で実装した。プログラム3.1、3.2のキャプションＡ、Ｂを埋めるのに最も適切なアルゴリズムの名称を選択肢から選び、その記号を答えよ。\n「選択肢」\nア　選択ソート\nイ　バブルソート\nウ　クイックソート\nエ　挿入ソート\nプログラム3.1：A 1 2 3 4 5 6 7 8 9 10 11 12 13 void sort_a(int a[], int n) { int i, j, tmp; for(i=0; i\u0026lt;n-1; ++i){ for(j=n-1; i\u0026lt;j; --j){ if(a[j]\u0026lt;a[j-1]){ tmp=a[j]; a[j]=a[j-1]; a[j-1]=tmp; } } } } プログラム3.2：B 1 2 3 4 5 6 7 8 9 10 11 12 13 void sort_b(int a[], int n) { int i, j, tmp; for(j=1; j\u0026lt;n; ++j){ tmp=a[j]; i=j-1; while(0\u0026lt;=i \u0026amp;\u0026amp; tmp\u0026lt;a[i]){ a[i+1]=a[i]; --i; } a[i+1]=tmp; } } 解答\nこの問題は、2つのソートアルゴリズムのコードを見て、どのソート方法が使われているかを判断するものだね。Aはバブルソート（イ）、Bは挿入ソート（エ）だよ。\n2 ヒープソートに関して、次の問いに答えよ。ただし、ｎは正の整数とする。\na）二分ヒープにおいて、根以外の任意の節点の値が満たすべき条件を説明せよ（maxヒープ条件とminヒープ条件のどちらでもよい）\nb）二分ヒープがｎ個の要素を格納しているとき、その木の高さをｎの式で表せ。なお、木の高さは、根と葉を結ぶ路の長さの最大値として定義される\nc）ヒープソートでｎ個の要素を整列させるとき、その平均時間計算量と最悪時間計算量の漸近的評価として、最も適切なものを以下の選択肢からそれぞれ答えよ\nア　$O(1)$\nイ　$O(\\log n)$\nウ　$O(n)$\nエ　$O(n\\log n)$\nオ　$O(n^2)$\nこの問題はヒープソートについてだよ。1問目は、根以外の任意の節点の値が満たすべき条件（最大ヒープか最小ヒープのどちらかを選ぶ）を書くんだ。2問目は、構築されるヒープの二分木の高さを書くよ。3問目は、平均時間計算量と最悪時間計算量を選ぶんだ。\n解答\na\n最大ヒープ条件：根以外の任意の節点の値は、その親の値以下である必要がある。 最小ヒープ条件：根以外の任意の節点の値は、その親の値以上である必要がある。 b\n$$ \\left \\lfloor \\log_2n \\right \\rfloor $$c\n平均時間計算量と最悪時間計算量: エ　$O(n\\log n)$\n3 $A=\\{ A[0], A[1], \\cdots, A[n-1] \\}$ をｎ個の相異なる整数の配列とする。ｎ未満の非負整数 $i,j$ に対し、$i\\lt j$ かつ $A[i]\\gt A[j]$ のとき、対 $(i,j)$ をAの反転と呼ぶ、Aの反転の数をAの反転数と呼ぶ。例えば、配列 $\\{ 5,7,4,6 \\}$ の反転は $(0,2),(1,2),(1,3)$ であり、反転数は3である。次の問いに答えよ。\na）配列 $\\{ 1,0,4,3,2, \\}$ の反転数を求めよ。\nb）集合 $\\{ 1,2,\\cdots,n \\}$ の要素をすべて並べた配列（要素数はｎ個）の中で、反転数が最大となるものを示せ。また、その反転数をｎの式で表せ。\nc）集合 $\\{ 1,2,\\cdots,n \\}$ の要素をすべて並べた任意の配列B（要素数はｎ個）をバブルソートで昇順に整列させる。このとき、「バブルソートにおけるＸと配列Ｂの反転数は等しい」という関係が成り立つ。Ｘを埋めるのに適切な語句と、その関係が成り立つ理由を簡潔に答えよ。\nこの問題ではまず「反転」の概念が導入されてるね ( 宋浩先生の線形代数の授業 で話があったよ)。1問目は反転数を求めるんだ。2問目は最大の反転数を求めるんだね。3問目は、バブルソートの何が反転数と等しくなるか、その理由とともに答えるんだ。\n解答\na 反転数は4だよ。(1,0), (4,3), (4,2), (3,2)の4組だね。\nb 最大の反転数になるのは、配列がこう並んだ時だね。\n$$ \\{ n, n-1, n-2, \\cdots, 2, 1 \\} $$n個の要素はn-1個と、n-1個の要素はn-2個と、という具合に続くね。反転数自体はその合計になるよ。\n$$ (n-1)+(n-2)+\\cdots+2+1+0=\\frac{n(n-1)}{2} $$ c X：交換回数\n理由：スワップが反転を1つ解消する操作であるため\nバブルソートは2つの要素を比較して、順序が間違っていたら交換するよね。1回の操作で1つの反転を解消するってことなんだ。\n4 プログラム3.3は、整数の配列を昇順に整列させる処理を、マージソートのアルゴリズムに基づき、C言語で実装したものである、次の問いに答えよ。\nプログラム3.3：マージソート 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 int mergesort(int a[], int begin, int end, int w[]){ int mid = (begin+end)/2; int i = begin, j = mid+1, k, c=0; printf(\u0026#34;(%d, %d)\\n\u0026#34;, begin, end); if(begin\u0026lt;end){ mergesort(a, begin, mid, w); mergesort(a, mid+1, end, w); for(k=begin; k\u0026lt;=end; ++k){ if(mid\u0026lt;1){ A }else if(end\u0026lt;j){ B }else{ /* ++c */ if(a[i]\u0026lt;a[j]){ C }else{ D } } } for(k=begin; k\u0026lt;=end; ++k){ E } } return 0; } a）空欄A、B、C、D、Eを埋めるのに適切なコードを、選択肢から選び、プログラムを完成させよ。ただし、整列させたい配列をa整列時の作業領域に用いる配列をｗとし、mergesort 関数を以下の2行のコードで呼び出すこととする。\n1 2 int a[5] = {3, 5, 1, 4, 2}, w[5]; mergesort(a, 0, 4, w); 選択肢 $$ \\begin{matrix} ア. a[k]=w[i] \u0026 イ. a[k]=w[i++] \u0026 ウ. a[k]=w[++i] \\\\ エ. a[k]=w[j] \u0026 オ. a[k]=w[j++] \u0026 カ. a[k]=w[++j] \\\\ キ. a[k]=w[k] \u0026 ク. a[k]=w[k++] \u0026 ケ. a[k]=w[++k] \\\\ コ. w[k]=a[i] \u0026 サ. w[k]=a[i++] \u0026 シ. w[k]=a[++i] \\\\ ス. w[k]=a[j] \u0026 セ. w[k]=a[j++] \u0026 ソ. w[k]=a[++j] \\\\ タ. w[k]=a[k] \u0026 チ. w[k]=a[k++] \u0026 ツ. w[k]=a[++k] \\end{matrix} $$b）a）に示したコードで mergesort 関数を呼び出したとき、標準出力の1行目に $(0,4)$ が書き出される。3行目、5行目、7行目に書き出される内容をそれぞれ答えよ。\nc）mergesort 関数が引数で指定された範囲の配列の要素を整列させるまでにプログラム3.3の18行目を実行した回数の総数（要素の比較回数）を求めたい。そこで、17行目を（コメントアウトを外して）++c; に変更したが、これだけでは不十分である。以下の2行のコードで比較回数を変数 count に格納するには、プログラム3.3をどうのように変更すればよいか答えよ。\n1 2 int a[5] = {3, 5, 1, 4, 2}, w[5]; int count = mergesort(a, 0, 4, w); ただし、大域変数や静的変数を使っていけない。また、17行目の変更に加えて行うプログラムの変更は3回までの行の差し替えに限定する。行の差し替えとは、ある行のコードを60文字以内（空白文字は数えない）の別のコードに置き換えることを指す。解答の際は、以下の「答案の書き方（例）」のように、変更する行の番号と差し替え後のコードを記すこと。17行目のコメントは外してあることとし、それ以外に必要な変更を記述すること。\n「答案の書き方（例）」 6行目：printf(\u0026quot;hello\\n\u0026quot;);\n30行目：c= end - begin + 1;\n解答\na\nA: w[k] = a[j++]; 即 セ B: w[k] = a[i++]; 即 サ C: w[k] = a[i++]; 即 サ D: w[k] = a[j++]; 即 セ E: a[k] = w[k]; 即 キ b\n3 行目: (0,1)\n5 行目: (1,1)\n7 行目: (3,4)\nc\n8 行目: c += mergesort(a, begin, mid, w);\n9 行目: c += mergesort(a, mid + 1, end, w);\n31 行目: return c;\nこの問題、最初見たときはちょっとビビっちゃったんだけど、よく読んでみたら、出題内容はまあまあいける感じだったよ。マージソートを理解していれば、結構簡単に解けるんじゃないかな。ちなみに、僕もうアルゴリズムのことほとんど忘れかけてたし、前はアニメーションで（直感的に分かりやすいからね）理解してたんだけど、問題解いてるときに、 いい感じのアニメーションアルゴリズムサイト を見つけられたのはラッキーだったよ。\n","date":"2024-11-23T20:35:28+08:00","permalink":"https://blog.yexca.net/ja/archives/200/","title":"東京科学大学大学院 情報理工学院 2020 問題三 / 科学大院理工学 2020 問題三"},{"content":" 📢 この記事は gemini-2.5-flash によって翻訳されました 前に書いたちょっとした記事なんだけど、システム作成日は2023.12.01だね。\n今見ると、前に書いた記事ってあんまり公開したくないなって思うんだけど、消すのももったいないし、色々考えた結果、やっぱり公開することにしたよ。これも俺が書いたものだしね。\nngrok ワンクリック 公式サイト でアカウント登録してメール認証すると、Authtokenがもらえるよ。\nプログラムをダウンロード： ngrok - download トークンを追加\n1 ngrok config add-authtoken YourToken 実行 1 ngrok http [Port] [Port] を、リッスンしたいローカルポートに置き換えてね。\n自前で構築 ngrok 参考にしてみてね： ngrok内网穿透 学海无涯-回头是岸 学海无涯，回头是岸 frp 参考にしてみてね： frp 内网穿透 ","date":"2024-11-22T22:05:34+08:00","permalink":"https://blog.yexca.net/ja/archives/199/","title":"ローカルネットワークからの外部アクセス（ポートフォワーディング）"},{"content":"問題一：この記事\n問題二： https://blog.yexca.net/ja/archives/201 問題三： https://blog.yexca.net/ja/archives/200 問題四： https://blog.yexca.net/ja/archives/202 問題五： https://blog.yexca.net/ja/archives/203 まえがき この記事は初めて母国語じゃない言語で書いて、他の記事を参考しないので、言葉遣いがてきせつではないかも。それで、参考の答えはなくて、記事の答えが自分でできたので、正しくないかも。\n科学大とは東京工業大学の新しい名前で、略称が何か知らなくてこれを使った。\n問題の著作権は東京科学大学に帰属します。閲覧の便宜のためにのみ引用されており、営利を目的とするものではありません。\n1 以下の極限を求めよ。\na) $\\lim_{x\\to\\infty}\\{ \\log_e(2x+3)-\\log_e(x) \\}$\nb) $\\lim_{x\\to 0}\\frac{1-\\cos x}{x\\sin x}$\nc) $\\lim_{x\\to 0}\\frac{e^{3x}-\\cos x}{x}$\n回答\na\n$$\ra=\\lim_{x \\to \\infty}\\log_e\\frac{2x+3}{x}=\\lim_{x\\to \\infty}\\log_e(2+\\frac{3}{x})=\\log_e2\r$$b\n$$\r\\because when \\space x \\to 0 ,\\space 1-\\cos x \\sim \\frac{1}{2}x^2 \\space and \\space sinx \\sim x \\\\\r\\therefore \\lim_{x\\to 0}\\frac{1-\\cos x}{x\\sin x}=\\lim_{x\\to 0}\\frac{\\frac{1}{2}x^2}{x^2}=\\frac{1}{2}\r$$c ロピタルの定理を用いて\n$$\r\\lim_{x\\to 0}\\frac{e^{3x}-\\cos x}{x}=\\lim_{x\\to 0}\\frac{3e^{3x}+sinx}{1}=3\r$$2 以下の実行列の積の行列式を計算せよ。\n$$\r\\begin{pmatrix}\r1 \u0026 0 \u0026 0 \\\\\rx \u0026 2 \u0026 1 \\\\\rx^2 \u0026 3 \u0026 2\r\\end{pmatrix}\r\\begin{pmatrix}\r31 \u0026 23 \u0026 17 \\\\\r0 \u0026 11 \u0026 11 \\\\\r0 \u0026 4 \u0026 5\r\\end{pmatrix}\r$$ 2つの行列の積の行列式は、それらの行列式の積である。\nA の場合\n$$\rA=\\begin{pmatrix}\r1 \u0026 0 \u0026 0 \\\\\rx \u0026 2 \u0026 1 \\\\\rx^2 \u0026 3 \u0026 2\r\\end{pmatrix}\r$$A の行列式\n$$\r\\det(A)=(-1)^{1+1} \\times 1 \\times \\begin{vmatrix}\r2 \u0026 1 \\\\\r3 \u0026 2\r\\end{vmatrix} -0+0 =1\r$$B の場合\n$$\rB=\\begin{pmatrix}\r31 \u0026 23 \u0026 17 \\\\\r0 \u0026 11 \u0026 11 \\\\\r0 \u0026 4 \u0026 5\r\\end{pmatrix}\r$$B の行列式\n$$\r\\det(B)=(-1)^{1+1} \\times 31 \\times \\begin{vmatrix}\r11 \u0026 11 \\\\\r4 \u0026 5\r\\end{vmatrix} -0+0 = 341\r$$だから\n$$\r\\det=\\det(A) \\times \\det(B)=1 \\times 341 = 341\r$$3 以下の確率密度関数 $f_X(x)$ に従う連続型確率変数 $X$ の分散 $V(X)$ 、累積分布関数 $F_X(x)$ を各々求めよ。ただし、$\\lim_{x \\to +0}x^n\\log_e(x)=0$ ($n$ は 1 以上の整数) とする。\n$$\rF_X(x)=\\left \\{ \\begin{matrix}\r-4x\\log_e(x) \u0026 0 \\lt x \\le 1 \\\\\r0 \u0026 x \\le 0 \\space または \\space x \\gt 1\r\\end{matrix}\r\\right .\r$$ まずは、累積分布関数を考えて\n$x \\le 0$ $$\rF_X(x) = 0\r$$ $x\\gt 1$ $$\rF_X(x) = 1\r$$ $0 \\lt x \\le 1$ $$\r\\begin{align}\rF_X(x)\r\u0026= \\int_0^x(-4t\\log_e(t))dt \\\\\r\\end{align}\r$$部分積分を用いて\n$$\r\\begin{matrix}\ru = \\ln t \u0026 dv=4tdt \\\\\rdu = \\frac{1}{t}dt \u0026 v=2t^2\r\\end{matrix}\r$$したがって\n$$\r\\begin{align}\rF_X(x)\r\u0026=-( [2t^2\\ln t]_0^x - \\int_0^x 2t^2\\frac{1}{t}dt ) \\\\\r\u0026=-( 2x^2\\ln x - \\int_0^x 2t dt ) \\\\\r\u0026=-( 2x^2\\ln x - t^2\\mid_0^x ) \\\\\r\u0026=x^2 - 2x^2\\ln x\r\\end{align}\r$$これより\n$$\rF_X(x)= \\left \\{ \\begin{matrix}\r0 \u0026 x \\le 0 \\\\\rx^2-2x^2\\ln x \u0026 0 \\lt x \\le 1 \\\\\r1 \u0026 x \\gt 1\r\\end{matrix}\r\\right .\r$$次に、分散を求める。分散の定義は\n$$\rV(X)=E[X^2] - (E[X])^2\r$$期待値 $E[X]$ を計算する\n$$\r\\begin{align}\rE[X]\r\u0026= \\int_{-\\infty}^{\\infty}xf_X(x)dx \\\\\r\u0026= \\int_0^1x(-4x\\ln x)dx \\\\\r\u0026= -\\int_0^1 4x^2\\ln xdx\r\\end{align}\r$$部分積分を用いて\n$$\r\\begin{matrix}\ru=\\ln x \u0026 dv=4x^2dx \\\\\rdu=\\frac{1}{x} \u0026 v=\\frac{4}{3}x^3\r\\end{matrix}\r$$したがって\n$$\r\\begin{align}\rE[X]\r\u0026= -([\\frac{4}{3}x^3\\ln x]_0^1-\\int_0^1\\frac{4}{3}x^3\\frac{1}{x}dx) \\\\\r\u0026= -(-\\frac{4}{9}x^3\\mid_0^1) \\\\\r\u0026= \\frac{4}{9}\r\\end{align}\r$$$E[X^2]$ の計算\n$$\r\\begin{align}\rE[X^2]\r\u0026= \\int_{-\\infty}^{\\infty}x^2f_X(x)dx \\\\\r\u0026= \\int_0^1x^2(-4x\\ln x)dx \\\\\r\u0026= -4\\int_0^1x^3\\ln xdx\r\\end{align}\r$$部分積分を用いて\n$$\r\\begin{matrix}\ru=\\ln x \u0026 dv=x^3dx \\\\\rdu=\\frac{1}{x} \u0026 v=\\frac{1}{4}x^4\r\\end{matrix}\r$$したがって\n$$\r\\begin{align}\rE[X^2]\r\u0026= -4 \\times ([\\frac{1}{4}x^4\\ln x]_0^1-\\int_0^1\\frac{1}{4}x^3dx) \\\\\r\u0026= -4 \\times (-\\frac{1}{16}x^4\\mid_0^1) \\\\\r\u0026= \\frac{1}{4}\r\\end{align}\r$$だから\n$$\r\\begin{align}\rV(X)\r\u0026= E[X^2] - (E[X])^2 \\\\\r\u0026= \\frac{1}{4} - (\\frac{4}{9})^2 \\\\\r\u0026= \\frac{17}{342}\r\\end{align}\r$$4 ある製造ラインで生産された製品は1/1000の確率で不良品である。不良品を99/100の確率で正しく不良品と判定し、かつ、不良品でないものを4/5の確率で正しく不良品ではないと判定する検査手法がある。この製造ラインにおいて、この手法が不良品と判定した製品が、不良品である確率を求めよ。\n不良品である確率：$P(A)=\\frac{1}{1000}$、不良品と判定する確率：$P(B)$\nこれより\n$$\r\\begin{matrix}\rp(\\bar{A})=\\frac{999}{1000} \u0026 P(B\\mid A)=\\frac{99}{100} \u0026 P(B\\mid \\bar{A})=\\frac{1}{5}\r\\end{matrix}\r$$したがって\n$$\rP(B)=P(A)P(B\\mid A)+P(\\bar{A})P(B\\mid \\bar{A})=\\frac{20079}{100000}\r$$ベイズの定理を用いると\n$$\rP(A\\mid B)=\\frac{P(AB)}{P(B)}=\\frac{P(A)P(B\\mid A)}{P(B)}=\\frac{99}{20079}\r$$以上より、不良品である確率は $\\frac{99}{20079}$\n5 あるカジノで、4個のパケットA,B,C,Dに区切られたルーレットがある。カジノの説明ではそれぞれのパケットにボールが入る確率は同じであるとされている。そのルーレットを5回試行したところ、ボールはパケットAに4回入った。カジノの説明とは異なる「このルーレットはボールがポケットAにより入りやすい」という仮設を、有意水準5％で検定せよ。解答には帰無仮説 $H_0$ 、対立仮説 $H_1$ を明記すること。\n$H_0$：ポケットAにボールが入る確率は他のポケットと同じである。すなわち\n$$\rP(A)=\\frac{1}{4}\r$$$H_1$ ：ポケットAにボールが入る確率は他のポケットより高い。すなわち\n$$\rP(A)\\gt \\frac{1}{4}\r$$ボールはポケットAに4回入る確率は\n$$\rP(X=4)=(_4^5) (\\frac{1}{4})^4 \\times \\frac{3}{4}=\\frac{15}{1024}\r$$ボールはポケットAに5回入る確率は\n$$\rP(X=5)=(_5^5) (\\frac{1}{4})^5=\\frac{1}{1024}\r$$これより\n$$\rP(X\\ge 4)=\\frac{15}{1024}+\\frac{1}{1024}=\\frac{1}{64}\r$$この確率は有意水準より小さいため、帰無仮説を棄却する。ゆえに、「このルーレットはボールがポケットAにより入りやすい」という仮設は統計的に有意であると言えます。\n","date":"2024-11-21T15:42:18+08:00","permalink":"https://blog.yexca.net/ja/archives/198/","title":"科学大院理工学 2020 問題一"},{"content":" 📢 この記事は gemini-2.5-flash によって翻訳されました はじめに Sometimes it\u0026rsquo;s the people who no one imagines anything of who do the things that no one can imagine\n最近ね、 Bidaoの動画 のコメント欄で知ったんだけど、チューリングに関するドキュメンタリー「イミテーション・ゲーム」っていうのがあって、ついでに観てみたんだ。その中で出てきたこの言葉にすごく感銘を受けたんだよね。だから、形式言語とオートマトンの記事の冒頭の引用文として使わせてもらうよ。\nもし、ちょっと気分が落ち込んじゃった時は、 エイミーの、この言葉についての感想 も見てみてね。\n基本概念 アルファベット：記号（文字）の、空じゃなくて有限な集合のこと。\n$$ {\\textstyle \\sum_1} = \\{0, 1\\} $$文字列：あるアルファベットの中の記号で構成された、有限の並び（シーケンス）のこと。\n$$ もし \\space {\\textstyle \\sum_1} = \\{0, 1\\} \\space だったら、 \\space 0，1，00，101011 \\space は \\space {\\textstyle \\sum_1} \\space 上の文字列になるよ。 $$空文字列：$\\varepsilon$ と書くんだ。0個の文字でできた文字列のことね。どんなアルファベット $\\sum$ でも、$\\varepsilon \\notin \\sum$ が成り立つよ。\n記号の使い方の約束\nアルファベット：$\\sum, \\Gamma, \\cdots$\n文字：$a, b, c, \\cdots$\n文字列：$\\cdots,w,x,y,z$\n集合：$A,B,C,\\cdots$\n文字列の長さ：文字列の中にある記号の数だよ。\n$$ 例えば \\space {\\textstyle \\sum_1} = \\{0, 1\\} \\space の場合、|0010|=4 だね。 $$文字列 $x$ と $y$ の連結：先頭と末尾をつなぎ合わせて新しい文字列を作る操作のこと。$x \\cdot y$ または $xy$ と書くよ。\n$$ x=01, y=ab, ならば \\space xy=01ab \\space になるね。 $$文字列 $x$ の $n$ 乗 （$n \\ge 0$） ，再帰的にこう定義するよ。\n$$ x^n= \\left \\{ \\begin{matrix} \\varepsilon \u0026 n=0 \\\\ x^{n-1}x \u0026 n \\gt 0 \\end{matrix} \\right . $$例えば \\space ${\\textstyle \\sum_1} = \\{a, b\\} \\space なら \\space (ba)^2=baba, ba^2=baa \\space って感じ。$\n集合 $A$ と $B$ の連結，$A\\cdot B$ または $AB$ と書いて、こう定義するんだ。\n$$ A \\cdot B = \\{ w |w=x \\cdot y, x \\in A \\space and \\space y \\in B \\} $$もし $\\space A = \\{0, 11\\} \\space B = \\{ab, ba\\} $\n$AB = \\{ 0ab, 0ba, 11ab, 11ba \\}, BA= \\{ ab0, ab11, ba0, ba11 \\}$\n集合 $A$ の $n$ 乗 （$n \\ge 0$） ，再帰的にこう定義するよ。\n$$ A^n= \\left \\{ \\begin{matrix} \\{ \\varepsilon \\} \u0026 n=0\\\\ A^{n-1}A \u0026 n \\ge 1 \\end{matrix} \\right . $$例えば \\space ${\\textstyle \\sum_1} = \\{0, 1\\} \\space だと、{\\textstyle \\sum^0}=\\{\\varepsilon\\}, {\\textstyle \\sum^1}=\\{0,1\\}, {\\textstyle \\sum^2}=\\{00,01,10,11\\}, \\cdots \\space ってなるね。$\nクリーネ閉包 (Kleene Closure) : あるアルファベットの全てのべき乗（0乗を含む）を結合（ユニオン）したものだよ。\n$$ {\\textstyle \\sum^*} = \\bigcup_{i=0}^{\\infty}{\\textstyle \\sum^i} $$正閉包 (Positive Closure) : あるアルファベットの全てのべき乗（0乗を含まない）を結合（ユニオン）したものなんだ。\n$$ {\\textstyle \\sum^+} = \\bigcup_{i=1}^{\\infty}{\\textstyle \\sum^i} $$明らかに\n$$ {\\textstyle \\sum^*} = {\\textstyle \\sum^+} \\cup \\{ \\varepsilon \\} $$言語 定義：$\\sum$ がアルファベットで、$\\forall L \\subseteq \\sum^*$ が成り立つなら、$L$ をアルファベット $\\sum$ 上の言語と呼ぶよ。\n自然言語とか、プログラミング言語とかね。 $ \\\\{ 0^n 1^n \\mid n \\ge 0 \\\\} $ The set of strings of 0\u0026rsquo;s and 1\u0026rsquo;s with an equal number of each $\\emptyset$ と $\\{ \\varepsilon \\}$ と $\\sum^*$ はそれぞれどんなアルファベット $\\sum$ 上の言語でもあるんだ。でも、$\\emptyset \\ne \\{ \\varepsilon \\}$ だよ。 言語の唯一の制約は、全てのアルファベットが有限であることだけなんだ。\n","date":"2024-11-19T22:18:42+08:00","permalink":"https://blog.yexca.net/ja/archives/197/","title":"形式言語とオートマトン - 基本概念"},{"content":" 📢 この記事は gemini-3-flash-preview によって翻訳されました Vue ディレクティブ Vueは、いろんなディレクティブを使って、タグごとに違う機能を実現するんだ。ディレクティブっていうのは v- プレフィックスがついた特別なタグ属性のことだよ。\nv-html 要素の innerHTML を設定するために使うよ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;v-html\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;div v-html=\u0026#34;link\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const app = new Vue({ el: \u0026#39;#app\u0026#39;, data: { link:\u0026#39;\u0026lt;a href=\u0026#34;https://yexca.net/\u0026#34;\u0026gt;yexca\u0026lt;/a\u0026gt;\u0026#39; } }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; v-show と v-if \\ v-show v-if 役割 要素の表示・非表示を制御する 要素の表示・非表示を制御する (条件付きレンダリング) 文法 v-show=\u0026ldquo;式\u0026rdquo; v-if=\u0026ldquo;式\u0026rdquo; 式の値 true で表示、false で非表示 true で表示、false で非表示 非表示の説明 属性 style=\u0026quot;display:none;\u0026quot; で制御 要素を直接削除または作成する シーン 切り替えが頻繁なとき 切り替えがあまり頻繁じゃないとき v-else と v-else-if v-if のレンダリングを補助するために使うよ。v-if のすぐ後ろに続けて書く必要があるんだ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;v-else and v-else-if\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;p v-if=\u0026#34;gender === 1\u0026#34;\u0026gt;性別：男\u0026lt;/p\u0026gt; \u0026lt;p v-else\u0026gt;性別：女\u0026lt;/p\u0026gt; \u0026lt;hr /\u0026gt; \u0026lt;p v-if=\u0026#34;score \u0026gt;= 90\u0026#34;\u0026gt;判定 A\u0026lt;/p\u0026gt; \u0026lt;p v-else-if=\u0026#34;score \u0026gt;= 70\u0026#34;\u0026gt;判定 B\u0026lt;/p\u0026gt; \u0026lt;p v-else-if=\u0026#34;score \u0026gt;= 60\u0026#34;\u0026gt;判定 C\u0026lt;/p\u0026gt; \u0026lt;p v-else\u0026gt;判定 D\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const app = new Vue({ el: \u0026#39;#app\u0026#39;, data: { gender: 1, score: 89 } }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; v-on イベントを登録するために使うよ。「リスナーの追加 + 処理ロジックの提供」って感じだね。\n文法1 v-on:イベント名=\u0026ldquo;インラインステートメント\u0026rdquo;\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;v-on 1\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;button v-on:click=\u0026#34;count1--\u0026#34;\u0026gt;-\u0026lt;/button\u0026gt; \u0026lt;span\u0026gt;{{count1}} \u0026lt;/span\u0026gt; \u0026lt;!-- v-on: は @ に省略できるよ --\u0026gt; \u0026lt;button @click=\u0026#34;count1++\u0026#34;\u0026gt;+\u0026lt;/button\u0026gt; \u0026lt;hr /\u0026gt; \u0026lt;button v-on:mouseenter=\u0026#34;count2--\u0026#34;\u0026gt;-\u0026lt;/button\u0026gt; \u0026lt;span\u0026gt;{{count2}}\u0026lt;/span\u0026gt; \u0026lt;button v-on:mouseenter=\u0026#34;count2++\u0026#34;\u0026gt;+\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const app = new Vue({ el: \u0026#39;#app\u0026#39;, data: { count1: 1, count2: 2 } }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 文法2 v-on:イベント名=\u0026ldquo;methods内の関数名\u0026rdquo;\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;v-on 2\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;button @click=\u0026#34;fun\u0026#34;\u0026gt;表示・非表示を切り替え\u0026lt;/button\u0026gt; \u0026lt;p v-show=\u0026#34;isShow\u0026#34;\u0026gt;hello yexca\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const app = new Vue({ el: \u0026#34;#app\u0026#34;, data: { isShow: true }, methods: { fun(){ // this は常に現在のインスタンスを指すよ this.isShow = !this.isShow } } }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 引数の渡し方 さっそく例を見てみよう。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;v-on 3\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; .box{ border-style: solid; border-color: aqua; padding: 10px; margin: 10px; width: 200px; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;自動販売機\u0026lt;/h3\u0026gt; \u0026lt;button @click=\u0026#34;fun(5)\u0026#34;\u0026gt;コーラ 5円\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;fun(10)\u0026#34;\u0026gt;コーヒー 10円\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div style=\u0026#34;padding-left: 20px;\u0026#34;\u0026gt;残高：{{balance}}\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;../js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const app = new Vue({ el: \u0026#34;#app\u0026#34;, data: { balance: 900 }, methods: { fun(a){ this.balance -= a } } }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; v-bind HTMLタグの属性（src、url、title など）を動的に設定するために使うよ。\n文法：v-bind:属性名=\u0026ldquo;式\u0026rdquo;\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;v-bind\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; img{ width: 400px; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;!-- v-bind は省略できるよ --\u0026gt; \u0026lt;img v-bind:src=\u0026#34;imgURL\u0026#34; :title=\u0026#34;imgTitle\u0026#34; :alt=\u0026#34;imgAlt\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;../js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const app = new Vue({ el: \u0026#39;#app\u0026#39;, data: { imgURL: \u0026#39;../img/01.jpg\u0026#39;, imgTitle: \u0026#39;warma\u0026#39;, imgAlt: \u0026#39;warma\u0026#39; } }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; v-for データに基づいてループして、要素全体を何度もレンダリングするよ。\n文法：v-for=\u0026quot;(item, index) in 配列\u0026quot;\nitem：各要素、index：インデックス\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;v-for\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;フルーツショップ\u0026lt;/h3\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;!-- index が不要なときは省略できるよ --\u0026gt; \u0026lt;li v-for=\u0026#34;item in list\u0026#34;\u0026gt;{{ item }}\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;(item,index) in list\u0026#34;\u0026gt;{{ index }}\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;../js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const app = new Vue({ el: \u0026#39;#app\u0026#39;, data: { list: [\u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;watermelon\u0026#39;] } }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Vueがリスト項目を正しく並べ替えたり再利用したりしやすくするために、要素に一意の識別子、つまり key 属性を付ける必要があるんだ。\nkeyの値は文字列か数値だけで、かつ一意じゃないといけないよ。\n1 \u0026lt;li v-for=\u0026#34;(item, index) in list\u0026#34; :key=\u0026#34;item.id\u0026#34;\u0026gt;\u0026lt;/li\u0026gt; key には id を使うのがおすすめ。index を key にするのは、データの順番が変わると index も変わっちゃうからおすすめしないよ。\nv-model フォーム要素に使って、双方向データバインディングを実現するよ。これでフォームの内容を素早く取得したり設定したりできるんだ。\n双方向データバインディングっていうのは、見た目（ビュー）が変わればデータも自動で更新されるってこと。\n文法：v-model=\u0026lsquo;変数\u0026rsquo;\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;v-model\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; username: \u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;username\u0026#34;/\u0026gt;\u0026lt;br /\u0026gt;\u0026lt;br /\u0026gt; password: \u0026lt;input type=\u0026#34;password\u0026#34; v-model=\u0026#34;password\u0026#34; /\u0026gt;\u0026lt;br /\u0026gt;\u0026lt;br /\u0026gt; \u0026lt;button @click=\u0026#34;login\u0026#34;\u0026gt;ログイン\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;reset\u0026#34;\u0026gt;リセット\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;../js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const app = new Vue({ el: \u0026#39;#app\u0026#39;, data: { username: \u0026#39;\u0026#39;, password: \u0026#39;\u0026#39; }, methods: { login(){ console.log(this.username, this.password) }, reset(){ this.username = \u0026#39;\u0026#39; this.password = \u0026#39;\u0026#39; } } }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; ディレクティブ修飾子 . を使ってディレクティブに接尾辞を付けることで、特定の処理を簡単に実行できるよ。\nキー修飾子\n@keyup.enter エンターキーの入力を監視\nv-model 修飾子\nv-model.trim 前後の空白を削除\nv-model.number 数値に変換\nイベント修飾子\n@イベント名.stop バブリングを阻止\n@イベント名.prevent デフォルトの挙動を阻止\n算出プロパティ (Computed) すでにあるデータをもとに計算される新しいプロパティのこと。依存しているデータが変わると、自動で再計算されるよ。\n1 2 3 4 5 6 7 8 9 10 11 new Vue(){ el: \u0026#34;#app\u0026#34;, data: { count: 0, }, computed: { doubleCount() { return this.count * 2; }, }, } Vue ライフサイクル ライフサイクルっていうのは、オブジェクトが作成されてから破棄されるまでの一連の流れのこと。\nVue のライフサイクルには8つの段階があって、それぞれのタイミングでライフサイクルメソッド（フック）が自動で実行されるんだ。\n状態 フェーズ/周期 beforeCreate 作成前 created 作成後 beforeMount マウント前 mounted マウント完了 beforeUpdate 更新前 updated 更新後 beforeDestroy 破棄前 destroyed 破棄後 その中でも mounted はよく使われるよ。Vue の初期化が成功して、HTML のレンダリングが完了した状態を指すんだ。（サーバーにデータをリクエストして読み込むときとかに使うね）\n1 2 3 4 5 6 7 8 9 10 11 12 new Vue(){ el: \u0026#34;#app\u0026#34;, data: { }, mounted(){ console.log(\u0026#34;Vue のマウントが完了。データを取得するリクエストを送信するよ\u0026#34;); }, methods: { } } ","date":"2024-11-15T20:48:29+08:00","permalink":"https://blog.yexca.net/ja/archives/196/","title":"Vueの学習"},{"content":" 📢 この記事は gemini-2.5-flash によって翻訳されました はじめに HTML学習その1 - 基本編: https://blog.yexca.net/ja/archives/146 HTML学習その2 - リスト、テーブル、フォーム: https://blog.yexca.net/ja/archives/150 HTML学習その3 - Webページのレイアウト: https://blog.yexca.net/ja/archives/195 標準フローはドキュメントフローとも呼ばれてて、要素がページ内でデフォルトで配置されるルールを指すよ。例えば、ブロック要素は1行を占有し、インライン要素は1行に複数表示できるって感じ。\n標準フローじゃないレイアウトにするなら、フロートかFlexレイアウトを使えばOK。\nフロート 役割：ブロック要素を横に並べること。プロパティ名はfloatで、値はleftとrightの2つがあるよ。\nフロートを設定したボックスは標準フローから外れるから注意ね。\nフロートの影響をクリアする フロート要素は標準フローから外れちゃうから、親要素に高さがない場合、自分で親の高さを確保できなくなって、ページのレイアウトがぐちゃぐちゃになる可能性があるんだ。\nフロートをクリアする一般的な方法は4つあるよ。\n追加タグを使う方法 親要素の最後にブロック要素を追加して、CSSプロパティのclear:bothを設定するんだ。\n1 2 3 4 5 6 7 8 9 10 \u0026lt;style\u0026gt; .clearfix { clear: both; } \u0026lt;/style\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;clearfix\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; シングル疑似要素を使う方法 原理は上と同じ。\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;style\u0026gt; .clearfix::after { content: \u0026#34;\u0026#34;; display: block; clear: both; } \u0026lt;/style\u0026gt; \u0026lt;div class=\u0026#34;clearfix\u0026#34;\u0026gt; \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ダブル疑似要素を使う方法 この方法は、高さの崩れとフロートの影響を同時に解決できるんだ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;style\u0026gt; .clearfix::before, /* 高さの崩れを解決 */ .clearfix::after { content: \u0026#34;\u0026#34;; display: table; } .clearfix::after { /* フロートの問題を解決 */ clear: both; } \u0026lt;/style\u0026gt; \u0026lt;div class=\u0026#34;clearfix\u0026#34;\u0026gt; \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; overflowプロパティを使う方法 親要素にCSSプロパティのoverflow: hidden;を追加するだけ。\nFlex Flexレイアウトは、フレキシブルボックスレイアウトとも呼ばれてて、ブラウザが推奨してるレイアウトモデルなんだ。構造化されたレイアウトにすごく適していて、強力な空間分布と配置（アライメント）機能を提供してくれるよ。\nそれに、Flexモデルはフロートレイアウトみたいに標準フローから外れるってことがないから、Webページのレイアウトがもっとシンプルで柔軟になるんだ。\n構成要素 Flexには4つの構成要素があるよ。\nフレックスコンテナ フレックスアイテム 主軸（メインアクシス）：デフォルトでは水平方向 側軸（クロスアクシス）：デフォルトでは垂直方向 親要素にdisplay: flex;を設定すると、それがフレックスコンテナになって、子要素はフレックスアイテムになるんだ。すると自動的に縮んだり伸びたりしてくれるようになるよ。\nFlexレイアウト 記述 属性 主軸の配置方法 justify-content 側軸の配置方法 align-items 特定のフレックスアイテムの\n側軸の配置方法 align-self 主軸の方向を変更 flex-direction フレックスアイテムの伸縮 flex フレックスアイテムの折り返し flex-wrap 行の配置方法 align-content 主軸の配置方法 プロパティ名：justify-content\n属性値 効果 flex-start デフォルト値。フレックスアイテムが開始位置から順番に並ぶよ。 flex-end フレックスアイテムが終了位置から順番に並ぶよ。 center フレックスアイテムが主軸に沿って中央に配置されるよ。 space-between フレックスアイテムが主軸に沿って均等に配置されて、余白はアイテム間に均等に割り振られるよ。 space-around フレックスアイテムが主軸に沿って均等に配置されて、余白はアイテムの両側に均等に割り振られるよ。 space-evenly フレックスアイテムが主軸に沿って均等に配置されて、アイテムとコンテナの間の余白が同じになるよ。 側軸の配置方法 プロパティ名\nalign-items：現在のフレックスコンテナ内の全フレックスアイテムの側軸方向の配置方法（フレックスコンテナに設定する） align-self：特定のフレックスアイテム単独の側軸方向の配置方法を制御（フレックスアイテムに設定する） 属性値 効果 stretch フレックスアイテムが側軸に沿ってコンテナいっぱいに引き伸ばされるよ（フレックスアイテムに側軸方向のサイズが設定されてない場合、デフォルトで引き伸ばされる）。 center フレックスアイテムが側軸に沿って中央に配置されるよ。 flex-start フレックスアイテムが開始位置から順番に並ぶよ。 flex-end フレックスアイテムが終了位置から順番に並ぶよ。 主軸の方向を変更 主軸はデフォルトで水平方向で、側軸はデフォルトで垂直方向になってるよ。\nプロパティ名：flex-direction\n属性値 効果 row 水平方向、左から右へ（デフォルト） column 垂直方向、上から下へ row-reverse 水平方向、右から左へ column-reverse 垂直方向、下から上へ フレックスアイテムの伸縮比率 役割：フレックスアイテムの主軸方向のサイズを制御すること。プロパティ名：flexで、子要素（フレックスアイテム）に追加するよ。\nプロパティ値：整数値で、親要素の残りサイズをどれくらいの割合で占有するかを表すよ。\nフレックスアイテムの折り返し フレックスアイテムは自動的に縮んだり伸びたりするけど、デフォルトでは全部のアイテムが1行に表示されるんだ。プロパティ名：flex-wrapで、親要素（フレックスコンテナ）に追加するよ。\n値にはwrap（折り返す）とnowrap（折り返さない、デフォルト）があるよ。\n行の配置方法 プロパティ名：align-content\nプロパティ値は主軸の配置方法と同じで、複数行のフレックスアイテムにのみ適用されるんだ。\n","date":"2024-11-10T21:36:51+08:00","permalink":"https://blog.yexca.net/ja/archives/195/","title":"HTML学習その3 - Webページのレイアウト"},{"content":" 📢 この記事は gemini-3-flash-preview によって翻訳されました はじめに 2022 SA 午前II\n01-08: http://127.0.0.1:4000/ja/archives/191 09-15: http://127.0.0.1:4000/ja/archives/192 16-20: http://127.0.0.1:4000/ja/archives/193 21-25: http://127.0.0.1:4000/ja/archives/194 この5問の難易度はまあまあかな。解き終わったときは自信満々だったんだけど、午後の論述問題（論文）をちらっと見たら、一気に自信をなくしちゃったよ :cry:\nひとりごと 人生について考えるなんてのは、確かに暇な人がすることだよね。忙しくなるとそんなこと考えてる暇もなくなっちゃうし。まあ忙しすぎても、逆に考えちゃうかもしれないけど。\n今思うと、自分には足りないところが2つあった気がする。1つは「いつでも復習できる」と思い込んでいたこと。もう1つは「学びに終わりなし（学無止境）」という考え方の誤用だね。\nまずは「学びに終わりなし」から。この言葉自体は正しいんだけど、僕の理解がちょっと偏っていたんだ。知識は無限だから、何事も完全にマスターするのは不可能だと思い込んで、そのせいで「自分は何もできない」っていうマインドセットになっちゃってた。実際には知識は無限だけど、実務で使うにはその分野のすべてを極める必要はないんだよね。一部をマスターするだけで、仕事やタスクをこなすには十分なことも多い。\n例えば、試験に合格した後でも「自分はまだ何も知らないし、関連する仕事なんてできない」って感じることがよくあった。でも客観的に見れば、必要な部分さえ押さえていれば、タスクを完了する能力は備わっているはずなんだ。この考え方は、昔受けてきた教育のせいかもしれない。「世界は広い」「学びは全然足りない」「本当のプロはもっとすごい」みたいな言葉をよく聞いてきたから。それが学習のモチベーションになることもあるけど、自分の欠点ばかりに目が向いて、自信を失う原因にもなっていたんだと思う。\n今の学生たちも「自分には何もできない」って言っているのをよく耳にするけど、もしかしたらこの考え方の副作用なのかもしれないね。\n次は「いつでも復習できる」という考え。復習というよりは、「いつでも調べられる」という依存心に近いかな。以前日本語のN2の勉強をしていたときに、文字を持たない人々がどうやって学ぶか、という文章を読んだんだ。文字の記録がないから、授業などで知識を得るチャンスは一生に一度しかなくて、だから死ぬ気ですべてを覚えなきゃいけない。その文章には、現代の僕たちがネットが便利すぎて物を覚えようとせず、検索で見つかるものを自分の知識だと思い込んでいることも書かれていた。もしネットが使えなくなったら、実際には何も知らないのと同じ。本当に自分の知識と言えるのは、記憶として内面化されたものだけなんだ。\n自分の状況に当てはめてみると、Linuxのコマンドやアルゴリズムのコードなんかを「いつでも見られる」と思って覚えないようにしていた。そのせいで「できるつもり」になっているけど、いざ使うときに書けない。これは実際には「できない」の範疇に入るんだよね。こういう経験を繰り返すことで、さっき言った「何もできない」という感覚がさらに強まってしまった。\nまとめると、まずは「覚えていないことは、できないこと」だと自覚すること。そして、ある作業をこなしたり、ある役割を担ったりするために必要な知識には境界があるから、すべてを完璧に極めようとしなくてもいい、ということだね。\n書いていることと伝えたいことがちょっとズレている気がするけど、文章力がないしChatGPTも使ったから、まあこんな感じかな。\n21 容量が a M バイトでアクセス時間がｘナノ秒の命令キャッシュと、容量が b M バイトでアクセス時間がｙナノ秒の主記憶をもつシステムにおいて、CPUからみた、主記憶と命令キャッシュとを合わせた平均アクセス時間を表す式はどれか。ここで、読み込みたい命令コードが命令キャッシュに存在しない確率をｒとし、キャッシュ管理に関するオーバヘッドは無視できるものとする。\n$$ \\begin{align} ア　\u0026\\frac{(1-r)\\cdot a}{a+b} \\cdot x +\\frac{r \\cdot b}{a+b} \\cdot y \\\\ イ　\u0026(1-r) \\cdot x + r \\cdot y \\\\ ウ　\u0026\\frac{r \\cdot a}{a+b} \\cdot x + \\frac{(1-r) \\cdot b}{a+b} \\cdot y \\\\ エ　\u0026r \\cdot x + (1-r) \\cdot y \\end{align} $$解説：\nキャッシュにヒットする場合の時間は $(1-r) \\times x$ キャッシュにヒットせず、主記憶を読み込む時間は $r \\times y$ よって、答えは イ。\n22 データベースサーバのクラスタリング技術の特徴のうち、シェアードエブリシングはどれか。\nア　クラスタリング構成にして可用性を高めることによって、故障発生時に担当していた範囲のデータを待機系のサーバに引き継ぐことができる。\nイ　サーバごとに管理する対象データが決まっているので、1台のサーバに故障が発生すると故障したサーバが管理する対象データを処理できなくなり、システム全体の可用性が低下する。\nウ　データを複数の磁気ディスクに分割配置し、更にサーバと磁気ディスクが1対1に対応しているので、複数サーバを用いた並列処理ができる。\nエ　負荷を分散し、全てのサーバのリソースを有効活用できることに加えて、データを共有することによって1台のサーバに故障が発生したときでも処理を継続することができる。\n解説： Shared Everything（共有ディスク）は、すべてのサーバが同じデータストレージを共有するデータベースクラスタ構成のこと。これにより、どのサーバのリソースからでもデータベース内のすべてのデータにアクセスして処理できるため、システムの冗長性と耐障害性が高まる。1台のサーバが故障しても、他のサーバがそのタスクを引き継ぐことができるので、システム全体が使えなくなることはない。よって、答えは エ。\nア はアクティブ/スタンバイ構成、イ は Shared Nothing 構成、ウ は各サーバが専用ディスクを持つ構成（Shared Nothingに近い）の説明だね。\n23 幾つかのサブシステムから成るシステムの信頼性に関する記述のうち、適切なものはどれか。\nア　あるサブシステムで発生したフォールトの影響が他のサブシステムに波及することを防ぐフォールトマスキングは、システムのMTBFは変化させないが、MTTRの短縮につながる。\nイ　サブシステムにフォールトが検出されたとき、再試行すると正しい結果が得られる場合もあるので、再試行はシステムのMTBFの向上とMTTRの短縮につながる。\nウ　サブシステムの稼働中に行われるフォールトの検出は、システムを停止せず行われるので、システムのMTTRは変化させないが、MTBFの向上につながる。\nエ　フォールトが発生したあるサブシステムを切り離して、待機系のサブシステムに自動で切り替えるフェールオーバーは、システムのMTBFは変化させないが、MTTRの短縮につながる。\n解説： 信頼性は通常、MTBF（平均無故障間隔）とMTTR（平均修理時間）によって決まる。\nFault Masking（フォールトマスキング）は、故障の影響が他に広がらないようにするもの。故障したサブシステムの特定や修復には役立つかもしれないけど、故障そのものを防ぐわけではないからMTBFには直接影響しない。\n再試行（リトライ）は偶発的なエラーへの対処法だけど、これは耐障害（フォールトトレラント）メカニズムであって、システム全体のMTBFを向上させるものではない。根本的な故障が減るわけではないからね。\n稼働中の故障検出はMTBFを直接向上させるものではない（故障は発生している）。\nFailover（フェールオーバー）は、故障したシステムを即座に待機系に切り替える。これにより復旧時間が大幅に短くなるから、MTTRの短縮に直結する。一方で、故障の発生頻度（MTBF）自体には影響しない。\nア と エ で迷うかもしれないけど、答えは エ。フェールオーバーの方が復旧時間の短縮という意味でより直接的だね。\n24 $t_{1} \\sim t_{10}$ の時刻でスケジュールされたトランザクション $T_1 \\sim T_4$ がある。時刻 $t_{10}$ で $T_1$ が commit を発行する直前の、トランザクションの待ちグラフを作成した。a に当てはまるトランザクションはどれか。ここで、select(X) は共有ロックを掛けて資源 X を参照することを表し、update(X) は専有ロックを掛けて資源 X を更新することを表す。これらのロックは、commit された時にアンロックされるものとする。また、トランザクションの待ちグラフの矢印は、$T_i \\rightarrow T_j$ としたとき、$T_j$ がロックしている資源のアンロックを、$T_i$ が待つことを表す。\n（トランザクションのスケジュール$t_1$）\n時刻 $T_1$ $T_2$ $T_3$ $T_4$ $t_1$ select(A) $t_2$ select(B) $t_3$ select(B) $t_4$ select(A) $t_5$ update(B) $t_6$ select(C) $t_7$ select(C) $t_8$ update(C) $t_9$ update(A) $t_{10}$ commit （トランザクションの待ちグラフ）\nア　$T_1$\nイ　$T_2$\nウ　$T_3$\nエ　$T_4$\n解説： データベースの排他制御（共有ロック S と専有ロック X）についてだね。\n共有ロック（S）同士は競合しないけど、専有ロック（X）は他のロックと競合する。\n時刻 $t_5$：$T_4$ が B に専有ロック（update）をかけようとする。でも B は $T_2$ と $T_3$ が共有ロック（select）をかけているので、ここで $T_4$ は $T_2$ と $T_3$ の解放待ちになる。グラフで2つの矢印を受けている b か c が $T_4$ になる。 時刻 $t_8$：$T_2$ が C に専有ロックをかけようとする。でも C は $T_1$ が共有ロックをかけているので、$T_2$ は $T_1$ の解放待ちになる。グラフで1つの矢印を出している a が $T_2$、待ち先の d が $T_1$ と推測できる。 時刻 $t_9$：$T_3$ が A に専有ロックをかけようとする。でも A は $T_1$ と $T_4$ が共有ロックをかけているので、$T_3$ は $T_1$ と $T_4$ の解放待ちになる。 これらを整理すると：\n$T_2$ (a) $\\rightarrow T_1$ (d) $T_4$ (b) $\\rightarrow T_2$ (a), $T_3$ (c) （※ $T_4$ は $T_2$ と $T_3$ を待つ） $T_3$ (c) $\\rightarrow T_1$ (d), $T_4$ (b) （※ $T_3$ は $T_1$ と $T_4$ を待つ） a に当てはまるのは $T_2$。よって答えは イ。\n25 図は、既存の電話機とPBXを使用した企業内の内線網を、IPネットワークに統合する場合の接続構成を示している。図中の $a \\sim c$ に該当する装置の適切な組合せはどれか。\n- a b c ア PBX VoIPゲートウェイ ルータ イ PBX ルータ VoIPゲートウェイ ウ VoIPゲートウェイ PBX ルータ エ VoIPゲートウェイ ルータ PBX 解説： 従来の電話システムを IP ネットワークに統合するために必要なデバイスの役割を考えよう。\nPBX (Private Branch Exchange)：企業の拠点内で内線電話を交換するための装置。電話機が直接つながる (a) VoIP ゲートウェイ：電話の音声信号を IP パケットに変換（またはその逆）して、IP ネットワークとつなぐための装置 (b) ルータ：IP ネットワーク上でパケットを転送するための装置 (c) したがって、a = PBX、b = VoIP ゲートウェイ、c = ルータ となる。答えは ア。\n","date":"2024-11-08T18:29:54+08:00","permalink":"https://blog.yexca.net/ja/archives/194/","title":"2022 SA 午前II -21-25"},{"content":" 📢 この記事は gemini-3-flash-preview によって翻訳されました はじめに 2022 SA 午前2\n01-08: http://127.0.0.1:4000/ja/archives/191 09-15: http://127.0.0.1:4000/ja/archives/192 16-20: http://127.0.0.1:4000/ja/archives/193 21-25: http://127.0.0.1:4000/ja/archives/194 だんだん難しくなってきた気がするけど、まあまだなんとかなるかな (doge\n16 e シールの説明はどれか。\nア　インターネット上のゲーム内に限定されたキャラクターのイメージデータの作成者を証明する仕組みの一つである。\nイ　個人の意思表示をしている個人の本人確認が必要な電子文書データについて、その電子文書データの作成者の証明と改ざん防止のために、個人が行う電子署名である。\nウ　電子文書データの作成者の証明と改ざん防止のために、重要文書を扱う国や地方自治体などの公共機関だけに使用が許されている電子署名である。\nエ　法人が作成した電子文書データについて、その電子文書データの作成者が間違いなくその法人であり、かつその電子文書データは作成後に改ざんされていないことを証明するものである。\n【問題の訳】e シールの説明はどれか\nア　インターネット上でゲームキャラクターのイメージデータの作成者を証明する仕組みで、ゲーム内限定のもの。\nイ　個人の本人確認が必要な電子文書に対して、作成者の証明と改ざん防止のために個人が行う電子署名。\nウ　電子文書の作成者証明と改ざん防止のため、国や地方自治体などの公共機関だけが使用を許されている電子署名。\nエ　法人が作成した電子文書について、作成者が間違いなくその法人であり、作成後に改ざんされていないことを証明するもの。\ne シール（e-Seal）は、通常、法人や組織が発行する電子文書の真正性を保証するために使われるんだ。作成者がその法人であることと、改ざんがないことを証明するものだから、正解は選択肢 エ だよ。\n17 マルチベクトル型 DDoS 攻撃に該当するものはどれか。\nア　攻撃対象のWebサーバ1台に対して、多数のPCから一斉にリクエストを送ってサーバのリソースを枯渇させる攻撃と、大量のDNS通信によってネットワークの帯域を消費する攻撃を同時に行う。\nイ　攻撃対象のWebサイトのログインパスワードを解読するために、ブルートフォースによるログイン試行を、多数のスマートフォン、IoT機器などから成るボットネットを踏み台にして一斉に行う。\nウ　攻撃対象のサーバに大量のレスポンスが同時に送り付けられるようにするために、多数のオープンリゾルバに対して、送信元IPアドレスを攻撃対象のサーバのIPアドレスに偽装した名前解決のリクエストを一斉に送信する。\nエ　攻撃対象の組織内の多数の端末をマルウェアに感染させ、当該マルウェアを遠隔操作することによってデータの改ざんやファイルの消去を一斉に行う。\n【問題の訳】マルチベクトル型 DDoS 攻撃に該当するものはどれか\nア　ターゲットのWebサーバ1台に対し、多数のPCからリクエストを送ってリソースを枯渇させる攻撃と、大量のDNS通信で帯域を消費する攻撃を同時に行う。\nイ　ターゲットサイトのパスワード解読のため、ボットネット（スマホやIoT機器）を踏み台にして一斉にブルートフォース攻撃を行う。\nウ　ターゲットサーバに大量のレスポンスを送りつけるため、送信元を偽装して多数のオープンリゾルバに名前解決リクエストを一斉に送信する。\nエ　組織内の多数の端末をマルウェアに感染させ、遠隔操作でデータの改ざんやファイル消去を一斉に行う。\nマルチベクトル型 DDoS 攻撃は、複数の異なる攻撃手法を組み合わせて行う攻撃のこと。選択肢 ア は「サーバーリソースの枯渇」と「ネットワーク帯域の消費」という2つの手法を同時に使っているから、これがマルチベクトル攻撃に当たる。選択肢 ウ は DNS アンプ攻撃（Amplification Attack）単体だから違うし、イ はログイン試行、エ はマルウェア感染による破壊工作だから DDoS 攻撃の定義とは少しズレるんだ。というわけで答えは ア。\n18 暗号方式に関する記述のうち、適切なものはどれか。\nア　AESは公開鍵暗号方式、RSAは共通鍵暗号方式の一種である。\nイ　共通鍵暗号方式では、暗号化及び複合に同一の鍵を使用する。\nウ　公開鍵暗号方式を通信内容の秘匿に使用する場合は、暗号化に使用する鍵を秘密にして、複合に使用する鍵を公開する。\nエ　デジタル署名に公開鍵暗号方式が使用されることはなく、共通鍵暗号方式が使用される。\n【問題の訳】暗号方式に関する記述のうち、適切なものはどれか\nア　AES は公開鍵暗号方式、RSA は共通鍵暗号方式の一種である。\nイ　共通鍵暗号方式では、暗号化と復号に同一の鍵を使用する。\nウ　公開鍵暗号方式を通信の秘匿に使う場合、暗号化用の鍵を秘密にし、復号用の鍵を公開する。\nエ　デジタル署名に公開鍵暗号方式が使われることはなく、共通鍵暗号方式が使われる。\nこれは暗号の基本問題だね。正解は イ。AES は共通鍵、RSA は公開鍵暗号方式（アは逆）。公開鍵暗号で通信を秘匿するときは、相手の「公開鍵」で暗号化して、相手が自分の「秘密鍵」で復号する（ウも間違い）。デジタル署名には公開鍵暗号方式が使われるのが一般的だよ（エも間違い）。\n19 CRYPTREC の役割として、適切なものはどれか。\nア　外国為替及び外国貿易法で規制されている暗号装置の輸出許可申請を審査、承認する。\nイ　政府調達においてIT関連製品のセキュリティ機能の適切性を評価、認証する。\nウ　電子政府での利用を推奨する暗号技術の安全性を評価、監視する。\nエ　民間企業のサーバに対するセキュリティ攻撃を監視、検知する。\n【問題の訳】CRYPTREC の役割として適切なものはどれか\nア　外為法で規制されている暗号装置の輸出許可申請を審査・承認する。\nイ　政府調達における IT 製品のセキュリティ機能の適切性を評価・認証する。\nウ　電子政府での利用を推奨する暗号技術の安全性を評価・監視する。\nエ　民間企業のサーバに対する攻撃を監視・検知する。\nCRYPTREC (Cryptography Research and Evaluation Committees) は、日本の電子政府で利用される暗号技術の安全性を評価・監視し、推奨リストなどを作成するプロジェクトのこと。だから答えは ウ になる。\n20 インターネットとの接続において、ファイアウォールのNAPT機能によるセキュリティ上の効果はどれか。\nア　DMZ上にある公開Webサイトの脆弱性を悪用する攻撃を防御できる。\nイ　インターネットから内部ネットワークへの侵入を検知し、検知後の通信を遮断できる。\nウ　インターネット上の特定のWebサービスを利用するHTTP通信を検知し、遮断できる。\nエ　内部ネットワークからインターネットにアクセスする利用者PCについて、インターネットからの不正アクセスを困難にすることができる。\n【問題の訳】インターネット接続において、ファイアウォールの NAPT 機能によるセキュリティ効果はどれか\nア　DMZ 上の公開 Web サイトの脆弱性を突く攻撃を防御できる。\nイ　外部から内部への侵入を検知し、通信を遮断できる。\nウ　特定の Web サービスへの HTTP 通信を検知・遮断できる。\nエ　内部から外部へアクセスする PC に対して、外部からの不正アクセスを困難にできる。\nNAPT (Network Address Port Translation) は、プライベート IP アドレスとグローバル IP アドレスをポート番号を使って紐付ける技術。これによって、外部からは内部ネットワークの個々の PC の IP アドレスが直接見えなくなるし、外部から勝手に通信を開始することが難しくなる（戻りの通信しか通さない設定が一般的だから）。なので、セキュリティ的な効果としては エ が正解。\n","date":"2024-11-06T22:05:18+08:00","permalink":"https://blog.yexca.net/ja/archives/193/","title":"2022 SA 午前2 問16-20"},{"content":" 📢 この記事は gemini-3-flash-preview によって翻訳されました はじめに 2022 SA 午前2\n01-08: http://127.0.0.1:4000/ja/archives/191 09-15: http://127.0.0.1:4000/ja/archives/192 16-20: http://127.0.0.1:4000/ja/archives/193 21-25: http://127.0.0.1:4000/ja/archives/194 中盤の問題から難易度が上がってきた気がする。学んだことのない内容ばかりで、「合格できそう」なんて言った前言を撤回したい気分だ。でも、何も学ばずにそのまま受かるよりは、たとえ不合格でも学んだ知識が自分に影響を与えてくれる方がいいよね（また語り出しちゃいそうな予感）。\nひとりごと 書きたいことが多すぎるから、「はじめに」じゃなくて「ひとりごと」に変えるね（本当は一番上に置いてたんだけど、記事の内容に関することを先に書いた方がいいと思って。だから接続がちょっと変かも）。\n最近、どの記事でも何かしら感悟みたいなのを書いてる気がする（笑）。人間の発想力には限界があるっていうのにね。\n実は、こういう感悟や思考が出てくるようになったのは、去年からなんだ。目がすごく痛くなって、ただベッドに横になって音楽を聴くことしかできなかった時期があった（画面だけじゃなく、自然の景色を見るのも辛かった）。その横になっている時間に、夢なのか妄想なのか分からないけど（寝ているのか起きているのか、目の痛みと体の気だるさで境界が曖昧だった）、自分に深く影響を与えた2つの理論を思いついたんだ。それを「状態行動理論」と「圏理論（サークル理論）」と名付けた。それを大体形にしてからは、夢の中や何かを考えている時にいつもこの理論に立ち返って、細部を修正したり再考したりしている。もちろん、最近の記事に書いてるような他の思考もあるよ。当時はその2つの理論を書き出そうと思ったんだけど、ズルズルと先延ばしにしているうちに、発表するのが少し恥ずかしくなっちゃった。ちゃんと先行研究を調べたわけでもない、独りよがりの理論を発表するのはどうかなって。それに、普段はこのブログは技術的な話だけにするべきだと思ってたし。でも今は吹っ切れたかな。技術を学ぶ第一歩は関連するコースを探すことだけど、僕が書いたものなんてそんなに誰も見てないし、好きに作っちゃえばいいんだ。（warmaが「爆発ラジオ」を紹介してた時の様子を思い出しちゃった）。\nそういえば、今の流れでwarmaの動画を探してみたんだけど、すぐには見つからなかった。消えた第2回だったかな。でも第9回の冒頭で「皆さんは、何かをやろうとして完璧な計画を立てたのに、いざ実行してみたら、第一歩目から計画通りに進めるのが嫌になった経験はありませんか？『なんで計画通りにやらなきゃいけないんだ』って感じちゃうような」という話をしていた。これは僕の以前の葛藤を思い出させた。人生に計画がなかったり決められた通りだったりすると、目標がなくてどう動けばいいか分からなくなる。でも、計画があったり手配通りだったりすると、人生が不自由だと感じてしまう。その結果、計画を立てては壊し、また立てては壊すというループの中で、結局何も成し遂げられない。実際、今の僕はそういう状態だ。何かを求めていても近づこうとせず、失うのを恐れて、少しの失敗で諦めてしまう。これは昨日考えていた「信頼」の話にも通じるんだけど、長くなるから割愛するね。でもwarmaの言葉を聴いた瞬間、その状態を打破できるような感覚があった（これも前の考えと繋がっている）。特定の人が発する言葉は、時に人生に影響を与える。おかげで、一時的にいくつかの迷いが消えた気がする。\nいつの間にか結構な文字数になっちゃった。まだ話したいことはあるけど、この辺にしておくのがいいかな。こうして書いていると、他のブログで個人年報みたいなまとめ記事が出る理由が分かった気がする（最近見たのは 翠翠 さんのかな）。\nプレビューで見たら、本文より長くなりそう（笑）\n9 ソフトウェアのテスト工程において、バグ管理図を用いて、テストの進捗状況とソフトウェアの品質を判断したい。このときの考え方のうち、最も適切なものはどれか。\nア　テスト工程の前半で予想以上にバグが摘出され、スケジュールが遅れたので、スケジュールの見直しを行い、五日遅れでテストが終了すると判断した。\nイ　テスト項目がスケジュールどおりに消化され、かつ、バグ摘出の累積件数が増加しなければ、ソフトウェアの品質は高いと判断できる。\nウ　テスト項目消化の累積件数、バグ摘出の累積件数及び未解決バグの件数の全てが変化しなくなった場合は、解決困難なバグに直面しているかどうかを確認する必要がある。\nエ　バグ摘出の累積件数の推移とテスト項目の未消化件数の推移から、テスト終了の時期をほぼ正確に予測できる。\nテストの進捗と品質管理において、バグ管理図はバグの累積トレンドやテストの完了状況を視覚化するために使われる。これらのトレンドを分析することで、チームは進捗と品質をより良く理解できる。この問題では、アはバグ管理図とは無関係。イは、バグが見つからないからといって品質が高いとは限らない（テストが不十分な可能性もある）ので間違い。残りの2つのうち、参考回答はウ。進捗と品質の両方を判断するという意味で、この選択肢が一番しっくりくるのかな（僕も完全には納得してないけど）。\n10 故障の予防を目的とした解析手法であるFMEAの説明はどれか。\nア　個々のシステム構成要素に起こり得る潜在的な故障モードを特定し、それらの影響度を評価する。\nイ　故障を、発生した工程や箇所などで分類して分析し、改善すべき工程や箇所を特定する。\nウ　発生した故障について、故障の原因に関係するデータ、事象などを収集し、”なぜ”を繰り返して原因を掘り下げ、根本的な原因を追究する。\nエ　発生した故障について、その引き金となる原因を列挙し、それらの関係を木構造で表現する。\nFMEA (Failure Mode and Effects Analysis、故障モード影響解析) は、システムや部品の潜在的な故障モードを特定し、その影響を評価して、故障を未然に防ぐための体系的な手法。主に予防保守や設計改善に使われる。だから正解は ア。\nイ は故障分類分析、ウ は RCA (根本原因分析)、エ は FTA (故障の木解析) の説明だね。\n11 JIS X 0160:2021 (ソフトウェアライフサイクルプロセス) によれば、廃棄プロセスのタスクのうち、アクティビティ“廃棄を確実化する”において実施すべきタスクはどれか。\nア　選定されたソフトウェアシステム要素を再利用、再生利用、再調整、分解修理、保管又は破壊する。\nイ　ソフトウェアシステムの廃棄戦略を定義する。\nウ　ソフトウェアシステム又は要素を不活化して取り除くための準備する。\nエ　廃棄後の、人の健康、安全性、セキュリティ及び環境への有害な状況が識別されて対処されていることを確認する。\nア は具体的な廃棄の実行、イ は戦略の定義、ウ は廃棄前の準備段階。エ は廃棄後に負の影響が出ないことを確認する内容で、これが「廃棄を確実にする」という目的に合致している。だから正解は エ。\n12 JIS X 0160:2021 (ソフトウェアライフサイクルプロセス) によれば、ライフサイクルモデルの目的及び成果を達成するために、ライフサイクルプロセスを修正するか、又は新しいライフサイクルプロセスを定義することを何というか。\nア　シミュレーション\nイ　修整（Tailoring）\nウ　統治（Governance）\nエ　ベンチマーキング\nシミュレーションはモデルを使ってシステムの挙動を模倣すること。テーラリング（Tailoring）は、特定のニーズに合わせてライフサイクルプロセスを調整したり新しいプロセスを定義したりすること。統治（Governance）は組織やプロジェクトの管理・監督。ベンチマーキングはベストプラクティスとの比較。ということで、答えは イ。\n13 IT 投資に対する評価指標の設定に際し、バランススコアカードの手法を用いてKPIを設定する場合に、内部ビジネスプロセスの視点に立ったKPIの例はどれか。\nア　ITリテラシ向上のための研修会の受講率を100％とする。\nイ　売上高営業利益率を前年同期比5％アップとする。\nウ　顧客クレーム件数を1か月当たり20件以内とする。\nエ　注文受付から製品出荷までの日数を3日短縮とする。\nバランススコアカード (BSC) は、財務指標だけでなく非財務指標も組み合わせて多角的に評価するマネジメント手法。主に4つの視点がある：\n財務の視点：収益、利益率など。 顧客の視点：顧客満足度、クレーム数など。 内部ビジネスプロセスの視点：業務効率、サイクルタイムなど。 学習と成長の視点：従業員のスキル、研修受講率など。 設問は「内部ビジネスプロセス」なので、業務の期間短縮に関わる エ が正解。\n14 組込みシステム開発において、製品に搭載するLSIを新規に開発する。LSI設計を自社で行い、LSI製造を外部に委託する場合の委託先として、適切なものはどれか。\nア　IPプロバイダ\nイ　デザインハウス\nウ　ファウンドリ\nエ　ファブレスメータ\nIPプロバイダは設計資産（IP）を提供する会社。デザインハウスは設計を支援する会社。ファウンドリ（Foundry）は半導体の製造を専門に請け負う会社。ファブレス（Fabless）は工場を持たず設計に特化する会社。今回は「製造を外注する」ので、答えは ウ。\n15 ラボ契約の特徴はどれか。\nア　依頼元がベンダ企業側の作業担当者を指名して直接指揮命令を行う契約であり、ベンダ企業はこれを前提に要員を割り当てる。\nイ　依頼元は、契約に基づきスキルや人数などの準備を満たすように要員を確保することをベンダ企業に求めるかわりに一定以上の発注を約束する。\nウ　開発したシステムによって依頼元が将来獲得する売上や利益をベンダ企業にも分配することを条件に、開発時のベンダ企業への発注金額を抑える。\nエ　ベンダ企業が契約で定めた最低発注工数を下回って作業を完了した場合には、実稼働工数に基づいて請求することが求められる。\nラボ契約（Lab Contract）は、特定の期間、一定のスキルを持った人員を確保する契約形態。ア は準委任や派遣に近い説明。ウ はレベニューシェア型。ラボ契約の特徴は、一定のリソース確保を約束する代わりに発注量を保証する イ が正しい。\n","date":"2024-11-04T23:29:15+08:00","permalink":"https://blog.yexca.net/ja/archives/192/","title":"2022 SA 午前2 -09-15"},{"content":" 📢 この記事は gemini-3-flash-preview によって翻訳されました はじめに 2022 SA 午前2\n01-08: http://127.0.0.1:4000/ja/archives/191 09-15: http://127.0.0.1:4000/ja/archives/192 16-20: http://127.0.0.1:4000/ja/archives/193 21-25: http://127.0.0.1:4000/ja/archives/194 この専門試験の難易度はそこそこだけど、これまでに学んだ内容も出てくるね。しっかり勉強すれば午前（客観式）はパスできそう。早めに終わらせて午後問題に取り掛かりたいな、そっちが合格の決め手だから。\nそういえば、共通Iの時のやり方は良くなかったなと反省してる。全く理解できていない状態で問題を解いても意味がないし、一題ずつ丁寧に進めるのが一番。前は記事を書く時に「早く終わらせなきゃ」と思って焦っちゃって、結局あの回は身に付かなかった気がする。最初はゆっくり一歩ずつで大丈夫だよね。\nひとりごと 最近、学習って一種の「繋がり」を作ることなんじゃないかって感じてるんだ。言語学習が「モノ」と「言葉」を繋げるように、他の学習も抽象的な繋がりを作ることなんだと思う。特定の入力に対して特定の出力を出す。それを繰り返すことで繋がりを深くしていくんだ。知識同士の関連付けも同じで、ある点から別の点を導き出すのは、知識間のルートを太くするようなもの。これって、モノと単語を繋げてその概念を把握するのと似てる気がする。（まあ、ただの思いつきで根拠はないけどね。実際、僕らが持ってる意見も、案外あやふやな根拠や自分の経験から勝手に導き出したものだったりするし。人間は自分の経験に基づいて観点を作るから、見たことがないものは想像できないんだよね。でも例外があるとしたら、それは「夢」かな。夢って、実は別の世界を旅してるんじゃないか、なんて妄想しちゃうんだ。最近読んだ小説で、別世界にランダムに飛ばされて、特定の条件を満たすとその世界の記憶を一部持ち帰れるっていうのがあって、自分の夢もそんな感じだったら面白いなと思って。まあ、実際は寝ている間に脳が想像力に全振りして、起きてる時にはできないような発想をしてるだけなんだろうけど。DNAの二重螺旋構造を見つけた人も、夢からインスピレーションを得たらしいしね。）\n1 アジャイル開発の初期段階において、プロジェクトの目的、スコープなどに対する共通認識を得るために、あらかじめ設定されている設問と課題について関係者が集まって確認し合い、その成果を共有する手法はどれか。\nア　アジャイルモデリング\nイ　インセプションデッキ\nウ　プランニングポーカ\nエ　ユーザストーリマッピング\n【問題の要約】アジャイル開発の初期に、目的や範囲の共通認識を作るために、質問や課題を確認し合う手法はどれ？\nア agile modeling イ Inception Deck ウ planning poker エ user story mapping\nインセプションデッキ（Inception Deck）は、プロジェクトの初期段階でチームが目的や範囲について合意形成するために使われる重要な手法なんだ。チームは事前に決められた重要な質問（プロジェクトの目標、潜在的リスク、成功基準など）について話し合うことで、全員がプロジェクトの方向性と境界線を明確に理解できるようになる。だから、正解は イ。\n2 ソフトウェアパターンのうち、GoFのデザインパターンの説明はどれか。\nア　Javaのパターンとして、引数オブジェクト、オブジェクトの可変性などで構成される。\nイ　オブジェクト指向開発のためのパターンであって、生成、構造、振る舞いの三つのカテゴリに分類される。\nウ　構造、分散システム、対話型システム及び適合型システムの四つのカテゴリに分類される。\nエ　抽象度が異なる要素を分割して階層化するためのLayers、コンポーネント分割のためのBrokerなどで構成される。\n【問題の要約】GoF（Gang of Four）デザインパターンの説明として正しいのはどれ？\nア Javaのパターン。引数オブジェクトや可変性などで構成。 イ オブジェクト指向開発用で、生成・構造・振る舞いの3つに分類。 ウ 構造、分散、対話型、適合型の4つに分類。 エ 抽象度による階層化（Layers）やコンポーネント分割（Broker）などで構成。\nGoFのデザインパターンは、4人のソフトウェアエンジニアが提唱した古典的なパターンで、オブジェクト指向プログラミングに特化したもの。デザインパターンを「生成（Creational）」「構造（Structural）」「振る舞い（Behavioral）」の3つのカテゴリに分けて、よくある設計上の問題を解決するんだ。だから、正解は イ。\nちょっと 関連する紹介 を調べてみたけど、たぶん僕が 以前書いたデザインパターンの記事 の元ネタだね。\n3 Pattern-Oriented Software Architecture (POSA) のアーキテクチャパターンのうち、ソフトウェアをメタレベルとベースレベルの二つのレベルに分割し、ソフトウェアの構造と振る舞いとを動的に変更できる仕組みを提供しているものはどれか。\nア　Broker\nイ　Microkernel\nウ　Model-View-Controller\nエ　Reflection\n【問題の要約】POSAのパターンの中で、ソフトウェアを「メタレベル」と「ベースレベル」に分け、構造や振る舞いを動的に変更できるようにするのはどれ？\nア Broker（代理） イ Microkernel（マイクロカーネル） ウ Model-View-Controller（MVC） エ Reflection（リフレクション/反射）\nBrokerパターンは、分散システムのコンポーネント間（クライアントとサーバなど）を疎結合にするためのもので、Brokerが通信を仲介する役割を果たす。\nMicrokernelパターンは、OS設計によく使われるもので、コア機能（メモリ管理など）をカーネルに持ち、他の機能は独立したモジュールとして動的に追加・削除できるようにするもの。\nMVCパターンは、アプリケーションのビジネスロジック（Model）、インターフェース（View）、入力制御（Controller）を分離するインタラクティブなシステム用。主に表示とロジックの分離が目的で、動的な構造変更の仕組みではない。\nReflectionパターンは、システムを「メタレベル」と「ベースレベル」の2層に分けるアーキテクチャ。メタレベルにはシステムの構造や振る舞いを記述したメタデータがあり、ベースレベルが実際の業務ロジックを動かす。リフレクションによって、ソフトウェアは実行時に自分の構造や振る舞いを動的に変更できるんだ。高い拡張性や柔軟性が必要なシステムで使われるよ。だから、正解は エ。\n4 組込みシステムでDBMSを用いるときには、通信のオーバヘッド、通信負荷の発生を防ぐこと、必要なメモリ容量をリソース制限内に抑えることなどを目的として、インプロセスデータベースを用いることがある。このインプロセスデータベースの説明として、適切なものはどれか。\nア　クライアントサーバ形式のクライアントとなるアプリケーションプログラムとソケットを介して通信し、SQLを用いて処理を記述する。\nイ　データベースエンジンはライブラリ形式で提供され、アプリケーションプログラムとリンクされて同一メモリ空間で動作する。\nウ　データベースの全体をメモリ上に配置して、データベース処理を高速化する。\nエ　一つのテーブルを一つのファイルで管理し、アプリケーションプログラムからはファイル入出力のAPIで操作する。\n【問題の要約】組込みシステムで使われる「インプロセスデータベース」の説明として正しいのはどれ？\nア ソケット通信を使って、クライアントアプリからSQLで操作する。 イ エンジンがライブラリとして提供され、アプリと同じメモリ空間で動く。 ウ データベース全体をメモリに置いて高速化する。 エ 1テーブル1ファイルで管理し、ファイルI/O APIで操作する。\nインプロセスデータベース（In-process database）は、データベースエンジンがライブラリファイルとしてアプリケーションに組み込まれ、同じメモリ空間を共有するもの。これによってクライアント・サーバ型のような通信オーバーヘッドや負荷を避けられるから、リソースが限られた組み込みシステムに向いているんだ。\nア は一般的なクライアント・サーバ型、ウ は「インメモリデータベース」、エ はファイルベースの管理方法を指しているね。というわけで、正解は イ。\n5 デザインパターンのなかのストラテジパターンを用いて、帳票出力のクラス図のとおりに設計した。適切な説明はどれか。\nア　クライアントは、使用したいフォーマットに対応する、帳票出力ストラテジクラスのサブクラスを意識せずに利用できる。\nイ　新規フォーマット用のアルゴリズムの追加が容易である。\nウ　帳票出力ストラテジクラスの中で、どのフォーマットで帳票を出力するかの振り分けを行っている。\nエ　帳票出力のアルゴリズムは、コンテキストクラスの中に記述する。\n【問題の要約】ストラテジ（Strategy）パターンを使った帳票出力の設計について、正しい説明はどれ？\nア クライアントは具体的なサブクラスを意識しなくていい。 イ 新しいフォーマット用のアルゴリズム追加が簡単。 ウ ストラテジクラス自身がフォーマットの振り分けを行う。 エ アルゴリズムはコンテキストクラスの中に書く。\nこれはストラテジパターンを使って、複数のフォーマットで帳票を出し分ける設計だね。ストラテジパターンの原則は、「アルゴリズムの実装」と「その利用」を分離すること。そうすることで、クライアント側のコードを変えずにアルゴリズムを切り替えたり追加したりできるんだ。ちなみに、ストラテジパターンの記事も書いたことがあるよ： https://blog.yexca.net/ja/archives/137 新しいアルゴリズム（フォーマット）を増やしたい時は、新しい具体的なストラテジクラスを作るだけで既存の構造に組み込めるから、追加がすごく楽なんだ。だから、正解は イ。\n6 モジュール間のデータの受渡し方法のうち、最も低いモジュール結合度となるものはどれか。\nア　単一のデータ項目を大域的データで受け渡す。\nイ　単一のデータ項目を引数で受け渡す。\nウ　データ構造を大域的データで受け渡す。\nエ　データ構造を引数で受け渡す。\n【問題の要約】モジュール結合度が「最も低い（良い）」データの渡し方はどれ？\nア グローバル変数で単一データを渡す。 イ 引数で単一データを渡す。 ウ グローバル変数でデータ構造を渡す。 エ 引数でデータ構造を渡す。\nこれはプログラムの結合度についての問題だね。これについても記事を書いたことがあるよ： https://blog.yexca.net/ja/archives/145#結合度 単一のデータ値を渡すのは「データ結合」、データ構造を渡すのは「スタンプ結合」、グローバル変数を使うのは「共通結合」になる。この中で最も結合度が低い（独立性が高い）のはデータ結合。だから、正解は イ。\n7 既存システムを基に、新システムのモデル化を行う場合のDFD作成の手順として、適切なものはどれか。\nア　現物理モデル -\u0026gt; 現論理モデル -\u0026gt; 新物理モデル -\u0026gt; 新論理モデル\nイ　現物理モデル -\u0026gt; 現論理モデル -\u0026gt; 新論理モデル -\u0026gt; 新物理モデル\nウ　現論理モデル -\u0026gt; 現物理モデル -\u0026gt; 新物理モデル -\u0026gt; 新論理モデル\nエ　現論理モデル -\u0026gt; 現物理モデル -\u0026gt; 新論理モデル -\u0026gt; 新物理モデル\n【問題の要約】既存システムをベースに新システムをモデル化する時のDFD作成順序は？\nア 現物理 -\u0026gt; 現論理 -\u0026gt; 新物理 -\u0026gt; 新論理 イ 現物理 -\u0026gt; 現論理 -\u0026gt; 新論理 -\u0026gt; 新物理 ウ 現論理 -\u0026gt; 現物理 -\u0026gt; 新物理 -\u0026gt; 新論理 エ 現論理 -\u0026gt; 現物理 -\u0026gt; 新論理 -\u0026gt; 新物理\nこれは感覚的に イ かな。一般的にDFDを作るときは、まず今のシステムの具体的な実装（現物理）から業務要件を抽出（現論理）して、それから新しい業務要件に改善（新論理）し、最後にそれをどう実現するか（新物理）を決める、という流れになるんだ。\n8 ある購買システムの開発において、開発者が行った探索的テストの例として、適切なものはどれか。\nア　過去に購買システムを開発した経験に基づいて、入力項目間の関連チェックの不備を検出できそうなデータパターンを推測し、テストケースを事前に作成してテストした。\nイ　数量の範囲に応じて適用する商品価格が正しいかどうかを確認するために、各範囲の数量の中央の値を用いたテストケースを作成してテストした。\nウ　組織変更の前後で組織名が正しく印刷されるかどうかを確認するために、新組織の有効開始日とその前日とを発注日とするテストケースを事前に作成してテストした。\nエ　入力値の組合せが無効なときは伝票を作成しないことを確認するために、幾つかの代表的な入力値の組合せをテストし、その結果に基づいて次のテストケースを作成してテストしを繰り返した。\n【問題の要約】「探索的テスト」の例として正しいのはどれ？\nア 経験に基づいてテストケースを事前に作ってテストした。 イ 範囲の中央値を使ってテストケースを作ってテストした。 ウ 境界日を使ってテストケースを事前に作ってテストした。 エ 代表的な組み合わせをテストし、その結果を見ながら次のテストケースを繰り返し作った。\n探索的テスト（Exploratory Testing）は、テストをしながら動的にテストケースを設計・実行する手法のこと。あらかじめ決められたテストケースに頼るんじゃなくて、システムの動きを観察しながらその場でテストプランを調整していくのが特徴なんだ。\nア、イ、ウ はどれも「事前にテストケースを作成」しているから、従来型の設計テストだね。結果を見ながら次のテストを考えて繰り返している エ が探索的テストに該当する。だから、正解は エ。\n","date":"2024-11-03T23:11:52+08:00","permalink":"https://blog.yexca.net/ja/archives/191/","title":"2022 SA 午前2 -01-08"},{"content":" 📢 この記事は gemini-3-flash-preview によって翻訳されました はじめに 2022 SA am1\n01-02: https://blog.yexca.net/ja/archives/184 03-05: https://blog.yexca.net/ja/archives/185 06-10: https://blog.yexca.net/ja/archives/186 11-15: https://blog.yexca.net/ja/archives/189 16-30: https://blog.yexca.net/ja/archives/190 試験問題を一通り解いてみたけど、大部分はソフトウェア設計者（ソフトウェア開発技術者）試験みたいな感じだったな。共通科目は開発寄りの要求が低めなのかな。専門の試験になるともっと難しくなりそう。専門用語がわからなくて戸惑うこともあるけど、翻訳してみれば解ける問題も多いから、やっぱり用語を覚えるのは大事だね。\n第 16 問 次の流れ図において、判定条件網羅（分岐網羅）を満たす最小のテストケースの組みはどれか。\nア　(1) A=0, B=0 (2) A=1, B=1\nイ　(1) A=1, B=0 (2) A=1, B=1\nウ　(1) A=0, B=0 (2) A=1, B=1 (3) A=1, B=0\nエ　(1) A=0, B=0 (2) A=0, B=1 (3) A=1, B=0\nこの問題は、各分岐をすべてテストするために最小でいくつのテストケースが必要かというもの。詳しい解析は省くけど、答えは選択肢 イ だよ。\n第 17 問 問題が発生していないが、プログラムの仕様書と現状のソースコードとの不整合を解消するために、リバースエンジニアリングの手法を使って仕様書を作成し直す。これはソフトウェア保守のどの分類に該当するか。\nア　完全化保守\nイ　是正保守\nウ　適応保守\nエ　予防保守\n問題の要約：問題はまだ起きていないけど、プログラムの仕様書と実際のコードの食い違いをなくすために、リバースエンジニアリングで仕様書を作り直す。これはソフトウェア保守のどれに当たる？\nア：完全化保守（パーフェクティブ保守）\nイ：是正保守（コレクティブ保守）\nウ：適応保守（アダプティブ保守）\nエ：予防保守（プリベンティブ保守）\n昔勉強した記憶が蘇ってきた\u0026hellip;。完全化保守は、新しい基準や要求に合わせて機能や性能を向上させること。是正保守はバグ修正。適応保守は新しいOSやハードへの対応。予防保守は問題が起きる前に潜在的な問題を予防するために行うメンテナンスのこと。だから答えは選択肢 エ。\n第 18 問 ある組織では、プロジェクトのスケジュールとコストの管理にアーンドバリューマネジメントを用いている。期間10日間のプロジェクトの、5日目の終了時点の状況は表のとおりである。この時点でのコスト効率が今後も続くとしたとき、完成時総コスト見積り（EAC）は何万円か。\n管理項目 金額（万円） 完成時総予算（BAC） 100 プランドバリュー（PV） 50 アーンドバリュー（EV） 40 実コスト（AC） 60 ア　110\nイ　120\nウ　135\nエ　150\n問題の要約：ある組織がEVMを使ってプロジェクト管理をしている。10日間のプロジェクトの5日目終了時点の状況は表の通り。このコスト効率が今後も続く場合、完成時の総コスト見積り (EAC) は何万か。\nこれはまだ勉強してなかった内容だな。完成時総コスト見積り (EAC) の計算方法はこうなるよ。\n$$ EAC=\\frac{BAC}{CPI} $$ここで、CPI (コスト効率指数) は\n$$ CPI=\\frac{EV}{AC} $$数値を代入して計算すると\n$$ \\begin{align} CPI\u0026=\\frac{40}{60}=\\frac{2}{3} \\\\ EAC\u0026=\\frac{100}{\\frac{2}{3}}=150 \\end{align} $$だから答えは選択肢 エ。\n第 19 問 ソフトウェア開発プロジェクトにおいて、表の全ての作業を完了させるために必要な期間は最短で何日間か。\n作業 作業の開始条件 所要日数（日） 要件定義 なし 30 設計 要件定義の完了 20 製造 設計の完了 25 テスト 製造の完了 15 利用者マニュアル作成 設計の完了 20 利用者教育 テストの完了及び利用者マニュアル作成の完了 10 ア　80\nイ　95\nウ　100\nエ　120\n問題の要約：ソフトウェア開発プロジェクトで、表の全作業を完了させるのに最短で何日かかるか。\nこれはネットワーク工程図（アローダイアグラム的なやつ）を描けばOK。結構シンプルな図になるよ。答えは選択肢 ウ。\n第 20 問 ITIL 2011 edition では、可用性管理における重要業績評価指標（KPI）の例として、”保守性を表す指標値”の短縮を挙げている。保守性を表す指標に該当するものはどれか。\nア　一定時間内での中断の数\nイ　平均故障間隔\nウ　平均サービス・インシデント間隔\nエ　平均サービス回復時間\n問題の要約：ITIL 2011版の可用性管理において、「保守性を表す指標」に該当するのはどれ？\nア：一定時間内の中断回数\nイ：平均故障間隔 (MTBF)\nウ：平均サービス・インシデント間隔 (MTBSI)\nエ：平均サービス回復時間 (MTTR)\nITILの可用性管理において、保守性（メンテナンス性）は故障が発生した後の回復や修理の能力を指すんだ。故障の頻度じゃなくてね。平均サービス回復時間 (MTTR, Mean Time to Restore Service) は故障後の回復スピードを表すから、これが正解。答えは選択肢 エ。\n第 21 問 基幹業務システムの構築及び運用において、データ管理者（DA）とデータベース管理者（DBA）を別々に任命した場合のDAの役割として、適切なものはどれか。\nア　業務データ量の増加傾向を把握し、ディスク装置の増設などの計画して実施する。\nイ　システム開発の設計工程では、主に論理データベース設計を行い、データ項目を管理して標準化する。\nウ　システム開発のテスト工程では、主にパフォーマンスチューニングを担当する。\nエ　システム障害が発生した場合には、データの復旧や整合性のチェックなどを行う。\n問題の要約：コアシステムでDAとDBAを分けた場合、DAの適切な役割はどれ？\nア：データ増加の把握とディスク増設の計画・実施。\nイ：設計段階で、主に論理データベース設計を行い、データ項目の管理と標準化を行う。\nウ：テスト段階で、主にパフォーマンスチューニングを担当する。\nエ：障害発生時に、データ復旧や整合性チェックを行う。\nデータ管理者 (DA) は主に、データ標準の策定、データ項目の定義、論理データベース設計といった論理的なデータ管理を担当するんだ。データの一貫性と標準化を確保するのがDAの役割。一方でデータベース管理者 (DBA) は、ハードウェア資源の管理やパフォーマンス最適化、データ復旧なんかを担当するよ。だから答えは選択肢 イ。\n第 22 問 監査証拠の入手と評価に関する記述のうち、システム監査基準（平成30年）に照らして、適切でないものはどれか。\nア　アジャイル手法を用いたシステム開発プロジェクトにおいては、管理用ドキュメントとしての体裁が整っているものだけが監査証拠として利用できる。\nイ　外部委託業務実施拠点に対する監査において、システム監査人が委託先から入手した第三者の保証報告書に依拠できると判断すれば、現地調査を省略できる。\nウ　十分かつ適切な監査証拠を入手するための本調査の前に、監査対象の実態を把握するための予備調査を実施する。\nエ　一つの監査目的に対して、通常は、複数の監査手続きを組み合わせ監査を実施する。\n問題の要約：システム監査基準（平成30年）に照らして、適切でない記述はどれ？\nア：アジャイル開発プロジェクトでは、形式の整った管理ドキュメントだけが監査証拠になる。\nイ：外包先の監査で、第三者の保証報告書を信頼できるなら、現地調査を省略してもいい。\nウ：本調査の前に、実態を把握するための予備調査を行う。\nエ：一つの監査目的のために、通常は複数の手続きを組み合わせて行う。\nこの基準は詳しく知らなかったけど、アジャイルプロジェクトの監査証拠が「形式の整った管理ドキュメント」に限定されるなんてことはないんだ。実際、会議録やコードベース、かんばん（進捗ボード）なんかも、実態を反映する有効な証拠として使えるからね。だから答えは選択肢 ア。\n第 23 问 BPOの説明はどれか。\nア　災害や事故で被害を受けても、重要事業を中断させない、又は可能な限り中断期間を短くする仕組みを構築すること\nイ　社内業務のうちコアビジネスでない事業に関わる業務の一部又は全部を、外部の専門的な企業に委託すること\nウ　製品の基準生産計画、部品表及び在庫情報を基に、資材の所要量と必要な時期を求め、これを基準に資材の手配、納入的管理を支援する生産管理手法のこと\nエ　プロジェクトを、戦略との適合性や費用対効果、リスクといった観点から評価を行い、情報化投資のバランスを管理し、最適化を図ること\n問題の要約：BPOの説明として正しいのはどれ？\nBPO (Business Process Outsourcing) は、自社の非コア業務をまるごと外部の専門企業に委託して、自分たちはコア業務に集中することを指すんだ。だから答えは選択肢 イ。\nちなみに、ア はBCP（事業継続計画）、ウ はMRP（資材所要量計画）、エ はPPM（プロジェクトポートフォリオ管理）の説明だね。\n第 24 问 IT投資効果の評価方法において、キャッシュフローベースで初年度の投資によるキャッシュアウトを何年後に回収できるかという指標はどれか。\nア　IRR(Internal Rate of Return)\nイ　NPV(Net Present Value)\nウ　PBP(Pay Back Period)\nエ　ROI(Return On Investment)\n問題の要約：IT投資の評価方法で、投資額を何年で回収できるかを示す指標はどれ？\nア は内部収益率。投資の利回りみたいなもの。\nイ は正味現在価値。将来のキャッシュフローを今の価値に直して合計したもの。\nウ は回収期間法。これが問題文の内容。\nエ は投資利益率。利益とコストの比率。\nというわけで、答えは ウ。\n第 25 问 UMLの図のうち、業務要件定義において、業務フローを記述する際に使用する、処理の分岐や並行処理、処理の同期などを表現できる図はどれか。\nア　アクティビティ図\nイ　クラス図\nウ　状態マシン図\nエ　ユースケース図\n問題の要約：UMLの中で、業務フローを記述し、分岐や並行処理、同期を表現できる図はどれ？\nア：アクティビティ図\nイ：クラス図\nウ：状態マシン図\nエ：ユースケース図\nアクティビティ図は業務プロセスを記述するのに向いていて、分岐や並行、同期もバッチリ表現できる。だから要件定義でよく使われるんだ。クラス図はシステムの静的な構造、状態マシン図はオブジェクトの状態変化、ユースケース図は機能要求を表すもの。正解は ア。\n第 26 问 PPMにおいて、投資用の資金源として位置付けられる事業はどれか。\nア　市場成長率が高く、相対的市場占有率が高い事業\nイ　市場成長率が高く、相対的市場占有率が低い事業\nウ　市場成長率が低く、相対的市場占有率が高い事業\nエ　市場成長率が低く、相対的市場占有率が低い事業\n問題の要約：PPM（プロダクト・ポートフォリオ・マネジメント）で、他の事業への投資資金源となるのはどの事業？\nア：花形 (Star)\nイ：問題児 (Problem Child)\nウ：金のなる木 (Cash Cow)\nエ：負け犬 (Dog)\nPPMでは、「金のなる木」が資金源になるんだ。シェアが高くて安定した利益を生むけど、市場の成長が鈍化しているから、追加投資があまりいらない。そこで稼いだお金を「問題児」とかに投資するんだね。答えは ウ。\n第 27 问 半導体産業において、ファブレス企業と比較したファウンドリ企業のビジネスモデルの特徴として、適切なものはどれか。\nア　工場での生産をアウトソーシングして、生産設備への投資を抑える。\nイ　自社製品の設計、マーケティングに注力し、新市場を開拓する。\nウ　自社製品の販売に注力し、売上げを拡大する。\nエ　複数の企業から生産だけを専門に請け負い、多くの製品を低コストで生産する。\n問題の要約：半導体業界で、ファブレス企業と比べた時のファウンドリ企業の特徴は？\n半導体業界では、ファウンドリ企業は製造に特化していて、自社製品の設計はせずに他社の製造だけを請け負う。複数の企業から注文を受けることで大量生産・低コスト化を実現しているんだ。答えは エ。\n第 28 问 XBRLで主要な取扱いの対象とされている情報はどれか。\nア　医療機関のカルテ情報\nイ　企業の顧客情報\nウ　企業の財務情報\nエ　自治体の住民情報\n問題の要約：XBRLが主に扱う情報はどれ？\nXBRL (eXtensible Business Reporting Language) は、ビジネスニュースや財務報告のための標準的なコンピュータ言語。主に企業の財務諸表などをデータ化するために使われるよ。だから答えは ウ。\n第 29 问 リーダシップ論のうち、PM理論の特徴はどれか。\nア　優れたリーダシップを発揮する、リーダ個人がもつ性格、知性、外観などの個人的資質の分析に焦点を当てている。\nイ　リーダシップのスタイルについて、目標達成能力と集団維持能力の二つの次元に焦点を当てている。\nウ　リーダシップの有効性は、部下の成熟（自律性）の度合いという状況要因に依存するとしている。\nエ　リーダシップの有効性は、リーダがもつバーソナリティと、リーダがどれだけ統制力や影響力を行使できるかという状況要因に依存するとしている。\n問題の要約：リーダーシップ論のPM理論の特徴はどれ？\nPM理論は、リーダーシップを「P（Performance：目標達成）」と「M（Maintenance：集団維持）」の2つの軸で捉える理論なんだ。だから答えは イ。\n第 30 问 A社は、B社と著作物の権利に関する特段の取決めをせず、A社の要求仕様に基づいて、販売管理システムのプログラム作成をB社に委託した。この場合のプログラム著作権の原始的帰属に関する記述のうち、適切なものはどれか。\nア　A社とB社が話し合って帰属先を決定する。\nイ　A社とB社の共有帰属となる。\nウ　A社に帰属する。\nエ　B社に帰属する。\n問題の要約：A社がB社にプログラム作成を委託した。著作権の特別な取り決めがない場合、著作権は誰のものになる？\n特に契約で定めがない場合、著作権法上は実際に作品を作った人（この場合は受託者のB社）に帰属するのが一般的だよ（日本も中国も同じようなルールだね）。だから答えは エ。\n","date":"2024-10-28T19:04:14+08:00","permalink":"https://blog.yexca.net/ja/archives/190/","title":"2022 SA 午前1 -16-30"},{"content":" 📢 この記事は gemini-3-flash-preview によって翻訳されました はじめに 2022 SA 午前1\n01-02: https://blog.yexca.net/ja/archives/184 03-05: https://blog.yexca.net/ja/archives/185 06-10: https://blog.yexca.net/ja/archives/186 11-15: https://blog.yexca.net/ja/archives/189 16-30: https://blog.yexca.net/ja/archives/190 ちょっとした雑談 最近、目がどんどん痛くなってきちゃって。画面を見て1時間もすると痛みだすし、おまけに視界もぼやけてるんだよね。そろそろ目を休ませないと、これ以上近視が進んで何も見えなくなったら本当に困るな（痛くなければ、この試験問題全部更新しきれたと思うんだけどね）。\n第 11 問 OpenFlow を使った SDN(Software-Defined Networking) に関する記述として、適切なものはどれか。\nア　インターネットのドメイン名を管理する世界規模の分散データベースを用いて、IPアドレスの代わりに名前を指定して通信できるようにする仕組む\nイ　携帯電話網において、回線交換方式ではなく、パケット交換方式で音声通話を実現する方式\nウ　ストレージ装置とサーバを接続し、WWN(World Wide Name) によってノードやポートを識別するストレージ用ネットワーク\nエ　データ転送機能とネットワーク制御機能を論理的に分離し、ネットワーク制御を集中的に行う可能にしたアーキテクチャ\n問題の解説：OpenFlow を使った SDN (Software Defined Networking) について、正しいものを選ぶ問題だよ。\nア：世界規模のデータベースでドメイン名を管理するのは、DNS の説明だね。\nイ：回線交換ではなくパケット交換で音声通話をするのは、モバイル通信における VoIP（VoLTEなど）の説明。\nウ：ストレージとサーバーを接続して WWN で識別するのは、SAN (Storage Area Network) の説明だね。\nエ：データ転送機能と制御機能を論理的に分離して、集中制御を可能にする。これがまさに SDN のアーキテクチャ。\nということで、答えは エ だよ。\n第 12 問 メッセージの送受信における署名鍵の使用に関する記述のうち、適切なものはどれか。\nア　送信者が送信者の署名鍵を使ってメッセージに対する署名を作成し、メッセージに付加することによって、受信者が送信者による署名であることを確認できようになる。\nイ　送信者が送信者の署名鍵を使ってメッセージを暗号化することによって、受信者が受信者の署名鍵を使って、暗号文を元のメッセージに戻すことができるようになる。\nウ　送信者が送信者の署名鍵を使ってメッセージを暗号化することによって、メッセージの内容が関係者以外に分からないようになる。\nエ　送信者がメッセージに固定文字列を付加し、更に送信者の署名鍵を使って暗号化することによって、受信者がメッセージの改ざん部位を特定できるようになる。\n問題の解説：メッセージ送受信での署名鍵の使い方について、適切なものを選ぶ問題。\nデジタル署名（RSA アルゴリズムなど）の話だね。署名は「送信者本人であること」を証明するために使うものだよ。\nア：送信者が自分の秘密鍵（署名鍵）で署名を作り、受信者が送信者の公開鍵で検証する。これで送信者本人であることを確認できる。これが正解。\nイ：送信者の鍵で暗号化して、受信者の鍵で復号することはできないよ（ペアが違うからね）。\nウ：署名鍵は「本人の証明」に使うもので、機密保持（暗号化）のために使うわけじゃないんだ。公開鍵は誰でも手に入るから、機密性は保てないよ。\nエ：署名で「改ざんされたこと」は分かっても、「どの部分が改ざんされたか」までは特定できないんだ。\n答えは ア。\n第 13 問 クライアント証明書で利用者を確認するリバースプロキシサーバを用いて、複数のWebサーバにシングルサインオンを行うシステムがある。このシステムに関する記述のうち、適切なものはどれか。\nア　クライアント証明書を利用者のPCに送信するのは、Webサーバではなく、リバースプロキシサーバである。\nイ　クライアント証明書を利用者のPCに送信するのは、リバースプロキシサーバではなく、Webサーバである。\nウ　利用者IDなどの情報をWebサーバに送信するのは、リバースプロキシサーバではなく、利用者のPCである。\nエ　利用者IDなどの情報をWebサーバに送信するのは、利用者のPCではなく、リバースプロキシサーバである。\n問題の解説：リバースプロキシとクライアント証明書を使ったシングルサインオン (SSO) システムについての問題。\nこの構成は実務でもよく見かけるね。大きな会社なんかで、ログイン専用の入り口があるようなイメージ。\nア・イ：クライアント証明書はもともと利用者の PC に入っているものだから、サーバーから送信するものではないね（配布の話なら別だけど、この文脈では不適切）。\nウ・エ：このシステムでは、リバースプロキシがまずクライアント証明書を検証してユーザーを特定するんだ。その後、リバースプロキシが「このユーザーは認証済みだよ」という情報（利用者IDなど）を後ろにある各 Web サーバーに伝える仕組みになっている。\nだから、答えは エ になるよ。\n第 14 問 内部ネットワークのPCからインターネット上のWebサイトを参照するときに、DMZに設置したVDI (Virtual Desktop Infrastructure) サーバ上のWebブラウザを利用すると、未知のマルウェアがPCにダウンロードされるのを防ぐというセキュリティ上の効果が期待できる。この効果を生み出すVDIサーバの動作の特徴はどれか。\nア　Webサイトからの受信データを受信処理した後、IPsecでカプセル化し、PCに送信する。\nイ　Webサイトからの受信データを受信処理した後、実行ファイルを削除し、その他のデータをPCに送信する。\nウ　Webサイトからの受信データを受信処理した後、生成したデスクトップ画面の画像データだけをPCに送信する。\nエ　Webサイトからの受信データを受信処理した後、不正なコード列が検知されない場合だけPCに送信する。\n問題の解説：DMZ にある VDI サーバー経由でブラウザを使うことで、PC へのマルウェア感染を防ぐ仕組みについての問題。\nVDI（仮想デスクトップ）の最大の特徴を考えればすぐわかるよ。\nア：IPsec でカプセル化しても、中身がマルウェアならそのまま PC に届いちゃうよね。\nイ：実行ファイル以外にもスクリプトとかで感染するから、これだけじゃ不十分。\nウ：VDI は「画面の書き換え情報（画像データ）」だけを転送する仕組み。実際のファイルやデータは DMZ 上のサーバーにあるから、手元の PC にマルウェアがダウンロードされることはないんだ。\nエ：未知のマルウェアは検知できないから「未知」なわけで、この方法では防げないね。\n答えは ウ。名前の通り「仮想デスクトップ」は画面を送るだけ！\n第 15 問 ファジングに該当するものはどれか。\nア　サーバにFINバケットを送信し、サーバからの応答を観測して、稼働しているサービスを見つけ出す。\nイ　サーバのOSやアプリケーションソフトウェアが生成したログやコマンド履歴などの解析して、ファイルサーバに保存されているファイルの改ざんを検知する。\nウ　ソフトウェアに、問題を引き起こしそうな多様なデータを入力し、挙動を監視して、脆弱性を見つけ出す。\nエ　ネットワーク上を流れるバケットを収集し、そのプロトコルヘッダやペイロードを解析して、あらかじめ登録された攻撃パターンと一致するものを検出する。\n問題の解説：ファジング (Fuzzing) の説明として正しいものを選ぶ問題。\nファジングは、ソフトウェアのバグや脆弱性を見つけるための自動テスト手法のことだよ。\nア：これは FIN スキャン。ポートスキャンの一種で、どんなサービスが動いているか調べる手法だね（nmap とか）。\nイ：これはログ解析による改ざん検知だね。侵入検知システム (IDS) の一部。\nウ：これがファジング。予測不能なデータや、あえておかしなデータをたくさん入力してみて、システムが落ちたり変な挙動をしないかチェックするんだ。\nエ：これはシグネチャ型の侵入検知 (NIDS) の説明。登録されたパターンと照らし合わせる手法だね。\nということで、答えは ウ だよ。\n","date":"2024-10-26T21:41:16+08:00","permalink":"https://blog.yexca.net/ja/archives/189/","title":"2022 SA 午前1 - 11-15"},{"content":" 📢 この記事は gemini-3-flash-preview によって翻訳されました はじめに 日本語のタイトルを書いてるけど、この記事の内容は主に日本語じゃないんだ。時間があれば追記するかも\n問題一： https://blog.yexca.net/ja/archives/183 問題二： https://blog.yexca.net/ja/archives/187 問題三：この記事\n全部解いてみた感想としては、いろんな専攻共通の数学試験だからかな。線形代数はわからないけど、微積分と確率は、ある結論の証明を誘導したり、何かを理解させたりするような内容がほとんどだった。微積分は弧長パラメータ、線形代数は37%法則（秘書問題）だね。これらの結論を知っていれば解きやすいけど、知らずにゼロから解くのは本当にすごいと思う。少なくとも俺がゼロからだったら、確実に落ちてるわ。\nそれと、既存の理論がベースだから、答え自体は合ってるはず。過程については……まあ、どうだろうね（笑）\n問題 Source: https://www.i.u-tokyo.ac.jp/edu/entra/examarchive.shtml 題目権限は東京大学に帰属します。閲覧の便宜のために引用しており、営利目的ではありません。\n$n$ 人のアルバイト候補者を面接し、その中の最適任者を採用したい。ただし、$n \\ge 2$ とする。候補者にあらかじめ順位 $1$、順位 $2$、$\\cdots$、順位 $n$　までの絶対的順位が定まっており、すでに面接した候補者についてはそれらの間の相対的順位が分かるものとする。面接は一人ずつ順に行うが、候補者の現れる順番はランダムに決定され、事前には分からない。採用プロセスでは、すでに面接した候補者の間での相対的順位に基づいて採否の決定が行われ、さらに以下の条件が課される。\n各候補者の面接の直後に、その候補者の採否を決定する。 ある候補者の採用が決まった時点で採用プロセスを終了する。 過去に不採用にした候補者を採用することはできない。 $n-1$ 回までの面接で採用しなかったときは、$n$ 番目の候補者を無条件で採用する。 アルバイトの採用において次のような戦略をとる。ただし、$1 \u003c r \\le n$ とする。\n$r-1$ 回の面接までは無条件で候補者を不採用にする。 以降の面接では、候補者がその $r-1$ 人の中での最良候補（相対的順位 $1$）よりも良ければ採用する。 この戦略で、絶対的順位 $1$ の候補者を採用する確率を $P_{n}(r)$ とする。以下の問いに答えよ。\n（１）$P_{4}(2)$ を求めよ。\n（２）$P_{10}(3)=\\frac{2}{10}(\\frac{1}{2}+\\frac{1}{3}+\\cdots+\\frac{1}{9})$ となることを示せ。\n（３）$n$ 人の候補者に対して、$k$ 回目の面接で絶対的順位 $1$ の候補者を採用する確率を求めよ。ただし、$r \\le k \\le n$ である。\n（４）以下の漸化式において、$A,B$ に入る式を求めよ。\n$$ P_{n}(r)=A+B\\times P_{n}(r+1) $$ただし、$A,B$ には $n,r$ と定数からなる式が入る。\n（５）$q=r/n$ とする。$n$ が十分大きいときに $P_{n}(r)$ は $-q\\ln(q)$ で近似できることを説明せよ。さらに、$-q\\ln(q)$ の最大値を与える $q\\in (0,1]$ の値を求めよ。ただし、$\\ln$ は自然対数を表す。\n日本語解説 背景の要約：$n$ 人を面接して最高の人を採用したい。$n \\ge 2$。各候補者の能力には絶対的な順位がある。面接した人たちの相対的な順位はわかる。面接は一人ずつで、順番はランダム。以下の条件で採用を決める：\n面接直後に採用・不採用を決める 採用が決まれば終了 一度不採用にしたら、後から採用はできない $n-1$ 人目まで誰も採用しなかったら、最後の人を自動的に採用する 採用戦略（$1 \u003c r \\le n$）：\n最初の $r-1$ 人は無条件で不採用 それ以降は、これまでの $r-1$ 人の中の最高の人よりも優秀な人が来たら即採用 この戦略で、一番優秀な人を採用できる確率 $P_{n}(r)$ についての問題。\nこの問題を読んだとき、ビダオ（毕導）の あの科学的に脱単（恋人を作る）する方法の動画 を思い出したよ。動画で紹介されている「37%法則」そのものだね。問題文はそのルールの説明で、最後の設問がその 導出プロセス になってる。\n第一問 問題の要約：$P_{4}(2)$ を求めよ。\n$$ \\begin{align} P_{4}(2) \u0026=\\frac{1}{4}+\\frac{1}{4} \\times \\frac{1}{2} + \\frac{1}{4} \\times \\frac{1}{3} \\\\ \u0026=\\frac{1}{4}+\\frac{1}{8}+\\frac{1}{12} \\\\ \u0026=\\frac{11}{24} \\end{align} $$この式は、一番優秀な人が2人目にいて選ばれる確率、3人目にいて選ばれる確率、4人目にいて選ばれる確率を足したもの。一番優秀な人を選ぶためには、第 $r$ 人目から一番優秀な人までの間に、最初の $r-1$ 人よりも優秀な人が現れてはいけない。ちょっとややこしいから、場合分けして考えよう。\n一番優秀な人が1人目の場合：即不採用になるから、選ばれる確率は $0$。\n一番優秀な人が2人目の場合：2人目から採用判断が始まる。2人目が一番優秀なんだから、当然1人目よりも優秀。だから確実に選ばれる。確率は $1$。\n一番優秀な人が3人目の場合：2つのパターンがある。\n2人目が1人目より優秀なら、2人目が採用されてしまう。 2人目が1人目より優秀でなければ、3人目の一番優秀な人が採用される。 だから、この場合に選ばれる確率は $\\frac{1}{2}$。\n一番優秀な人が4人目の場合：2番目に優秀な人が1人目にいる場合（他にも条件はあるけど、要はそれまでの最高が最初の $r-1$ 人の中にいる必要がある）に一番優秀な人が選ばれる。パターンを全部出すと大変だけど、確率は $\\frac{1}{3}$ になる。\n以上の4つのケースを合わせて：$P=\\frac{1}{4} \\times 0+\\frac{1}{4} \\times 1 +\\frac{1}{4} \\times \\frac{1}{2} + \\frac{1}{4} \\times \\frac{1}{3}$\n第二問 問題の要約：$P_{10}(3)=\\frac{2}{10}(\\frac{1}{2}+\\frac{1}{3}+\\cdots+\\frac{1}{9})$ を証明せよ。\n一番優秀な人が第 $m$ 位（$3 \\le m \\le 10$）にいると仮定する。一番優秀な人を選び出すためには、最初の $m-1$ 人の中での最高責任者が、最初の2人（$r-1=2$）の中にいなければならない。その確率は $\\frac{2}{m-1}$。よって、各 $m$ において一番優秀な人が選ばれる確率は：\n$$ \\begin{align} P =\u0026\\frac{1}{10} \\times \\frac{2}{2}+\\frac{1}{10} \\times \\frac{2}{3}+\\frac{1}{10} \\times \\frac{2}{4}+\\frac{1}{10} \\times \\frac{2}{5}+\\\\ \u0026\\frac{1}{10} \\times \\frac{2}{6}+\\frac{1}{10} \\times \\frac{2}{7}+\\frac{1}{10} \\times \\frac{2}{8}+\\frac{1}{10} \\times \\frac{2}{9} \\\\ =\u0026\\frac{1}{10}(\\frac{2}{2}+\\frac{2}{3}+\\frac{2}{4}+\\frac{2}{5}+\\frac{2}{6}+\\frac{2}{7}+\\frac{2}{8}+\\frac{2}{9}) \\\\ =\u0026\\frac{2}{10}(\\frac{1}{2}+\\frac{1}{3}+\\frac{1}{4}+\\frac{1}{5}+\\frac{1}{6}+\\frac{1}{7}+\\frac{1}{8}+\\frac{1}{9}) \\end{align} $$一番優秀な人が最初の2人にいるときは選ばれないので、\n$$ \\begin{align} P_{10}(3) \u0026=\\frac{1}{10} \\times 0 + \\frac{1}{10} \\times 0 + P \\\\ \u0026=P \\end{align} $$となり、証明された。\n第三問 問題の要約：$n$ 人の候補者に対して、第 $k$ 回目の面接で一番優秀な候補者を採用する確率を求めよ。ただし $r \\le k \\le n$。\n第 $k$ 回目で一番優秀な人を採用するには、まず一番優秀な人が $k$ 番目にいなければならない。その確率は $1/n$。次に、その $k$ 番目の人が採用されるためには、それまでの $k-1$ 人の中の最高責任者が、最初の $r-1$ 人の中にいなければならない。その確率は $\\frac{r-1}{k-1}$。したがって、\n$$ P=\\frac{1}{n} \\times \\frac{r-1}{k-1} $$第四問 問題の要約：以下の漸化式（式は略）において $A$ と $B$ を求めよ。$A, B$ は $n, r$ と定数を用いた式。\n$$ \\begin{align} P_{n}(r) \u0026= \\frac{1}{n}(\\frac{r-1}{r-1}+\\frac{r-1}{r}+\\frac{r-1}{r+1}+\\cdots+\\frac{r-1}{n-1}) \\\\ \u0026=\\frac{1}{n} \\sum_{i=r-1}^{n-1} \\frac{r-1}{i} \\\\ \u0026= \\frac{r-1}{n}\\sum_{i=r-1}^{n-1}\\frac{1}{i} \\end{align} $$よって\n$$ P_{n}(r+1)=\\frac{r}{n}\\sum_{i=r}^{n-1}\\frac{1}{i} $$まず $B$ を計算すると：\n$$ \\frac{r}{n} \\times B = \\frac{r-1}{n} \\\\ B = \\frac{r-1}{r} $$次に $A$ を計算する。両者の違いは $i=r-1$ の項、つまり $\\frac{r-1}{n} \\times \\frac{1}{r-1} = \\frac{1}{n}$ だけなので、\n$A = \\frac{1}{n}$\n第五問 問題の要約：$q=r/n$ とし、$n$ が十分大きいとき $P_{n}(r)$ が $-q\\ln(q)$ で近似できることを説明せよ。また $-q\\ln(q)$ の最大値を与える $q\\in (0,1]$ を求めよ。\n上で $P_{n}(r)$ の公式を出したけど、$n$ が十分大きいとき、\n$$ \\sum_{i=r-1}^{n-1}\\frac{1}{i} \\approx \\int_{r}^{n} \\frac{1}{x} \\mathrm{d}x = \\ln(n)-\\ln(r)= \\ln(\\frac{n}{r}) $$したがって、\n$$ P_{n}(r) \\approx \\frac{r}{n}\\ln(\\frac{n}{r}) = q\\ln(\\frac{1}{q}) = -q\\ln(q) $$$y=-q\\ln(q)$ とおくと、$\\frac{\\mathrm{d} y}{\\mathrm{d} q} = -\\ln(q)-1$。$\\frac{\\mathrm{d} y}{\\mathrm{d} q}=0$ とすると $q=\\frac{1}{e}$。\nつまり $q=\\frac{1}{e}$ のとき、$-q\\ln(q)$ は最大値をとる。\nこの問題、俺もそこまで深く理解してるわけじゃないけど、とりあえず近似すればこうなる。具体的には 動画の中の公式 ともちょっと違う気がするけど、まあいいや。\nWrote with ChatGPT\n","date":"2024-10-25T19:24:36+08:00","permalink":"https://blog.yexca.net/ja/archives/188/","title":"東京大学大学院 理工学 数学 2020 問題三"},{"content":" 📢 この記事は gemini-3-flash-preview によって翻訳されました はじめに 日本語のタイトルを書いたけど、この記事の内容はもともと中国語がメインだったんだ。時間があればもっと書き足すかも。\n問題一： https://blog.yexca.net/ja/archives/183 問題二：この記事\n問題三： https://blog.yexca.net/ja/archives/188 はぁ、やる気って現実に打ち砕かれがちだよね。でも今回は落ち込んでる時間が短くて済んだし、少しずつ良くなるといいな。\nこの問題については、ベクトルの独立した講義内容っぽい感じ。最初はさっぱりわからなかったけど、3b1bの「線形代数の本質」を思い出して、数学でのベクトルの一般表現を考えてから少しずつ解き進められたよ。\n実際、問題文にほとんど定義が書いてあるから、日本の授業で習ってなくても、その場で定義を理解して解く感じだね。これを初見で解ききれる人は本当にすごいと思う。自分はまだまだだなぁ。\nあと、全部証明問題だから、過程が正しいかどうかの保証はできないから気をつけてね。\n問題 Source: https://www.i.u-tokyo.ac.jp/edu/entra/examarchive.shtml 題目権限は東京大学に帰属します。ここでは閲覧の便宜のために引用しており、営利目的ではありません。\n$xy$ 平面内の滑らかな曲線 $\\boldsymbol{p}=(p(t),q(t))(t \\in [a,b])$ を考える。時刻 $t=a^{'} $ から $b^{'}$ までの $\\boldsymbol{p}$ の長さ $l_{a^{'},b^{'}}$ は\n$$ l_{a^{'},b^{'}} = \\int_{a^{'}}^{b^{'}} \\sqrt{(\\frac{\\mathrm{d} p}{\\mathrm{d} t})^2+(\\frac{\\mathrm{d} q}{\\mathrm{d} t})^2} \\mathrm{d} t $$と定義され、$\\boldsymbol{p}$ の全長 $l_{a,b}$ を $L$ で表す。曲線 $\\boldsymbol{p}$ は、$\\frac{\\mathrm{d} \\boldsymbol{p}}{\\mathrm{d} t}=(0,0)$ とはならないものとする。時刻 $a$ から $t$ までの $\\boldsymbol{p}$ の長さ $l_{a,t}$ を変数 $s=s(t)$ で表すと、$\\boldsymbol{p}$ を媒介変数 $s \\in [0,L]$ の曲線とみることができる。そして、$s$ も時刻と呼ぶ。以下の問いに答えよ。\n（１）以下の等式を示せ。\n$$ \\sqrt{(\\frac{\\mathrm{d} p}{\\mathrm{d} s})^2+(\\frac{\\mathrm{d} q}{\\mathrm{d} s})^2} = 1 $$（２）$\\theta = \\theta(s)$ を時刻 $s$ における $\\boldsymbol{p}$ の接線ベクトル $\\frac{\\mathrm{d} \\boldsymbol{p}}{\\mathrm{d} s} = (\\frac{\\mathrm{d} p}{\\mathrm{d} s},\\frac{\\mathrm{d} q}{\\mathrm{d} s})$ と $x$ 軸とのなす角とする。このとき、以下の等式を示せ。\n$$ \\frac{\\mathrm{d} p}{\\mathrm{d} s} \\frac{\\mathrm{d}^2 q}{\\mathrm{d} s^2}-\\frac{\\mathrm{d} q}{\\mathrm{d} s}\\frac{\\mathrm{d}^2 p}{\\mathrm{d} s^2} = \\frac{\\mathrm{d} \\theta}{\\mathrm{d} s} $$以下では、曲線 $\\boldsymbol{p}$ は、滑らかな閉曲線で、凸集合 $\\boldsymbol{K}$ の境界となっているもの。また、$\\boldsymbol{p}$ は、反時計方向に $\\boldsymbol{K}$ をまわるものとする。\n（３）任意の時刻 $s$ で $\\frac{\\mathrm{d} \\theta}{\\mathrm{d} s} \\ge 0$ となることを説明せよ。\n（４）$\\boldsymbol{K}$ に含まれない点 $\\boldsymbol{x}=(x,y)$ は、時刻 $s \\in [0,L]$ および $\\boldsymbol{x}$ と $\\boldsymbol{K}$ の距離 $r$ によって。\n$$ \\boldsymbol{x} = \\boldsymbol{p} (s) + r \\boldsymbol{u} (s) $$と一意に表すことができる。ここで、$\\boldsymbol{u} (s)$ は、時刻 $s$ における $\\boldsymbol{p}$ の単位法線ベクトルで、$\\boldsymbol{K}$ の外を向いているものとする。そのような $\\boldsymbol{x} = (x,y)$ に対して、以下の等式を示せ。\n$$ \\left | det \\begin{pmatrix} \\frac{\\partial x}{\\partial s} \u0026 \\frac{\\partial x}{\\partial r} \\\\ \\frac{\\partial y}{\\partial s} \u0026 \\frac{\\partial y}{\\partial r} \\end{pmatrix} \\right | =1 +r\\frac{\\mathrm{d} \\theta}{\\mathrm{d} s} $$（５）非負実数 $D$ に対し、$K_D$ を $K$ から距離 $D$ 以内にある点の集合とする。このとき、$K_D$ の面積 $A_D = \\iint_{K_D} \\mathrm{d}x\\mathrm{d}y$ は、$K$ の面積 $A$ と $\\boldsymbol{p}$ の全長 $\\boldsymbol{L}$ を用いて\n$$ A_D = A + LD + \\pi D^2 $$と表せることを示せ。\n日本語解答 設定の要約：$xy$ 平面上の滑らかな曲線 $\\boldsymbol{p}=(p(t),q(t))(t \\in [a,b])$ を考える。時刻 $t=a^{'}$ から $t=b^{'}$ までの長さ $l_{a^{'},b^{'}}$ は定義通り。全長は $L$。$s$ を弧長パラメータとすると、$\\boldsymbol{p}$ を $s \\in [0,L]$ の曲線として扱える。\nこの設定は、曲線の弧の長さをパラメータとして使う「弧長パラメータ表示 (arc length parametrization)」のことだね。これを使うと、曲線上の移動距離がそのままパラメータになるから、幾何学的な性質を考えるときにすごく便利なんだ。\n第一問 問題：等式を示せ。\n曲線の時刻が $t \\in [a,b]$ のとき、全長 $L$ は\n$$ l_{a,b} = \\int_{a}^{b} \\sqrt{(\\frac{\\mathrm{d} p}{\\mathrm{d} t})^2+(\\frac{\\mathrm{d} q}{\\mathrm{d} t})^2} \\mathrm{d} t $$$s$ は $a$ から $t$ までの弧長だから\n$$ s = \\int_{a}^{t} \\sqrt{(\\frac{\\mathrm{d} p}{\\mathrm{d} t})^2+(\\frac{\\mathrm{d} q}{\\mathrm{d} t})^2} \\mathrm{d} t $$ここから、$s$ を $t$ で微分すると\n$$ \\frac{\\mathrm{d} s}{\\mathrm{d} t} = \\sqrt{(\\frac{\\mathrm{d} p}{\\mathrm{d} t})^2+(\\frac{\\mathrm{d} q}{\\mathrm{d} t})^2} $$$\\boldsymbol{p}$ を $s$ の関数とみなし、$s$ が $t$ の関数であることを利用すると（連鎖律だね）\n$$ \\frac{\\mathrm{d} p}{\\mathrm{d} t} = \\frac{\\mathrm{d} p}{\\mathrm{d} s} \\frac{\\mathrm{d} s}{\\mathrm{d} t} \\\\ \\frac{\\mathrm{d} q}{\\mathrm{d} t} = \\frac{\\mathrm{d} q}{\\mathrm{d} s} \\frac{\\mathrm{d} s}{\\mathrm{d} t} $$これを代入すると\n$$ \\begin{align} \\frac{\\mathrm{d} s}{\\mathrm{d} t} \u0026=\\sqrt{(\\frac{\\mathrm{d} p}{\\mathrm{d} s} \\frac{\\mathrm{d} s}{\\mathrm{d} t})^2+(\\frac{\\mathrm{d} q}{\\mathrm{d} s} \\frac{\\mathrm{d} s}{\\mathrm{d} t})^2} \\\\ \u0026=\\sqrt{(\\frac{\\mathrm{d} p}{\\mathrm{d} s})^2+(\\frac{\\mathrm{d} q}{\\mathrm{d} s})^2} \\frac{\\mathrm{d} s}{\\mathrm{d} t} \\end{align} $$$\\frac{\\mathrm{d} \\boldsymbol{p}}{\\mathrm{d} t} \\ne (0,0)$ だから $\\frac{\\mathrm{d} s}{\\mathrm{d} t} \\ne 0$。よって\n$$ \\sqrt{(\\frac{\\mathrm{d} p}{\\mathrm{d} s})^2+(\\frac{\\mathrm{d} q}{\\mathrm{d} s})^2} = 1 $$この証明は、弧長パラメータ表示では、曲線の速度ベクトルの大きさが常に1になることを示しているよ。\n第二問 問題：$\\theta = \\theta(s)$ を接線ベクトルと $x$ 軸のなす角とするとき、等式を示せ。\n一般的に、ベクトルの大きさを $|v|$、 $x$ 軸とのなす角を $\\theta$ とすると、成分はこう書けるよね。\n$$ v_x = \\left | v \\right | \\cos(\\theta) \\\\ v_y = \\left | v \\right | \\sin(\\theta) $$第一問から $\\begin{vmatrix} \\frac{\\mathrm{d} \\boldsymbol{p}}{\\mathrm{d} s} \\end{vmatrix} = 1$ なので\n$$ \\begin{align} \\frac{\\mathrm{d} \\boldsymbol{p}}{\\mathrm{d} s} \u0026= (\\frac{\\mathrm{d} p}{\\mathrm{d} s},\\frac{\\mathrm{d} q}{\\mathrm{d} s}) \\\\ \u0026= (\\cos(\\theta(s)), \\sin(\\theta(s))) \\end{align} $$各成分を $s$ で微分すると\n$$ \\begin{align} \\frac{\\mathrm{d}^2 p}{\\mathrm{d} s^2} \u0026= -\\sin(\\theta(s)) \\cdot \\frac{\\mathrm{d} \\theta}{\\mathrm{d} s} \\\\ \\frac{\\mathrm{d}^2 q}{\\mathrm{d} s^2} \u0026= \\cos(\\theta(s)) \\cdot \\frac{\\mathrm{d} \\theta}{\\mathrm{d} s} \\end{align} $$これらを左辺に代入すると\n$$ \\begin{align} \\frac{\\mathrm{d} p}{\\mathrm{d} s} \\frac{\\mathrm{d}^2 q}{\\mathrm{d} s^2}-\\frac{\\mathrm{d} q}{\\mathrm{d} s}\\frac{\\mathrm{d}^2 p}{\\mathrm{d} s^2} \u0026= \\cos(\\theta(s)) \\cdot \\cos(\\theta(s)) \\cdot \\frac{\\mathrm{d} \\theta}{\\mathrm{d} s} - \\sin(\\theta(s)) \\cdot (-\\sin(\\theta(s)) \\cdot \\frac{\\mathrm{d} \\theta}{\\mathrm{d} s}) \\\\ \u0026= (\\cos(\\theta(s)))^2 \\cdot \\frac{\\mathrm{d} \\theta}{\\mathrm{d} s} + (\\sin(\\theta(s)))^2 \\cdot \\frac{\\mathrm{d} \\theta}{\\mathrm{d} s}) \\\\ \u0026= \\frac{\\mathrm{d} \\theta}{\\mathrm{d} s} \\end{align} $$きれいに証明できたね。\n第三問 問題：なぜ任意の時刻 $s$ で $\\frac{\\mathrm{d} \\theta}{\\mathrm{d} s} \\ge 0$ となるのか説明せよ。\nこれは直感的には分かりやすいけど、説明が難しいね。曲線 $\\boldsymbol{p}$ は滑らかな凸曲線だから、接線の方向の変化は連続的で、かつ逆戻りしない（つまり単調）。反時計回りに動いている場合、$x$ 軸とのなす角 $\\theta$ は常に増加し続けることになる。だから、その微分である $\\frac{\\mathrm{d} \\theta}{\\mathrm{d} s}$ は常に $0$ 以上になるんだ。\n第四問 問題：点 $\\boldsymbol{x}$ が法線ベクトルを用いて表されるとき、行列式の等式を示せ。\n$\\frac{\\mathrm{d} \\boldsymbol{p}}{\\mathrm{d} s}$ は単位接線ベクトルで、$\\boldsymbol{u}(s)$ は外向きの単位法線ベクトルだから、接線ベクトルを時計回りに90度回転させたものになるはず。\n$$ \\boldsymbol{u} (s) = (\\frac{\\mathrm{d} q}{\\mathrm{d} s},-\\frac{\\mathrm{d} p}{\\mathrm{d} s}) $$$\\boldsymbol{x}$ を $s$ と $r$ で偏微分すると\n$$ \\begin{align} \\frac{\\partial \\boldsymbol{x}}{\\partial s} \u0026= \\frac{\\partial \\boldsymbol{p}}{\\partial s} + r\\frac{\\partial \\boldsymbol{u}}{\\partial s} \\\\ \\frac{\\partial \\boldsymbol{x}}{\\partial r} \u0026= \\boldsymbol{u} (s) \\end{align} $$各成分の偏微分を計算すると、まず $x$ については\n$$ \\begin{align} \\frac{\\partial x}{\\partial s} \u0026= \\frac{\\mathrm{d} p}{\\mathrm{d} s} + r\\frac{\\mathrm{d}^2 q}{\\mathrm{d} s^2} \\\\ \\frac{\\partial x}{\\partial r} \u0026= \\frac{\\mathrm{d} q}{\\mathrm{d} s} \\end{align} $$$y$ については\n$$ \\begin{align} \\frac{\\partial y}{\\partial s} \u0026= \\frac{\\mathrm{d} q}{\\mathrm{d} s} - r\\frac{\\mathrm{d}^2 p}{\\mathrm{d} s^2} \\\\ \\frac{\\partial y}{\\partial r} \u0026= -\\frac{\\mathrm{d} p}{\\mathrm{d} s} \\end{align} $$よって行列はこうなる：\n$$ \\begin{pmatrix} \\frac{\\partial x}{\\partial s} \u0026amp; \\frac{\\partial x}{\\partial r} \\ \\frac{\\partial y}{\\partial s} \u0026amp; \\frac{\\partial y}{\\partial r} \\end{pmatrix} \\begin{pmatrix} \\frac{\\mathrm{d} p}{\\mathrm{d} s} + r\\frac{\\mathrm{d}^2 q}{\\mathrm{d} s^2} \u0026amp; \\frac{\\mathrm{d} q}{\\mathrm{d} s} \\ \\frac{\\mathrm{d} q}{\\mathrm{d} s} - r\\frac{\\mathrm{d}^2 p}{\\mathrm{d} s^2} \u0026amp; -\\frac{\\mathrm{d} p}{\\mathrm{d} s} \\end{pmatrix} $$\n行列式を計算すると\n$$ \\begin{align} \\det\\begin{pmatrix} \\frac{\\mathrm{d} p}{\\mathrm{d} s} + r\\frac{\\mathrm{d}^2 q}{\\mathrm{d} s^2} \u0026 \\frac{\\mathrm{d} q}{\\mathrm{d} s} \\\\ \\frac{\\mathrm{d} q}{\\mathrm{d} s} - r\\frac{\\mathrm{d}^2 p}{\\mathrm{d} s^2} \u0026 -\\frac{\\mathrm{d} p}{\\mathrm{d} s} \\end{pmatrix} \u0026= (\\frac{\\mathrm{d} p}{\\mathrm{d} s} + r\\frac{\\mathrm{d}^2 q}{\\mathrm{d} s^2})(-\\frac{\\mathrm{d} p}{\\mathrm{d} s})-(\\frac{\\mathrm{d} q}{\\mathrm{d} s} - r\\frac{\\mathrm{d}^2 p}{\\mathrm{d} s^2})(\\frac{\\mathrm{d} q}{\\mathrm{d} s}) \\\\ \u0026= -(\\frac{\\mathrm{d} p}{\\mathrm{d} s})^2 -r\\frac{\\mathrm{d}^2 q}{\\mathrm{d} s^2}\\frac{\\mathrm{d} p}{\\mathrm{d} s}-(\\frac{\\mathrm{d} q}{\\mathrm{d} s})^2+r\\frac{\\mathrm{d}^2 p}{\\mathrm{d} s^2}\\frac{\\mathrm{d} q}{\\mathrm{d} s} \\\\ \u0026= -[(\\frac{\\mathrm{d} p}{\\mathrm{d} s})^2+(\\frac{\\mathrm{d} q}{\\mathrm{d} s})^2]-r(\\frac{\\mathrm{d}^2 q}{\\mathrm{d} s^2}\\frac{\\mathrm{d} p}{\\mathrm{d} s}-\\frac{\\mathrm{d}^2 p}{\\mathrm{d} s^2}\\frac{\\mathrm{d} q}{\\mathrm{d} s}) \\end{align} $$第一問と第二問の結果を使うと\n$$ \\begin{align} \\left | \\det\\begin{pmatrix} \\frac{\\mathrm{d} p}{\\mathrm{d} s} + r\\frac{\\mathrm{d}^2 q}{\\mathrm{d} s^2} \u0026 \\frac{\\mathrm{d} q}{\\mathrm{d} s} \\\\ \\frac{\\mathrm{d} q}{\\mathrm{d} s} - r\\frac{\\mathrm{d}^2 p}{\\mathrm{d} s^2} \u0026 -\\frac{\\mathrm{d} p}{\\mathrm{d} s} \\end{pmatrix} \\right | \u0026= \\left | -1-r\\frac{\\mathrm{d} \\theta}{\\mathrm{d} s} \\right | \\\\ \u0026= 1+r\\frac{\\mathrm{d} \\theta}{\\mathrm{d} s} \\end{align} $$ちなみに、ここで出てきた行列は ヤコビ行列 だね。\n第五問 問題：$K_D$ の面積 $A_D$ を、もとの面積 $A$ と全長 $L$ を使って示せ。\nこの証明は図を描いて考えるとイメージしやすいよ。言葉で説明するのはちょっと難しいけど、だいたいこんな感じ。\n青い部分が $K$ の面積 $A$。緑の部分は、曲線の各点から距離 $D$ まで法線方向に伸ばしたときにできる長方形のような部分で、その面積は全長 $L \\times D$ になる。そして、図では見やすくするために大きく描いているけど、角にあるピンク色の部分は、凸で滑らかな閉曲線の場合、全部合わせるとちょうど半径 $D$ の円になるんだ。だからこの部分の面積は $\\pi D^2$。\n直感的には、角の部分を無限に小さくしていくと直角に近づくけど、単純に $LD$ だけだと扇形の「隙間」が計算に入らない。その全ての隙間を足し合わせると、一周分でちょうど一つの円になる、ってことだね。\nだから $A_D = A + LD + \\pi D^2$ となるんだ。\nWrote with ChatGPT\n","date":"2024-10-24T22:46:25+08:00","permalink":"https://blog.yexca.net/ja/archives/187/","title":"東京大学大学院 理工学研究科 数学 2020 問題2 の解答"},{"content":" 📢 この記事は gemini-3-flash-preview によって翻訳されました はじめに 2022 SA 午前1\n01-02: https://blog.yexca.net/ja/archives/184 03-05: https://blog.yexca.net/ja/archives/185 06-10: https://blog.yexca.net/ja/archives/186 11-15: https://blog.yexca.net/ja/archives/189 16-30: https://blog.yexca.net/ja/archives/190 複数の試験で共通して使われる問題だからか、内容は結構基礎的だね。感覚としては応用情報技術者試験（ソフトウェアデザイン）くらいのレベルかな。でも試験は全部で4つあるし、この最初のパートをいつ書き終えられるか自分でもわからないや。\n第六問 一つの $I^2C$ バスに接続された二つのセンサがある。それぞれのセンサ値を読み込む二つのタスクで排他的に制御したい。利用するリアルタイムOSの機能として、適切なものはどれか。\nア　キュー\nイ　セマフォ\nウ　マルチスレッド\nエ　ラウンドロビン\n問題の要約：一つの I²C バスに接続された2つのセンサがある。2つのタスクがそれぞれのセンサ値を読み込む際に排他制御を行いたい場合、どのリアルタイムOSの機能を使うべきか？\nア：キュー (queue)\nキューはデータ構造の一つで、FIFO（先入れ先出し）の原則に従うもの。複数のタスク間での通信やデータの受け渡しに適しているよ。\nイ：セマフォ (semaphore)\nセマフォは同期メカニズムの一つで、主に共有リソースへのアクセスを制御し、並行環境で複数のタスクが同時に同じリソースにアクセスしないようにするために使われる。セマフォには、二値セマフォ（排他アクセス用）と計数セマフォ（リソースプール管理用）の2種類があるんだ。\nウ：マルチスレッド (Multithreading)\nマルチスレッドは、一つのプロセス内で複数のスレッドを同時に実行する仕組みのこと。それ自体は排他制御の機能ではないけれど、共有リソースに安全にアクセスするためにセマフォやミューテックスなどのメカニズムと一緒に使われることが多いね。\nエ：ラウンドロビン (Round Robin)\nラウンドロビンは単純なタスクスケジューリングアルゴリズムの一つで、例えばタイムスライスごとにタスクを切り替える方式のことだよ。\n選択肢自体は難しくないけれど、カタカナ用語ばかりだとちょっと大変だね。以上のことから、正解は イ。\n第七問 アクチュエータの説明として、適切なものはどれか。\nア　与えられた目標量と、センサから得られた制御量に比較し、制御量を目標量に一致させるように操作量を出力する。\nイ　位置、角度、速度、加速度、力、温度などを検出し、電気的な情報に変換する。\nウ　エネルギー源からのパワーを、回転、直進などの働きに変換する。\nエ　マイクロフォン、センサなどが出力する微小な電気信号を増幅する。\n問題の要約：アクチュエータの説明として正しいのはどれ？\nア：与えられた目標値とセンサから得た制御値を比較し、一致させるように操作量を出力する。\nイ：位置、角度、速度、加速度、力、温度などを検出し、電気信号に変換する。\nウ：エネルギー源からのパワーを回転や直線運動などの働きに変換する。\nエ：マイクロフォンやセンサなどが出力する微弱な電気信号を増幅する。\nア はコントローラの機能で、通常はフィードバック制御システムで使われるもの。イ はセンサの機能で、物理量を電気信号に変えるもの。ウ がアクチュエータの機能だね。エ はアンプ（増幅器）の機能。ということで、正解は ウ。\n第八問 第1、第2、第3正規形とリレーションの特徴 a, b, c の組合のうち、適切なものはどれか。\na：どの非キー属性も、主キーの真部分集合に対して関数従属しない。\nb：どの非キー属性も、主キーに推移的に関数従属しない。\nc：繰り返し属性が存在しない。\n第1正規形 第2正規形 第3正規形 ア a b c イ a c b ウ c a b エ c b a 問題の要約：1NF、2NF、3NF の定義と、特徴 a, b, c の組み合わせとして正しいのはどれ？\na：どの非キー属性も、主キーの真部分集合に依存しない（部分関数従属の排除）。\nb：どの非キー属性も、他の非キー属性を介して主キーに依存しない（推移的関数従属の排除）。\nc：繰り返し属性が存在しない。\nこれはデータベースの正規化の話だね。以前 この記事 でも書いたことがあるよ。まとめると、1NF は c、2NF は a、3NF は b に対応する。答えは ウ だね。\n第九問 ビッグデータの利用におけるデータマイニングを説明したものはどれか。\nア　蓄積されたデータを分析し、単なる検索だけではわからない隠れた規則や相関関係を見つけ出すこと\nイ　データウェアハウスに格納されたデータの一部を、特定の用途や部門用に切り出して、データベースに格納すること\nウ　データ処理の対象となる情報を基に規定した、データの構造、意味及び操作の枠組みのこと\nエ　データを複数のサーバに複製し、性能と可用性を向上させること\n問題の要約：ビッグデータ利用における「データマイニング」の説明はどれ？\nア：蓄積されたデータを分析し、単純な検索では見つからない隠れた法則や相関関係を見つけ出す。\nイ：データウェアハウスからデータの一部を抽出し、特定の用途や部門向けにデータベースに格納する。\nウ：処理対象の情報に基づき、データの構造、意味、操作の枠組みを定義する。\nエ：データを複数のサーバに複製して、性能と可用性を高める。\nア がデータマイニングの正しい説明だね。イ はデータマートの説明。ウ はデータモデルの定義。エ はレプリケーション（データ複製）のこと。正解は ア。\n第十問 UDPを使用しているものはどれか。\nア　FTP\nイ　NTP\nウ　POP３\nエ　TELNET\n問題の要約：次のうち、UDP プロトコルを使用しているのはどれ？\nFTP はファイル転送プロトコルで、データの確実性を保証するために TCP を使う。NTP はネットワーク時刻プロトコルで、速度（低遅延）を優先するために UDP を使うんだ。POP3 はメール受信用のプロトコルで、メールの信頼性を保つために TCP を使う。TELNET は遠隔操作プロトコルで、信頼できるセッションを確立するために TCP を使う。だから、正解は イ。\n","date":"2024-10-22T15:37:34+08:00","permalink":"https://blog.yexca.net/ja/archives/186/","title":"2022 SA 午前1 - 06-10"},{"content":" 📢 この記事は gemini-3-flash-preview によって翻訳されました はじめに 2022 SA am1\n01-02: https://blog.yexca.net/ja/archives/184 03-05: https://blog.yexca.net/ja/archives/185 06-10: https://blog.yexca.net/ja/archives/186 11-15: https://blog.yexca.net/ja/archives/189 16-30: https://blog.yexca.net/ja/archives/190 つぶやき 月曜日はいつも疲れるよね。週末に休んだ後だと、どうしてもやる気が出ない。でも、今日はどういうわけか、これまでの沈んでた気分が嘘みたいにスッキリして、急にポジティブになったんだ。何もしてないんだけどね。感情とか心の状態って本当に不思議。\nだから今日は結構のんびりしちゃって、危うく更新をサボるところだった。でもこの試験、30問もあるんだよね。今のペースだと全部終わるのに半月はかかりそう……。 :cry:\n第3問 プログラミング言語のうち、ブロックの範囲を指定する方法として特定の記号や予約語を用いず、等しい文字数の字下げを用いるという特徴をもつものはどれか。\nア　C\nイ　Java\nウ　PHP\nエ　Python\n問題の要約：プログラミング言語の中で、特定の記号や予約語を使わずに、同じ文字数のインデント（字下げ）でコードブロックの範囲を決める特徴があるのはどれ？\nもちろん Python だから、正解は選択肢「エ」だね。\n第4問 キャッシュメモリのアクセス時間が主記憶のアクセス時間の1/30で、ヒット率が95％のとき、実効メモリアクセス時間は、主記憶のアクセス時間の約何倍になるか。\nア　0.03\nイ　0.08\nウ　0.37\nエ　0.95\nこの問題は実効メモリアクセス時間（EMAT）についての問題。この公式で計算できるよ。\n$$ EMAT = \\text{キャッシュのアクセス時間} \\times \\text{ヒット率} + \\text{主記憶のアクセス時間} \\times \\text{失効率} $$主記憶のアクセス時間を T とすると、キャッシュのアクセス時間は $\\frac{T}{30}$。問題文からヒット率は 95% だから、失効率（ミス率）は 5% になる。\nなので、EMAT = $\\frac{T}{30} \\times 95\\% + T \\times 5\\% \\approx 0.08T$。というわけで、答えは選択肢「イ」だね。\nこの問題、実は最初解けなかったんだ。コンピュータ構成法は半分くらいしか聞いてなかったし、正直ほとんど忘れちゃってる。\n第5問 プロセッサ数と、計算処理におけるプロセスの並列化が可能な部分の割合とが、性能上へ及ぼす影響に関する記述のうち、アムダールの法則に基づいたものはどれか。\nア　全ての計算処理が並列化できる場合、速度向上比は、プロセッサ数を増やしてもある水準に漸近的に近づく。\nイ　並列化できない計算処理がある場合、速度向上比は、プロセッサ数に比例して増加する。\nウ　並列化できない計算処理がある場合、速度向上比は、プロセッサ数を増やしてもある水準に漸近的に近づく。\nエ　並列化できる計算処理の割合が増えると、速度向上比は、プロセッサ数に反比例して減少する。\n問題の要約：プロセッサの数と並列化可能な部分の割合が性能に与える影響について、アムダールの法則に基づいた説明はどれ？\nア：すべての計算が並列化できる場合、速度向上比はプロセッサ数を増やしてもある一定値に近づく。 イ：並列化できない部分がある場合、速度向上比はプロセッサ数に比例して増える。 ウ：並列化できない部分がある場合、プロセッサ数を増やしても速度向上比はある一定値に近づく。 エ：並列化できる割合が増えると、速度向上比はプロセッサ数に反比例して減る。\nこの問題を解くには、まず「アムダールの法則（Amdahl\u0026rsquo;s Law）」が何かを知っておく必要があるよ。アムダールの法則は、プログラムの中に並列化できない部分があると、いくらプロセッサを増やしても全体の性能向上には限界があるということを示しているんだ。公式はこんな感じ：\n$$ S(N)=\\frac{1}{(1-P)+\\frac{P}{N}} $$ここで $S(N)$ は $N$ 個のプロセッサを使った時の速度向上比、$P$ はプログラムの中で並列化できる部分の割合、$N$ はプロセッサの数だよ。\n以上のことから、正解は「ウ」になるね。\n","date":"2024-10-21T20:35:34+08:00","permalink":"https://blog.yexca.net/ja/archives/185/","title":"2022 SA 午前1 - 03-05"},{"content":" 📢 この記事は gemini-3-flash-preview によって翻訳されました はじめに 2022 SA am1\n01-02: https://blog.yexca.net/ja/archives/184 03-05: https://blog.yexca.net/ja/archives/185 06-10: https://blog.yexca.net/ja/archives/186 11-15: https://blog.yexca.net/ja/archives/189 16-30: https://blog.yexca.net/ja/archives/190 さて、この記事についてだけど、ちょっと挑戦してみようかなと思って書いているんだ。合格するかどうかは別として、システムアーキテクト試験、つまり情報処理技術者試験の高度試験を受けてみようと思う。この試験で手に入る資格や知識は、普段のコーディングではあまり使わないかもしれないけど（本当は使えるのに気づいてないだけかもしれないけどね）、持っていて損はないはず。少しずつでもこの過去問を解き進めて、現実感を取り戻していけたらいいな。\n独り言 ここ2年くらい、本当にふわふわした感じで過ごしちゃってて、その状態が今の物事の進め方にも大きく影響してるんだ。このままじゃダメだよね。選べないなら、せめて今できることを精一杯やろうと思う。少なくとも挑戦はしてみたい。挑戦する勇気がないのが一番怖いことだし、それで最近もチャンスを一つ逃しちゃったから。少しずつでも変化を起こして、もっと「生きてる」実感を持ちたいんだ。時々、自分が夢の中にいるような感覚になることがあるけど、それは良い意味じゃなくて、現実味がないっていうか。言葉の力には限界があるけど、実際の経験には説得力があるよね。たとえそれが作り物だったとしても、今は信じてみることにしたんだ。\nうーん、なんか日記みたいになっちゃったね。まあまあ、そんな感じ。\n「夢を見てるみたい」って書いたけど、それで面白い修仙小説（仙人を目指す中国の小説）を思い出した。ある魔宗の人が、自分は仙人で今の世界はただの幻影、修行のために来てるんだって思い込んでる設定。僕もたまにその設定に影響されてる気がする。だからもう無駄話はやめようね。\n第1問 ハミング符号とは、データに冗長ビットを付加して、1ビットの誤りを訂正できるようにしたものである。ここでは。$X_1, X_2, X_3, X_4$ の4ビットから成る数据に3ビットの冗長ビット $P_3, P_2, P_1$ を付加したハミング符号 $X_1X_2X_3P_3X_4P_2P_1$ を考える。付加したビット $P_1, P_2, P_3$ は、それぞれ\n$$ X_1 \\oplus X_3 \\oplus X_4 \\oplus P_1 = 0 \\\\ X_1 \\oplus X_2 \\oplus X_4 \\oplus P_2 = 0 \\\\ X_1 \\oplus X_2 \\oplus X_3 \\oplus P_3 = 0 $$となるように決める。ここで、$\\oplus$ は排他的論理和を表す。\nハミング符号1110011には1ビットの誤りが存在する。誤りビットを訂正したハミング符号はどれか。\nア　0110011\nイ　1010011\nウ　1100011\nエ　1110111\nハミング符号の問題だね。問題文に公式があるから、それぞれ代入して排他的論理和（XOR）を計算すると、\n$$ X_1 \\oplus X_3 \\oplus X_4 \\oplus P_1 = 1 \\\\ X_1 \\oplus X_2 \\oplus X_4 \\oplus P_2 = 1 \\\\ X_1 \\oplus X_2 \\oplus X_3 \\oplus P_3 = 1 $$となる。これから誤りがある位置は $(111)_2$、つまり第7位だとわかる。だから、正しいデータは 0110011、つまり選択肢 ア だね。\nハミング符号を見たとき、懐かしいなとは思ったけど、具体的にどんなものだったか全然覚えてなかった。あぁ、前は何を学んでたんだろうね。\nハミング符号はデータの誤りチェックと1ビットの訂正ができる。元のデータが 1100 の場合を例に、ハミング符号にする手順はこんな感じ。\nまず、冗長ビット（チェックビット）の数 $k$ を計算する。$2^k \\ge k + m + 1$ （mは元のデータ数、kはチェックビット数）。この例だと $k=3$ になる。チェックビットは $2^n$ の位置、つまり 1, 2, 4, 8 ··· に配置される。ここでは右から数えて 1, 2, 4番目だね。\n3ビットのチェックビットと4ビットのデータで合計7ビット。2進数で表すとこうなる（チェックビット3ビット分なので3桁の2進数）。\n7 6 5 4 3 2 1 111 110 101 100 011 010 001 チェックビットの位置、つまり 1, 2, 4 の数字はそれぞれ 001, 010, 100 に対応している。つまり 1 が立っている位置が1桁目、2桁目、3桁目ということ。次に、同じ位置に 1 を持つものを探し出すよ。\nチェックビット位置 1の位置 位置番号 1 1桁目、**1 1、3、5、7 2 2桁目、*1* 2、3、6、7 4 3桁目、1** 4、5、6、7 次に、各グループ（上の表の各行）ごとにチェックビットを計算する。元のデータを使うとこんな感じ。\n位置 7 6 5 4 3 2 1 数値 1 1 0 0 チェックビットの値はまだ決まってないから、一旦空欄にしておく。\n第1グループは、1, 3, 5, 7番目の数字で決める。1が1個あるから、1の数を偶数にするために 1 を補う（偶数パリティの場合）。\n第2グループは、2, 3, 6, 7番目の数字で決める。1が2個あるから、0 を補う。\n第3グループは、4, 5, 6, 7番目の数字で決める。1が2個あるから、0 を補う。\nだから、ハミング符号の各位置はこうなる。\n位置 7 6 5 4 3 2 1 数値 1 1 0 0 0 0 1 つまり、データ 1100 のハミング符号は 1100001 になる。チェック方法は問題文と同じだね。問題の例も7ビットだし。\nどうやってチェックするかというと、問題の3つの式の位置を右から数えるように変換してみると、さっきチェックビットを決める時に分けた3つのグループと同じだってことがわかる。だから、チェック方法は各グループでXOR操作をして、得られた結果（全部0ならエラーなし）を右から並べればいいんだ。つまり、\n···第3グループ、第2グループ、第1グループ\n得られた2進数が、データが変化した位置を表している。その位置の数値を反転させれば元のハミング符号に戻るよ。\n参考記事\n海明码一篇文章彻底搞懂 海明码的编码和校验方法 排他的論理和（XOR） 第2問 リストには、配列で実現する場合とポインタで実現する場合とがある。リストを配列で実現した場合の特徴として、適切なものはどれか。ここで、配列を用いたリストは配列に要素を連続して格納することによってリストを構成し、ポインタを用いたリストは要素と次の要素へのポインタを用いることによってリストを構成するものとする。\nア　リストにある実際の要素数にかかわらず、リストに入れられる要素の最大個数に対応した領域を確保し、実際には使用されない領域が発生する可能性がある。\nイ　リストの中間要素を参照するには、リストの先頭から順番に要素をたどっていくことから、要素数に比例した時間が必要となる。\nウ　リストの要素を格納する領域の他に、次の要素を指し示すための領域が別途必要となる。\nエ　リストへの挿入位置が分かる場合には、リストにある実際の要素数にかかわらず、要素の挿入を一定時間で行うことができる。\nこの問題は、配列で実現したリストの特徴を聞いているね。ア 以外は全部ポインタで構成されたリスト（連結リスト）の特徴だから、答えは選択肢 ア だ。\n内容はかなり分かりやすいね。間違えるとしたら、日本語が読めなかったときかな :cry:。各選択肢の解説はこんな感じ：\nア：リストの実際の要素数に関係なく、あらかじめ最大個数分のメモリを確保するから、使われない無駄な領域ができる可能性がある。\nイ：中間要素にアクセスするのに先頭から辿る必要があるのは連結リストの特徴。配列ならインデックスで直接アクセスできる。\nウ：次の要素を指すための追加領域（ポインタ）が必要なのは連結リストの特徴。\nエ：挿入を一定時間で行えるのは連結リスト（位置がわかっている場合）。配列だと、要素をずらす必要があるから時間がかかる。\n","date":"2024-10-20T20:19:11+08:00","permalink":"https://blog.yexca.net/ja/archives/184/","title":"2022 SA am1 -01-02"},{"content":" 📢 この記事は gemini-2.5-flash によって翻訳されました はじめに 日本語のタイトルをつけたけど、この記事の内容は主に日本語じゃないよ。もし時間があれば追記するかもね\n問題1：この記事\n問題2： https://blog.yexca.net/ja/archives/187 問題3： https://blog.yexca.net/ja/archives/188 ここ数年、ちゃんと授業は聞いてるはずなのに、勉強で何の成果も出てない気がしてたんだ。だから、試しに問題を解いてみようと思ってね（そう、勉強はするけど問題を解かないっていう、あんまり普通じゃない状況が、当時の自分にはすごく普通に思えてたんだよね。多分、ただ怠けてただけだと思うけど）。で、いざ問題を解いてみたら、なんていうか、解けないんだよね。どう解くかを調べたら、授業でやった記憶はあるんだけど、結局ほとんど一から学び直す感じで解き終えたってわけ。\nあと、解答例がないから、最初の3問はPythonで計算してみたんだ。答えは合ってるはずだけど、最後の2問は証明問題だから、証明が正しいかは保証できないな。\n問題 出典: https://www.i.u-tokyo.ac.jp/edu/entra/examarchive.shtml 問題の著作権は東京大学のものだよ。見やすいように引用してるだけで、営利目的じゃないからね。\n正方行列 $A,B$ を\n$$ A=\\begin{pmatrix} 1 \u0026 \\sqrt{2} \u0026 0 \\\\ \\sqrt{2} \u0026 1 \u0026 \\sqrt{2} \\\\ 0 \u0026 \\sqrt{2} \u0026 1 \\end{pmatrix}, B=\\begin{pmatrix} 0 \u0026 -\\frac{2}{3} \u0026 \\frac{1}{3} \\\\ \\frac{2}{3} \u0026 0 \u0026 -\\frac{2}{3} \\\\ -\\frac{1}{3} \u0026 \\frac{2}{3} \u0026 0 \\end{pmatrix} $$とする。また、行列 $I$ は単位行列とする。実正方行列 $X$ に対して、$\\exp(X)$ を\n$$ \\exp(X)=\\sum_{k=0}^{\\infty}(\\frac{1}{k!}X^{k})=I+X+\\frac{1}{2!}X^{2}+\\frac{1}{3!}X^{3}+\\cdots $$と定義するとき、以下の問いに答えよ。\n（1）$A$ の全ての固有値と、それらに対応する固有ベクトルを求めよ。ただし、固有ベクトルとして、ノルムは $1$ かつ第一要素は非負実数であるものを選べ。\n（2）非負整数 $n$ に対して、$A^{n}$ を求めよ。\n（3）$\\exp(A)$ を求めよ。\n（4）$\\alpha$ を実数とするとき、$\\exp(\\alpha B)$ が次式のように表せることを示せ。\n$$ \\exp(\\alpha B) = I + (\\sin\\alpha)B + (1-\\cos(\\alpha))B^{2} $$ただし、ケーリー・ハミルトンの定理を用いてもよい。\n（5）$3$ 次元実ベクトル $a$ が与えられたとき、$3$ 次元実ベクトル $x$ に関する関数 $f$ を\n$$ f(x) = \\sum_{k=1}^{n} \\left \\| \\exp(\\frac{2\\pi k}{n}B)a - x \\right \\|^{2} $$とおく。ただし、$n \\ge 2$ とする。このとき、$x=(I+B^{2})a$ において $f$ が最小になることを示せ。\n問題1 問題: $A$ の固有値と固有ベクトルを求めよう（固有ベクトルのノルムは1で、第1要素は非負実数だよ）。\n固有方程式 $\\det(A-\\lambda I) = 0$ を使って行列を作って、その行列式を計算するよ。固有方程式はこんな感じ。\n$$ \\det(A-\\lambda I) =\\begin{vmatrix} 1-\\lambda \u0026 \\sqrt{2} \u0026 0 \\\\ \\sqrt{2} \u0026 1-\\lambda \u0026 \\sqrt{2} \\\\ 0 \u0026 \\sqrt{2} \u0026 1-\\lambda \\end{vmatrix} = 0 $$1行目で展開すると、\n$$ (1-\\lambda)[(1-\\lambda)^{2}-2]-\\sqrt{2}[\\sqrt{2}(1-\\lambda)]=0 $$これを解くと、\n$$ \\lambda_{1}=1, \\lambda_{2}=-1, \\lambda_{3}=3 $$次は、それぞれの固有値に対応する固有ベクトルを求めるよ。$\\lambda_{1}=1$ の場合。\n$$ (A-\\lambda_{1}I) = \\begin{pmatrix} 0 \u0026 \\sqrt{2} \u0026 0 \\\\ \\sqrt{2} \u0026 0 \u0026 \\sqrt{2} \\\\ 0 \u0026 \\sqrt{2} \u0026 0 \\end{pmatrix} $$方程式 $(A-\\lambda_{1}I)\\mathbf{v}_{1}=0$ を解くと、固有ベクトルはこれ。\n$$ \\mathbf{v}_{1}=\\begin{pmatrix} 1 \\\\ 0 \\\\ -1 \\end{pmatrix} $$$\\lambda_{2}=-1$ の場合。\n$$ (A-\\lambda_{2}I)=\\begin{pmatrix} 2 \u0026 \\sqrt{2} \u0026 0 \\\\ \\sqrt{2} \u0026 2 \u0026 \\sqrt{2} \\\\ 0 \u0026 \\sqrt{2} \u0026 2 \\end{pmatrix} $$方程式 $(A-\\lambda_{2}I)\\mathbf{v}_{2}=0$ を解くと、固有ベクトルはこれ。\n$$ \\mathbf{v}_{2}=\\begin{pmatrix} 1 \\\\ -\\sqrt{2} \\\\ 1 \\end{pmatrix} $$$\\lambda_{3}=3$ の場合。\n$$ (A-\\lambda_{3}I)=\\begin{pmatrix} -2 \u0026 \\sqrt{2} \u0026 0 \\\\ \\sqrt{2} \u0026 -2 \u0026 \\sqrt{2} \\\\ 0 \u0026 \\sqrt{2} \u0026 -2 \\end{pmatrix} $$方程式 $(A-\\lambda_{3}I)\\mathbf{v}_{3}=0$ を解くと、固有ベクトルはこれ。\n$$ \\mathbf{v}_{3}=\\begin{pmatrix} 1 \\\\ \\sqrt{2} \\\\ 1 \\end{pmatrix} $$固有ベクトルを正規化して、まとめるとこうなるよ。\n$$ \\begin{align*} 固有値\u0026: \\lambda_{1}=1, \\lambda_{2}=-1, \\lambda_{3}=3 \\\\ 固有ベクトル\u0026: \\mathbf{v}_{1}=\\frac{1}{\\sqrt{2}} \\begin{pmatrix} 1 \\\\ 0 \\\\ -1 \\end{pmatrix}, \\mathbf{v}_{2}=\\frac{1}{2} \\begin{pmatrix} 1 \\\\ -\\sqrt{2} \\\\ 1 \\end{pmatrix}, \\mathbf{v}_{3}=\\frac{1}{2} \\begin{pmatrix} 1 \\\\ \\sqrt{2} \\\\ 1 \\end{pmatrix} \\end{align*} $$Pythonコード sympyで結果を確かめてみたよ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import sympy as sp # 定義行列 A A = sp.Matrix([[1, sp.sqrt(2), 0], [sp.sqrt(2), 1, sp.sqrt(2)], [0, sp.sqrt(2), 1]]) # 固有値と固有ベクトルを計算 eigenvals = A.eigenvals() # 固有値 eigenvects = A.eigenvects() # 固有ベクトル print(f\u0026#34;A の固有値は\u0026#34;) sp.pprint(eigenvals) print(f\u0026#34;A の固有ベクトルは\u0026#34;) sp.pprint(eigenvects) 出力結果はこんな感じ。\n問題2 問題: $A^{n}$ を求めよう（$n$ は非負整数だよ）。\n対角化の理論によると、行列 $A$ は $A=S^{-1}DS$ に分解できるんだ。問題1から、こうなるね。\n$$ S=\\begin{pmatrix} 1 \u0026 1 \u0026 1 \\\\ 0 \u0026 -\\sqrt[]{2} \u0026 \\sqrt[]{2} \\\\ -1 \u0026 1 \u0026 1 \\end{pmatrix}, D=\\begin{pmatrix} 1 \u0026 0 \u0026 0 \\\\ 0 \u0026 -1 \u0026 0 \\\\ 0 \u0026 0 \u0026 3 \\end{pmatrix} $$$S$ の逆行列を計算すると、こうなるよ。\n$$ S^{-1}=\\begin{pmatrix} \\frac{1}{2} \u0026 0 \u0026 -\\frac{1}{2} \\\\ \\frac{1}{4} \u0026 -\\frac{\\sqrt{2}}{4} \u0026 \\frac{1}{4} \\\\ \\frac{1}{4} \u0026 \\frac{\\sqrt{2}}{4} \u0026 \\frac{1}{4} \\end{pmatrix} $$$D^{n}$ を計算するとこう。\n$$ D^{n}=\\begin{pmatrix} 1^{n} \u0026 0 \u0026 0 \\\\ 0 \u0026 (-1)^{n} \u0026 0 \\\\ 0 \u0026 0 \u0026 3^{n} \\end{pmatrix} $$$A^{n}=S^{-1}D^{n}S$ を解くと、\n$$ A^{n}=\\begin{pmatrix} \\frac{1}{2}+(-1)^{n}\\frac{1}{4}+\\frac{3^{n}}{4} \u0026 (-1)^{n+1}\\frac{\\sqrt{2}}{4}+\\frac{\\sqrt{2}}{4}3^{n} \u0026 -\\frac{1}{2}+(-1)^{n}\\frac{1}{4}+\\frac{3^{n}}{4} \\\\ (-1)^{n+1}\\frac{\\sqrt{2}}{4}+\\frac{\\sqrt{2}}{4}3^{n} \u0026 (-1)^{n}\\frac{1}{2}+\\frac{1}{2}3^{n} \u0026 (-1)^{n+1}\\frac{\\sqrt{2}}{4}+\\frac{\\sqrt{2}}{4}3^{n} \\\\ -\\frac{1}{2}+(-1)^{n}\\frac{1}{4}+\\frac{3^{n}}{4} \u0026 (-1)^{n+1}\\frac{\\sqrt{2}}{4}+\\frac{\\sqrt{2}}{4}3^{n} \u0026 \\frac{1}{2}+(-1)^{n}\\frac{1}{4}+\\frac{3^{n}}{4} \\end{pmatrix} $$Pythonコード sympyで結果を確かめてみたよ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 import sympy as sp # sqrt(2) を定義 sqrt_2 = sp.sqrt(2) # 行列 S と S^{-1} を定義 S = sp.Matrix([[1, 1, 1], [0, -sqrt_2, sqrt_2], [-1, 1, 1]]) S_inv = sp.Matrix([ [sp.Rational(1, 2), 0, -sp.Rational(1, 2)], [sp.Rational(1, 4), -sqrt_2 / 4, sp.Rational(1, 4)], [sp.Rational(1, 4), sqrt_2 / 4, sp.Rational(1, 4)] ]) # 対角行列 D を定義 lambda_1 = 1 lambda_2 = -1 lambda_3 = 3 D = sp.diag(lambda_1, lambda_2, lambda_3) # n を定義 n = sp.symbols(\u0026#39;n\u0026#39;) # D^n を計算 D_n = D**n # A^n = S D^n S^{-1} を計算 A_n = S * D_n * S_inv # 結果を出力 print(f\u0026#34;A^n = S D^n S^{-1} =\u0026#34;) sp.pprint(A_n) 出力結果はこんな感じ。\n他の解法 問題4でケーリー・ハミルトンの定理（ハミルトン–ケーリーの定理）が出てきたよね。この定理は行列の冪乗計算に使えるんだ。\n問題1で固有値を求めた後、こう置いてみる。\n$$ \\lambda^{n} = f(\\lambda)g(\\lambda) +a\\lambda^{2} +b\\lambda +c $$固有値を代入すると、$f(\\lambda_{1})=f(\\lambda_{2})=f(\\lambda_{3})=0$ だから、連立方程式はこうなるよ。\n$$ \\left\\{\\begin{matrix} 1 =a+b+c \\\\ (-1)^{n} =a-b+c \\\\ 3^{n} =9a+3b+c \\end{matrix}\\right. $$この連立方程式を解くと、\n$$ \\left\\{\\begin{matrix} a=\\frac{(-1)^{n}+3^{n}-2}{8} \\\\ b=1-\\frac{1+(-1)^{n}}{2} \\\\ c=\\frac{1+(-1)^{n}}{2}-\\frac{(-1)^{n}+3^{n}-2}{8} \\end{matrix}\\right. $$公式 $A^{n}=f(A)g(A)+aA^{2}+bA+cI$ に代入するんだけど、$f(A)=0$ だから $A^{n}=aA^{2}+bA+cI$ になるね。\n$$ A^{n}=\\begin{pmatrix} \\frac{1}{2}+(-1)^{n}\\frac{1}{4}+\\frac{3^{n}}{4} \u0026 (-1)^{n+1}\\frac{\\sqrt{2}}{4}+\\frac{\\sqrt{2}}{4}3^{n} \u0026 -\\frac{1}{2}+(-1)^{n}\\frac{1}{4}+\\frac{3^{n}}{4} \\\\ (-1)^{n+1}\\frac{\\sqrt{2}}{4}+\\frac{\\sqrt{2}}{4}3^{n} \u0026 (-1)^{n}\\frac{1}{2}+\\frac{1}{2}3^{n} \u0026 (-1)^{n+1}\\frac{\\sqrt{2}}{4}+\\frac{\\sqrt{2}}{4}3^{n} \\\\ -\\frac{1}{2}+(-1)^{n}\\frac{1}{4}+\\frac{3^{n}}{4} \u0026 (-1)^{n+1}\\frac{\\sqrt{2}}{4}+\\frac{\\sqrt{2}}{4}3^{n} \u0026 \\frac{1}{2}+(-1)^{n}\\frac{1}{4}+\\frac{3^{n}}{4} \\end{pmatrix} $$問題3 問題: $\\exp(A)$ を求めよう。\n問題2から $A$ は対角化できるから、\n$$ \\begin{align*} \\exp(A)\u0026=\\exp(SDS^{-1})\\\\ \u0026=I+SDS^{-1}+\\frac{1}{2!}(SDS^{-1})^{2}+\\frac{1}{3!} (SDS^{-1})^{3}+\\cdots \\\\ \u0026= I+SDS^{-1} +\\frac{1}{2!}SD^{2}S^{-1}+\\frac{1}{3!}SD^{3}S^{-1}+\\cdots \\end{align*} $$$S$ と $S^{-1}$ を抜き出すと、\n$$ \\begin{align*} \\exp(SDS^{-1})\u0026=S(I+D+\\frac{1}{2!}D^{2}+\\frac{1}{3!}D^{3}+\\cdots)S^{-1} \\\\ \u0026=S\\exp(D)S^{-1} \\end{align*} $$で、$D$ は対角行列だから、\n$$ \\exp(D)=\\begin{pmatrix} e \u0026 0 \u0026 0 \\\\ 0 \u0026 e^{-1} \u0026 0 \\\\ 0 \u0026 0 \u0026 e^{3} \\end{pmatrix} $$$\\exp(A)=S\\exp(D)S^{-1}$ を求めると、\n$$ \\exp(A)=\\begin{pmatrix} \\frac{1}{2}e+\\frac{1}{4}e^{-1}+\\frac{1}{4}e^{3} \u0026 -\\frac{\\sqrt{2}}{4}e^{-1}+\\frac{\\sqrt{2}}{4}e^{3} \u0026 -\\frac{1}{2}e+\\frac{1}{4}e^{-1}+\\frac{1}{4}e^{3} \\\\ -\\frac{\\sqrt{2}}{4}e^{-1}+\\frac{\\sqrt{2}}{4}e^{3} \u0026 \\frac{1}{2}e^{-1}+\\frac{1}{2}e^{3} \u0026 -\\frac{\\sqrt{2}}{4}e^{-1}+\\frac{\\sqrt{2}}{4}e^{3} \\\\ -\\frac{1}{2}e+\\frac{1}{4}e^{-1}+\\frac{1}{4}e^{3} \u0026 -\\frac{\\sqrt{2}}{4}e^{-1}+\\frac{\\sqrt{2}}{4}e^{3} \u0026 \\frac{1}{2}e+\\frac{1}{4}e^{-1}+\\frac{1}{4}e^{3} \\end{pmatrix} $$Pythonコード sympyで結果を確かめてみたよ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 import sympy as sp # 行列 A を定義 A = sp.Matrix([[1, sp.sqrt(2), 0], [sp.sqrt(2), 1, sp.sqrt(2)], [0, sp.sqrt(2), 1]]) # exp(A) を計算 exp_A = A.exp() # 結果を出力 print(\u0026#34;exp(A) =\u0026#34;) sp.pprint(exp_A) 出力結果はこんな感じ。\n問題4 問題: $\\alpha$ が実数のとき、等式を証明しよう（ケーリー・ハミルトンの定理を使ってもいいよ）。\n行列 $B$ の固有方程式を求めると、\n$$ \\det(B-\\lambda I)=\\begin{pmatrix} -\\lambda \u0026 -\\frac{2}{3} \u0026 \\frac{1}{3} \\\\ \\frac{2}{3} \u0026 -\\lambda \u0026 -\\frac{2}{3} \\\\ -\\frac{1}{3} \u0026 \\frac{2}{3} \u0026 -\\lambda \\end{pmatrix} = -\\lambda^{3}-\\lambda $$ケーリー・ハミルトンの定理から、\n$$ P(B)=-B^{3}-B=0 $$だから、\n$$ B^{3}=-B $$これを使って、こう計算できるね。\n$$ \\begin{align*} B^{4}\u0026=B^{3}B=-B^{2} \\\\ B^{5}\u0026=B^{4}B=-B^{3}=B \\end{align*} $$$\\exp(\\alpha B)$ に代入すると、\n$$ \\begin{align*} \\exp(\\alpha B) \u0026=I+\\alpha B+\\frac{1}{2!}(\\alpha B)^{2}+\\frac{1}{3!}(\\alpha B)^{3}+\\frac{1}{4!}(\\alpha B)^{4}+\\frac{1}{5!}（\\alpha B）^{5}+\\cdots \\\\ \u0026=I+\\alpha B+\\frac{1}{2!}\\alpha^{2}B^{2}-\\frac{1}{3!}\\alpha^{3}B-\\frac{1}{4!}\\alpha^{4}B^{2}+\\frac{1}{5!}\\alpha^{5}B+\\cdots \\\\ \u0026=I+(\\alpha-\\frac{1}{3!}\\alpha^{3}+\\frac{1}{5!}\\alpha^{5}-\\cdots)B+(\\frac{1}{2!}\\alpha^{2}-\\frac{1}{4!}\\alpha^{4}+\\cdots)B^{2} \\end{align*} $$上の式を見ると、$B$ の係数は $\\sin(\\alpha)$ のテイラー展開、そして $B^{2}$ の係数は $1-\\cos(\\alpha)$ のテイラー展開になってるよね。だから、\n$$ \\exp(\\alpha B) = I + (\\sin\\alpha)B + (1-\\cos(\\alpha))B^{2} $$問題5 問題: 3次元実ベクトル $a$ が与えられたとき、3次元実ベクトル $x$ に関する関数 $f$ を以下のように定義するよ（公式は省略）。ただし $n \\ge 2$ だ。このとき、$x=(I+B^{2})a$ のときに $f$ が最小になることを証明しよう。\n問題4から $\\exp(\\alpha B)$ がわかるよね。これに $\\alpha=\\frac{2\\pi k}{n}$ を代入すると、\n$$ \\exp(\\frac{2\\pi k}{n}B)=I+(\\sin(\\frac{2\\pi k}{n}))B+(1-\\cos(\\frac{2\\pi k}{n}))B^{2} $$$x=(I+B^{2})a$ を $f$ に代入すると、\n$$ \\begin{align*} f(x)\u0026=\\sum_{k=1}^{n}\\left \\| [I+(\\sin(\\frac{2\\pi k}{n}))B+(1-\\cos(\\frac{2\\pi k}{n}))B^{2}]a - (I+B^{2})a \\right \\|^{2} \\\\ \u0026=\\sum_{k=1}^{n}\\left \\| [I+(\\sin(\\frac{2\\pi k}{n}))B+(1-\\cos(\\frac{2\\pi k}{n}))B^{2}-I-B^{2}]a \\right \\|^{2} \\\\ \u0026=\\sum_{k=1}^{n}\\left \\| [(\\sin(\\frac{2\\pi k}{n}))B-(\\cos(\\frac{2\\pi k}{n}))B^{2}]a \\right \\|^{2} \\end{align*} $$$f(x)$ はユークリッドノルムの2乗、つまり距離の値だから、$f(x)\\ge0$ だよね。\nあと、$\\sin x$ と $\\cos x$ の周期は $2\\pi$ で、$k$ を $1$ から $n$ まで動かすのはその周期を等分してるんだ。周期内で対称な値の和は $0$ になるから、\n$$ \\sum_{k=1}^{n}(\\sin(\\frac{2\\pi k}{n}))=\\sum_{k=1}^{n}(\\cos(\\frac{2\\pi k}{n}))=0 $$だから、$x=(I+B^{2})a$ のとき $f(x)=0$ になるんだ。そして $f(x)\\ge0$ なんだから、元の命題は成り立つってわけ。\n参考資料 MIT - 線形代数 妈咪说が作ったLaTeX数式エディタ 『線形代数』講義動画 宋浩先生 Wikipedia - ケーリー・ハミルトンの定理 龍殺しの奥義：ケーリー・ハミルトンの定理で行列のべき乗をサクサク倒す方法 ChatGPTで書きました\n","date":"2024-10-14T21:37:58+08:00","permalink":"https://blog.yexca.net/ja/archives/183/","title":"東京大学大学院理工学 数学 2020 問題一"},{"content":" 📢 この記事は ChatGPT によって翻訳されました はじめに 最近、SSD を交換したので PC をクリーンインストールすることに。\n何年も使ってなかった USB を取り出したら、中のソフトがだいぶ古くなってたし、新しい環境に対応してないものも多かった。\nこの機会に使ってるソフトを整理して記録しておくことにした。\nこの記事自体は 2024年9月16日から書き始めたけど、ちょっと色々あって、最終的に書き上げたのは 10月2日。\nシステム しばらく Win11 を使ってて、今回も Win11 を続投。\nUSB に入ってたイメージが古かったので、 MSDN itellyou から最新の ISO をダウンロード。\nインストール中に気づいたけど、最近のやつはネット接続しないと進まないんだね……。\nMS アカウントでのログインを求められて、ネットがないとスキップできない。古いバージョンか Win10 にしてアップグレードする方が楽かも (doge)\n2024.10.03\nネット接続をスキップする方法が2つあるらしい 、まだ試してないけどメモ：\nCtrl+Shift+F3 を押すとセットアップをスキップできて、ローカルユーザーも作成しない（再起動後に再設定になる） Shift+F10 でコマンドプロンプトを開いて oobe\\bypassnro.cmd を実行。再起動後に「ネット接続なし」オプションが出る ソフト構成 前に作ったインストール用 USB がかなり古かったので、不要なソフトや今は別の代替ツールを使ってるものも多かった。\n今後の自分用にメモ残しておく。どうせ次回はまた違う構成になるだろうし。\nオフィスソフト 基本の Office は必須。Office Tool を使って簡単にインストール。\n必要なのは Word、Excel、PowerPoint のみ。\nOffice Tool ダウンロード: https://otp.landian.vip/zh-cn/download.html コードでインストール実行：\n1 deploy /add O365ProPlusRetail_zh-cn /O365ProPlusRetail.exclapps Access,Bing,Groove,Lync,OneDrive,OneNote,Outlook,Publisher,Teams /channel Current /dlfirst KMS でライセンス認証：\n1 2 3 ospp /inslicid MondoVolume /sethst:kms.loli.beer /setprt:1688 /act # または kms.03k.org ospp /inslicid MondoVolume /sethst:kms.03k.org /setprt:1688 /act 参考：\nhttps://www.coolhub.top/archives/11 https://www.coolhub.top/archives/14 ダウンロード・クラウド 迅雷：古い軽量版を使用。吸血云々あるけど必要なときはある BitComet：BT 用、軽量版。qBittorrent や µTorrent も選択肢 Resilio Sync ：BT 技術をベースにしたファイル同期ツール IDM：マルチスレッド型ダウンロードマネージャ 115 : 動かない BT を落とすときに使う。他に pikpak なども 百度网盘 : プレミアムなら便利。阿里網盤や夸克網盤などは必要時に入れる チャット・SNS 使ってるのはこんな感じ：\nTencent 系\nQQ : 最近の NT バージョンはまあまあ WeChat: https://www.wechat.com/ Telegram\nhttps://desktop.telegram.org/ 解凍ツール 前の PC にはいくつか入れてたけど、実際使うのは 2 つだけ。\nBandizip : 定番の解凍ツール WinRAR：一部の RAR はこれじゃないと開けない その他候補：\n7zip ：王道の無料ツール NanaZip ：7z の UI 改良版。Win11 の右クリック統合も可 その他ツール Utools : プラグインで何でもできる超便利ランチャー。この記事も Utools の MD プラグインで書いてる\nQuickLook : ファイルプレビュー\n1Password : パスワードマネージャ。オープンソース代替は bitwarden PDF 閲覧ツールはお好みで\nFoxit PDF Wondershare PDFelement PDF XChange sandboxie : サンドボックス環境。非インストール版は管理者権限が必要\nTickTick : ToDo アプリ。最近同期が不調気味？\nQuiteRSS : RSS クライアント。古い UI だけど気に入ってる\nDuplicate Cleaner Pro：重複ファイル整理ツール。八酱のおすすめ\nPixPin : スクリーンショットツール\nコード系ツール VS Code : 必須 Typora : MD 可視化エディタ Git: https://git-scm.com/downloads/win 1 2 git config --global user.name \u0026#34;Your Name\u0026#34; git config --global user.email \u0026#34;email@example.com\u0026#34; JetBrains\nIntelliJ IDEA : Java GoLand : Go Dataflare : DB GUI ツール\nDocker 完全に Docker 中毒。\nインストール： https://docs.docker.com/desktop/install/windows-install/ エラー：WSL Update Failed → WSL 最新版をインストール → 再起動\n参考：\nhttps://forums.docker.com/t/wsl-update-failed/140473/3 https://github.com/docker/for-win/issues/13845 https://github.com/docker/for-win/issues/13580#issuecomment-1619667316 MySQL：\n1 docker pull mysql:5.7 環境変数 MYSQL_ROOT_PASSWORD を指定して起動。\nブログ環境（Jekyll） 自分のブログは Jekyll ベース。 Ruby や Node.js を使うからセットアップ面倒くさい。\n必要なツール：\nRuby: https://www.ruby-lang.org/en/downloads/ RubyGems: https://rubygems.org/pages/download Node.js: https://nodejs.org/zh-cn 1 2 gem install jekyll bundle でもいくつかの gem がどうしてもインストールできなかった…… 最終的に Docker で動かすのが正解だった。\nVS Code に Dev Containers extension を入れて、 F1 → Dev Containers: Clone Repository in Container Volume... で Git リポジトリをクローンして使う\nコンテナ内で以下を実行：\n1 2 3 4 5 sudo apt-get update sudo apt-get install ruby-full build-essential sudo gem install jekyll bundler sudo apt install nodejs sudo bundle 1 bundle exec jekyll s VS Code 経由で直接表示できる。Docker、マジ最高。\n参考：\nhttps://jekyllcn.com/docs/installation/ https://jekyllrb.com/docs/installation/windows/#installation-via-bash-on-windows-10 https://code.visualstudio.com/docs/devcontainers/containers#_quick-start-open-a-git-repository-or-github-pr-in-an-isolated-container-volume おわりに 今のところ必要なのはこのくらいかな。 使わなくなったソフトや頻度の低いやつはもう省いた。 また次回の装機タイミングでは内容が変わってるかもね。おつかれ自分。\n","date":"2024-10-02T21:35:24+08:00","permalink":"https://blog.yexca.net/ja/archives/182/","title":"2024年 PC再インストール記録"},{"content":" 📢 この記事は gemini-2.5-flash によって翻訳されました 記事は2022.11.30に書いたよ。もうこのパネルもCuteOneも使ってないから、最新の状況には合ってないし、再現できないかもしれない。\nそれに、当時記事は書ききってなかったんだ。僕にはもう関連するニーズがないから、ただの記録ね。\n構築手順 参考にした記事は2つあるよ。\n宝塔パネルのPythonプロジェクトマネージャーでCuteOneをインストール – OneDriveマルチドライブマウントプログラム - 大鳥ブログ (daniao.org) CuteOneで個人用クラウドストレージを構築する完全ガイド！_将暮のブログ-CSDNブログ 1つ目の記事の通りにPythonプロジェクトマネージャーでデプロイしてみたんだけど、なぜかうまく動かなくて。それで2つ目の記事を見つけたら、これがすごく詳しくてね。\n動画がずっとクルクル回って再生できない、画像が表示されない インストールした後、画像が表示されなかったり、動画がずっとクルクル回って再生できなかったりするかもしれないね。\nこれはSSLが原因なんだ。もしSSLじゃないなら、この問題は起きないはずだよ。\nもしSSLを使ってるなら、ここを修正する必要があるよ：\napp\\templates\\themes\\default\\public\\layout.html\n\u0026lt;!-- \u0026lt;meta http-equiv=\u0026quot;Content-Security-Policy\u0026quot; content=\u0026quot;upgrade-insecure-requests\u0026quot; /\u0026gt;--\u0026gt;\nこれを\n\u0026lt;meta http-equiv=\u0026quot;Content-Security-Policy\u0026quot; content=\u0026quot;upgrade-insecure-requests\u0026quot; /\u0026gt;\n修正したら、管理画面のトップにある再起動ボタンを忘れずに押してね。そうしないと反映されないから。\nもしすでに反映されてるなら、再起動は必要ないよ。\nそれか、手動で再起動してもOK。\nSSLに関する問題は、全部この方法で解決できるよ。\n管理画面も同じような状況なら。\n管理画面のファイルパスはこれだよ：\napp\\templates\\admin\\public\\layout.html\nここも同じ行を修正するんだ。\n","date":"2024-09-10T23:06:59+08:00","permalink":"https://blog.yexca.net/ja/archives/181/","title":"宝塔パネルでCuteOneを構築"},{"content":" 📢 この記事は gemini-3-flash-preview によって翻訳されました この記事は 2022年5月9日に書かれたもので、最新のアップデートには対応していないから、今は再現できないかもしれない。もっと新しいプロジェクトを使うのがおすすめだよ。\nOnedriveを使えば、オンラインストレージサイトが作れるんだ。例えば、僕のVRChat用ストレージ（もうなくなっちゃったけど）みたいに、直接ウェブページとして公開したり、画像ホスティングとして使ったりできるよ。\noneindex について Github: https://github.com/avedu/oneindex Onedrive Directory Indexといって、サーバーの容量を圧迫しないし、サーバー側の通信量も使わない。OneDriveのディレクトリを直接リスト表示して、ファイルを直リンクでダウンロードできる優れものなんだ。\n環境 PHP 5.6以上が必要で、curlのサポートを有効にしておく必要があるよ。初心者（僕みたいにね）なら、 宝塔 (BT Panel) を使ってデプロイするのが手軽で便利だと思う。\nあと、宝塔のプライバシー問題が気になるなら、 宝塔純浄版 とかの別バージョンもあるから、自分で調べてインストールしてみてね。\nインストール Githubからリポジトリをダウンロードして、サイトのルートディレクトリにアップロードして解凍しよう。\nそれからサイトにアクセスして、インストールプログラムを開始するよ。\nチェック まずは規約への同意。もし「同意」をクリックして元のページに戻っちゃう場合は、アドレスバーの最後にある \u0026amp;mdui-dialog を削除してEnterを押してみて。\n環境に問題がなければ「次へ」をクリック。\nプログラムのインストール 「アプリIDとシークレットを取得（2ページに分かれて表示されるから保存を忘れずに）」をクリックして、Microsoftアカウントでログインしてね。\n表示された「アプリシークレット」を保存して、「わかった、クイックスタートに戻る」をクリックする。\n注意：このシークレットは一度しか表示されないから、大切に保管してね。\n次に、言語（例えば Python とか）を選んで「Get a client ID」をクリック。表示された Client ID をコピーしよう。\nインストール画面に戻って、「アプリシークレット」と「Client ID」を入力して「次へ」をクリック。\n「アカウントを紐付ける」をクリックして、「承諾」を選べばOK。\nもしエラーが出たら\n「アプリシークレット」と「Client ID」を入力する画面に戻って、 Azure のアプリ登録 を開いてみて。そこに2つアプリがあるはず。\noneindex という名前のアプリを探して、その「アプリケーション (クライアント) ID」をコピーして Client ID に入力してみて。\nもう一つのいらないアプリは消しちゃって大丈夫。\n管理 インストールが終わると、「管理画面」と「サイトを表示」の選択肢が出るよ。\n管理画面に入れば、サイト名やテーマ、管理パスワード（初期パスワードは oneindex）を変更できる。\n管理画面のURLは 君のドメイン/?/admin になるよ。\n擬似静的 (Rewrite) ApacheやNginxのrewrite設定をする（Wordpressの設定をそのまま使えばOK）。\nこれは元の作者の説明（一部修正してるけど）なんだけど、僕は 宝塔 を使ってるから、その設定方法を書いておくね。\n宝塔パネルの「サイト」設定から「擬似静的（URL書き換え）」を選んで、wordpress を選択して保存するだけ。\nそのあと、サイトの管理画面で「擬似静的」にチェックを入れて保存すれば完了。\nこれでURLから ? が消えて、管理画面にも 君のドメイン/admin でアクセスできるようになるよ。\n特殊ファイルで機能を追加 Markdownの書き方はこの記事を参考にしてみてね： Markdownメモ フォルダの下部に説明を追加する:\nOneDriveのフォルダ内に README.md ファイルを作って、Markdown形式で書く。\nフォルダの上部に説明を追加する:\nOneDriveのフォルダ内に HEAD.md ファイルを作って、Markdown形式で書く。\nフォルダにパスワードをかける:\nOneDriveのフォルダ内に .password ファイルを作って、パスワードを書き込む（空欄はダメだよ）。\n直接ウェブページを表示する:\nOneDriveのフォルダ内に index.html ファイルを置くと、ディレクトリ一覧を表示せずに、直接そのページが表示される。 「ファイル表示設定 - 直接出力」を合わせるともっと使いやすくなるよ。\n直接ページを出せるから、そのままウェブサイトとして運用もできるんだ。\n他のファイルは見れるのに、画像だけ404になる場合 これはサーバーソフト (Nginx/Apache) が画像の処理を横取りしちゃってるのが原因。設定を消せば直るよ。\n宝塔を使っている場合はこんな感じ：\n「サイト」の「設定ファイル」から、以下のコードをコメントアウトすればOK。\n1 2 3 4 5 location ~ .*\\.(gif|jpg|jpeg|png|bmp|swf)$ { expires 30d; access_log on; } こんな風に変更してね：\n1 2 3 4 5 #location ~ .*\\.(gif|jpg|jpeg|png|bmp|swf)$ #{ # expires 30d; # access_log on; #} この問題は 部署 OneDrive for business (PHP) 客户端程序 OneIndex 详细教程 - VirCloud\u0026rsquo;s Blog を参考にしたよ。\nコマンドライン機能 PHP CLI モードでのみ動作するよ。\nキャッシュをクリア:\n1 php one.php cache:clear キャッシュを更新:\n1 php one.php cache:refresh トークンを更新:\n1 php one.php token:refresh ファイルをアップロード:\n1 php one.php upload:file ローカルファイル [OneDrive上のパス] フォルダをアップロード:\n1 php one.php upload:folder ローカルフォルダ [OneDrive上のパス] 例：\n1 2 3 4 5 6 7 8 9 10 11 // demo.zip を OneDrive のルートにアップロード php one.php upload:file demo.zip // demo.zip を OneDrive の /test/ フォルダにアップロード php one.php upload:file demo.zip /test/ // demo.zip を OneDrive の /test/ に d.zip という名前でアップロード php one.php upload:file demo.zip /test/d.zip // up/ フォルダを OneDrive の /test/ にアップロード php one.php upload:file up/ /test/ 定期実行 (Cron) [オプション] 推奨設定。必須じゃないけど、バックグラウンドでキャッシュを自動更新しておくと、サイトの表示が速くなるよ。\n1 2 3 4 5 # 1時間ごとにトークンを更新 0 * * * * /phpのパス/php /プログラムのパス/one.php token:refresh # 10分ごとにキャッシュを更新 */10 * * * * /phpのパス/php /プログラムのパス/one.php cache:refresh Dockerでのインストール こっちの TimeBye/oneindex を参考にしてみて。\n","date":"2024-08-27T11:00:24+08:00","permalink":"https://blog.yexca.net/ja/archives/180/","title":"Onedriveでサイト作成 (oneindex)"},{"content":" 📢 この記事は gemini-3-flash-preview によって翻訳されました この記事は 2022年6月9日に書かれたものだよ。もうかなり前からこのパネルや OLAINDEX は使っていないから、最新のアップデートには対応していないし、再現できないかもしれないから注意してね。\n宝塔パネル（BT Panel）の使用はおすすめしないよ\n環境要件 PHP 拡張機能の要件：\nPHP \u0026gt;= 7.4 PHP OpenSSL 拡張 PHP PDO 拡張 PHP Mbstring 拡張 PHP Tokenizer 拡張 PHP XML 拡張 PHP Ctype 拡張 PHP JSON 拡張 PHP BCMath 拡張 PHP Fileinfo 拡張 最低インストール基準： nginx + php\n環境のインストール PHP 宝塔のソフトウェアストア（软件商店）で PHP7.4 を検索してインストールしてね。\nそれから PHP7.4 の 設定 を開いて、 無効化関数（禁用函数） へ移動するよ。\nそこにある proc_open、proc_get_status、putenv の 3 つの関数を削除してね。\ncomposer 宝塔の公式デフォルトでは composer のソースが AliCloud になっているから修正不要だけど、他のバージョンの場合は必要になるかもしれない。\n1 2 3 curl -sS https://getcomposer.org/installer | php mv composer.phar /usr/local/bin/composer composer config -g repo.packagist composer https://mirrors.aliyun.com/composer # ソースを中国国内のものに変更。海外サーバーならこの手順は無視してOK デプロイ 新しいサイトを作成して、PHPバージョン は忘れずに PHP-74 を選んでね。\nサイトのルートディレクトリに入って、ターミナル をクリックして、以下のコマンドを順番に入力していこう。\n1 2 3 4 5 6 7 8 git clone https://github.com/WangNingkai/OLAINDEX.git tmp mv tmp/.git . rm -rf tmp git reset --hard composer install -vvv # ここで composer が正常にインストールされていることを確認して。権限エラーが出る場合は、ユーザーにフル権限を与えるのがおすすめ。 chmod -R 777 storage chown -R www:www * # ここでの www は、サーバーの具体的なユーザーグループに合わせてね composer run install-app (これは自動インストールで、デフォルトでは sqlite にデータを保存するよ) もし 5 番目のステップで fileinfo を無視したい場合は：\n1 2 3 composer install -vvv を以下に変更： composer install -vvv --ignore-platform-req=ext-fileinfo --ignore-platform-req=ext-fileinfo --ignore-platform-req=ext-fileinfo --ignore-platform-req=ext-fileinfo インストールが完了すると、管理者の名前とパスワードが表示されるよ。\n設定 サイト メニューでドメイン名をクリックして、サイトディレクトリ を見つけたら、実行ディレクトリを /public に変更して保存してね。\n偽スタティック（URL書き換え） をクリックして、laravel5 を選択して保存しよう。\n設定ファイル をクリックして：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 ここを： location ~ .*\\.(gif|jpg|jpeg|png|bmp|swf)$ { expires 30d; error_log /dev/null; access_log /dev/null; } location ~ .*\\.(js|css)?$ { expires 12h; error_log /dev/null; access_log /dev/null; } こう変更（コメントアウト）してね： #location ~ .*\\.(gif|jpg|jpeg|png|bmp|swf)$ #{ # expires 30d; # error_log /dev/null; # access_log /dev/null; #} #location ~ .*\\.(js|css)?$ #{ # expires 12h; # error_log /dev/null; # access_log /dev/null; #} 管理画面 ログイン URL は xxx.com/admin だよ（xxx.com は自分のドメインに置き換えてね）。\nデフォルトのアカウントは admin、パスワードは 123456 だよ。\n参考記事 宝塔面板安装OLAINDEX 6.0教程 - 如默星空 OLAINDEX ","date":"2024-08-23T17:14:26+08:00","permalink":"https://blog.yexca.net/ja/archives/179/","title":"宝塔パネルで OLAINDEX を構築する"},{"content":" 📢 この記事は gemini-3-flash-preview によって翻訳されました この記事は 2022.06.12 に書いたもの。公開するつもりはなかったんだけど、内容が比較的まとまっていたから、記念にアップしておくことにしたよ。もうこのパネルも ZFile も使っていないから、最新のアップデートには対応していないし、再現できない可能性もあるから注意してね。\n宝塔パネル（BT Panel）の使用はおすすめしないよ\n依存関係のインストール システムバージョンの確認 1、cat /etc/issue。このコマンドはすべての Linux ディストリビューションで使えるよ。\n1 2 3 [root@S-CentOS home]# cat /etc/issue CentOS release 6.5 (Final) Kernel \\r on an \\m 2、cat /etc/redhat-release。この方法は Redhat 系の Linux にだけ適しているよ：\n1 2 [root@S-CentOS home]# cat /etc/redhat-release CentOS release 6.5 (Final) 3、lsb_release -a。これですべてのバージョン情報をリストアップできるよ：\n1 2 3 [root@S-CentOS ~]# lsb_release -a LSB Version: :base-4.0-amd64:base-4.0-noarch:core-4.0-amd64:core-4.0-noarch:graphics-4.0-amd64:graphics-4.0-noarch:printing-4.0-amd64:printing-4.0-noarch Distributor ID: CentOS システムに合わせてコマンドを入力 1 2 3 4 5 # CentOS システム yum install -y java-1.8.0-openjdk unzip # Debian/Ubuntu システム apt update apt install -y openjdk-8-jre-headless unzip サイトの作成 サイトを作成する。\nサイトのディレクトリに入って、ターミナルを開き、以下のコマンドを入力してね。\n1 2 3 wget https://c.jun6.net/ZFILE/zfile-release.war unzip zfile-release.war \u0026amp;\u0026amp; rm -rf zfile-release.war chmod +x ./bin/*.sh よく使うコマンド サイトディレクトリのターミナルで実行してね。\n1 2 3 ./bin/start.sh # プロジェクトの起動 ./bin/stop.sh # プロジェクトの停止 ./bin/restart.sh # プロジェクトの再起動 ポートの開放 セキュリティ設定で 8080 ポートを開放してね。\nコマンドを入力してプロジェクトを起動した後、IP:8080 にアクセスすればサイトが見れるはずだよ。\nカスタムドメイン HTTPS を有効にしたい場合は、まず証明書を申請してからリバースプロキシを設定してね。\n宝塔パネルのサイト設定から「リバースプロキシ」を見つける。\nターゲット URL は http://IP:8080、送信ドメイン名は $host に設定するよ。\nデプロイがうまくいかない場合 他のバージョンの宝塔を使ったせいで、うまくデプロイできないことがあったんだ。自分で調べた結果、設定ファイルに問題があることがわかった。リバースプロキシの設定ファイルで、元のコードを以下のコードに置き換えてみて。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #PROXY-START/ location ^~ / { proxy_pass http://127.0.0.1:8080; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header REMOTE-HOST $remote_addr; add_header X-Cache $upstream_cache_status; #Set Nginx Cache set $static_fileJA2B5K30 0; if ( $uri ~* \u0026#34;\\.(gif|png|jpg|css|js|woff|woff2)$\u0026#34; ) { set $static_fileJA2B5K30 1; expires 12h; } if ( $static_fileJA2B5K30 = 0 ) { add_header Cache-Control no-cache; } } #PROXY-END/ カスタム設定 設定ファイルのディレクトリは ./WEB-INF/classes/application.yml だよ。\n具体的な設定項目は、 公式ドキュメント - パラメータ設定 を参考にしてね。\n特殊なファイルの変更（表示ファイル） ZFile のデフォルトの表示ファイルは readme.md だけど、多くのサイト構築プログラムでは README.md が使われているよね。\nまた、ZFile の暗号化ファイルはデフォルトで password.txt だけど、oneindex は .password だったりする。ファイル名をいちいち変更するのは正直面倒だよね。\napplication.yml を開いて（ダブルクリックで宝塔内で編集できるよ）、CTRL+F で readme を検索して、以下のコードを見つけてね。\n1 2 3 constant: readme: readme.md password: password.txt これを以下のように変更する：\n1 2 3 constant: readme: README.md password: .password CTRL+S で保存して、再起動コマンドを実行すれば反映されるよ。\n参考記事 宝塔面板部署 ZFile 网盘系统（原创改良版） - 柚子蜜 linux 查看系统信息命令 - konglingbin - 博客园 ","date":"2024-08-16T14:43:25+08:00","permalink":"https://blog.yexca.net/ja/archives/178/","title":"宝塔パネルで ZFile を構築する"},{"content":" 📢 この記事は gemini-3-flash-preview によって翻訳されました 最近サーバーの期限が切れそうだから、VRC BlogをGitHubに移行しようと思ってさ。それでいいテーマがないか探してたんだよね。最初は今使ってるTypechoのテーマがJekyllから移植されたものだったから、それを探してたんだけど、半年前に 検索したときには見つからなくて。最近またHexoにも興味が出てきたから、いろいろ探してたら、前にお気に入りだったArgonのHexo版があることを思い出して、この記事を書くことにしたよ。\n環境 Node.js 10.13以上が必要。12.0以上がおすすめ。\nGitのインストールも必要だよ。\nインストール コマンドを実行：\n1 npm install -g hexo-cli インストールが成功したか確認：\n1 hexo -h 新しいブログを作る インストールしたいフォルダに移動して：\n1 hexo init \u0026lt;folder_name\u0026gt; フォルダに入る：\n1 cd \u0026lt;folder_name\u0026gt; 依存関係をインストール：\n1 npm i 作成が終わったら ./_config を編集して設定できるよ。\nテーマのインストール テーマサイト で好きなテーマを選ぼう。テーマによってインストール方法が違うから、詳しくは各テーマのドキュメントを参考にしてね。\nここではArgonテーマのインストール方法を紹介するよ。\nテーマのクローン まずは ./themes フォルダでテーマのリポジトリをクローンする。\n1 git clone https://github.com/solstice23/hexo-theme-argon.git クローンしたフォルダの名前を argon に変更してね。\nejsレンダラーをインストール：\n1 npm install hexo-renderer-ejs ./_config.yml ファイルの theme を argon に変更しよう。\n設定ファイル ./themes/argon/_config.yml を編集して設定を変えられるよ。\n検索機能の設定 ルートディレクトリで実行：\n1 npm install hexo-generator-search --save それから ./_config.yml にオプションを追加する。\n1 2 3 4 search: path: search.xml field: post content: true 執筆 新しい記事を作成：\n1 hexo new [layout] \u0026lt;title\u0026gt; [layout] はオプションで、内容はこんな感じ：\nLayout 説明 パス post 記事（デフォルト） source/_posts page ページ source draft 下書き source/_drafts 作成できたら記事を書いていこう。\nプレビュー：\n1 hexo s localhost:4000 にアクセスして確認してみてね。\n静的ファイルの生成 コマンドを実行：\n1 hexo generate このコマンドを実行すると差分があるものだけビルドされるんだけど、一度元のファイルを削除してからビルドし直すほうが確実だよ。\n参考記事 https://hexo.io/docs/ https://github.com/solstice23/hexo-theme-argon ","date":"2024-08-09T08:49:53+08:00","permalink":"https://blog.yexca.net/ja/archives/177/","title":"Hexoのインストールと使い方"},{"content":" この記事は Google 翻訳を使用して処理されました\n問題の説明 n クイーン問題は、n 行 n 列のチェス盤に n 個のクイーンを配置し、クイーン同士が攻撃できないようにすることです。ルールは、2 個のクイーンが同じ行、列、または対角線上にないことです（つまり、 、チェスのクイーンの移動範囲）\n問題分析 n クイーン問題を解決するために、次のアイデアが提案されています。\ni 番目のクイーンは i 番目の列に置かれる\n最初のクイーンから始めて、各クイーンについて、対応する行の最初の列から試します（i番目のクイーンはi番目の行に対応します） 配置できる場合は位置を決定し、次のクイーンを検討します 前の女王と衝突する場合は、次の列を考慮する 最後の列を超えた場合は、前のクイーンの位置が再決定されます。\nすべての配置ソリューションが見つかるまでこのプロセスを繰り返します。\nC コード 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;math.h\u0026gt; #define N 4 // クイーンの数 // k 番目のクイーンの現在の位置が前のクイーンと競合するかどうかを判定する int isplace(int pos[], int k){ int i; for(i=1; i\u0026lt;k; i++){ if(pos[i]==pos[k] || fabs(i-k) == fabs(pos[i]-pos[k])) return 0; } return 1; } int main(){ int i,j; int count = 1; int pos[N+1]; // 初期化の位置 for(i=1;i\u0026lt;=N;i++) pos[i]=0; j = 1; while(j\u0026gt;=1){ pos[j]=pos[j]+1; // i 番目のクイーンを配置してみて while(pos[j]\u0026lt;=N \u0026amp;\u0026amp; !isplace(pos,j)){ pos[j]=pos[j]+1; // 配置計画を取得する } if(pos[j]\u0026lt;=N \u0026amp;\u0026amp; j==N){ printf(\u0026#34;方案 %d：\u0026#34;, count++); for(i=1;i\u0026lt;=N;i++) printf(\u0026#34;%d\u0026#34;, pos[i]); printf(\u0026#34;\\n\u0026#34;); } // 次のクイーンを考えてみよう if(pos[j]\u0026lt;=N \u0026amp;\u0026amp; j\u0026lt;N){ j+=1; }else{ // 前のクイーンについて考えるために戻る pos[j]=0; j-=1; } } return 1; } ","date":"2024-07-28T14:26:26+08:00","permalink":"https://blog.yexca.net/ja/archives/176/","title":"n-クイーン問題のアルゴリズム（バックトラッキング）"},{"content":" 📢 この記事は ChatGPT によって翻訳されました はじめに 以前 Typecho を Docker コンテナへ移行したとき、HTTPS を有効化すると管理画面にログインできなくなった。\nHTTPS を無効化すれば正常にアクセスできる。\nDocker 以前の通常構成では問題なかったので、Docker ネットワークのせいかと思ってとりあえず HTTPS を切って編集して、そのまま放置してた。\n今回改めて Typecho を使うことになり、再び同じ症状に遭遇。今後の運用のためにも原因を調査して解決策を記録しておく。\n解決方法 解決方法はめっちゃシンプル。\ndata/config.inc.php の末尾に以下のコードを追加するだけ：\n1 define(\u0026#39;__TYPECHO_SECURE__\u0026#39;, true); これでコンテナを再起動すれば OK。\n原因について 参考記事によると、ユーザーとブラウザ間の通信は HTTPS だけど、Typecho 側 (PHP) が受け取るのは Cloudflare 経由の HTTP リクエスト。 その結果、PHP が HTTP ベースでレスポンスを返してしまい、セッションエラーやログイン不可になるらしい。\n参考記事 Typecho HTTPS 无法登陆后台 ","date":"2024-07-26T22:22:22+08:00","permalink":"https://blog.yexca.net/ja/archives/175/","title":"Typecho で HTTPS 化後に管理画面へログインできない問題"},{"content":" 📢 この記事は gemini-2.5-flash によって翻訳されました ElementUIは、餓了么（Ele.me）チームが開発した、開発者、デザイナー、プロダクトマネージャー向けのVue2.0ベースのデスクトップUIコンポーネントライブラリだよ。\nコンポーネントってのは、ハイパーリンク、ボタン、画像、テーブル、フォーム、ページネーションバーみたいに、ウェブページを構成するパーツのことね。\nVue2.x 公式サイト： 国際版 中国大陸版 Vue3.x 公式サイト： https://element-plus.org/zh-CN/#/zh-CN ElementUIのインストール ElementUIライブラリをインストールするよ（現在のプロジェクトディレクトリで）。コマンドはこれ。\n1 npm install element-ui@2.15.3 ElementUIコンポーネントライブラリの読み込み\n1 2 3 4 import ElementUI from \u0026#39;element-ui\u0026#39;; import \u0026#39;element-ui/lib/theme-chalk/index.css\u0026#39;; Vue.use(ElementUI); 入門的な使い方 src/views/element/elementView.vueコンポーネントを作成して、公式サイトからコードをコピーする感じね。例えばこんな風に。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;!-- ボタン --\u0026gt; \u0026lt;el-row\u0026gt; \u0026lt;el-button\u0026gt;デフォルトボタン\u0026lt;/el-button\u0026gt; \u0026lt;el-button type=\u0026#34;primary\u0026#34;\u0026gt;主要ボタン\u0026lt;/el-button\u0026gt; \u0026lt;el-button type=\u0026#34;success\u0026#34;\u0026gt;成功ボタン\u0026lt;/el-button\u0026gt; \u0026lt;el-button type=\u0026#34;info\u0026#34;\u0026gt;情報ボタン\u0026lt;/el-button\u0026gt; \u0026lt;el-button type=\u0026#34;warning\u0026#34;\u0026gt;警告ボタン\u0026lt;/el-button\u0026gt; \u0026lt;el-button type=\u0026#34;danger\u0026#34;\u0026gt;危険ボタン\u0026lt;/el-button\u0026gt; \u0026lt;/el-row\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { } \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; \u0026lt;/style\u0026gt; App.vueでコンポーネントをインポート\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;template\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;element-view\u0026gt;\u0026lt;/element-view\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import elementView from \u0026#39;./views/element/elementView.vue\u0026#39; export default { components: { elementView }, } \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt;\u0026lt;/style\u0026gt; 他のコンポーネントについても、こんな感じだよ。\nAxiosのインポート インストール\n1 npm install axios インポート\n1 import axios from \u0026#39;axios\u0026#39;; Vue ルーティング Vue RouterはVueの公式ルーティングだよ。構成要素はこれね：\nVueRouter：ルータークラスで、ルーティングリクエストに基づいてルーティングビューに選択されたコンポーネントを動的にレンダリングするやつ。 \u0026lt;router-link\u0026gt;：リクエストリンクコンポーネントで、ブラウザがリンクタグとして解析するよ。 \u0026lt;router-view\u0026gt;：動的ビューコンポーネントで、ルーティングに対応するコンポーネントを表示するために使うんだ。 Axiosのインストール コマンド\n1 npm install vue-router@3.5.1 ルーティングの定義 src/router/index.jsで\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import HomeView from \u0026#39;../views/HomeView.vue\u0026#39; const routes = [ { path: \u0026#39;/\u0026#39;, name: \u0026#39;home\u0026#39;, component: HomeView // 上でのインポート方法 }, { path: \u0026#39;/emp\u0026#39;, name: \u0026#39;emp\u0026#39;, // 直接インポートする方法 component: () =\u0026gt; import(\u0026#39;../views/tlias/empView.vue\u0026#39;) }, { path: \u0026#39;/redirect\u0026#39;, // リダイレクト redirect: \u0026#39;/emp\u0026#39; } ] 使い方 使いたい場所で\n1 \u0026lt;router-link to=\u0026#34;/dept\u0026#34;\u0026gt;部署管理\u0026lt;/router-link\u0026gt; App.vueで\n1 2 3 4 5 \u0026lt;template\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;router-view\u0026gt;\u0026lt;/router-view\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; main.jsで\n1 2 3 4 5 6 import router from \u0026#39;./router\u0026#39; new Vue({ router, // ルーティングを使う render: h =\u0026gt; h(App) }).$mount(\u0026#39;#app\u0026#39;) ビルドとデプロイ コマンド\n1 npm run build コマンド実行が終わったらdistディレクトリが生成されるから、そのディレクトリのファイルをデプロイすればOKだよ。\n","date":"2024-06-03T18:04:58+08:00","permalink":"https://blog.yexca.net/ja/archives/174/","title":"ElementUI"},{"content":" 📢 この記事は gemini-2.5-flash によって翻訳されました 昔はフロントエンドとバックエンドが混在した開発だったよね。コミュニケーションコストが高くて、分業もあいまい、管理も保守拡張もやりにくかったんだ。\n今の主流はフロントエンドとバックエンドを分離した開発で、インターフェースドキュメントを使うんだ。\nフロントエンド・バックエンド分離開発 フロントエンドはインターフェースドキュメントに従ってパラメータを送信し、レスポンスデータを解析する。バックエンドはインターフェースドキュメントに従ってパラメータを受け取り、レスポンスを返すってわけ。\n開発フローはこんな感じ：要件分析 -\u0026gt; インターフェース定義 (APIインターフェースドキュメント) -\u0026gt; フロントエンド・バックエンド並行開発 (仕様を遵守) -\u0026gt; テスト -\u0026gt; フロントエンド・バックエンド結合テスト。\nインターフェース開発が終わる前に、 YApi でテストできるよ。\nフロントエンドエンジニアリング 企業規模のフロントエンドプロジェクト開発で、フロントエンド開発に必要なツール、技術、プロセス、経験などを標準化・規範化することだよ。\nモジュール化：JS、CSS コンポーネント化：UI構造、スタイル、振る舞い 規範化：ディレクトリ構造、コーディング、インターフェース 自動化：ビルド、デプロイ、テスト Vue CLI Vue-cliはVue公式が提供してるスキャフォールド（足場）で、Vueプロジェクトのテンプレートをサクッと生成できるんだ。NodeJSが必要だよ。\nVue-cliはこんな機能を提供してるよ：\n統一されたディレクトリ構造 ローカルデバッグ ホットデプロイ：コードを変更しても再実行不要で、最新のプログラムを読み込めるんだ 単体テスト 統合パッケージングとデプロイ NodeJS 公式サイトからインストールして、npmパッケージの場所を設定するんだ。\n1 2 3 npm config set prefix \u0026#34;path\u0026#34; # 位置を取得 npm config get prefix npmのタオバオミラーに切り替えるよ。\n1 npm config set registry https://registry.npm.taobao.org Vue-cliをインストールするよ。\n1 npm install -g @vue/cli ちゃんとインストールできたか確認だ。\n1 vue --version Vueプロジェクト コマンドラインとGUIの2種類があるよ。\n1 2 3 4 # コマンドライン vue create project-name # GUI vue ui ディレクトリ構造 ルートディレクトリ：\nnode_modules：プロジェクト全体の依存パッケージが格納されてる public：プロジェクトの静的ファイル src：プロジェクトのソースコード package.json：モジュールの基本情報、プロジェクト開発に必要なモジュール、バージョン情報 vue.config.js：Vueの設定を保存するファイル。プロキシやポートの設定などだね。 srcフォルダのディレクトリ\nassets：静的リソース components：再利用可能なコンポーネント router：ルーティング設定 views：ビューコンポーネント（ページ） App.vue：エントリページ（ルートコンポーネント） main.js：エントリJSファイル プロジェクトの実行 VS Codeを使えば、下部で直接実行できるよ。\nコマンドラインで実行するならこれ。\n1 npm run serve ポートの変更 vue.config.jsファイルで設定するよ。\n1 2 3 4 5 6 7 const { defineConfig } = require(\u0026#39;@vue/cli-service\u0026#39;) module.exports = defineConfig({ transpileDependencies: true, devServer: { port: 7589 // ポート番号 } }) 開発フロー エントリファイルは src/main.js で、デフォルトはこんな感じだよ。\n1 2 3 4 5 6 7 8 9 10 import Vue from \u0026#39;vue\u0026#39; import App from \u0026#39;./App.vue\u0026#39; import router from \u0026#39;./router\u0026#39; Vue.config.productionTip = false new Vue({ router, render: h =\u0026gt; h(App) // インポートしたAppから仮想要素を作成 }).$mount(\u0026#39;#app\u0026#39;) // #appにマウント 上にある import キーワードはコンポーネントのインポートを意味するんだけど、それと対になる export はコンポーネントのエクスポートを意味するんだ。\n上記のVueオブジェクトのコードはこんな感じにも書けるよ。\n1 2 3 4 5 6 new Vue({ el: \u0026#34;#app\u0026#34;, // router: router, router, // 値とキーが同じなら省略可能 render: h =\u0026gt; h(App) }) Vueのコンポーネントファイルは .vue で終わるんだけど、各コンポーネントは \u0026lt;template、script、\u0026lt;style\u0026gt; の3つの部分で構成されてるんだ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;!-- HTMLタグ --\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; // JS export default{ data(){ return{ // データモデル } }, methods:{ // メソッド } } \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; /* CSS */ \u0026lt;/style\u0026gt; ","date":"2024-05-28T16:22:15+08:00","permalink":"https://blog.yexca.net/ja/archives/173/","title":"シンプルなVueプロジェクト"},{"content":"導入 卒業論文は面倒くさいな、この記事はいつか書いたのでしょうか。ファイルは 2023-11-30 に作成されたけど、2022.09.18 に変更されて、わからなくて、ショックを受けた\nコード 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 \u0026lt;script\u0026gt; function secondToDate(second) { if (!second) { return 0; } var time = new Array(0, 0, 0, 0, 0); if (second \u0026gt;= 365 * 24 * 3600) { time[0] = parseInt(second / (365 * 24 * 3600)); second %= 365 * 24 * 3600; } if (second \u0026gt;= 24 * 3600) { time[1] = parseInt(second / (24 * 3600)); second %= 24 * 3600; } if (second \u0026gt;= 3600) { time[2] = parseInt(second / 3600); second %= 3600; } if (second \u0026gt;= 60) { time[3] = parseInt(second / 60); second %= 60; } if (second \u0026gt; 0) { time[4] = second; } return time; }\u0026lt;/script\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; language=\u0026#34;javascript\u0026#34;\u0026gt; function setTime() { var create_time = Math.round(new Date(Date.UTC(2021, 11, 06, 14, 15, 19)).getTime() / 1000); var timestamp = Math.round((new Date().getTime() + 8 * 60 * 60 * 1000) / 1000); currentTime = secondToDate((timestamp - create_time)); currentTimeHtml = \u0026#39;This Blog has running: \u0026lt;br/\u0026gt;\u0026#39; + currentTime[0] + \u0026#39; y \u0026#39; + currentTime[1] + \u0026#39; d \u0026#39; + currentTime[2] + \u0026#39; h \u0026#39; + currentTime[3] + \u0026#39; m \u0026#39; + currentTime[4] + \u0026#39; s\u0026#39;; document.getElementById(\u0026#34;htmer_time\u0026#34;).innerHTML = currentTimeHtml; } setInterval(setTime, 1000); \u0026lt;/script\u0026gt; 呼び出し 使いたいところで以下のコードを入れる\n1 \u0026lt;span id=\u0026#34;htmer_time\u0026#34; style=\u0026#34;color: pink;\u0026#34; /\u0026gt; 参考資料 个人博客添加运行时间 - 腾讯云开发者社区-腾讯云 ","date":"2024-05-14T11:08:25+08:00","permalink":"https://blog.yexca.net/ja/archives/172/","title":"ブログ実行時間"},{"content":" 📢 この記事は gemini-2.5-flash によって翻訳されました Gateway は、全てのマイクロサービスの統一エントリポイントで、以下の機能があるよ。\n認証と認可のチェック: ゲートウェイはマイクロサービスのエントリポイントとして、ユーザーがリクエストの資格を持っているか確認する必要があるんだ。もしなければ、インターセプトするよ。 リクエストルーティング、ロードバランシング: 全てのリクエストはGatewayを通過する必要があるんだけど、ゲートウェイはビジネスロジックを処理しないんだ。代わりに、特定のルールに基づいてリクエストを特定のマイクロサービスに転送するよ。このプロセスをルーティングって呼ぶんだ。もちろん、ルーティング先のサービスが複数ある場合は、ロードバランシングも必要になるね。 リクエストレートリミット: リクエストトラフィックが高すぎる場合、ゲートウェイでダウンストリームのマイクロサービスが受け入れられる速度に合わせてリクエストを許可し、サービスの負荷が過大になるのを防ぐよ。 SpringCloud のゲートウェイ実装は2種類あるんだ。\nZuul: Servlet ベースの実装で、ブロッキングプログラミングに属するよ。 SpringCloudGateway: Spring5 で提供される WebFlux ベースで、リアクティブプログラミングの実装に属し、より良いパフォーマンスを持ってるんだ。 簡単入門 プロジェクトを作って、依存関係を追加しよう。\n1 2 3 4 5 6 7 8 9 10 \u0026lt;!--ゲートウェイ--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-gateway\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--nacosサービスディスカバリ依存--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-alibaba-nacos-discovery\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 基本設定とルーティングルールを書こう。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 server: port: 10010 # ゲートウェイポート spring: application: name: gateway # サービス名 cloud: nacos: server-addr: localhost:8848 # nacosアドレス gateway: routes: # ゲートウェイルーティング設定 - id: user-service # ルーティングID、カスタムで、ユニークならOK # uri: http://127.0.0.1:8081 # ルーティングのターゲットアドレス httpは固定アドレス uri: lb://userService # ルーティングのターゲットアドレス lbはロードバランシング、その後にサービス名 predicates: # ルーティングアサーション、つまりリクエストがルーティングルールに合致するかの条件を判断するよ - Path=/user/** # これはパスによるマッチングで、/user/ で始まっていればOK そしたら \u0026lt;localhost:10010/user/1\u0026gt; にアクセスしてテストしてみてね。\nルーティング設定には、以下が含まれるよ。\nルーティングID: ルーティングの一意な識別子 ルーティングターゲット (uri): ルーティングのターゲットアドレス。http は固定アドレスを、lb はサービス名に基づくロードバランシングを表すよ。 ルーティングアサーション (predicates): ルーティングのルールを判断するもので、合致すればルーティング先に転送されるよ。 ルーティングフィルター (filters): リクエストやレスポンスを処理するよ。 アサーションファクトリ 設定ファイルに書いたアサーションルールはただの文字列で、これらの文字列は Predicate Factory によって読み込まれて処理され、ルーティング判断の条件に変換されるんだ。\n例えば、上記の例の Path=/user/** はパスによるマッチングで、このルールは org.springframework.cloud.gateway.handler.predicate.PathRoutePredicateFactory クラスで処理されるよ。似たようなアサーションファクトリにはこんなのがあるんだ。\n名前 説明 例 After 特定の時刻以降のリクエスト - After=2037-01-20T17:42:47.789-07:00[America/Denver] Before 特定の時刻以前のリクエスト - Before=2031-04-13T15:14:47.433+08:00[Asia/Shanghai] Between 2つの時刻の間のリクエスト - Between=2037-01-20T17:42:47.789-07:00[America/Denver], 2037-01-21T17:42:47.789-07:00[America/Denver] Cookie 特定のクッキーを含むリクエスト - Cookie=chocolate, ch.p Header 特定のヘッダーを含むリクエスト - Header=X-Request-Id, \\d+ Host 特定のホスト（ドメイン）へのリクエスト - Host=.somehost.org,.anotherhost.org Method 指定されたリクエストメソッド - Method=GET,POST Path 指定されたルールに合致するリクエストパス - Path=/red/{segment},/blue/** Query 指定されたパラメータを含むリクエスト - Query=name, Jackまたは- Query=name RemoteAddr 指定された範囲内のリクエスト元IP - RemoteAddr=192.168.1.1/24 Weight 重み付け処理 フィルターファクトリ GatewayFilter は、ゲートウェイで提供される一種のフィルターで、ゲートウェイに入ってくるリクエストやマイクロサービスから返されるレスポンスを処理できるよ。\nSpring は31種類の異なるルートフィルターファクトリを提供しているんだ。例えばこんな感じ。\n名前 説明 AddRequestHeader 現在のリクエストにリクエストヘッダーを追加する RemoveRequestHeader リクエストからリクエストヘッダーを削除する AddResponseHeader レスポンス結果にレスポンスヘッダーを追加する RemoveResponseHeader レスポンス結果からレスポンスヘッダーを削除する RequestRateLimiter リクエストのトラフィックを制限する 詳しい情報はここを参考にしてね： https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway/gatewayfilter-factories.html リクエストヘッダーフィルター リクエストヘッダーフィルターを例にとると、userService に入る全てのリクエストに \u0026lsquo;Hello=World\u0026rsquo; というリクエストヘッダーを追加するよ。\ngateway の application.yml を修正して、ルーティングフィルターを追加するんだ。\n1 2 3 4 5 6 7 8 9 10 spring: cloud: gateway: routes: - id: user-service uri: lb://userservice predicates: - Path=/user/** filters: # フィルター - AddRequestHeader=Hello, World # リクエストヘッダーを追加 そしたら Controller を修正してテストできるよ。\n1 2 3 4 5 @GetMapping(\u0026#34;/{id}\u0026#34;) public User queryById(@PathVariable(\u0026#34;id\u0026#34;) Long id, @RequestHeader(\u0026#34;Hello\u0026#34;) String hello) { System.out.println(hello); return userService.queryById(id); } デフォルトフィルター もし全てのルートに効果を適用したいなら、フィルターファクトリを default の下に書けばいいよ。\n1 2 3 4 5 6 7 8 9 10 spring: cloud: gateway: routes: - id: user-service uri: lb://userservice predicates: - Path=/user/** default-filters: # デフォルトフィルター項目 - AddRequestHeader=Hello, World グローバルフィルター ゲートウェイには31種類のフィルターが提供されているけど、それぞれのフィルターの役割は固定されてるんだ。もしリクエストをインターセプトして、独自のビジネスロジックを実装したい場合は、そのままじゃ実現できないんだよね。\n一方、グローバルフィルターもゲートウェイに入る全てのリクエストとマイクロサービスのレスポンスを処理する役割があって、GatewayFilter と同じだよ。違いは、GatewayFilter が設定を通じて定義され、処理ロジックが固定されているのに対して、GlobalFilter のロジックは自分でコードを書いて実装する必要があるってこと。GlobalFilter インターフェースを実装することで定義するんだ。\n1 2 3 4 5 6 7 8 9 10 public interface GlobalFilter { /** * 現在のリクエストを処理し、必要であれば {@link GatewayFilterChain} を通じて次のフィルターにリクエストを渡す * * @param exchange リクエストコンテキスト。ここからRequestやResponseなどの情報を取得できる * @param chain リクエストを次のフィルターに委譲するために使う * @return {@code Mono\u0026lt;Void\u0026gt;} 現在のフィルターのビジネス処理が終了したことを示す */ Mono\u0026lt;Void\u0026gt; filter(ServerWebExchange exchange, GatewayFilterChain chain); } filter でカスタムロジックを書くことで、以下の機能を実装できるよ。\nログイン状態の判断 権限のチェック リクエストレートリミットなど 簡単な使い方 目標：グローバルフィルターを定義して、リクエストをインターセプトし、リクエストのパラメータが以下の条件を満たしているか判断するよ。\nパラメータに authorization が含まれているか authorization パラメータの値が admin であるか もし両方満たしていれば通過させて、そうでなければインターセプトするよ。\nまず gateway でフィルターを定義するよ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 @Order(-1) // 優先的に処理 @Component public class AuthorizeFilter implements GlobalFilter { @Override public Mono\u0026lt;Void\u0026gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) { // リクエストパラメータを取得 MultiValueMap\u0026lt;String, String\u0026gt; params = exchange.getRequest().getQueryParams(); // AuthorizeFilterパラメータを取得、ここでは最初のものが認証パラメータと約束 String authorize = params.getFirst(\u0026#34;AuthorizeFilter\u0026#34;); // チェック if(\u0026#34;admin\u0026#34;.equals(authorize)){ // 通過 return chain.filter(exchange); } // インターセプト、アクセス禁止 exchange.getResponse().setStatusCode(HttpStatus.FORBIDDEN); // 処理終了 return exchange.getResponse().setComplete(); } } フィルターの実行順序 リクエストがゲートウェイに入ると、3種類のフィルターに出会うよ。現在のルートのフィルター、DefaultFilter、GlobalFilterだね。\nリクエストがルーティングされた後、現在のルートフィルターと DefaultFilter、GlobalFilter は1つのフィルターチェーン（コレクション）にマージされて、ソートされた後に各フィルターが順番に実行されるんだ。\n各フィルターには int 型の order 値があって、order 値が小さいほど優先度が高く、実行順序も前になるよ。\nルートフィルターと defaultFilter の order 値は Spring によって指定されて、デフォルトでは1からインクリメントされるんだ。\nGlobalFilter は Ordered インターフェースを実装するか、または @Order アノテーションを追加することで order 値を指定できるよ。これは自分たちで指定するんだ。\nフィルターの order 値が同じ場合、defaultFilter \u0026gt; ルートフィルター \u0026gt; GlobalFilter の順序で実行されるよ。\nその中でインターフェースを実装して order 値を指定する方法はこれだね。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 //@Order(-1) // 優先的に処理 @Component public class AuthorizeFilter implements GlobalFilter, Ordered { @Override public Mono\u0026lt;Void\u0026gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) { // リクエストパラメータを取得 MultiValueMap\u0026lt;String, String\u0026gt; params = exchange.getRequest().getQueryParams(); // AuthorizeFilterパラメータを取得、ここでは最初のものが認証パラメータと約束 String authorize = params.getFirst(\u0026#34;AuthorizeFilter\u0026#34;); // チェック if(\u0026#34;admin\u0026#34;.equals(authorize)){ // 通過 return chain.filter(exchange); } // インターセプト、アクセス禁止 exchange.getResponse().setStatusCode(HttpStatus.FORBIDDEN); // 処理終了 return exchange.getResponse().setComplete(); } @Override public int getOrder() { return -1; } } クロスドメイン問題 同一オリジンとは、プロトコルが同じ、IPまたはドメインが同じ、ポートが同じことを指すよ。\nクロスドメイン問題：ブラウザがリクエストの発信元がサーバーとクロスドメインのAjaxリクエストを発生させるのを禁止し、リクエストがブラウザによってインターセプトされる問題のこと。その解決策は CORS だよ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 spring: cloud: gateway: globalcors: # グローバルなクロスドメイン処理 add-to-simple-url-handler-mapping: true # optionsリクエストがインターセプトされる問題を解決 corsConfigurations: \u0026#39;[/**]\u0026#39;: allowedOrigins: # どのサイトからのクロスドメインリクエストを許可するか - \u0026#34;http://localhost:8090\u0026#34; allowedMethods: # 許可されるクロスドメインAjaxのリクエストメソッド - \u0026#34;GET\u0026#34; - \u0026#34;POST\u0026#34; - \u0026#34;DELETE\u0026#34; - \u0026#34;PUT\u0026#34; - \u0026#34;OPTIONS\u0026#34; allowedHeaders: \u0026#34;*\u0026#34; # リクエストに含めることが許可されるヘッダー情報 allowCredentials: true # クッキーの持ち運びを許可するかどうか maxAge: 360000 # このクロスドメイン検出の有効期間 ","date":"2024-05-05T00:54:52+08:00","permalink":"https://blog.yexca.net/ja/archives/171/","title":"Gateway サービスゲートウェイ"},{"content":" 📢 この記事は gemini-3-flash-preview によって翻訳されました Feignは宣言的な Http クライアントだよ。Githubはこちら： https://github.com/OpenFeign/feign 簡単な使い方 依存関係を導入するよ。\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-openfeign\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 起動クラスにアノテーションを追加して、Feign の機能を有効にするよ。\n1 2 @EnableFeignClients @SpringBootApplication Feign クライアントを書くよ。\n1 2 3 4 5 @FeignClient(\u0026#34;userService\u0026#34;) public interface UserClient { @GetMapping(\u0026#34;/user/{id}\u0026#34;) User findById(@PathVariable(\u0026#34;id\u0026#34;) Long id); } RestTemplate を置き換えるよ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 @Service public class OrderService { @Autowired private OrderMapper orderMapper; // @Autowired // private RestTemplate restTemplate; @Autowired private UserClient userClient; public Order queryOrderById(Long orderId) { // 1.注文を検索 Order order = orderMapper.findById(orderId); // 2.ユーザーを検索 // String url = \u0026#34;http://localhost:8081/user/\u0026#34; + order.getUserId(); // String url = \u0026#34;http://userService/user/\u0026#34; + order.getUserId(); // User user = restTemplate.getForObject(url, User.class); // Feign を使う User user = userClient.findById(order.getUserId()); // 3.ユーザー情報をセット order.setUser(user); // 4.返す return order; } } カスタム設定 Feign はデフォルト設定を上書きするためにカスタム設定ができるんだ。変更できる設定はこんな感じ：\nタイプ 役割 説明 feign.Logger.Level ログレベルの変更 NONE、BASIC、HEADERS、FULL の4つのレベルがあるよ feign.codec.Decoder レスポンス解析器 HTTP呼び出しの結果を解析する。例えばJSON文字列をJavaオブジェクトにするなど feign.codec.Encoder リクエストパラメータ符号化 リクエストパラメータを符号化して、HTTPリクエストで送りやすくする feign. Contract サポートするアノテーション形式 デフォルトは SpringMVC のアノテーション feign. Retryer 失敗時のリトライメカニズム リクエスト失敗時のリトライ。デフォルトはないけど、Ribbonのリトライが使われるよ 普通はログレベルだけ設定すれば十分だよ。ログレベルの種類はこれ：\nNONE：ログを一切記録しない（デフォルト） BASIC：リクエストメソッド、URL、レスポンスステータスコード、実行時間のみ記録 HEADERS：BASICの内容に加えて、リクエストとレスポンスのヘッダー情報も記録 FULL：リクエストとレスポンスの全ての詳細（ヘッダー、ボディ、メタデータ）を記録 設定方法は、設定ファイルを使う方法と Bean を作る方法の2つがあるよ。\n設定ファイル 特定のサービスに対して設定する場合：\n1 2 3 4 5 feign: client: config: userservice: # 特定のマイクロサービス向けの設定 loggerLevel: FULL # ログレベル 全てのサービスに対して設定する場合：\n1 2 3 4 5 feign: client: config: default: # defaultにするとグローバル設定になるよ loggerLevel: FULL # ログレベル Bean まずクラスを定義して、Logger.Level のオブジェクトを宣言するよ。\n1 2 3 4 5 6 public class DefaultFeignConfiguration { @Bean public Logger.Level feignLogLevel(){ return Logger.Level.BASIC; // ログレベルをBASICに設定 } } グローバルに適用したいなら、起動クラスの @EnableFeignClients アノテーションに含めるよ。\n1 @EnableFeignClients(defaultConfiguration = DefaultFeignConfiguration .class) 特定のサービスだけに適用したいなら、@FeignClient アノテーションに含めるよ。\n1 @FeignClient(value = \u0026#34;userService\u0026#34;, configuration = DefaultFeignConfiguration .class) Feign の使用の最適化 Feign の裏側のクライアント実装にはいくつか種類があるんだ：\nURLConnection：デフォルト実装。コネクションプールをサポートしていない。\nApache HttpClient ：コネクションプールをサポート。\nOKHttp：コネクションプールをサポート。\nコネクションプールを使うと Feign のパフォーマンスが上がるよ。\n以下は HttpClient に置き換える例だよ。\n依存関係の導入 1 2 3 4 5 \u0026lt;!-- httpClientの依存関係 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.github.openfeign\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;feign-httpclient\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; コネクションプールの設定 1 2 3 4 5 6 7 8 9 feign: client: config: default: # グローバル設定 loggerLevel: BASIC # ログレベル httpclient: enabled: true # HttpClientのサポートを有効化 max-connections: 200 # 最大接続数 max-connections-per-route: 50 # パスごとの最大接続数 ベストプラクティス ベストプラクティスっていうのは、使っていく中でまとめられた「一番良い使い方の経験則」のことだね。\nFeign のクライアントとサービス提供側の Controller のコードはすごく似ているんだ。\n1 2 3 4 5 6 7 8 9 10 11 12 // Feign クライアント @FeignClient(\u0026#34;userService\u0026#34;) public interface UserClient { @GetMapping(\u0026#34;/user/{id}\u0026#34;) User findById(@PathVariable(\u0026#34;id\u0026#34;) Long id); } // Controller @GetMapping(\u0026#34;/user/{id}\u0026#34;) public User queryById(@PathVariable(\u0026#34;id\u0026#34;) Long id) { return userService.queryById(id); } 重複コードを減らすための、2つの簡略化メソッドを紹介するね。\n方法1：継承 消費側の FeignClient と提供側の Controller で共通の親インターフェースを定義して標準化する方法だよ。\nインターフェースを定義する：\n1 2 3 4 public interface UserAPI{ @GetMapping(\u0026#34;/user/{id}\u0026#34;) User findById(@PathVariable(\u0026#34;id\u0026#34;) Long id); } Feign クライアントの実装：\n1 2 @FeignClient(value=\u0026#34;userService\u0026#34;) public interface UserClient extends UserAPI{} Controller クラス：\n1 2 3 4 5 6 @RestController public class UserController implements UserAPI{ public User findById(@PathVariable(\u0026#34;id\u0026#34;) Long id){ // 処理コード } } メリット：シンプルで、コードを共有できる。\nデメリット：\nサービス提供側と消費側が密結合になる。 引数リストのアノテーションマッピングは継承されないから、Controller でメソッド、引数リスト、アノテーションをもう一度宣言しないといけない。 方法2：切り出し方式 FeignClient を独立したモジュールとして切り出して、インターフェースに関連する POJO やデフォルトの Feign 設定もそのモジュールに入れて、全ての消費者が使えるようにする方法だよ。\n新しいプロジェクトを作成して、Feign のスターター依存関係を導入するよ。\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-openfeign\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 消費側で feign-api の依存関係を導入する。\n定義した FeignClient が SpringBootApplication のスキャン対象外にある場合、そのままでは使えないんだ。解決策は2つあるよ。\nFeign がスキャンすべきパッケージを指定する 1 @EnableFeignClients(basePackages = \u0026#34;net.yexca.feign.clients\u0026#34;) ロードする Client インターフェースを個別に指定する 1 @EnableFeignClients(clients = {UserClient.class}) ","date":"2024-05-03T23:11:52+08:00","permalink":"https://blog.yexca.net/ja/archives/170/","title":"Feignでのリモート呼び出し"},{"content":"まずソフトウェアをインストールする必要があります。公式ウェブサイト (英語): https://nacos.io/en/ ポートは conf/application.properties ファイルで変更できます。デフォルトは 8848 です。\nサービスに登録する 親プロジェクトに管理依存関係を追加する\n1 2 3 4 5 6 7 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-alibaba-dependencies\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.6.RELEASE\u0026lt;/version\u0026gt; \u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt; \u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; Eureka の依存関係をコメントアウトし、Nacos クライアントの依存関係を追加します。\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-alibaba-nacos-discovery\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; application.yml を修正し、Nacos アドレスを追加し、Eureka アドレスをコメントします。\n1 2 3 4 spring: cloud: nacos: server-addr: localhost:8848 Nacos を始める\n1 2 startup.cmd -m standalone # 単一マシンの起動パラメータ http://localhost:8848/nacos/ にアクセスすると、ログイン アカウントとパスワードは両方とも nacos になります。\n階層型ストレージモデル サービスは複数のクラスターに分割され、各クラスターには複数のインスタンスがあり、クラスターはリージョンごとに割り当てられ、アクセス速度が向上します。\n対照的に、Eureka にはサービスインスタンスのみがあり、クラスターはありません。\nサービスを呼び出すときは、クラスター間の呼び出しの方が待機時間が長くなるため、可能な限りローカル クラスター内のサービスを選択してください。ローカルクラスタにアクセスできない場合は、他のクラスタにアクセスする\napplication.yml でクラスタを設定できます\n1 2 3 4 5 6 spring: cloud: nacos: server-addr: localhost:8848 discovery: cluster-name: Shanghai # クラスター名 次に Ribbon 戦略を Nacos に設定する\n1 2 3 4 5 # マイクロサービスの負荷分散ルールを設定します。ここでは userService サービスです。 userService: ribbon: NFLoadBalancerRuleClassName: com.alibaba.cloud.nacos.ribbon.NacosRule # NFLoadBalancerRuleClassName: com.netflix.loadbalancer.Nac # 負荷分散ルール 次に、Nacos でインスタンスの重み (0-1) を設定できます。重みが大きいほど、アクセス頻度が高くなります。\n環境隔離 Nacos のサービスストレージとデータストレージの最外層は、名前空間と呼ばれるもので、最外層の分離に使用されます。\nNacos に dev などの新しい名前空間を作成し、application.yml を修正することができます。\n1 2 3 4 5 6 7 spring: cloud: nacos: server-addr: localhost:8848 discovery: cluster-name: Shanghai # クラスター名 namespace: UUID # 名前空間のUUIDは次のとおりです 異なる名前空間内のサービスは相互に表示されず、アクセスできません。\n一時インスタンスと非一時インスタンス 一時的なインスタンスの場合、Nacos は Eukera と同じ方法で処理します。\n一時的でないインスタンスの場合、Nacos はアクティブにインスタンスが稼働中かどうかを問い合わせます。サービスが利用できない場合は削除されません。サービスが利用できない場合、Nacos は積極的に消費者に通知します。\n非一時的インスタンスの設定\n1 2 3 4 5 spring: cloud: nacos: discovery: ephemeral: false # 非一時インスタンスとして設定 Nacos 構成管理 マイクロサービスのデプロイインスタンスが増えると、一つ一つ構成を変更するのは非常に面倒です。Nacos を使用すると、構成を一元管理し、ホットアップデートを行うことができます。\nシンプルな使い方 Nacos コンソールの設定管理で、新しい設定を作成します。ここで、Data ID は、[サービス名]-[プロファイル].[サフィックス名] の形式の設定ファイルの ID です (例: userService-dev.yaml)。\n次に、設定コンテンツに設定を記述します。たとえば、\n1 2 pattern: dateformat: yyyy-MM-dd HH:mm:ss Nacos 構成管理クライアント依存関係の紹介\n1 2 3 4 5 \u0026lt;!--nacos 構成管理依存関係--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-alibaba-nacos-config\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 取得を構成する手順\nプロジェクトの起動 -\u0026gt; bootstrap.yml -\u0026gt; Nacos 構成ファイル -\u0026gt; ローカル application.yml -\u0026gt; Spring コンテナの作成 -\u0026gt; Bean のロード\nbootstrap.yml を追加する\n1 2 3 4 5 6 7 8 9 10 spring: application: name: userService # サービス名 profiles: active: dev # 開発環境、こちらが dev です cloud: nacos: server-addr: localhost:8848 # Nacos住所 config: file-extension: yaml # ファイル拡張子 テスト\n1 2 3 4 5 6 7 8 9 10 11 12 @RestController @RequestMapping(\u0026#34;/user\u0026#34;) public class UserController{ @Value(\u0026#34;${pattern.dateformat}\u0026#34;) private String dateformat; @GetMapping(\u0026#34;/now\u0026#34;) public String now(){ return LocalDateTime.now().format(DateTimeFormatter.ofPattern(dateformat)) } } 効果を確認するにはページをご覧ください\nホットアップデート これは2つの方法で達成できる\n方法1: @Value によって注入された変数が配置されているクラスにアノテーション @RefreshScope を追加する\n1 2 3 4 5 6 7 8 9 10 11 12 13 @RefreshScope // 自動更新の設定 @RestController @RequestMapping(\u0026#34;/user\u0026#34;) public class UserController{ @Value(\u0026#34;${pattern.dateformat}\u0026#34;) private String dateformat; @GetMapping(\u0026#34;/now\u0026#34;) public String now(){ return LocalDateTime.now().format(DateTimeFormatter.ofPattern(dateformat)) } } 方法 2: @ConfigurationProperties を使用する\n新しい構成クラスを作成する\n1 2 3 4 5 6 @Component @Data @ConfigurationProperties(prefix = \u0026#34;pattern\u0026#34;) public class PatternProperties { private String dateformat; } Controller クラス\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // @RefreshScope // 自動更新の設定 @RestController @RequestMapping(\u0026#34;/user\u0026#34;) public class UserController{ // @Value(\u0026#34;${pattern.dateformat}\u0026#34;) // private String dateformat; @Autowired private PatternProperties properties; @GetMapping(\u0026#34;/now\u0026#34;) public String now(){ return LocalDateTime.now().format(DateTimeFormatter.ofPattern(properties.getDateformat())) } } 共有の構成 マイクロサービスが起動すると、Nacos から複数の設定ファイルを読み取ります。\n[spring.application.name]-[spring.profiles.active].yaml，例えば：userService-dev.yaml\n[spring.application.name].yaml，例えば：userService.yaml\n2番目の [spring.application.name].yaml には環境が含まれていないため、複数の環境で共有できます。\n設定の優先順位: [spring.application.name]-[spring.profiles.active].yaml \u0026gt; [spring.application.name].yaml \u0026gt; ローカル設定\n","date":"2024-05-02T22:36:17+08:00","permalink":"https://blog.yexca.net/ja/archives/169/","title":"Nacos 登録センター"},{"content":"コンシューマによって開始されたリクエストはリボンによってインターセプトされ、リボンはユーレカからプロバイダリストを取得し、ユーレカはプロバイダリストを返し、リボンはIRuleに基づいてリクエストを開始するサーバを選択します。\n詳細なインターセプション: リクエスト -\u0026gt; DynamicServerListLoadBalancer (URL 内のサービス ID、userService を取得) -\u0026gt; DynamicServerListLoadBalancer -\u0026gt; Eureka -\u0026gt; DynamicServerListLoadBalancer -\u0026gt; IRule -\u0026gt; DynamicServerListLoadBalancer -\u0026gt; リクエストの開始\n負荷分散戦略 組み込みの負荷分散ルールクラス ルールの説明 ZoneAvoidanceRule(Eureka 默认) サーバーの選択は、その地域で利用可能なサーバーに基づいて行われます。ゾーンを使用してサーバーを分類します。このゾーンは、コンピューター ルーム、ラックなどとして理解できます。次にゾーン内の複数のサービスをポーリングします RoundRobinRule サービス リストをポーリングするだけでサーバーを選択できます。これはリボンのデフォルトの負荷分散ルールです AvailabilityFilteringRule 次の 2 種類のサーバーは無視されます: (1) デフォルトでは、このサーバーへの接続が 3 回失敗すると、サーバーは「短絡」状態に設定されます。短絡状態は30秒間続きます。接続が再度失敗すると、短絡の持続時間は指数関数的に増加します。 (2) 同時接続数が多すぎるサーバー。サーバーへの同時接続数が多すぎる場合、AvailabilityFilteringRule ルールが設定されたクライアントもそれを無視します。同時接続の上限は、クライアントの\u0026lt;clientName\u0026gt;.\u0026lt;clientConfigNameSpace\u0026gt;.ActiveConnectionsLimitプロパティで設定できます。 WeightedResponseTimeRule 各サーバーに重み値を割り当てます。サーバーの応答時間が長くなるほど、このサーバーの重みは小さくなります。このルールはサーバーをランダムに選択します。この重み値はサーバーの選択に影響します。 BestAvailableRule 短絡したサーバーを無視し、同時実行性の低いサーバーを選択する RandomRule 利用可能なサーバーをランダムに選択 RetryRule 再試行メカニズムの選択ロジック ランダム戦略の使用 負荷分散ルールは、次の 2 つの方法で IRule 実装を定義することによって変更できます。\nコードメソッド: 構成クラスで、新しい IRule（グローバル設定）を定義します。 1 2 3 4 @Bean public IRule randomRule(){ return new RandomRule(); } 設定ファイル方式: orderServer application.yml ファイルで、ルールを変更するための新しい設定を追加します。 1 2 3 userService: # マイクロサービスの負荷分散ルールを設定します。ここでは userservice サービスです ribbon: NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule # 負荷分散ルール 遅延読み込み Ribbon はデフォルトで遅延読み込みを使用します。つまり、初めてアクセスされたときにのみ LoadBalanceClient が作成され、要求時間が非常に長くなります。プロジェクトの開始時にハングリー読み込みが作成され、最初のアクセスの時間消費が短縮されます。ハングリー読み込みを有効にするには、次のように構成します。\n1 2 3 4 ribbon: eager-load: enabled: true clients: userService # userService サービスのハングリーロードを指定します ","date":"2024-04-28T15:50:15+08:00","permalink":"https://blog.yexca.net/ja/archives/168/","title":"Ribbon 負荷分散"},{"content":" 📢 この記事は gemini-2.5-flash によって翻訳されました 表示モード 表示モードっていうのは、タグの表示方法のことだよ。ウェブページをレイアウトするとき、タグの表示モードに合わせて、適切なタグを選んでコンテンツを配置するんだ。\nブロックレベル要素 (例えば div) 1行を占有する 幅はデフォルトで親要素の100%になる 幅と高さのプロパティを追加すると有効になる インライン要素 (例えば span) 1行に複数表示できる 幅と高さのプロパティを設定しても効かない 幅と高さのサイズはコンテンツによって決まる インラインブロック要素 (例えば img) 1行に複数表示できる 幅と高さのプロパティを設定すると有効になる 幅と高さのサイズもコンテンツによって決まる CSSの display プロパティで表示モードを切り替えられるんだ。値はこれね。\n効果 ブロック インライン インラインブロック プロパティ値 block inline inline-block ボックスモデル 役割：ウェブページをレイアウトしたり、ボックスやコンテンツを配置したりする。\nボックスモデルの構成要素：\nコンテンツ領域：width \u0026amp; height パディング (内側の余白)：padding (コンテンツとボックスの端の間に現れる) ボーダー (境界線)：border マージン (外側の余白)：margin (ボックスの外側に現れる) ボーダー (境界線) プロパティ値：線の太さ 線のスタイル 色 順序は問わないよ。\nよくある線のスタイルはこれらね。\n線のスタイル 実線 破線 点線 プロパティ値 solid dashed dotted 1 2 3 div { border: 1px solid aqua; } もちろん、個別方向を設定できるプロパティもあるよ。プロパティ値は上と同じ。\n1 2 3 4 5 6 div { border-top: 1px solid red; border-left: 1px dashed red; border-bottom: 1px dotted red; border-right: 1px solid blue; } パディング (内側の余白) コンテンツとボックスの端の間の距離を設定する。\n1 2 3 4 5 6 7 8 9 10 11 12 /* 四方向のパディングが同じ */ div { padding: 10px; } /* 個別に四方向を設定 */ div { padding-top: 10px; padding-right: 20px; padding-bottom: 5px; padding-left: 10px; } padding にも複数値の書き方があって、1つのプロパティで4つのパディングを制御できるよ。\n値の数 例 意味 一つ padding: 10px; 四方向すべて10px 四つ padding: 10px 20px 30px 40px; 上 右 下 左 (時計回り) 二つ padding: 10px 30px 20px; 上 左右 下 三つ padding: 10px 20px; 上下 左右 サイズ内減モード デフォルトだと、ボックスのサイズは「コンテンツサイズ + パディングサイズ + ボーダーサイズ」になるんだ。つまり、ボックスに padding や border プロパティを追加すると、ボックスが大きくなっちゃう。\n1 2 3 4 5 6 div { height: 200px; width: 200px; /* このボックスのサイズは240*240になる */ padding: 20px; } もしボックスのサイズを200*200にしたいなら、手動で計算して height と width の値を160pxに調整する必要があるんだ。\nでも box-sizing: border-box を追加すると、ボックスのサイズは height と width の値のまま維持されるようになるよ。\n1 2 3 4 5 6 7 div { height: 200px; width: 200px; /* このボックスのサイズは200*200になる */ padding: 20px; box-sizing: border-box; } マージン (外側の余白) 役割：2つのボックス間の距離を空ける。プロパティ値は padding の書き方と同じだよ。\nマージンはボックスを大きくしない。\nもし margin の左右のプロパティ値を auto に設定すると、そのボックスは水平方向で中央揃えになるよ。\n1 2 3 4 5 6 div { height: 200px; width: 800px; /* このボックスは水平方向で中央揃えになる */ margin: 0 auto; } 相殺現象 (マージンコラプス) 垂直に並んだ同じ階層の要素は、上下のマージンが相殺されて、値は大きい方のマージンが適用されるんだ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;style\u0026gt; .box1 { width: 200px; height: 100px; background-color: aqua; margin-bottom: 10px; } /* 2つのボックスの間に20pxの間隔ができる */ .box2 { width: 100px; height: 100px; background-color: aquamarine; margin-top: 20px; } \u0026lt;/style\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;box1\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box2\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; 崩壊問題 (マージンコラプス) 親子関係のタグで、子要素に上マージンを追加すると崩壊現象が起きるんだ。親要素も一緒に下にずれてしまう。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;style\u0026gt; .father{ width: 300px; height: 300px; background-color: pink; } .son{ width: 100px; height: 100px; background-color: aqua; /* 2つのボックスが一緒に50px下にずれる */ margin-top: 50px; } \u0026lt;/style\u0026gt; \u0026lt;div class=\u0026#34;father\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;son\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 解決方法：\n子要素の margin をなくして、親要素で padding を使う 親要素に overflow: hidden を設定する 親要素に border-top を設定する 要素のオーバーフロー ボックスのコンテンツがボックスのサイズを超えると、オーバーフローが発生するんだ。overflow プロパティで、あふれたコンテンツの表示方法を制御できるよ。\nプロパティ値 効果 hidden はみ出た部分を隠す scroll はみ出た部分をスクロール (はみ出ているかどうかにかかわらず、スクロールバーを表示する) auto はみ出た部分をスクロール (はみ出た場合にのみスクロールバーを表示する) インライン要素の垂直位置 インライン要素 (例えば span) に margin や padding を追加しても垂直位置は変えられないんだ。この場合は line-height で変更できるよ。\n1 2 3 4 5 6 span { margin: 50px; padding: 20px; line-height: 100px; } 角丸効果 border-radius プロパティを使って要素の外側のボーダーを角丸にするんだ。プロパティ値は角丸の半径で、数値とpx、またはパーセンテージが使えるよ。複数値の指定は padding と似てる。\n値の数 意味 一つ 四隅すべて設定値になる 四つ 左上 右上 右下 左下 (時計回り) 三つ 左上 右上+左下 右下 二つ 左上+右下 右上+左下 正円の形 正方形のボックスに、角丸のプロパティ値を幅と高さの半分、または50%に設定する。\n1 2 3 4 5 6 7 8 div { width: 100px; height: 100px; background-color: aqua; border-radius: 50%; /* もしくは border-radius: 50px */ } カプセル型 長方形のボックスに、角丸のプロパティ値をボックスの高さの半分に設定する。\n1 2 3 4 5 6 7 div { width: 100px; height: 50px; background-color: aqua; border-radius: 25px; } 影の効果 box-shadow を使って設定するよ。プロパティ値は：x y ぼかし半径 拡散半径 色 内外の影\nこのうち x と y は必須だよ。デフォルトでは外側の影になるんだけど、内側の影を設定したい場合はプロパティ値を inset にするんだ。\n","date":"2024-04-13T22:06:58+08:00","permalink":"https://blog.yexca.net/ja/archives/167/","title":"CSS ボックスモデル"},{"content":" 📢 この記事は gemini-2.5-flash によって翻訳されました 背景プロパティにはこんなのがあるよ\n説明 プロパティ 背景色 background-color 背景画像 background-image 背景画像の繰り返し方 background-repeat 背景画像の位置 background-position 背景画像の拡大縮小 background-size 背景画像の固定 background-attachment 背景画像の複合プロパティ background 背景画像 Webページでは、装飾的な画像効果を出すために背景画像を使うんだ。\n1 2 3 4 5 6 div { width: 500px; height: 300px; background-image: url(./img/00.jpg); } 背景画像の繰り返し方 background-repeatには4つの値があるよ。\n効果 繰り返さない 繰り返す (デフォルト) 水平方向に繰り返す 垂直方向に繰り返す 属性値 no-repeat repeat repeat-x repeat-y 背景画像の位置 background-positionの値は水平方向の位置 垂直方向の位置だよ。位置の値にはキーワードと座標があるんだ。\nキーワードにはleft、right、center、top、bottomがあるよ。\n座標は数字+pxを使って、正負どちらもOKだよ。\n1 2 3 4 5 div { background-position: center top; /* 数字とキーワードを混ぜてもいいよ */ /* background-position: -50px center; */ } キーワードを一つだけ書いたら、もう一方の方向は中央になるよ。数字を一つだけ書いた場合は水平方向が指定されて、垂直方向は中央になるんだ。\n背景画像の拡大縮小 background-sizeにはよく使う3つの属性値があるよ。\nキーワード cover：背景領域を完全に覆うように背景画像を等比率で拡大縮小するよ。画像の一部が見えなくなることもあるかもしれないね。 contain：背景領域に完全に収まるように背景画像を等比率で拡大縮小するよ。一部が空白になることもあるかもしれない。 パーセンテージ：ボックスのサイズに基づいて画像の大きさを計算するよ。 数字+単位 (例: px) パーセンテージが100%だと、画像の幅とボックスの幅が同じになって、高さは等比率で拡大縮小されるよ。\n背景画像の固定 background-attachmentを使うと、背景が要素のコンテンツと一緒にスクロールしないようになるんだ。属性値はfixedだよ。\n背景画像の複合プロパティ backgroundプロパティの値は背景色 背景画像 繰り返し方 位置/拡大縮小 固定だよ。順序は関係ないんだ。\n1 2 3 4 5 6 div { width: 500px; height: 500px; background: aqua url(./img/01.jpg) no-repeat center/cover; } ","date":"2024-04-10T16:21:51+08:00","permalink":"https://blog.yexca.net/ja/archives/166/","title":"CSSの背景プロパティ"},{"content":" 📢 この記事は gemini-2.5-flash によって翻訳されました テキスト制御プロパティで設定できる内容はこんな感じだよ。\n名前 プロパティ フォントサイズ font-size フォントの太さ font-weight フォントの傾き font-style 行の高さ line-height フォントファミリー font-family フォント複合プロパティ font テキストインデント text-indent テキスト配置 text-align 装飾線 text-decoration 色 color フォントサイズ プロパティ値は文字のサイズだよ。単位は通常 px を使うね。\n1 2 3 p { font-size: 30px; } フォントの太さ プロパティ値は数値かキーワードだよ。\n1 2 3 4 5 6 7 8 p { font-weight: 400; /* 文字を通常にする */ /* font-weight: normal; */ } div { font-weight: 700; /* 文字を太字にする */ /* font-weight: bold; */ } フォントの傾き これは通常、文字のデフォルトの傾き効果を消したいときに使うよ。\n1 2 3 4 5 6 em { font-style: normal; /* em タグの傾き効果を削除する */ } p { font-style: italic; /* p タグ内の文字を傾ける */ } 行の高さ 複数行のテキストの間隔を設定するんだ。プロパティ値は2種類あるよ。\n1 2 3 4 5 6 P { line-height: 30px; /* 行の高さは 30px */ } div { line-height: 2; /* 行の高さは font-size の2倍 (font-size はデフォルトで 16px だよ) */ } 行の高さは、テキストの高さ + 上余白 + 下余白のことだよ。\n行の高さのプロパティ値がボックス (div) の高さのプロパティ値と同じだと、垂直方向の中央揃えができるよ。\n1 2 3 4 div { line-height: 100px; height: 100px; } フォントファミリー 文字のフォントを制御するもので、プロパティ値はフォント名だよ。\n1 2 3 p { font-family: 楷体; } 普通は複数設定するんだ。\n1 2 3 p { font-family: Microsoft YaHei, Heiti SC, tahoma, arial, Hiragino Sans GB, \u0026#34;\\5B8B\\4F53\u0026#34;, sans-serif; } 実行順序は左から右だよ。つまり、ブラウザはシステムに現在のフォントがあるか確認して、なければ次のフォントを、という感じで最後のフォントまで見ていくんだ。上記の最後のものは、サンセリフフォント のフォントファミリー名だね。\nfont 複合プロパティ 開発でフォントを設定するとき、こんな状況があるよね。\n1 2 3 4 5 6 7 div { font-style: italic; /* 文字を傾ける */ font-weight: 700; /* 文字を太字にする */ font-size: 30px; /* フォントサイズは 30px */ line-height: 2; /* 行の高さは字号の 2 倍 */ font-family: 楷体; /* フォントを設定する */ } こんな風に省略できるよ。\n1 2 3 4 div { font: italic 700 30px/2 楷体; /* 傾き 太さ 字号/行の高さ フォント */ } このプロパティは、ウェブページの文字の共通スタイルを設定するときによく使うね。プロパティ値は順番通りに書く必要があって、その中でも字号（フォントサイズ）とフォントの値は必須だけど、他は省略できるよ。\nテキストインデント プロパティ値は px か em の2種類だよ。em は現在のタグのフォントサイズのことだね。\n1 2 3 4 5 p { font-size: 20px; text-indent: 2em; /* 最初の行を2文字分インデントする */ /* text-indent: 40px; 上の行のコードと同じ効果だよ */ } テキストの配置方法 text-align プロパティには left、center、right の3つの値があるんだ。\n1 2 3 div { text-align: center; /* 文字を中央揃えにする */ } このプロパティは文字の配置だけでなく、例えば次のように使うと画像を中央揃えにできるよ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; div { text-align: center; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div\u0026gt; \u0026lt;img src=\u0026#34;path\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; text-align の本質はコンテンツの配置を制御することなんだ。プロパティはコンテンツの親要素に設定するんだよ。上の例では img の親は div だね。\nテキスト装飾線 効果 なし 下線 打ち消し線 上線 プロパティ値 none underline line-through overline 1 2 3 4 5 6 a { text-decoration: none; /* リンクの下線を削除する */ } del { text-decoration: none; /* del タグの打ち消し線を削除して、del タグを無効にする */ } 文字の色 色の表現方法 プロパティ値 説明 キーワード 英単語 red、green、aqua など rgb 表現 rgb(r, g, b) r, g, b は赤緑青の3原色を表すよ。値は 0-255 だね。 rgba 表現 rgba(r, g, b, a) a は透明度を表すよ。値は 0 から 1 だね。 16進数表現 #RRGGBB 2つずつで1組。同じ場合は省略できるよ。#ffcc00 -\u0026gt; #fc0 1 2 3 4 5 6 p { color: rgba(250, 200, 0, 0.5); } div { dolor: #acf; /* #aaccff と同じだよ */ } ","date":"2024-03-14T21:07:15+08:00","permalink":"https://blog.yexca.net/ja/archives/165/","title":"CSS テキスト制御プロパティ"},{"content":" 📢 この記事は gemini-2.5-flash によって翻訳されました CSSの三つの特性：継承性、重ね合わせ、優先順位\n継承性 子要素は親要素の文字に関するプロパティをデフォルトで継承するけど、もし子要素自身にスタイルがあったら、それは継承しないよ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;style\u0026gt; body { font: 30px/0.5 楷体; color: aqua; } \u0026lt;/style\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div\u0026gt;div\u0026lt;/div\u0026gt; \u0026lt;p\u0026gt;p\u0026lt;/p\u0026gt; \u0026lt;span\u0026gt;span\u0026lt;/span\u0026gt; \u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt;色は継承されないよ\u0026lt;/a\u0026gt; \u0026lt;/body\u0026gt; 重ね合わせ セレクターの種類が同じ場合：\n同じプロパティは上書きされるよ：後から書いたCSSプロパティが前のCSSプロパティを上書きするんだ。 異なるプロパティは重ね合わされるよ：異なるCSSプロパティはどちらも有効になるんだ。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;style\u0026gt; div { color: red; font-size: 30px; } div { color: aqua; font-weight: 700; } \u0026lt;/style\u0026gt; \u0026lt;div\u0026gt; 色はアクアで、文字サイズは30px、太字になるよ。 \u0026lt;/div\u0026gt; 優先順位 一つの要素に複数のセレクターが使われたら、優先順位が高いスタイルが適用されるよ。優先順位はこんな感じ：\nユニバーサルセレクター \u0026lt; タイプセレクター \u0026lt; クラスセレクター \u0026lt; IDセレクター \u0026lt; インラインスタイル \u0026lt; !important\n!importantは普通は使わないよ。次の例では使ってないよ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;style\u0026gt; #app { color: orange; } .box { color: blue; } div { color: red; } * { color: purple; } \u0026lt;/style\u0026gt; \u0026lt;div\u0026gt;タイプセレクター red\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;クラスセレクター blue\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34; id=\u0026#34;app\u0026#34;\u0026gt;IDセレクター orange\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34; id=\u0026#34;app\u0026#34; style=\u0026#34;color: aqua;\u0026#34;\u0026gt;インラインスタイル aqua\u0026lt;/div\u0026gt; !importantを使う場合\n1 2 3 4 5 6 7 \u0026lt;style\u0026gt; div { color: aqua !important; } \u0026lt;/style\u0026gt; \u0026lt;div style=\u0026#34;color: blue\u0026#34;\u0026gt;aqua\u0026lt;/div\u0026gt; 複合セレクターの優先順位 優先順位は (インラインスタイル、IDセレクターの数、クラスセレクターの数、タイプセレクターの数) の順番で左から順に比較していくんだ。各項目で数が多い方が優先度が高くなるよ。もし同じだったら次の項目で比較するって感じ。\n!importantがあったら一番優先順位が高くて、継承されたものだと一番低くなるよ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 \u0026lt;style\u0026gt; /* (0, 0, 2, 1) */ .c1 .c2 div { color: blue; } /* (0, 1, 0, 1) */ div #box3 { color: red; } /* (0, 1, 1, 0) */ #box1 .c3 { color: aqua; } \u0026lt;/style\u0026gt; \u0026lt;div class=\u0026#34;c1\u0026#34; id=\u0026#34;box1\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;c2\u0026#34; id=\u0026#34;box2\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;c3\u0026#34; id=\u0026#34;box3\u0026#34;\u0026gt; aqua \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 例 2\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 \u0026lt;style\u0026gt; /* (0, 2, 0, 0) */ #father #son { color: aqua; } /* (0, 1, 1, 1) */ #father p.c2 { color: black; } /* (0, 0, 2, 2) */ div.c1 p.c2 { color: red; } /* 継承 */ #father { color: blue !important; } /* 継承 */ div#father.c1{ color: yellow; } \u0026lt;/style\u0026gt; \u0026lt;div class=\u0026#34;c1\u0026#34; id=\u0026#34;father\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;c2\u0026#34; id=\u0026#34;son\u0026#34;\u0026gt; aqua \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; Emmet記法 これはコードを短く書く方法で、省略形を入力するとVS Codeが自動で対応するコードを生成してくれるんだ。\nHTMLの場合\n説明 Emmet 結果 クラスセレクター タグ名.クラス名 \u0026lt;div class=\u0026quot;box\u0026quot;\u0026gt;\u0026lt;/div\u0026gt; IDセレクター タグ名#ID名 \u0026lt;div id=\u0026quot;app\u0026quot;\u0026gt;\u0026lt;/div\u0026gt; 同じ階層のタグ div+p \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt; 親子関係のタグ div\u0026gt;p \u0026lt;div\u0026gt;\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;/div\u0026gt; 複数の同じタグ span*3 \u0026lt;span\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt;\u0026lt;/span\u0026gt; コンテンツがあるタグ div{内容} \u0026lt;div\u0026gt;内容\u0026lt;/div\u0026gt; CSSの場合は、単語の頭文字を使うことが多いよ。\nh500+w300+bgc はこうなるよ\n1 2 3 4 5 div { width: 500px; height: 300px; background-color: #fff; } ","date":"2024-03-11T16:38:34+08:00","permalink":"https://blog.yexca.net/ja/archives/164/","title":"CSSの三つの特性"},{"content":" 📢 この記事は gemini-2.5-flash によって翻訳されました CSSの導入方法 CSSには3つの導入方法があるんだ。最初の方法は内部スタイルシートで、これは学習目的でしか使わないよ。\n1 2 3 4 5 6 7 8 9 10 \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; /* ここにCSSを書くよ */ \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 二番目はインラインスタイルで、これは通常JavaScriptと組み合わせて使うんだ。\n1 \u0026lt;div style=\u0026#34;ここにCSSを書くよ\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; 最後は外部スタイルシートで、CSSコードを別のファイルに書いて、linkタグで読み込む方法だね。開発でよく使うよ。\n1 2 3 4 \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;css path\u0026#34; /\u0026gt; \u0026lt;/head\u0026gt; CSSセレクター セレクターの役割は、タグを探してスタイルを設定することだよ。基本セレクターは全部で4種類あるんだ。\nタグセレクター タグ名をそのままセレクターとして使うと、同じ名前のタグが全部選ばれて、同じスタイルが適用されるよ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; div{ /* 全てのdivタグを選択してスタイルを設定するよ */ } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; p、h1、div、a、imgなんかのタグが使えるね。\nクラスセレクター タグを探して、表示を差別化するために使うんだ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; .first{ /* firstクラスのdivを選択してスタイルを設定するよ */ } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;first\u0026#34;\u0026gt; first div \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; second div \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; クラス名が複数の単語でできてる場合は-でつなげるといいよ。1つのクラスセレクターを複数のタグで使えるし、1つのタグに複数のクラス名を指定することもできるんだ。\n1 2 3 \u0026lt;div class=\u0026#34;first second\u0026#34;\u0026gt; 二つのクラス名を使ったよ \u0026lt;/div\u0026gt; idセレクター タグを探して、表示を差別化するために使うよ。これは普通、JavaScriptと組み合わせて使うんだ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; #app{ /* idがappのタグを選択するよ */ } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 同じidセレクターは1ページにつき1回しか使えないんだ。\nユニバーサルセレクター（全称セレクター） ページの全てのタグを探して、同じスタイルを設定するやつだよ。これは通常、タグのデフォルトスタイルをリセットするときに使うんだ。\n1 2 3 4 5 \u0026lt;style\u0026gt; *{ /* 全てのタグに影響するスタイルを書くよ */ } \u0026lt;/style\u0026gt; 複合セレクター 定義：2つ以上の基本セレクターが異なる方法で組み合わされたもの。\n役割：目的の要素（タグ）をより正確に、より効率的に選択できるよ。\n子孫セレクター ある要素の全ての子孫要素を選択できるんだ。\n構文：親セレクター 子セレクター { CSSプロパティ }\n親セレクターと子セレクターの間は半角スペースで区切るよ。クラスセレクターやidセレクターも使えるんだ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;style\u0026gt; div span{ color: aqua; } \u0026lt;/style\u0026gt; \u0026lt;span\u0026gt;色は変わらないよ\u0026lt;/span\u0026gt; \u0026lt;div\u0026gt; \u0026lt;span\u0026gt;色は変わるよ\u0026lt;/span\u0026gt; \u0026lt;p\u0026gt; \u0026lt;span\u0026gt;色は変わるよ\u0026lt;/span\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; 直下セレクター（子セレクター） ある要素の直下の子要素だけを選択するよ。\n構文：親セレクター \u0026gt; 子セレクター { CSSプロパティ }\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;style\u0026gt; div \u0026gt; span{ color: aqua; } \u0026lt;/style\u0026gt; \u0026lt;div\u0026gt; \u0026lt;span\u0026gt;色は変わるよ\u0026lt;/span\u0026gt; \u0026lt;p\u0026gt; \u0026lt;span\u0026gt;色は変わらないよ\u0026lt;/span\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; グループセレクター（カンマセレクター） 複数のタググループを選択して、同じスタイルを設定するよ。\n構文：セレクター1, セレクター2, ..., セレクターN { CSSプロパティ }\n1 2 3 4 5 6 7 8 9 \u0026lt;style\u0026gt; div, span, p { color: aqua; } \u0026lt;/style\u0026gt; \u0026lt;div\u0026gt;色は変わるよ\u0026lt;/div\u0026gt; \u0026lt;p\u0026gt;色は変わるよ\u0026lt;/p\u0026gt; \u0026lt;span\u0026gt;色は変わるよ\u0026lt;/span\u0026gt; 属性セレクター（結合セレクター） 複数の条件を同時に満たす要素を選択するんだ。\n構文：セレクター1セレクター2 { CSSプロパティ } セレクター間はスペースなしで続けるよ。\nもし結合セレクターにタグセレクターが含まれているなら、タグセレクターは一番最初に書かなきゃいけないんだ。\n1 2 3 4 5 6 7 8 9 \u0026lt;style\u0026gt; p.box { color: aqua; } \u0026lt;/style\u0026gt; \u0026lt;p class=\u0026#34;box\u0026#34;\u0026gt;色は変わるよ\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;pタグ、色は変わらないよ\u0026lt;/p\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;色は変わらないよ\u0026lt;/div\u0026gt; 擬似クラスセレクター 擬似クラスは要素の状態を表していて、要素の特定の状態を選択してスタイルを設定するんだ。\nマウスホバー状態 構文：セレクター:hover { CSSプロパティ }\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;style\u0026gt; a:hover{ color: red; } .box:hover{ color: aqua; } \u0026lt;/style\u0026gt; \u0026lt;a href=\u0026#34;https://yexca.net\u0026#34;\u0026gt;yexca\u0026lt;/a\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt; divタグ \u0026lt;/div\u0026gt; どんなタグでもマウスホバーの状態を設定できるよ。\nハイパーリンクの状態 セレクター 役割 :link 未訪問時 :visited 訪問済み時 :hover マウスオーバー時 :active クリック時 (アクティブ時) もしハイパーリンクに4つの状態を設定するなら、この順番で書かなきゃいけないよ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;style\u0026gt; a:link { color: green; } a:visited { color: red; } a: hover { color: aqua; } a: active { color: orange; } \u0026lt;/style\u0026gt; \u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt;aタグ\u0026lt;/a\u0026gt; 構造擬似クラスセレクター 役割：要素の構造的な関係に基づいて要素を探すんだ。\nセレクター 説明 E:first-child 最初の E 要素を選択するよ E:last-child 最後の E 要素を選択するよ E:nth-child(N) N番目の E 要素を選択するよ (1から数えるんだ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;style\u0026gt; li:first-child { background-color: aqua; } li:last-child { background-color: green; } li:nth-child(3) { background-color: blue; } \u0026lt;/style\u0026gt; \u0026lt;ol\u0026gt; \u0026lt;li\u0026gt;aqua\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;2\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;blue\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;4\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;green\u0026lt;/li\u0026gt; \u0026lt;/ol\u0026gt; 3番目のセレクターは、式を使って複数の要素を選択できるんだ。\n機能 式 偶数番目のタグ 2n 奇数番目のタグ 2n+1 または 2n-1 5の倍数のタグを見つける 5n 5番目以降のタグを見つける (5番目を含む) n+5 5番目以前のタグを見つける (5番目を含む) -n+5 擬似要素セレクター 役割：仮想要素（擬似要素）を作成して、装飾的なコンテンツを配置するんだ。\nセレクター 説明 E::before E要素の内部の一番前に擬似要素を追加するよ E::after E要素の内部の一番後ろに擬似要素を追加するよ 注意点：\ncontentプロパティを設定して、擬似要素の内容を設定する必要があるんだ。内容がなければ、クォーテーションは空にしておいてね。 擬似要素はデフォルトで行内表示モードだよ。 優先度はタグセレクターと同じだよ。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;style\u0026gt; div { width: 110px; height: 30px; background-color: aqua; font-size: 20px; } div::before { content: \u0026#39;yexca\u0026#39;; } div::after { content: \u0026#39;blog\u0026#39;; } \u0026lt;/style\u0026gt; \u0026lt;div\u0026gt;\u0026#39;\u0026lt;/div\u0026gt; \u0026lt;!-- 内容は yexca\u0026#39;blog になるよ --\u0026gt; ","date":"2024-03-02T17:15:35+08:00","permalink":"https://blog.yexca.net/ja/archives/163/","title":"CSSセレクター"},{"content":" この記事の一部は機械翻訳を使ったよ\nGolang シリーズ\nHello GoLang: https://blog.yexca.net/ja/ja/archives/154 GoLang (var and const) 変数と定数: https://blog.yexca.net/ja/ja/archives/155 GoLang (func) 関数: https://blog.yexca.net/ja/ja/archives/156 GoLang (slice and map) スライス: https://blog.yexca.net/ja/ja/archives/160 GoLang (OOP) オブジェクト指向: この記事\nGoLang (reflect) リフレクション: https://blog.yexca.net/ja/ja/archives/204 GoLang (struct tag) 構造タグ: https://blog.yexca.net/ja/ja/archives/205 GoLang (goroutine) ゴルーチン: https://blog.yexca.net/ja/ja/archives/206 GoLang (channel) チャンネル: https://blog.yexca.net/ja/ja/archives/207 造を使用してクラスとオブジェクトの概念を構築する\nオブジェクト指向を理解する: オブジェクト指向の基礎 struct まずは、C に似た type キーワードを使用したカスタム型です。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package main import \u0026#34;fmt\u0026#34; type myType int func main() { var a myType fmt.Println(\u0026#34;a =\u0026#34;, a) fmt.Printf(\u0026#34;type of a is %T\u0026#34;, a) } /* * 出力 * a = 0 * type of a is main.myTye */ stuct を使用して型を定義する\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package main import \u0026#34;fmt\u0026#34; type Person struct { name string age int } fun main() { var zhang Person zhang.name = \u0026#34;zhangSan\u0026#34; zhang.age = 20 fmt.Print(zhang) } 関数転送は関連しており、ポインタは使用されず、値の転送です\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 package main import \u0026#34;fmt\u0026#34; type Person struct { name string age int } // 値の転送、元のデータは変更されません func changeName(person Person) { person.name = \u0026#34;liSi\u0026#34; } // 参照を渡すと元のデータが変更されます func changeAge(person *Person) { person.age = 18 } func main() { var zhang Person zhang.name = \u0026#34;zhangSan\u0026#34; zhang.age = 20 fmt.Println(zhang) changeName(zhang) fmt.Println(zhang) changeAge(\u0026amp;zhang) fmt.Println(zhang) } カプセル化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 package main import \u0026#34;fmt\u0026#34; // クラス type Person struct { // プロパティ name string age int } // クラスメソッド func (this *Person) SetName(name string) { this.name = name } func (this *Person) SetAge(age int) { this.age = age } func (this *Person) GetName() string { return this.name } func (this *Person) GetAge() int { return this.age } func main() { person := Person{name: \u0026#34;zhangSan\u0026#34;, age: 18} fmt.Println(person) } クラス名とメソッド名の最初の文字が大文字になっていることに注意してください。これは、クラスとメソッドが他のパッケージからアクセスできることを意味します (java public)。最初の文字が小文字の場合は、このパッケージからのみアクセスできます (java private) プロパティについても同様です。\n継承 次のコードは同じファイル、親クラスにあります\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 親クラス type Person struct { name string age int } // 親クラスのメソッド func (this *Person) Eat() { fmt.Println(\u0026#34;Person Eat...\u0026#34;) } func (this *Person) Walk() { fmt.Println(\u0026#34;Person Walk...\u0026#34;) } サブクラス\n1 2 3 4 5 6 7 8 9 10 11 12 13 // サブクラス type SuperMan struct { Person // 親クラスから継承 level int // サブクラス属性 } // サブクラスは親クラスのメソッドをオーバーライドします func (this *SuperMan) Walk() { fmt.Println(\u0026#34;SuperMan Walk\u0026#34;) } // サブクラス固有のメソッド func (this *SuperMan) Fly() {} main 関数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func main() { // サブクラスの属性を定義する、方法 1 superMan1 := SuperMan{Person{\u0026#34;zhangSan\u0026#34;, 18}, 4} // サブクラスの属性を定義する、方法 2 var superMan2 SuperMan superMan2.name = \u0026#34;liSi\u0026#34; // 同じパッケージ内にあるため、親クラスの属性にアクセスできます superMan2.age = 20 superMan2.level = 5 // サブクラスは親クラスのメソッドを呼び出す superMan1.Eat() // サブクラスのオーバーライドメソッド superMan1.Walk() // サブクラスメソッド superMan2.Fly() } 多態性 次のコードは同じファイルにあり、インターフェースを定義しています\n1 2 3 4 5 6 // インターフェース、基本的にはポインタ type Animal interface { Sleep() GetName() string GetType() string } 実装クラス 1\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 実装クラス 1 type Cat struct { name string kind string } // インターフェースのすべてのメソッドを実装する func (this *Cat) Sleep() { fmt.Println(\u0026#34;Cat Sleep()\u0026#34;) } func (this *Cat) GetName() string { return this.name } func (this *Cat) GetType() string { return this.kind } 実装クラス 2\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // 実装クラス 2 type Dog struct { name string kind string } // インターフェースのすべてのメソッドを実装する func (this *Dog) Sleep() { fmt.Println(\u0026#34;Cat Sleep()\u0026#34;) } func (this *Dog) GetName() string { return this.name } func (this *Dog) GetType() string { return this.kind } func ShowAnimal(animal Animal) { fmt.Println(animal) } main\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 func ShowAnimal(animal Animal) { fmt.Println(animal) } func main() { var animal Animal animal = \u0026amp;Cat{\u0026#34;cat1\u0026#34;, \u0026#34;cat\u0026#34;} animal.Sleep() animal = \u0026amp;Dog{\u0026#34;dog1\u0026#34;, \u0026#34;dog\u0026#34;} animal.Sleep() cat := Cat{\u0026#34;cat2\u0026#34;, \u0026#34;cat\u0026#34;} dog := Dog{\u0026#34;dog2\u0026#34;, \u0026#34;dog\u0026#34;} ShowAnimal(\u0026amp;cat) ShowAnimal(\u0026amp;dog) } ユニバーサル型とアサーション 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package main import \u0026#34;fmt\u0026#34; // ユニバーサルデータ型を表すために空のインターフェースを使用する func f(arg interface{}) { // 型アサーションメカニズム (つまり型変換) value, flag := arg.(string) if !flag { fmt.Println(\u0026#34;arg is not string type\u0026#34;) } else { fmt.Println(\u0026#34;arg is string type, arg =\u0026#34;, value) } } func main() { // カスタムを含む任意のデータ型を渡すことができます f(\u0026#34;abc\u0026#34;) f(123) f(3.14) } /* * 出力 * arg is string type, arg = abc * arg is not string type * arg is not string type */ ","date":"2024-03-01T15:35:38+08:00","permalink":"https://blog.yexca.net/ja/archives/162/","title":"GoLang オブジェクト指向"},{"content":"レジストリを導入する前に、プロバイダーとコンシューマーの概念を紹介します。\nプロバイダーとコンシューマー サービス プロバイダー: ビジネス内の他のマイクロサービスによって呼び出されるサービス。 (他のマイクロサービスへのインターフェースを提供する)\nサービス コンシューマー: 1 つのビジネス内の他のマイクロサービスを呼び出すサービス。 (他のマイクロサービスによって提供されるインターフェースの呼び出し)\nプロバイダーとコンシューマーは相対的です。サービスはプロバイダーとコンシューマーの両方になることができます。\nEureka プロバイダーが複数ある場合、消費者はどのようにしてプロバイダー情報を入手し、プロバイダーの健全性状態を知ることができるのでしょうか?\n起動時に、マイクロサービスは Eureka にサービス情報を登録します。コンシューマーは Eureka を通じてプロバイダー情報を取得し、それをリモートで呼び出すことができます。マイクロサービスは 30 秒ごとに Eureka にまだ稼働中であることを通知し、Eureka はサービス リスト情報を更新して、正常でないサーバーを削除します。\n複数のサービス プロバイダーがある場合、コンシューマーは負荷分散アルゴリズムを使用してサービス リストから 1 つを選択します。\n建てる 新しい Maven モジュールを作成し、依存関係を導入する\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-eureka-server\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; スタートアップクラスの作成\n1 2 3 4 5 6 7 @EnableEurekaServer @SpringBootApplication public class EurekaApplication { public static void main(String[] args) { SpringApplication.run(EurekaApplication.class,args); } } 設定ファイル\n1 2 3 4 5 6 7 8 9 server: port: 7995 spring: application: name: eureka-server eureka: client: service-url: defaultZone: http://127.0.0.1:7995/eureka サービスに登録する 依存関係の導入\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-eureka-client\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 構成の記述\n1 2 3 4 5 6 7 spring: application: name: userService eureka: client: service-url: defaultZone: http://127.0.0.1:7995/eureka サービスの利用 上記の登録例\n1 2 3 4 5 @Bean @LoadBalanced public RestTemplate restTemplate(){ return new RestTemplate(); } ドメイン名をサービス名に変更する\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 @Service public class OrderService { @Autowired private OrderMapper orderMapper; @Autowired private RestTemplate restTemplate; public Order queryOrderById(Long orderId) { // 1.注文をクエリ Order order = orderMapper.findById(orderId); // 2.ユーザーをクエリ // String url = \u0026#34;http://localhost:8081/user/\u0026#34; + order.getUserId(); String url = \u0026#34;http://userService/user/\u0026#34; + order.getUserId(); User user = restTemplate.getForObject(url, User.class); // 3.ユーザー情報をカプセル化する order.setUser(user); // 4.戻る return order; } } ","date":"2024-02-29T16:53:15+08:00","permalink":"https://blog.yexca.net/ja/archives/161/","title":"登録センター - Eureka"},{"content":" この記事の一部は機械翻訳を使ったよ\nGolang シリーズ\nHello GoLang: https://blog.yexca.net/ja/ja/archives/154 GoLang (var and const) 変数と定数: https://blog.yexca.net/ja/ja/archives/155 GoLang (func) 関数: https://blog.yexca.net/ja/ja/archives/156 GoLang (slice and map) スライス: この記事\nGoLang (OOP) オブジェクト指向: https://blog.yexca.net/ja/ja/archives/162 GoLang (reflect) リフレクション: https://blog.yexca.net/ja/ja/archives/204 GoLang (struct tag) 構造タグ: https://blog.yexca.net/ja/ja/archives/205 GoLang (goroutine) ゴルーチン: https://blog.yexca.net/ja/ja/archives/206 GoLang (channel) チャンネル: https://blog.yexca.net/ja/ja/archives/207 Go のスライスは配列の抽象化である\n配列 配列の長さは変更できません\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package main import \u0026#34;fmt\u0026#34; func main() { // 定義方法 1 var arr1 [10]int // トラバース for i := 0; i \u0026lt; len(arr1); i++ { fmt.Println(\u0026#34;arr1[\u0026#34;, i, \u0026#34;]:\u0026#34;, arr1[i]) } // 定義方法 2、代入 arr2 := [10]int{0, 1, 2, 3} // range トラバーサル for index, value := range arr2 { fmt.Println(\u0026#34;index =\u0026#34;, index, \u0026#34;value =\u0026#34;, value) } // 異なる長さを定義する var arr3 [4]int fmt.Printf(\u0026#34;type of arr1 is %T\\n\u0026#34;, arr1) // [10]int fmt.Printf(\u0026#34;type of arr1 is %T\\n\u0026#34;, arr2) // [10]int fmt.Printf(\u0026#34;type of arr1 is %T\u0026#34;, arr3) // [4]int } コンパイルして実行すると、arr3 が arr1 および arr2 とは異なる型であることがわかります。そのため、関数パラメータを定義するときにも対応する型を指定する必要があります。\n1 2 3 4 5 func test(arr [4]int) { for i := 0; i \u0026lt; len(arr); i++ { fmt.Println(\u0026#34;fmt_arr[\u0026#34;, i, \u0026#34;]:\u0026#34;, arr[i]) } } 上記の関数は arr3 を値で渡すことしかできず、値を変更しても元のデータには影響しません。\nスライスを定義する 配列と比較すると、スライスは固定長ではなく、要素を追加することができます（動的配列）。追加するとスライスの容量が増加する可能性があります。\nスライスは、サイズが指定されていない配列を宣言することによって定義できます。\n1 2 3 var name []type // 例えば var s []int または make() 関数を使用してスライスを作成する\n1 2 3 var slice []type = make([]type, len) // len はスライスの初期の長さです // 次のように省略することもできます slice := make([]type, len) オプションの capacity パラメータを使用して容量を指定できます。省略した場合は、length と同じになります。\n1 var slice []type = make([]type, length, capacity) スライスの初期化 直接初期化\n1 s := []int {1, 2, 3} 配列の値を startIndex から endIndex-1 までのスライスとして初期化します。両方の値は省略できます。\n1 s := arr[startIndex:endIndex] startIndex または endIndex を省略すると、最初の要素からインデックス付けするか、最後の要素までインデックス付けすることを意味します。\nlen() と cap() スライスはインデックス可能であり、その長さは len() 関数を使用して取得できます。\ncap() は容量を計算するメソッドであり、スライスが到達できる長さを測定できます。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package main import \u0026#34;fmt\u0026#34; // スライス渡しは参照渡しであり、関数内の変更は元のデータに影響します func printSlice(slice []int) { fmt.Printf(\u0026#34;len=%d, cap=%d, slice=%v\u0026#34;, len(slice), cap(slice), slice) } func main() { s := make([]int, 3, 5) printSlice(s) } /* * 出力 * len=3, cap=5, slice=[0 0 0] */ 空のスライス スライスは初期化前はデフォルトで nil (空のスライス) であり、その長さは 0 です。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package main import \u0026#34;fmt\u0026#34; func printSlice(slice []int) { fmt.Printf(\u0026#34;len=%d, cap=%d, slice=%v\\n\u0026#34;, len(slice), cap(slice), slice) } func main() { var s []int printSlice(s) // 空かどうか確認する if s == nil { fmt.Println(\u0026#34;slice is empty\u0026#34;) } } スライスインターセプション 上限と下限を設定してスライスをカットする\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package main import \u0026#34;fmt\u0026#34; func printSlice(slice []int) { fmt.Printf(\u0026#34;len=%d, cap=%d, slice=%v\\n\u0026#34;, len(slice), cap(slice), slice) } func main() { s := []int{0, 1, 2, 3, 4, 5, 6, 7} // 元のスライスを印刷する fmt.Println(s) // 2(含む) から 5(含まない) まで printSlice(s[2:5]) // 1 番目から 5 まで (含まない) printSlice(s[:5]) // 2 番目から最後まで printSlice(s[2:]) // この割り当てと subS の変更は s に影響します subS := s[1:6] printSlice(subS) } append() と copy() スライスの容量を増やし、スライスをコピーする\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package main import \u0026#34;fmt\u0026#34; func printSlice(slice []int) { fmt.Printf(\u0026#34;len=%d, cap=%d, slice=%v\\n\u0026#34;, len(slice), cap(slice), slice) } func main() { var s []int printSlice(s) // 要素を追加する s = append(s, 0) printSlice(s) // 複数の要素を追加する s = append(s, 1, 2, 3, 4) printSlice(s) // s の 2 倍の容量を持つ s2 を作成します s2 := make([]int, len(s), cap(s)*2) // s を s2 にコピーします。s2 を変更しても s には影響しません。 copy(s2, s) printSlice(s2) } スライス拡張: 追加された値が容量を超える場合、容量は2倍になります\nmap map を宣言する方法は 2 つあります\n1 2 3 4 5 6 7 8 9 10 11 package main import \u0026#34;fmt\u0026#34; func main() { var map1 = make(map[string]string) // データを挿入 map1[\u0026#34;one\u0026#34;] = \u0026#34;1\u0026#34; map1[\u0026#34;two\u0026#34;] = \u0026#34;2\u0026#34; fmt.Println(map1) // map[one:1 two:2] } 2 番目\n1 2 3 4 5 6 7 8 9 10 11 package main import \u0026#34;fmt\u0026#34; func main() { map1 := map[string]string{ \u0026#34;one\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;two\u0026#34;: \u0026#34;2\u0026#34;, } fmt.Println(map1) } map のネスト 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package main import \u0026#34;fmt\u0026#34; func main() { map1 := make(map[string]map[string]string) map1[\u0026#34;first\u0026#34;] = make(map[string]string, 2) map1[\u0026#34;first\u0026#34;][\u0026#34;one\u0026#34;] = \u0026#34;1\u0026#34; map1[\u0026#34;first\u0026#34;][\u0026#34;two\u0026#34;] = \u0026#34;2\u0026#34; fmt.Println(map1) } /* * 出力 * map[first:map[one:1 two:2]] */ トラバーサルを変更して削除する 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package main import \u0026#34;fmt\u0026#34; func main() { map1 := make(map[string]map[string]string) map1[\u0026#34;first\u0026#34;] = make(map[string]string, 2) map1[\u0026#34;first\u0026#34;][\u0026#34;one\u0026#34;] = \u0026#34;1\u0026#34; map1[\u0026#34;first\u0026#34;][\u0026#34;two\u0026#34;] = \u0026#34;2\u0026#34; // 改訂 map1[\u0026#34;first\u0026#34;][\u0026#34;one\u0026#34;] = \u0026#34;one\u0026#34; fmt.Println(map1) // トラバース for key, value := range map1{ fmt.println(\u0026#34;key =\u0026#34;, key, \u0026#34;value =\u0026#34;, value) } // 消去 delete(map1, \u0026#34;first\u0026#34;) fmt.Println(map1) } 特定の値があるかどうかを判定する 1 2 3 4 5 6 7 8 9 10 11 12 13 14 package main import \u0026#34;fmt\u0026#34; func main() { map1 := make(map[string]string) map1[\u0026#34;one\u0026#34;] = \u0026#34;1\u0026#34; val, key := map1[\u0026#34;one\u0026#34;] if key { fmt.Println(val) } else { fmt.Println(\u0026#34;empty\u0026#34;) } } ","date":"2024-02-27T20:00:00+08:00","permalink":"https://blog.yexca.net/ja/archives/160/","title":"GoLang スライス"},{"content":" 📢 この記事は gemini-3-flash-preview によって翻訳されました この記事、結構前に書いたやつだから、書き方のクセが今と違ってて自分でもちょっと違和感あるかも\ncrontabコマンドを使うと、決まった時間の間隔で特定のシステムコマンドやshellスクリプトを実行できるんだ。時間の間隔は、分、時、日、月、曜日、それらの組み合わせで自由に設定できるよ。\nコマンドの形式 1 crontab [-u user] file crontab [-u user] [ -e | -l | -r ] コマンドの引数 -u user：特定のユーザーのcrontabサービスを設定するために使う。 file：コマンドファイルの名前。このファイルをcrontabのタスクリストとして読み込む。コマンドラインで指定しない場合は、標準入力（キーボード）からの入力を受け取ってcrontabに読み込むよ。 -e：特定のユーザーのcrontabファイルの内容を編集する。ユーザーを指定しない場合は、現在のユーザーのファイルを編集するよ。 -l：特定のユーザーのcrontabファイルの内容を表示する。指定しない場合は現在のユーザーのものを表示するよ。 -r：/var/spool/cron ディレクトリから特定のユーザーのcrontabファイルを削除する。指定しない場合は現在のユーザーのものが削除されるよ。 -i：crontabファイルを削除する時に確認プロンプトを出す。 ファイル形式 crontab -e コマンドを実行すると、現在のユーザーの crontab ファイルが開くよ。このファイルの中で、# で始まる行はコメントになるんだ。\ncrontab ファイルでは、m h dom mon dow command という6つのフィールドで定時タスクを設定するよ。1行が1つのタスクに対応してるんだ。それぞれの意味はこんな感じ：\nm：分 (minute) 1時間の中の何分目に実行するか。範囲は 0-59。\nh：時 (hour) 1日の中の何時目に実行するか。範囲は 0-23。\ndom：日 (day of month) 1ヶ月の中の何日目に実行するか。範囲は 0-31。\nmon：月 (month) 1年の中の何ヶ月目に実行するか。範囲は 1-12。 月の英語名の最初の3文字で指定することもできるよ（大文字小文字は区別しない）。例えば january なら jan で指定可能。\ndow：曜日 (day of week) 1週間の中の何曜日に実行するか。範囲は 0-7 で、0 と 7 はどちらも日曜日。 これも英語名の最初の3文字で指定できるよ（例：monday なら mon）。\ncommand：具体的な操作\n実行したい具体的なコマンドや、実行したいスクリプトのパスを指定するよ。\nこれら6つのフィールドはスペースで区切る必要があるんだ。すべてのフィールドに値を設定しなきゃいけなくて、省略はできないよ。5番目のフィールドより後の内容は、すべて6番目のフィールド（実行する操作）として扱われるんだ。\n最初の5つのフィールドでは、以下の特殊文字を使って時間を指定できるよ：\nアスタリスク（*）：すべての可能な値を表す。例えば、月フィールドがアスタリスクなら、他の条件が合えば毎月実行されるよ。 カンマ（,）：カンマで区切ってリストで指定できる。例えば、\u0026ldquo;1,2,5,7,8,9\u0026rdquo; みたいにね。 ハイフン（-）：整数をハイフンで繋いで範囲を指定できる。例えば \u0026ldquo;2-6\u0026rdquo; は \u0026ldquo;2,3,4,5,6\u0026rdquo; と同じ意味。 スラッシュ（/）：時間の**間隔（頻度）**を指定できる。例えば \u0026ldquo;0-23/2\u0026rdquo; は2時間ごとに実行。アスタリスクと組み合わせて */10 と書けば、分フィールドなら10分ごとに実行っていう意味になるよ。 command フィールドでは、改行文字や % 文字を使ってコマンド内容を区切ることができるんだ。\n最初の % より前の内容は実行のために shell に渡されて、% 自体は改行に置き換わるよ。% 以降、行末までの内容は標準入力として渡されるんだ。\nもし % 文字そのものを使いたい時は、\\% でエスケープしてね。\nよく使う方法 cronプロセスにcrontabファイルを渡す前に、まずは環境変数 EDITOR を設定しておこう。cronはこの変数を見て、どのエディタでcrontabファイルを編集するか決めるんだ。\nデフォルトの nano エディタが使いにくい場合は、vi に変更できるよ。$HOME ディレクトリの .profile ファイルを編集して、こんな一行を追加してみて：\n1 EDITOR=vi; export EDITOR 保存して終了したら準備OK。例えば \u0026lt;user\u0026gt;cron（ユーザー名が yexca なら yexcacron）っていう名前のファイルを作って、そこに実行したい内容を書いてみよう。\n1 2 # 午後6時から午前6時まで、15分ごとに日付をコンソールに表示する 0,15,30,45 18-06 * * * /bin/echo \u0026#39;date\u0026#39; \u0026gt; /dev/console この例では、15分ごとに現在の時刻がコンソールに出力されるよ。システムがクラッシュしたり止まったりした時に、最後に表示された時間を見ればいつ止まったかすぐ分かるんだ。システムによっては tty1 がコンソールになってることもあるから、環境に合わせて適宜書き換えてね。作ったファイルを登録するには、そのファイルを引数にして crontab コマンドを実行すればいいよ：\n1 crontab yexcacron これで cron プロセスに登録されて、15分ごとに実行されるようになるんだ。同時に、このファイルのコピーが /var/spool/cron ディレクトリにユーザー名（この場合は yexca）で保存されるよ。\nスクリプトの実行 スクリプトを実行する時に環境変数を使いたい場合は、こんな感じで書くよ：\n1 30 6 * * * . /etc/profile;/bin/sh /root/zfile/bin/restart.sh これは毎日 6:30 に zfile の restart.sh を実行する設定だね。\n参考記事 crontab 定时任务 — Linux Tools Quick Tutorial Linux技巧：介绍设置定时周期执行任务的方法 - SegmentFault 思否 Linux命令之Crontab——定时任务 - SegmentFault 思否 nano编辑器使用教程 - VPS侦探 Linux vi/vim - 菜鸟教程 ","date":"2024-02-26T21:34:15+08:00","permalink":"https://blog.yexca.net/ja/archives/159/","title":"Linuxの定時実行タスク crontab"},{"content":"サービスアーキテクチャ モノリシックアーキテクチャ すべてのビジネス機能を1つのプロジェクトで開発し、展開用に1つのパッケージにパッケージ化します。\n利点: シンプルなアーキテクチャ、スケーラビリティが低い、導入コストが低い、小規模プロジェクトに適している\nデメリット: 結合度が高い\n分散アーキテクチャ システムは業務機能ごとに分割されており、各業務モジュールはサービスと呼ばれる独立したプロジェクトとして開発されている。\n利点: サービスの結合を減らし、サービスのアップグレードと拡張を容易にする\nデメリット: 複雑なアーキテクチャ、使いにくい、大規模なインターネットプロジェクトに適している\nマイクロサービス マイクロサービスは、適切に設計された分散アーキテクチャ ソリューションです。マイクロサービス アーキテクチャの特徴:\n単一責任 : マイクロサービスはより細かい粒度に分割されます。各サービスは固有のビジネス機能に対応しており、単一責任を実現し、重複したビジネス開発を回避します。 サービス指向: マイクロサービスはビジネスインターフェースを外部に公開します 自律性: チームの独立性、テクノロジーの独立性、データの独立性、展開の独立性 強力な分離: サービス呼び出しは分離され、フォールトトレラントであり、連鎖的な問題を回避するためにダウングレードされます。 マイクロサービス技術 マイクロサービス ソリューションには技術フレームワークの実装が必要です。最も一般的なものは次のとおりです。\nDubbo SpringCloud SpringCloudAlibaba 登録センター zookeeper、 Redis Eureka、 Consul Nacos、 Eureka リモートサービスコール Dubbo プロトコル Feign (http プロトコル) Dubbo、Feign 構成センター 无 SpringCloudConfig SpringCloudConfig、 Nacos サービスゲートウェイ 无 SpringCloudGateway、 Zuul SpringCloudGateway、 Zuul サービスの監視と保護 dubbo-admin，弱い機能 Hystix Sentinel マイクロサービスはビジネスモジュールに応じて分割する必要がある\n単一責任: 異なるマイクロサービスに対して同じビジネスを繰り返し開発しない データの独立性: 他のマイクロサービスのデータベースにアクセスしない サービス指向: 独自のビジネスを他のマイクロサービスが呼び出すためのインターフェースとして公開する SpringCloud SpringCloud は現在最も広く使用されているマイクロサービス フレームワークです。さまざまなマイクロサービス機能コンポーネントを統合し、SpringBoot に基づいてこれらのコンポーネントの自動アセンブリを実装します。\n公式サイト: https://spring.io/projects/spring-cloud/ サービス登録と検出: Eureka、Nacos、Consul 統合構成管理: SpringCloudConfig、Nacos リモートサービスコール: OpenFeign、Dubbo 統合ゲートウェイルーティング: SpringCloudGateway、Zuul サービスリンク監視: Zipkin、Sleuth フロー制御、劣化、保護: Hystix、Sentinel マイクロサービス呼び出し 要件: 注文 ID に基づいて注文を照会する場合、注文が属するユーザー情報を返します。\nRestTemplate を登録する 1 2 3 4 @Bean public RestTemplate restTemplate(){ return new RestTemplate(); } サービスリモート呼び出し RestTemplate 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 @Service public class OrderService { @Autowired private OrderMapper orderMapper; @Autowired private RestTemplate restTemplate; public Order queryOrderById(Long orderId) { // 1.注文をクエリ Order order = orderMapper.findById(orderId); // 2.ユーザーをクエリ String url = \u0026#34;http://localhost:8081/user/\u0026#34; + order.getUserId(); // RestTemplateのGETメソッド User user = restTemplate.getForObject(url, User.class); // 3.ユーザー情報をカプセル化する order.setUser(user); // 4.戻る return order; } } ","date":"2024-02-25T17:56:54+08:00","permalink":"https://blog.yexca.net/ja/archives/158/","title":"Hi SpringCloud"},{"content":" 📢 この記事は gemini-3-flash-preview によって翻訳されました Redisの基礎：この記事\nRedis分散キャッシュ： https://blog.yexca.net/ja/archives/225/ Redisはメモリベースのkey-value構造のデータベースで、インターネット技術の分野で最も広く使われているストレージミドルウェアなんだ。\n公式サイト： https://redis.io 中国語サイト： https://www.redis.net.cn/ Redisはメモリにデータを保存するから読み書きのパフォーマンスがすごく高くて、ホットデータ（商品情報、ニュース、お知らせとか）の保存に向いているよ。C言語で開発されたオープンソースの高性能なキーバリューストアで、扱える値（value）の型が豊富なことから「構造化されたNoSQL（Not Only SQL）」データベースとも呼ばれているんだ。\nNoSQLは非リレーショナルデータベースの総称で、リレーショナルデータベースを置き換えるものではなく、それを補完するものとして使われるよ。\nリレーショナルデータベース (RDBMS)：\nMySQL Oracle DB2 SQLServer 非リレーショナルデータベース (NoSQL)：\nRedis MongoDB MemCached Redisのダウンロード・インストールと実行 ダウンロード先：\nWindows: https://github.com/microsoftarchive/redis/releases Linux: https://download.redis.io/releases/ 中国向けミラー: http://www.redis.cn/download.html Windows版は解凍するだけで使えるよ。Linux版の手順はこんな感じ：\n解凍する：tar -zxvf redis-4.0.0.tar.gz -C /usr/local 依存環境をインストールする：yum install gcc-c++ インストールディレクトリに入ってコンパイルする：make redisのsrcディレクトリに入ってインストールする：make install 関連ファイルの解説：\n/usr/local/redis-4.0.0/src/redis-server：Redisサーバーの起動スクリプト /usr/local/redis-4.0.0/src/redis-cli：Redisクライアントのスクリプト /usr/local/redis-4.0.0/redis.conf：Redisの設定ファイル サーバーの起動について。Windows版を例にすると、起動コマンドはこれ：\n1 redis-server.exe redis.windows.conf デフォルトのポート番号は6379で、パスワードは設定されていないよ。起動したらクライアントで接続できる。\nコマンドラインでの接続 redis-cli.exe を使って接続するよ。\n1 redis-cli.exe -h ip -p port -a password 省略した場合は 127.0.0.1:6379 が使われるよ。\n設定ファイル (redis.windows.conf) を書き換えてパスワードを設定することもできる。\n1 requirepass 123456 書き換えた後は再起動すれば有効になるよ。\nGUIツールでの接続 Github： https://github.com/qishibo/AnotherRedisDesktopManager ダウンロードしてインストールしたら、新規接続を作成して情報を入力すれば接続できるよ。\nDockerでのデプロイ イメージのプル\n1 docker pull redis 設定ファイルの取得。対応するバージョンをダウンロードして中身を取り出せばOK。Linuxなら redis.conf だね。\nRedisのデータマッピング用フォルダを作成する。例えばこんな感じ：\n1 2 mkdir /home/redis mkdir /home/redis/data 設定ファイルを修正して、デプロイ先のサーバーに送る。例えば Windows から Linux へ scp で送るなら：\n1 scp pathOfFile root@IP:/PathOfFile 起動\n1 docker run -p 6379:6379 --name redis -v /home/redis/redis.conf:/etc/redis/redis.conf -v /home/redis/data:/data -d redis redis-server /etc/redis/redis.conf 参考資料： https://cloud.tencent.com/developer/article/1670205 Redisのデータ型 Redisのキー（key）は文字列型だけど、バリュー（value）にはよく使われる5つのデータ型があるよ。\n文字列 (string)：普通の文字列 ハッシュ (hash)：連想配列みたいなもの リスト (list)：挿入順に並ぶ。重複要素OK セット (set)：順序のない集合。重複要素NG ソート済みセット (sorted set/zset)：各要素にスコア (score) が紐付いていて、スコア順に並ぶ Redisのよく使うコマンド Redisはコマンドの大文字・小文字を区別しないよ。\n文字列操作のよく使うコマンド：\n1 2 3 4 5 6 7 8 # 指定したキーの値をセット SET key value # 指定したキーの値を取得 GET key # 指定したキーの値をセットし、有効期限をseconds秒に設定 SETEX key seconds value # キーが存在しない場合のみ、値をセット SETNX key value hashは文字列型のフィールド（field）と値（value）のマップで、オブジェクトを保存するのにぴったりなんだ。よく使うコマンド：\n1 2 3 4 5 6 7 8 9 10 # ハッシュ表 key の field に value をセット HSET key field value # ハッシュ表に保存されている指定フィールドの値を取得 HGET key field # ハッシュ表に保存されている指定フィールドを削除 HDEL key field # ハッシュ表にある全フィールドを取得 HKEYS key # ハッシュ表にある全値を取得 HVALS key リストは単純な文字列のリストで、挿入順に並ぶよ。よく使うコマンド：\n1 2 3 4 5 6 7 8 9 10 11 # 1つまたは複数の値をリストの先頭に挿入 LPUSH key value1 [value2] # リストの指定範囲の要素を取得 LRANGE key start stop # リストの最後の要素を取り出して取得 RPOP key # リストの長さを取得 LLEN key # リストの最後の要素を取り出して取得。 # リストが空なら要素が見つかるかタイムアウトするまでブロックする BRPOP key1 [key2] timeout キュー（Queue）みたいに、先入れ先出し（FIFO）の動きだね。\nセットは文字列型の順序のない集合で、メンバーは一意だよ。よく使うコマンド：\n1 2 3 4 5 6 7 8 9 10 11 12 # 集合に1つまたは複数のメンバーを追加 SADD key member1 [member2] # 集合の全メンバーを返す SMEMBERS key # 集合のメンバー数を取得 SCARD key # 指定した全集合の積集合（共通部分）を返す SINTER key2 [key2] # 指定した全集合の和集合を返す SUNION key1 [key2] # 集合から1つまたは複数のメンバーを削除 SREM key member1 [member2] ソート済みセットは文字列要素の集合で、各メンバーに double 型のスコアが紐付いているよ。よく使うコマンド：\n1 2 3 4 5 6 7 8 # ソート済みセットに1つまたは複数のメンバーを追加 ZADD key score1 member1 [score2 member2] # インデックス範囲で指定した範囲のメンバーを返す ZRANGE key start stop [WITHSCORES] # 指定したメンバーのスコアに increment を加算 ZINCRBY key increment member # ソート済みセットから1つまたは複数のメンバーを削除 ZREM key member1 [member2] 各データ型専用のコマンド以外に、どの型でも使える共通コマンドもあるよ：\n1 2 3 4 5 6 7 8 # パターン(pattern)に一致する全キーを探す KEYS pattern # patternには * とかが使える # 指定したキーが存在するか確認 EXISTS key # キーに保存されている値の型を返す TYPE key # キーが存在すれば削除 DEL key JavaでRedisを操作する JDBCを使ってMySQLを操作するのと同じように、RedisもJava用のクライアントを使って操作する必要があるんだ。\nRedisのJavaクライアントはたくさんあるけど、有名なのはこのあたり：\nJedis Lettuce Spring Data Redis Jedisはカプセル化が一番しっかりしていて、Redisのコマンドと同じ感覚で使えるから公式でも推奨されているよ。Lettuceはスレッド呼び出しの扱いが上手くてパフォーマンスが良いのが特徴。Springはこれらのクライアントを統合してSpring Data Redisを提供していて、Spring Bootプロジェクトなら専用のStarter（spring-boot-starter-data-redis）も用意されているよ。\nSpring Data Redis Spring Data RedisはSpringプロジェクトの一部で、簡単な設定だけでRedisサーバーにアクセスできるように、低レイヤーのライブラリを高度にカプセル化してくれているんだ。SpringプロジェクトでRedisを楽に扱いたいならこれを使おう。サイト： https://spring.io/projects/spring-data-redis Mavenの依存関係：\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-data-redis\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; Spring Data Redisでは、RedisTemplate という高度にカプセル化されたクラスが提供されていて、操作のタイプごとに専用のインターフェースにまとめられているよ：\nValueOperations：string型のデータ操作 SetOperations：set型のデータ操作 ZSetOperations：zset型のデータ操作 HashOperations：hash型のデータ操作 ListOperations：list型のデータ操作 Redisデータソースの設定（設定ファイル）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # application spring: profiles: active: dev redis: host: ${sky.redis.host} port: ${sky.redis.port} password: ${sky.redis.password} database: ${sky.redis.database} # -dev sky: redis: host: localhost port: 6379 password: 123456 # どのデータベースを使うか。指定しない場合は 0 database: 10 Redisはデフォルトで16個のデータベース（0-15）を持っていて、設定でその数を変更することもできるよ。\n設定クラスを書いて、RedisTemplateオブジェクトを作成する：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 @Configuration @Slf4j public class RedisConfiguration { @Bean public RedisTemplate redisTemplate(RedisConnectionFactory redisConnectionFactory){ log.info(\u0026#34;Redisオブジェクトの作成を開始します\u0026#34;); RedisTemplate redisTemplate = new RedisTemplate(); // redisの接続ファクトリをセット redisTemplate.setConnectionFactory(redisConnectionFactory); // redisキーのシリアライザをセット redisTemplate.setKeySerializer(new StringRedisSerializer()); return redisTemplate; } } この設定クラスは必須じゃないんだ。SpringBootが自動で RedisTemplate を自動構成してくれるけど、デフォルトのシリアライザが JdkSerializationRedisSerializer だから、Redisに保存されたデータが元のデータと少し違って見えることがあるんだよね。\n文字列型のデータ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @SpringBootTest public class RedisTest { @Autowired private RedisTemplate redisTemplate; @Test public void testString(){ // set redisTemplate.opsForValue().set(\u0026#34;name\u0026#34;, \u0026#34;Tom\u0026#34;); // get String name =(String) redisTemplate.opsForValue().get(\u0026#34;name\u0026#34;); System.out.println(name); // setex redisTemplate.opsForValue().set(\u0026#34;code\u0026#34;, \u0026#34;1234\u0026#34;, 2, TimeUnit.MINUTES); // setnx redisTemplate.opsForValue().setIfAbsent(\u0026#34;lock\u0026#34;,\u0026#34;1\u0026#34;); redisTemplate.opsForValue().setIfAbsent(\u0026#34;lock\u0026#34;,\u0026#34;2\u0026#34;); } } ハッシュ型のデータ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @Test public void testHash(){ HashOperations hashOperations = redisTemplate.opsForHash(); // hset hashOperations.put(\u0026#34;100\u0026#34;, \u0026#34;name\u0026#34;, \u0026#34;Jerry\u0026#34;); hashOperations.put(\u0026#34;100\u0026#34;, \u0026#34;age\u0026#34;, \u0026#34;20\u0026#34;); // hget String name =(String) hashOperations.get(\u0026#34;100\u0026#34;, \u0026#34;name\u0026#34;); System.out.println(name); // hkeys Set keys = hashOperations.keys(\u0026#34;100\u0026#34;); System.out.println(keys); // hvals List values = hashOperations.values(\u0026#34;100\u0026#34;); System.out.println(values); // hdel hashOperations.delete(\u0026#34;100\u0026#34;, \u0026#34;name\u0026#34;); } リスト型のデータ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Test public void testList(){ ListOperations listOperations = redisTemplate.opsForList(); // lpush listOperations.leftPushAll(\u0026#34;mylist\u0026#34;, \u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;); listOperations.leftPush(\u0026#34;mylist\u0026#34;, \u0026#34;d\u0026#34;); // lrange List mylist = listOperations.range(\u0026#34;mylist\u0026#34;, 0, -1); System.out.println(mylist); // rpop listOperations.rightPop(\u0026#34;mylist\u0026#34;); // llen Long size = listOperations.size(\u0026#34;mylist\u0026#34;); System.out.println(size); } セット型のデータ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 @Test public void testSet(){ SetOperations setOperations = redisTemplate.opsForSet(); // sadd setOperations.add(\u0026#34;set1\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;,\u0026#34;c\u0026#34;,\u0026#34;d\u0026#34;); setOperations.add(\u0026#34;set2\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;,\u0026#34;x\u0026#34;,\u0026#34;y\u0026#34;); // smembers Set members = setOperations.members(\u0026#34;set1\u0026#34;); System.out.println(members); // scard Long size = setOperations.size(\u0026#34;set1\u0026#34;); System.out.println(size); // sinter Set intersect = setOperations.intersect(\u0026#34;set1\u0026#34;, \u0026#34;set2\u0026#34;); System.out.println(intersect); // sunion Set union = setOperations.union(\u0026#34;set1\u0026#34;, \u0026#34;set2\u0026#34;); System.out.println(union); // srem setOperations.remove(\u0026#34;set1\u0026#34;, \u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;); } ソート済みセット型のデータ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Test public void testZset(){ ZSetOperations zSetOperations = redisTemplate.opsForZSet(); // zadd zSetOperations.add(\u0026#34;zset1\u0026#34;, \u0026#34;a\u0026#34;, 10); zSetOperations.add(\u0026#34;zset1\u0026#34;, \u0026#34;b\u0026#34;, 12); zSetOperations.add(\u0026#34;zset1\u0026#34;, \u0026#34;c\u0026#34;, 9); // zrange Set zset = zSetOperations.range(\u0026#34;zset1\u0026#34;, 0, -1); System.out.println(zset); // zincrby zSetOperations.incrementScore(\u0026#34;zset1\u0026#34;, \u0026#34;c\u0026#34;, 10); // zrem zSetOperations.remove(\u0026#34;zset1\u0026#34;, \u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;); } 共通コマンドの操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @Test public void testCommon(){ // keys Set keys = redisTemplate.keys(\u0026#34;*\u0026#34;); System.out.println(keys); // exists Boolean name = redisTemplate.hasKey(\u0026#34;name\u0026#34;); System.out.println(name); // type for (Object key : keys) { DataType type = redisTemplate.type(key); System.out.println(type.name()); } // del redisTemplate.delete(\u0026#34;set2\u0026#34;); } ","date":"2024-02-23T16:40:34+08:00","permalink":"https://blog.yexca.net/ja/archives/157/","title":"Redis"},{"content":" この記事の一部は機械翻訳を使ったよ\nGolang シリーズ\nHello GoLang: https://blog.yexca.net/ja/ja/archives/154 GoLang (var and const) 変数と定数: https://blog.yexca.net/ja/ja/archives/155 GoLang (func) 関数: この記事\nGoLang (slice and map) スライス: https://blog.yexca.net/ja/ja/archives/160 GoLang (OOP) オブジェクト指向: https://blog.yexca.net/ja/ja/archives/162 GoLang (reflect) リフレクション: https://blog.yexca.net/ja/ja/archives/204 GoLang (struct tag) 構造タグ: https://blog.yexca.net/ja/ja/archives/205 GoLang (goroutine) ゴルーチン: https://blog.yexca.net/ja/ja/archives/206 GoLang (channel) チャンネル: https://blog.yexca.net/ja/ja/archives/207 複数の戻り値 Go 関数は複数の値を返すことができる\n匿名の戻り 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package main import \u0026#34;fmt\u0026#34; func swap(a, b int) (int, int) { return b, a } func main() { var x, y = swap(10, 20) fmt.Println(x, y) } /* 出力 * 20 10 */ パラメータ名を返す 1 2 3 4 5 6 7 8 9 10 11 12 13 14 package main import \u0026#34;fmt\u0026#34; func swap(a, b int) (x int, y int) { x = b y = a return } func main() { var x, y = swap(10, 20) fmt.Println(x, y) } 上記の戻り値は同じ型であり、組み合わせることができる\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package main import \u0026#34;fmt\u0026#34; func swap(a, b int) (x, y int) { x = b y = a // 如果不给 x,y 赋值，默认为0 return } func main() { var x, y = swap(10, 20) fmt.Println(x, y) } init と main init はどのパッケージにも、あるいは同じパッケージに複数回出現することができますが、1 つだけ記述することをお勧めします。\nmain は package main 内にのみ存在でき、パッケージにはこの関数がなければなりません。\nこれら 2 つの関数は予約関数であり、定義時にパラメーターや戻り値を持つことはできません。\nGo プログラムは自動的に init() と main() を呼び出す\nプログラムの実行 プログラムの初期化と実行はすべて main パッケージから始まります。同じパッケージが複数のパッケージでインポートされた場合でも、インポートされるのは 1 回だけです。次の図は実行順序を示しています。\n例\n次の構造を想定する\n1 2 3 4 5 6 hello -- InitLib1 -- lib1.go -- InitLib2 -- lib2.go main.go 内容は以下のとおりです\nlib1.go\n1 2 3 4 5 6 7 package InitLib1 import \u0026#34;fmt\u0026#34; func init() { fmt.Println(\u0026#34;lib1 init\u0026#34;) } lib2.go\n1 2 3 4 5 6 7 package InitLib2 import \u0026#34;fmt\u0026#34; func init() { fmt.Println(\u0026#34;lib2 init\u0026#34;) } main.go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package main import ( \u0026#34;fmt\u0026#34; // ここでのアンダースコアはパッケージの別名です。別名でない場合はインポートは呼び出されず、コンパイルは成功しません。 _ \u0026#34;hello/InitLib1\u0026#34; _ \u0026#34;hello/InitLib2\u0026#34; ) func init() { fmt.Println(\u0026#34;main init\u0026#34;) } func main() { fmt.Println(\u0026#34;main\u0026#34;) } 運用結果\n1 2 3 4 lib1 init lib2 init main init main Lib1 パッケージを Lib2 にインポートすると、main コードは変更されません。\nlib1.go\n1 2 3 4 5 6 7 8 9 10 package InitLib1 import ( \u0026#34;fmt\u0026#34; _ \u0026#34;hello/InitLib2\u0026#34; ) func init() { fmt.Println(\u0026#34;lib1 init\u0026#34;) } main 結果を実行\n1 2 3 4 lib2 init lib1 init main init main lib2 は 1 回だけ出現する\n他のパッケージ関数を呼び出す 上記の例では、エイリアスとして _ を使用していますが、これは匿名であり、対応するパッケージ メソッドを呼び出すことはできません。\nlib1 に関数を追加する\nlib1.go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package InitLib1 import ( \u0026#34;fmt\u0026#34; //_ \u0026#34;hello/InitLib2\u0026#34; ) // 他のパッケージから呼び出す前に、最初の文字を大文字にする必要があります func Lib1Test() { fmt.Println(\u0026#34;lib1 test\u0026#34;) } func init() { fmt.Println(\u0026#34;lib1 init\u0026#34;) } main.go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package main import ( \u0026#34;fmt\u0026#34; // パッケージにエイリアスを付ける mylib1 \u0026#34;hello/InitLib1\u0026#34; _ \u0026#34;hello/InitLib2\u0026#34; ) func main() { // alias.method 経由で呼び出す mylib1.Lib1Test() fmt.Println(\u0026#34;main\u0026#34;) } /* * 出力 * lib1 init * lib2 init * lib1 test * main */ または . を直接使用して\nmain.go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 package main import ( \u0026#34;fmt\u0026#34; // エイリアスが . に変更されました。 . \u0026#34;hello/InitLib1\u0026#34; _ \u0026#34;hello/InitLib2\u0026#34; ) func main() { // 直接使用する Lib1Test() fmt.Println(\u0026#34;main\u0026#34;) } 推奨されません。 2 つのパッケージに同じ名前の関数がある場合、あいまいさが生じます。\nポインタ C ポインタに似ている\n数を呼び出すときにパラメータを渡す方法は、値渡しとポインタ（参照）渡しの 2 つがあります。デフォルトでは、この記事の最初のコードのように値の受け渡しが使用されます。\n変数に対応するメモリアドレスを取得するには \u0026amp; を使用します\n1 2 3 4 5 6 7 8 9 10 package main import ( \u0026#34;fmt\u0026#34; ) func main() { var a int fmt.Printf(\u0026#34;%x\u0026#34;, \u0026amp;a) } 参照渡しはメモリアドレスを関数に渡し、関数の変更は実際のパラメータに影響します。これはスワップ関数でもあり、今回はポインタを使用しています。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package main import \u0026#34;fmt\u0026#34; func swap(a, b *int) { var tmp = *a *a = *b *b = tmp } func main() { x, y := 10, 20 swap(\u0026amp;x, \u0026amp;y) fmt.Println(\u0026#34;x =\u0026#34;, x, \u0026#34;y =\u0026#34;, y) } defer defer ステートメントは、遅延関数と呼ばれる関数の呼び出しをスケジュールするために使用されます。その機能は次のとおりです。\n占有されているリソースを解放する 例外をキャッチして処理する 出力ログ try\u0026hellip;catch\u0026hellip;finally の finally に似ています\nファイルのオープン/クローズ、ロックの取得/解放、接続/切断などのペア操作を処理するためによく使用され、エラーや早期復帰が発生した場合でもリソースが適切に解放され、実行が保証されます。\n関数内に複数の defer ステートメントがある場合、それらはスタックと同様に LIFO (後入れ先出し) の順序で実行されます。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package main import \u0026#34;fmt\u0026#34; func deferDemo() { defer fmt.Println(\u0026#34;1\u0026#34;) defer fmt.Println(\u0026#34;2\u0026#34;) defer fmt.Println(\u0026#34;3\u0026#34;) defer fmt.Println(\u0026#34;4\u0026#34;) } func main() { deferDemo() } /* * 出力 * 4 * 3 * 2 * 1 */ recover ランタイム パニック例外がトリガーされると、プログラムはクラッシュします。recover は、例外をキャプチャする Java の try\u0026hellip;catch と同様に、ランタイム パニックを「インターセプト」するために使用される組み込み関数です。\nrecover は defer によって呼び出される関数内でのみ有効です\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 package main import \u0026#34;fmt\u0026#34; func deferDemo(i int) { var arr [10]int // エラーインターセプションはエラーの前に設定されます defer func() { // エラーメッセージを傍受するように recover を設定する err := recover() if err != nil { fmt.Println(err) } }() arr[i] = 10 } func main() { deferDemo(10) fmt.Println(\u0026#34;main code\u0026#34;) } /* * 出力 * runtime error: index out of range [10] with length 10 * main code */ ","date":"2024-02-22T04:47:28+08:00","permalink":"https://blog.yexca.net/ja/archives/156/","title":"GoLang 関数"},{"content":" この記事の一部は機械翻訳を使ったよ\nGolang シリーズ\nHello GoLang: https://blog.yexca.net/ja/ja/archives/154 GoLang (var and const) 変数と定数: この記事\nGoLang (func) 関数: https://blog.yexca.net/ja/archives/ja/156 GoLang (slice and map) スライス: https://blog.yexca.net/ja/ja/archives/160 GoLang (OOP) オブジェクト指向: https://blog.yexca.net/ja/ja/archives/162 GoLang (reflect) リフレクション: https://blog.yexca.net/ja/ja/archives/204 GoLang (struct tag) 構造タグ: https://blog.yexca.net/ja/ja/archives/205 GoLang (goroutine) ゴルーチン: https://blog.yexca.net/ja/ja/archives/206 GoLang (channel) チャンネル: https://blog.yexca.net/ja/ja/archives/207 変数 変数は通常 var キーワードを使用して宣言されます\n単一変数 タイプを定義する 初期値が指定されていない場合、デフォルトは 0 です。\n1 2 3 4 5 6 7 8 package main import \u0026#34;fmt\u0026#34; func main() { var a int fmt.Println(\u0026#34;a =\u0026#34;, a) } 初期値を指定します。a は 100 です。\n1 2 3 4 5 6 7 8 package main import \u0026#34;fmt\u0026#34; func main() { var a int = 100 fmt.Println(\u0026#34;a =\u0026#34;, a) } 省略タイプ 宣言時に型がわからない場合、Go は変数の型を自動的に決定します。\n1 2 3 4 5 6 7 8 9 10 11 12 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) func main() { var a = 100 fmt.Println(\u0026#34;a =\u0026#34;, a) fmt.Printf(\u0026#34;Type of a = %s\u0026#34;, reflect.TypeOf(a)) } := 省略に応じて型が自動的に決定され、:= を使用して変数を直接宣言できます。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) func main() { p := 3.14 fmt.Println(\u0026#34;p =\u0026#34;, p) fmt.Printf(\u0026#34;Type of p is %s\u0026#34;, reflect.TypeOf(p)) } /* * 出力 * p = 3.14 * Type of p is float64 */ 多変量 同じタイプ 1 2 3 4 5 6 7 8 9 package main import \u0026#34;fmt\u0026#34; func main() { var a, b int fmt.Println(\u0026#34;a =\u0026#34;, a) fmt.Println(\u0026#34;b =\u0026#34;, b) } 同じタイプの割り当て 1 2 3 4 5 6 7 8 9 package main import \u0026#34;fmt\u0026#34; func main() { var a, b int = 100, 200 fmt.Println(\u0026#34;a =\u0026#34;, a) fmt.Println(\u0026#34;b =\u0026#34;, b) } 異なるタイプ 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) func main() { var a, b = 100, 3.14 fmt.Println(\u0026#34;a =\u0026#34;, a) fmt.Printf(\u0026#34;Type of a is %s\\n\u0026#34;, reflect.TypeOf(a)) fmt.Println(\u0026#34;b =\u0026#34;, b) fmt.Printf(\u0026#34;Type of b is %s\u0026#34;, reflect.TypeOf(b)) } /* * 出力 * a = 100 * Type of a is int * b = 3.14 * Type of b is float64 */ 異なるタイプ 2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) func main() { a, b := 100, \u0026#34;Hello\u0026#34; fmt.Println(\u0026#34;a =\u0026#34;, a) fmt.Printf(\u0026#34;Type of a is %s\\n\u0026#34;, reflect.TypeOf(a)) fmt.Println(\u0026#34;b =\u0026#34;, b) fmt.Printf(\u0026#34;Type of b is %s\u0026#34;, reflect.TypeOf(b)) } Go の文字列型は、基になる配列へのポインタと長さを含む構造体です。これら 2 つの部分はそれぞれ 8 バイトなので、文字列型のサイズは 16 バイトになります。\nunsafe.Sizeof()関数を使用して、タイプ占有率が見られます。\nグローバル変数 グローバル変数は := を使用して宣言することはできません\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) var a, b int func main() { fmt.Println(\u0026#34;a =\u0026#34;, a) fmt.Printf(\u0026#34;Type of a is %s\\n\u0026#34;, reflect.TypeOf(a)) fmt.Println(\u0026#34;b =\u0026#34;, b) fmt.Printf(\u0026#34;Type of b is %s\u0026#34;, reflect.TypeOf(b)) } または、グローバル変数に一般的に使用される分解を使用します。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) var ( a int = 1 b string = \u0026#34;Go\u0026#34; ) func main() { fmt.Println(\u0026#34;a =\u0026#34;, a) fmt.Printf(\u0026#34;Type of a is %s\\n\u0026#34;, reflect.TypeOf(a)) fmt.Println(\u0026#34;b =\u0026#34;, b) fmt.Printf(\u0026#34;Type of b is %s\u0026#34;, reflect.TypeOf(b)) } 定数 定数は通常、const キーワードを使用して定義されます。\n定義 1 2 3 4 5 6 7 8 package main import \u0026#34;fmt\u0026#34; func main() { const c int = 9 fmt.Println(\u0026#34;c = \u0026#34;, c) } タイプを省略することもできます\n1 2 3 4 5 6 7 8 package main import \u0026#34;fmt\u0026#34; func main() { const c = 9 fmt.Println(\u0026#34;c = \u0026#34;, c) } 列挙 定数定義は列挙に使用できる\n1 2 3 4 5 6 7 8 9 package main func main() { const ( BEIJING = 0 SHANGHAI = 1 SHENZHEN = 2 ) } iota 自己増加 上記の列挙は 0 から始まり、増分で増加します。代わりに iota を使用できます。\n1 2 3 4 5 6 7 8 9 10 11 12 13 package main import \u0026#34;fmt\u0026#34; func main() { const ( BEIJING = iota // 0 SHANGHAI // 1 SHENZHEN // 2 ) fmt.Println(BEIJING, SHANGHAI, SHENZHEN) } iota は式の中で使用できますが、通常は自動増分に使用されます\n","date":"2024-02-20T06:41:18+08:00","permalink":"https://blog.yexca.net/ja/archives/155/","title":"GoLang 変数と定数"},{"content":" この記事の一部は機械翻訳を使ったよ\nGolang シリーズ\nHello GoLang: この記事\nGoLang (var and const) 変数と定数: https://blog.yexca.net/ja/ja/archives/155 GoLang (func) 関数: https://blog.yexca.net/ja/ja/archives/156 GoLang (slice and map) スライス: https://blog.yexca.net/ja/ja/archives/160 GoLang (OOP) オブジェクト指向: https://blog.yexca.net/ja/ja/archives/162 GoLang (reflect) リフレクション: https://blog.yexca.net/ja/ja/archives/204 GoLang (struct tag) 構造タグ: https://blog.yexca.net/ja/ja/archives/205 GoLang (goroutine) ゴルーチン: https://blog.yexca.net/ja/ja/archives/206 GoLang (channel) チャンネル: https://blog.yexca.net/ja/ja/archives/207 Go のダウンロード： https://go.dev/dl/ JetBrains GoLand： https://www.jetbrains.com/go/ Go の紹介 Go は直接コンパイルして直接実行し、デプロイできる静的型付け言語です。\n1 2 3 4 5 6 7 # 直接実行 go run hello.go # コンパイル go build hello.go # コンパイル後に実行 ./hello Go の応用例\n(1)、クラウドコンピューティングインフラ\n代表的なプロジェクト：docker、kubernetes、etcd、consul、cloudflare CDN、\u0026ldquo;七牛云存储(中国語)\u0026ldquo;など\n(2)、基本的なバックエンドソフトウェア\n代表的なプロジェクト：tidb、influxdb、cockroachdb など\n(3)、マイクロサービス\n代表的なプロジェクト：go-kit、micro、monzo bank的typhon、bilibili など\n(4)、インターネットインフラ\n代表的なプロジェクト：Ethereum、hyperledger など\nHello Go 1 2 3 4 5 6 7 8 9 10 11 package main // パッケージ名を定義する /* * ソースファイルの最初の非コメント行で、ファイルが属するパッケージを指定する必要があります。 * main は独立して実行可能なプログラムを表します。すべての Go アプリケーションには、main という名前のパッケージが含まれています。 */ import \u0026#34;fmt\u0026#34; // IO フォーマットの関数を実装するために fmt パッケージをインポートします func main(){ // 関数 fmt.println(\u0026#34;Hello Go\u0026#34;) } 一般的に、main 関数は起動後に最初に実行される関数です。init関数がある場合は、init 関数が最初に実行されます。\n関数を定義するときは { が関数名と同じ行になければなりません\n","date":"2024-02-19T07:58:37+08:00","permalink":"https://blog.yexca.net/ja/archives/154/","title":"Hello GoLang"},{"content":" 📢 この記事は gemini-3-flash-preview によって翻訳されました これ、いつ書いた記事だっけ（\nXfce グループがあるか確認する 1 yum grouplist もしなかったら、追加の yum リポジトリをインストールする必要があるよ。\n1 yum install epel-release -y X Window system のインストール 1 yum groupinstall \u0026#34;X Window system\u0026#34; Xfce のインストール 1 yum groupinstall xfce 中国語フォント (楷書体) のインストール 1 yum install cjkuni-ukai-fonts Xfce デスクトップを起動する 1 systemctl isolate graphical.target 参考記事 CentOS 7安装Xfce桌面环境过程_qq_28641401的博客-CSDN博客 ","date":"2024-02-17T22:51:34+08:00","permalink":"https://blog.yexca.net/ja/archives/153/","title":"CentOS 7 に Xfce をインストールする"},{"content":" 📢 この記事は gemini-2.5-flash によって翻訳されました 旧正月おめでとう！\n流れはここを見てね： https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/login.html フロントエンドで認証コードを取得したら、 https://api.weixin.qq.com/sns/jscode2session にリクエストを送って、session_keyとopenidを手に入れるんだ。\nWeChatのリクエストAPIはこちら： https://developers.weixin.qq.com/miniprogram/dev/OpenApiDoc/user-login/code2Session.html 分析と設計 API設計 リクエストパス：/user/user/login\nリクエストメソッド：POST\nリクエストパラメータ：code String (WeChatユーザーの認証コード)\n返却データ：\nid integer (ユーザーID) openid (WeChat openid) token (JWTトークン) データベーステーブル設計 ユーザーがミニプログラムを初めて使うと自動的に登録されて、関連情報がuserテーブルに保存されるよ。\nフィールド名 データ型 説明 id bigint 主キー、自動インクリメント openid varchar(45) WeChatユーザーのユニークな識別子 name varchar(32) ユーザー名 phone varchar(11) 電話番号 gender varchar(2) 性別 id_number varchar(18) 身分証明書番号 avatar varchar(500) WeChatユーザーのアバターパス create_time datetime 登録時間 個人の身分で登録したミニプログラムだと、WeChatユーザーの電話番号は取得できないからね。\nプログラム設定 まずはWeChatログインに必要なパラメータを設定するよ。\napplication-dev.yml\n1 2 3 4 sky: wechat: appid: your_appid secret: your_secret application.yml\n1 2 3 4 sky: wechat: appid: ${sky.wechat.appid} secret: ${sky.wechat.secret} WeChatユーザーにJWTトークンを生成する際に使う設定項目だよ。\n1 2 3 4 5 6 sky: jwt: # ユーザー関連 user-secret-key: key user-ttl: 7200000 user-token-name: authentication Java ビジネスロジックコード controller\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 @RestController @RequestMapping(\u0026#34;/user/user\u0026#34;) @Api(tags = \u0026#34;ユーザー関連API\u0026#34;) @Slf4j public class UserController { @Autowired private UserService userService; @Autowired private JwtProperties jwtProperties; @PostMapping(\u0026#34;/login\u0026#34;) @ApiOperation(\u0026#34;WeChatログイン\u0026#34;) public Result\u0026lt;UserLoginVO\u0026gt; login(@RequestBody UserLoginDTO userLoginDTO){ log.info(\u0026#34;WeChatユーザーログイン：{}\u0026#34;, userLoginDTO.getCode()); // WeChatログイン User user = userService.wxlogin(userLoginDTO); // WeChatユーザーのためにJWTトークンを生成する HashMap\u0026lt;String, Object\u0026gt; claims = new HashMap\u0026lt;\u0026gt;(); claims.put(JwtClaimsConstant.USER_ID, user.getId()); String token = JwtUtil.createJWT(jwtProperties.getUserSecretKey(), jwtProperties.getUserTtl(), claims); UserLoginVO userLoginVO = UserLoginVO.builder() .id(user.getId()) .openid(user.getOpenid()) .token(token) .build(); return Result.success(userLoginVO); } } service\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 @Service @Slf4j public class UserServiceImpl implements UserService { // WeChat API public static final String WX_LOGIN = \u0026#34;https://api.weixin.qq.com/sns/jscode2session\u0026#34;; @Autowired private WeChatProperties weChatProperties; @Autowired private UserMapper userMapper; @Override public User wxlogin(UserLoginDTO userLoginDTO) { String openid = getOpenid(userLoginDTO.getCode()); // openidが有効かどうかのチェック if (openid == null){ throw new LoginFailedException(MessageConstant.LOGIN_FAILED); } // 新しいユーザーかどうかをチェック User user = userMapper.getByOpenid(openid); // もし新しいユーザーだったら、自動的に登録する if (user == null){ user = User.builder() .openid(openid) .createTime(LocalDateTime.now()) .build(); userMapper.insert(user); } return user; } // WeChat APIを呼び出して、ユーザーのopenidを取得する private String getOpenid(String code){ Map\u0026lt;String,String\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(\u0026#34;appid\u0026#34;, weChatProperties.getAppid()); map.put(\u0026#34;secret\u0026#34;, weChatProperties.getSecret()); map.put(\u0026#34;js_code\u0026#34;, code); map.put(\u0026#34;grant_type\u0026#34;, \u0026#34;authorization_code\u0026#34;); String json = HttpClientUtil.doGet(WX_LOGIN, map); JSONObject jsonObject = JSON.parseObject(json); String openid = jsonObject.getString(\u0026#34;openid\u0026#34;); return openid; } } Mapper\n1 2 3 4 5 6 7 @Mapper public interface UserMapper { @Select(\u0026#34;select * from user where openid = #{openid}\u0026#34;) User getByOpenid(String openid); void insert(User user); } Mapper XML\n1 2 3 4 5 6 7 8 9 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34; \u0026gt; \u0026lt;mapper namespace=\u0026#34;com.sky.mapper.UserMapper\u0026#34;\u0026gt; \u0026lt;insert id=\u0026#34;insert\u0026#34;\u0026gt; insert into user(openid, name, phone, sex, id_number, avatar, create_time) VALUES (#{openid}, #{name}, #{phone}, #{sex}, #{idNumber}, #{avatar}, #{createTime}) \u0026lt;/insert\u0026gt; \u0026lt;/mapper\u0026gt; インターセプター ユーザーからのリクエストを一括でインターセプトして、JWTの検証を行うよ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 @Component @Slf4j public class JwtTokenUserInterceptor implements HandlerInterceptor { @Autowired private JwtProperties jwtProperties; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { // インターセプトのタイプがコントローラーなのか、他のリソースなのかを判断する if(!(handler instanceof HandlerMethod)){ // 現在のインターセプトが動的メソッドじゃない場合、そのまま通す return true; } // リクエストからトークンを取得する String token = request.getHeader(jwtProperties.getUserTokenName()); // トークンの検証 try { log.info(\u0026#34;JWT検証：{}\u0026#34;, token); Claims claims = JwtUtil.parseJWT(jwtProperties.getUserSecretKey(), token); Long userId = Long.valueOf(claims.get(JwtClaimsConstant.USER_ID).toString()); log.info(\u0026#34;現在のユーザーID：{}\u0026#34;, userId); BaseContext.setCurrentId(userId); // 検証成功 return true; }catch (Exception ex){ // 検証失敗 return false; } } } WebMvcConfigurationにインターセプターを登録する\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Autowired private JwtTokenUserInterceptor jwtTokenUserInterceptor; /** * カスタムインターセプターを登録する * @param registry */ protected void addInterceptors(InterceptorRegistry registry) { log.info(\u0026#34;カスタムインターセプターの登録を開始するよ...\u0026#34;); //......... registry.addInterceptor(jwtTokenUserInterceptor) .addPathPatterns(\u0026#34;/user/**\u0026#34;) .excludePathPatterns(\u0026#34;/user/user/login\u0026#34;) .excludePathPatterns(\u0026#34;/user/shop/status\u0026#34;); } ","date":"2024-02-10T18:09:17+08:00","permalink":"https://blog.yexca.net/ja/archives/152/","title":"WeChatログインのバックエンド"},{"content":" 📢 この記事は gemini-2.5-flash によって翻訳されました 公式サイト： https://mp.weixin.qq.com/cgi-bin/wx ミニプログラムを開発する前に、まず登録する必要があるよ。異なる主体で登録できるけど、それによって権限も変わってくるんだ。例えば、個人で登録すると支払い機能は使えないんだよね（テストアカウントで試すことはできるけど）。\n登録が終わったら、必要な情報を設定してAppIDとAppSecretを取得してね。 開発者ツール をダウンロードして、ログインして、プロジェクトを作成するよ。\nまずは右上の「詳細」-「ローカル設定」で、「合法ドメイン、web-view(ビジネスドメイン)、TLSバージョン、およびHTTPS証明書を検証しない」にチェックを入れてね。\nミニプログラムの開発はフロントエンド開発に属していて、主にJavaScriptを使うんだ。\nミニプログラムのディレクトリ構造 ミニプログラムは、全体を記述するappと、それぞれのページを記述する複数のpageから構成されるよ。\n本体部分 3つのファイルで構成されていて、プロジェクトのルートディレクトリに置く必要があるんだ。\nファイル 役割 app.js ミニプログラムのロジック app.json ミニプログラムの共通設定 app.wxss ミニプログラムの共通スタイルシート。必須じゃないファイルで、CSSみたいなものだね。 ページ ミニプログラムには複数のページがあって、pagesディレクトリに保存されるんだ。\n各ページは4つのファイルで構成されるよ。\nファイルタイプ 必須かどうか 役割 js はい ページロジック、JavaScript wxml はい ページ構造、レイアウト、HTML json いいえ ページ設定 wxss いいえ ページスタイルシート、CSS 簡単な入門 ミニプログラムの書き方はVueに似てるんだ。\nデータバインディング wxml\n1 \u0026lt;view\u0026gt;{{title}}\u0026lt;/view\u0026gt; js\n1 2 3 4 5 Page({ data: { title: \u0026#39;Hello\u0026#39; } }) ユーザー情報の取得 wxml\n1 2 3 4 \u0026lt;view\u0026gt; \u0026lt;button type=\u0026#34;default\u0026#34; bindtap=\u0026#34;getUserInfo\u0026#34;\u0026gt;ユーザー情報を取得\u0026lt;/button\u0026gt; \u0026lt;image src=\u0026#34;{{avatarUrl}}\u0026#34; style=\u0026#34;width: 100px; height: 100px;\u0026#34;/\u0026gt;{{nickName}} \u0026lt;/view\u0026gt; js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 Page({ data: { title: \u0026#39;Hello\u0026#39;, avatarUrl: \u0026#39;\u0026#39;, nickName: \u0026#39;\u0026#39; }, getUserInfo: function(){ wx.getUserProfile({ desc: \u0026#39;ユーザー情報を取得\u0026#39;, success: (res) =\u0026gt; { console.log(res); this.setData({ avatarUrl: res.userInfo.avatarUrl, nickName: res.userInfo.nickName }) } }) } }) WeChatログイン wxml\n1 2 3 4 \u0026lt;view\u0026gt; \u0026lt;button type=\u0026#34;primary\u0026#34; bind:tap=\u0026#34;wxlogin\u0026#34;\u0026gt;WeChatログイン\u0026lt;/button\u0026gt; 認証コード：{{code}} \u0026lt;/view\u0026gt; js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 Page({ data: { code: \u0026#39;\u0026#39; }, wxlogin: function(){ wx.login({ success: (res) =\u0026gt; { console.log(\u0026#34;認証コード：\u0026#34; + res.code); this.setData({ code: res.code }) }, }) } }) WeChatログインフロー： https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/login.html HTTPリクエストの送信 wxml\n1 2 3 4 \u0026lt;view\u0026gt; \u0026lt;button type=\u0026#34;warn\u0026#34; bind:tap=\u0026#34;sendRequest\u0026#34;\u0026gt;リクエストを送信\u0026lt;/button\u0026gt; 応答結果：{{result}} \u0026lt;/view\u0026gt; js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 Page({ data: { result: \u0026#39;\u0026#39; }, sendRequest: function(){ wx.request({ url: \u0026#39;url\u0026#39;, // リクエストパス method: \u0026#39;GET\u0026#39;, // リクエスト方式 success: (res) =\u0026gt; { console.log(\u0026#34;応答結果：\u0026#34; + res.data); this.setData({ result: res.data // 応答データ }) } }) } }) コンパイルと公開 上にあるコンパイルボタンで、コンパイルが終わったら左側でプレビューできるよ。\nコード開発が終わったら、アップロードしてバージョン番号を指定するんだ。アップロードが成功したら、WeChat公式プラットフォームで審査に提出して、オンラインバージョンとして公開できるよ。\n","date":"2024-01-31T16:50:34+08:00","permalink":"https://blog.yexca.net/ja/archives/151/","title":"WeChatミニプログラムを理解しよう"},{"content":" 📢 この記事は gemini-2.5-flash によって翻訳されました はじめに HTML学習その1 - 基本: https://blog.yexca.net/ja/archives/146 HTML学習その2 - リスト、テーブル、フォーム: https://blog.yexca.net/ja/archives/150 HTML学習その3 - ウェブページのレイアウト: https://blog.yexca.net/ja/archives/195 リスト リストには順序なしリスト、順序付きリスト、定義リストがあるよ。\n順序なしリスト unordered list -\u0026gt; list\n1 2 3 4 5 \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;項目1\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;項目2\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;項目3\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; 表示はこんな感じ\n項目1 項目2 項目3 順序付きリスト ordered list -\u0026gt; list\n1 2 3 4 5 \u0026lt;ol\u0026gt; \u0026lt;li\u0026gt;項目1\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;項目2\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;項目3\u0026lt;/li\u0026gt; \u0026lt;/ol\u0026gt; 表示はこんな感じ\n項目1 項目2 項目3 定義リスト 僕の覚え方: define list -\u0026gt; define title -\u0026gt; define describe\n1 2 3 4 5 6 7 8 \u0026lt;dl\u0026gt; \u0026lt;dt\u0026gt;タイトル1\u0026lt;/dt\u0026gt; \u0026lt;dd\u0026gt;1.1 説明\u0026lt;/dd\u0026gt; \u0026lt;dd\u0026gt;1.2 説明\u0026lt;/dd\u0026gt; \u0026lt;dt\u0026gt;タイトル2\u0026lt;/dt\u0026gt; \u0026lt;dd\u0026gt;2.1 説明\u0026lt;/dd\u0026gt; \u0026lt;dd\u0026gt;2.2 説明\u0026lt;/dd\u0026gt; \u0026lt;/dl\u0026gt; 表示はこんな感じ\nタイトル1 1.1 説明 1.2 説明 タイトル2 2.1 説明 2.2 説明 dlタグにはdtタグとddタグしか含められないけど、dtタグとddタグの中には何でも入れられるよ。\nテーブル タグ 説明 僕の覚え方 table テーブルを定義する tr テーブルの行 table row th ヘッダーセル table head td データセル table data 以下の構造タグは省略できるけど、主にブラウザ向けだね。\nタグ 説明 thead ヘッダー部分を定義する tbody テーブル本体を定義する tfoot テーブルのフッター部分を定義する（集計情報など） テーブルの例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 \u0026lt;table\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;\\\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;x\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;y\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;total\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tbody\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;a\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;50\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;50\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;100\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;b\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;50\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;50\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;100\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/tbody\u0026gt; \u0026lt;tfoot\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;total\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;100\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;100\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;100\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/tfoot\u0026gt; \u0026lt;/table\u0026gt; 表示はこんな感じ\n\\ x y total a 50 50 100 b 50 50 100 total 100 100 100 セルの結合 テーブルの結合は、行をまたぐ結合と列をまたぐ結合があるよ。結合したら、結合された方のセルは削除しないといけないんだ。\n属性 説明 rowspan 行をまたぐ結合、値は結合する行数 colspan 列をまたぐ結合、値は結合する列数 例えば、上のテーブルの2行目2列目と3行目2列目を結合して、最後の行の最後の3列を結合するよ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 \u0026lt;table\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;\\\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;x\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;y\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;total\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tbody\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;a\u0026lt;/td\u0026gt; \u0026lt;!-- ここに`rowspan`属性を追加 --\u0026gt; \u0026lt;td rowspan=\u0026#34;2\u0026#34;\u0026gt;50\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;50\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;100\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;b\u0026lt;/td\u0026gt; \u0026lt;!-- この内容は削除できる（ここをコメントアウト） --\u0026gt; \u0026lt;!--\u0026lt;td\u0026gt;50\u0026lt;/td\u0026gt;--\u0026gt; \u0026lt;td\u0026gt;50\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;100\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/tbody\u0026gt; \u0026lt;tfoot\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;total\u0026lt;/td\u0026gt; \u0026lt;!-- ここに`colspan`属性を追加 --\u0026gt; \u0026lt;td colspan=\u0026#34;3\u0026#34;\u0026gt;100\u0026lt;/td\u0026gt; \u0026lt;!-- この内容は削除できる（ここをコメントアウト） --\u0026gt; \u0026lt;!--\u0026lt;td\u0026gt;100\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;100\u0026lt;/td\u0026gt;--\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/tfoot\u0026gt; \u0026lt;/table\u0026gt; 表示はこんな感じ\n\\ x y total a 50 50 100 b 50 100 total 100 もし構造タグ（thead, tbody, tfoot）を使ってるなら、構造をまたいで結合はできないよ。例えば、上のテーブルの3行目と最後の行は結合できないってことね。\nフォーム formタグ フォームを作るには、formタグを使ってフォームの範囲を決める必要があるよ。これから説明するタグは、全部formタグの中に入れるんだ。\ninputタグ ほとんどのフォームはinputタグで作るんだ。type属性の値によって、いろんな機能が実現できるよ。\ntype属性値 説明 text テキストボックス password パスワードボックス radio ラジオボタン checkbox チェックボックス file ファイルアップロード プレースホルダーテキスト プレースホルダーテキストっていうのは、入力例とかヒントのことだね。テキストボックスとパスワードボックスで使えるよ。\n1 \u0026lt;input type=\u0026#34;text\u0026#34; placeholder=\u0026#34;ヒント情報\u0026#34; /\u0026gt; 表示はこんな感じ\nラジオボタン (radio) 属性 役割 name コントロール名 checked デフォルトで選択 以下のコードは性別の選択を実装するよ。\n1 2 3 性別： \u0026lt;input type=\u0026#34;radio\u0026#34; name=\u0026#34;gender\u0026#34; checked /\u0026gt;男 \u0026lt;input type=\u0026#34;radio\u0026#34; name=\u0026#34;gender\u0026#34; /\u0026gt;女 表示はこんな感じ\n性別： 男 女 ファイルアップロード デフォルトだと、fileタイプのinputタグはファイルを1つしかアップロードできないんだ。複数アップロードしたい場合は、multiple属性を追加すればいいよ。\n1 \u0026lt;input type=\u0026#34;file\u0026#34; multiple /\u0026gt; チェックボックス (checkbox) 別名チェックボックスだね。デフォルトで選択状態にしたい場合はchecked属性を使えるよ。\n1 2 3 4 \u0026lt;input type=\u0026#34;checkbox\u0026#34; checked /\u0026gt; a \u0026lt;input type=\u0026#34;checkbox\u0026#34; /\u0026gt; b \u0026lt;input type=\u0026#34;checkbox\u0026#34; /\u0026gt; c \u0026lt;input type=\u0026#34;checkbox\u0026#34; /\u0026gt; d プルダウンメニュー 1 2 3 4 5 6 7 \u0026lt;select\u0026gt; \u0026lt;option\u0026gt;CN\u0026lt;/option\u0026gt; \u0026lt;option\u0026gt;USA\u0026lt;/option\u0026gt; \u0026lt;option\u0026gt;UK\u0026lt;/option\u0026gt; \u0026lt;!-- selectedでデフォルト選択を指定 --\u0026gt; \u0026lt;option selected\u0026gt;JP\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; テキストエリア 複数行のテキストを入力するためのフォームコントロールだよ。自己紹介とかでよく使うね。\n1 \u0026lt;textarea\u0026gt;ヒント情報\u0026lt;/textarea\u0026gt; labelタグ ウェブページのあるタグに対する説明テキストとして使うんだ。あと、テキストとフォームコントロールを紐付けて、クリックできる範囲を広げることもできるよ。\n例えば、さっきの性別のラジオボタンだと、丸い部分をクリックしないと選択できなかったよね。でも、このタグを使えば、文字を選んでもラジオボタンが選択できるようになるんだ。\n方法1 inputタグにid属性を追加して、labelタグにfor属性を追加するよ。この2つの属性値は同じにするんだ。\n1 2 3 4 \u0026lt;input type=\u0026#34;radio\u0026#34; name=\u0026#34;gender\u0026#34; id=\u0026#34;male\u0026#34;/\u0026gt; \u0026lt;label for=\u0026#34;male\u0026#34;\u0026gt;男\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;radio\u0026#34; name=\u0026#34;gender\u0026#34; id=\u0026#34;female\u0026#34;/\u0026gt; \u0026lt;label for=\u0026#34;female\u0026#34;\u0026gt;女\u0026lt;/label\u0026gt; 方法2 labelタグで文字とフォームコントロールを直接囲む方法。\n1 2 \u0026lt;label\u0026gt;\u0026lt;input type=\u0026#34;radio\u0026#34; name=\u0026#34;gender\u0026#34; /\u0026gt;男\u0026lt;/label\u0026gt; \u0026lt;label\u0026gt;\u0026lt;input type=\u0026#34;radio\u0026#34; name=\u0026#34;gender\u0026#34; /\u0026gt;女\u0026lt;/label\u0026gt; labelタグでクリック範囲を広げられるコントロールは、テキストボックス、パスワードボックス、ファイルアップロード、ラジオボタン、チェックボックス、プルダウンメニュー、テキストエリアなんかがあるよ。\nボタン buttonタグは、type属性の値によって機能が変わるんだ。\ntype属性値 説明 submit デフォルトの機能で、データをバックエンドに送信する reset リセットボタンで、フォームコントロールを初期値に戻す button 普通のボタンで、JavaScriptと組み合わせて使う必要がある 1 \u0026lt;button type=\u0026#34;\u0026#34;\u0026gt;ボタン\u0026lt;/button\u0026gt; ","date":"2024-01-29T13:24:25+08:00","permalink":"https://blog.yexca.net/ja/archives/150/","title":"HTML学習その2 - リスト、テーブル、フォーム"},{"content":" 📢 この記事は gemini-3-flash-preview によって翻訳されました はじめに 無限ループは絶対に中に入れないでね！！！今回は systemd を使った方法を紹介するよ。\nスクリプトを作成する このファイルに自分のスクリプトを書き込んでね。\n1 vi /etc/rc.d/rc.local 実行権限を付与するよ。\n1 chmod +x /etc/rc.d/rc.local 起動設定を編集する ファイルを編集していくよ。\n1 vi /usr/lib/systemd/system/rc-local.service 最後の行に [Install] を追記してね。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # This file is part of systemd. # # systemd is free software; you can redistribute it and/or modify it # under the terms of the GNU Lesser General Public License as published by # the Free Software Foundation; either version 2.1 of the License, or # (at your option) any later version. # This unit gets pulled automatically into multi-user.target by # systemd-rc-local-generator if /etc/rc.d/rc.local is executable. [Unit] Description=/etc/rc.d/rc.local Compatibility ConditionFileIsExecutable=/etc/rc.d/rc.local After=network.target [Service] Type=forking ExecStart=/etc/rc.d/rc.local start TimeoutSec=0 RemainAfterExit=yes SysVStartPriority=99 [Install] WantedBy=multi-user.target それから、systemd で自動起動を有効にするよ。\n1 systemctl enable rc-local.service 起動ステータスを確認する 次のコマンドを使って確認してね。\n1 systemctl status rc-local.service 参考記事 Fedora 22(15以上版本)开机自启动脚本 - 可酷可乐 - 博客园 ","date":"2024-01-28T14:25:58+08:00","permalink":"https://blog.yexca.net/ja/archives/149/","title":"Fedora 起動時にスクリプトを自動実行する方法"},{"content":" 📢 この記事は gemini-3-flash-preview によって翻訳されました JSは、クロスプラットフォームでオブジェクト指向のスクリプト言語だよ。ウェブページの挙動を制御して、ユーザーとやり取りできるようにするために使われるんだ。\nJSの導入方法 内部スクリプトと外部スクリプトの2種類があるよ。\n内部スクリプト JSのコードをHTMLページの中に直接書く方法だよ。\nJSのコードは必ず \u0026lt;script\u0026gt;\u0026lt;/script\u0026gt; タグの間に書くこと。 HTMLドキュメント内のどこにでも、いくつでも \u0026lt;script\u0026gt; を置けるよ。 一般的には、表示速度を上げるために \u0026lt;body\u0026gt; 要素の最後に置くことが多いかな。 1 2 3 \u0026lt;script\u0026gt; alert(\u0026#34;Hello JavaScript\u0026#34;) \u0026lt;/script\u0026gt; 外部スクリプト JSのコードを外部のJSファイルに定義して、それをHTMLページに読み込む方法だよ。\n外部JSファイルにはJSのコードだけを書いて、 \u0026lt;script\u0026gt; タグは含めないよ。 1 2 3 4 5 \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;script src=\u0026#34;./js/1.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;/html\u0026gt; JSファイルの内容：\n1 alert(\u0026#34;Hello JavaScript\u0026#34;) JSの基本構文 大文字と小文字を区別するよ。行末のセミコロンはあってもなくても大丈夫。コメントは2種類あるんだ。\n1 2 3 4 5 // 一行コメント /* 複数行コメント */ 波括弧 {} はコードブロックを表すよ。\n1 2 3 4 // 判断 if(count==3){ alert(count); } 出力ステートメント 警告ボックス、HTML、またはコンソールに出力できるよ。\n1 2 3 4 5 6 // ブラウザに警告ボックスを表示 window.alert(\u0026#34;Hello from alert\u0026#34;) // HTMLに書き込んでブラウザに表示 document.write(\u0026#34;Hello from HTML\u0026#34;) // ブラウザのコンソールに書き込む console.log(\u0026#34;Hello from console\u0026#34;) 変数 JSは弱型言語で、変数には異なる型の値を入れられるんだ。変数名は以下のルールに従う必要があるよ。\n使える文字は、文字、数字、アンダースコア（_）、またはドル記号（$）。 数字から始めてはいけない。 キャメルケース（camelCase）での命名がおすすめ。 変数を定義するキーワードは var、let、const の3つがあるよ。\nvar variableの略。宣言された変数はグローバル変数になり、重複して定義することもできちゃう。\n1 2 3 4 5 6 7 8 9 10 // 重複宣言 var a = 1; var a = \u0026#39;A\u0026#39;; alert(a); // グローバル変数 { var b = \u0026#39;B\u0026#39;; } alert(b); let ECMAScript 6で追加されたよ。宣言された変数は、その let があるコードブロック内でのみ有効で、重複宣言はできないんだ。\n1 2 3 4 5 6 7 8 let a = \u0026#39;A\u0026#39;; alert(a); // ローカル変数 { let a=\u0026#39;A\u0026#39;; } alert(a); // 何も表示されず、コンソールでエラーになる const 読み取り専用の定数を宣言するために使うよ。一度宣言すると、値を変えることはできないんだ。\n1 2 3 const a = \u0026#39;A\u0026#39;; a = 1; alert(a); // 何も表示されず、コンソールでエラーになる データ型 JSにはプリミティブ型と参照型の2種類があるよ。つまり、基本データ型とオブジェクトだね。\nプリミティブ型は5種類：\nnumber：数字（整数、小数、NaN (Not a Number)） string：文字列。シングルクォートでもダブルクォートでもOK。 boolean：論理値。true と false。 null：オブジェクトが空。 undefined：宣言された変数が初期化されていない時のデフォルト値。 typeof 演算子を使えばデータ型を確認できるよ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // number console.log(\u0026#34;number 型\u0026#34;); console.log(typeof 3); console.log(typeof 3.14); // string console.log(\u0026#34;\\nstring 型\u0026#34;); console.log(typeof \u0026#39;A\u0026#39;); console.log(typeof \u0026#34;string\u0026#34;); // boolean console.log(\u0026#34;\\nboolean 型\u0026#34;); console.log(typeof true); console.log(typeof false); // null - object console.log(\u0026#34;\\nnull-object 型\u0026#34;); console.log(typeof null); // undefined var a; console.log(\u0026#34;\\nundefined 型\u0026#34;); console.log(typeof a); なんで typeof null が \u0026ldquo;Object\u0026rdquo; を返すのか不思議に思うかもしれないけど、これは実はJavaScriptの初期の実装ミスがそのまま引き継がれちゃったものなんだ。今は null はオブジェクトのプレースホルダーだと解釈されているけど、技術的には依然としてプリミティブ値なんだよ。\n参考: https://www.w3school.com.cn/js/pro_js_primitivetypes.asp 演算子 算術演算子：+、-、*、/、%、++、\u0026ndash; 代入演算子：=、+=、-=、*=、/=、%= 比較演算子：\u0026gt;、\u0026lt;、\u0026gt;=、\u0026lt;=、!=、==、=== 論理演算子：\u0026amp;\u0026amp;、||、! 三項演算子：条件 ? trueの場合 : falseの場合 == と ===\n== は型変換を行うけど、 === は型変換を行わないんだ。つまり、型と値の両方が一致して初めて true になるよ。\n1 2 3 4 5 6 7 var a = 20; var aStr = \u0026#34;20\u0026#34;; var aInt = 20; console.log(a==aStr); // true console.log(a===aStr);// false console.log(a===aInt);// true 型変換 文字列を数字に変換するには parseInt() 関数を使えばいいよ。\n変換は最初の文字から始まって、数値以外の文字にぶつかるまで続くんだ。最初が数値以外なら NaN になるよ。\n1 2 3 4 5 6 7 var a = \u0026#34;12\u0026#34;; var b = \u0026#34;12A34\u0026#34;; var c = \u0026#34;A34\u0026#34;; console.log(parseInt(a)); // 12 console.log(parseInt(b)); // 12 console.log(parseInt(c)); // NaN 他の型から Boolean への変換：\nNumber：0 と NaN は false、それ以外は true。 String：空文字列は false、それ以外は true。 Null と undefined：どちらも false。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // number if (0) { console.log(\u0026#34;0\u0026#34;); } if (NaN) { console.log(\u0026#34;NaN\u0026#34;); } if (-1) { console.log(\u0026#34;-1\u0026#34;); } // 実行結果：-1 // String if (\u0026#34;\u0026#34;) { console.log(\u0026#34;空文字\u0026#34;); } if (\u0026#34; \u0026#34;) { console.log(\u0026#34;スペース\u0026#34;); } // 実行結果：スペース // Null と undefined if (null) { console.log(\u0026#34;null\u0026#34;) } if (undefined) { console.log(\u0026#34;undefined\u0026#34;) } if (1) { console.log(\u0026#34;null と undefined はどちらも false\u0026#34;) } // 実行結果：null と undefined はどちらも false 制御フロー if\u0026hellip;else if\u0026hellip;else switch for while do\u0026hellip;while 参考: https://www.w3school.com.cn/jsref/jsref_statements.asp 関数 関数は、特定のタスクを実行するために設計されたコードブロックだよ。\n定義の方法は2種類あるけど、一般的な構文はこんな感じ。\n1 2 3 function functionName(var1, var2, ...){ // コード } ポイント：\n引数に型指定はいらない。 戻り値の型定義もいらなくて、関数内で return すればOK。 1 2 3 4 5 6 function add1(a, b){ return a+b; } var result = add1(10, 20); console.log(result); // 30 関数の定義方法その2：\n1 2 3 var functionName = function(var1, var2, ...){ // コード } さっきの例をこの方法で書くと：\n1 2 3 4 5 6 var add2 = function(a, b){ return a+b; } var result = add2(10, 20); console.log(result); // 30 JSでは、関数を呼び出す時に引数をいくつ渡してもいいんだけど、実際に受け取れるのは定義した引数の数だけだよ。\nオブジェクト 基本オブジェクト、ブラウザオブジェクトモデル (BOM)、ドキュメントオブジェクトモデル (DOM) があるよ。\nArray 配列 定義方法1：\n1 2 3 var name = new Array(element1, element2, ...); // 例えば var arr = new Array(1, 2, 3, 4); 定義方法2：\n1 2 3 var name = [element]; // 例えば var arr = [1, 2, 3, 4]; アクセスと代入：\n1 2 3 4 // アクセス（インデックスは0から） arr[2]; // 代入 arr[4]=5; 配列の長さは可変だし、どんな型のデータでも混ぜて保存できるよ。\n1 2 3 4 5 6 7 8 9 10 var arr = [1, 2, 3, 4]; // console.log(arr); // 長さが変わる arr[9] = 8; // console.log(arr); // 型も変わる arr[8] = \u0026#39;A\u0026#39;; console.log(arr); プロパティ length プロパティは配列の要素の数を返してくれるよ。これを使ってループを回したりするね。\n1 2 3 4 var arr = [1, 2, 3, 4]; for (let i = 0; i \u0026lt; arr.length; i++) { console.log(arr[i]); } メソッド メソッド 説明 forEach() 配列内の値がある各要素をループして、関数を呼び出す push() 配列の末尾に新しい要素を追加して、新しい長さを返す splice() 配列から要素を削除する forEach でループ：\n1 2 3 4 var arr = [1, 2, 3, 4]; arr.forEach(function(e){ console.log(e); }) アロー関数を使えばもっとスッキリ書けるよ。\n1 2 3 4 // アロー関数：(...) =\u0026gt; {...} で定義を簡略化 arr.forEach(e =\u0026gt; { console.log(e); }); push で要素追加：\n1 2 3 4 var arr = [1, 2, 3, 4]; // 複数の値を一度に入れられる arr.push(5, 6, 7, 8); console.log(arr);// [1, 2, 3, 4, 5, 6, 7, 8] splice で削除：\n1 2 3 4 5 var arr = [1, 2, 3, 4]; arr.push(5, 6, 7, 8); // [1, 2, 3, 4, 5, 6, 7, 8] // 何番目の要素から、何個削除するか arr.splice(2, 4); // 2番目の要素から4個削除 console.log(arr);// [1, 2, 7, 8] 2つのループの違い for ループは undefined を含めて全ての要素を回るけど、 forEach は値がある要素だけを回るんだ。\n1 2 3 4 5 6 7 8 9 10 11 12 var arr = [1, 2, 3, 4]; arr[9] = 10; for (let i = 0; i \u0026lt; arr.length; i++) { console.log(arr[i]); }// 1, 2, 3, 4, undefined, undefined, undefined, undefined, undefined, 10 console.log(\u0026#34;==============================\u0026#34;); arr.forEach(e =\u0026gt; { console.log(e); })// 1, 2, 3, 4, 10 String 文字列 作成方法は2つ。\n1 2 3 4 // 方法1 var name = new String(\u0026#34;\u0026#34;); // 方法2 var name = \u0026#34;\u0026#34;; // シングルでもダブルでもOK プロパティとメソッド プロパティ・メソッド 説明 length 文字列の長さ charAt() 指定された位置の文字を返す indexOf() 文字列を検索する trim() 文字列の両端の空白を削除する substring() 指定された2つのインデックス間の文字を抽出する 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 var str = \u0026#34;Hello String\u0026#34;; console.log(str.length); // 12 // 0から数えるよ console.log(str.charAt(4)); // o console.log(str.indexOf(\u0026#34;lo\u0026#34;)); // 3 var s = \u0026#34; Hello String \u0026#34;; var s = s.trim(); console.log(s); // Hello String // 開始、終了（開始位置を含み、終了位置は含まない） var s = s.substring(0, 5); console.log(s); // Hello JS カスタムオブジェクト 定義の形式：\n1 2 3 4 5 6 var オブジェクト名 = { プロパティ名: プロパティ値, 関数名: function(引数){ } } 例えば：\n1 2 3 4 5 6 7 8 9 10 11 var person = { name: \u0026#34;tom\u0026#34;, age: 18, gender: \u0026#34;male\u0026#34;, eat: function(){ console.log(\u0026#34;ご飯食べるにゃ\u0026#34;); } } console.log(person.age); person.eat(); メソッドは短縮して書くこともできるよ。\n1 2 3 4 5 6 7 8 9 10 11 var person = { name: \u0026#34;tom\u0026#34;, age: 18, gender: \u0026#34;male\u0026#34;, // eat: function(){ // console.log(\u0026#34;ご飯食べるにゃ\u0026#34;); // } eat(){ console.log(\u0026#34;ご飯食べるにゃ\u0026#34;); } } JSON JavaScript Object Notation。JavaScriptのオブジェクト記法を使ったテキストのことだよ。構文がシンプルで構造が分かりやすいから、今はネットワーク上でのデータ伝送によく使われているんだ。\n定義と例：\n1 2 3 4 // 定義 var 変数名 = \u0026#39;{\u0026#34;key1\u0026#34;:value1, \u0026#34;key2\u0026#34;:value2}\u0026#39;; // 例 var userStr = \u0026#39;{\u0026#34;name\u0026#34;:\u0026#34;Tom\u0026#34;, \u0026#34;age\u0026#34;:18, \u0026#34;addr\u0026#34;:[\u0026#34;北京\u0026#34;, \u0026#34;上海\u0026#34;]}\u0026#39;; valueに使えるデータ型：\n数値（整数または浮点数） 文字列（ダブルクォートで囲む） 論理値（true または false） 配列（角括弧の中） オブジェクト（波括弧の中） null JSにはオブジェクトをJSON文字列に変換するメソッドがあるよ。\n1 var jsonStr = JSON.stringify(jsObject) 逆に、JSON文字列をオブジェクトに変換するメソッドもあるよ。\n1 2 var userStr = \u0026#39;{\u0026#34;name\u0026#34;:\u0026#34;Tom\u0026#34;, \u0026#34;age\u0026#34;:18, \u0026#34;addr\u0026#34;:[\u0026#34;北京\u0026#34;, \u0026#34;上海\u0026#34;]}\u0026#39;; var jsObject = JSON.parse(userStr) BOM Browser Object Model。JavaScriptがブラウザと対話するための仕組みで、ブラウザの各パーツをオブジェクトとして扱えるようにしたものだよ。\nWindow：ブラウザウィンドウオブジェクト Navigator：ブラウザ情報オブジェクト Screen：画面オブジェクト History：履歴オブジェクト Location：アドレスバーオブジェクト Window ブラウザウィンドウオブジェクトは直接使えるし、 window. は省略してもいいよ。プロパティにはこんなのがある：\nプロパティ 説明 history Historyオブジェクトへの読み取り専用参照 location ウィンドウのLocationオブジェクト navigator Navigatorオブジェクトへの読み取り専用参照 メソッド：\nメソッド 説明 alert() メッセージとOKボタンがある警告ボックスを表示する confirm() メッセージとOK・キャンセルボタンがあるダイアログを表示する setInterval() 指定した周期（ミリ秒）で関数を繰り返し呼び出す setTimeout() 指定したミリ秒後に一度だけ関数を呼び出す 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // windowオブジェクトを取得して使用 window.alert(\u0026#34;windowオブジェクトだよ\u0026#34;); // 省略してもOK alert(\u0026#34;windowを省略したよ\u0026#34;); // confirm var flag = confirm(\u0026#34;確認してね\u0026#34;); console.log(flag); // タイマー1 var i = 0; setInterval(function(){ i++; console.log(\u0026#34;タイマー実行 \u0026#34;+i+\u0026#34;回目\u0026#34;); }, 2000); // 2秒ごとに実行 // タイマー2 setTimeout(function(){ console.log(\u0026#34;一度だけ実行されるよ\u0026#34;); }, 3000); // 3秒後に実行 Location アドレスバーオブジェクトだね。 window.location で取得できるよ（ window. は省略可）。\nhref プロパティを使うと、URLを設定したり取得したりできるんだ。\n1 2 3 4 // 現在のアドレスを取得 console.log(location.href); // アドレスを設定すると、自動的にジャンプするよ location.href = \u0026#34;https://blog.yexca.net/\u0026#34; DOM Document Object Model。マークアップ言語（HTMLとか）の各パーツをオブジェクトとして扱えるようにしたものだよ。\nDOMはW3Cの標準で、HTMLやXMLドキュメントにアクセスするための標準を定義しているんだ。大きく分けて3つあるよ：\nCore DOM - 全てのドキュメントタイプの標準モデル Document：ドキュメント全体 Element：要素 Attribute：属性 Text：テキスト Comment：コメント XML DOM - XMLドキュメントの標準モデル HTML DOM - HTMLドキュメントの標準モデル Image: \u0026lt;img\u0026gt; Button: \u0026lt;input type='button'\u0026gt; JSはDOMを通じて、HTMLを操作できるんだ。例えば：\nHTML要素の内容を変える HTML要素のスタイル（CSS）を変える HTML DOMイベントに反応する HTML要素を追加したり削除したりする HTMLの Element オブジェクトは Document オブジェクトから取得できて、その Document オブジェクトは window オブジェクトから取得するんだよ。\nDocument オブジェクトには、要素を取得するための関数がいくつか用意されているよ。\nid属性で取得（1つの要素を返す） 1 var app = document.getElementById(\u0026#39;app\u0026#39;); タグ名で取得（要素の配列を返す） 1 var links = document.getElementsByTagName(\u0026#34;a\u0026#34;); name属性で取得（要素の配列を返す） 1 var hobbys = document.getElementsByName(\u0026#39;hobby\u0026#39;); class属性で取得（要素の配列を返す） 1 var classes = document.getElementsByClassName(\u0026#39;cls\u0026#39;); 上の例で使ったHTML：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;ja\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;DOM\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt;abc\u0026lt;/a\u0026gt;\u0026lt;br\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;hobby\u0026#34;\u0026gt;hobby1 \u0026lt;br\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;hobby\u0026#34;\u0026gt;hobby2 \u0026lt;br\u0026gt; \u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt;def\u0026lt;/a\u0026gt;\u0026lt;br\u0026gt; \u0026lt;div class=\u0026#34;cls\u0026#34;\u0026gt;class\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script src=\u0026#34;./js/10-DOM.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; 要素を取得したら、あとは書き換えるだけ。詳しい操作は W3SchoolのHTMLオブジェクトリファレンス を見てみて。\n例えば、最初の \u0026lt;a\u0026gt; タグのテキストを変えるなら：\n1 2 3 4 // 取得 var links = document.getElementsByTagName(\u0026#34;a\u0026#34;); // 変更 links[0].innerHTML = \u0026#34;書き換えたよ\u0026#34;; イベントリスナー イベントっていうのは、HTML要素の上で起きること（ボタンがクリックされた、マウスが乗った、キーが押された、とか）だよ。\nイベントリスナーは、そのイベントを検知した時にJavaScriptのコードを実行させる仕組みのことなんだ。\nイベントの紐付け（バインド） 紐付けには2つの方法があるよ。方法1：HTMLタグの属性として書く。\n1 2 3 4 5 6 \u0026lt;button id=\u0026#34;btn\u0026#34; onclick=\u0026#34;on()\u0026#34;\u0026gt;ボタン\u0026lt;/button\u0026gt; \u0026lt;script\u0026gt; function on(){ alert(\u0026#34;ボタンがクリックされたよ1\u0026#34;); } \u0026lt;/script\u0026gt; 方法2：DOM要素のプロパティに代入する。\n1 2 3 document.getElementById(\u0026#34;btn\u0026#34;).onclick=function(){ alert(\u0026#34;ボタンがクリックされたよ2\u0026#34;); } よく使うイベント イベント名 説明 onclick マウスをクリックした時 onblur フォーカスが外れた時 onfocus フォーカスが当たった時 onload ページや画像が読み込み終わった時 onsubmit フォームが送信される時 onkeydown キーボードのキーが押された時 onmouseover マウスが要素の上に乗った時 onmouseout マウスが要素から離れた時 ","date":"2024-01-22T19:51:24+08:00","permalink":"https://blog.yexca.net/ja/archives/148/","title":"JavaScriptの勉強"},{"content":" 📢 この記事は gemini-2.5-flash によって翻訳されました 事例導入 従業員データを取得して、統一された応答結果を返して、ページに表示するよ。\nまず、XMLファイルを解析するためにdom4jの依存関係を追加する必要があるんだ。\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.dom4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;dom4j\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.1.3\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; XML解析用のユーティリティクラスXMLParserUtils、対応するエンティティクラスEmp、XMLファイルemp.xmlを導入するよ。\n静的ページファイルをresources/staticに配置するね。\nSpringBootプロジェクトの静的リソース（HTML5+CSS+JSなどのフロントエンドリソース）は、デフォルトでclsspath:/static、classpath:/public、clsspath:/resourcesに置かれるんだ。\nMavenの場合、classpathはsrc/main/resourcesになるよ。\nControllerプログラムを書いて、リクエストを処理して、データを応答するんだ（この例ではコードは省略、後述の3層アーキテクチャを使うよ）。\n3層アーキテクチャ 上の例のempコードだと、データアクセス、処理ロジック、リクエスト受信と応答が全部一つのControllerに入っちゃってるから、再利用性が低くて保守も難しいんだ。だから、単一責任の原則を満たすためにこれらを分離する必要がある。3層アーキテクチャにすると、コードの再利用性が高まって、保守しやすくなるし、拡張も楽になるよ。\n3層アーキテクチャはController、Service、Daoに分かれるよ。\nController：制御層で、フロントエンドから送られてきたリクエストを受け取って、処理してからデータを返すんだ。 Service：ビジネスロジック層で、具体的なビジネスロジックを処理するよ。 Dao：データアクセス層（Data Access Object）または永続化層で、データアクセス操作、つまりCRUDを担当するんだ。 ブラウザがリクエストを出す -\u0026gt; Controllerがリクエストを受け取ってデータを応答 -\u0026gt; Serviceがロジックを処理 -\u0026gt; Daoがデータアクセス\n上の例のempコードは次のように最適化できるよ。\nController 1 2 3 4 5 6 7 8 9 @RestController public class EmpController { @RequestMapping(\u0026#34;/listEmp\u0026#34;) public Result listEmp(){ EmpService empServiceA = new EmpServiceA(); List\u0026lt;Emp\u0026gt; empList = empServiceA.listEmp(); return Result.success(empList); } } Service 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // interface public interface EmpService { public List\u0026lt;Emp\u0026gt; listEmp(); } public class EmpServiceA implements EmpService { private EmpDao empDao = new EmpDaoA(); public List\u0026lt;Emp\u0026gt; listEmp(){ List\u0026lt;Emp\u0026gt; empList = empDao.listEmp(); empList.forEach(emp -\u0026gt; { String gender = emp.getGender(); if(\u0026#34;1\u0026#34;.equals(gender)){ emp.setGender(\u0026#34;男\u0026#34;); } else if (\u0026#34;2\u0026#34;.equals(gender)) { emp.setGender(\u0026#34;女\u0026#34;); } String job = emp.getJob(); if(\u0026#34;1\u0026#34;.equals(job)){ emp.setJob(\u0026#34;講師\u0026#34;); } else if (\u0026#34;2\u0026#34;.equals(job)) { emp.setJob(\u0026#34;班主任\u0026#34;); } else if (\u0026#34;3\u0026#34;.equals(job)) { emp.setJob(\u0026#34;就業指導\u0026#34;); } }); return empList; } } Dao 1 2 3 4 5 6 7 8 9 10 11 12 // interface public interface EmpDao { public List\u0026lt;Emp\u0026gt; listEmp(); } public class EmpDaoA implements EmpDao { public List\u0026lt;Emp\u0026gt; listEmp(){ String file = this.getClass().getClassLoader().getResource(\u0026#34;emp.xml\u0026#34;).getFile(); List\u0026lt;Emp\u0026gt; empList = XmlParserUtils.parse(file, Emp.class); return empList; } } レイヤーの疎結合 凝集度：ソフトウェアの各機能モジュール内部における機能的な関連性のこと。\n結合度：ソフトウェアの各層/モジュール間の依存関係や関連性の度合いを測るもの。\nソフトウェア設計原則：高凝集度、低結合度\n詳細は https://blog.yexca.net/ja/archives/145 を見てね。\n例えば、上の3層アーキテクチャの例だと、ControllerとServiceが結合してて、ServiceとDaoも結合してるよね。\nControllerで直接ServiceオブジェクトEmpService empServiceA = new EmpServiceA();みたいにAを使っちゃうと、Bに変更するときはControllerも変更しなきゃいけないんだ。Serviceを変えてもControllerを変更しないようにするためには、コンテナを作成して、Controllerがコンテナからオブジェクトを取得するように（依存性注入）、そしてServiceがサービスをコンテナに注入するように（制御の反転）できるよ。\n制御の反転：Inverse Of Control、略してIOC。オブジェクトの生成制御がプログラム自身から外部（コンテナ）に移されること。 依存性注入：Dependency Injection、略してDI。コンテナがアプリケーションの実行時に、必要となるリソースを提供するんだ。 Beanオブジェクト：IOCコンテナで作成、管理されるオブジェクトのこと。 IOC あるオブジェクトをIOCコンテナに管理してもらうには、対応するクラスに以下のいずれかのアノテーションを付ける必要があるよ。\nアノテーション 説明 位置 @Component Beanを宣言する基本アノテーション 以下の3つのカテゴリに属さない場合に使用する（ユーティリティクラスなど） @Controller @Componentの派生アノテーション コントローラクラスに付ける @Service @Componentの派生アノテーション ビジネスロジッククラスに付ける @Repository @Componentの派生アノテーション データアクセス層のクラスに付ける（MyBatis連携ではあまり使わない） Beanを宣言するときは、value属性で名前を指定できるよ。指定しない場合は、デフォルトでクラス名の先頭が小文字になるんだ。 SpringBootでのWeb開発では、コントローラBeanの宣言には@Controllerしか使えないよ。 Beanコンポーネントスキャン 上で宣言したBeanの4つのアノテーションは、有効にするにはコンポーネントスキャンアノテーション@ComponentScanでスキャンされる必要があるんだ。\nこのアノテーションは、実は起動クラスのアノテーション@SpringBootApplicationにすでに含まれてるんだ。デフォルトのスキャン範囲は、起動クラスのあるパッケージとそのサブパッケージになるよ。\nvalueまたはbasePackage属性でスキャン範囲を指定できるよ。\n1 @ComponentScan({\u0026#34;dao\u0026#34;,\u0026#34;net.yexca\u0026#34;}) 例 上の例では、\nController @RestControllerアノテーションはすでに@Controllerを含んでいるから、修正は不要だよ。\nService 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 // interface public interface EmpService { public List\u0026lt;Emp\u0026gt; listEmp(); } // 実装クラスに追加 @Service // このクラスをIOCコンテナに管理させ、IOCコンテナのBeanにする public class EmpServiceA implements EmpService { private EmpDao empDao = new EmpDaoA(); public List\u0026lt;Emp\u0026gt; listEmp(){ List\u0026lt;Emp\u0026gt; empList = empDao.listEmp(); empList.forEach(emp -\u0026gt; { String gender = emp.getGender(); if(\u0026#34;1\u0026#34;.equals(gender)){ emp.setGender(\u0026#34;男\u0026#34;); } else if (\u0026#34;2\u0026#34;.equals(gender)) { emp.setGender(\u0026#34;女\u0026#34;); } String job = emp.getJob(); if(\u0026#34;1\u0026#34;.equals(job)){ emp.setJob(\u0026#34;講師\u0026#34;); } else if (\u0026#34;2\u0026#34;.equals(job)) { emp.setJob(\u0026#34;班主任\u0026#34;); } else if (\u0026#34;3\u0026#34;.equals(job)) { emp.setJob(\u0026#34;就業指導\u0026#34;); } }); return empList; } } Dao 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // interface public interface EmpDao { public List\u0026lt;Emp\u0026gt; listEmp(); } // 実装クラスに追加 @Repository // このクラスをIOCコンテナに管理させ、IOCコンテナのBeanにする public class EmpDaoA implements EmpDao { public List\u0026lt;Emp\u0026gt; listEmp(){ String file = this.getClass().getClassLoader().getResource(\u0026#34;emp.xml\u0026#34;).getFile(); List\u0026lt;Emp\u0026gt; empList = XmlParserUtils.parse(file, Emp.class); return empList; } } DI @Autowiredアノテーションを使うと依存性を注入できるんだけど、デフォルトでは型に基づいて行われるから、同じ型のBeanが複数あるとエラーになるんだ。\n上記の例にDIを追加するよ（変更されたコードはコメントアウトするね）。\nController 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @RestController public class EmpController { @Autowired // 実行時、IOCコンテナがこの型のBeanオブジェクトを提供し、この変数に代入するんだ -- 依存性注入 private EmpService empService; @RequestMapping(\u0026#34;/listEmp\u0026#34;) public Result listEmp(){ //EmpService empServiceA = new EmpServiceA(); //List\u0026lt;Emp\u0026gt; empList = empServiceA.listEmp(); List\u0026lt;Emp\u0026gt; empList = empService.listEmp(); return Result.success(empList); } } Service 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 // interface public interface EmpService { public List\u0026lt;Emp\u0026gt; listEmp(); } // 実装クラスに追加 @Service // このクラスをIOCコンテナに管理させ、IOCコンテナのBeanにする public class EmpServiceA implements EmpService { @Autowired // 実行時、IOCコンテナがこの型のBeanオブジェクトを提供し、この変数に代入するんだ -- 依存性注入 private EmpDao empDao; // private EmpDao empDao = new EmpDaoA(); public List\u0026lt;Emp\u0026gt; listEmp(){ List\u0026lt;Emp\u0026gt; empList = empDao.listEmp(); empList.forEach(emp -\u0026gt; { String gender = emp.getGender(); if(\u0026#34;1\u0026#34;.equals(gender)){ emp.setGender(\u0026#34;男\u0026#34;); } else if (\u0026#34;2\u0026#34;.equals(gender)) { emp.setGender(\u0026#34;女\u0026#34;); } String job = emp.getJob(); if(\u0026#34;1\u0026#34;.equals(job)){ emp.setJob(\u0026#34;講師\u0026#34;); } else if (\u0026#34;2\u0026#34;.equals(job)) { emp.setJob(\u0026#34;班主任\u0026#34;); } else if (\u0026#34;3\u0026#34;.equals(job)) { emp.setJob(\u0026#34;就業指導\u0026#34;); } }); return empList; } } Dao データ注入がないから、修正は不要だよ。\n@Primary もしServiceにEmpServiceBという別の実装クラスを追加して、それにも@Autowiredを使ったら、プログラムはエラーになるんだ。その場合は@Primaryアノテーションを使って、どれを使うか指定できるよ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 // interface public interface EmpService { public List\u0026lt;Emp\u0026gt; listEmp(); } // 実装クラスに追加 @Service // このクラスをIOCコンテナに管理させ、IOCコンテナのBeanにする public class EmpServiceA implements EmpService { @Autowired // 実行時、IOCコンテナがこの型のBeanオブジェクトを提供し、この変数に代入するんだ -- 依存性注入 private EmpDao empDao; // private EmpDao empDao = new EmpDaoA(); public List\u0026lt;Emp\u0026gt; listEmp(){ List\u0026lt;Emp\u0026gt; empList = empDao.listEmp(); empList.forEach(emp -\u0026gt; { String gender = emp.getGender(); if(\u0026#34;1\u0026#34;.equals(gender)){ emp.setGender(\u0026#34;男\u0026#34;); } else if (\u0026#34;2\u0026#34;.equals(gender)) { emp.setGender(\u0026#34;女\u0026#34;); } String job = emp.getJob(); if(\u0026#34;1\u0026#34;.equals(job)){ emp.setJob(\u0026#34;講師\u0026#34;); } else if (\u0026#34;2\u0026#34;.equals(job)) { emp.setJob(\u0026#34;班主任\u0026#34;); } else if (\u0026#34;3\u0026#34;.equals(job)) { emp.setJob(\u0026#34;就業指導\u0026#34;); } }); return empList; } } @Primary // このBeanを使う @Service // このクラスをIOCコンテナに管理させ、IOCコンテナのBeanにする public class EmpServiceB implements EmpService { @Autowired // 実行時、IOCコンテナがこの型のBeanオブジェクトを提供し、この変数に代入するんだ -- 依存性注入 private EmpDao empDao; // private EmpDao empDao = new EmpDaoA(); public List\u0026lt;Emp\u0026gt; listEmp(){ List\u0026lt;Emp\u0026gt; empList = empDao.listEmp(); empList.forEach(emp -\u0026gt; { String gender = emp.getGender(); if(\u0026#34;1\u0026#34;.equals(gender)){ emp.setGender(\u0026#34;男\u0026#34;); } else if (\u0026#34;2\u0026#34;.equals(gender)) { emp.setGender(\u0026#34;女\u0026#34;); } String job = emp.getJob(); if(\u0026#34;1\u0026#34;.equals(job)){ emp.setJob(\u0026#34;講師\u0026#34;); } else if (\u0026#34;2\u0026#34;.equals(job)) { emp.setJob(\u0026#34;班主任\u0026#34;); } else if (\u0026#34;3\u0026#34;.equals(job)) { emp.setJob(\u0026#34;就業指導\u0026#34;); } }); return empList; } } @Qualifier どのBeanを使うか指定するアノテーションで、Controllerで使うよ。上の@Primaryアノテーションはキャンセルするね。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @RestController public class EmpController { @Qualifier(\u0026#34;empServiceA\u0026#34;) // Bean `empServiceA`を使う @Autowired // 実行時、IOCコンテナがこの型のBeanオブジェクトを提供し、この変数に代入するんだ -- 依存性注入 private EmpService empService; @RequestMapping(\u0026#34;/listEmp\u0026#34;) public Result listEmp(){ //EmpService empServiceA = new EmpServiceA(); //List\u0026lt;Emp\u0026gt; empList = empServiceA.listEmp(); List\u0026lt;Emp\u0026gt; empList = empService.listEmp(); return Result.success(empList); } } @Resource @Qualifierと似てるんだけど、@Autowiredは使わないよ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @RestController public class EmpController { // @Qualifier(\u0026#34;empServiceA\u0026#34;) // Bean `empServiceA`を使う // @Autowired @Resource(name = \u0026#34;empServiceB\u0026#34;) // Bean `empServiceB`を使う private EmpService empService; @RequestMapping(\u0026#34;/listEmp\u0026#34;) public Result listEmp(){ //EmpService empServiceA = new EmpServiceA(); //List\u0026lt;Emp\u0026gt; empList = empServiceA.listEmp(); List\u0026lt;Emp\u0026gt; empList = empService.listEmp(); return Result.success(empList); } } @Autowiredと@Resourceの違い\n@AutowiredはSpringフレームワークが提供するアノテーションで、@ResourceはJDKが提供するアノテーションだよ。\n@Autowiredはデフォルトで型に基づいて注入するけど、@Resourceはデフォルトで名前に基づいて注入するんだ。\n","date":"2024-01-19T10:37:15+08:00","permalink":"https://blog.yexca.net/ja/archives/147/","title":"3層アーキテクチャとレイヤーの疎結合"},{"content":" 📢 この記事は gemini-2.5-flash によって翻訳されました はじめに HTML 学習 その1 - 基礎: https://blog.yexca.net/ja/archives/146 HTML 学習 その2 - リスト、テーブル、フォーム: https://blog.yexca.net/ja/archives/150 HTML 学習 その3 - ウェブページのレイアウト: https://blog.yexca.net/ja/archives/195 基本的な骨組み 1 2 3 4 5 6 7 8 \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;ウェブページのタイトル\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; ウェブページの本文 \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 普通はソフトウェアで自動生成されるよ。例えば、VS Code で .html ファイルを新規作成して、!って入力してTABキーを押すと自動で生成してくれるんだ。\nheadタグは主にブラウザ向け、bodyタグはユーザー向けって感じかな。\nコメント 1 \u0026lt;!-- コメント内容 --\u0026gt; VS Code では、行を選択してショートカットキーの Ctrl + / を使うと一発でコメントアウトできるよ。\nブラウザはコメントの中身は表示しないんだ。\n見出しと段落 1 2 3 4 5 6 7 8 \u0026lt;h1\u0026gt;レベル1見出し\u0026lt;/h1\u0026gt; \u0026lt;h2\u0026gt;レベル2見出し\u0026lt;/h2\u0026gt; \u0026lt;h3\u0026gt;レベル3見出し\u0026lt;/h3\u0026gt; \u0026lt;h4\u0026gt;レベル4見出し\u0026lt;/h4\u0026gt; \u0026lt;h5\u0026gt;レベル5見出し\u0026lt;/h5\u0026gt; \u0026lt;h6\u0026gt;レベル6見出し\u0026lt;/h6\u0026gt; \u0026lt;p\u0026gt;段落内容\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;段落内容\u0026lt;/p\u0026gt; 見出しタグは文字が太字になって、一行を独占するよ。\n段落タグの中身も一行を独占するんだけど、段落と段落の間には隙間ができるんだ。\n改行と水平線 段落タグの中身を改行しても表示されないから、改行したいときは改行タグを使う必要があるよ。\n1 \u0026lt;br /\u0026gt; 水平線タグのコードはこんな感じ。\n1 \u0026lt;hr /\u0026gt; 表示はこんな感じ。\nテキスト書式設定タグ 効果 タグ名 略称 太字 strong b 斜体 em i 下線 ins u 取り消し線 del s 普通は略称を使うのはおすすめしないよ。使用例はこんな感じ。\n1 2 3 4 \u0026lt;p\u0026gt; こんにちは、\u0026lt;em\u0026gt;yexca\u0026lt;/em\u0026gt;だよ。このブログに\u0026lt;strong\u0026gt;ようこそ\u0026lt;/strong\u0026gt;！\u0026lt;ins\u0026gt;見てくれてありがとう\u0026lt;/ins\u0026gt;\u0026lt;br /\u0026gt; \u0026lt;del\u0026gt;で、次は何を書けばいいんだっけ？\u0026lt;/del\u0026gt; \u0026lt;/p\u0026gt; 表示はこんな感じ。\nこんにちは、yexcaだよ。このブログにようこそ！見てくれてありがとう\nで、次は何を書けばいいんだっけ？ 画像タグ 画像タグは、src属性で画像の場所を指定する必要があるんだ。\n1 \u0026lt;img src=\u0026#34;path\u0026#34; alt=\u0026#34;画像が読み込めない時に表示される内容\u0026#34; /\u0026gt; パスには絶対パスと相対パスがあるよ。今のパスを（Linuxシステムだと仮定して）こうするね。\n1 2 3 /home/yexca/code index.html photo.jpg index.htmlファイルにコードを書くとして、相対パスはこうなるよ。\n1 \u0026lt;img src=\u0026#34;./photo.jpg\u0026#34; /\u0026gt; 絶対パスはこう。\n1 \u0026lt;img src=\u0026#34;/home/yexca/code/photo.jpg\u0026#34; /\u0026gt; ハイパーリンクタグ 1 \u0026lt;a href=\u0026#34;目的のページ\u0026#34; target=\u0026#34;方法\u0026#34;\u0026gt;リンクテキスト\u0026lt;/a\u0026gt; このタグはウェブページにジャンプするための、つまりウェブサイトのリンクなんだ。もし新しいウィンドウでページを開きたいなら、target属性の値を_blankにするだけでいいよ。例えばこんなコード。\n1 2 3 4 5 \u0026lt;p\u0026gt; ジャンプ先： \u0026lt;a href=\u0026#34;https://yexca.net\u0026#34;\u0026gt;yexca\u0026lt;/a\u0026gt;\u0026lt;br /\u0026gt; これは新しいタブで開くよ：\u0026lt;a href=\u0026#34;https://yexca.net\u0026#34;\u0026gt;yexca\u0026lt;/a\u0026gt; \u0026lt;/p\u0026gt; 表示はこんな感じ。\nジャンプ先： yexca\nこれは新しいタブで開くよ：yexca 音声・動画タグ 1 2 \u0026lt;audio src=\u0026#34;path\u0026#34;\u0026gt;音声タグ\u0026lt;/audio\u0026gt; \u0026lt;video src=\u0026#34;path\u0026#34;\u0026gt;動画タグ\u0026lt;/video\u0026gt; 音声タグの属性はこんな感じだよ。\n属性 役割 説明 src 音声ファイルのパス 必須属性、mp3、ogg、wavに対応 controls 音声コントロールパネルを表示 loop 繰り返し再生 autoplay 自動再生 ブラウザは通常、自動再生を禁止してるよ 動画タグの属性はこんな感じだよ。\n属性 役割 説明 src 動画ファイルのパス 必須属性、mp4、webm、oggに対応 controls 動画コントロールパネルを表示 loop 繰り返し再生 muted ミュートで再生 autoplay 自動再生 ブラウザはミュート状態なら自動再生をサポートしてるよ 今のパスがこんな感じだと仮定するね。\n1 2 3 4 /home/yexca/code index.html audio.mp3 video.mp4 例えばこんなコード。\n1 2 3 4 5 6 7 8 \u0026lt;audio src=\u0026#34;./audio.mp3\u0026#34; controls loop\u0026gt;\u0026lt;/audio\u0026gt; \u0026lt;!-- コントロールを表示して、最後まで再生したら最初に戻ってループ再生 --\u0026gt; \u0026lt;video src=\u0026#34;./video.mp4\u0026#34; controls loop\u0026gt;\u0026lt;/video\u0026gt; \u0026lt;!-- コントロールを表示して、最後まで再生したら最初に戻ってループ再生 --\u0026gt; \u0026lt;video src=\u0026#34;./video.mp4\u0026#34; controls muted autoplay\u0026gt;\u0026lt;/video\u0026gt; \u0026lt;!-- このコードは自動再生されるよ --\u0026gt; \u0026lt;video src=\u0026#34;./video.mp4\u0026#34; controls autoplay\u0026gt;\u0026lt;/video\u0026gt; \u0026lt;!-- このコードは自動再生されないよ --\u0026gt; レイアウトタグ 特に意味を持たないけど、ウェブページのレイアウトに使われるタグだよ。エリアを分けたり、コンテンツを配置したりするのに使うんだ。\ndiv: 一行を独占する span: 改行しない 例えばこんなコード。\n1 2 3 4 5 6 7 8 \u0026lt;div\u0026gt; div1 \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; div2 \u0026lt;/div\u0026gt; \u0026lt;span\u0026gt;span1\u0026lt;/span\u0026gt; \u0026lt;span\u0026gt;span2\u0026lt;/span\u0026gt; 表示はこんな感じ。\ndiv1 div2 span1 span2 文字参照 ウェブページで予約文字を表示するために使うんだ。例えば、半角スペースとか\u0026lt;とか\u0026gt;とかを表示するときだね。\nResult Description Entity Name Entity Number 改行しない スペース \u0026amp;nbsp; \u0026amp;#160; \u0026lt; より小さい \u0026amp;lt; \u0026amp;#60; \u0026gt; より大きい \u0026amp;gt; \u0026amp;#62; \u0026amp; アンパサンド \u0026amp;amp; \u0026amp;#38; “ 二重引用符 \u0026amp;quot; \u0026amp;#34; ‘ 単一引用符（アポストロフィ） \u0026amp;apos; \u0026amp;#39; ¢ セント \u0026amp;cent; \u0026amp;#162; £ ポンド \u0026amp;pound; \u0026amp;#163; ¥ 円 \u0026amp;yen; \u0026amp;#165; € ユーロ \u0026amp;euro; \u0026amp;#8364; © 著作権 \u0026amp;copy; \u0026amp;#169; ® 登録商標 \u0026amp;reg; \u0026amp;#174; 例えば、\u0026lt;p\u0026gt;を表示するとき。\n1 2 3 \u0026lt;p\u0026gt; \u0026amp;lt;p\u0026amp;gt; \u0026lt;/p\u0026gt; 参考： HTML文字参照 \u0026amp;Nbsp; \u0026amp;Ensp; \u0026amp;Emsp; の違い ","date":"2024-01-18T14:43:34+08:00","permalink":"https://blog.yexca.net/ja/archives/146/","title":"HTML 学習 その1 - 基礎"},{"content":" 📢 この記事は gemini-2.5-flash によって翻訳されました システム設計の基本原則 抽象化、モジュール化、情報隠蔽、モジュール独立性\nモジュール化 ソフトウェアのアーキテクチャでは、モジュールは組み合わせたり、分解したり、交換したりできる単位なんだ。\nモジュール化ってのは、開発するソフトウェアをいくつかの小さくてシンプルな部分、つまりモジュールに分解することだよ。各モジュールは独立して開発・テストできて、最後に完全なプログラムとして組み立てられるんだ。これは複雑な問題を「分割統治」するっていう考え方だね。モジュール化の目的は、プログラムの構造を明確にして、読みやすく、理解しやすく、テストしやすく、修正しやすくすることなんだ。\nモジュール独立性 モジュール独立性っていうのは、各モジュールが比較的独立した特定のサブ機能を果たして、他のモジュールとの連携がシンプルであることだよ。モジュール独立性の度合いを測る基準は二つあるんだ。それは結合度と凝集度だね。\n結合度 結合度ってのは、モジュール間の相対的な独立性（互いの繋がりがどれだけ密接か）を測る尺度だよ。結合度は、各モジュール間のインターフェースの複雑さ、モジュールの呼び出し方、インターフェースを介して渡される情報タイプなんかで決まるんだ。一般的に、モジュール間の結合方式は7種類あるよ。\n直接結合なし。これは、二つのモジュール間に直接的な関係がなく、それぞれ異なるモジュールの制御や呼び出しに属していて、互いに情報をやり取りしない場合のことだね。 データ結合。これは、二つのモジュール間に呼び出し関係があって、シンプルなデータ値をやり取りする場合のこと。高級言語の値渡しみたいなもんだね。 スタンプ結合。これは、二つのモジュール間でデータ構造が渡される場合だね。 制御結合。これは、あるモジュールが別のモジュールを呼び出して、制御変数を渡す場合のこと。呼び出されたモジュールは、その制御変数の値によってモジュール内の特定機能を選択的に実行するんだ。 外部結合。これは、モジュールがソフトウェア外部の環境（例えば、I/Oによってモジュールが特定のデバイス、フォーマット、通信プロトコルに結合される場合とか）を介して連携する場合のことだよ。 共通結合。これは、共通のデータ環境を介して相互作用するモジュール間の結合のことだね。 内容結合。これは、あるモジュールが別のモジュールの内部データを直接使ったり、非正常な入り口から別のモジュール内部に入り込んだりする場合のこと。こういうモジュール間の結合を内容結合って呼ぶんだ。 凝集度 凝集度ってのは、モジュール内部の各要素がどれだけ密接に結びついているかを測る尺度だよ。凝集度の高いモジュール（理想的には）は、一つのことだけをすべきなんだ。一般的にモジュールの凝集度は7種類に分けられるよ。\n偶然的凝集（偶発的凝集）。これは、モジュール内の各処理要素間に何の関連性もない場合のことだね。 論理的凝集。これは、モジュール内で論理的に類似した複数の機能を実行して、パラメータによってどの機能を実行するかを決める場合だよ。 時間的凝集。これは、同時に実行する必要があるアクションをまとめて形成されたモジュールを指すんだ。 手順的凝集。これは、あるモジュールが複数のタスクをこなすんだけど、それらのタスクが指定された手順で実行される必要がある場合のことだよ。 情報的凝集（通信的凝集）。これは、モジュール内のすべての処理要素が同じデータ構造を操作するか、あるいは各処理が同じ入力データを使ったり同じ出力データを生成したりする場合を言うんだ。 連続的凝集。これは、モジュール内の各処理要素が同じ機能に密接に関連していて、しかも順序通りに実行される必要がある場合のこと。前の機能要素の出力が次の機能要素の入力になるんだ。 機能的凝集。これは最も強い凝集で、モジュール内のすべての要素が協力して一つの機能を完成させること。どれか一つでも欠けたらダメなんだ。 結合度と凝集度は、モジュール独立性の二つの定性的な基準なんだ。ソフトウェアシステムをモジュールに分割するときは、できるだけ高凝集・低結合になるようにして、モジュールの独立性を高めるようにしようね。\nシステム構造設計の原則 全体の構造設計をスムーズに完了させるために、以下の原則に従うべきだよ。\n分解・協調の原則。システム全体は一つのまとまりで、全体的な目的と機能を持っているけど、これらの目的や機能の実現は、互いに関連し合う各構成要素が協力して働く結果なんだ。複雑な問題を解決するためのすごく重要な原則の一つは、それを複数の小さな問題に分解してそれぞれ処理すること。その処理の過程で、システム全体の要求に基づいて各部門の関係を調整するんだ。 トップダウンの原則。まずシステム全体の機能目的を捉えて、それから段階的に分解していくんだ。つまり、まず上位モジュールの機能を決めて、それから下位モジュールの機能を決めていくってことだね。 情報隠蔽・抽象化の原則。上位モジュールは、下位モジュールが何をすべきか、そして所属モジュール間の調整関係だけを規定するんだ。どうやるかは規定しない。これは各モジュールの相対的な独立性と内部構造の合理性を保証するためで、モジュール間の階層を明確にして、理解しやすく、実装しやすく、保守しやすくするんだよ。 一貫性の原則。ソフトウェア設計プロセス全体を通じて、統一された規範、統一された標準、統一されたドキュメント形式なんかを確保する必要があるよ。 明確性の原則。各モジュールは機能が明確で、インターフェースが正しくなければいけないんだ。複数の機能や無用なインターフェースは排除しよう。 モジュール間の結合はできるだけ小さく、モジュールの凝集度はできるだけ高くしようね。 モジュールのファンインとファンアウトは適切であるべきだよ。あるモジュールが直接呼び出す他のモジュールの数をファンアウト係数って呼ぶんだ。逆に、あるモジュールが他のモジュールに呼び出されるとき、それを直接呼び出すモジュールの数をファンイン係数って呼ぶんだよ。モジュールのファンイン、ファンアウト係数は適切でなければいけないね。経験上、うまく設計されたシステムの平均ファンイン、ファンアウト係数は通常3か4で、一般的には7を超えないようにするべきだ。そうしないと、エラーの発生確率が上がっちゃうからね。ただ、メニュー呼び出し型のモジュールや共通モジュールのファンイン係数は大きくても大丈夫だよ。 モジュールの規模は適切であるべきだよ。大きすぎるモジュールは、システムの分解が不十分になりがちで、内部に複数の機能が含まれている可能性があるんだ。だから、元のモジュールをさらに、できるだけ機能が単一なモジュールに分解する必要があるんだよ。でも、分解も適度にするべきだね。なぜなら、小さすぎるモジュールはモジュールの独立性を下げてしまって、システムインターフェースを複雑にする可能性があるからさ。 モジュールの作用範囲は、その制御範囲内であるべきなんだ。 システムドキュメント 情報システムのドキュメントは、システム構築プロセスの「足跡」であり、システム保守担当者の指針であり、開発者とユーザーのコミュニケーションツールなんだ。規範に沿ったドキュメントがあるってことは、システムが工学的に開発されたってことで、情報システムの品質が形式的に保証されてるってことだよね。ドキュメントが不足したり、適当だったり、規範に沿ってなかったりすると、元の開発者が異動した後、システムが保守もアップグレードもできなくなって、拡張性も生命力もないシステムになっちゃう可能性がすごく高いんだ。\nシステム開発者、プロジェクト管理者、システム保守担当者、システム評価者、そしてユーザー間のドキュメントの様々な役割を以下にまとめるね。\nユーザーとシステムアナリストは、システム企画とシステム分析の段階でドキュメントを介してコミュニケーションを取るんだ。ここでのドキュメントは主に、実現可能性調査報告書、全体計画報告書、システム開発契約書、システム提案書などがあるよ。 システム開発者とプロジェクト管理者は、プロジェクト期間中にドキュメントを介してコミュニケーションを取るんだ。ここでのドキュメントは主に、システム開発計画（作業分解表、PERT図、ガントチャート、予算配分表などを含む）、システム開発月報、システム開発完了報告書などのプロジェクト管理書類だね。 システムテスト担当者とシステム開発者は、ドキュメントを介してコミュニケーションを取るんだ。システムテスト担当者は、システム提案書、システム開発契約書、システム設計書、テスト計画書などのドキュメントに基づいて、システム開発者が開発したシステムをテストできるんだよ。そして、システムテスト担当者は評価結果をシステムテスト報告書としてまとめるんだ。 システム開発者とユーザーは、システム稼働中にドキュメントを介してコミュニケーションを取るんだ。ユーザーは、システム開発者が作成したドキュメントを参考にシステムを運用するよ。ここでのドキュメントは主に、ユーザーマニュアルと操作ガイドだね。 システム開発者とシステム保守担当者は、ドキュメントを介してコミュニケーションを取るんだ。ここでのドキュメントは主に、システム設計書とシステム開発完了報告書だよ。 ユーザーと保守担当者は、運用保守期間中にドキュメントを介してコミュニケーションを取るんだ。ユーザーは情報システムを使っている間に、運用中の問題を記録して、システム運用報告書や保守修正提案書を作成するんだよ。システム保守担当者は、その保守修正提案書やシステム開発者が残した技術マニュアルなどのドキュメントに基づいて、システムを保守・アップグレードするんだ。 ","date":"2024-01-16T08:10:10+08:00","permalink":"https://blog.yexca.net/ja/archives/145/","title":"構造化開発"},{"content":" 📢 この記事は gemini-2.5-flash によって翻訳されました ブラウザがリクエストを送ると、まずDispatcherServletを経由して各*Controllerプログラムに処理が渡されるんだ。処理が終わったら、DispatcherServletに結果が返されて、そこからブラウザに戻る流れだよ。\nDispatcherServletは、コアコントローラとかフロントコントローラって呼ばれるね。\nブラウザからのリクエストデータはHttpServletRequestオブジェクトに、レスポンスデータはHttpServletResponseにそれぞれカプセル化されるんだ。\n*Controllerはリクエストを受け取って、レスポンスを設定するんだ。\nリクエスト シンプルなパラメータ まず、昔ながらの方法だと、リクエストパラメータはHttpServletRequestオブジェクトを使って手動で取得するよ。\n1 2 3 4 5 6 7 8 9 @RequestMapping(\u0026#34;/simpleParam\u0026#34;) public String simpleParam(HttpServletRequest request){ String name = request.getParameter(\u0026#34;name\u0026#34;); String ageStr = request.getParameter(\u0026#34;age\u0026#34;); int age = Integer.parseInt(ageStr); System.out.println(name + \u0026#34;;\u0026#34; + age); return \u0026#34;OK\u0026#34;; } ブラウザで http://localhost:8080/simpleParam?name=tom\u0026age=18 にアクセスすると、ウェブページには「OK」って文字列が返ってきて、プログラムでは「Tom;18」って表示されるよ。\n当然、このやり方だと面倒すぎるよね。SpringBootなら、パラメータ名と仮引数名を同じにするだけで、仮引数でパラメータを受け取れるんだ。\n1 2 3 4 5 @RequestMapping(\u0026#34;/simpleParam\u0026#34;) public String simpleParam(String name, Integer age){ System.out.println(name + \u0026#34;;\u0026#34; + age); return \u0026#34;OK\u0026#34;; } 結果は上と同じだよ。\nただ、上の方法だと、リクエストのパラメータ名が違ってもそのまま実行されて、存在しないパラメータはnullになっちゃうんだ。\n@RequestParamを使えば、リクエスト名と仮引数名が違う場合でもマッピングできるようになるよ。\n1 2 3 4 5 6 7 @RequestMapping(\u0026#34;/simpleParam\u0026#34;) public String simpleParam(@RequestParam(name = \u0026#34;name\u0026#34;) String username, Integer age){ // @RequestParamを宣言すると、そのパラメータは必須になるから、渡さないとエラーになっちゃう // もし@RequestParam(name = \u0026#34;name\u0026#34;, required = false)に変えれば、そのパラメータは必須じゃなくなるよ System.out.println(username + \u0026#34;;\u0026#34; + age); return \u0026#34;OK\u0026#34;; } エンティティパラメータ パラメータが少ないなら上の方法でいいんだけど、データが多い場合はシンプルなエンティティオブジェクトを使えるよ。リクエストパラメータ名と仮引数オブジェクトのプロパティ名を同じにして、POJOを定義すれば受け取れるんだ。\n1 2 3 4 5 6 7 8 9 10 11 12 @RequestMapping(\u0026#34;/simplePojo\u0026#34;) public String simplePojo(User user){ System.out.println(user); return \u0026#34;OK\u0026#34;; } // Userクラス public class User{ private String name; private Integer age; // set/get/toString メソッド } ブラウザで http://localhost:8080/simplePojo?name=tom\u0026age=18 にアクセスすると、ウェブページには「OK」って文字列が返ってきて、プログラムでは「User{name=\u0026lsquo;tom\u0026rsquo;, age=18}」って表示されるよ。\n複雑なエンティティオブジェクトの場合：リクエストパラメータ名と仮引数プロパティ名を同じにして、オブジェクトの階層構造に合わせてネストされたPOJOプロパティパラメータを受け取れるんだ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 @RequestMapping(\u0026#34;/complexPojo\u0026#34;) public String complexPojo(UserComplex user){ System.out.println(user); return \u0026#34;OK\u0026#34;; } // Userクラス public class UserComplex{ private String name; private Integer age; private Address address; // set/get/toString } // Addressクラス public class Address{ private String province; private String city; // set/get/toString } ブラウザで http://localhost:8080/complexPojo?name=tom\u0026age=18\u0026address.province=beijing\u0026address.city=beijing にアクセスすると、ウェブページには「OK」って文字列が返ってきて、プログラムでは「UserComplex{name=\u0026lsquo;tom\u0026rsquo;, age=1000, address=Address{province=\u0026lsquo;ads,beijing\u0026rsquo;, city=\u0026lsquo;asda,beijing\u0026rsquo;}}」って表示されるよ。\n配列パラメータ リクエストパラメータ名と仮引数配列名が同じで、リクエストパラメータが複数ある場合、配列型の仮引数を定義するだけでパラメータを受け取れるよ。例えば、チェックボックスなんかの場合だね。\n1 2 3 4 5 @RequestMapping(\u0026#34;/arrayParam\u0026#34;) public String arrayParam(String[] hobby){ System.out.println(Arrays.toString(hobby)); return \u0026#34;OK\u0026#34;; } ブラウザで http://localhost:8080/arrayParam?hobby=ads\u0026hobby=58s にアクセスすると、ウェブページには「OK」って文字列が返ってきて、プログラムでは「[ads, 58s]」って表示されるよ。\nコレクションパラメータ リクエストパラメータ名と仮引数配列名が同じで、リクエストパラメータが複数ある場合、@RequestParamを使ってパラメータの関係をバインドするんだ。\n1 2 3 4 5 @RequestMapping(\u0026#34;/listParam\u0026#34;) public String listParam(@RequestParam List\u0026lt;String\u0026gt; hobby){ System.out.println(hobby); return \u0026#34;OK\u0026#34;; } ブラウザで http://localhost:8080/listParam?hobby=ads\u0026hobby=58s にアクセスすると、ウェブページには「OK」って文字列が返ってきて、プログラムでは「[ads, 58s]」って表示されるよ。\n日付パラメータ @DateTimeFormatアノテーションを使って、日付パラメータのフォーマット変換を行うんだ。\n注意点として、パラメータの渡し方には3つの形式があるよ。\nyyyy-MM-dd HH:mm:ss yyyy/MM/dd HH:mm:ss yyyy年MM月dd日 HH時mm分ss秒 フロントエンドとバックエンドで統一する必要があるよ。\n1 2 3 4 5 @RequestMapping(\u0026#34;/dateParam\u0026#34;) public String dateParam(@DateTimeFormat(pattern = \u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;) LocalDateTime localDateTime){ System.out.println(localDateTime); return \u0026#34;OK\u0026#34;; } ブラウザで http://localhost:8080/dateParam?localDateTime=2024-01-01%2001:01:01 にアクセスすると、ウェブページには「OK」って文字列が返ってきて、プログラムでは「2024-01-01T01:01:01」って表示されるよ。\nJSONパラメータ JSONデータのキー名と仮引数オブジェクトのプロパティ名を同じにして、POJO型の仮引数を定義すればパラメータを受け取れるよ。@RequestBodyでマークする必要があるんだ。\nJSONデータを送信したい場合は、必ずPOSTリクエストを使う必要があるよ。\n1 2 3 4 5 @RequestMapping(\u0026#34;/jsonParam\u0026#34;) public String jsonParam(@RequestBody UserComplex userComplex){ System.out.println(userComplex); return \u0026#34;OK\u0026#34;; } リクエストデータ\n1 2 3 4 5 6 7 8 { \u0026#34;name\u0026#34;: \u0026#34;jane\u0026#34;, \u0026#34;age\u0026#34;: \u0026#34;18\u0026#34;, \u0026#34;address\u0026#34;: { \u0026#34;province\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34; } } 上記のJSONデータをPOSTメソッドで http://localhost:8080/jsonParam にリクエストすると、ウェブページには「OK」って文字列が返ってきて、プログラムでは「UserComplex{name=\u0026lsquo;jane\u0026rsquo;, age=18, address=Address{province=\u0026lsquo;上海\u0026rsquo;, city=\u0026lsquo;上海\u0026rsquo;}}」って表示されるよ。\nパスパラメータ リクエストURLで直接パラメータを渡す方法だよ。{...}を使ってそのパスパラメータを識別して、@PathVariableで取得する必要があるんだ。\n1 2 3 4 5 @RequestMapping(\u0026#34;/path/{id}\u0026#34;) public String pathParam(@PathVariable Integer id){ System.out.println(id); return \u0026#34;OK\u0026#34;; } ブラウザで http://localhost:8080/path/52 にアクセスすると、ウェブページには「OK」って文字列が返ってきて、プログラムでは「52」って表示されるよ。\nブラウザで http://localhost:8080/path/255 にアクセスすると、ウェブページには「OK」って文字列が返ってきて、プログラムでは「255」って表示されるよ。\n複数のパスパラメータの場合だよ。\n1 2 3 4 5 @RequestMapping(\u0026#34;/path/{id}/{name}\u0026#34;) public String pathParam(@PathVariable Integer id, @PathVariable String name){ System.out.println(id + \u0026#34;;\u0026#34; + name); return \u0026#34;OK\u0026#34;; } ブラウザで http://localhost:8080/path/255/Tom にアクセスすると、ウェブページには「OK」って文字列が返ってきて、プログラムでは「255;Tom」って表示されるよ。\nまとめ シンプルなパラメータ メソッドの仮引数を定義して、リクエストパラメータ名と仮引数変数を一致させるんだ。 もし一致しない場合は、@RequestParamを使って手動でマッピングするよ。 エンティティパラメータ リクエストパラメータ名をエンティティオブジェクトのプロパティ名と一致させると、自動的に受け取ってカプセル化してくれるんだ。 配列・コレクションパラメータ 配列：リクエストパラメータ名と配列名を一致させると、直接カプセル化されるよ。 コレクション：リクエストパラメータ名と配列名を一致させて、@RequestParamで関係をバインドするんだ。 日付パラメータ @DateTimeFormat JSONパラメータ @RequestBody パスパラメータ @PathVariable レスポンス @RequestBodyを使ってレスポンスを処理するよ。\n上のリクエストでレスポンスできたのは、@RestControllerアノテーションが@Controllerと@ResponseBodyを含んでいるからなんだ。\n@RequestBody タイプ：メソッドアノテーション、クラスアノテーション\n場所：Controllerメソッド上またはクラス上\n作用：メソッドの戻り値を直接レスポンスするよ。もし戻り値の型がエンティティオブジェクトやコレクションだったら、JSON形式に変換してレスポンスされるんだ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 @RestController public class ResponseController { @RequestMapping(\u0026#34;/hello\u0026#34;) public String hello(){ System.out.println(\u0026#34;Hello SpringBoot\u0026#34;); return \u0026#34;Hello SpringBoot\u0026#34;; } @RequestMapping(\u0026#34;/getAddr\u0026#34;) public Address getAddr(){ Address address = new Address(); address.setProvince(\u0026#34;上海\u0026#34;); address.setCity(\u0026#34;上海\u0026#34;); return address; } @RequestMapping(\u0026#34;/listAddr\u0026#34;) public List\u0026lt;Address\u0026gt; listAddr(){ List\u0026lt;Address\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); Address address1 = new Address(); address1.setProvince(\u0026#34;北京\u0026#34;); address1.setCity(\u0026#34;北京\u0026#34;); Address address2 = new Address(); address2.setProvince(\u0026#34;上海\u0026#34;); address2.setCity(\u0026#34;上海\u0026#34;); list.add(address1); list.add(address2); return list; } } 対応するURLにアクセスしてテストしてみてね。\n統一されたレスポンス結果 上の3つのメソッドは戻り値の型が全部違うから、フロントエンド開発がちょっと大変だよね。だから、レスポンス結果を一つのクラスに統一できるんだ。\n1 2 3 4 5 6 7 8 9 public class Result{ // レスポンスコード、1は成功、0は失敗を表すよ private Integer code; // メッセージ private String msg; // 返されるデータ private Object data; // ... } すべてのレスポンスメソッドがResultオブジェクトを返すようにすれば、プロジェクトの管理と保守がもっと楽になるんだ。\n例えば、こんなクラスだよ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 public class Result { private Integer code ;//1 成功 , 0 失敗 private String msg; //メッセージ private Object data; //データ data public Result() { } public Result(Integer code, String msg, Object data) { this.code = code; this.msg = msg; this.data = data; } public Integer getCode() { return code; } public void setCode(Integer code) { this.code = code; } public String getMsg() { return msg; } public void setMsg(String msg) { this.msg = msg; } public Object getData() { return data; } public void setData(Object data) { this.data = data; } public static Result success(Object data){ return new Result(1, \u0026#34;success\u0026#34;, data); } public static Result success(){ return new Result(1, \u0026#34;success\u0026#34;, null); } public static Result error(String msg){ return new Result(0, msg, null); } @Override public String toString() { return \u0026#34;Result{\u0026#34; + \u0026#34;code=\u0026#34; + code + \u0026#34;, msg=\u0026#39;\u0026#34; + msg + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, data=\u0026#34; + data + \u0026#39;}\u0026#39;; } } そうすると、上のコードはこう変えられるよ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 @RequestMapping(\u0026#34;/hello\u0026#34;) public Result hello(){ System.out.println(\u0026#34;Hello SpringBoot\u0026#34;); return Result.success(\u0026#34;Hello SpringBoot\u0026#34;); } @RequestMapping(\u0026#34;/getAddr\u0026#34;) public Result getAddr(){ Address address = new Address(); address.setProvince(\u0026#34;上海\u0026#34;); address.setCity(\u0026#34;上海\u0026#34;); return Result.success(address); } @RequestMapping(\u0026#34;/listAddr\u0026#34;) public Result listAddr(){ List\u0026lt;Address\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); Address address1 = new Address(); address1.setProvince(\u0026#34;北京\u0026#34;); address1.setCity(\u0026#34;北京\u0026#34;); Address address2 = new Address(); address2.setProvince(\u0026#34;上海\u0026#34;); address2.setCity(\u0026#34;上海\u0026#34;); list.add(address1); list.add(address2); return Result.success(list); } 対応するURLにアクセスしてテストしてみてね。\n","date":"2024-01-14T16:47:28+08:00","permalink":"https://blog.yexca.net/ja/archives/144/","title":"Springのリクエストとレスポンス"},{"content":" 📢 この記事は gemini-3-flash-preview によって翻訳されました Mavenは、Javaプロジェクトの管理とビルドを行うためのツールだよ。\nMavenを使うと、プロジェクトが依存しているリソース（jarパッケージ）を簡単かつスピーディに管理できて、バージョンの衝突も避けられるんだ。標準的で統一されたプロジェクト構造や、プラットフォームに依存しない自動ビルド方法も提供してくれるよ。\nインストール 公式サイト でダウンロードして解凍したら、ローカルリポジトリを設定しよう。conf/setting.xml の \u0026lt;localRepository\u0026gt; を特定のディレクトリに変更するんだ。\n1 2 \u0026lt;!-- 例えばローカルリポジトリを D:\\develop\\maven_repo にする場合 --\u0026gt; \u0026lt;localRepository\u0026gt;D:\\develop\\maven_repo\u0026lt;/localRepository\u0026gt; アリババクラウド（Aliyun）のプライベートミラーを設定するには、conf/setting.xml の \u0026lt;mirror\u0026gt; タグ内に子タグを追加してね。\n1 2 3 4 5 6 \u0026lt;mirror\u0026gt; \u0026lt;id\u0026gt;alimaven\u0026lt;/id\u0026gt; \u0026lt;name\u0026gt;aliyun maven\u0026lt;/name\u0026gt; \u0026lt;url\u0026gt;http://maven.aliyun.com/nexus/content/groups/public/\u0026lt;/url\u0026gt; \u0026lt;mirrorOf\u0026gt;central\u0026lt;/mirrorOf\u0026gt; \u0026lt;/mirror\u0026gt; 環境変数の設定：MAVEN_HOME をMavenの解凍ディレクトリにして、その中の bin ディレクトリを PATH 環境変数に追加しよう。\nインストール完了のテスト：コマンドラインで mvn -v を入力して出力を確認してみて。\n依存関係の設定 依存関係（Dependency）：プロジェクトの実行に必要な jar パッケージのこと。1つのプロジェクトに複数の依存関係を導入できるよ。\n設定の手順：\npom.xml に \u0026lt;dependencies\u0026gt; タグを書く \u0026lt;dependencies\u0026gt; タグの中で \u0026lt;dependency\u0026gt; を使って座標を導入する 座標の groupId, artifactId, version を定義する 設定を更新して、新しく追加した座標を取り込む 1 2 3 4 5 6 7 8 \u0026lt;!-- 例えば logback を導入する場合 --\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;ch.qos.logback\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;logback-classic\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.3\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 依存関係の座標情報は https://mvnrepository.com/ で探せるよ。\n依存関係の推移 依存関係には推移性があるんだ。\n直接依存：今のプロジェクトで依存設定を通じて直接作られた依存関係。 間接依存：依存しているリソースが他のリソースに依存している場合、今のプロジェクトも間接的にそのリソースに依存することになる。 依存関係を追加したとき、そのパッケージが他のパッケージに依存していれば、関連するパッケージも自動的に追加されるよ。\nもちろん、あるパッケージのサブパッケージが必要ない場合は、依存関係を除外することもできる（依存を自ら断ち切るリソースについては、バージョンを指定する必要はないよ）。\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;!-- 例えばあるプロジェクトの junit を除外する場合 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.yexca\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-project\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;exclusions\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;groupId\u0026gt;junit\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit\u0026lt;/artifactId\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;/exclusions\u0026gt; \u0026lt;/dependency\u0026gt; 依存関係のスコープ 依存している jar パッケージは、デフォルトではどこでも使えるけど、\u0026lt;scope\u0026gt;...\u0026lt;/scope\u0026gt; を使ってその有効範囲を設定できるんだ。\nメインプログラムの範囲で有効（main フォルダ内） テストプログラムの範囲で有効（test フォルダ内） パッケージングして実行する際に含まれるか（package コマンドの範囲内） scopeの値 メインプログラム テストプログラム パッケージング (実行) 例 compile (デフォルト) Y Y Y log4j test - Y - junit provided Y Y - servlet-api runtime - Y Y jdbc ドライバ 1 2 3 4 5 6 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;junit\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.10\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; ライフサイクル Maven のライフサイクルは、すべての Maven プロジェクトのビルドプロセスを抽象化して統一するためにあるんだ。\nMaven には、互いに独立した 3 つのライフサイクルがあるよ：\nclean：掃除作業 default：コア作業（コンパイル、テスト、パッケージング、インストール、デプロイなど） site：レポート生成、サイト公開など それぞれのライフサイクルはいくつかのフェーズ（phase）で構成されていて、フェーズには順番があるんだ。後のフェーズは前のフェーズに依存しているよ。\nclean pre-clean clean：前回ビルドで生成されたファイル（target フォルダ）を削除する post-clean default validate initialize generate-sources process-sources generate-resources process-resources compile：プロジェクトのソースコードをコンパイルする process-classes generate-test-sources process-test-sources generate-test-resources process-test-resources test-compile process-test-classes test：適切なユニットテストフレームワーク（junit）を使ってテストを実行する prepare-package package：コンパイル後のファイルを jar や war などにパッケージングする verify install：プロジェクトをローカルリポジトリにインストールする deploy site pre-site site post-site site-deploy 同じライフサイクルの中で後のフェーズを実行すると、それより前のフェーズもすべて実行されるよ。\nマルチモジュール設計 マルチモジュール設計とは、プロジェクトの設計段階で大きなプロジェクトをいくつかのモジュールに分割すること。各モジュールは独立していて、別のモジュールの機能が必要になったら、そのモジュールを依存関係として追加するだけでいいんだ。\n共通のエンティティクラスやツールクラスを独立したモジュールにしておけば、あるモジュールでそれを使いたい時に対応する依存関係を入れるだけで済むよ。\nプロジェクトの管理・メンテナンス・拡張がしやすくなるし、モジュール間の呼び出しやリソースの共有も便利になるんだ。\n継承 Lombok みたいな依存関係は、プロジェクトの全モジュールで使うかもしれないよね。各モジュールで毎回宣言するのは面倒だけど、継承を使えばこの問題を解決できるよ。\n継承関係 親プロジェクトを作成して、モジュール共通の依存関係を親プロジェクトにまとめて設定するんだ。子プロジェクトが親プロジェクトを継承すれば、依存関係も継承されるから、各子プロジェクトで設定する必要がなくなるよ。\n継承は 2 つのプロジェクト間の関係を表すもので、Java の継承と似ているんだ。子プロジェクトは親プロジェクトの設定情報を継承できる。特によくあるのが依存関係の継承で、これによって依存設定を簡略化し、一括管理できるようになるよ。\n1 2 3 4 5 6 7 \u0026lt;!--親プロジェクトを指定--\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;...\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;...\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;...\u0026lt;/version\u0026gt; \u0026lt;relativePath\u0026gt;....\u0026lt;/relativePath\u0026gt; \u0026lt;/parent\u0026gt; JavaWeb 開発なら、親プロジェクトに spring-boot-starter-parent を継承させて、他のモジュールがその親プロジェクトを継承する形にできるね。\n普通、ファイル構造上では、子プロジェクトは親プロジェクトのサブディレクトリになるよ。\n以下は例：\n親プロジェクトのパッケージング方式を pom にする 1 2 3 4 5 6 7 8 9 10 11 \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.7.5\u0026lt;/version\u0026gt; \u0026lt;relativePath/\u0026gt; \u0026lt;!-- lookup parent from repository --\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;groupId\u0026gt;net.yexca\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;tlias-parent\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;packaging\u0026gt;pom\u0026lt;/packaging\u0026gt; Maven のパッケージング方式：\njar：通常のモジュール。SpringBoot プロジェクトは基本 jar パッケージ（tomcat 内蔵で動く）。 war：通常の Web プログラム。外部の tomcat サーバにデプロイして動かす必要がある。 pom：親プロジェクトや集約プロジェクト。このモジュールにはコードを書かず、依存関係の管理だけを行う。 子プロジェクトで親プロジェクトを指定する 1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;net.yexca\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;tlias-parent\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;!-- 親プロジェクトのpomファイルの相対パスを指定（指定しない場合はローカル/リモートリポジトリから探される） --\u0026gt; \u0026lt;relativePath\u0026gt;../tlias-parent/pom.xml\u0026lt;/relativePath\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;!-- \u0026lt;groupId\u0026gt;net.yexca\u0026lt;/groupId\u0026gt; -\t親プロジェクトから自動継承されるので省略可能 --\u0026gt; \u0026lt;artifactId\u0026gt;tlias-utils\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; 親プロジェクトで共通の依存関係を設定する 1 2 3 4 5 6 7 \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.18.24\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; バージョンロック 一部のモジュールには必要だけど、他のモジュールには必要ない依存関係がある場合、親プロジェクトで依存関係の version を管理しておくと、変更が楽になるよ。\n\u0026lt;dependencyManagement\u0026gt; タグで依存関係のバージョンを管理できるんだ。\n親プロジェクト：\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;!--依存関係のバージョンを一括管理--\u0026gt; \u0026lt;dependencyManagement\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!--JWTトークン--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.jsonwebtoken\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jjwt\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.9.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/dependencyManagement\u0026gt; 子プロジェクト：\n1 2 3 4 5 6 7 8 9 10 \u0026lt;dependencies\u0026gt; \u0026lt;!--JWTトークン--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.jsonwebtoken\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jjwt\u0026lt;/artifactId\u0026gt; \u0026lt;!-- \u0026lt;version\u0026gt;0.9.1\u0026lt;/version\u0026gt; - 親プロジェクトでバージョンが指定されているので、記入不要 --\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 親プロジェクトの \u0026lt;dependencyManagement\u0026gt; 設定はバージョンを管理するだけで、依存関係を子プロジェクトに自動導入することはないよ。子プロジェクト側で導入して初めて使えるようになるんだけど、その時にバージョン番号を指定する必要がなくなるんだ。\n一方で、\u0026lt;dependencies\u0026gt; は依存関係を子プロジェクトに強制的に継承させるよ。\nプロパティ設定 カスタムプロパティを使って、親プロジェクトで依存関係のバージョンを一箇所で管理・メンテナンスすることもできるよ。\nプロパティの定義：\n1 2 3 \u0026lt;properties\u0026gt; \u0026lt;lombok.version\u0026gt;1.18.24\u0026lt;/lombok.version\u0026gt; \u0026lt;/properties\u0026gt; プロパティの引用：\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${lombok.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; これで親プロジェクトにすべてのバージョン番号をまとめて管理できるね。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 \u0026lt;properties\u0026gt; \u0026lt;maven.compiler.source\u0026gt;11\u0026lt;/maven.compiler.source\u0026gt; \u0026lt;maven.compiler.target\u0026gt;11\u0026lt;/maven.compiler.target\u0026gt; \u0026lt;lombok.version\u0026gt;1.18.24\u0026lt;/lombok.version\u0026gt; \u0026lt;jjwt.version\u0026gt;0.9.1\u0026lt;/jjwt.version\u0026gt; \u0026lt;aliyun.oss.version\u0026gt;3.15.1\u0026lt;/aliyun.oss.version\u0026gt; \u0026lt;jaxb.version\u0026gt;2.3.1\u0026lt;/jaxb.version\u0026gt; \u0026lt;activation.version\u0026gt;1.1.1\u0026lt;/activation.version\u0026gt; \u0026lt;jaxb.runtime.version\u0026gt;2.3.3\u0026lt;/jaxb.runtime.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${lombok.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;!--依存関係のバージョンを一括管理--\u0026gt; \u0026lt;dependencyManagement\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!--JWTトークン--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.jsonwebtoken\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jjwt\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${jjwt.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--アリババクラウドOSS--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.aliyun.oss\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;aliyun-sdk-oss\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${aliyun.oss.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.xml.bind\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jaxb-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${jaxb.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.activation\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;activation\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${activation.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 2.3.3以下推奨 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.glassfish.jaxb\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jaxb-runtime\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${jaxb.runtime.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/dependencyManagement\u0026gt; 依存関係のバージョンを変更したいときは、親プロジェクトのカスタムプロパティの値を書き換えるだけで OK だよ。\n集約 あるモジュールが別のモジュールに依存している場合、そのモジュールをパッケージングする前に、まず依存先のモジュールをローカルリポジトリに install しないといけないんだ。依存モジュールが多いと、この操作がすごく面倒だよね。\nMaven の集約（Aggregation）を使えば、プロジェクトの一括ビルド（クリーン、コンパイル、テスト、パッケージ、インストールなど）が簡単にできるよ。\n集約： 複数のモジュールを一つの全体としてまとめ、同時にプロジェクトを構築すること。 集約プロジェクト： ビジネス機能を持たない「空」のプロジェクト（pom ファイルのみを持つ。一般的に、継承関係の親プロジェクトと集約プロジェクトは同じものにするよ）。 役割： プロジェクトの高速ビルド（依存関係に合わせて手動でビルドする必要がなく、集約プロジェクトでビルドすれば完了する）。 集約プロジェクトの \u0026lt;modules\u0026gt; タグで、含まれる子モジュールの名称を設定できるんだ。\n1 2 3 4 5 6 7 \u0026lt;!--他のモジュールを集約--\u0026gt; \u0026lt;modules\u0026gt; \u0026lt;!-- プロジェクトのパス --\u0026gt; \u0026lt;module\u0026gt;../tlias-pojo\u0026lt;/module\u0026gt; \u0026lt;module\u0026gt;../tlias-utils\u0026lt;/module\u0026gt; \u0026lt;module\u0026gt;../tlias-web-management\u0026lt;/module\u0026gt; \u0026lt;/modules\u0026gt; あとは集約プロジェクトでコンパイルやパッケージング、インストールの操作をするだけで、他のプロジェクトも自動的に同期して実行されるよ。\n継承 集約 役割 依存設定の簡略化、依存関係の一括管理 プロジェクトの高速ビルド 共通点 パッケージング方式はいずれも pom で、通常一つの pom にまとめる いずれも設計用のモジュールで、実際の中身（コード）はない 相違点 子モジュール側で関係を設定する。\n親モジュールはどの子が自分を継承しているか知らない 集約プロジェクト側で関係を設定する。\n集約プロジェクトはどのモジュールが集約されているか知っている プライベートリポジトリ（私服） プライベートリポジトリ（私服）は特殊なリモートリポジトリで、ローカルネットワーク内に設置されるリポジトリサービスだよ。外部の中央リポジトリを代理し、チーム内部でのリソース共有や同期の問題を解決するために使われるんだ。\nプロジェクトでサードパーティの依存関係を使うとき、ローカルリポジトリになければ自動的に私服に繋いでダウンロードする。私服にもなければ、私服が中央リポジトリに繋いでダウンロードし、それを私服内とローカルリポジトリの両方に保存してくれるよ。\n私服は普通、会社に1台あるものだから、自分一人で設定することはあまりないかな。\nリポジトリの種類とプロジェクトバージョン 私服リポジトリの説明：\nRELEASE：自社開発した RELEASE（リリース）バージョンのリソースを保存する。 SNAPSHOT：自社開発した SNAPSHOT（スナップショット）バージョンのリソースを保存する。 Central：中央リポジトリからダウンロードしてきた依存関係を保存する。 プロジェクトバージョンの説明：\nRELEASE（リリース版）：機能が安定し、更新が止まった、配布可能なバージョン。私服の RELEASE リポジトリに保存される。 SNAPSHOT（快照版）：機能が不安定で、開発途中のバージョン。私服の SNAPSHOT リポジトリに保存される。 設定 私服へのアクセスのためのユーザー名とパスワードを設定しよう。Maven インストールディレクトリの conf/settings.xml の servers に設定するよ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;servers\u0026gt; \u0026lt;server\u0026gt; \u0026lt;id\u0026gt;maven-releases\u0026lt;/id\u0026gt; \u0026lt;username\u0026gt;admin\u0026lt;/username\u0026gt; \u0026lt;password\u0026gt;admin\u0026lt;/password\u0026gt; \u0026lt;/server\u0026gt; \u0026lt;server\u0026gt; \u0026lt;id\u0026gt;maven-snapshots\u0026lt;/id\u0026gt; \u0026lt;username\u0026gt;admin\u0026lt;/username\u0026gt; \u0026lt;password\u0026gt;admin\u0026lt;/password\u0026gt; \u0026lt;/server\u0026gt; \u0026lt;/servers\u0026gt; 私服から依存関係をダウンロードするためのリポジトリグループのアドレスを設定する。ファイルは同じく settings.xml の mirrors と profiles タグの中だよ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 \u0026lt;mirrors\u0026gt; \u0026lt;mirror\u0026gt; \u0026lt;id\u0026gt;maven-public\u0026lt;/id\u0026gt; \u0026lt;mirrorOf\u0026gt;*\u0026lt;/mirrorOf\u0026gt; \u0026lt;url\u0026gt;http://127.0.0.1:8081/repository/maven-public/\u0026lt;/url\u0026gt; \u0026lt;/mirror\u0026gt; \u0026lt;/mirrors\u0026gt; \u0026lt;profiles\u0026gt; \u0026lt;profile\u0026gt; \u0026lt;id\u0026gt;allow-snapshots\u0026lt;/id\u0026gt; \u0026lt;activation\u0026gt; \u0026lt;activeByDefault\u0026gt;true\u0026lt;/activeByDefault\u0026gt; \u0026lt;/activation\u0026gt; \u0026lt;repositories\u0026gt; \u0026lt;repository\u0026gt; \u0026lt;id\u0026gt;maven-public\u0026lt;/id\u0026gt; \u0026lt;url\u0026gt;http://127.0.0.1:8081/repository/maven-public/\u0026lt;/url\u0026gt; \u0026lt;releases\u0026gt; \u0026lt;enabled\u0026gt;true\u0026lt;/enabled\u0026gt; \u0026lt;/releases\u0026gt; \u0026lt;snapshots\u0026gt; \u0026lt;enabled\u0026gt;true\u0026lt;/enabled\u0026gt; \u0026lt;/snapshots\u0026gt; \u0026lt;/repository\u0026gt; \u0026lt;/repositories\u0026gt; \u0026lt;/profile\u0026gt; \u0026lt;/profiles\u0026gt; pom.xml にアップロード先のアドレスを設定しよう。親プロジェクトで設定すれば OK だよ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;distributionManagement\u0026gt; \u0026lt;!-- RELEASE版の公開先アドレス --\u0026gt; \u0026lt;repository\u0026gt; \u0026lt;id\u0026gt;maven-releases\u0026lt;/id\u0026gt; \u0026lt;url\u0026gt;http://127.0.0.1:8081/repository/maven-releases/\u0026lt;/url\u0026gt; \u0026lt;/repository\u0026gt; \u0026lt;!-- SNAPSHOT版の公開先アドレス --\u0026gt; \u0026lt;snapshotRepository\u0026gt; \u0026lt;id\u0026gt;maven-snapshots\u0026lt;/id\u0026gt; \u0026lt;url\u0026gt;http://127.0.0.1:8081/repository/maven-snapshots/\u0026lt;/url\u0026gt; \u0026lt;/snapshotRepository\u0026gt; \u0026lt;/distributionManagement\u0026gt; 設定ができたら、親プロジェクトの deploy ライフサイクルを実行すれば、プロジェクトが私服リポジトリに公開されるよ。\n","date":"2024-01-13T23:58:42+08:00","permalink":"https://blog.yexca.net/ja/archives/143/","title":"Mavenの学習"},{"content":"SpringBoot 入門の例 要件：SpringBoot 开发一个 Web 应用，浏览器発行起 /hello 後，返字文字列 “Hello Spring” を使用します。\n最初に必要な SpringBoot 工程、段階选 web 开公開相关依赖\nその後、制御制御クラス、路線径が *Application.java に同定されています Controller/HelloController.java\n1 2 3 4 5 6 7 8 9 @RestController public class HelloController{ @RequestMapping(\u0026#34;/hello\u0026#34;) public String hello(){ String s = \u0026#34;Hello Spring\u0026#34;; System.out.println(s); return s; } } *Application.java を実行して，ブラウザで http://localhost:8080/hello にアクセスして。\nHTTP ハイパーテキスト転送プロトコルは、TCP プロトコル (接続指向、安全) と要求応答モデル (1 つの要求が 1 つの応答に対応する) に基づいています。\nHTTP プロトコルはステートレス プロトコルであり、トランザクション処理用のメモリ機能はありません。各リクエストとレスポンスは独立しているため高速ですが、複数のリクエスト間でデータを共有することはできません。\n詳細については (簡体字中国語)： https://blog.yexca.net/ja/archives/64 ","date":"2024-01-10T17:53:18+08:00","permalink":"https://blog.yexca.net/ja/archives/142/","title":"JavaWeb 入門"},{"content":" 📢 この記事は ChatGPT によって翻訳されました 新しいディレクトリを作成し、Web ファイルを ./dict に配置する。\nプロジェクトルートに dockerfile ファイルを作成し、以下の内容を記述：\n1 2 3 4 5 6 # nginx:1.20 ベースのイメージを使用 FROM nginx:1.20 # dist フォルダの内容を nginx の静的ファイルディレクトリへコピー COPY dist/ /usr/share/nginx/html/dist/ # nginx 設定をローカルファイルで置き換える COPY nginx.conf /etc/nginx/nginx.conf nginx.conf ファイルの内容は以下の通り：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #user nobody; worker_processes 1; events { worker_connections 1024; } http { include mime.types; default_type application/octet-stream; sendfile on; #tcp_nopush on; keepalive_timeout 65; # HTTP サーバー設定 server { listen 80; server_name localhost; location / { root /usr/share/nginx/html/dist; index index.html index.htm; } error_page 500 502 503 504 /50x.html; location = /50x.html { root html; } } } 以下のコマンドでビルド：\n1 docker build -t username/imagename:v1.0 . tag でイメージ名を変更する Docker Hub にプッシュする際の命名規則：\n1 docker push ユーザー名/イメージ名 tag を変更するには：\n1 docker tag name username/imagename:v1.0 tag を付けなかった場合、デフォルトでは latest になる。 イメージのプッシュ：\n1 docker push username/imagename:v1.0 参考記事 docker: 打包h5项目的镜像 Docker镜像推送（push）到Docker Hub ","date":"2024-01-09T21:50:25+08:00","permalink":"https://blog.yexca.net/ja/archives/141/","title":"Docker で H5 イメージを作成・プッシュする"},{"content":" 📢 この記事は gemini-2.5-flash によって翻訳されました デザインパターンを簡単に紹介するね\nデザインパターン 入門 具体的なデザインパターン\n生成パターン 構造パターン 振る舞いパターン クラス ファクトリーメソッドパターン アダプターパターン (クラス) インタープリターパターン テンプレートメソッドパターン オブジェクト 抽象ファクトリーパターン\nビルダーパターン プロトタイプパターン シングルトンパターン アダプターパターン (オブジェクト)\nブリッジパターン コンポジットパターン デコレーターパターン ファサードパターン フライウェイトパターン プロキシパターン 責任の連鎖パターン コマンドパターン イテレーターパターン メディエーターパターン メメントパターン オブザーバーパターン ステートパターン ストラテジーパターン ビジターパターン 補足ね\nファクトリーメソッドパターン と 抽象ファクトリーパターン については、 ファクトリーパターン を見てみてね。\nアダプターパターン ではクラスとオブジェクトについて説明してるよ。\nおすすめの読み物 https://refactoringguru.cn/design-patterns ","date":"2023-12-27T16:14:15+08:00","permalink":"https://blog.yexca.net/ja/archives/140/","title":"デザインパターン インデックス"},{"content":" 📢 この記事は gemini-2.5-flash によって翻訳されました Visitorパターン オブジェクトの振る舞いパターン\n意図 あるオブジェクト構造内の各要素に作用する操作を表現するよ。要素のクラスを変更せずに、これらの要素に作用する新しい操作を定義することを可能にするね。\n構造 ここでね：\nVisitor (訪問者) は、このオブジェクト構造内の ConcreteElement の各クラスに対して、Visit 操作を宣言するんだ。この操作名と特別な識別子によって、その訪問者へのVisitリクエストを送信するクラスが特定できるから、訪問者は現在訪問されている要素の具体的なクラスを特定できるよ。これで、訪問者はその要素の特定のインターフェースを通じて直接アクセスできるね。 ConcreteVisitor (具体的な訪問者) は、Visitorが宣言した各操作を実装するよ。各操作はアルゴリズムの一部を実装し、そのアルゴリズムの断片は構造内のオブジェクトのクラスに対応する。ConcreteVisitorはこのアルゴリズムのコンテキストを提供し、その局所状態を保持する。この状態は、構造を巡回する過程で蓄積されることが多いね。 Element (要素) は、訪問者を引数とするAccept操作を定義する。 ConcreteElement (具体的な要素) は、訪問者を引数とするAccept操作を実装する。 ObjectStructure (オブジェクト構造) は、その要素を列挙できるよ。訪問者がその要素にアクセスできるように、高レベルのインターフェースを提供できる。コンポジットや、リストや順序なし集合のようなコレクションであってもいいんだ。 適用性 Visitorパターンは、こんなときに使えるよ：\nあるオブジェクト構造が多くのクラスオブジェクトを含んでいて、それらが異なるインターフェースを持っていて、ユーザーがそれらの具体的なクラスに依存する操作を実行したいとき。 あるオブジェクト構造内のオブジェクトに対して、たくさん異なる、そして関連性のない操作を実行する必要があるのに、それらの操作がオブジェクトのクラスを「汚染」するのを避けたいとき。Visitorパターンを使うと、関連する操作を一つのクラスにまとめて定義できるよ。そのオブジェクト構造が多くのアプリケーションで共有されている場合、Visitorパターンを使えば、各アプリケーションが必要な操作だけを含むようにできるんだ。 オブジェクト構造を定義するクラスはほとんど変更されないけど、この構造上で新しい操作を頻繁に定義する必要があるとき。オブジェクト構造クラスを変更すると、すべての訪問者のインターフェースを再定義する必要があって、それは大きなコストがかかる可能性があるんだ。もしオブジェクト構造クラスが頻繁に変わるなら、たぶんそれらのクラスの中で操作を定義する方がいいかもしれないね。 例文 1 ある図書管理システムでは、書籍と論文の2種類の文献を管理しているんだ。今、すべての所蔵文献の総ページ数を集計するという要求があって、それをVisitorパターンで実装するよ。クラス図はこんな感じ：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 interface LibraryVisitor{ void visit(Book p_book); void visit(Article p_article); void printSum(); } class LibrarySumPrintVisitor implements LibraryVisitor{ // 印刷総ページ数 private int sum = 0; @Override public void visit(Book p_book) { sum = sum + p_book.getNumberOfPages(); } @Override public void visit(Article p_article) { sum = sum + p_article.getNumberOfPages(); } @Override public void printSum() { System.out.println(\u0026#34;SUM = \u0026#34; + sum); } } interface LibraryItemInterface{ void accept(LibraryVisitor visitor); } class Article implements LibraryItemInterface{ private String m_title; // 論文名 private String m_author; // 論文著者 private int m_start_page; private int m_end_page; public Article(String p_author, String p_title, int p_start_page, int p_end_page){ m_title = p_title; m_author = p_author; m_start_page = p_start_page; m_end_page = p_end_page; } public int getNumberOfPages(){ return m_end_page - m_start_page; } @Override public void accept(LibraryVisitor visitor) { visitor.visit(this); } } class Book implements LibraryItemInterface{ private String m_title; // 書名 private String m_author; // 書著者 private int m_pages; // ページ数 public Book(String p_author, String p_title, int p_pages){ m_title = p_title; m_author = p_author; m_pages = p_pages; } public int getNumberOfPages(){ return m_pages; } @Override public void accept(LibraryVisitor visitor) { visitor.visit(this); } } 例文 2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 import java.util.ArrayList; import java.util.List; public class VisitorPattern { public static void main(String[] args) { PersonStructure personStructure = new PersonStructure(); Visitor1 visitor1 = new Visitor1(); System.out.println(\u0026#34;For Visitor1\u0026#34;); personStructure.Accept(visitor1); System.out.println(\u0026#34;The sum of student age: \u0026#34; + visitor1.getStudentAgeSum()); System.out.println(\u0026#34;The sum of teacher age: \u0026#34; + visitor1.getTeacherAgeSum()); Visitor2 visitor2 = new Visitor2(); System.out.println(\u0026#34;For Visitor2\u0026#34;); personStructure.Accept(visitor2); System.out.println(\u0026#34;Max score: \u0026#34; + visitor2.getMaxScore()); System.out.println(\u0026#34;Max work year: \u0026#34; + visitor2.getMaxWorkYear()); } } interface Visitor{ public void VisitS(Student student); public void VisitT(Teacher teacher); } class Visitor1 implements Visitor{// 学生と教師の年齢の合計をそれぞれ集計する private int studentAgeSum = 0; private int teacherAgeSum = 0; public int getStudentAgeSum() { return studentAgeSum; } public int getTeacherAgeSum() { return teacherAgeSum; } @Override public void VisitS(Student student){ System.out.println(\u0026#34;Visitor1: \u0026#34; + student.getName() + \u0026#34; Age: \u0026#34; + student.getAge()); studentAgeSum += student.getAge(); } public void VisitT(Teacher teacher){ System.out.println(\u0026#34;Visitor1: \u0026#34; + teacher.getName() + \u0026#34; Age: \u0026#34; + teacher.getAge()); teacherAgeSum += teacher.getAge(); } } class Visitor2 implements Visitor{ // 学生の最高成績と教師の最高勤続年数をそれぞれ求める private int maxScore = -1; private int maxWorkYear = -1; public int getMaxScore() { return maxScore; } public int getMaxWorkYear() { return maxWorkYear; } @Override public void VisitS(Student student){ System.out.println(\u0026#34;Visitor2: \u0026#34; + student.getName() + \u0026#34; Score: \u0026#34; + student.getScore()); if(student.getScore() \u0026gt; maxScore) maxScore = student.getScore(); // maxScore = Math.max(maxScore, student.getScore()); } public void VisitT(Teacher teacher){ System.out.println(\u0026#34;Visitor2: \u0026#34; + teacher.getName() + \u0026#34; WorkYear: \u0026#34; + teacher.getWorkYear()); if(teacher.getWorkYear() \u0026gt; maxWorkYear) maxWorkYear = teacher.getWorkYear(); // maxWorkYear = Math.max(maxWorkYear, teacher.getWorkYear()); } } class PersonStructure{ private List\u0026lt;Person\u0026gt; personList = new ArrayList\u0026lt;\u0026gt;(); public PersonStructure(){ personList.add(new Student(\u0026#34;Mike\u0026#34;, 16, 99)); personList.add(new Student(\u0026#34;Jane\u0026#34;, 15, 100)); personList.add(new Teacher(\u0026#34;Alice mana\u0026#34;, 20, 1)); } public void Accept(Visitor visitor){ for(Person p : personList){ p.Accept(visitor); } } } abstract class Person{ private String name; private int age; public abstract void Accept(Visitor visitor); public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } } class Student extends Person{ private int score; public int getScore() { return score; } public Student(String name, int age, int score){ this.setName(name); this.setAge(age); this.score = score; } @Override public void Accept(Visitor visitor){ visitor.VisitS(this); } } class Teacher extends Person{ private int workYear; public int getWorkYear() { return workYear; } public Teacher(String name, int age, int workYear){ this.setName(name); this.setAge(age); this.workYear = workYear; } @Override public void Accept(Visitor visitor){ visitor.VisitT(this); } } ","date":"2023-12-26T16:09:09+08:00","permalink":"https://blog.yexca.net/ja/archives/139/","title":"Visitorパターン"},{"content":" 📢 この記事は gemini-2.5-flash によって翻訳されました Template Method Pattern クラスの振る舞いパターン\n目的 ある操作のアルゴリズムの骨格を定義し、一部のステップはサブクラスに任せる。テンプレートメソッドを使うと、サブクラスはアルゴリズムの構造を変えずに、その特定のステップを再定義できるようになるんだ。\n構造 ここで、\nAbstractClass (抽象クラス) 抽象的なプリミティブ操作を定義する。具体的なサブクラスは、アルゴリズムの各ステップを実装するためにこれらを再定義するんだ。テンプレートメソッドを実装し、アルゴリズムの骨格を定める。このテンプレートメソッドは、プリミティブ操作だけでなく、AbstractClassや他のオブジェクトで定義された操作も呼び出すよ。 ConcreteClass (具象クラス) プリミティブ操作を実装し、アルゴリズム内の特定のサブクラスに関連するステップを完了させる。 適用性 テンプレートメソッドパターンが役立つのは、こんな時だよ。\nアルゴリズムの変わらない部分を一度だけ実装して、変わる可能性のある振る舞いはサブクラスに任せたい時。 各サブクラスで共通の振る舞いがあるなら、コードの重複を避けるために共通の親クラスに抽出して集約すべきだね。 サブクラスの拡張を制御したい時。テンプレートメソッドは、特定のポイントで「フック」操作（デフォルトの振る舞いで、サブクラスが必要に応じて再定義して拡張できるもの）を呼び出すように設計されてる。これで、これらのポイントでしか拡張できないように制限できるんだ。 例 学校に行く例で見てみよう。生徒は授業を受けたり、宿題をしたりする。先生は授業を教えたり、宿題を採点したりするよね。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 public class TemplateMethodPattern { public static void main(String[] args) { Person stu = new Student(); Person tec = new Teacher(); stu.TemplateMethod(); System.out.println(\u0026#34;==========\u0026#34;); tec.TemplateMethod(); } } abstract class Person{ public void TemplateMethod(){ System.out.println(\u0026#34;go to class\u0026#34;); PrimitiveOperation1(); System.out.println(\u0026#34;End of class\u0026#34;); PrimitiveOperation2(); } public abstract void PrimitiveOperation1(); // プリミティブ操作1：授業：生徒は聞く；先生は教える public abstract void PrimitiveOperation2(); // プリミティブ操作2：宿題：生徒はする；先生は採点する } class Student extends Person{ @Override public void PrimitiveOperation1(){ System.out.println(\u0026#34;Listen\u0026#34;); } public void PrimitiveOperation2(){ System.out.println(\u0026#34;Do assignments\u0026#34;); } } class Teacher extends Person{ @Override public void PrimitiveOperation1(){ System.out.println(\u0026#34;Teach\u0026#34;); } public void PrimitiveOperation2(){ System.out.println(\u0026#34;Grade assignments\u0026#34;); } } ","date":"2023-12-25T21:06:06+08:00","permalink":"https://blog.yexca.net/ja/archives/138/","title":"テンプレートメソッドパターン"},{"content":" 📢 この記事は gemini-2.5-flash によって翻訳されました Strategy Pattern オブジェクトの振る舞いパターン\n目的 一連のアルゴリズムを定義して、それぞれをカプセル化し、互いに置き換え可能にするよ。このパターンを使うと、アルゴリズムをそれを使うクライアントとは独立して変更できるようになるんだ。\n構造 ポイントはね：\nStrategy（戦略）は、サポートするすべてのアルゴリズムの共通インターフェースを定義するよ。Contextはこのインターフェースを使って、特定のConcreteStrategyが定義するアルゴリズムを呼び出すんだ。\nConcreteStrategy（具体的な戦略）は、Strategyインターフェースを実装して具体的なアルゴリズムを実現するんだ。\nContext（コンテキスト）は、ConcreteStrategyオブジェクトで設定されるよ。Strategyオブジェクトへの参照を保持していて、Strategyがそのデータにアクセスするためのインターフェースを定義することもできるんだ。\n適用できる場面 Strategyパターンは、こんなときに役立つよ：\n多くの関連するクラスが、振る舞いだけが違う場合。「戦略」は、複数の振る舞いの中から1つを使ってクラスを設定する方法を提供してくれるんだ。\nあるアルゴリズムの異なるバリアントを使う必要がある場合。例えば、異なる空間/時間トレードオフを反映するアルゴリズムをいくつか定義するとか。これらのバリアントがアルゴリズムのクラス階層として実装されている場合、戦略パターンが使えるよ。\nアルゴリズムが、クライアントが知るべきではないデータを使う場合。複雑な、アルゴリズム関連のデータ構造を公開しないようにするために、戦略パターンが使えるんだ。\nあるクラスが複数の振る舞いを定義していて、それがそのクラスの操作の中で複数の条件文の形として現れる場合。関連する条件分岐をそれぞれのStrategyクラスに移すことで、これらの条件文を置き換えることができるんだ。\n例1 とある大型ショッピングモールがレジソフトウェアを開発したいんだって。ショッピングモールが時期によって出す割引やキャッシュバック（例えば、300元以上で100元バックとか）みたいな色々なプロモーションに対応できるようにしたいんだ。これを戦略パターンで実現してみるよ。設計したクラス図はこんな感じ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 import java.util.*; enum TYPE { NORMAL, CASH_DISCOUNT, CASH_RETURN}; interface CashSuper { public double acceptCash(double money); } class CashNormal implements CashSuper { // 正常收费子类 public double acceptCash(double money) { return money; } } class CashDiscount implements CashSuper { private double moneyDiscount; // 折扣率 public CashDiscount(double moneyDiscount) { this moneyDiscount = moneyDiscount; } public double acceptCash(double money) { return money* moneyDiscount; } } class CashReturn implements CashSuper { // 满额返利 private double moneyCondition; private double moneyReturn; public CashReturn(double moneyCondition, double moneyReturn) { this.moneyCondition = moneyCondition; // 满额数额 this.moneyReturn = moneyReturn; // 返利数额 } public double acceptCash(double money) { double result = money; if(money \u0026gt;= moneyCondition ) result = money - Math.floor(money / moneyCondition) * moneyReturn; return result; } } class CashContext { private CashSuper cs; private TYPE t; public CashContext(TYPE t) { switch(t) { case NORMAL: // 正常收费 cs = new CashNormal(); break; case CASH_DISCOUNT: // 打8折 cs = new CashDiscount(0.8); break; case CASH_RETURN: // 满300返100 cs = new CashReturn(300, 100); break; } } public double GetResult(double money) { return cs.acceptCash(money); } // 此处略去main()函数 } 例2 足し算、引き算、掛け算\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 public class StrategyPattern { public static void main(String[] args) { Strategy add = new AddStrategy(); Strategy subtraction = new SubtractionStrategy(); Strategy multiply = new MultiplyStrategy(); OperationContext context = new OperationContext(add); context.Operation(1, 2); context = new OperationContext(subtraction); context.Operation(1, 2); context = new OperationContext(multiply); context.Operation(1, 2); } } class OperationContext{ private Strategy strategy; public OperationContext(Strategy strategy){ this.strategy = strategy; } public void Operation(int a, int b){ strategy.operation(a, b); } } interface Strategy{ public void operation(int a, int b); } class AddStrategy implements Strategy{ @Override public void operation(int a, int b){ System.out.println(a + b); } } class SubtractionStrategy implements Strategy{ @Override public void operation(int a, int b){ System.out.println(a - b); } } class MultiplyStrategy implements Strategy{ @Override public void operation(int a, int b){ System.out.println(a * b); } } ","date":"2023-12-24T18:30:30+08:00","permalink":"https://blog.yexca.net/ja/archives/137/","title":"戦略パターン"},{"content":" 📢 この記事は gemini-3-flash-preview によって翻訳されました State Pattern オブジェクト振る舞い型パターン\n意図 オブジェクトの内部状態が変化したときに、そのオブジェクトの振る舞いを変えられるようにする。まるでオブジェクトがそのクラスを書き換えたかのように見えるよ。\n構成 構成要素はこんな感じ：\nContext (コンテキスト): クライアントが利用するインターフェースを定義する。現在の状態を表す ConcreteState サブクラスのインスタンスを保持しているよ。\nState (状態): Context の特定の状態に関連する振る舞いをカプセル化するためのインターフェースを定義する。\nConcreteState (具体状態サブクラス): 各サブクラスが、Context の一つの状態に対応する振る舞いを実装する。\nどんな時に使う？ オブジェクトの振る舞いがその時の状態によって決まり、実行時にその状態に応じて振る舞いを変える必要があるとき。\nある操作の中に、オブジェクトの状態に依存する巨大な多分岐の条件文（if-else や switch）があるとき。この状態は通常、1つ以上の列挙定数で表される。State パターンは、それぞれの条件分岐を独立したクラスに分けることで、状態を一つのオブジェクトとして扱えるようにするんだ。そうすれば、他のオブジェクトに依存せずに状態を変化させることができるようになるよ。\n例 1 あるショッピングモールに、2元で1パックのティッシュを売るシンプルな自販機があるとする。一度に1パックだけ売れる仕様だ。自販機の状態遷移図はこんな感じ。\nこのティッシュ自販機を State パターンで実装すると、次のようなクラス図になる。State クラスは抽象クラスで、コイン投入、コイン返却、ボタン押し、ティッシュ出す、といったメソッドを定義している。SoldState（販売中）、SoldOutState（売り切れ）、NoQuarterState（コインなし）、HasQuarterState（コインあり）の4つのクラスが、それぞれの状態に対応しているよ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 import java.util.*; interface State { public void insertQuarter(); // コイン投入 public void ejectQuarter(); // コイン返却 public void turnCrank(); // 「ティッシュを出す」ボタンを押す public void dispense(); // ティッシュを出す } class TissueMachine { State soldOutState, noQuarterState, hasQuarterState, soldState, state; state = soldOutState; int count = 0; // ティッシュの数 public TissueMachine(int numbers) { /* 実装は省略 */ } public State getHasQuarterState() { return hasQuarterState; } public State getNoQuarterState() { return noQuarterState; } public State getSoldState() { return soldState; } public State getSoldOutState() { return soldOutState; } public int getCount() { return count; } // 残りのコードは省略 } class NoQuarterState implements State { TissueMachine tissueMachine; public void insertQuarter() { tissueMachine.setState(tissueMachine.getHasQuarterState()); } // コンストラクタなどは省略 } class HasQuarterState implements State { TissueMachine tissueMachine; public void ejectQuarter() { tissueMachine.setState(tissueMachine.getNoQuarterState()); } // コンストラクタなどは省略 } class SoldState implements State { TissueMachine tissueMachine; public void dispense() { if (tissueMachine.getCount() \u0026gt; 0) { tissueMachine.setState(tissueMachine.getNoQuarterState()); } else { tissueMachine.setState(tissueMachine.getSoldOutState()); } } } 例 2 ある航空会社のマイレージシステムでは、会員を「一般 (Basic)」「シルバー (Silver)」「ゴールド (Gold)」の3つのランクに分けている。非会員 (NonMember) は一般会員の申請ができる。会員ランクは、1年間の累積マイル数によって調整される。ランク変動の状態遷移図はこんな感じ。\nこれを State パターンで実装すると、次のようなクラス図になる。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 import java.util.*; abstract class CState { public int flyMiles; // マイル数 public abstract double travel(int miles, CFrequentFlyer context); // 累積マイルに基づいてランクを調整 } class CNoCustomer extends CState { // 非会員 public double travel(int miles, CFrequentFlyer context) { System.out.println(\u0026#34;Your travel will not account for points\u0026#34;); return miles; // マイルは貯まらない } } class CBasic extends CState { // 一般会員 public double travel(int miles, CFrequentFlyer context) { if (context.flyMiles \u0026gt;= 25000 \u0026amp;\u0026amp; context.flyMiles \u0026lt; 50000) context.setState(new CSilver()); if (context.flyMiles \u0026gt;= 50000) context.setState(new CGold()); return miles; } } class CGold extends CState { // ゴールド会員 public double travel(int miles, CFrequentFlyer context) { if (context.flyMiles \u0026gt;= 25000 \u0026amp;\u0026amp; context.flyMiles \u0026lt; 50000) context.setState(new CSilver()); if (context.flyMiles \u0026lt; 25000); context.setState(new CBasic()); return miles + 0.5 * miles; // マイルにボーナスがつく } } class CSilver extends CState { // シルバー会員 public double travel(int miles, CFrequentFlyer context) { if (context.flyMiles \u0026lt;= 25000) context.setState(new CBasic()); if (context.flyMiles \u0026gt;= 50000) context.setState(new CGold()); return (miles + 0.25 * miles); // マイルにボーナスがつく } } class CFrequentFlyer { CState state; double flyMiles; public CFrequentFlyer() { state = new CNoCustomer(); flyMiles = 0; setState(state); } public void setState(CState state) { this.state = state; } public void travel(int miles) { double bonusMiles = state.travel(miles, this); flyMiles = flyMiles + bonusMiles; } } 例 3 自動販売機、在庫ありと在庫なしの例。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 public class StatePattern { public static void main(String[] args) { Context context = new Context(); context.Request(); // count = 2 context.Request(); // count = 1 context.Request(); // count = 0 context.Request(); // switch to State A (在庫補充) context.Request(); // count = 4 } } class Context{ // 自販機 private int count; private State state; public Context(){ count = 3; state = new StateA(); } public int getCount() { return count; } public State getState() { return state; } public void setCount(int count) { this.count = count; } public void setState(State state) { this.state = state; } public void Request(){ // 飲み物を買う state.Handle(this); } } interface State{ public void Handle(Context context); } class StateA implements State{ // 在庫あり @Override public void Handle(Context context){ int count = context.getCount(); if(count \u0026gt;= 1){ context.setCount(count - 1); System.out.println(\u0026#34;Complete! あと\u0026#34; + context.getCount() + \u0026#34;個\u0026#34;); if(context.getCount() == 0){ context.setState(new StateB()); } }else{ System.out.println(\u0026#34;Refused!\u0026#34;); } } } class StateB implements State{ // 在庫なし @Override public void Handle(Context context){ int count = context.getCount(); if(count == 0){ System.out.println(\u0026#34;Refused!\u0026#34;); context.setCount(5); // 在庫を5つ補充 System.out.println(\u0026#34;Please try again\u0026#34;); context.setState(new StateA()); }else { context.setState(new StateA()); context.Request(); } } } ","date":"2023-12-22T15:11:16+08:00","permalink":"https://blog.yexca.net/ja/archives/136/","title":"状態パターン (State Pattern)"},{"content":" 📢 この記事は gemini-2.5-flash によって翻訳されました Asynchronous JavaScript And XML、非同期のJSとXMLってことだね。役割はこんな感じ。\nデータ交換：Ajaxを使えば、サーバーにリクエストを送って、サーバーからデータを受け取ることができるんだ。 非同期インタラクション：ページ全体をリロードせずに、サーバーとデータをやり取りして、一部のウェブページを更新する技術だね。 使う場面：検索の予測候補とか、ユーザー名が使えるかどうかの確認とかだね。\n同期と非同期 同期っていうのは、ウェブページにアクセスして何か操作するときにサーバーにリクエストが必要で、サーバーが処理してる間はウェブページは操作できないんだ。サーバーがクライアントに応答するまで、次の操作に進めないってこと。\n一方、非同期はサーバーにリクエストを送ってる間に、クライアントは他の操作を実行できるんだ。\n素のAjax まずXMLHttpRequestオブジェクト（サーバーとデータをやり取りするためのもの）を作って、それからサーバーにリクエストを送って、最後にサーバーからの応答データを受け取るんだ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Ajax\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;获取数据\u0026#34; onclick=\u0026#34;getDate()\u0026#34;\u0026gt; \u0026lt;div id=\u0026#34;div1\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; function getDate(){ // 创建XMLHttpRequest var xmlHttpRequest = new XMLHttpRequest(); // 发送异步请求 xmlHttpRequest.open(\u0026#39;GET\u0026#39;, \u0026#39;//127.0.0.1:8080/listEmp\u0026#39;); xmlHttpRequest.send(); // 获取服务响应数据 xmlHttpRequest.onreadystatechange=function(){ if(xmlHttpRequest.readyState==4 \u0026amp;\u0026amp; xmlHttpRequest.status==200){ document.getElementById(\u0026#34;div1\u0026#34;).innerHTML=xmlHttpRequest.responseText; } } } \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; 詳しい参考情報はこちら： https://www.w3school.com.cn/js/js_ajax_intro.asp Axios Axiosは素のAjaxをラップして、記述をシンプルにして、素早い開発を可能にしてくれるんだ。公式サイトはこちら： https://www.axios-http.cn/ Axiosを使うには、まずAxiosファイルを読み込む必要があるよ。\n1 \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; Axiosを使ってリクエストを送って結果を受け取る方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Axios\u0026lt;/title\u0026gt; \u0026lt;!-- 文件下载到了本地 --\u0026gt; \u0026lt;script src=\u0026#34;./js/axios-0.18.0.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;获取数据\u0026#34; onclick=\u0026#34;getData()\u0026#34;\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; function getData(){ axios({ method: \u0026#34;get\u0026#34;, url: \u0026#34;//127.0.0.1:8080/listEmp\u0026#34; }).then(result =\u0026gt; { console.log(result.data); }) } \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; これはGETメソッドだけど、POSTメソッドはデータを追加する必要があるよ。\n1 2 3 4 5 6 7 8 9 function deleteData(){ axios({ method: \u0026#34;POST\u0026#34;, url: \u0026#34;//127.0.0.1:8080/deleteEmpById\u0026#34;, data: \u0026#34;id=1\u0026#34; }).then(result =\u0026gt; { console.log(result.data); }) } もちろん、こう書くのもまだちょっと面倒だよね。Axiosにはエイリアスが用意されてるんだ。\naxios.get(url[, config]) axios.delete(url[, config]) axios.post(url[, data[, config]]) axios.put(url[, data[, config]]) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 function getData(){ // axios({ // method: \u0026#34;get\u0026#34;, // url: \u0026#34;//127.0.0.1:8080/listEmp\u0026#34; // }).then(result =\u0026gt; { // console.log(result.data); // }) axios.get(\u0026#34;//127.0.0.1:8080/listEmp\u0026#34;).then(result =\u0026gt; { console.log(result.data); }) } function deleteData(){ // axios({ // method: \u0026#34;POST\u0026#34;, // url: \u0026#34;//127.0.0.1:8080/deleteEmpById\u0026#34;, // data: \u0026#34;id=1\u0026#34; // }).then(result =\u0026gt; { // console.log(result.data); // }) axios.post(\u0026#34;//127.0.0.1:8080/deleteEmpById\u0026#34;,\u0026#34;id=1\u0026#34;).then(result =\u0026gt; { console.log(result.data); }) } ","date":"2023-12-21T13:32:15+08:00","permalink":"https://blog.yexca.net/ja/archives/135/","title":"AjaxとAxios"},{"content":" 📢 この記事は gemini-3-flash-preview によって翻訳されました Observer Pattern (オブザーバーパターン) オブジェクト振る舞い型パターン\n意図 オブジェクト間に一対多の依存関係を定義して、あるオブジェクトの状態が変化したときに、それに依存しているすべてのオブジェクトに通知が届き、自動的に更新されるようにすること。\n構造 役割：\nSubject (目標): 自分のオブザーバー（観察者）を知っている。任意の数のオブザーバーが一つの目標を観察できる。オブザーバーを登録したり削除したりするためのインターフェースを提供するよ。 Observer (オブザーバー): 目標に変化があったときに通知を受け取る必要があるオブジェクトのために、更新用のインターフェースを定義する。 ConcreteSubject (具体的な目標): 関連する状態を各 ConcreteObserver オブジェクトに保存する。自分の状態が変化したときに、登録されているオブザーバーたちに通知を送るんだ。 ConcreteObserver (具体的なオブザーバー): ConcreteSubject オブジェクトへの参照を保持する。目標の状態と一致させておくべき状態を保存する。Observer の更新インターフェースを実装して、自分の状態を目標の状態に合わせるよ。 適用場面 Observer パターンはこんな時に使えるよ：\n抽象的なモデルに2つの側面があって、片方がもう片方に依存している場合。これらを独立したオブジェクトにカプセル化することで、それぞれをバラバラに変更したり再利用したりできるようになる。 1つのオブジェクトを変更したときに、他のオブジェクトも同時に変更する必要があるけれど、具体的にいくつのオブジェクトを変更しなきゃいけないか分からないとき。 あるオブジェクトが他のオブジェクトに通知を送る必要があるけれど、その相手が誰かを特定したくない（つまり、ガチガチに結合させたくない）とき。 例 1 あるファイル管理システムで OfficeDoc クラスと DocExplorer クラスが定義されているとする。OfficeDoc クラスに変化があったとき、DocExplorer クラスのすべてのオブジェクトが自分の状態を更新しなきゃいけない。これをオブザーバーパターンを使って実現すると、クラス図は以下のようになるよ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 import java.util.*; interface Observer { public void update(); } interface Subject { public void Attach(Observer obs); public void Detach(Observer obs); public void Notify(); public void setStatus(int status); public int getStatus(); } class OfficeDoc implements Subject { private List\u0026lt;Observer\u0026gt; myObs; private String mySubjectName; private int m_status; public OfficeDoc(String name) { mySubjectName = name; this.myObs = new ArrayList\u0026lt;Observer\u0026gt;(); m_status = 0; } public void Attach(Observer obs) { this.myObs.add(obs); } public void Detach(Observer obs) { this.myObs.remove(obs); } public void Notify() { for (Observer obs : this.myObs) {obs.update(); } } public void setStatus(int status) { m_status = status; System.out.println(\u0026#34;SetStatus subject[\u0026#34; + mySubjectName + \u0026#34;]status:\u0026#34; + status); } public int getStatus() { return m_status; } } class DocExplorer implements Observer { private String myObsName; public DocExplorer(String name,Subject sub) { myObsName = name; sub.Attach(this); } public void update() { System.out.println(\u0026#34;update observer[\u0026#34; + myObsName + \u0026#34;]\u0026#34;); } } class ObserverTest { public static void main(String[] args) { Subject subjectA = new OfficeDoc(\u0026#34;subject A\u0026#34;); Observer observerA = new DocExplorer(\u0026#34;observer A\u0026#34;, subjectA); subjectA.setStatus(1); subjectA.Notify(); } } 例 2 Subject を YouTuber、Observer をチャンネル登録者とする例だよ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 import java.util.ArrayList; import java.util.List; public class ObserverPattern { public static void main(String[] args) { Subject subjectA = new ConcerteSubject(); Observer observer1 = new ConcerteObserver(\u0026#34;Mike\u0026#34;, subjectA); Observer observer2 = new ConcerteObserver(\u0026#34;Jane\u0026#34;, subjectA); subjectA.Notify(); } } interface Subject{ // 目標 public void Attach(Observer observer); public void Detach(Observer observer); public void Notify(); public String getState(); public void setState(String state); } class ConcerteSubject implements Subject{ private String state; private List\u0026lt;Observer\u0026gt; observerList; public String getState() { return state; } @Override public void setState(String state) { this.state = state; this.Notify(); } public ConcerteSubject(){ state = \u0026#34;-1\u0026#34;; observerList = new ArrayList\u0026lt;\u0026gt;(); } public void Attach(Observer observer){ observerList.add(observer); } public void Detach(Observer observer){ observerList.remove(observer); } public void Notify(){ for(Observer o : observerList){ o.update(); } } } interface Observer{ // オブザーバー public void update(); } class ConcerteObserver implements Observer{ private String name; private Subject subject; private String state; public ConcerteObserver(String name, Subject subject){ this.name = name; this.state = subject.getState(); this.subject = subject; subject.Attach(this); } @Override public void update(){ System.out.println(this.name + \u0026#34; Received\u0026#34;); this.state = subject.getState(); } } ","date":"2023-12-21T01:18:25+08:00","permalink":"https://blog.yexca.net/ja/archives/134/","title":"オブザーバーパターン"},{"content":" 📢 この記事は ChatGPT によって翻訳されました はじめに いつからか（正確な時期は忘れたけど）ASMR が好きになって、音声作品にも触れるようになった。\nでも価格が結構高いので、自然とネットで探すようになって、このサイトを知った。\nただし、このサイトはログインしないと詳細が見られず、しかも登録は年に数回の不定期オープン。\nそこで、サーバー側で登録可能かどうかを定期チェックし、登録可能なら Telegram に通知するようなツールを作った。\nGitHub: yexca/hvdb 目的 hvdb が登録可能なタイミングを監視し、登録可能であれば Telegram で通知。\n登録可能かどうかのチェック方法 灵梦广场 のスレッドによると、登録が開放されているときは login ページに register が表示されるらしい。\nならば、シンプルにそのページをクローリングして register という単語があるかどうかを確認するだけで OK。\nBot 設定 Telegram で通知を送るには、まず Bot を作成する必要がある。\nhttps://t.me/BotFather にアクセスし、/newbot と入力して手順に従い作成。\n作成した bot に hello などを送信してから、以下の URL にアクセス（TOKEN を自分のものに置き換える）：\n1 https://api.telegram.org/botTOKEN/getUpdates JSON が返ってくるので、その中から id を取得 → これが chat_id になる。\n参考： 使用Telegram Bot来实现推送通知 Python スクリプト Python でやるのが一番簡単（他言語は面倒だった）\nクローリングには requests を、通知には pyTelegramBotAPI を使用。\nファイル名は http.py や requests.py にしないこと（ライブラリと衝突する）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 import telebot import requests import time # 自分の Bot トークン bot = telebot.TeleBot(\u0026#34;TOKEN\u0026#34;, parse_mode=\u0026#34;MARKDOWN\u0026#34;) # デフォルトのパースモード def inform(): web = requests.get(\u0026#34;https://hvdb.me/\u0026#34;) str = web.text a = str.find(\u0026#34;register\u0026#34;) if a != -1: # chat_id を自分のに置き換える bot.send_message(\u0026#34;chat_id\u0026#34;, \u0026#34;[hvdb](http://hvdb.me/) register start\u0026#34;) t = 0 while True: inform() # 1時間ごとにチェック time.sleep(3600) # 実行時間をカウント t += 1 # 24時間ごとに動作報告 if t == 24: t -= 24 local_time = time.ctime(time.time()) inform_str = \u0026#34;{} 実行済み\u0026#34;.format(local_time) bot.send_message(\u0026#34;chat_id\u0026#34;, inform_str) 参考：\nAttributeError: module \u0026lsquo;requests\u0026rsquo; に関するエラー対処 requests - 廖雪峰の公式サイト Python time.sleep() - 菜鸟教程 Python 時刻・日付の使い方 Docker 化 ファイル構成：\n1 2 3 D:\\DOCKER\\HVDB Dockerfile inform.py Dockerfile：\n1 2 3 4 5 6 FROM python:3.11-alpine RUN pip install requests \\ \u0026amp;\u0026amp; pip install pyTelegramBotAPI COPY ./inform.py /app/inform.py CMD [ \u0026#34;python\u0026#34;, \u0026#34;/app/inform.py\u0026#34; ] 同じディレクトリで以下のコマンドでビルド：\n1 docker build -t hvdb:v1.0 . サーバーへ転送 Windows 側で：\n1 docker save -o hvdb:v1.0 hvdb.tar tar ができたらサーバーに転送：\n1 scp .\\hvdb.tar username@hostname:/path サーバー上で：\n1 docker load -i hvdb.tar 参考： docker load エラー「archive/tar: invalid tar header」の対処 ","date":"2023-12-02T21:23:01+08:00","permalink":"https://blog.yexca.net/ja/archives/133/","title":"hvdb 登録監視ツール"},{"content":" 📢 この記事は gemini-3-flash-preview によって翻訳されました メメント・パターン（Memento Pattern）オブジェクト振る舞い型パターン\n意図 カプセル化を壊さずにオブジェクトの内部状態をキャプチャして、それをオブジェクトの外に保存しておくこと。そうすれば、後でオブジェクトを元の状態に戻せるようになるんだ。\n構造 それぞれの役割はこんな感じ：\nMemento（メメント）: Originator（作成者）オブジェクトの内部状態を保存する。Originator が必要に応じて、どの内部状態を保存するかを決めるんだ。Originator 以外のオブジェクトがメメントにアクセスするのを防ぐ役割もあるよ。 Originator（作成者）: 現在の内部状態を記録するためのメメントを作成する。また、メメントを使って内部状態を復元するのもこの役割だよ。 Caretaker（管理者）: メメントを適切に保管する責任がある。ただし、メメントの内容を操作したりチェックしたりはできないんだ。 どんな時に使う？ メメント・パターンはこんな時に役立つよ：\nオブジェクトのある時点での（一部の）状態を保存しておいて、後で必要になった時にその状態に戻さなきゃいけない場合。 もし、他のオブジェクトが直接その状態を取得できるようなインターフェースを作ってしまうと、実装の詳細が漏れてカプセル化が壊れてしまうような場合。 例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 import java.util.ArrayList; import java.util.List; public class MementoPattern { public static void main(String[] args) { Caretaker caretaker = new Caretaker(); Originator originator = new Originator(); originator.setState(\u0026#34;first\u0026#34;); Memento memento1 = originator.createMemento(); caretaker.addMemento(memento1); originator.setState(\u0026#34;second\u0026#34;); Memento memento2 = originator.createMemento(); caretaker.addMemento(memento2); originator.setState(\u0026#34;third\u0026#34;); Memento memento3 = originator.createMemento(); caretaker.addMemento(memento3); caretaker.showMemento(); Memento backup = caretaker.getMemento(2); originator.setMemento(backup); System.out.println(\u0026#34;=========\u0026#34;); System.out.println(originator.getState()); } } class Originator{ // 作成者 private String state; public void setState(String state){ this.state = state; } public String getState(){ return state; } public Memento createMemento(){ return new Memento(state); } public void setMemento(Memento memento){ state = memento.getState(); } } class Memento{ // メメント private String state; public Memento(String state){ this.state = state; } public String getState(){ return state; } } class Caretaker{ // 管理者 private List\u0026lt;Memento\u0026gt; mementoList = new ArrayList\u0026lt;\u0026gt;(); public void addMemento(Memento memento){ mementoList.add(memento); } public Memento getMemento(int index){ return mementoList.get(index - 1); } public void showMemento(){ int i = 1; for(Memento m : mementoList){ System.out.println(\u0026#34;No.\u0026#34; + i + \u0026#34;: \u0026#34; + m.getState()); i++; } } } ","date":"2023-11-27T14:08:05+08:00","permalink":"https://blog.yexca.net/ja/archives/132/","title":"メメント・パターン (Memento Pattern)"},{"content":" 📢 この記事は ChatGPT によって翻訳されました はじめに ブログを GitHub に移した後は「もう新しいサーバー買わなくていいかな〜」と思ってたけど、\nここ数ヶ月静かすぎて何かいじりたい気分になってきて、\nあと「使わないけど無いと不安」みたいな気持ちで衝動買いしちゃった。\n現在運営してるサイト（yexca.net ドメイン） 自己紹介？： http://yexca.net （まだ半分くらいしかできてない） このブログ： http://blog.yexca.net 懐かしのブログ： http://wp.yexca.net VRChatブログ： http://vrc.yexca.net VRChatドキュメント： http://vrchat.yexca.net Navidrome（自分用音楽）： http://music.yexca.net ACG関連： http://acg.yexca.net （DNSで記録見て思い出した、まだ用途未定） xlog（Web3）： http://xlog.yexca.net Docker Docker を知ってからというもの、ほぼすべてのプロジェクトを Docker で立てるようになった。マジ便利。\nDebian10 + root でログインしてまず更新：\n1 apt update 必要なパッケージをインストール：\n1 apt install curl gpg GPG鍵を追加：\n1 curl -fsSL https://download.docker.com/linux/debian/gpg | gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg Dockerのリポジトリを追加：\n1 2 3 echo \\ \u0026#34;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/debian \\ buster stable\u0026#34; | tee /etc/apt/sources.list.d/docker.list \u0026gt; /dev/null Docker をインストール：\n1 2 apt update apt install docker-ce docker-ce-cli containerd.io docker-compose Docker を起動・自動起動：\n1 2 systemctl enable docker systemctl start docker テスト用：\n1 docker run --rm hello-world 参考： 服务器用 Docker 部署记录 公開鍵ログイン 参考： SSH 公钥登录 Nginx 今回も nginx-ui プロジェクトを使った Docker デプロイ。docker-compose.yml は以下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 version: \u0026#39;3.1\u0026#39; services: nginx-ui: restart: always image: uozi/nginx-ui:latest container_name: nginx_UI volumes: - /home/nginx_ui/nginx:/etc/nginx - /home/nginx_ui/nginx-ui:/etc/nginx-ui - /home/nginx_ui/www:/www ports: - 80:80 - 443:443 DNS 側で HTTPS を有効化してる場合は、証明書の設定は不要。そうしないとブラウザからアクセス不可になっちゃう。\n自己紹介ページ 実は前のサーバーで全部 Docker 化する前から考えてた。 だから blog.yexca.xyz に変更したのも、yexca.xyz を空けたかったから。\nyexca.xyz は現在手放してる。\nフォルダ作成日を見たら 2022.03.07、最後の編集が 2022.06.29。完全に放置してた。\nこのアイデアを思いついたきっかけは他のブロガーの自己紹介ページを見たとき。たとえば https://idealclover.top/ 、 https://the.moe/ など。 中にはテンプレートを公開してる人もいて、自分の情報を入れれば紹介ページが作れるやつもあった（リンク失念\u0026hellip;）\n最終的には http://lolicon.app のようなデザインを真似ることにした（なんでだっけ\u0026hellip;）\n参考：\nCSS でスクロールバーをカスタマイズ Webサイトに favicon.ico を設定する方法 Navidrome 衝動買いのもう一つの理由が、良い音楽サイトを自分で持ちたかったから。 以前は Onedriveベースのやつ を使ってたけど、中国からだとアクセスが遅い。 ちょうど 115 がセールしてたから契約した → それが今回のトリガー。\n結論：超微妙。OneDrive より遅い。やっぱ衝動買いは良くない。 最初は気に入ったら kikoeru-express も立てようかと思ってたけど\u0026hellip;ナシだな。\nRclone（115 対応） 115をマウントするには、115対応版 rclone が必要。\nGitHub: https://github.com/gaoyb7/rclone-release 本家と同じだけど 115 対応済み。\nCookie の取得 Chrome で手動取得 115 にログイン → DevTools → Network タブ → ページ更新 cookie.js?_=[number] を探す → Request Headers 内に Cookie がある。\nChrome 拡張で取得 Get cookies.txt LOCALLY アプリ経由の Cookie Web の Cookie はすぐ期限切れになるから、App から取得した方がいい。\niOS：Stream や Quantumult X Android：抓包精灵 PC：Fiddler など すぐ出てくるからここでは省略。\nRclone の設定 コマンドで設定 1 rclone config 完了後、Windows の場合は以下に設定ファイルができる：\n1 C:\\Users\\%USERNAME%\\AppData\\Roaming\\rclone 直接編集 rclone.conf を作成：\n1 2 3 4 5 [name] type = 115 uid = your_uid cid = your_cid seid = your_seid Windows でマウント winfsp を先にインストール： https://winfsp.dev/ 1 .\\rclone.exe mount -v --read-only --vfs-read-chunk-size=4M --buffer-size=32M --network-mode 115: X: Ctrl+C で解除\nLinux Docker マウント 1 docker pull gaoyb7/rclone:latest 1 2 3 4 5 6 7 docker run --rm \\ --volume /home/rclone/config:/config/rclone \\ --volume /home/rclone/data:/data:shared \\ --volume /etc/passwd:/etc/passwd:ro --volume /etc/group:/etc/group:ro \\ --device /dev/fuse --cap-add SYS_ADMIN --security-opt apparmor:unconfined \\ gaoyb7/rclone:latest \\ mount 115:/music /data/music --allow-other --allow-non-empty --vfs-cache-mode writes \u0026amp; Navidrome の設定 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 version: \u0026#34;3.0\u0026#34; services: navidrome: image: deluan/navidrome:latest ports: - \u0026#34;8005:4533\u0026#34; restart: unless-stopped environment: ND_SCANSCHEDULE: 1h ND_LOGLEVEL: info ND_SESSIONTIMEOUT: 24h ND_BASEURL: \u0026#34;\u0026#34; ND_LASTFM_ENABLED: \u0026#34;true\u0026#34; ND_LASTFM_APIKEY: your_LASTFM_APIKEY ND_LASTFM_SECRET: your_LASTFM_SECRET ND_LASTFM_LANGUAGE: zh ND_SPOTIFY_ID: your_SPOTIFY_ID ND_SPOTIFY_SECRET: your_SPOTIFY_SECRET ND_ENABLESHARING: \u0026#34;true\u0026#34; ND_UILOGINBACKGROUNDURL: \u0026#34;https://www.loliapi.com/acg\u0026#34; ND_UIWELCOMEMESSAGE: \u0026#34;ようこそ〜\u0026#34; volumes: - \u0026#34;/home/navidrome/data:/data\u0026#34; - \u0026#34;/home/rclone/data/music:/music/115:ro\u0026#34; - \u0026#34;/home/navidrome/music:/music/server:ro\u0026#34; Blog ブログは2つあって、どちらも過去記事の手順で構築済み。もう更新する予定なし。\nWordpress yexca\u0026rsquo;Blog は画像 CDN が見れなくなってて、置換プラグイン使っても直らずそのまま放置中（背景だけ見えればいい）\nTypecho VRChat 教程 は久々に開いたらログインパス忘れてて焦ったけど、ちゃんとバックアップとってあった。新環境に構築してデータ移行完了。\n画像も上と同様、時間ができたら CDN を変えるつもり（とりあえずカバーだけ変更済み）\nWarmaTap 初音ミクの音声を Warma に置き換えたタイプ音ページ。\n電子音風 GitHub: lwd-temp/warmatap デモ： http://yexca.net/warma_tap 人間っぽい声 GitHub: MonianHello/WarmaTap デモ： http://yexca.net/warmatap MikuTap（元ネタ） GitHub: HFIProgramming/mikutap デモ： http://yexca.net/mikutap MikuTap は patatap を参考に作られたもの\n","date":"2023-11-03T15:34:01+08:00","permalink":"https://blog.yexca.net/ja/archives/131/","title":"2023年 新しいサーバー構築記録"},{"content":" 📢 この記事は gemini-3-flash-preview によって翻訳されました サイト スマホでアクセスすれば見れるよ（iOSでしか試してないけど）。\n2020: https://st.music.163.com/c/year2020 2021: https://st.music.163.com/c/year2021 2022: https://st.music.163.com/c/year2022 経緯 Googleで「网易云年度报告」って検索してたら、 https://st.music.163.com/c/reportreview2020 を見つけたんだ（スマホでアクセスすると2020年の年度レポートへの入り口が表示される）。そのURLの年号を書き換えて試してみたら、2020年から2022年までの分が見れることがわかったよ。\n","date":"2023-10-29T23:45:01+08:00","permalink":"https://blog.yexca.net/ja/archives/130/","title":"NetEase Cloud Music 2020-2022 年度レポート"},{"content":" 📢 この記事は gemini-3-flash-preview によって翻訳されました この記事は 2022年12月に書いたものだけど、色んな理由で公開してなかったんだ。\nこの一連の記事は、僕が『Linux システム管理、サーバー設定、セキュリティ、クラウドデータセンター』を読んだ時に書いた関連ノートだよ。\n第1部：入門 このセクションの記事はないよ。\n第1章 Linux を使い始める Linux の歴史。まとめ：Linux 最高。\n第2章 完璧な Linux デスクトップを作る で、その結果 Fedora デスクトップいじり を書いたんだ。\n第2部：Linux パワーユーザーになる 第3章 シェルを使う シェルの使い方と変数について。\n第4章 ファイルシステム内を移動する ファイル関連のシェルコマンド、メタ文字、ファイルの権限。\n第5章 テキストファイルを扱う vi エディタ、ファイル検索 (locate 、find 、grep)。\n第6章 実行中のプロセスを管理する プロセスの一覧表示、プロセスの強制終了、プロセスの制限。\n第7章 簡単なシェルスクリプトを書く シェルスクリプトの構文をいくつか。\n第3部 Linux システム管理者の仲間入り 第8章 システム管理を学ぶ /etc 配下の設定ファイルについて。\n第9章 Linux のインストール (なし) 記事はないよ。個人向けの GUI やコマンドラインでのインストール、企業での一括インストールについて。\n第10章 ソフトウェアの入手と管理 RPM と DEB パッケージ、yum 、rpm 、dnf 、apt コマンド。\n第11章 ユーザーアカウントの作成 ユーザーアカウントとグループアカウントの管理。\n第12章 ディスクとファイルシステムの管理 ファイルシステムの作成、LVM 論理ボリューム、ファイルシステムのマウント。\nこの後にはサーバー管理者、Linux セキュリティ技術、Linux のクラウド拡張についてもあったんだけど、諸事情でノートは書かないことにしたよ。\n","date":"2023-10-21T14:18:15+08:00","permalink":"https://blog.yexca.net/ja/archives/129/","title":"Linux 学習インデックス"},{"content":" 📢 この記事は gemini-3-flash-preview によって翻訳されました Mediator Pattern オブジェクト振る舞い型パターン\n意図 中介者（メディエーター）オブジェクトを使って、一連のオブジェクト同士のやり取りをカプセル化するよ。メディエーターを使うことで、各オブジェクトが互いに明示的に参照し合う必要がなくなるから、結合をゆるくできるんだ。それに、オブジェクト間のやり取りを独立して自由に変更できるようになるよ。\n構造 役割分担はこんな感じ：\nMediator (中介者)：各 Colleague (同僚) オブジェクトが通信するためのインターフェースを定義する。 ConcreteMediator (具体的な中介者)：各同僚オブジェクトを調整して協力動作を実現するよ。自分の同僚たちを把握して管理しているんだ。 Colleague class (同僚クラス)：自分の中介者オブジェクトを知っているよ。他の同僚と通信したいときは、いつも自分の中介者を通して通信するんだ。 適用シーン Mediator パターンはこんな時にぴったりだよ：\nオブジェクトのグループが、定義はされているけど複雑な方法で通信していて、依存関係がごちゃごちゃで理解しにくいとき。 あるオブジェクトが他の多くのオブジェクトを参照し、直接通信しているせいで、そのオブジェクトを再利用するのが難しいとき。 複数のクラスに分散している振る舞いをカスタマイズしたいけど、サブクラスを増やしすぎたくないとき。 例 1 オンライン決済はネットショッピングの重要な要素だけど、プラットフォームによって決済インターフェースがバラバラなんだ。今回は、異なるプラットフォームの決済インターフェースを統合して、利用者が具体的なインターフェースを意識せずに買い物できるようにしたい。これをメディエーターパターンで実装すると、クラス図はこんな風になるよ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 interface WebServiceMediator { public void buy(double money, WebService service); public void SetAmazon(WebService amazon); public void SetEbay(WebService ebay); } abstract class WebService { protected WebServiceMediator mediator; public abstract void SetMediator(WebServiceMediator mediator); public abstract void buyService(double money); public abstract void search(double money); } class ConcreteServiceMediator implements WebServiceMediator { private WebService amazon; private WebService ebay; public ConcreteServiceMediator() { amazon = null; ebay = null; } public void SetAmazon(WebService amazon) { this.amazon = amazon; } public void SetEbay(WebService ebay) { this.ebay = ebay; } public void buy(double money, WebService service) { if (service == amazon) amazon.search(money); else ebay.search(money); } } class Amazon extends WebService { public void SetMediator(WebServiceMediator mediator) { this.mediator = mediator; } public void buyService(double money) { mediator.buy(money, this); } public void search(double money) { System.out.println(\u0026#34;Amazon receive：\u0026#34; + money); } } class Ebay extends WebService { public void SetMediator(WebServiceMediator mediator) { this.mediator = mediator; } public void buyService(double money) { mediator.buy(money, this); } public void search(double money) { System.out.println(\u0026#34;Ebay receive：\u0026#34; + money); } } 例 2 二人の同僚（Colleague）間での通信の例だよ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 public class MediatorPattern { public static void main(String[] args) { ConcreteMediator m = new ConcreteMediator(); Colleague1 c1 = new Colleague1(m); Colleague2 c2 = new Colleague2(m); m.setC1(c1); m.setC2(c2); c1.sendMessage(\u0026#34;hello\u0026#34;); c2.sendMessage(\u0026#34;hi\u0026#34;); } } abstract class Colleague{ protected Mediator mediator; } class Colleague1 extends Colleague{ public Colleague1(Mediator mediator){ this.mediator = mediator; } public void sendMessage(String message){ mediator.sendMessage(message, this); } public void Notify(String message){ System.out.println(\u0026#34;Colleague1 received: \u0026#34; + message); } } class Colleague2 extends Colleague{ public Colleague2(Mediator mediator){ this.mediator = mediator; } public void sendMessage(String message){ mediator.sendMessage(message, this); } public void Notify(String message){ System.out.println(\u0026#34;Colleague2 received: \u0026#34; + message); } } abstract class Mediator{ public abstract void sendMessage(String message, Colleague c); } class ConcreteMediator extends Mediator{ // この例ではオブジェクトが少ないから直接定義しているよ private Colleague1 c1; private Colleague2 c2; // もし同僚がたくさんいるなら // List\u0026lt;Colleague\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); // public void Add(Colleague c){ // list.add(c); // } public void setC1(Colleague1 c1){ this.c1 = c1; } public void setC2(Colleague2 c2){ this.c2 = c2; } @Override public void sendMessage(String message, Colleague c){ if(c == c1){ // 同僚2にメッセージを届ける c2.Notify(message); }else{ // 同僚1にメッセージを届ける c1.Notify(message); } } } ","date":"2023-10-15T17:14:26+08:00","permalink":"https://blog.yexca.net/ja/archives/128/","title":"メディエーターパターン (Mediator Pattern)"},{"content":" 📢 この記事は gemini-3-flash-preview によって翻訳されました Iterator Pattern（オブジェクト振る舞い型パターン）\n意図 集合オブジェクトの内部表現を露出させることなく、その中の各要素に順番にアクセスする方法を提供するよ。\n構造 役割分担はこんな感じ：\nIterator (イテレーター): 要素へのアクセスや走査のためのインターフェースを定義する。 ConcreteIterator (具体的なイテレーター): Iterator インターフェースを実装する。集合を走査する際の現在の位置を保持するよ。 Aggregate (集合体): 対応するイテレーターオブジェクトを作成するためのインターフェースを定義する。 ConcreteAggregate (具体的な集合体): イテレーター作成のインターフェースを実装して、ConcreteIterator の適切なインスタンスを返すよ。 適用シーン イテレーターパターンは、以下のような場合にぴったりだよ：\n集合オブジェクトの内部構造を見せずに、その内容にアクセスしたいとき 集合オブジェクトに対して、複数の異なる方法で走査したいとき 異なる集合構造に対しても、共通のインターフェースで走査できるようにしたいとき Java ですでに実装されているイテレーターを使ってみる 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 import java.util.ArrayList; import java.util.Iterator; import java.util.List; public class IteratorPattern { public static void main(String[] args) { List\u0026lt;Book\u0026gt; bookList = new ArrayList\u0026lt;\u0026gt;(); String[] books = {\u0026#34;Linear Algebra\u0026#34;, \u0026#34;Algorithm\u0026#34;}; double[] prices = {25.8, 29.8}; for(int i = 0; i \u0026lt; 2; i++){ bookList.add(new Book(books[i], prices[i])); } // 要素へのアクセス 1 (通常のforループ) for(int i = 0; i \u0026lt; bookList.size(); i++){ Book book = bookList.get(i); System.out.println(\u0026#34;name: \u0026#34; + book.getName() + \u0026#34; price: \u0026#34; + book.getPrice()); } // 要素へのアクセス 2 (拡張forループ) System.out.println(\u0026#34;=====222=====\u0026#34;); for(Book book : bookList){ System.out.println(\u0026#34;name: \u0026#34; + book.getName() + \u0026#34; price: \u0026#34; + book.getPrice()); } // 要素へのアクセス 3 (イテレーター) System.out.println(\u0026#34;=====333=====\u0026#34;); Iterator iterator = bookList.iterator(); while (iterator.hasNext()){ Book book = (Book) iterator.next(); System.out.println(\u0026#34;name: \u0026#34; + book.getName() + \u0026#34; price: \u0026#34; + book.getPrice()); } } } class Book{ private String name; private double price; public Book(String name, double price){ this.name = name; this.price = price; } public double getPrice() { return price; } public String getName() { return name; } } 実装例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 import javax.sound.midi.Soundbank; import java.util.ArrayList; import java.util.List; public class IteratorPattern { public static void main(String[] args) { BookAggregate bookAggregate = new BookAggregate(); String[] books = {\u0026#34;Linear Algebra\u0026#34;, \u0026#34;Algorithm\u0026#34;}; double[] prices = {25.8, 29.8}; for(int i = 0; i \u0026lt; 2; i++){ bookAggregate.Add(new Book(books[i], prices[i])); } Iterator iterator = bookAggregate.CreateIterator(); while(iterator.hasNext()){ Book book = (Book)iterator.next(); System.out.println(\u0026#34;name: \u0026#34; + book.getName() + \u0026#34; price: \u0026#34; + book.getPrice()); } } } interface Iterator{ public boolean hasNext(); public Object next(); } class BookIterator implements Iterator{ private int index; private BookAggregate bookAggregate; public BookIterator(BookAggregate bookAggregate){ this.index = 0; this.bookAggregate = bookAggregate; } @Override public boolean hasNext(){ if (index \u0026lt; bookAggregate.getSize()) return true; return false; } @Override public Object next(){ Object obj = bookAggregate.get(index); index++; return obj; } } interface Aggregate{ public Iterator CreateIterator(); } class BookAggregate implements Aggregate{ private List\u0026lt;Book\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); public void Add(Book book){ list.add(book); } public Book get(int index){ return list.get(index); } public int getSize(){ return list.size(); } @Override public Iterator CreateIterator(){ return new BookIterator(this); } } class Book{ private String name; private double price; public Book(String name, double price){ this.name = name; this.price = price; } public double getPrice() { return price; } public String getName() { return name; } } ","date":"2023-10-12T09:09:24+08:00","permalink":"https://blog.yexca.net/ja/archives/127/","title":"イテレーターパターン"},{"content":" 📢 この記事は gemini-2.5-flash によって翻訳されました Interpreter Pattern クラスの振る舞いパターン\nどんなこと？ ある言語があったとき、その文法を表す方法を定義して、その表現を使って言語の文を解釈するインタプリタも定義するんだ。\n構造 こんな感じだよ：\nAbstractExpression はプログラムの解釈操作を宣言するインターフェースで、これは抽象構文木のすべてのノードで共有されるものなんだ。 TerminalExpression は文法の終端記号に関連する解釈操作を実装するよ。文中の各終端記号には、このクラスのインスタンスが一つ必要になるんだ。 NonterminalExpression は、文法の各ルールごとに NonterminalExpression クラスが必要になるよ。各記号に対して AbstractExpression 型のインスタンス変数を一つずつ持ってて、文法の非終端記号の解釈 (Interpret) 操作を実装するんだ。 Context は、インタプリタ以外のグローバルな情報を含むものだよ。 Client は、その文法で定義された言語の特定の文を表す抽象構文木を構築する (または与えられる) んだ。この抽象構文木は NonterminalExpression と TerminalExpression のインスタンスを組み合わせて作られるよ。そして、解釈操作を呼び出すんだ。 いつ使うといいの？ インタプリタパターンは、解釈実行が必要な言語があって、その言語の文を抽象構文木として表せる場合に役立つよ。特に、次の状況で一番うまくいくんだ：\n文法がシンプル 効率がそこまで重要じゃない 例を見てみよう 文字列をチェックする例だよ：「某区の某人員 (someone of ? region)」\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 import java.util.*; public class InterpreterPattern { public static void main(String[] args) { Context context = new Context(); context.check(\u0026#34;developer of A region\u0026#34;); } } class Context{ private String[] regions = {\u0026#34;A region\u0026#34;, \u0026#34;B region\u0026#34;, \u0026#34;C region\u0026#34;}; private String[] persons = {\u0026#34;developer\u0026#34;, \u0026#34;tester\u0026#34;}; private NonterminalExpression nte; public Context(){ TerminalExpression region = new TerminalExpression(regions); TerminalExpression person = new TerminalExpression(persons); nte = new NonterminalExpression(region, person); } public void check(String info){ boolean bool = nte.Interpret(info); if(bool){ System.out.println(\u0026#34;right\u0026#34;); }else { System.out.println(\u0026#34;wrong\u0026#34;); } } } interface Expression{ public boolean Interpret(String info); } class NonterminalExpression implements Expression{ TerminalExpression region; TerminalExpression person; public NonterminalExpression(TerminalExpression region, TerminalExpression person){ this.person = person; this.region = region; } @Override public boolean Interpret(String info){ String[] str = info.split(\u0026#34; of \u0026#34;); // \u0026#34;developer of A region\u0026#34; --\u0026gt; str = {\u0026#34;developer\u0026#34;, \u0026#34;A region\u0026#34;} return region.Interpret(str[1]) \u0026amp;\u0026amp; person.Interpret(str[0]); } } class TerminalExpression implements Expression{ private Set\u0026lt;String\u0026gt; set = new HashSet\u0026lt;\u0026gt;(); public TerminalExpression(String[] data){ for(String str : data){ set.add(str); } } @Override public boolean Interpret(String info){ return set.contains(info); } } ","date":"2023-10-09T17:31:58+08:00","permalink":"https://blog.yexca.net/ja/archives/126/","title":"インタプリタパターン"},{"content":" 📢 この記事は gemini-2.5-flash によって翻訳されました Commandパターン オブジェクトの振る舞いパターン\n目的 リクエストをオブジェクトにカプセル化して、異なるリクエストでクライアントをパラメータ化できるようにするよ。リクエストをキューに入れたり、ログに残したり、取り消し可能な操作をサポートしたりできるんだ。\n構造 要素はこんな感じ。\nCommand は実行操作のインターフェースを宣言するよ。 ConcreteCommand はレシーバーオブジェクトをアクションにバインドするんだ。Execute を実装するために、レシーバーの対応する操作を呼び出すよ。 Client は具体的なコマンドオブジェクトを作成して、そのレシーバーを設定するよ。 Invoker はそのコマンドにこのリクエストを実行するよう要求するよ。 Receiver はリクエストに関連する操作をどのように実施し、実行するかを知っているんだ。どんなクラスでもレシーバーになれるよ。 適用できる場面 Command パターンが使えるのは、こんな時だよ。\n実行するアクションを抽象化して、オブジェクトをパラメータ化したい時。 異なるタイミングでリクエストを指定したり、並べたり、実行したりしたい時。 操作のキャンセルをサポートしたい時。 変更ログをサポートしたい時。 プリミティブな操作の上に構築された高レベルな操作を使ってシステムを構築したい時。 例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 public class CommandPattern { public static void main(String[] args) { // レシーバーオブジェクト テレビ Tv tv = new Tv(); // コマンドオブジェクト Command oncommand = new OnCommand(tv); Command offcommand = new OffCommand(tv); // インヴォーカー（要求者） Invoker invoker = new Invoker(); // 電源オン invoker.setCommand(oncommand); invoker.Execute(); // 電源オフ invoker.setCommand(offcommand); invoker.Execute(); } } class Invoker{ // インヴォーカー（要求者） private Command command; // コマンド public void setCommand(Command command){ // インヴォーカーの要求コマンドを設定 this.command = command; } public void Execute(){ // コマンドを実行 command.Execute(); } } interface Command{ // コマンドインターフェース public void Execute(); // コマンドを実行 } class OnCommand implements Command{ // 電源オンコマンド private Tv tv; public OnCommand(Tv tv){ this.tv = tv; } @Override public void Execute(){ tv.OnAction(); } } class OffCommand implements Command{ // 電源オフコマンド private Tv tv; public OffCommand(Tv tv){ this.tv = tv; } @Override public void Execute(){ tv.OffAction(); } } class Tv{ // レシーバー テレビ public void OnAction(){ System.out.println(\u0026#34;Tv On\u0026#34;); } public void OffAction(){ System.out.println(\u0026#34;Tv Off\u0026#34;); } } ","date":"2023-09-10T15:26:55+08:00","permalink":"https://blog.yexca.net/ja/archives/125/","title":"Commandパターン"},{"content":" 📢 この記事は gemini-2.5-flash によって翻訳されました Chain of Responsibility パターン オブジェクトの振る舞いパターン\n意図 複数のオブジェクトがリクエストを処理する機会を持てるようにして、リクエストの送信者と受信者の間の結合を避けるのが目的だよ。これらのオブジェクトを鎖のように繋いで、リクエストが処理されるまでその鎖に沿って渡していくんだ。\n構造 こんな感じだよ：\nHandler：リクエストを処理するインターフェースを定義するよ。（オプションで）後続のチェーンも実装できるんだ。 ConcreteHandler：担当するリクエストを処理するよ。後続のオブジェクトにアクセスできるんだ。もしリクエストを処理できるなら自分で処理して、できなければ後続に転送するよ。 Client：チェーン上の具体的な処理者 (ConcreteHandler) オブジェクトにリクエストを送信するんだ。 適用性 Chain of Responsibility パターンは、こんな時に使うといいよ：\n複数のオブジェクトが1つのリクエストを処理できるけど、どのオブジェクトが処理するかは実行時に自動で決まる場合。 受け取り側を明示的に指定せずに、複数のオブジェクトのどれかにリクエストを送りたい場合。 リクエストを処理できるオブジェクトの集合を動的に指定したい場合。 例 学生が休暇を申請する例で見てみよう。まずカウンセラーに申請して、カウンセラーが処理できなかったら学長に回して、学長が処理できなかったら校長に回すんだ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 public class ChainOfResponsibilityPattern { public static void main(String[] args) { // 实例化对象 Handler counsellor = new Counsellor(); Handler president = new President(); Handler schoolmaster = new Schoolmaster(); // 设置对象下一级 counsellor.next = president; president.next = schoolmaster; schoolmaster.next = null; // 向辅导员请求7天假期 counsellor.HandlerRequest(7); } } abstract class Handler{ protected Handler next; public void setNext(Handler next){ this.next = next; } // 学生请假请求 public abstract void HandlerRequest(int request); } class Counsellor extends Handler{ // 辅导员 小于等于7天审批 @Override public void HandlerRequest(int request){ if (request \u0026lt;= 7) { System.out.println(\u0026#34;Counsellor Agree!\u0026#34;); } else { if(next != null){ next.HandlerRequest(request); } else { System.out.println(\u0026#34;Counsellor Refuse!\u0026#34;); } } } } class President extends Handler{ // 院长 小于等于15天审批 @Override public void HandlerRequest(int request){ if (request \u0026lt;= 15) { System.out.println(\u0026#34;President Agree!\u0026#34;); } else { if(next != null){ next.HandlerRequest(request); } else { System.out.println(\u0026#34;President Refuse!\u0026#34;); } } } } class Schoolmaster extends Handler{ // 校长 小于等于30天审批 @Override public void HandlerRequest(int request){ if (request \u0026lt;= 30) { System.out.println(\u0026#34;Schoolmaster Agree!\u0026#34;); } else { if(next != null){ next.HandlerRequest(request); } else { System.out.println(\u0026#34;Schoolmaster Refuse!\u0026#34;); } } } } ","date":"2023-09-09T07:02:55+08:00","permalink":"https://blog.yexca.net/ja/archives/124/","title":"責任チェーンパターン"},{"content":" 📢 この記事は gemini-3-flash-preview によって翻訳されました プロキシパターン (Proxy Pattern) オブジェクト構造型パターン\n意図 他のオブジェクトへのアクセスをコントロールするために、そのオブジェクトの身代わり（代理人）を提供するよ。\n構造 役割分担はこんな感じ：\nProxy (代理人)：実際のオブジェクト（RealSubject）への参照を持っていて、代理としてアクセスを受け付けるよ。Subject と同じインターフェースを持っているから、使う側は本物だと思って扱えるんだ。本物へのアクセスを制限したり、必要に応じて本物の生成や削除も担当するよ。 Subject (インターフェース)：RealSubject と Proxy に共通のインターフェースを定義するよ。これがあるおかげで、RealSubject が必要な場所ならどこでも Proxy を代わりに使えるようになるんだ。 RealSubject (実体)：Proxy が代理を務める、実際のオブジェクトだよ。 どんな時に使う？ 単純なポインタよりも、もっと多機能だったり複雑な制御が必要な時にプロキシパターンが使われるよ。よくあるケースをいくつか紹介するね。\nリモートプロキシ (Remote Proxy)：別の場所に（別のサーバーとかに）あるオブジェクトを、まるで手元にあるかのように見せたい時に使うよ。 仮想プロキシ (Virtual Proxy)：作るのに時間がかかる重いオブジェクトを、本当に必要になるまで作らない（遅延生成）ようにする時に使うよ。 保護プロキシ (Protection Proxy)：アクセス権限をチェックして、元のオブジェクトを勝手に触られないようにガードしたい時に使うよ。 スマートリファレンス (Smart Reference)：オブジェクトにアクセスする時に、ついでに何か処理をさせたい時に使うよ。例えば、参照カウンターを増やしたり、最初にアクセスした時にメモリにロードしたり、他の人が書き換えないようにロックをかけたりするんだ。 例 仲介業者が代わりに買い物をするイメージのコードだよ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 public class ProxyPattern { public static void main(String[] args) { RealSubject realSubject = new RealSubject(); Proxy proxy = new Proxy(realSubject); proxy.buy(); } } interface Subject{ public void buy(); } class Proxy implements Subject{ protected RealSubject realSubject; public Proxy(RealSubject realSubject){ this.realSubject = realSubject; } @Override public void buy() { System.out.println(\u0026#34;準備中...\u0026#34;); realSubject.buy(); System.out.println(\u0026#34;完了！\u0026#34;); } } class RealSubject implements Subject{ @Override public void buy() { System.out.println(\u0026#34;お金を払って購入\u0026#34;); } } ","date":"2023-09-08T12:15:26+08:00","permalink":"https://blog.yexca.net/ja/archives/123/","title":"プロキシパターン (Proxy Pattern)"},{"content":" 📢 この記事は gemini-3-flash-preview によって翻訳されました Flyweight Pattern（フライウェイトパターン） オブジェクト構造型パターン\n意図 共有技術を使って、大量の細かい粒度のオブジェクトを効率的にサポートするよ。\n構造 役割はこんな感じ：\nFlyweight：外部状態を受け取り、それに基づいて動作するためのインターフェースを定義するよ。\nConcreteFlyweight：Flyweight インターフェースを実装して、内部状態（もしあれば）のためのストレージを追加するんだ。ConcreteFlyweight オブジェクトは共有可能である必要があるよ。保持する状態は「内部的」なもの、つまりオブジェクトが置かれた状況に依存しないものである必要があるんだ。\nすべての Flyweight サブクラスが共有される必要があるわけじゃないよ。Flyweight インターフェースは共有を可能にするけど、強制はしないんだ。Flyweight オブジェクト構造の特定の階層では、UnsharedConcreteFlyweight オブジェクトが ConcreteFlyweight オブジェクトを子ノードとして持つこともよくあるよ。\nFlyweightFactory：Flyweight オブジェクトを作成して管理するよ。Flyweight が適切に共有されるように制御して、ユーザーが Flyweight をリクエストした時に、作成済みのインスタンスを提供するか、存在しない場合は新しく作成するんだ。\nClient：Flyweight への参照を保持して、一つ以上の Flyweight の外部状態を計算したり保存したりするよ。\n適用性 Flyweight パターンはこんな時に適しているよ：\nアプリケーションが大量のオブジェクトを使用している 大量のオブジェクトを使用することで、メモリのコストが非常に高くなっている オブジェクトの状態のほとんどが外部状態にできる オブジェクトの外部状態を取り除けば、比較的少数の共有オブジェクトで、多くのオブジェクトグループを代替できる アプリケーションがオブジェクトの識別（アイデンティティ）に依存していない。Flyweight オブジェクトは共有されるから、概念的に異なるオブジェクトでも、同一性テストで真（true）が返ってくることがあるんだ。 例 1 オンライン囲碁プログラムを開発するとするね。たくさんのプレイヤーがオンラインで対局できるようにしたい。サーバーが1台しかないから、メモリ空間を節約するためにフライウェイトパターンを使って実装してみるよ。クラス図は以下の通り。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 import java.util.ArrayList; enum PieceColor {BLACK, WHITE} // 駒の色 class PiecePods{ // 駒の位置 private int x; private int y; public PiecePods(int a, int b){ x = a; y = b; } public int getX(){ return x; } public int getY() { return y; } } abstract class Piece{ // 駒の定義 protected PieceColor m_color; // 色 protected PiecePods m_pos; // 位置 public Piece(PieceColor color, PiecePods pos){ this.m_color = color; this.m_pos = pos; } public abstract void draw(); } class BlackPiece extends Piece{ public BlackPiece(PieceColor color, PiecePods pos){ super(color, pos); } @Override public void draw(){ System.out.println(\u0026#34;黒駒を描画するよ\u0026#34;); } } class WhitePiece extends Piece{ public WhitePiece(PieceColor color, PiecePods pos){ super(color, pos); } @Override public void draw(){ System.out.println(\u0026#34;白駒を描画するよ\u0026#34;); } } class PieceBoard{ // 盤上の既にある駒 private static final ArrayList\u0026lt;Piece\u0026gt; m_arrayPiece = new ArrayList\u0026lt;\u0026gt;(); private String m_blackName; // 黒のプレイヤー名 private String m_whiteName; // 白のプレイヤー名 public PieceBoard(String black, String white){ m_blackName = black; m_whiteName = white; } // 一手打つ、盤上に駒を置く public void setPiece(PieceColor color, PiecePods pos){ Piece piece = null; if(color == PieceColor.BLACK){ // 黒を置く piece = new BlackPiece(color, pos); System.out.println(m_blackName + pos.getX() + pos.getY()); piece.draw(); }else{ // 白を置く piece = new WhitePiece(color, pos); System.out.println(m_whiteName + pos.getX() + pos.getY()); piece.draw(); } m_arrayPiece.add(piece); } } 例 2 五目並べ\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 public class FlyWeightPattern { public static void main(String[] args) { PieceFactory factory = new PieceFactory(); Piece wp1 = factory.getPiece(0); wp1.draw(2023, 0527); } } class PieceFactory{ private Piece[] pieces = {new WhitePiece(), new BlackPiece()}; public Piece getPiece(int key){ if(key == 0) return pieces[0]; else return pieces[1]; } } abstract class Piece{ protected String color; public abstract void draw(int x, int y); } class WhitePiece extends Piece{ public WhitePiece(){ this.color = \u0026#34;white\u0026#34;; } @Override public void draw(int x, int y){ System.out.println(\u0026#34;draw a \u0026#34; + this.color + \u0026#34; piece x: \u0026#34; + x + \u0026#34; y: \u0026#34; + y); } } class BlackPiece extends Piece{ public BlackPiece(){ this.color = \u0026#34;Black\u0026#34;; } @Override public void draw(int x, int y){ System.out.println(\u0026#34;draw a \u0026#34; + this.color + \u0026#34; piece x: \u0026#34; + x + \u0026#34; y: \u0026#34; + y); } } 例 3 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 import java.util.HashMap; import java.util.Map; import java.util.Random; public class FlyWeightPattern { public static void main(String[] args) { ShapeFactory sf = new ShapeFactory(); Random r = new Random(); String[] colors = {\u0026#34;red\u0026#34;, \u0026#34;blue\u0026#34;, \u0026#34;green\u0026#34;, \u0026#34;white\u0026#34;, \u0026#34;black\u0026#34;}; for (int i = 0; i \u0026lt; 10; i++) { int x = r.nextInt(colors.length); Shape s = sf.getShape(colors[x]); s.draw(r.nextInt(2023), r.nextInt(527)); } } } class ShapeFactory{ private Map\u0026lt;String, Shape\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); public Shape getShape(String key){ if (!map.containsKey(key)) { map.put(key, new Circle(key)); System.out.println(\u0026#34;create new circle, color: \u0026#34; + key); } return map.get(key); } } abstract class Shape{ protected String color; public abstract void draw(int x, int y); } class Circle extends Shape{ public Circle(String color){ this.color = color; } @Override public void draw(int x, int y) { System.out.println(\u0026#34;draw a \u0026#34; + this.color + \u0026#34; circle x: \u0026#34; + x + \u0026#34; y: \u0026#34; + y); } } ","date":"2023-09-07T13:54:55+08:00","permalink":"https://blog.yexca.net/ja/archives/122/","title":"フライウェイトパターン (Flyweight Pattern)"},{"content":" 📢 この記事は gemini-3-flash-preview によって翻訳されました Facade（ファサード）パターン オブジェクト構造型パターン\n意図 サブシステム内の一連のインターフェースに対して、統一されたインターフェースを提供する。Facade パターンは、このサブシステムをより使いやすくするための高レベルなインターフェースを定義するものだよ。\n構造 役割分担：\nFacade（窓口）：どのサブシステムクラスがリクエストの処理を担当するかを知っていて、クライアントのリクエストを適切なサブシステムオブジェクトに転送（委譲）する。 Subsystem classes（サブシステム群）：サブシステムの機能を実際に実装する。Facade オブジェクトから割り当てられたタスクを処理するけど、Facade についての情報は一切持っていない（Facade への参照を持たない）んだ。 使いどころ Facade パターンはこんな時に役立つよ：\n複雑なサブシステムにシンプルなインターフェースを提供したいとき。サブシステムは進化するにつれてどんどん複雑になりがち。たいていのパターンはクラスを細分化するから、再利用性やカスタマイズ性は上がるけど、単純に使いたいだけのユーザーにとっては扱いづらくなっちゃう。Facade はシンプルなデフォルトのビューを提供することで、一般ユーザーには使いやすく、こだわりたいユーザーは Facade を超えて中身を触れるようにするんだ。 クライアントプログラムと抽象クラスの実装部分の間に大きな依存関係があるとき。Facade を導入してサブシステムをクライアントや他のサブシステムから切り離すことで、独立性と移植性を高めることができるよ。 階層構造のサブシステムを構築するとき。Facade を使って各層の入り口を定義する。サブシステム同士が依存し合っている場合でも、Facade を通して通信するようにすれば、依存関係をシンプルに整理できるんだ。 例 1 病院を例に考えてみよう。診察を受けるとき、患者は受付、診察、薬の受け取りなど、病院のいろんな部署とやり取りする必要があるよね。この流れを簡略化するために「案内係」を置くイメージ。患者は案内係とだけやり取りすれば、案内係が代わりに各ステップを進めてくれるんだ。\nJava コード 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 import java.util.*; interface Patient { public String getName(); } interface Disposer { public void dispose(Patient patient); } class Registry implements Disposer { // 受付 public void dispose(Patient patient) { System.out.println(\u0026#34;I am registering...\u0026#34; + patient.getName()); } } class Doctor implements Disposer { // 診察 public void dispose(Patient patient) { System.out.println(\u0026#34;I am diagnosing...\u0026#34; + patient.getName()); } } class Pharmacy implements Disposer { // 薬局（薬の受け取り） public void dispose(Patient patient) { System.out.println(\u0026#34;I am medicine... \u0026#34; + patient.getName()); } } class Facade { private Patient patient; public Facade(Patient patient) { this.patient = patient; } void dispose() { Registry registry = new Registry(); Doctor doctor = new Doctor(); Pharmacy pharmacy = new Pharmacy(); registry.dispose(patient); doctor.dispose(patient); pharmacy.dispose(patient); } } class ConcretePatient implements Patient { private String name; public ConcretePatient(String name) { this.name = name; } public String getName() { return name; } } public class FacadeTest { public static void main(String[] args) { Patient patient = new ConcretePatient(\u0026#34;zst\u0026#34;); Facade f = new Facade(patient); f.dispose(); } } C++ コード 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; class Patient { public: virtual string getName() = 0; }; class Disposer { public: virtual void dispose(Patient *patient) = 0; }; class Registry : public Disposer { // 受付 public: void dispose(Patient *patient) { cout \u0026lt;\u0026lt; \u0026#34;I am registering....\u0026#34; \u0026lt;\u0026lt; patient-\u0026gt;getName() \u0026lt;\u0026lt; endl; } }; class Doctor : public Disposer { // 診察 public: void dispose(Patient *patient) { cout \u0026lt;\u0026lt; \u0026#34;I am diagnosing....\u0026#34; \u0026lt;\u0026lt; patient-\u0026gt;getName() \u0026lt;\u0026lt; endl; } }; class Pharmacy : public Disposer { // 薬局（薬の受け取り） public: void dispose(Patient *patient) { cout \u0026lt;\u0026lt; \u0026#34;I am giving medicine....\u0026#34; \u0026lt;\u0026lt; patient-\u0026gt;getName() \u0026lt;\u0026lt; endl; } }; class Facade { private: Patient *patient; public: Facade(Patient *patient) { this-\u0026gt;patient = patient; } void dispose() { Registry *registry = new Registry(); Doctor *doctor = new Doctor(); Pharmacy *pharmacy = new Pharmacy(); registry-\u0026gt;dispose(patient); doctor-\u0026gt;dispose(patient); pharmacy-\u0026gt;dispose(patient); } }; class ConcretePatient : public Patient { private: string name; public: ConcretePatient(string name) { this-\u0026gt;name = name; } string getName() { return name; } }; int main() { Patient *patient = new ConcretePatient(\u0026#34;zst\u0026#34;); Facade *f = new Facade(patient); f-\u0026gt;dispose(); return 0; } 例 2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 public class FacadePattern { public static void main(String[] args) { Facade f = new Facade(); f.methodA(); } } class Facade{ SubSystemOne s1; SubSystemTwo s2; SubSystemThree s3; public Facade(){ s1 = new SubSystemOne(); s2 = new SubSystemTwo(); s3 = new SubSystemThree(); } public void methodA(){ s1.Operation(); } public void methodB(){ s2.Operation(); } public void methodC(){ s3.Operation(); } } class SubSystemOne{ public void Operation(){ System.out.println(\u0026#34;SubSystemOne\u0026#34;); } } class SubSystemTwo{ public void Operation(){ System.out.println(\u0026#34;SubSystemTwo\u0026#34;); } } class SubSystemThree{ public void Operation(){ System.out.println(\u0026#34;SubSystemThree\u0026#34;); } } ","date":"2023-09-06T03:02:02+08:00","permalink":"https://blog.yexca.net/ja/archives/121/","title":"Facade パターン"},{"content":" 📢 この記事は gemini-2.5-flash によって翻訳されました デコレーターパターン オブジェクト構造パターン\n目的 オブジェクトに動的に追加の機能（責務）を与えられるよ。機能を追加するって点では、デコレーターパターンはサブクラスを作るよりずっと柔軟なんだ。\n構造 登場するやつらはこんな感じ。\nComponent: オブジェクトのインターフェースを定義するよ。このインターフェースを持つオブジェクトには、動的に機能を追加できるんだ。 ConcreteComponent: 実際のオブジェクトを定義するやつ。これに機能を追加していくんだ。 Decorator: Componentオブジェクトへのポインタを持っていて、Componentのインターフェースと一致するインターフェースを定義するんだ。 ConcreteDecorator: コンポーネントに具体的な機能を追加する役目だよ。 いつ使うといいか デコレーターパターンが役立つのは、こんな時かな。\n他のオブジェクトに影響を与えずに、動的かつ透過的な方法で、個々のオブジェクトに機能を追加したいとき。 後から取り消せるような機能を扱いたいとき。 サブクラスを作って拡張するのが難しいとき。たとえば、独立した拡張がたくさんあって、すべての組み合わせをサポートしようとするとサブクラスが爆発的に増えちゃう場合とか、クラス定義が隠されてたり、サブクラスを作るのに使えなかったりする場合だね。 例1 あるコーヒーショップでは、コーヒーを売るときにお客さんの要望に応じていろんなトッピングを追加できるんだ。で、追加されたトッピングに基づいて料金を計算するんだよ。コーヒーとトッピングの種類と値段は下の表のとおり。\nこの料金計算機能をデコレーターパターンで実装すると、こんなクラス図になるよ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 import java.util.*; abstract class Beverage { // 飲み物 String description = \u0026#34;Unknown Beverage\u0026#34;; public String getDescription() { return description; } public abstract int cost(); } abstract class CondimentDecorator extends Beverage { // トッピング Beverage beverage; } class Espresso extends Beverage { // エスプレッソ private final int ESPRESSO_PRICE = 25; public Espresso() { description = \u0026#34;Espresso\u0026#34;; } public int cost() { return ESPRESSO_PRICE; } } class DarkRoast extends Beverage { // ダークローストコーヒー private final int DARKROAST_PRICE = 20; public DarkRoast() { description = \u0026#34;DarkRoast\u0026#34;; } public int cost() { rcturn DARKROAST PRICE; } } class Mocha extends CondimentDecorator { // モカ private final int MOCHA_PRICE = 10; public Mocha (Beverage beverage) { this.beverage = beverage; } public String getDescription() { return beverage.getDescription() + \u0026#34;, Mocha\u0026#34;; } public int cost() { return MOCHA_PRICE + beverage.cost(); } } class Whip extends CondimentDecorator { // ホイップ private final int WHIP_PRICE = 8; public Whip (Beverage beverage) { this.beverage = beverage; } public String getDescription() { return beverage.getDescription() + \u0026#34;, Whip\u0026#34;; } public int cost() { return WHIP_PRICE + beverage.cost(); } } public class Coffee { public static void main(String args[]) { Beverage beverage = new DarkRoast(); beverage = new Mocha(beverage); beverage = new Whip(beverage); System.out.println(beverage.getDescription() +\u0026#34; ￥\u0026#34;+ beverage.cost()); } } 例2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 public class DecoratorPattern { public static void main(String[] args) { Person p = new Student(\u0026#34;Mike\u0026#34;); p.Operation(); System.out.println(\u0026#34;\\n--------------------\u0026#34;); p = new DecoratorA(p); p.Operation(); System.out.println(\u0026#34;\\n--------------------\u0026#34;); p = new DecoratorB(p); p.Operation(); // No.2 Person p2 = new DecoratorB(new Student(\u0026#34;Jane\u0026#34;)); } } abstract class Person{ protected String name; public abstract void Operation(); } class Student extends Person{ public Student(String name){ this.name = name; } @Override public void Operation(){ System.out.print(name + \u0026#34; Study\u0026#34;); } } abstract class Decorator extends Person{ protected Person person; } class DecoratorA extends Decorator{ public DecoratorA(Person person){ this.person = person; } @Override public void Operation() { person.Operation(); System.out.print(\u0026#34; Play\u0026#34;); } } class DecoratorB extends Decorator{ public DecoratorB(Person person){ this.person = person; } @Override public void Operation() { person.Operation(); System.out.print(\u0026#34; Exam\u0026#34;); } } ","date":"2023-09-05T21:45:45+08:00","permalink":"https://blog.yexca.net/ja/archives/120/","title":"デコレーターパターン"},{"content":" 📢 この記事は gemini-2.5-flash によって翻訳されました コンポジットパターン オブジェクト構造パターン\n意図 オブジェクトをツリー構造に組み合わせて「部分 - 全体」の階層を表現するんだ。コンポジットパターンを使うと、単一のオブジェクトと複合オブジェクトを同じように扱えるようになるよ。\n構造 ここで、\nComponent：複合構造内のオブジェクトのインターフェースを宣言するんだ。適切な場合には、すべてのクラスで共通のインターフェースのデフォルトの振る舞いを実装するよ。Componentの子コンポーネントにアクセスして管理するためのインターフェースも宣言するね。オプションだけど、再帰的な構造で親コンポーネントにアクセスするためのインターフェースを定義して、適切な場合にそれを実装することもできるよ。 Leaf：複合構造の葉ノードオブジェクトを表すよ。葉ノードには子ノードがないんだ。複合構造でプリミティブオブジェクトの振る舞いを定義するね。 Composite：すべての子コンポーネントを持つコンポーネントの振る舞いを定義するよ。子コンポーネントを格納して、Componentインターフェースで子コンポーネントに関する操作を実装するんだ。 Client：Componentインターフェースを通じて複合コンポーネントのオブジェクトを操作するよ。 適用性 コンポジットパターンは、こんな時に役立つよ：\nオブジェクトの部分 - 全体階層を表現したい時。 ユーザーが複合オブジェクトと単一オブジェクトの違いを意識せず、複合構造内のすべてのオブジェクトを一様に扱ってほしい時。 例子 1 ある会社の組織図が下の図のようになっているとするね。\nここで、コンポジット（Composition）デザインパターンを使ってこの会社の組織構造を構築すると、下の図のようなクラス図になるよ。\nCompanyは抽象クラスで、組織図に支社/事業所または部署を追加（Add）したり削除（Delete）したりするメソッドインターフェースを定義しているんだ。ConcreteCompanyクラスは具体的な支社や事業所を表していて、支社や事業所の配下には異なる部署を設置できるよ。HRDepartmentクラスとFinanceDepartmentクラスはそれぞれ人事部と財務部を表しているね。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 import java.util.*; abstract class Company { protected String name; public Company(String name) { this.name = name; } public abstract void Add(Company c); // 子会社、事業所、または部署を追加する public abstract void Delete(Company c); // 子会社、事業所、または部署を削除する } class ConcreteCompany extends Company { private List\u0026lt;Company\u0026gt; children = new ArrayList\u0026lt;Company\u0026gt;(); // 子会社、事業所、または部署を格納する public ConcreteCompany(String name) { super(name); } public void Add(Company c) {children.add(c); } public void Delete(Company c) {children.remove(c); } } class HRDepartment extends Company { public HRDepartment(String name) { super(name); } // その他のコードは省略 } class FinanceDepartment extends Company { public FinanceDepartment(String name) { super(name); } // その他のコードは省略 } public class Test { public static void main(String[] args) { ConcreteCompany root = new ConcreteCompany(\u0026#34;北京総公司\u0026#34;); root.Add(new HRDepartment(\u0026#34;総公司人力資源部\u0026#34;)); root.Add(new FinanceDepartment(\u0026#34;総公司財務部\u0026#34;)); ConcreteCompany comp = new ConcreteCompany(\u0026#34;上海分公司\u0026#34;); comp.Add(new HRDepartment(\u0026#34;上海分公司人力資源部\u0026#34;)); comp.Add(new FinanceDepartment(\u0026#34;上海分公司財務部\u0026#34;)); root.Add(comp); ConcreteCompany comp1 = new ConcreteCompany(\u0026#34;南京办事处\u0026#34;); comp1.Add(new HRDepartment(\u0026#34;南京办事处人力資源部\u0026#34;)); comp1.Add(new FinanceDepartment(\u0026#34;南京办事处財務部\u0026#34;)); comp.Add(comp1); // その他のコードは省略 } } 例子 2 カスケードメニューは、ウィンドウ形式のソフトウェアシステムでよく使われるシステム機能の整理方法だよね。カスケードメニューには、メニュー項目（特定の機能に直接対応するもの）が含まれることもあれば、サブメニューが含まれることもあるんだ。ここで、コンポジット（composite）デザインパターンを使ってカスケードメニューを実装すると、下の図のようなクラス図になるよ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 import java.util.*; abstract class MenuComponent { // カスケードメニューを構成する要素 protected String name; // メニュー項目またはサブメニュー名 public void printName() { System.out.println(name); } public abstract boolean addMenuElement(MenuComponent element) ; public abstract boolean removeMenuElement(MenuComponent element); public abstract List\u0026lt;MenuComponent\u0026gt; getElement(); } class MenuItem extends MenuComponent { public MenuItem(String name) { this.name=name; } public boolean addMenuElement(MenuComponent element) { return false; } public boolean removeMenuElement(MenuComponent element) { return false; } public List\u0026lt;MenuComponent\u0026gt; getElement(){ return null; } } class Menu extends MemuComponent { private List\u0026lt;MenuComponent\u0026gt; elementsList; public Menu(String name) { this.name = name; this.elementList = new ArrayList\u0026lt;MenuComponent\u0026gt;; } public boolean addMenuElement(MenuComponent element) { return elementList.add(element); } public boolean removeMenuElement(MenuComponent element) { return elementList.remove(element); } public List\u0026lt;MenuComponent\u0026gt; getElement() { return elementList; } } class CompositeTest { public static void main(String[] args) { MenuComponent mainMenu = new Menu(\u0026#34;Insert\u0026#34;); MenuComponent subMenu = new Menu(\u0026#34;Chart\u0026#34;); MenuComponent element = new MenuItem(\u0026#34;On This Sheet\u0026#34;); mainMenu.addMenuElement(subMenu); subMenu.addMenuElement(element); printMenus(mainMenu); } private static void printMenus(MenuComponent ifile) { ifile.printName(); List\u0026lt;MenuComponent\u0026gt; children = ifile.getElement(); if (children == null) return; for(MenuComponent element; children) { printMenus(element); } } } 例子 3 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 import java.util.*; public class CompositePattern { public static void main(String[] args) { AbstractFile root = new Folder(\u0026#34;root\u0026#34;); AbstractFile bin = new Folder(\u0026#34;bin\u0026#34;); AbstractFile tmp = new Folder(\u0026#34;tmp\u0026#34;); AbstractFile file = new File(\u0026#34;file\u0026#34;); root.Add(bin); bin.Add(tmp); root.Add(file); // root.Remove(tmp); print(root); } static void print(AbstractFile file){ List\u0026lt;AbstractFile\u0026gt; lf = file.GetChildren(); file.Operation(); // より簡潔な方法 // if(lf == null) return; // for(AbstractFile i : lf) print(i); if (lf != null) { for (AbstractFile i : lf) { if (i != null) { print(i); } else return; } } else return; } } abstract class AbstractFile{ protected String name; public void Operation(){ System.out.println(name); } public abstract boolean Add(AbstractFile af); public abstract boolean Remove(AbstractFile af); public abstract List\u0026lt;AbstractFile\u0026gt; GetChildren(); } class Folder extends AbstractFile{ private List\u0026lt;AbstractFile\u0026gt; childrenList = new ArrayList\u0026lt;\u0026gt;(); public Folder(String name){ this.name = name; } @Override public boolean Add(AbstractFile af){ return childrenList.add(af); } @Override public boolean Remove(AbstractFile af){ return childrenList.remove(af); } @Override public List\u0026lt;AbstractFile\u0026gt; GetChildren(){ return this.childrenList; } } class File extends AbstractFile{ public File(String name){ this.name = name; } @Override public boolean Add(AbstractFile af){ System.out.println(\u0026#34;Forbidden\u0026#34;); return false; } @Override public boolean Remove(AbstractFile af){ System.out.println(\u0026#34;Forbidden\u0026#34;); return false; } @Override public List\u0026lt;AbstractFile\u0026gt; GetChildren(){ return null; } } ","date":"2023-09-03T15:44:45+08:00","permalink":"https://blog.yexca.net/ja/archives/119/","title":"コンポジットパターン"},{"content":" 📢 この記事は gemini-2.5-flash によって翻訳されました Bridgeパターン オブジェクト構造パターン\n意図 抽象部分とその実装部分を分離して、それぞれが独立して変化できるようにするんだ。\n構造 構成要素はこれだ：\nAbstractionは抽象クラスのインターフェースを定義して、Implementor型のオブジェクトへのポインタを保持するんだ。 RefinedAbstractionはAbstractionが定義したインターフェースを拡張する役割だよ。 Implementorは実装クラスのインターフェースを定義するんだけど、これはAbstractionのインターフェースと完全に一致する必要はないんだ。実際、この2つのインターフェースは全く異なっていても大丈夫。一般的に、Implementorのインターフェースは基本的な操作だけを提供するけど、Abstractionはそれらの基本操作を基にした、より高レベルな操作を定義するって感じだね。 ConcreteImplementorはImplementorインターフェースを実装して、その具体的な実装を定義するんだ。 適用できる場面 Bridgeパターンはこんな時に便利だよ：\n抽象とその実装部分の間に固定的な結びつきを持たせたくない時。例えば、プログラムの実行時に実装部分を選択したり、切り替えたりしたい場合なんかがあるね。 クラスの抽象部分と実装部分の両方を、サブクラスを生成することで拡張できるようにしたい時。Bridgeパターンを使うと、開発者は異なる抽象インターフェースと実装部分を組み合わせて、それぞれを個別に拡張できるようになるんだ。 抽象部分の実装を変更しても、クライアントに影響を与えたくない時、つまりクライアントのコードを再コンパイルする必要がないようにしたい時だね。 (C++の場合) 抽象部分の実装をクライアントから完全に隠したい時。 多くのクラスを生成する必要があるクラス階層がある時。 複数のオブジェクト間で実装を共有したい時（参照カウントを使うこともありえるね）、でもクライアントにはその事実を知られたくない時。 例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 public class main { public static void main(String[] args) { Product ProductA1 = new ProductA(); Product ProductA2 = new ProductA(); Color red = new Red(); ProductA1.setName(\u0026#34;P-A1\u0026#34;); ProductA1.setColor(red); ProductA1.Operation; Color blue = new Blue(); ProductA1.setName(\u0026#34;P-A2\u0026#34;); ProductA1.setColor(blue); ProductA1.Operation; } } abstract class Product{ private String name; protected Color color; public void setName(String name){ this.name = name; } public String getName(){ return this.name; } public setColor(Color color){ this.color = color; } public abstract void Operation(); } class ProductA extends Product{ @Override public void Operation(){ color.OperationImp(this.getName()); } } class Color{ public void OperationImp(String name); } class Red extends Color{ @Override public void OperationImp(String name){ System.out.println(name + \u0026#34;: red\u0026#34;) } } class Blue extends Color{ @Override public void OperationImp(String name){ System.out.println(name + \u0026#34;: blue\u0026#34;) } } ","date":"2023-09-02T17:34:34+08:00","permalink":"https://blog.yexca.net/ja/archives/118/","title":"ブリッジパターン"},{"content":" 📢 この記事は gemini-2.5-flash によって翻訳されました Adapter Pattern クラス構造パターン/オブジェクト構造パターン\n目的 あるクラスのインターフェースを、クライアントが望む別のインターフェースに変換するんだ。アダプターパターンを使うと、インターフェースが合わなくて一緒に動かせなかったクラス同士も一緒に使えるようになるんだ。\n構造 クラスアダプターは多重継承を使って、あるインターフェースを別のインターフェースに合わせるよ。 オブジェクトアダプターはオブジェクトの合成に依存してるんだ。 内訳はこれだね：\nTargetは、Clientが使う特定分野に関するインターフェースを定義するよ。 Clientは、Targetインターフェースに準拠するオブジェクトと一緒に動くんだ。 Adapteeは、すでに存在するインターフェースを定義するんだけど、これがアダプト（適応）される必要があるんだ。 Adapterは、AdapteeのインターフェースとTargetインターフェースを適応させるんだ。 適用性 アダプターパターンは、こんな時に役立つよ：\n既存のクラスを使いたいけど、そのインターフェースが要件に合わない場合。 再利用可能なクラスを作りたいんだけど、それが他の無関係なクラスや予期しないクラス（つまり、インターフェースが互換性がないかもしれないクラス）と一緒に動く必要がある場合。 （オブジェクトアダプターにのみ適用）既存のサブクラスを使いたいけど、それぞれのインターフェースに合わせるためにすべてをサブクラス化するのは無理な場合。オブジェクトアダプターなら、その親クラスのインターフェースを適応させられるんだ。 例 1 あるソフトウェアシステムで、住所情報を表示するためのAddressクラスがすでに設計・実装されてるんだけど、今度はオランダ語ベースの住所情報表示インターフェースが必要になったんだ。この要求を満たすため、そして将来的に新しい言語インターフェースが出てくる可能性も考慮して、アダプターパターンを使ってこの要求を実装することにしたよ。クラス図はこれね。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 public class Adapter { public static void main(String[] args) { Address address = new Address(); DutchAddress dutchAddress = new DutchAddressAdapter(address); System.out.println(\u0026#34;The DutchAddress\u0026#34;); test(dutchAddress); } static void test(DutchAddress dutchAddress){ dutchAddress.plaats(); dutchAddress.postcode(); dutchAddress.straat(); } } class Address{ public void street(){/* code omission */} public void zip(){/* code omission */} public void city(){/* code omission */} } class DutchAddress{ public void straat(){/* code omission */} public void postcode(){/* code omission */} public void plaats(){/* code omission */} } class DutchAddressAdapter extends DutchAddress{ private Address address; public DutchAddressAdapter(Address address){ this.address=address; } @Override public void straat() { address.street(); } @Override public void postcode() { address.zip(); } @Override public void plaats() { address.city(); } } 例 2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // Javaは多重継承をサポートしてないから、以下はオブジェクトアダプターだよ public class main{ public static void main(String[] args) { Target target = new Adapter(); target.Request(); } } class Target{ public void Request(){ System.out.println(\u0026#34;hello\u0026#34;); } } class Adapter extends Target{ private Adaptee a = new Adaptee(); @Override public void Request(){ a.SpecificRequest(); } } class Adaptee{ public void SpecificRequest(){ System.out.println(\u0026#34;hi\u0026#34;); } } ","date":"2023-09-01T15:03:03+08:00","permalink":"https://blog.yexca.net/ja/archives/117/","title":"アダプターパターン"},{"content":" 📢 この記事は ChatGPT によって翻訳されました 前にサーバー持ってたときも同じことを考えたことあったけど、\nそのときは「どうせ別サイト立てればいいじゃん」で済んだのでちゃんと調べなかった。\nでも今はブログを GitHub に移しちゃったし、\n今までみたいにサブパスへ直接リダイレクトするのはできない。\nだから改めて解決策を探すことにした。\n失敗の記録 失敗したけど、ちゃんと記録しとく。きっと使い方を間違えただけ\n昔ちょっとだけ試したときは DNS の CNAME に設定しただけで当然動かなくて放置してた。\n今回「ドメイン パス URL にリダイレクト」とかで検索してみたら、\n最初に出てきた https://cloud.tencent.com/developer/ask/sof/89340 に\n紹介されてたサービス： http://redirect.center/ を発見。\n例 https://acg.yexca.net → https://blog.yexca.net/acg にリダイレクトさせたい場合\n結果：アクセス不可\n説明通りに設定するなら、CNAME の内容は\nblog.yexca.net.opts-slash.acg.opts-https.redirect.center. にするべきらしい。\nでも実際には全然うまくいかなくて、エラーが出るだけ。\n他にもいろいろ試してみたけど全部エラー。\n諦めて他を探すことにした。\n補足：サイトの最後には自動生成機能もあるっぽい\n新しいツール 今度は「redirect center」で検索して、3番目に出てきた\nhttps://redirect.name/ というサービスを試してみた。\nこれが前のよりずっと使いやすくて、ちゃんと動いた！\n新しい例 https://twinkle.yexca.net を https://yexca.github.io/MusicPlayer-Twinkle/ にリダイレクトする。\n結果：アクセス可能！\n必要な DNS レコードは2つ：\n種類 名前 内容 CNAME twinkle alias.redirect.name TXT _redirect.acg Redirects to https://yexca.github.io/MusicPlayer-Twinkle/ コード形式で書くとこんな感じ：\n1 2 acg IN CNAME alias.redirect.name _redirect.acg IN TXT \u0026#34;https://blog.yexca.net/acg\u0026#34; ","date":"2023-08-28T15:31:01+08:00","permalink":"https://blog.yexca.net/ja/archives/116/","title":"CNAME でドメインをパス付き URL にリダイレクトする方法"},{"content":" 📢 この記事は gemini-2.5-flash によって翻訳されました シングルトンパターン オブジェクト生成パターン\n目的 あるクラスがただ一つのインスタンスしか持たないことを保証し、それにアクセスするためのグローバルなアクセスポイントを提供するんだ。\n構造 この中でね：\nSingletonはInstance操作を指定して、クライアントがその唯一のインスタンスにアクセスできるようにするよ。 Instanceはクラス操作なんだ。多分、それ自身の唯一のインスタンスを作成する責任があるんだろうね。 適用性 シングルトンパターンは、こんな時に使えるよ：\nクラスがただ一つのインスタンスしか持てなくて、しかもクライアントがよく知られたアクセスポイントからそれにアクセスできる時。 この唯一のインスタンスがサブクラス化によって拡張可能であるべきで、しかもクライアントがコードを変更せずに拡張されたインスタンスを使える時。 例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public class main{ // s1 と s2 は同じインスタンスだよ（アドレスが同じ）。 Singleton s1 = Singleton.getInstance(); Singleton s2 = Singleton.getInstance(); } class Singleton{ private int num = 2023; public void setNum(int num){ this.num = num; } public int getNum(){ return this.num; } private Singleton(){} private static Singleton instance = new Singleton(); public static Singleton getInstance(){ return instance; } } ","date":"2023-07-05T13:58:25+08:00","permalink":"https://blog.yexca.net/ja/archives/115/","title":"シングルトンパターン"},{"content":" 📢 この記事は gemini-3-flash-preview によって翻訳されました 最近ミリシタを遊んでる時に繋がらなくて、解決方法を探してみたよ。(ついでに Spotify の埋め込み効果も試してみよう。このテーマ、H5を直接解析できないみたいだけど、直すのめんどくさいからもういいや)\nドメイン 1 theaterdays.appspot.com ここには元々 雨宿り の Spotify の曲が埋め込まれてたんだ\n最近雨宿りの曲が大好きで、よく聴いてるんだ。Last.fm で過去30日間の再生回数を確認したら、雨宿りの「猫かぶり」が一番人気のトラックになってた。で、トップアーティストじゃないかって？トップアーティストは、もちろん湊あくあ！　草、ミリシタの記事で何書いてるんだろ、どっちもミリシタと関係ないじゃん！\nclash グループ設定を作ることで、より選びやすくなるよ。\nまずは JP グループを設定する。\n1 2 3 4 5 6 proxy-groups: - name: JP type: select proxies: - your jp proxy name - your jp proxy name それからルールを追加する。\n1 2 rules: - DOMAIN-SUFFIX,theaterdays.appspot.com,JP ","date":"2023-06-09T23:32:09+08:00","permalink":"https://blog.yexca.net/ja/archives/114/","title":"アイドルマスター ミリオンライブ！の IP ルール"},{"content":" 📢 この記事は gemini-3-flash-preview によって翻訳されました プロトタイプパターン (Prototype Pattern) - オブジェクト生成に関するパターン\n意図 原型のインスタンスを使って生成するオブジェクトの種類を特定して、その原型をコピーすることで新しいオブジェクトを作るんだ。\n構造 役割：\nPrototype：自分自身をコピーするためのインターフェースを宣言するよ。 ConcretePrototype：自分自身をコピーする処理を実装するんだ。 Client：原型に自分自身をコピーさせて、新しいオブジェクトを作るよ。 使いどころ Prototype パターンは以下のような場合に適しているよ：\nシステムが製品の生成・構成・表現方法に依存しないようにしたいとき。 インスタンス化するクラスが実行時に指定されるとき（例えば、動的読み込みなど）。 製品のクラス階層と並行した工場クラスの階層を作るのを避けたいとき。 クラスのインスタンスが、いくつかの異なる状態の組み合わせのうちの一つにしかならないとき。あらかじめいくつかの原型を用意してクローンするほうが、毎回手動で適切な状態のインスタンスを作るよりも便利な場合があるんだ。 例 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 public class main{ Product p1 = new Product(2023, 3.03); System.out.println(p1.getId() + \u0026#34; \u0026#34; + p1.getPrice()); // Product p2 = new Product(2023, 3.03); Product p2 = (Product) p1.Clone(); System.out.println(p2.getId() + \u0026#34; \u0026#34; + p2.getPrice()); } interface Prototype{ public Object Clone(); } class Product implements Prototype{ private int id; private double price; public Product(){} public Product(int id, double price){ this.id = id; this.price = price; } public int getId(){ return this.id; } public double getPrice(){ return this.price; } public void setId(int id){ this.id = id; } public void setPrice(double price){ this.price = price; } @Override public Object Clone(){ Product object = new Product(); object.id = this.id; object.price = this.price; return object; } } 例 2 (公式インターフェースを使う場合) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 public class main{ Product p1 = new Product(2023, 3.03); System.out.println(p1.getId() + \u0026#34; \u0026#34; + p1.getPrice()); // Product p2 = new Product(2023, 3.03); Product p2 = (Product) p1.clone(); System.out.println(p2.getId() + \u0026#34; \u0026#34; + p2.getPrice()); } // 削除 // interface Prototype{ // public Object Clone(); // } // インターフェースを実装 class Product implements Cloneable{ private int id; private double price; public Product(){} public Product(int id, double price){ this.id = id; this.price = price; } public int getId(){ return this.id; } public double getPrice(){ return this.price; } public void setId(int id){ this.id = id; } public void setPrice(double price){ this.price = price; } // メソッドをオーバーライド @Override public Object clone(){ return super.clone(); } } ","date":"2023-06-02T19:31:44+08:00","permalink":"https://blog.yexca.net/ja/archives/113/","title":"プロトタイプパターン"},{"content":" 📢 この記事は gemini-3-flash-preview によって翻訳されました Builder Pattern (生成器パターン) - オブジェクト生成に関するパターン\n意図 複雑なオブジェクトの構築とその表現を分離して、同じ構築プロセスで異なる表現を作成できるようにすることだよ。\n構造 役割分担はこんな感じ：\nBuilder: Product オブジェクトの各パーツを作成するための抽象インターフェースを指定するよ。 ConcreteBuilder: Builder のインターフェースを実装して、製品のパーツを構築・組み立てる。作成する表現を定義して、製品を取得するためのインターフェースも提供するんだ。 Director: Builder インターフェースを使うオブジェクトを構築するよ。 Product: 構築される複雑なオブジェクトのこと。ConcreteBuilder がこの製品の内部表現を作成して、組み立てプロセスを定義する。コンポーネントを定義するクラスや、それらを最終的な製品に組み立てるためのインターフェースが含まれるよ。 適用場面 Builder パターンは、次のような場合にぴったりだよ：\n複雑なオブジェクトを作成するアルゴリズムが、そのオブジェクトの構成部品やそれらの組み立て方法から独立している必要があるとき。 構築プロセスの中で、構築されるオブジェクトに異なる表現（バリエーション）が必要なとき。 例 1 あるファストフード店でキッズセットを作って販売しているとするね。セットには通常、メイン（各種ピザ）、飲み物、おもちゃが含まれている。メニューによって中身は違うけど、作る工程は同じなんだ。フロアの店員（Waiter）がシェフに指示を出してセットを作らせる。これを生成器パターンで実装してみよう。クラス図は以下の通り：\nJava 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class Pizza { private String parts; public void setParts(String parts) { this.parts = parts; } public String toString() { return this.parts; } } abstract class PizzaBuilder { protected Pizza pizza; public Pizza getPizza() { return pizza; } public void createNewPizza() { pizza = new Pizza(); } public abstract void buildParts(); } class HawaiianPizzaBuilder extends PizzaBuilder { public void buildParts(){ pizza.setParts(\u0026#34;生地 + マイルド + ハム＆パイナップル\u0026#34;); } } class SpicyPizzaBuilder extends PizzaBuilder { public void buildParts() { pizza.setParts(\u0026#34;パンピザ + ホット + ペパロニ＆サラミ\u0026#34;); } } class Waiter { private PizzaBuilder pizzaBuilder; public void setPizzaBuilder(PizzaBuilder pizzaBuilder) {/* ビルダーを設定 */ this.pizzaBuilder = pizzaBuilder; } public Pizza getPizza() { return pizzaBuilder.getPizza(); } public void construct() { /* 構築 */ pizzaBuilder.createNewPizza(); pizzaBuilder.buildParts(); } } class FastFoodOrdering { public static void main(String[] args) { Waiter waiter = new Waiter(); PizzaBuilder hawaiian_pizzabuilder = new HawaiianPizzaBuilder(); waiter.setPizzaBuilder(hawaiian_pizzabuilder); waiter.construct(); System.out.println(\u0026#34;ピザ：\u0026#34; + waiter.getPizza()); // 出力：ピザ：生地 + マイルド + ハム＆パイナップル } } C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; class Pizza { private: string parts; public: void setParts(string parts) { this-\u0026gt;parts = parts; } string getParts() { return parts; } }; class PizzaBuilder { protected: Pizza *pizza; public: Pizza *getPizza() { return pizza; } void createNewPizza() { pizza = new Pizza(); } virtual void buildParts() = 0; }; class HawaiianPizzaBuilder : public PizzaBuilder { public: void buildParts() { pizza-\u0026gt;setParts(\u0026#34;生地 + マイルド + ハム＆パイナップル\u0026#34;); } }; class SpicyPizzaBuilder : public PizzaBuilder { public: void buildParts() { pizza-\u0026gt;setParts(\u0026#34;パンピザ + ホット + ペパロニ＆サラミ\u0026#34;); } }; class Waiter { private: PizzaBuilder *pizzaBuilder; public: void setPizzaBuilder(PizzaBuilder *pizzaBuilder) { /* ビルダーを設定 */ this-\u0026gt;pizzaBuilder = pizzaBuilder; } Pizza *getPizza() { return pizzaBuilder-\u0026gt;getPizza(); } void construct() { pizzaBuilder-\u0026gt;createNewPizza(); pizzaBuilder-\u0026gt;buildParts(); } }; int main() { Waiter *waiter = new Waiter(); PizzaBuilder *hawaiian_pizzabuilder = new HawaiianPizzaBuilder(); waiter-\u0026gt;setPizzaBuilder(hawaiian_pizzabuilder); waiter-\u0026gt;construct(); cout \u0026lt;\u0026lt; \u0026#34;ピザ: \u0026#34; \u0026lt;\u0026lt; waiter-\u0026gt;getPizza()-\u0026gt;getParts() \u0026lt;\u0026lt; endl; } // プログラムの出力結果： // ピザ：生地 + マイルド + ハム＆パイナップル 例 2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 import java.util.*; public class Main{ public static void main(String[] args) { Director d = new Director(); Builder b1 = new Builder1(); d.Construct(b1); Product p1 = b1.getResult(); p1.show(); } } class Product{ List\u0026lt;String\u0026gt; parts = new ArrayList\u0026lt;String\u0026gt;(); public void Add(String part){ parts.add(part); } public void show(){ System.out.println(\u0026#34;製品の情報:\u0026#34;); for(String s : parts) System.out.print(s + \u0026#34; \u0026#34;); System.out.println(); } } abstract class Builder{ public abstract void BuildPart(); public abstract Product getResult(); } class Builder1 extends Builder{ Product p = new Product(); @Override public void BuildPart(){ p.Add(\u0026#34;A1\u0026#34;); p.Add(\u0026#34;A2\u0026#34;); p.Add(\u0026#34;C\u0026#34;); } @Override public Product getResult(){ return p; } } class Builder2 extends Builder{ Product p = new Product(); @Override public void BuildPart(){ p.Add(\u0026#34;B1\u0026#34;); p.Add(\u0026#34;B2\u0026#34;); p.Add(\u0026#34;C\u0026#34;); } @Override public Product getResult(){ return p; } } class Director{ public void Construct(Builder builder){ builder.BuildPart(); } } ","date":"2023-06-01T23:33:17+08:00","permalink":"https://blog.yexca.net/ja/archives/112/","title":"生成器パターン (Builder Pattern)"},{"content":" 📢 この記事は gemini-3-flash-preview によって翻訳されました Simple Factory（単純工場）パターン Simple Factoryパターンは生成に関するパターンに分類されるけど、GoFの23種類のデザインパターンには含まれないんだ。\n定義：パラメータに応じて異なるクラスのインスタンスを返すことができる工場クラスを定義する。作成されるインスタンスは通常、共通の親クラスを持っているよ。\nSimple Factoryパターンでインスタンスを作成するために使われるメソッドは通常、静的（static）メソッドなんだ。だから、Simple Factoryパターンは「Static Factory Method（静的工場メソッド）パターン」とも呼ばれているよ。\n必要な製品に対応するパラメータを渡すだけで、その実装過程を知らなくても、必要な製品オブジェクトを手に入れることができるんだ。\n例えば、ある餃子屋さんがあるとする。お客さんが特定の餃子を注文すると、店はその餃子を作ってお客さんに提供するよね。ここでは、餃子屋さんを「工場 (Factory)」、餃子を「製品 (Product)」、餃子の名前を「パラメータ」と見なすことができる。餃子屋さんはパラメータに応じて、異なる餃子を返してくれるってわけ。\n例えば、お客さんが「ニラ餃子」を欲しがったら、「ニラ」がパラメータになる。餃子屋さんはそのパラメータに基づいて、ニラ餃子を返すんだ（店にニラ餃子のメニューがあることが前提だけどね）。\n3つの役割：\n工場（核心） すべての製品を作成するための内部ロジックの実装を担当する。工場クラスは外部から直接呼び出され、必要なオブジェクトを作成するよ。\n抽象製品 工場クラスが作成するすべてのオブジェクトの親クラス。製品オブジェクトの共通メソッドをカプセル化していて、具体的な製品はすべてその子クラスになるんだ。\n具体的な製品 Simple Factoryパターンが作成する目標。作成されるオブジェクトはすべて、ある具体的なクラスのインスタンスだよ。\n例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 public class SimpleFactory{ public static void main(String[] args){ Product productA = Factory.createProduct(\u0026#34;A\u0026#34;); productA.info(); // ... } } abstract class Product{ public abstract void info(); } class ProductA extends Product{ @Override public void info(){ System.out.println(\u0026#34;A\u0026#34;); } } class ProductB extends Product{ @Override public void info(){ System.out.println(\u0026#34;B\u0026#34;); } } class Factory{ public static Product creatProduct(String type){ Product p = null; // ここでは例外処理などは考慮していないよ switch(type){ case \u0026#34;A\u0026#34;: p = new ProductA(); break; case \u0026#34;B\u0026#34;: p = new ProductB(); break; default: System.out.println(\u0026#34;Please try again\u0026#34;); break; } return p; } } 製品を追加したい時、工場クラスを書き換える必要があるから、これは 開放・閉鎖の原則 (Open-Closed Principle) に違反しちゃうんだよね。\nFactory Method（工場方法）パターン Factory Method Pattern。クラス生成に関するパターンだよ。\n意図 オブジェクトを作成するためのインターフェースを定義し、どのクラスをインスタンス化するかは子クラスに決定させる。Factory Methodは、クラスのインスタンス化をその子クラスに遅延させるんだ。\n構造 役割の説明：\nProduct：工場メソッドが作成するオブジェクトのインターフェースを定義する。 ConcreteProduct：Productインターフェースを実装する。 Creator：工場メソッドを宣言する。このメソッドはProduct型のオブジェクトを返す。Creatorは工場メソッドのデフォルト実装を定義することもできて、それはデフォルトのConcreteProductオブジェクトを返す。工場メソッドを呼び出してProductオブジェクトを作成できるよ。 ConcreteCreator：工場メソッドを再定義して、ConcreteProductのインスタンスを返す。 適用場面 Factory Methodパターンは次のような場合に適しているよ：\nクラスが、自分が作成しなければならないオブジェクトのクラスを事前には知らないとき。 クラスが、作成するオブジェクトの指定を子クラスに委ねたいとき。 クラスが、オブジェクト作成の責任を複数の補助子クラスのいずれかに委任していて、どの補助子クラスが代理人であるかという情報を局所化（隠蔽）したいとき。 例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 // 前のコードをベースに修正 public class FactoryMethod{ public static void main(String[] args){ Factory factoryA = new FactoryA(); //Product productA = Factory.createProduct(\u0026#34;A\u0026#34;); Product productA = factoryA.createProduct(); productA.info(); // ... } } // 抽象クラスをインターフェースに変更 // abstract class Product interface Product{ // public abstract void info(); public void info(); } // 継承を実装に変更 // class ProductA extends Product{ class ProductA implements Product{ @Override public void info(){ System.out.println(\u0026#34;A\u0026#34;); } } // 継承を実装に変更 // class ProductB extends Product{ class ProductB implements Product{ @Override public void info(){ System.out.println(\u0026#34;B\u0026#34;); } } // 実装クラスをインターフェースに変更 // class Factory interface Factory{ public Product createProduct(); } // インターフェースの実装を追加 class FactoryA implements Factory{ @Override public Product createProduct(){ return new ProductA(); } } class FactoryB implements Factory{ @Override public Product createProduct(){ return new ProductB(); } } Abstract Factory（抽象工場）パターン Abstract Factory Pattern。オブジェクト生成に関するパターンだよ。\n意図 具体的なクラスを指定することなく、関連し合う一連のオブジェクト、または依存し合う一連のオブジェクトを作成するためのインターフェースを提供するんだ。\n構造 役割の説明：\nAbstractFactory：抽象製品オブジェクトを作成する操作のインターフェースを宣言する。 ConcreteFactory：具体的な製品オブジェクトを作成する操作を実装する。 AbstractProduct：ある種類の製品オブジェクトのインターフェースを宣言する。 ConcreteProduct：対応する具体的な工場によって作成される製品オブジェクトを定義し、AbstractProductインターフェースを実装する。 Client：AbstractFactoryとAbstractProductクラスで宣言されたインターフェースのみを使用する。 適用場面 Abstract Factoryパターンは次のような場合に適しているよ：\nシステムが、製品の作成、構成、表現方法から独立している必要があるとき。 システムを、複数の製品ファミリーのうちの1つで構成する必要があるとき。 関連する一連の製品オブジェクトをまとめて使用するように設計し、その制約を強調したいとき。 製品のクラスライブラリを提供し、その実装ではなくインターフェースだけを公開したいとき。 例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 public class AbstractFactory{ public static void main(String[] args){ Factory factory1 = new Factory1(); ProductA productA = factory1.createProductA(); productA.info(); // ... } } interface ProductA{ public void info(); } class ProductA1 implements ProductA{ @Override public void info(){ System.out.println(\u0026#34;A1\u0026#34;); } } class ProductA2 implements ProductA{ @Override public void info(){ System.out.println(\u0026#34;A2\u0026#34;); } } interface ProductB{ public void info(); } class ProductB1 implements ProductB{ @Override public void info(){ System.out.println(\u0026#34;B1\u0026#34;); } } class ProductB2 implements ProductB{ @Override public void info(){ System.out.println(\u0026#34;B2\u0026#34;); } } interface Factory{ public ProductA createProductA(); public ProductB createProductB(); } class Factory1 implements Factory{ @Override public ProductA createProductA(){ return new ProductA1(); } @Override public ProductB createProductB(){ return new ProductB1(); } } class Factory2 implements Factory{ @Override public ProductA createProductA(){ return new ProductA2(); } @Override public ProductB createProductB(){ return new ProductB2(); } } ","date":"2023-05-28T10:23:46+08:00","permalink":"https://blog.yexca.net/ja/archives/111/","title":"工場パターン"},{"content":" この記事は Google 翻訳を使用して処理されました\n問題の説明 ある会社が長い鉄棒を購入し、それを切断して販売します。鉄筋を切断するコストはごくわずかで、鉄筋の長さはインチです。価格表 $p$ が与えられます。ここで、 $p_{i}(i=1,2,\\cdots,m)$ は長さ $i$ インチの鉄棒の価格を表します。今、売上収益を最大化するカット計画を見つける必要があります。\n問題分析 長い鋼棒の長さが $n$ インチで、最適な切断計画の左端の切断セグメントの長さが $i$ インチであると仮定して、残りの鋼棒の長さに対する最適な切断計画を解き続けます。 $m-1$ インチ。すべての可能な $i$ を考慮すると、最大の利益 $r_{n}$ に対応する伐採計画が最適な伐採計画となります。 $r_{n}$ の再帰定義は次のようになる。\n$$ r_{n}=max_{1\\le i \\le n}(p_{i}+r_{n-i}) $$C コード この問題には2つの解決策があります\n(1) 分割統治法（上から下まで） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int Top_Down_Cut_Rod(int p[], int n){ int r=0; // 最大値 int i; if(n==0){ retrun 0; } for(i=1; i\u0026lt;=n; i++){ int tmp = p[i]+Top_Down_Cut_Rod(p, n-i); r = (r\u0026gt;=tmp) ? r : tmp; } return r; } 時間計算量 $O(2^{n})$\n(2) 動的計画法（下から上まで） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int Bottom_Up_Cut_Rod(int p[], int n, int *s){ // *s:部分問題の最適な切断方法 int r[n+1]; // 部分問題の最適値 r[0]=0; for(int j=1; j\u0026lt;=n; j++){ int tmp=0; for(int i=1; i\u0026lt;=j; i++){ if(p[i]+r[j-1] \u0026gt; tmp){ tmp = p[i]+r[j-i]; s[j]=i; } } r[i]=tmp; } return r[n]; } 時間計算量 $O(n^{2})$\nその他のコンテンツ 検索プロセス中に、既存の記事を見つけました： 【基础算法】动态规划详解——钢条切割 ","date":"2023-05-27T19:37:08+08:00","permalink":"https://blog.yexca.net/ja/archives/110/","title":"アルゴリズム 鉄筋切断問題 (動的計画法 分割統治法)"},{"content":" この記事は Google 翻訳を使用して処理されました\n問題の説明 コインは $n$ 枚あり、そのうち 1 枚は偽造コインであり、偽造コインの方が軽いことが分かっています。今では残高は 1 つだけなので、できるだけ少ない比較で偽造コインを見つける必要があります。\n問題分析 $n$ 枚のコインを 2 つの等しい部分に分割します。\n$n$ が偶数の場合、最初の部分と2番目の部分、$1\\cdots\\frac{n}{2}$ と $\\frac{n}{2}+1\\cdots n$ を2つのスケールの端と端を照らします。軽い方の端に偽造コインが含まれています。同じ方法を使用して、コインの軽い部分にある偽造コインを見つけます。 $n$ が奇数の場合、最初と最後の部分 $1\\cdots\\frac{n-1}{2}$ と $\\frac{n+1}{2}+1\\cdots n$ を、天秤の軽い方の端に偽造コインがあります。同じ方法を使用して、コインの軽い部分にある偽造コインを見つけ続けます。両端の重さが同じであれば、真ん中のコインは偽造コインです。つまり、$\\frac{n+1}{2}$ 枚のコインは偽造品である。 Cコード 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 #include \u0026lt;stdio.h\u0026gt; // coins:重量配列 first,last:配列の最初と最後の添え字 int getCounterfeitCoin(int *coins, int first, int last); int main(void){ int coins[10] = {2,2,1,2,2,2,2,2,2,2}; int tmp = getCounterfeitCoin(coins, 0, 9); printf(\u0026#34;%d は偽造コインです\\n\u0026#34;,tmp+1); return 0; } int getCounterfeitCoin(int *coins, int first, int last){ int firstSum=0; int lastSum=0; int i; // 残りコインは2枚のみ if(first == last -1){ if(coins[first] \u0026lt; coins[last]) return first; return last; } // 偶数枚のコイン if ((last-first+1)%2 == 0){ for(i=first; i\u0026lt;first+(last-first)/2+1; i++){ firstSum += coins[i]; } for(i=first+(last-first)/2+1; i\u0026lt;last+1; i++){ lastSum += coins[i]; } if(firstSum \u0026lt; lastSum){ return getCounterfeitCoin(coins, first, first+(last-first)/2); }else{ return getCounterfeitCoin(coins, first+(last-first)/2+1, last); } }else{ // 奇数のコイン for(i=first; i\u0026lt;first+(last-first)/2; i++){ firstSum += coins[i]; } for(i=first+(last-first)/2+1; i\u0026lt;last+1; i++){ lastSum += coins[i]; } if(firstSum \u0026lt; lastSum){ return getCounterfeitCoin(coins, first, first+(last-first)/2-1); }else if(firstSum \u0026gt; lastSum){ return getCounterfeitCoin(coins, first+(last-first)/2+1, last); }else{ return first+(last-first)/2; } } } ","date":"2023-05-18T20:17:35+08:00","permalink":"https://blog.yexca.net/ja/archives/109/","title":"アルゴリズム偽造コイン問題 (分割統治)"},{"content":" 📢 この記事は gemini-3-flash-preview によって翻訳されました 「それぞれのデザインパターンは、私たちの周りで繰り返し発生する問題と、その解決策の核心を記述している。そうすることで、同じ解決策を何度も何度も、ゼロから考え直すことなく使い回せるようになるんだ」。デザインパターンの核心は、関連する問題への解決策を提供することで、成功した設計やアーキテクチャを簡単に再利用できるようにすることにあるよ。\nデザインパターンには、一般的に以下の4つの基本要素があるんだ。\nパターン名 (Pattern Name)：パターンの問題、解決策、効果を一言二言で表す名前。 問題 (Problem)：いつそのパターンを使うべきかを記述したもの。 解決策 (Solution)：設計を構成する要素、それらの関係性、それぞれの役割や協力方法を記述したもの。 効果 (Consequences)：パターンを適用した際の結果や、使用する際に考慮すべきトレードオフを記述したもの。 デザインパターンは、含まれるクラスやインスタンス、それらの役割、協力方法、そして責任の割り当てを明確にするんだ。それぞれのデザインパターンは、特定のオブジェクト指向設計の問題やポイントに焦点を当てていて、いつ使うべきか、他の制約下でも使えるか、そして使用した際の効果や取捨選択について説明しているよ。デザインパターンの目的に応じて、大きく3つのカテゴリに分けられるんだ。\n生成に関するパターンはオブジェクトの作成に関わり、構造に関するパターンはクラスやオブジェクトの組み合わせを扱い、振る舞いに関するパターンはクラスやオブジェクトの責任分担について記述しているよ。\n生成に関するパターン 構造に関するパターン 振る舞いに関するパターン クラス Factory Method Adapter (クラス) Interpreter\nTemplate Method オブジェクト Abstract Factory\nBuilder\nPrototype\nSingleton Adapter (オブジェクト)\nBridge\nComposite\nDecorator\nFacade\nFlyweight\nProxy Chain of Responsibility\nCommand\nIterator\nMediator\nMemento\nObserver\nState\nStrategy\nVisitor 生成に関するデザインパターン 生成に関するパターンはインスタンス化のプロセスを抽象化するものだよ。これらは、システムがオブジェクトをどのように作成、構成、表現するかから独立するのを助けてくれるんだ。クラスの生成パターンは継承を使ってインスタンス化されるクラスを変え、オブジェクトの生成パターンはインスタンス化を別のオブジェクトに委譲するんだ。\nシステムがクラス継承よりもオブジェクトの合成に依存するように進化するにつれて、生成に関するパターンはより重要になっていくよ。この状況では、固定された動作をハードコーディングするのではなく、小さな基本動作のセットを定義し、それらを組み合わせて複雑な動作を作ることに重点が置かれるようになる。そうなると、特定の動作を持つオブジェクトを作るには、単にクラスをインスタンス化する以上のことが求められるんだ。\nこれらのパターンには、繰り返し現れる2つの大きなテーマがあるよ。\nシステムがどの具体的なクラスを使用しているかという情報をカプセル化する。 これらのクラスのインスタンスがどのように作成され、組み合わされるかを隠す。システム全体がこれらのオブジェクトについて知っているのは、抽象クラスで定義されたインターフェースだけになるんだ。 だから、生成に関するパターンは、「何を」「誰が」「いつ」「どのように」作成するかについて、大きな柔軟性を与えてくれるよ。構造や機能が大きく異なる「製品」オブジェクトを使ってシステムを構成できるし、その構成は静的（コンパイル時）でも動的（実行時）でもいいんだ。\n構造に関するデザインパターン 構造に関するデザインパターンは、より大きな構造を得るためにクラスやオブジェクトをどう組み合わせるかを扱うよ。構造に関するクラスパターンは、インターフェースや実装を組み合わせるために継承メカニズムを採用する。簡単な例は、多重継承を使って2つ以上のクラスを1つのクラスにまとめ、親クラスのすべての性質を持たせることだね。このパターンは、独立して開発された複数のライブラリを協力させるのに特に役立つよ。その一例がクラス形式の Adapter パターンだ。一般的にアダプターはあるインターフェースを他のインターフェースと適合させ、異なる複数のインターフェースに対して統一された抽象化を提供する。そのために、クラスアダプターは adaptee クラスをプライベート継承し、自らのインターフェースを adaptee のインターフェースで表現するんだ。\n構造に関するオブジェクトパターンは、インターフェースや実装を組み合わせるのではなく、オブジェクトを組み合わせて新しい機能を実現する方法を記述する。実行時にオブジェクトの組み合わせを変更できるため、オブジェクトの合成はより柔軟性が高く、静的なクラス合成では不可能な仕組みを実現できるんだ。\n振る舞いに関するデザインパターン 振る舞いに関するパターンは、アルゴリズムとオブジェクト間の責任の割り当てに関わっているよ。オブジェクトやクラスのパターンだけでなく、それらの間の通信パターンも記述するんだ。これらのパターンは、実行時に追跡するのが難しい複雑な制御フローを浮き彫りにする。ユーザーの注意を制御フローからオブジェクト間のつながりへと移してくれるんだ。\n振る舞いに関するクラスパターンは、継承を使ってクラス間に振る舞いを分配する。その中でも Template Method はシンプルでよく使われるよ。テンプレートメソッドはアルゴリズムの抽象的な定義で、ステップごとにアルゴリズムを定義し、各ステップで抽象操作やプリミティブ操作を呼び出す。サブクラスが抽象操作を定義してアルゴリズムを具体化するんだ。もう一つのクラスパターンは Interpreter で、文法をクラス階層として表現し、それらのインスタンスに対する操作としてインタープリタを実装するものだよ。\n振る舞いに関するオブジェクトパターンは、継承ではなくオブジェクトの合成を使う。いくつかのパターンは、対等なオブジェクトのグループが、単独では達成できないタスクをどのように協力して完了するかを記述している。ここで重要なのは、対等なオブジェクトがどうやってお互いを知るかだ。オブジェクト同士が明示的な参照を持ち合うこともできるけど、それでは結合度が上がってしまう。極端な場合、すべてのオブジェクトが他のすべてのオブジェクトを知る必要が出てくる。Mediator は、対等なオブジェクト間にメディエーターオブジェクトを導入することで、この状況を回避し、疎結合に必要な間接性を提供するんだ。\n推薦図書 https://refactoringguru.cn/design-patterns ","date":"2023-05-17T22:50:20+08:00","permalink":"https://blog.yexca.net/ja/archives/108/","title":"デザインパターンの基本：はじめに"},{"content":" 📢 この記事は gemini-3-flash-preview によって翻訳されました 中国大陸からゲームに入れない時のための分流（スプリット・トンネリング）ルールだよ。\nポイント ゲームにログインする時にUDP接続が必要なんだけど、多くのプロトコルはUDPをサポートしていないんだ。つまり、UDPに遭遇すると自動的に拒否されちゃう。だから、UDP接続で使うIPを「直連（ダイレクト）」に設定すれば解決するよ。僕がキャプチャした2つのIPはこれ：\n1 2 3 8.209.196.179 # 2つ目は直連だと繋がらないっぽいから、基本的には1つ目だけ設定すれば大丈夫 47.245.63.117 もちろん、安全のため（TCP接続とUDP接続が一致しないことで起こりうるリスクを避けるため）、関連するドメインも全部直連に設定しておくのがおすすめ。具体的にはこれらだね：\n1 2 3 *.starrails.com *.hoyoverse.com 8.209.196.179/8 OpenClash 「全局設置（グローバル設定）- 規則設置（ルール設定）」で、「自定義規則（カスタムルール）」を有効にして、最初の枠の rules: の下に入力してね。\n1 2 3 4 #rules: - DOMAIN-SUFFIX, starrails.com, DIRECT - DOMAIN-SUFFIX, hoyoverse.com, DIRECT - IP-CIDR, 8.209.196.179/8, DIRECT Quantumult X 設定ファイルを編集して、[filter_local] のセクションまで移動してから、以下の内容を入力してね。\n1 2 3 4 #SR host-suffix, starrails.com, direct host-suffix, hoyoverse.com, direct ip-cidr, 8.209.196.179/8, direct ","date":"2023-05-16T23:13:21+08:00","permalink":"https://blog.yexca.net/ja/archives/107/","title":"『崩壊：スターレイル』国際サーバーの分流ルール"},{"content":" この記事は Google 翻訳を使用して処理されました\n問題の説明 回路基板の上端と下端には n 個の端子があります。回路設計によれば、$(i, \\pi(i))$ は、上側の端子 i と下側の端子 $\\pi(i)$ の間の接続を表すために使用され、これは回路図上の i 番目の接続と呼ばれます。\n下の図に示す $\\pi(i)$ は、任意の $1 \\le i \u003c j \\le n $ に対して $\\{8, 7, 4, 2, 5, 1, 9, 3, 10, 6\\}$ として配置されます。i 番目のリンクと j 番目のリンクが交差するための必要十分条件は $\\pi(i)\u003e\\pi(j)$ である。\n回路基板を作るとき、これらのn本の配線を複数の絶縁層に分配する必要があり、同じ層の配線は交差しません。次に、どの配線を層に配置するかを決定する必要があります。このレイヤーで可能な限り多くのリンク、つまりリンクセット $Nets=\\{ (i,\\pi(i)),1\\le i\\le n \\}$ の最大の分離サブセットを決定する。\n問題分析 $N(i,j)=\\{ t\\|(t,\\pi(t))\\in Nets, t\\le i, \\pi(t) \\le j \\}$ とする。$N(i,j)$ の最大の分離部分集合を $MNS(i,j)$ ，$size(i,j)=\\|MNS(i,j)\\|$ とする。\n分析の結果、この問題は最適なサブ構造特性を持つことがわかりました。規模 n の回路配線問題では、次の再帰式を構築できます。\n$$ \\begin{align*} \u0026(1) \\ \\ i=1\\ とする、 size(1,j)= \\begin{cases} 0, \u0026 \\text{j\u003c$\\pi$(1)} \\\\ 1, \u0026 \\text{その他の状況} \\end{cases} \\\\ \u0026(2) \\ \\ i\u003e1\\ とする， size(i,j)= \\begin{cases} size(i-1,j), \u0026 \\text{j\u003c$\\pi$(i)} \\\\ max{size(i-1,j),size(i-1,\\pi(i)-1)+1}, \u0026 \\text{その他の状況} \\end{cases} \\end{align*} $$C コード 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #define N 10 // 問題の大きさ // 分離した接続の最大数を見つける void maxNum(int pi[], int **size); // 最大分離接続セットを構築します。net[i]は、最大分離サブセット内のi番目の接続の上位端末のシリアル番号を表します。 int constructSet(int pi[], int **size, int *net); int main(void){ // 下付き文字は1から始まります int pi[N+1] = {0, 8, 7, 4, 2, 5, 1, 9, 3, 10, 6}; int net[N]; int **size; size = (int**)malloc(sizeof(int*)*(N+1)); for(int i=0;i\u0026lt;N+1;i++) size[i]=(int*)malloc(sizeof(int)*(N+1)); maxNum(pi, size); int m = constructSet(pi, size, net); printf(\u0026#34;分離接続の最大数は次のとおりです。%d\\n\u0026#34;,m); printf(\u0026#34;含まれる接続は次のとおりです。\\n\u0026#34;); for(int i=0; i\u0026lt;m; i++){ printf(\u0026#34;(%d,%d)\\n\u0026#34;, net[i], pi[net[i]]); } } void maxNum(int pi[], int **size){ // size[i][j]: 上部と下部にそれぞれ i と j の端子がある回路基板の最初の層における分離接続の最大数 int i,j; // when j\u0026lt;pi(1) for(j=0; j\u0026lt;pi[1]; j++) size[1][j]; // when j\u0026gt;=pi(1) for(j=pi[1]; j\u0026lt;=N; j++) size[1][j]; for(i=2; i\u0026lt;N; i++){ // when j\u0026lt;pi(i) for(j=0; j\u0026lt;pi[i]; j++) size[i][j] = size[i-1][j]; // when j\u0026gt;=c[i] for(j=pi[i]; j\u0026lt;=N; j++) size[i][j]=size[i-1][j]\u0026gt;=size[i-1][pi[i]-1]+1 ? size[i-1][j] : size[i-1][pi[i]-1]+1; } // 最大接続数 size[N][N] = size[N-1][N]\u0026gt;=size[N-1][pi[N]-1]+1 ? size[N-1][N] : size[N-1][pi[N]-1]+1; } // 最大分離接続セットを構築します。net[i]は、最大分離サブセット内のi番目の接続の上位端末のシリアル番号を表します。 int constructSet(int pi[], int **size, int *net){ int i; int j=N; int m=0; // 端末セット内の最大接続数を記録する for(i=N; i\u0026gt;1; i--){ // 減少 // (i,pi[i])は最大の互いに素な部分集合を結ぶ線である。 if(size[i][j] != size[i-1][j]){ net[m++]=i; // iを配列ネットに記録し、接続ラインの数を1増やす j=pi[i]-1; // 拡張リンクバー間隔を更新しました } } // when i=1 if(j\u0026gt;=pi[1]) net[m++] = 1; return m; } その他のコンテンツ 検索中に既存の記事が見つかりました： 算法设计与分析——电路布线（动态规划） 参考文献 LaTeX公式手册 Typora中使用LaTeX：多行公式左对齐 用malloc动态申请一个二维数组的三种方法 ","date":"2023-05-16T17:53:31+08:00","permalink":"https://blog.yexca.net/ja/archives/106/","title":"アルゴリズム回路配線問題（動的計画法）"},{"content":" 📢 この記事は ChatGPT によって翻訳されました Rclone を使って OneDrive 上の音楽ファイルをマウントし、Navidrome を使って音楽サイトを構築。Docker でデプロイする。\nRclone まずは Windows 環境で設定ファイルを取得して、サーバー側でインストールとマウントを行う。\nToken の取得 Windows 向け Rclone をダウンロード：\nhttps://rclone.org/downloads/ 解凍後、cmd でそのフォルダに入り、以下のコマンドを実行：\n1 rclone.exe authorize \u0026#34;onedrive\u0026#34; ブラウザでログインして認証完了すると、Token が出力される。 この Token（中括弧ごと）を控えておく。\n設定ファイルの取得 次に以下のコマンドでインタラクティブ設定を行う：\n1 rclone.exe config 手順に従って設定すると、設定ファイルが以下に生成される：\n1 C:\\Users\\%USERNAME%\\AppData\\Roaming\\rclone 設定ファイルをコピー サーバー側に以下のディレクトリを作成：\n1 2 3 4 # 設定ファイル格納用 /home/docker/rclone/config # OneDrive をマウントするローカルフォルダ /home/docker/rclone/data 作成した設定ファイルを上記フォルダに配置。\nディレクトリをマウント Rclone の Docker イメージを取得：\n1 docker pull rclone/rclone:latest 以下のコマンドでマウント：\n1 2 3 4 5 6 7 docker run --rm \\ --volume /root/rclone/config:/config/rclone \\ --volume /root/rclone/data:/data:shared \\ --volume /etc/passwd:/etc/passwd:ro --volume /etc/group:/etc/group:ro \\ --device /dev/fuse --cap-add SYS_ADMIN --security-opt apparmor:unconfined \\ rclone/rclone \\ mount music:/ /data/music --allow-other --allow-non-empty --vfs-cache-mode writes \u0026amp; \u0026amp; はバックグラウンド実行。PID が表示されるので、停止したいときは：\n1 kill PID 補足： Linux 学習 第六章 管理运行中的进程 例では OneDrive 上の music フォルダを /home/docker/rclone/data/music にマウントしている。\n参考リンク：\nhttps://rclone.org/onedrive/ https://rclone.cn/install.html LinuxでRcloneを使ってOneDriveやGoogleDriveをマウントし自動起動を設定 Navidrome のデプロイ Docker Compose を使用。まず以下のディレクトリを作成：\n1 /home/docker/navidrome docker-compose.yml を作成して、以下の内容を記入：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 version: \u0026#34;3\u0026#34; services: navidrome: image: deluan/navidrome:latest ports: - \u0026#34;8001:4533\u0026#34; restart: unless-stopped environment: ND_SCANSCHEDULE: 1h ND_LOGLEVEL: info ND_SESSIONTIMEOUT: 24h ND_BASEURL: \u0026#34;\u0026#34; volumes: - \u0026#34;/home/docker/navidrome/data:/data\u0026#34; - \u0026#34;/home/docker/rclone/data/music:/music:ro\u0026#34; 他の設定項目はこちら： Navidrome Configuration Options - Navidrome デプロイ：\n1 docker-compose up -d アクセスは IP:8001 で。\n参考：\nhttps://www.navidrome.org/docs/installation/docker/ Navidromeで自分だけの音楽プレーヤーを構築 楽曲情報の管理 曲を分類したいなら、メタ情報（タグや歌詞）を埋め込んでおく必要がある。\nおすすめの編集ツール：\nMusicTag（作者ブログ） Web 版： xhongc/music-tag-web クライアントアプリで聴く Web UI は PC だと使えるけど、スマホだとちょっと微妙…\n幸いにも Navidrome に対応したクライアントアプリがいくつか存在する：\n詳細は公式ページへ： https://www.navidrome.org/docs/overview/#apps ","date":"2023-05-02T02:27:39+08:00","permalink":"https://blog.yexca.net/ja/archives/105/","title":"個人音楽サイトの構築"},{"content":" 📢 この記事は gemini-2.5-flash によって翻訳されました 図 (Diagram) は要素のグループをグラフィカルに表現したものだよ。ほとんどの場合、図は頂点 (物事を表す) と弧 (関係を表す) の連結グラフとして描かれるんだ。システムを視覚化するために、さまざまな視点から図を描けるから、図はシステムの投影なんだね。\nUML 2.0 は13種類の図を提供しているよ。クラス図、オブジェクト図、ユースケース図、シーケンス図、コミュニケーション図、ステートマシン図、アクティビティ図、コンポーネント図、合成構造図、配置図、パッケージ図、インタラクション概要図、タイミング図だね。シーケンス図、コミュニケーション図、インタラクション概要図、タイミング図はまとめてインタラクション図と呼ばれるんだ。\n(一) クラス図 クラス図 (Class Diagram) は、オブジェクト、インターフェース、コラボレーション、そしてそれらの関係を示すものだよ。オブジェクト指向システムのモデリングで最もよく作られる図がクラス図なんだ。クラス図はシステムの静的な設計ビューを表してくれるんだね。アクティブなクラスを含むクラス図は、システムの静的なプロセスビューを示してくれるよ。\nクラス図には通常、次の内容が含まれるよ。\nクラス インターフェース コラボレーション 依存、汎化、関連の関係 例えば：\nStudent +id: int\n-name: String\n#age: int ~borrow(): bool +: public\n-: private\n#: protected\n~: package\nクラス図には、注釈や制約を含めることもできるんだ。パッケージやサブシステムを含めることもできて、これらはどちらもモデル要素をより大きな塊にまとめるために使われるんだよ。\nクラス図はシステムの静的な設計ビューをモデリングするために使うんだ。このビューは、主にシステムの機能要件、つまりシステムがエンドユーザーに提供するサービスをサポートするよ。システムの静的な設計ビューをモデリングするときは、通常、次の3つの方法のいずれかでクラス図を使うんだ。\nシステムの語彙をモデリングする 単純なコラボレーションをモデリングする 論理データベーススキーマをモデリングする (二) オブジェクト図 オブジェクト図 (Object Diagram) は、ある時点におけるオブジェクトのグループとそれらの関係を示すものだよ。クラス図で確立された物事のインスタンスの静的なスナップショットを記述するんだ。オブジェクト図には通常、オブジェクトとリンクが含まれるよ。\nオブジェクト名：クラス名 属性 クラス図と同じように、オブジェクト図はシステムの静的な設計ビューまたは静的なプロセスビューを示してくれるんだ。\n(三) ユースケース図 ユースケース図 (Use Case Diagram) は、ユースケースのグループ、アクター (Actor)、そしてそれらの関係を示すものだよ。\nユースケース図には通常、次の内容が含まれるよ。\nユースケース アクター ユースケース間の拡張関係 \u0026lt;\u0026lt;extend\u0026gt;\u0026gt; と包含関係 \u0026lt;\u0026lt;include\u0026gt;\u0026gt;、アクターとユースケース間の関連関係、ユースケース同士およびアクター同士の汎化関係。 包含関係\nあるユースケースが別のユースケースを含むこと。\n基本ユースケース \u0026ndash;\u0026lt;\u0026lt;include\u0026gt;\u0026gt;\u0026ndash;\u0026gt; 包含されるユースケース\n拡張関係\nあるユースケースが実行されるときに、特別な状況やオプションの状況が発生する可能性があるんだ。この状況がそのユースケースの拡張ユースケースにあたるんだね。\n拡張ユースケース \u0026ndash;\u0026lt;\u0026lt;extend\u0026gt;\u0026gt;\u0026ndash;\u0026gt; 基本ユースケース\nユースケース図は、システムの静的なユースケースビューをモデリングするために使うんだ。このビューは、主にシステムの振る舞い、つまりシステムがその周辺環境のコンテキストで提供する外部から見えるサービスをサポートするよ。\nシステムの静的なユースケースビューをモデリングするときは、次の2つの方法でユースケース図を使うことができるよ。\nシステムのコンテキストをモデリングする システムの要件をモデリングする (四) インタラクション図 インタラクション図は、システムの動的な側面をモデリングするために使うよ。インタラクション図は1つのインタラクションを表していて、オブジェクトのグループとそれらの関係から構成され、それらの間でやり取りされる可能性のあるメッセージを含むんだ。インタラクション図は、シーケンス図、コミュニケーション図、インタラクション概要図、タイミング図として表現されるよ。それぞれ異なる目的を持っていて、異なる状況に適用できるんだ。シーケンス図はメッセージの時間順序を強調するインタラクション図で、コミュニケーション図はメッセージを受け渡しするオブジェクトの構造的な組織を強調するインタラクション図、インタラクション概要図は制御フローを強調するインタラクション図だよ。\nインタラクション図には一般的に、オブジェクト、リンク、メッセージが含まれるんだ。\nシーケンス図 シーケンス図 (Sequence Diagram) は、シナリオ (Scenario) をグラフィカルに表現したものだよ。時間順序で整理されたオブジェクト間のインタラクション活動を記述するんだ。シーケンス図を作成するときは、まずインタラクションに参加するオブジェクトを図の上部に水平方向に並べるんだ。通常、インタラクションを開始するオブジェクトを左側に、下位のオブジェクトを右側に配置するよ。それから、これらのオブジェクトが送受信するメッセージを垂直方向に時間順に上から下へと配置するんだ。こうすることで、時間の経過とともに制御フローがどのように流れるか、明確に視覚化できるんだね。\nシーケンス図には、コミュニケーション図とは異なる2つの特徴があるよ。\nシーケンス図にはオブジェクトのライフラインがあるんだ。ライフラインは垂直の破線で、あるオブジェクトが一定期間存在することを示すんだよ。 シーケンス図には制御のフォーカスがあるんだ。制御のフォーカスは細長い長方形で、あるオブジェクトがアクションを実行するのにかかる期間を表すんだ。直接実行する場合もあれば、下位プロセスを通じて実行する場合もあるよ。長方形の上部はアクションの開始を、下部はアクションの終了を示すんだ。 コミュニケーション図 コミュニケーション図 (Communication Diagram) は、メッセージを送受信するオブジェクトの構造的な組織を強調するもので、以前のバージョンではコラボレーション図とも呼ばれていたんだ。コミュニケーション図は、インタラクションに参加するオブジェクトの組織を強調するよ。コミュニケーション図を作成するには、まずインタラクションに参加するオブジェクトを図の頂点として配置し、次にこれらのオブジェクトを接続するリンクを図の弧として表現するんだ。最後に、オブジェクトが送受信するメッセージでこれらのリンクを装飾するんだね。こうすることで、協調するオブジェクトの構造的な組織のコンテキストで制御フローを観察する明確な視覚的な軌跡を提供してくれるんだ。\nコミュニケーション図には、シーケンス図とは異なる2つの特性があるよ。\nコミュニケーション図にはパスがあるんだ。あるオブジェクトが別のオブジェクトとどのようにリンクしているかを示すために、リンクの末端にパスのステレオタイプを付加できるんだよ。 コミュニケーション図には順序番号があるんだ。メッセージの時間順序を表すために、メッセージに数字のプレフィックスを付けることができるんだ。制御フローでは、新しいメッセージごとに順序番号が単調に増えるよ。ネストを使用するために、小数点付きの番号を使うこともできるんだね。 シーケンス図とコミュニケーション図は同型で、互いに変換できるんだ。\n(五) ステートマシン図 ステートマシン図 (State Diagram) は、状態、遷移、イベント、活動から構成されるステートマシンを示すものだよ。ステートマシン図はシステムの動的なビューに焦点を当てていて、インターフェース、クラス、コラボレーションの振る舞いのモデリングにおいて特に重要で、オブジェクトの振る舞いのイベント順序を強調するんだ。\nステートマシン図には通常、単純状態と複合状態、遷移 (イベントとアクション) が含まれるよ。\n状態 状態は、観察できるシステムの振る舞いのパターンだよ。1つの状態はシステムの1つの振る舞いパターンを表すんだ。状態はシステムがイベントにどのように応答するかを規定するんだね。システムのイベントへの応答は、1つ (または一連の) アクションを実行することでも、システム自体の状態のみを変更することでも、状態を変更してアクションを実行することでもあり得るんだ。\nステートマシン図で定義される主な状態は、初期状態 (初態)、最終状態 (終態)、中間状態だね。初期状態は黒い丸で、最終状態は黒い丸の外にさらに丸が描かれたもので表されるんだ。ステートマシン図における状態は、角丸四角形で表現されるよ。\n状態間には状態遷移があって、矢印付きの線で表されるんだ。矢印付きの線上のイベントが発生すると、状態遷移が始まるんだね。1つのステートマシン図には1つの初期状態しか持てないけど、最終状態はなくてもいいし、複数あっても大丈夫だよ。\n3つの標準イベント：\nentry: エントリアクション、状態に入った時にすぐに実行されるよ。 exit: イグジットアクション、状態から出るときにすぐに実行されるよ。 do: 内部活動、限られた時間を占有し、中断可能な作業だよ。 上の図の例：\nentry/turnON: この状態に遷移した時に、ライトを点けるアクションを実行するんだ。 do/blinkFivetimes: この状態にある間、ライトが5回点滅するんだ。 exit/turnOFF: この状態から遷移する時に、ライトを消すアクションを実行するんだ。 イベントと遷移 イベントは、ある特定の瞬間に発生する事柄で、システムにアクションを実行させたり (および) ある状態から別の状態へ遷移させたりする外部イベントの抽象化だよ。例えば、視聴者がテレビのリモコンを使う、ユーザーがマウスを動かす、マウスをクリックするなど、これらすべてがイベントなんだ。簡単に言えば、イベントはシステムにアクションを実行させたり (および) 状態を遷移させたりする制御情報なんだね。\n状態遷移は通常イベントによってトリガーされるんだ。この場合、状態遷移を表す矢印の上に、遷移をトリガーするイベント式を記す必要があるんだよ。\n矢印線上にイベントが明記されていない場合は、元となる状態の内部活動が完了した後、自動的に遷移がトリガーされることを意味するよ。イベント式の構文は次のとおりだよ。\nイベント説明[ガード条件]アクション式\nその中で、イベント説明の構文は：イベント名(パラメータリスト) だよ。\nガード条件 (または監視条件) はブール式だよ。イベント説明とガード条件を同時に使う場合、イベントが発生し、かつブール式が真である場合にのみ状態遷移が発生するんだ。ガード条件のみでイベント説明がない場合は、ガード条件が真である限り状態遷移が発生するよ。\n遷移は2つの状態 (元の状態、目標状態) を含むよ。 イベント、ガード条件、アクション\nイベントが遷移をトリガーするんだ。\n活動 (アクション) は状態内で実行することもできるし、状態遷移時に実行することもできるんだ。\n完了図 ステートマシン図を使ってシステムの動的な側面をモデリングできるよ。これらの動的な側面には、システムアーキテクチャのあらゆるビューに現れるあらゆる種類のオブジェクトのイベント順序に基づく振る舞いが含まれるんだ。これらのオブジェクトには、クラス (各アクティブクラス)、インターフェース、コンポーネント、ノードなどがあるよ。\nシステム、クラス、またはユースケースの動的な側面をモデリングするときは、通常、リアクティブなオブジェクトをモデリングするんだ。\n(六) アクティビティ図 アクティビティ図 (Activity Diagram) は特殊なステートマシン図で、システム内のある活動から別の活動への流れを示すものだよ。アクティビティ図はシステムの動的なビューに焦点を当てていて、システムの機能モデリングにとって特に重要で、オブジェクト間の制御フローを強調するんだ。\nアクティビティ図には一般的に、活動状態とアクション状態、遷移、オブジェクトが含まれるよ。\nアクティビティ図は、分岐、マージ、フォーク、ジョインを表現できるんだ。\nシステムの動的な側面をモデリングするときは、通常、2つの方法でアクティビティ図を使うんだ。\nワークフローをモデリングする 操作をモデリングする (七) コンポーネント図 コンポーネント図 (Component Diagram) は、コンポーネント間の組織と依存関係を示すものだよ。コンポーネント図はシステムの静的な実装ビューに焦点を当てているんだ。これはクラス図と関連していて、通常、コンポーネントは1つ以上のクラス、インターフェース、またはコラボレーションにマッピングされるんだ。\n(八) 配置図 配置図 (Deployment Diagram) は、オブジェクト指向システムの物理的な側面をモデリングするために使われる方法で、実行時処理ノードとそこに含まれるコンポーネント (成果物) の配置を示すものだよ。配置図はシステムの静的な配置ビューをモデリングし、コンポーネント図と関連しているんだ。通常、ノードは実行時に存在し、計算リソースを表す物理要素で、少なくとも何らかのコンテンツを持ち、しばしば処理能力を持ち、1つ以上のコンポーネントを含むんだ。ここで \u0026lt;\u0026lt;artifact\u0026gt;\u0026gt; は成果物を表しているよ。\nまとめ 静的モデリング：クラス図、オブジェクト図、ユースケース図\n動的モデリング：シーケンス図 (順序図、時系列図)、コミュニケーション図 (コラボレーション図)、ステートマシン図、アクティビティ図\n物理モデリング：コンポーネント図 (コンポーネント図)、配置図\nインタラクション図：シーケンス図 (順序図、時系列図)、コミュニケーション図 (コラボレーション図)\n","date":"2023-04-13T20:02:00+08:00","permalink":"https://blog.yexca.net/ja/archives/104/","title":"UMLの図"},{"content":" 📢 この記事は gemini-2.5-flash によって翻訳されました オブジェクト指向分析は、システム内のオブジェクトの特性と振る舞いの定義に焦点を当てるんだ。今、国際的には色々なオブジェクト指向手法が登場してるよね。業界で広く受け入れられてるのはUML（Unified Modeling Language、統一モデリング言語）だよ。\n統一モデリング言語は、オブジェクト指向ソフトウェアの標準的なモデリング言語なんだ。シンプルで統一されてるし、ソフトウェア設計における動的な情報も静的な情報も表現できるから、今やビジュアルモデリング言語の事実上の業界標準になってるんだよ。\nUMLは3つの要素で構成されてるんだ。UMLの基本的な構成ブロック、これらの構成ブロックをどう配置するかを支配するルール、そして言語全体に適用される共通のメカニズムだね。\nUMLの語彙には、3種類の構成ブロックが含まれるんだ。それは「物事（Thing）」「関係（Relationship）」「図（Diagram）」だよ。物事っていうのは、モデルの中で最も代表的な要素を抽象化したものだね。関係は物事を結びつけるもの。図は関連する物事をまとめたものさ。\n物事（Thing） UMLには4種類の物事があるんだ。構造物事、振る舞い物事、グループ化物事、そして注釈物事だよ。\n(1) 構造物事 (Structural Thing) 構造物事はUMLモデルにおける名詞のようなものだね。それらはたいていモデルの静的な部分で、概念や物理的な要素を記述するんだ。\n構造物事には以下が含まれるよ。\nクラス (Class) インターフェース (Interface) コラボレーション (Collaboration) ユースケース (Use Case) アクティブクラス (Active Class) コンポーネント (Component) アーティファクト (Artifact) ノード (Node) (2) 振る舞い物事 (Behavior thing) 振る舞い物事はUMLモデルの動的な部分さ。それらはモデルにおける動詞のようなもので、時間と空間を超えた振る舞いを記述するんだ。\n振る舞い物事には以下が含まれるよ。\n相互作用 (Interaction) ステートマシン (State Machine) アクティビティ (Activity) (3) グループ化物事 (Grouping Thing) グループ化物事はUMLモデルの組織化部分で、モデルが分解された「箱」みたいなものだね。全てのグループ化物事の中で、一番主要なのが「パッケージ (Package)」だよ。パッケージは要素をグループにまとめるための仕組みで、いろんな用途があるんだ。構造物事、振る舞い物事、さらには他のグループ化物事もパッケージの中に入れられるよ。パッケージはコンポーネント（実行時にのみ存在する）とは違って、純粋に概念的なものなんだ（つまり、開発時にのみ存在するってこと）。\n(4) 注釈物事 (Annotational Thing) 注釈物事はUMLモデルの解説部分だよ。これらの注釈物事は、モデルのあらゆる要素を記述したり、説明したり、マークしたりするのに使われるんだ。「注釈 (Note)」が主要な注釈物事の一つだね。注釈は、ある要素や一連の要素に付随して、それを制約したり説明したりするシンプルな記号のことだよ。\n関係（Relationship） UMLには4種類の関係があるよ。依存、関連、汎化、そして実現だね。\n依存 (Dependency) 依存は2つの物事間の意味的な関係なんだ。一方の物事（独立物事）が変化すると、もう一方の物事（依存物事）の意味合いに影響を与えるんだよ。図上では、依存は方向を持つかもしれない点線で描かれるんだ。\n関連 (Association) 関連は構造的な関係で、オブジェクト間の繋がりである「リンク」の集合を記述するんだ。「集約 (Aggregation)」は特殊な種類の関連で、全体と部分の間の構造的な関係を記述するよ。関連には多重度 (Multiplicity) と役割 (Role) を表記できるんだ。\n関連、集約、コンポジション 関連：関連は構造的な関係で、オブジェクト間の繋がりである「リンク」の集合を記述するんだ。関連には多重度と役割を表記できるよ。 例：雇用主と従業員\n集約：部分と全体のライフサイクルが一致しないんだ。全体がなくなっても、部分はまだ存在していて、全体から切り離して存在できるんだね。 例：クラスと生徒、会社と従業員\nコンポジション：部分と全体のライフサイクルが一致するんだ。全体がなくなると部分もなくなっちゃうし、部分は全体から切り離して存在できないよ。 例：人と脳\n依存と単方向関連 依存は比較的偶発的で一時的なものだね。例えば、人と食べ物。お腹が空いてるときだけ依存するけど、満腹になったら依存しないよね。\n単方向関連はもっと強くて、単方向の線で表すんだ。例えば、人と酸素、魚と水とかだね。\n汎化 (Generalization) 汎化は特殊／一般の関係だよ。特殊な要素（子要素）のオブジェクトは、一般的な要素（親要素）のオブジェクトに置き換えられるんだ。この方法で、子要素は親要素の構造と振る舞いを共有することになるんだね。図上では、親要素の方を指し示すんだ。\n実現 (Realization) 実現はクラス要素間の意味的な関係で、あるクラス要素が、別のクラス要素によって実行が保証される契約を規定するんだ。実現関係は2つの場合で使われるよ。1つはインターフェースと、それを実装するクラスやコンポーネントの間。もう1つはユースケースと、それを実現するコラボレーションの間だね。\n","date":"2023-04-11T08:01:00+08:00","permalink":"https://blog.yexca.net/ja/archives/103/","title":"UML"},{"content":" 📢 この記事は ChatGPT によって翻訳されました 思いつきから完全に実現するまで、なんと3ヶ月かかった（主に怠けすぎただけ）\nDocker のインストール APT でインストールする方法。\nHTTPS 転送と CA 証明書用パッケージを追加： 1 2 3 4 5 6 7 8 9 10 # まずは更新 sudo apt-get update # パッケージをインストール sudo apt-get install \\ apt-transport-https \\ ca-certificates \\ curl \\ gnupg \\ lsb-release GPG 鍵を追加してパッケージの正当性を確認： 1 2 3 4 5 # 中国ミラー curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/debian/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg # 公式 curl -fsSL https://download.docker.com/linux/debian/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg ソースリストに Docker ソースを追加： Debian のバージョンを確認して、以下の $(lsb_release -cs) を置き換えること 例：Debian10 → buster、Debian11 → bullseye\n1 2 3 4 5 6 7 8 9 # 中国ミラー echo \\ \u0026#34;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://mirrors.aliyun.com/docker-ce/linux/debian \\ bullseye stable\u0026#34; | sudo tee /etc/apt/sources.list.d/docker.list \u0026gt; /dev/null # 公式 echo \\ \u0026#34;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/debian \\ bullseye stable\u0026#34; | sudo tee /etc/apt/sources.list.d/docker.list \u0026gt; /dev/null stable → test にすればテスト版も使える。\nインストール実行： 1 2 3 4 5 6 7 8 # キャッシュ更新 sudo apt-get update # Docker インストール sudo apt-get install docker-ce docker-ce-cli containerd.io # docker-compose sudo apt-get install docker-compose 一括スクリプトもある：\n1 2 3 4 5 6 7 8 9 10 11 # テスト版 curl -fsSL test.docker.com -o get-docker.sh # 安定版 curl -fsSL get.docker.com -o get-docker.sh # Aliyun ミラー sudo sh get-docker.sh --mirror Aliyun # Azure China ミラー sudo sh get-docker.sh --mirror AzureChinaCloud Docker 起動 1 2 sudo systemctl enable docker sudo systemctl start docker インストール確認：\n1 docker run --rm hello-world 出力があれば成功。\nBlog1: WordPress 例：/root/wordpress に作成。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 version: \u0026#39;3.3\u0026#39; services: db: image: mysql:5.7 volumes: - db_data:/var/lib/mysql restart: always environment: MYSQL_ROOT_PASSWORD: somewordpress MYSQL_DATABASE: wordpress MYSQL_USER: wordpress MYSQL_PASSWORD: wordpress wordpress: depends_on: - db image: wordpress:latest volumes: - /root/wordpress/uploads.ini:/usr/local/etc/php/conf.d/uploads.ini ports: - 8000:80 restart: always environment: WORDPRESS_DB_HOST: db:3306 WORDPRESS_DB_USER: wordpress WORDPRESS_DB_PASSWORD: wordpress WORDPRESS_DB_NAME: wordpress volumes: db_data: {} uploads.ini：\n1 2 3 4 5 file_uploads = On memory_limit = 256M upload_max_filesize = 10M post_max_size = 10M max_execution_time = 600 Docker 関連操作 1 2 3 4 5 6 7 8 # バックグラウンド実行 docker-compose up -d # 停止 docker-compose stop # 停止＋削除 docker-compose down Blog2: Typecho Docker Hub: 80x86/typecho 1 2 3 4 5 6 7 8 9 10 11 12 13 version: \u0026#39;3.0\u0026#39; services: typecho: image: 80x86/typecho:latest container_name: Typecho_Blog volumes: - /root/typecho/data:/data ports: - 8001:80 restart: always environment: PHP_TZ: Asia/Shanghai PHP_MAX_EXECUTION_TIME: 600 クラウドストレージ（PanIndex） GitHub: https://github.com/px-org/PanIndex Docs: https://docs.noki.icu/ 1 2 3 4 5 6 7 8 9 10 version: \u0026#34;3.0\u0026#34; services: PanIndex: restart: always image: iicm/pan-index:latest container_name: VRC_Pan volumes: - /root/pan/data:/app/data ports: - 8002:5238 Nginx + SSL GUI 管理ツール: https://github.com/0xJacky/nginx-ui 1 2 3 4 5 6 7 8 9 10 11 12 13 version: \u0026#39;3.1\u0026#39; services: nginx-ui: restart: always image: uozi/nginx-ui:latest container_name: nginx_UI volumes: - /root/nginx/nginx:/etc/nginx - /root/nginx/nginx-ui:/etc/nginx-ui - /root/nginx/www:/www ports: - 80:80 - 443:443 ホスト側 IP は 172.17.0.1 で参照できる。確認は：\n1 ip addr show docker0 コンテナに入る 1 2 3 4 5 # 一覧確認 docker container ls # 入る docker exec -i [ID] bash bash がない場合もある。\n補足：SSL 証明書 Docker: neilpang/acme.sh 1 2 3 4 5 6 7 8 9 10 11 12 version: \u0026#39;3.1\u0026#39; services: acme.sh: image: neilpang/acme.sh container_name: acme.sh command: daemon volumes: - /root/acme/acme.sh:/acme.sh - /root/acme/conf:/.acme.sh environment: - CF_Key=\u0026#34;CFのAPIキー\u0026#34; - CF_Email=\u0026#34;メールアドレス\u0026#34; DNS API 参考： https://github.com/acmesh-official/acme.sh/wiki/dnsapi 登録：\n1 docker exec acme.sh --register-account -m mail@example.com 証明書取得（Cloudflare）：\n1 docker exec acme.sh --issue --dns dns_cf -d example.com -d www.example.com cron 自動更新は省略。\nNginx (手動構築) 1 2 3 4 5 6 7 8 9 10 11 12 13 version: \u0026#39;3.1\u0026#39; services: nginx: restart: always image: nginx container_name: nginx ports: - 80:80 volumes: - /root/docker/nginx/conf.d:/etc/nginx/conf.d - /root/docker/nginx/www:/user/share/nginx/html - /root/docker/nginx/log:/var/log/nginx - /root/acme/acme.sh:/ssl conf.d/default.conf 例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 server { listen 80; listen [::]:80; server_name your_domain.com; rewrite ^(.*)$ https://$host$1 permanent; } map $http_upgrade $connection_upgrade { default upgrade; \u0026#39;\u0026#39; close; } server { listen 443 ssl http2; listen [::]:443 ssl http2; server_name your_domain.com; ssl_certificate /ssl/fullchain.cer; ssl_certificate_key /ssl/your_domain.key; location / { proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection $connection_upgrade; proxy_pass http://172.17.0.1:9000/; } } 参考資料\ndocker安装nginx并配置ssl证书，代理宿主机服务_Blueeyedboy521的博客-CSDN博客_bitwarden docker ssl Nginx 安装 SSL 配置 HTTPS 超详细完整全过程-阿里云开发者社区 (aliyun.com) 快速部署 Docker 同时发布多个网站或服务_天道酬勤~的博客-CSDN博客_docker部署 一台服务器多个系统 Let\u0026rsquo;s Encrypt 使用教程，免费的SSL证书，让你的网站拥抱 HTTPS - Diamond-Blog (diamondfsd.com) Nginx反向代理的一次使用总结 - 简书 (jianshu.com) Nginx配置反向代理隐藏服务端口 - \u0026amp;大飞 - 博客园 (cnblogs.com) 参考記事 Debian - Docker — 从入门到实践 (gitbook.io) Docker 安装 Wordpress 博客 - 腾讯云开发者社区-腾讯云 (tencent.com) Docker部署WordPress解决“上传的文件尺寸超过php.ini中定义的upload_max_filesize值”问题_neiro-DevPress官方社区 (csdn.net) let’s Encrypt 证书之安装故障 Could not bind to IPv4 or IPv6. - 料网 (liaosam.com) 基于Let\u0026rsquo;s Encrypt生成免费证书-支持多域名泛域名证书 - DevOps在路上 - 博客园 (cnblogs.com) Docker Compose-菜鸟教程 (runoob.com) Nginx配置文件详解 - 程序员自由之路 - 博客园 (cnblogs.com) Docker使用acme.sh申请ssl证书 – 萌精灵 (moeelf.com) docker安装nginx并配置ssl证书，代理宿主机服务 ","date":"2023-04-04T22:31:45+08:00","permalink":"https://blog.yexca.net/ja/archives/102/","title":"サーバーでの Docker デプロイ記録"},{"content":" 📢 この記事は gemini-3-flash-preview によって翻訳されました ソフトウェア工学シリーズ第6弾。\nソフトウェア品質っていうのは、ソフトウェアシステムや製品が、規定されたニーズや潜在的なニーズを満たしているかどうかの特徴や特性全体のことだよ。\nソフトウェア品質管理は、ソフトウェア開発プロセスに対して独立した検査を行う活動のことで、品質保証・品質計画・品質管理の3つの主要な活動で構成されているんだ。\nソフトウェア品質保証は、ソフトウェアシステムや製品がユーザーの要求を十分に満たす品質であることを保証するために、計画的・組織的に行われる活動のこと。高品質なソフトウェアを作り出すことが目的なんだ。\nソフトウェア品質特性 ソフトウェア品質について語るには、まず品質特性を理解しておく必要があるよね。今までに、ソフトウェア品質特性を記述するための品質モデルがいくつか提案されているんだ。例えば、ISO/IEC 9126 ソフトウェア品質モデルや McCall のソフトウェア品質モデルが有名だよ。\nISO/IEC 9126 ソフトウェア品質モデル ISO/IEC 9126 ソフトウェア品質モデルは3つの階層で構成されているんだ。第1層は品質特性、第2層は品質副特性、第3層は計測指標（メトリクス）だよ。\n機能性 (Functionality) 指定された条件下で、明示的または暗示的なニーズを満たす機能を提供できる能力に関する属性のこと。\n適合性 (Suitability)：指定されたタスクに対して、適切な機能セットを提供できるかどうかに関する属性。 正確性 (Accurateness)：正しい、または一致した結果や効果を得られるかどうかに関する属性。 相互運用性 (Interoperability)：他の指定されたシステムと相互に作用できる能力に関する属性。 準拠性 (Compliance)：関連する標準、規約、法規制などに準拠しているかどうかに関する属性。 機密安全性 (Security)：プログラムやデータへの不正なアクセス（意図的または偶発的）を防ぐ能力に関する属性。 信頼性 (Reliability) 指定された時間内および指定された条件下で、ソフトウェアがその性能レベルを維持できる能力に関するもの。\n成熟性 (Maturity)：ソフトウェアの故障によって引き起こされる不具合の頻度に関する属性。 障害許容性 (Fault tolerance)：ソフトウェアのエラーやインターフェース違反が発生した場合でも、指定された性能レベルを維持できる能力に関する属性。 回復性 (Recoverability)：故障発生後に性能レベルを再確立し、直接影響を受けたデータを復旧させる能力、およびそれに必要な時間と努力に関する属性。 使用性 (Usability) 利用に必要な努力や、特定のユーザー層による評価に関する一連の属性。\n理解性 (Understandability)：ユーザーが論理的な概念やその適用を理解するために費やす努力に関する属性。 習得性 (Learnability)：ユーザーが操作方法（コントロール、入力、出力など）を学ぶために費やす努力に関する属性。 運用性 (Operability)：ユーザーが操作や運用制御を行うために費やす努力に関する属性。 効率性 (Efficiency) 指定された条件下で、ソフトウェアの性能レベルと使用されるリソース量との関係に関する属性。\n時間効率性 (Time behavior)：ソフトウェアが機能を実行する際の応答時間、処理時間、およびスループットに関する属性。 資源効率性 (Resource behavior)：ソフトウェアが機能を実行する際に使用するリソースの量と、その持続時間に関する属性。 保守性 (Maintainability) 指定された修正を行うために必要な努力に関する一連の属性。\n解析性 (Analyzability)：欠陥や故障の原因の診断、または修正が必要な箇所の特定に要する努力に関する属性。 変更性 (Changeability)：修正、デバッグ、または環境の変化への適応に要する努力に関する属性。 安定性 (Stability)：修正によって予期しない影響が出るリスクに関する属性。 試験性 (Testability)：修正されたソフトウェアを確認するために必要な努力に関する属性。 移植性 (Portability) ソフトウェアがある環境から別の環境へ移転できる能力に関する一連の属性。\n適応性 (Adaptability)：異なる環境に移転する際の処理や手段に関する属性。 設置性 (Installability)：指定された環境でソフトウェアをインストールするために必要な努力に関する属性。 共存性 (Conformance)：移植性に関する標準や規約に準拠しているかどうかに関する属性。 置換性 (Replaceability)：特定のソフトウェア環境で、他の指定されたソフトウェアの代わりにそのソフトウェアを使用できる可能性と努力に関する属性。 Mc Call ソフトウェア品質モデル McCall のソフトウェア品質モデルは、ソフトウェア製品の運用、修正、移行の3つの側面から11個の品質特性を定義しているんだ。\nMcCall も3層のモデルフレームワークを提示しているよ。第1層は品質特性、第2層は評価基準、第3層は計測指標だね。\nソフトウェアレビュー 通常、「品質」は「ユーザーの満足度」として理解されることが多いよね。ユーザーに満足してもらうためには、次の2つの条件が必要なんだ。\n設計仕様書がユーザーの要求に合致していること。これを「設計品質」と呼ぶよ。 プログラムが設計仕様書通りに正しく実行されること。これを「プログラム品質」と呼ぶんだ。 設計品質のレビュー内容 設計品質レビューの対象は、要件分析フェーズで作成されたソフトウェア要件定義書、データ要件定義書、および基本設計フェーズで作成されたソフトウェア基本設計書などだよ。通常、以下のような観点からレビューを行うんだ。\nソフトウェアの仕様がユーザーの要求に合っているか評価する。つまり、全体的な設計思想や方針が明確か、要件定義書がユーザーや上層部の承認を得ているか、要件定義書と基本設計書に矛盾がないかなどをチェックするよ。 信頼性をレビューする。入力異常（エラーやオーバーロードなど）、ハードウェア故障、ソフトウェア故障による失敗を回避できるか。もし発生した場合、すぐに代替手段や回復手段をとれるかを確認するんだ。 セキュリティ対策の実施状況をレビューする。システムの利用資格のチェックが行われているかなどを確認するよ。 操作特性の実施状況をレビューする。操作コマンドや情報の適切さ、入力データと制御文の適切さ、出力データの適切さ、レスポンスタイムの適切さなどをチェックするんだ。 性能の達成状況をレビューする。規定された性能目標値に達しているかを確認するよ。 ソフトウェアに変更容易性、拡張性、互換性、移植性があるかレビューする。 ソフトウェアにテスト容易性があるかレビューする。 ソフトウェアに再利用性があるかレビューする。 プログラム品質のレビュー内容 プログラム品質レビューは、通常開発者の視点で行われるもので、開発技術に直接関係するんだ。ソフトウェア自体の構造、実行環境とのインターフェース、変更による影響などに着目して行われる活動だよ。\nソフトウェアの構造については、以下のような項目があるよ。\n機能構造。チェック項目は： データ構造 機能構造 データ構造と機能構造の対応関係 機能の汎用性 モジュールの階層 モジュール構造。階層構造が静的な構造なら、ここでは動的な構造をチェックするよ。モジュールは処理モジュールとデータモジュールの2種類に分けられ、動的構造もこの分類に関係するんだ。チェック項目は以下の通り： 制御フロー構造 データフロー構造 モジュール構造と機能構造の対応関係 処理プロセスの構造 実行環境とのインターフェース 実行環境にはハードウェア、他のソフトウェア、そしてユーザーが含まれるよ。主なチェック項目は以下の通りだね。\nハードウェアとのインターフェース。ハードウェアの仕様書に基づいた規約、故障時の処理、オーバーロード時の処理など。 ユーザーとのインターフェース。ユーザーとのインターフェース規約、つまり入力データの構造、出力データの構造、異常入力時の処理、オーバーロード時の処理、アクセス権限のチェックなど。 ソフトウェアフォールトトレランス技術 ソフトウェアの品質と信頼性を高める技術は、大きく2つに分けられるんだ。1つは「フォールトアボイダンス（障害回避）」で、開発プロセスの中でミスが入り込まないようにする技術。もう1つが「フォールトトレランス（障害許容）」で、避けられないミスがあってもその影響を最小限に抑える技術だよ。\nフォールトトレラントソフトウェアの定義 規定された機能を持つソフトウェアが、自身のミス（ソフトウェアエラー）に対してある程度の遮蔽能力を持っている場合、そのソフトウェアはフォールトトレラントソフトウェアといえる。 規定された機能を持つソフトウェアが、エラー状態から自動的に正常状態に回復できる能力を持っている場合。 エラーが発生しても、規定された機能をある程度まで継続して実行できる場合。 ある程度の耐故障能力を備えている場合。 フォールトトレランスの一般的な手法 フォールトトレランスを実現する主な手段は「冗長化」だよ。冗長化とは、システムの規定機能を実現するために、本来は余分なリソース（ハードウェア、ソフトウェア、情報、時間）を付加すること。これによって、システムの信頼性を大幅に向上させることができるんだ。冗長化技術は通常4つのカテゴリーに分けられるよ。\n構造冗長。最も一般的な技術で、動作方法によって3種類に分けられる。 静的冗長 動的冗長 ハイブリッド冗長 情報冗長。演算や転送中のエラーを検出・訂正するために、追加の情報を付加すること。 時間冗長。命令やプログラムを繰り返し実行することで、一時的なエラーの影響を取り除くこと。 冗長付加技術。上記の冗長化を実現するために必要なリソースや技術のこと。プログラム、命令、データ、それらを保存・移動するためのスペースやチャネルなどが含まれるよ。 ハードウェアエラーを遮蔽するフォールトトレランス技術では、以下のようなものが冗長付加技術にあたるんだ：\n重要なプログラムやデータの冗長保存と呼び出し。 検出、多数決（ボート）、切り替え、再構成、エラー訂正、再計算の実行。 ソフトウェアエラーを遮蔽するシステムでは、以下のような構成になるよ：\n冗長バックアッププログラムの保存と呼び出し。 エラー検出とエラー回復を実行するプログラム。 フォールトトレラントソフトウェアを実現するために必要なファームウェア。 ソフトウェアツール ソフトウェアの開発、運用、保守、管理、サポートなどの活動を補助するために使われるソフトウェアを「ソフトウェアツール」と呼ぶよ。\nソフトウェア開発ツール 開発プロセスの各活動に対応して、要件分析ツール、設計ツール、コーディング・デバッグツール、テストツールなどが存在するんだ。\nソフトウェア保守ツール 保守プロセスの活動を補助するものをソフトウェア保守ツールと呼び、コードやドキュメントの保守活動をサポートするよ。主なものとして、バージョン管理ツール、ドキュメント分析ツール、開発情報リポジトリツール、リバースエンジニアリングツール、再工学（リエンジニアリング）ツールなどがあるね。\n","date":"2023-04-03T19:59:00+08:00","permalink":"https://blog.yexca.net/ja/archives/101/","title":"ソフトウェア工学 - ソフトウェア品質とソフトウェアツール"},{"content":" 📢 この記事は gemini-3-flash-preview によって翻訳されました ソフトウェア工学シリーズの第5回目だよ。\nソフトウェアプロジェクトの成功率がすごく低い理由は、プロジェクト管理の能力が弱いからかもしれない。ソフトウェアならではの特殊性や複雑さを考慮して、プロジェクト管理の考え方をソフトウェア工学の分野に取り入れたのが「ソフトウェアプロジェクト管理」なんだ。\nソフトウェアプロジェクト管理の範囲 効果的なソフトウェアプロジェクト管理は、4つの「P」に集中するよ。つまり、人員 (Person)、製品 (Product)、プロセス (Procedure)、そしてプロジェクト (Project) だね。\nソフトウェアプロジェクトの見積もり ソフトウェアプロジェクトの見積もりには、人、技術、環境などいろんな要素が絡んでくる。だから、見積もりをサポートするための方法や技術が必要なんだ。よく使われる見積もり方法は次の3つだよ。\nすでに完了した類似プロジェクトをもとに見積もる 分解技術を使って見積もる 経験則に基づいた見積もりモデルを使う。代表的なものには IBM モデル、CoCoMo モデル、Putnam モデルがあるよ これらの方法は、見積もりの精度を上げるために組み合わせて使うこともあるんだ。\nCOCOMO 見積もりモデル COCOMO モデルは、正確で使いやすいコスト見積もりモデルだよ。詳細度によって、基本 COCOMO モデル、中間 COCOMO モデル、詳細 COCOMO モデルの3つに分けられるんだ。\n基本 COCOMO モデル 基本 COCOMO モデルは、システム全体をひとまとめに見積もる静的な単一変数モデルだよ。\n式はこんな感じ：\nE=a(L)b D=cEd ここで、E は工数（人月）、D は開発期間（月）、L はソースコードの行数（千行単位、コメントやドキュメントは含まない）、a、b、c、d は定数だよ。\n基本モデルでは、コード行数 L を見積もることで、開発工数と期間を計算できるんだ。\n中間 COCOMO モデル 中間 COCOMO モデルは静的な多変数モデルで、ソフトウェアシステムをシステムとコンポーネントの2つの階層に分けるんだ。ソフトウェア開発に必要な人員（コスト）を、プログラムの規模と一連の「コスト駆動属性」の関数として捉えるよ。\n中間モデルは基本モデルをベースに、15種類の工数に影響する要因を考慮しているんだ。工数調整係数 (EAF) を使って見積もりを修正することで、より合理的な数値を出せるようになっているよ。\n式はこれ：\nE=a(L)bEAF L は目的のコード行数（千行単位）、a と b は定数だよ。\n詳細 COCOMO モデル これはシステム、サブシステム、モジュールの3階層に分けるモデルだよ。中間モデルの要因に加えて、要件分析やソフトウェア設計といった各工程におけるコスト駆動属性の影響も考慮するんだ。\nCOCOMOII モデル 最初の COCOMO モデルは業界で広く使われてきたけど、今はもっと包括的な「COCOMOII」へと進化しているよ。これも階層構造になっていて、3つの段階別モデルがあるんだ。\nアプリケーション合成モデル：プロジェクトの初期段階で使う。UIのプロトタイプ開発や、システム間のやり取り、性能評価、技術の成熟度が重要な時期だね。 初期設計段階モデル：要件が固まって、基本的なアーキテクチャができた段階で使うよ。 アーキテクチャ段階モデル：実際にソフトウェアを構築している最中に使うんだ。 他のモデルと同じく、COCOMOII も規模の見積もりが必要だけど、オブジェクト点、機能点、コード行数の3つの選択肢があるよ。アプリケーション合成モデルではオブジェクト点、初期設計では機能点（コード行数に変換可能）を使うのが一般的だね。\n進捗管理 進捗管理の目的は、ソフトウェアプロジェクトを決められた期限内に終わらせることだよ。\n進捗管理の基本原則 分割 相互依存性 時間配分 工数の確認 責任の確定 出力結果の明確化 マイルストーンの設定 スケジュール作成 スケジュールを立てる時によく使われる図には、ガントチャート (Gantt Chart) と PERT 図 (Program Evaluation \u0026amp; Review Technique) があるよ。\nガントチャート ガントチャートはシンプルな水平の棒グラフで、カレンダーを基準にタスクを表示するんだ。横軸が時間（日、週、月など）で、縦軸にタスク名が並ぶよ。棒の長さがタスクの期間を表していて、同じ時間帯に複数の棒があれば、それは並行して作業していることを意味するんだ。\nガントチャートは、いつ始まっていつ終わるか、進み具合はどうか、並行作業があるかどうかがひと目で分かるのがメリット。ただ、タスク同士の依存関係が見えにくかったり、クリティカルパス（プロジェクト全体の鍵となる部分）が分かりにくかったりするのが弱点かな。\nPERT 図 PERT 図は有向グラフで、矢印がタスクを表すよ。矢印にはタスク完了に必要な時間を書き込むことができるんだ。結節点（ノード）はタスクの終了や開始を表す「イベント」と呼ばれるよ。そのノードに入るすべてのタスクが終わらないと、次のタスクは始められないんだ。イベント自体は時間もリソースも消費しない、単なる「時点」を指すよ。\n各イベントには番号があり、そのイベントの「最早時刻」と「最遅時刻」が設定されるんだ。最早時刻より前には次のタスクは始められないし、最遅時刻までに始めないとプロジェクト全体が遅れちゃう。また、各タスクには「バッファ時間（スラックタイム）」があって、工期に影響を与えずにどれくらい遅らせられるかが分かるようになっているよ。\nPERT 図は、タスク間の関係やクリティカルパスを見つけるのに役立つけど、並行関係を直感的に把握するのはちょっと苦手なんだ。\nソフトウェア構成管理 ソフトウェア構成管理（SCM）の主な目標は、変更の識別、変更制御、バージョン管理、変更が正しく実装されたかの確認、そして変更の報告だよ。\n内容としては、バージョン管理、構成サポート、変更サポート、プロセスサポート、チームサポート、変更報告、監査サポートなんかが含まれる。\nまた、構成データベースは次の3つに分類されるよ：\n開発ライブラリ：開発者が使う用。頻繁に変更されるし、管理もゆるめ。 受控ライブラリ（管理ライブラリ）：ある段階が終わった時にリリースされる成果物を入れる場所。これがいわゆる「ソフトウェア構成ライブラリ」で、しっかり管理されるよ。 製品ライブラリ：テストが終わって、最終製品としてユーザーに渡す準備ができたものを入れる場所。 リスク管理 ソフトウェアのリスクには「不確実性」と「損失」という2つの特徴があると考えられているよ。不確実性は起こるかどうかわからないこと、損失はもし起こったらひどい結果になること。リスク分析では、この不確実さと損失の度合いを数値化することが大事なんだ。\nプロジェクトリスクは、プロジェクト計画を脅かすもの。予算、スケジュール、人員、リソース、要件などの潜在的な問題だね。\n技術リスクは、ソフトウェアの品質や納期を脅かすもの。設計、実装、インターフェース、保守などの問題だよ。技術が難しすぎたり、新しすぎたりする場合に起こりやすいんだ。\nビジネスリスクは、ソフトウェアの生存能力を脅かすもの。主に次の5つがあるよ：\n市場リスク：誰も欲しがらない良いものを作っちゃう。 戦略リスク：会社の戦略に合わなくなる。 販売リスク：営業が売り方を知らない。 管理リスク：上層部のサポートが得られなくなる。 予算リスク：お金や人が確保できなくなる。 (一) リスク識別 リスク識別は、計画に対する脅威をシステム的に見つけ出す作業だよ。既知のリスクや予測可能なリスクを見つけたら、まずは回避し、無理ならコントロールすることを考えるんだ。\n一つの方法は「リスク項目チェックリスト」を作ること。次のような項目を確認するよ。\n製品規模 ビジネスへの影響 顧客の特性 プロセスの定義度 開発環境 開発技術 人員の能力と経験 リスクの要因としては、性能、コスト、サポート、スケジュールなどが挙げられるね。\n(二) リスク予測 リスク予測（見積もり）では、「発生する確率」と「発生した時の影響」の2点から評価するよ。\n(1) 予測のステップ 発生確率の尺度を決める 起こる結果を記述する プロジェクトや製品への影響を見積もる 誤解がないように、予測の精度を明記する 簡単な方法として「リスク表」を作るのがいいよ。リスクの種類、確率、影響度（1：破滅的 〜 4：無視できる）を並べるんだ。\n(2) 影響の評価 影響を決めるのは、リスクの本質、範囲、時間だよ。 全体の「リスク露出度 (Risk Exposure, RE)」は、次の式で計算できるんだ。\nRE = P × C P は確率、C はコスト（影響）だね。\n(三) リスク評価 リスク評価では、(Ri, li, xi) という三元組を作るよ（リスク、確率、影響）。 大事なのは「リスク参照水準」を決めること。コストオーバー、スケジュールの遅れ、性能低下のどれかが一定のラインを超えたら「プロジェクト中止」となるような基準を持つことだね。\n(四) リスクコントロール リスクコントロールは、リスクに対処する戦略を立てること。\n(1) リスク回避 一番いいのは、起こる前に原因を分析して対策することだよ。 例えば「激しい人員流動」というリスクがあるなら、労働条件を改善したり、誰かが辞めても仕事が止まらないように情報を共有したり、バックアップの担当を決めたりする戦略が考えられるね。\n(2) リスク監視 リスクが高まっていないか、常にチェックすること。チームの雰囲気や、メンバー同士の関係、報酬への不満などを見ておくんだ。\n(3) RMMM 計画 これらをまとめたのが「リスク緩和・監視・管理計画 (RMMM 計画)」だよ。 プロジェクトが始まったら、この計画に沿ってリスクを追いかける。リスクが実際に起きたか確認し、対策が正しく行われているかをチェックして、将来のためにデータを集めるんだ。\n何か問題が起きた時、複数のリスクが絡んでいることも多いから、「どのリスクが原因でこの問題が起きたのか」を突き止めるのも大事な仕事だよ。\n","date":"2023-04-02T06:58:00+08:00","permalink":"https://blog.yexca.net/ja/archives/100/","title":"ソフトウェア工学 - ソフトウェアプロジェクト管理"},{"content":" 📢 この記事は gemini-3-flash-preview によって翻訳されました ソフトウェアエンジニアリング・シリーズの第4回。\nソフトウェア保守は、ソフトウェアライフサイクルの最後のフェーズで、システムが本番稼働に入った後の時期のこと。だから、システム開発プロセスそのものには含まれないんだ。ソフトウェア保守っていうのは、ソフトウェアをリリースした後に、エラーを直したり新しいニーズに応えたりするためにソフトウェアを修正するプロセスのこと。つまり、リリース後に行われるすべての変更のことだよ。\nシステム保守性の概念 システムの保守性は、メンテナンスする人がそのソフトウェアをどれだけ理解し、修正や変更、改善がしやすいかっていう「難易度」で定義される。保守性を高めることは、ソフトウェア開発の全ステップにおいてめちゃくちゃ重要な目的。システムがちゃんとメンテナンスできるかどうかは、「システム保守性」っていう指標で測れるんだ。\nシステム保守性の指標 可理解性（Understandability）: 他人がシステムの構造やインターフェース、機能、内部プロセスをどれだけ簡単に理解できるかってこと。モジュール化や詳細設計ドキュメント、構造化設計、優れたプログラミング言語なんかを使うと、理解しやすくなるよ。 可テスト性（Testability）: 診断やテストのしやすさは、理解のしやすさに直結する。良いドキュメントがあれば診断やテストに役立つし、プログラムの構造や高性能なテストツール、しっかり計画されたテスト手順もすごく大事。だから、開発者は設計やプログラミングの段階から、診断やテストがしやすいように作っておく必要があるんだ。あと、システム保守のときは、テスト段階で保存しておいたテストケースをフル活用すべきだね。 可修正性（Modifiability）: 診断やテストのしやすさは、設計原則と深く関わっている。モジュールの結合、内聚（凝集度）、スコープとコントロールの関係などが、修正のしやすさに影響するんだ。 保守とソフトウェアドキュメント ドキュメントは、ソフトウェアの保守性を決める決定打。長く使われる大規模システムは、使っているうちに何度も修正されるから、ドキュメントが本当に重要になるんだ。\nソフトウェアシステムのドキュメントは、「ユーザードキュメント」と「システムドキュメント」の2種類に分けられる。ユーザードキュメントは主にシステムの機能や使い方の説明で、中身がどう実装されているかは気にしない。システムドキュメントは、設計や実装、テストといったあらゆる側面を記述するものだよ。\n保守性はすべてのソフトウェアが持つべき基本特性。開発段階から保守性を確保しておかなきゃいけない。ソフトウェアエンジニアリングのあらゆる段階で保守性を考慮して高めていくべきだし、各フェーズ終了前の技術レビューや管理レビューでは、保守性を重点的にチェックする必要があるよ。\nソフトウェアドキュメント 質の高いドキュメントを書くことは、ソフトウェア開発の質そのものを向上させる。\nドキュメントもソフトウェアの一部。ドキュメントのないソフトウェアは、ソフトウェアとは呼べないんだ。\nドキュメント作成は、ソフトウェア開発の中でかなり大きな比重を占めている。高品質なドキュメントは、ソフトウェア製品の価値にとってすごく大きな意味を持つよ。\nシステム保守の内容とタイプ システム保守は主に、ハードウェア保守、ソフトウェア保守、データ保守の3つ。\nハードウェア保守 ハードウェア保守は、専任のハードウェア保守担当者が責任を持つ。\nソフトウェア保守 ソフトウェア保守は、ニーズの変化やハードウェア環境の変化に合わせて、アプリケーションを部分的または全面的に修正すること。修正するときはソースコードをフル活用して、修正後はプログラム修正登録表を記入し、プログラム変更通知書に新旧プログラムの違いを明記するんだ。\nソフトウェア保守の内容には、主に以下の4つの側面があるよ。\n正確性保守: 開発中に見つかったけど、テスト段階ではまだ見つかっていなかったエラーを直すこと。 適応性保守: IT技術の変化や管理上のニーズの変化に合わせて、ソフトウェアを修正すること。 完全性保守: 機能を拡張したり性能を良くしたりするための修正。主に、分析・設計段階では決まっていなかった機能や性能を追加することを指すよ。 予防的保守: 信頼性や保守性を向上させるため、あるいは将来のハード・ソフト環境の変化に備えて、先回りして新しい機能を追加すること。システムが時代遅れにならないようにするためだね。 データ保守 データ保守は主にデータベース管理者（DBA）が担当する。データベースの安全性や整合性、そして排他制御（コンカレンシー制御）の管理を行うよ。\nソフトウェアの品質特性 信頼性、可用性、保守性はソフトウェアの品質特性。ソフトウェアエンジニアリングでは、0から1の間の数値で測定するよ。\n信頼性は、特定の時間内に、特定の条件下でシステムが故障せずに動作する確率。MTTF / (1 + MTTF) で測定できる。MTTFは平均故障時間（Mean Time To Failure）のこと。\n可用性は、特定の時点で、システムが仕様通りに正しく動作している確率。MTBF / (1 + MTBF) で測定できる。MTBFは平均故障間隔（Mean Time Between Failures）のこと。\n保守性は、決められた使用条件で、特定の時間内に決められたプロセスとリソースを使って保守活動が完了する確率。1 / (1 + MTTR) で測定できる。MTTRは平均修復時間（Mean Time To Repair）のこと。\n","date":"2023-03-31T07:57:00+08:00","permalink":"https://blog.yexca.net/ja/archives/99/","title":"ソフトウェアエンジニアリング - システム保守の概要"},{"content":" 📢 この記事は gemini-3-flash-preview によって翻訳されました ソフトウェア工学シリーズの第3回目だよ。\nシステムテストの意義、目的、および原則 システムテストは、エラーを見つけるためにプログラムを実行するプロセスのことだよ。成功するテストとは、まだ発見されていないエラーを見つけ出したテストのことなんだ。\nテストの目的は、最小限の労力と時間で、潜在的なあらゆるエラーや欠陥を見つけ出すこと。ユーザーは、開発の各段階での要件や設計ドキュメント、あるいはプログラムの内部構造に基づいてテスト用例（テストケース）を慎重に設計し、それらを使ってプログラムを動かしてエラーを見つける必要があるよ。\n情報システムのテストには、ソフトウェアテスト、ハードウェアテスト、ネットワークテストが含まれるべきだね。ハードウェアやネットワークのテストは具体的な性能指標に基づいて行われるけど、ここで言う「テスト」は主にソフトウェアテストを指しているよ。\nシステムテストは、システムの品質と信頼性を保証するための重要なステップで、システム分析、システム設計、実施という開発プロセス全体の最終チェックでもあるんだ。テストの概念と目的に基づいて、システムテストを行うときは以下の基本原則に従おう。\n早めに、そして継続的にテストを行うこと。 テストはアプリの開発が終わってからやるものじゃないんだ。問題の複雑さや開発段階の多様性、メンバー間の調整不足なんかで、どの段階でもエラーは発生しうる。だから、テストは開発の全段階を通して行い、早めにエラーを修正して火種を消しておくのが大事だよ。 開発者本人やそのチームがテストを行うのは避けること。 開発者は自分の仕事を否定したくないし、「自分の作ったソフトに間違いはない」と思いがちだからね。それに、自分のプログラミングの思考回路に引きずられてテストの視点が偏ってしまうこともある。客観的で効果的なテストにするために、専門の担当者が行うのがベストだよ。 テスト計画を立てる時は、入力データだけでなく、期待される出力結果も決めておくこと。 実際の出力と期待値を比べることで、正しく動いているかどうかがわかるからね。 妥当で合理的な入力条件だけでなく、不合理なものや無効な入力条件もテストケースに含めること。 人はどうしても「正しく動くはず」のケースばかりテストしがちだけど、異常な事態や予想外のケースにこそ落とし穴があるんだ。 プログラムが「すべきこと」をしているかだけでなく、「すべきでないこと」をしていないかも確認すること。 余計な動作はサイドエフェクト（副作用）を生んだり、効率を下げたり、時には潜在的な害やエラーを引き起こすことがあるよ。 テスト計画に厳格に従い、行き当たりばったりのテストは避けること。 計画には内容、スケジュール、担当者、環境、ツール、資料などを盛り込もう。計画通りに進めることで、全体の足並みを揃えることができるよ。 テスト計画やテストケースは、ソフトウェアドキュメントの一部として大切に保管すること。 後のメンテナンスで役に立つからね。 テストケースは再利用できるように設計すること。 エラー修正後や機能追加後の再テスト（リポジトリテスト）は繰り返し作業が多いから、以前のケースを使い回したり修正したりできれば効率的だよ。 システムテスト段階のテスト目標は、要件分析段階から導き出されるものなんだ。\n伝統的なソフトウェアのテスト戦略 効果的なソフトウェアテストは、実際には「ユニットテスト」「統合テスト」「確認テスト」「システムテスト」の4つのステップで行われるよ。\n(一) ユニットテスト ユニットテスト（単体テスト）はモジュールテストとも呼ばれていて、モジュールのコーディングが終わってコンパイルエラーがなくなったらすぐに始められるよ。モジュール内部の処理ロジックやデータ構造に焦点を当てるんだ。マシンを使う場合は、一般的にホワイトボックステスト法が使われるよ。複数のモジュールを同時にテストすることも可能だね。\n(1) ユニットテストのテスト内容 ユニットテストでは、主にモジュールの以下の5つの特徴をチェックするよ。\nモジュールインターフェース。 データが正しく出入りしているかを確認するよ。 入力引数と仮引数の個数、型、単位が一致しているか。 他のモジュールを呼び出す際の実引数と仮引数が一致しているか。 標準関数を使う時の引数の型、数、順序が正しいか。 グローバル変数の定義と使い方が各モジュールで一致しているか。 入力が仮引数だけを変えていないか。 I/O（入出力）の形式が文と一致しているか。 ファイルの使用前後で適切にオープン/クローズされているか。 局所データ構造。 ここでのミスはよくあることだから、重点的にチェックしよう。 変数の宣言が適切か。 値が入っていない、または初期化されていない変数を使っていないか。 初期値やデフォルト値が正しいか。 変数名の間違い（スペルミスなど）はないか。 重要な実行パス。 パスのテストは基本中の基本。全部のパスを試すのは無理だから、計算、比較、制御フローのエラーを見つけられるようなテストケースを工夫して作ろう。 計算ミス：演算の優先順位、精度不足、型の不一致、アルゴリズムの間違いなど。 比較・制御フロー：精度のせいで一致しない、異なる型の比較、論理演算子の間違い、ループの終了条件ミス（1回多い、少ない）、無限ループ、ループ変数の不適切な書き換えなど。 エラー処理。 良い設計はエラーを予測し、それを処理するパスを持っているものだよ。エラーメッセージが出るだけでなく、その後のロジックが正しいことも大事なんだ。 境界条件。 境界条件のテストはユニットテストの仕上げであり、とても重要だよ。ソフトウェアは境界部分でエラーが起きやすいからね。 (2) ユニットテストのプロセス モジュールは単独では動かないから、呼び出し関係を再現するために2種類の補助モジュールを作る必要があるよ。\nドライバ (Driver)。 メインプログラムのような役割で、テストデータを受け取ってテスト対象のモジュールに渡し、結果を出力するよ。 スタブ (Stub)。 テスト対象モジュールが呼び出している下位モジュールの代わりをするもの。入り口のチェックや、呼び出し・戻りの情報を出力したりするよ。 モジュールの内聚度（結合度）を高めると、ユニットテストは楽になるよ。各モジュールが一つの機能に集中していれば、テストケースも減らせるし、エラーも見つけやすくなるんだ。\n(二) 統合テスト 統合テスト（結合テスト）は、システム設計書に従って各モジュールを組み合わせて行うテストだよ。個別のモジュールがパスしていても、組み合わせた途端に問題が出ることはよくあるんだ。\nやり方は大きく分けて2つ。\n非増分統合： 全部バラバラにテストしてから、一気にガッチャンコしてテストする。 増分統合： 少しずつ組み合わせて、段階的に作ってテストしていく方法。 増分統合にはいくつかの戦略があるよ。\n(1) トップダウン統合テスト 構造の上（メインプログラム）から順に、階層を降りながら組み合わせていく方法。深さ優先（Depth-first）か幅優先（Breadth-first）で進めるよ。\nメインモジュールをドライバとして使い、その下のモジュールをスタブに置き換える。 実際のモジュールを一つずつスタブと入れ替えていく。 入れ替えるたびにテストを行う。 回帰テストを行って、新しいエラーが出ていないか確認する。 全部終わるまで繰り返す。 ドライバを作る必要はないけど、スタブをたくさん作る必要があるよ。\n(2) ボトムアップ統合テスト 一番下のモジュール（原子モジュール）から順に組み合わせていく方法。下から順に作っていくから、スタブを作る必要がないんだ。\n低層のモジュールを組み合わせて「クラスター」を作る。 テスト用のドライバを作る。 クラスターをテストする。 ドライバを外して、上の階層へ組み合わせていく。 スタブはいらないけど、ドライバを作る必要があるよ。\n(3) 回帰テスト (Regression Testing) 新しいモジュールを追加すると、データの流れが変わったり、思わぬところに影響が出たりすることがある。回帰テストは、変更によって「今まで動いていた機能」が壊れていないかを確認するために、テスト済みの項目をもう一度やり直すことだよ。\n手動で行うこともあるし、自動化ツール（キャプチャ/リプレイツール）を使うこともあるね。全部やり直すと大変すぎるから、代表的なケースや影響を受けそうな機能に絞って行うのが現実的だよ。\n(4) スモークテスト 開発中によく行われる統合テストの一種で、主要な機能がとりあえず動くかどうかをサクッと確認するものだよ。頻繁に評価することで、プロジェクトの状態を把握しやすくするんだ。\nテスト方法 ソフトウェアテストには、大きく分けて「静的テスト」と「動的テスト」があるよ。\n静的テスト。 プログラムを動かさずに、人間がチェックしたりツールで分析したりする方法。 人手によるチェック：コードレビューやインスペクションなど。 コンピュータ支援静的分析：分析ツールを使って、ロジックの欠陥や疑わしい構造を抽出するよ。 動的テスト。 実際にプログラムを動かしてエラーを見つける方法。これには「ブラックボックステスト」と「ホワイトボックステスト」があるよ。 テストケースは「入力データ」と「期待される結果」のセットで作るんだ。\n(一) ブラックボックステスト 機能テストとも呼ばれるよ。中身（コード）がどうなっているかは気にせず、外側から見た機能や仕様が正しいかをチェックするんだ。\n主な手法は以下の通り。\n(1) 等価類分割 (等価分割法) 入力データを、同じ結果が得られるはずのグループ（等価類）に分けて、各グループから代表的なデータを一つ選んでテストする方法。効率よくテストできるよ。有効なデータ（有効等価類）と無効なデータ（無効等価類）の両方を考えるのがコツ。\n(2) 境界値分析 エラーは入力の端っこ（境界）で起きやすいから、そこを重点的に狙う方法。等価分割と組み合わせて使うことが多いよ。\n(3) エラー推測 経験や勘を頼りに、「ここらへんが怪しいな」という部分を狙い撃ちする方法。過去のミスなどをリストアップしてテストケースを作るよ。\n(4) 因果グラフ 仕様書から「原因（入力）」と「結果（出力）」の関係を整理して、判定表（デシジョンテーブル）に落とし込んでテストケースを作る方法だよ。\n(二) ホワイトボックステスト 構造テストとも呼ばれるよ。プログラムの内部ロジックやパスが設計通りになっているかをチェックするんだ。\n主な原則は：\n全ての独立したパスを少なくとも1回は実行する。 全ての論理判定で「真」と「偽」の両方を少なくとも1回は実行する。 ループの境界や一般的な条件をチェックする。 内部データ構造の有効性を確認する。 (1) 論理網羅 (ロジックカバレッジ) どの程度ロジックをカバーしたかを示す指標がいくつかあるよ。\n命令網羅 (Statement Coverage)。 全ての文を1回は通る。一番弱い。 判定網羅 (Decision/Branch Coverage)。 各判定の「真」「偽」を少なくとも1回は通る。 条件網羅 (Condition Coverage)。 判定文の中にある個々の条件式が「真」「偽」の両方を取るようにする。 判定/条件網羅。 判定そのものの「真/偽」と、中の個々の条件の「真/偽」の両方を満たす。 条件組合せ網羅。 判定内の条件のあらゆる組み合わせをテストする。 経路網羅 (Path Coverage)。 あり得る全てのパスを通る。一番強い。 (2) ループ網羅 ループ内の各条件が検証されるようにテストするよ。\n(3) 基本経路テスト プログラムのフローグラフを分析して、基本的な実行パスの集合を導き出し、そこからテストケースを作る方法だよ。\nデバッグ デバッグはテストの後にやる作業で、見つかったエラーの原因と場所を特定して、修正すること。\nよく使われる手法はこんな感じ。\n(1) 試行錯誤法 (Brute Force) エラーの症状から場所を推測して、出力文（printデバッグ）を入れたりメモリの中身を見たりして、一歩ずつ原因に迫る方法。\n(2) バックトラッキング法 (回溯法) エラーが出た場所からコードを逆に辿っていって、どこでおかしくなったかを見つける方法。\n(3) 二分探索法 (対分查找法) 正しい値がわかっている地点にチェックポイントを置いて、エラーの範囲を半分ずつ絞り込んでいく方法。\n(4) 帰納法 (帰納法) 起きた問題のデータを集めて、それらの関係性を分析し、「これが原因じゃないか？」という仮説を立てて証明していく方法。\n(5) 演繹法 (演繹法) 考えられる原因を全部リストアップして、矛盾するものやあり得ないものを消去法で消していき、残った可能性の高い原因を検証する方法だよ。\n","date":"2023-03-29T19:56:57+08:00","permalink":"https://blog.yexca.net/ja/archives/98/","title":"ソフトウェア工学 - システムテスト"},{"content":" 📢 この記事は gemini-2.5-flash によって翻訳されました ソフトウェア工学シリーズ記事その2\nソフトウェアのライフサイクル 実現可能性分析とプロジェクト開発計画 要件分析 概要設計 詳細設計 コーディング テスト 保守 ソフトウェア要件 要件をヒアリングする前に、まず「何をヒアリングする必要があるのか」、つまり「要件にどんな内容が含まれるのか」を明確にしとこうね。ソフトウェア要件っていうのは、ユーザーが目標とするソフトウェアシステムに対して機能、振る舞い、性能、設計上の制約なんかに関して期待してることだよ。\n機能要件。システムが何をすべきか、いつ行うか、いつ、どのように修正またはアップグレードするかを考えるよ。 性能要件。ソフトウェア開発における技術的な指標を考えるんだ。例えば、記憶容量の制限、実行速度、応答時間、スループットなんかだね。 ユーザーまたは人的要因。ユーザーのタイプを考えるよ。例えば、様々なユーザーのコンピューター使用の習熟度、必要なトレーニング、システムの理解・使用の難しさ、ユーザーによるシステム誤操作の可能性なんかがこれに当たるね。 環境要件。将来のソフトウェアが使われる環境、つまりハードウェアとソフトウェアの両方を考えるよ。ハードウェアデバイスへの要件としては、機種、周辺機器、インターフェース、場所、配置、湿度、磁場干渉なんかがある。ソフトウェアへの要件は、OS、ネットワーク、データベースなんかがそうだね。 インターフェース要件。他のシステムからの入力、他のシステムへの出力、データ形式に関する特別な規定、データ記憶媒体に関する規定を考えるよ。 ドキュメント要件。どんなドキュメントが必要で、どの読者を対象にするかを考えるんだ。 データ要件。入出力データの形式、データの送受信頻度、データの正確性と精度、データトラフィック、データを保持する必要がある期間なんかを考えるんだ。 リソース使用要件。ソフトウェア実行時に必要となるデータ、他のソフトウェア、メモリ空間なんかのリソース。それに、ソフトウェア開発・保守に必要な人材、サポートソフトウェア、開発設備なんかも考慮するよ。 セキュリティ・機密保持要件。システムやシステム情報へのアクセスを制御する必要があるか、ユーザーデータを隔離する方法、ユーザープログラムが他のプログラムやOSからどのように隔離されるか、システムバックアップ要件なんかを考えるんだ。 信頼性要件。システムの信頼性要件を考えるよ。システムがエラーを検出・隔離する必要があるか、エラー発生後にシステムを再起動するまでの許容時間なんかもそうだね。 ソフトウェアコストと開発進捗要件。開発に定められたスケジュールがあるか、ソフトウェア/ハードウェア投資に制限があるかなどを考えるよ。 その他の非機能要件。例えば、特定の開発モデルの採用、品質管理基準、マイルストーンとレビュー、受け入れ基準、様々な品質要件の優先順位の決定、保守性に関する要件なんかがこれに当たるね。 システム設計 システム設計の主な目的は、システムの青写真を描くことなんだ。様々な技術や実装方法のメリット・デメリットを比較検討し、慎重に設計して、様々なリソースを合理的に使いながら、最終的に新しいシステムの詳細な設計案を練り上げていくんだよ。\n概要設計 開発者は、確定した各機能要件を必要なアーキテクチャに変換するんだ。\n1. ソフトウェアシステム全体構造の設計 その基本的な任務は、ある設計手法を使って、複雑なシステムを機能ごとにモジュールに分割することだよ。各モジュールの機能を決めたり、モジュール間の呼び出し関係、モジュール間のインターフェース（つまりモジュール間でやり取りされる情報）を決めたり、モジュール構造の品質を評価したりするんだ。\nソフトウェアシステム全体構造の設計は、概要設計における重要なステップで、次の詳細設計やコーディング作業に直接影響するんだ。ソフトウェアシステムの品質や全体的な特性は、この全体構造の設計段階で決まるんだよ。\n2. データ構造とデータベース設計 (1) データ構造の設計 データ構造の設計にも、段階的に詳細化していく方法が当てはまるんだ。要件分析の段階で、データ辞書を使ってデータの構成、操作制約、データ間の関係なんかを記述して、データ構造の特性を確定したよね。概要設計段階ではそれをさらに詳細化し、詳細設計段階で具体的な実装の詳細を規定するんだ。概要設計段階では、抽象データ型を使うのがおすすめだよ。\n(2) データベースの設計 データベースの設計っていうのは、データ記憶ファイルのデザインのことで、主に次の側面の設計を行うよ。\n概念設計。データ分析に基づいて、ボトムアップ方式でユーザー視点からビュー設計を行うんだ。一般的にはE-Rモデルを使ってデータモデルを表現するよ。E-Rモデルはデータベース設計の基礎であると同時に、データ構造設計の基礎でもあるんだ。 論理設計。E-Rモデルはデータベース管理システム（DBMS）とは独立してるから、具体的なDBMSの特性に合わせてデータベースの論理構造を構築する必要があるんだ。 物理設計。異なるDBMSでは、物理環境が異なり、提供されるストレージ構造やアクセス方法もそれぞれ違うんだ。物理設計っていうのは、データ項目の記憶要件、アクセス方法、インデックスの作成なんかといったデータモデルの物理的な詳細を設計することだよ。 3. 概要設計ドキュメントの作成 ドキュメントには主に、概要設計説明書、データベース設計説明書、ユーザーマニュアル、そして改訂版テスト計画があるよ。\n4. レビュー 設計部分が要件で規定された機能、性能なんかを完全に実現しているか、設計方法の実現可能性、重要な処理や内外インターフェース定義の正確性、有効性、各部分間の一貫性なんかを一つ一つレビューするんだ。\n詳細設計 各モジュールについて詳細なアルゴリズム設計を行うよ。ある種の図形、表、言語なんかを使って、各モジュールの処理過程の詳細なアルゴリズムを記述するんだ。 モジュール内のデータ構造を設計するよ。 データベースの物理設計を行う、つまりデータベースの物理構造を決定するんだ。 その他の設計。ソフトウェアシステムの種類によっては、さらに以下の設計が必要になることもあるよ。 コード設計。データの入力、分類、保存、検索などの操作を効率化し、メモリ空間を節約するために、データベース内の特定データ項目の値についてコード設計を行うんだ。 入出力フォーマット設計 ユーザーインターフェース設計 詳細設計説明書を作成するよ。 レビュー。処理過程のアルゴリズムとデータベースの物理構造の両方をレビューするんだ。 システム設計の結果は、一連のシステム設計ファイルだよ。これらのファイルは、情報システム（ハードウェア機器やソフトウェアプログラムの作成を含む）を物理的に実装するための重要な基礎となるんだ。\n","date":"2023-03-29T17:04:45+08:00","permalink":"https://blog.yexca.net/ja/archives/97/","title":"ソフトウェア工学 - 要件分析とシステム設計"},{"content":" 📢 この記事は gemini-2.5-flash によって翻訳されました ソフトウェア工学シリーズ記事 その1\nソフトウェアプロセス ソフトウェア開発で従うロードマップを「ソフトウェアプロセス」って呼ぶんだ。\n能力成熟度モデル (CMM) CMMはソフトウェアプロセス改善を次の5つの成熟度レベルに分けるよ。\n初期レベル (Initial) ​\tソフトウェアはめちゃくちゃで、時には混乱することもある。明確に定義された手順はほとんどなく、プロジェクトの完了は完全に個人の努力とヒーロー的なキーパーソンの役割にかかっているんだ。\n反復可能レベル (Repeatable) ​\tプロジェクトの費用、スケジュール、機能特性を追跡するための基本的なプロジェクト管理プロセスと実践が確立されていて、以前の類似プロジェクトでの成功を繰り返すために必要なプロセスガイドラインがあるんだ。\n定義済みレベル (Defined) ​\t管理面と工学面の両方のソフトウェアプロセスが文書化、標準化されて、ソフトウェア開発組織全体の標準ソフトウェアプロセスに統合されている状態だね。すべてのプロジェクトは、実際の状況に合わせて修正された標準ソフトウェアプロセスを使ってソフトウェアを開発・保守するんだ。\n管理済みレベル (Managed) ​\tソフトウェアプロセスと製品品質の詳細な測定基準が定められているんだ。ソフトウェアプロセスの製品品質は、開発組織のメンバーに理解されていて、制御されているよ。\n最適化レベル (Optimized) ​\t定量分析が強化されていて、プロセス品質のフィードバックと新しいアイデアや技術からのフィードバックを通じて、プロセスが継続的に改善され続けるんだ。\nCMMモデルは、ソフトウェアプロセス改善の進化ステップを5つの成熟度レベルに編成するフレームワークを提供してくれて、プロセスの継続的な改善のための段階的な基盤を築いているよ。この5つの成熟度レベルは、組織のソフトウェアプロセス成熟度を測定し、そのソフトウェアプロセス能力を評価するために使われる、順序だった尺度を定義しているんだ。\n能力成熟度モデル統合 (CMMI) CMMの成功で、様々な分野に適用できるモデルがたくさん生まれたんだけど、一つのプロジェクトで複数の分野が絡むこともよくあるから、いろんなプロセス改善の取り組みを統合する必要があったんだ。CMMIは、いくつかのプロセスモデルを統合して改善したものだよ。\nCMMIには、ステージング型モデルと連続型モデルの2つの表現方法があるよ。\n1. ステージング型モデル ステージング型モデルの構造はCMMに似ていて、組織の成熟度に焦点を当てているんだ。CMMI-SE/SW/IPPD バージョン1.1には、5つの成熟度レベルがあるよ。\n初期：プロセスが予測不能で、コントロールが効かない。 管理済み：プロセスがプロジェクトに貢献している。 定義済み：プロセスが組織全体に貢献している。 定量的管理済み：プロセスが測定され、制御されている。 最適化：プロセス改善に集中している。 2. 連続型モデル 連続型モデルは、それぞれのプロセス領域の能力に注目するモデルだ。組織は、異なるプロセスに対して異なるプロセス領域能力レベル (Capability Level, CL) を達成できるんだ。CMMIには6つのプロセス領域能力レベルが含まれていて、レベル番号は0から5まであるよ。能力レベルには共通目標とそれに関連する共通プラクティスが含まれていて、これらのプラクティスはプロセス領域内の特定目標やプラクティスに追加されるんだ。組織がプロセス領域の特定目標と共通目標を満たしたとき、その組織はそのプロセス領域の能力レベルを達成したって言われるんだね。\nCL0 (未完了)：プロセス領域が実行されていないか、CL1で定義されたすべての目標を達成していない。 CL1 (実行済み)：その共通目標は、プロセスが識別可能な入力作業成果物を識別可能な出力作業成果物に変換して、プロセス領域をサポートする特定目標を達成することだ。 CL2 (管理済み)：その共通目標は、管理されているプロセスの制度化に集中しているよ。組織レベルのポリシーに基づいて、プロセスの運用でどのプロセスを使うかが規定されていて、プロジェクトは文書化された計画とプロセス記述に従う。仕事をしているみんなは十分なリソースを使う権利を持っていて、すべての作業タスクと成果物が監視、制御、レビューされているんだ。 CL3 (定義済み)：その共通目標は、定義されたプロセスの制度化に集中しているよ。プロセスは組織の標準プロセス集から、組織のテーラリングガイドラインに従って仕立てられているんだ。また、プロセス資産とプロセスの測定値を収集して、将来のプロセス改善に使う必要があるね。 CL4 (定量的管理済み)：その共通目標は、定量的に管理可能なプロセスの制度化に集中している。測定と品質保証を使ってプロセス領域を制御し、改善するんだ。品質とプロセス実行に関する定量的目標を管理基準として確立し、使用するよ。 CL5 (最適化)：定量的（統計学的な）手段を使ってプロセス領域を変更・最適化するんだ。これによって、顧客要求の変化や継続的な改善計画におけるプロセス領域の有効性を満たすことを目指すよ。 ソフトウェアプロセスモデル ソフトウェアプロセスモデルは、一般的にソフトウェア開発モデルとも呼ばれるものだね。これは、ソフトウェア開発のすべてのプロセス、活動、タスクの構造的フレームワークなんだ。代表的なソフトウェアプロセスモデルには、ウォーターフォールモデル、インクリメンタルモデル、進化的モデル（プロトタイプモデル、スパイラルモデル）、ファウンテンモデル、コンポーネントベース開発モデル、形式手法モデルなどがあるよ。\nウォーターフォールモデル ウォーターフォールモデルは、ソフトウェアのライフサイクルにおける各活動を、線形に順序づけられたいくつかの段階（要件分析、設計、コーディング、テスト、運用、保守）に規定したモデルなんだ。これは、滝の水が段階的に落ちるように、前から後ろへと連なり、固定された順序を定めているよ。\nウォーターフォールモデルは、ソフトウェアの開発と保守に効果的な管理パターンを提供してくれる。このパターンに基づいて開発計画を立てたり、コスト予算を組んだり、開発体制を組織したりするんだ。プロジェクトの段階レビューや文書管理を手段として、開発プロセス全体を効果的に指導するから、これは文書駆動型で、ソフトウェア要件がとても明確なソフトウェアプロジェクトに適したモデルだね。\nウォーターフォールモデルは、開発対象のシステム要件が完全で、簡潔で、一貫していて、設計や実装が完了する前に生成できる、って仮定しているんだ。\nウォーターフォールモデルの利点は、理解しやすく、管理コストが低いこと。開発の段階的な早期計画や要件調査、製品テストを重視している点だね。 不足している点は、顧客が自分のニーズを完全、正確、かつ明確に表現できる必要があること。最初の2〜3段階では、実際の進捗状況を評価するのが難しいこと。プロジェクト終盤に近づくと、大量の統合とテスト作業が発生すること。そして、プロジェクトが終わるまでシステムの能力をデモンストレーションできないこと、だね。 ウォーターフォールモデルでは、要件や設計の誤りがプロジェクトの後半になってようやく発見されることが多くて、プロジェクトリスクの制御能力が弱いんだ。その結果、プロジェクトが遅延したり、開発費用が予算を超過したりすることがよくあるよ。\nVモデル ウォーターフォールモデルの派生の一つがVモデルだよ。\nVモデルは、品質保証活動と、コミュニケーション、モデリング関連活動、そして早期構築関連活動との関係を表しているんだ。ソフトウェアチームがVモデルの左側のステップを下にたどっていくにつれて、基本的な問題要件が徐々に詳細化されて、問題と解決策の技術的な記述が形成される。コーディングが終わったら、チームはVモデルの右側のステップを上にたどっていくんだけど、これは実際には一連のテスト（品質保証活動）を実行していることになるんだね。これらのテストは、Vモデルの左側を下にたどる過程でチームが生成した各モデルを検証するものなんだ。Vモデルは、検証・確認活動を初期のソフトウェア工学作業に適用する方法を提供してくれるよ。\nインクリメンタルモデル インクリメンタルモデルは、ウォーターフォールモデルの基本要素とプロトタイプ実現のイテレーション（反復）特性を融合したものだよ。これは、要件を一連のインクリメンタルな製品に分割できると仮定していて、それぞれのインクリメンタルな製品を個別に開発できるんだ。このモデルは、スケジュールの進行とともに入れ替わる線形シーケンスを採用していて、それぞれの線形シーケンスがソフトウェアのリリース可能な「インクリメント」を生み出すんだよ。\nインクリメンタルモデルを使うとき、最初のインクリメントが核となる製品になることが多いよ。顧客は各インクリメントを利用・評価して、それが次のインクリメントでリリースされる新機能や機能として活用されるんだ。このプロセスは、それぞれのインクリメントがリリースされた後に繰り返し行われて、最終的に完璧な製品が作られるまで続くよ。インクリメンタルモデルは、すべてのインクリメントで動作可能な製品をリリースすることを強調しているんだ。\nインクリメンタルモデルはウォーターフォールモデルの派生版だから、ウォーターフォールモデルの利点をすべて持っているんだ。それに加えて、次の利点もあるよ。最初の成果物バージョンに必要なコストと時間が少ないこと。インクリメントで表される小さなシステム開発に伴うリスクが小さいこと。最初のバージョンがすぐにリリースされるため、ユーザー要求の変更を減らせること。そして、インクリメンタルな投資、つまりプロジェクト開始時に1つか2つのインクリメントにのみ投資できること、だね。\nインクリメンタルモデルには、次の不足点もあるんだ。ユーザーの変更要求に対する計画がなければ、生成された初期インクリメントが後続のインクリメントを不安定にする可能性があること。要件が早期に考えたほど安定していて完全でなかった場合、いくつかのインクリメントを再開発・再リリースする必要があるかもしれないこと。そして、発生するコスト、進捗、構成管理の複雑さが組織の能力を超える可能性があること、だね。\n進化的モデル ソフトウェアは他の複雑なシステムと同じで、時間の経過とともに進化していくものだよね。開発中に、次のような状況に直面することがよくあるんだ。ビジネスや製品の要件が頻繁に変わるせいで、最終製品の実現が難しくなること。厳しい納期のために開発チームがソフトウェア製品を完全に仕上げるのは不可能でも、競争やビジネス上の圧力に対応するために機能が限定されたバージョンをリリースしなければならないこと。そして、コアとなる製品やシステムの要件はよく理解しているんだけど、製品やシステムの拡張に関する詳細な問題が定義されていないこと、とかね。このような状況や類似のケースでは、ソフトウェア開発者は絶えず進化するソフトウェア製品に特化したプロセスモデルを必要とするんだ。\n進化的モデルはイテレーション（反復）型のプロセスモデルで、ソフトウェア開発者がより完成度の高いソフトウェアバージョンを段階的に開発できるようにしてくれるんだ。進化的モデルは、ソフトウェア要件に対する正確な認識が不足している場合に特に適しているよ。代表的な進化的モデルには、プロトタイプモデルやスパイラルモデルなどがあるね。\nプロトタイプモデル (Prototype Model) すべての要件を事前に定義できるわけじゃないんだ。多くの経験が示すところによると、開発初期に完全で正確な要件仕様書を得るのは難しいんだよ。これは主に、顧客が将来のシステムに対する全体的な要求を正確に表現できないことが多くて、開発者も解決すべきアプリケーション問題についてあいまいな理解しか持っていないため、作成される要件仕様書が不完全だったり、不正確だったり、時には曖昧だったりするからだね。さらに、開発プロセス全体でユーザーが新しい要求を出すことで、要件が変更されることもあるんだ。ウォーターフォールモデルは、このような要件の不確実性や変化に対応するのが難しいから、ラピッドプロトタイプという新しい開発手法が登場したんだよ。プロトタイプ方法は、ユーザーの要件が不明確だったり、頻繁に変化したりする場合に比較的適しているね。システム規模がそれほど大きくなく、複雑でもないときにこの方法を採用するのは良い選択だと言えるよ。\nプロトタイプは、期待されるシステムの一部を反映した実行可能なバージョンだよ。プロトタイプは、目標とするソフトウェアのすべての制約を満たす必要はなくて、その目的は、迅速かつ低コストで構築できることにあるんだ。もちろん、プロトタイプ方法を採用できるのは、開発ツールの急速な発展のおかげで、ユーザーが見て触れることができるシステムフレームワークを素早く開発できるようになったからだね。こうして、コンピューターにあまり詳しくないユーザーでも、このフレームワークに基づいて自分の要件を提案できるようになるんだ。プロトタイプシステムを開発するには、まずユーザー要件を確定して初期プロトタイプを開発し、次にユーザーから初期プロトタイプに対する改善意見を募って、その意見に基づいてプロトタイプを修正していくんだよ。\nプロトタイプモデルはコミュニケーションから始まるんだ。目的は、ソフトウェアの全体目標を定義し、要件を特定すること。その後、プロトタイプ開発の計画を迅速に立て、プロトタイプの目標と範囲を決定して、ラピッドデザインの手法でモデリングを行い、プロトタイプを構築するんだ。開発されたプロトタイプは顧客に提供されて使ってもらい、顧客からのフィードバック意見を収集するよ。これらのフィードバック意見は、次のイテレーションでプロトタイプの改善に活かされるんだ。前のプロトタイプを改善する必要があるとき、またはその範囲を拡張する必要があるときに、次のプロトタイプのイテレーション開発に入るんだね。\nスパイラルモデル 複雑な大規模ソフトウェアの場合、一つのプロトタイプを開発するだけでは要件を満たせないことが多いんだ。スパイラルモデルは、ウォーターフォールモデルと進化的モデルを組み合わせて、どちらのモデルも無視していたリスク分析を取り入れて、これら2つのモデルの欠点を補っているよ。\nスパイラルモデルは、開発プロセスをいくつかのスパイラルサイクルに分けているんだ。それぞれのスパイラルサイクルは、だいたいウォーターフォールモデルに合致していて、次の4つの作業ステップに分かれるよ。\n計画の策定。ソフトウェアの目標を決定し、実施案を選定して、プロジェクト開発の制約条件を明確にする。 リスク分析。選択した案を分析し、リスクを特定して、リスクを解消する。 エンジニアリングの実施。ソフトウェア開発を実施し、段階的な製品を検証する。 ユーザー評価。開発作業を評価し、修正提案を提出して、次のサイクルの開発計画を立てる。 スパイラルモデルはリスク分析を重視していて、開発者とユーザーが各進化段階で発生するリスクを理解し、それに応じた対応を取れるようにしているんだ。だから、このモデルは、大規模で複雑、かつリスクの高いシステムに特に適しているんだよ。\nウォーターフォールモデルと比較して、スパイラルモデルはユーザー要件の動的な変化をサポートしてくれるし、ユーザーがソフトウェア開発のすべての重要な意思決定に参加しやすくして、ソフトウェアの適応能力の向上に役立つんだ。さらに、プロジェクト管理者が管理上の意思決定をタイムリーに調整しやすくしてくれるから、ソフトウェア開発のリスクを低減できるよ。スパイラルモデルを使ってソフトウェア開発を行う場合、開発者には非常に豊富なリスク評価経験と専門知識が必要だね。それに、イテレーションの回数が多すぎると開発コストが増加して、納期が遅れる可能性もあるんだ。\nファウンテンモデル ファウンテンモデルは、ユーザー要件を原動力とし、オブジェクトを駆動源とするモデルで、オブジェクト指向開発手法に適しているんだ。これは、ウォーターフォールモデルがソフトウェアの再利用や複数の開発活動の統合をサポートしない、という限界を克服しているよ。ファウンテンモデルは、開発プロセスに反復性とシームレス性を持たせるんだ。\nイテレーションとは、モデル内の開発活動が何度も繰り返される必要があって、その過程でソフトウェアシステムが継続的に改善されることを意味するんだ。シームレス性っていうのは、開発活動（例えば分析、設計、コーディング）の間に明確な境界がないこと、つまり、ウォーターフォールモデルみたいに、要件分析活動が終わってから設計活動が始まり、設計活動が終わってからコーディング活動が始まる、っていうんじゃなくて、それぞれの開発活動が並行して、反復的に進められることを許容する、っていうことだよ。\nファウンテンモデルの各段階には明確な境界がなくて、開発者は並行して作業を進められるんだ。その利点は、ソフトウェアプロジェクトの開発効率を高め、開発時間を節約できることだね。ファウンテンモデルは開発の各段階が重複しているから、開発プロセス中に大量の開発者が必要で、プロジェクト管理には不利なんだ。それに、このモデルは厳格な文書管理が求められるから、監査の難易度も上がっちゃうんだよ。\n統一プロセス (UP) モデル 統一プロセスモデルは、「ユースケースとリスク駆動型、アーキテクチャ中心、反復的かつインクリメンタル」な開発プロセスで、UMLの手法とツールにサポートされているんだ。イテレーションっていうのは、ソフトウェア開発プロジェクト全体をたくさんの小さな「ポケットプロジェクト」に分割するってこと。それぞれの「ポケットプロジェクト」には、通常のソフトウェアプロジェクトのすべての要素が含まれるんだよ。つまり、計画、分析と設計、構築、統合とテスト、それに内部および外部リリース、だね。\n統一プロセスは、4つの技術段階とその成果物を定義しているよ。\n開始フェーズ (Inception Phase)\n開始フェーズはプロジェクトの立ち上げ活動に集中するんだ。主な成果物としては、ビジョン文書 (Vision Document)、初期ユースケースモデル、初期プロジェクト用語集、初期ビジネスユースケース、初期リスク評価、プロジェクト計画（フェーズおよびイテレーション）、ビジネスモデル、そして必要に応じて1つ以上のプロトタイプがあるよ。\n具現化フェーズ (Elaboration Phase)\n具現化フェーズでは、最初の領域範囲を理解した後、要件分析とアーキテクチャ進化を行うんだ。主な成果物としては、ユースケースモデル、補足要件、分析モデル、ソフトウェアアーキテクチャ記述などがあるよ。\n構築フェーズ (Construction Phase)\n構築フェーズはシステムの構築に注目して、実装モデルを生み出すんだ。主な成果物としては、設計モデル、ソフトウェアコンポーネント、統合されたソフトウェアインクリメント、テスト計画と手順、テストケース、そしてサポート文書などがあるよ。\n移行フェーズ (Transition Phase)\n移行フェーズは、ソフトウェアの提出に関する作業に注目して、ソフトウェアインクリメントを生み出すんだ。主な成果物としては、提出されたソフトウェアインクリメント、βテスト報告書、そして包括的なユーザーフィードバックがあるよ。\nそれぞれのイテレーションでは、最終システムの部分的に完成したバージョンと、関連するプロジェクト文書を含むベースラインが生成されるんだ。段階的なイテレーションを通じてベースライン同士が相互に構築されていき、最終システムが完成するまで続くよ。各イテレーションには5つのコアワークフローがあるんだ。\nシステムが何をすべきかを捉える要件ワークフロー 要件を詳細化し構造化する分析ワークフロー システムアーキテクチャ内で要件を実現する設計ワークフロー ソフトウェアを構築する実装ワークフロー 実装が期待通りに機能するかを検証するテストワークフロー UPの段階が進むにつれて、各コアワークフローの作業量は変化するんだ。4つの技術段階は、主要なマイルストーンで終了するよ。\n開始フェーズ：ライフサイクル目標 具現化フェーズ：ライフサイクルアーキテクチャ 構築フェーズ：初期動作機能 移行フェーズ：製品リリース 統一プロセスの代表例はRUP (Rational Unified Process) だね。RUPはUPの商業拡張版で、UPと完全に互換性があるんだけど、UPよりもさらに完全で詳細なものなんだ。\nアジャイル手法 アジャイル開発の全体的な目標は、「価値のあるソフトウェアを可能な限り早く、継続的に提供すること」を通じて顧客を満足させることなんだ。ソフトウェア開発プロセスに柔軟性を取り入れることで、アジャイル手法 (Agile Development) は、開発サイクルの後期にユーザーが要件を追加したり変更したりできるようにしてくれるんだよ。\nアジャイルプロセスの代表的な手法はたくさんあって、それぞれが原則のセットに基づいていて、それらの原則がアジャイル手法が提唱する理念（アジャイル宣言）を実現しているんだ。\n1. エクストリームプログラミング (XP) XPは、軽量（アジャイル）で、高効率、低コスト、柔軟性があり、予測可能で科学的なソフトウェア開発手法なんだ。これは、価値観、原則、実践、行動の4つの部分から構成されていて、お互いに依存し、関連し合いながら、行動を通じてライフサイクル全体を貫いているよ。\n4つの大きな価値観：コミュニケーション、シンプルさ、フィードバック、勇気 5つの大きな原則：迅速なフィードバック、シンプルさの仮定、段階的修正、修正の推奨、高品質な仕事 12のベストプラクティス 計画ゲーム（迅速な計画策定、詳細の変化に合わせて洗練させる） 小規模リリース（システムの設計は、可能な限り早期に提供できるようにする） メタファー（適切な比喩を見つけて情報を伝える） シンプルな設計（現在の要件だけを扱い、設計をシンプルに保つ） テスト駆動開発（先にテストコードを書き、その後にプログラムを作成する） リファクタリング（要件と設計を再検討し、新しい要件と既存の要件に合致するように明確に再記述する） ペアプログラミング 共同コード所有 継続的インテグレーション（顧客に日ごと、場合によっては時間ごとに動作可能なバージョンを提供できる） 週40時間労働 オンサイト顧客（システムの最終ユーザー代表がXPチームに全面的に協力する） コーディング標準 2. クリスタル法 (Crystal) クリスタル法は、それぞれの異なるプロジェクトには異なる戦略、慣習、方法論が必要だと考えるんだ。\n人間がソフトウェアの品質に重要な影響を与えると考えているから、プロジェクトの品質や開発者の質が向上するにつれて、プロジェクトとプロセスの品質もそれに伴って向上するんだ。より良いコミュニケーションと頻繁なデリバリーを通じて、ソフトウェアの生産性が向上するってわけだね。\n3. スクラム (Scrum) スクラムはイテレーション（反復）の手法を使っていて、30日ごとのイテレーションを「スプリント」と呼び、要件の優先度に従って製品を実現するんだ。複数の自己組織化された自律的なチームが並行して製品をインクリメンタルに実現していくんだけど、調整は短い日常の状況会議で行われるんだよ。まるでラグビーの「スクラム」みたいだね。手順は次の通りだよ。\n4. 適応的ソフトウェア開発 (ASD) ASDには6つの基本的な原則があるんだ。\n指針となるミッションがあること 特徴が顧客価値のキーポイントと見なされること プロセスにおける待機が重要で、「やり直し」は「実行」と同じくらい重要であること 変化は修正ではなく、ソフトウェア開発の実際の状況への調整と見なされること 確定された納期が、開発者に生産されるすべてのバージョンの重要な要件を真剣に検討させること リスクもその中に含まれること 5. アジャイル統一プロセス (AUP) アジャイル統一プロセス (Agile Unified Process, AUP) は、「大規模では連続的」であり「小規模では反復的」という原理を使ってソフトウェアシステムを構築するんだ。古典的なUPの段階的活動（開始、具現化、構築、移行）を採用し、チームがソフトウェアプロジェクトの包括的なプロセスフローを構想できるような一連の活動を提供するんだよ。それぞれの活動の中で、チームはアジャイルを反復的に使いながら、意味のあるソフトウェアインクリメントを可能な限り迅速にエンドユーザーに提供するんだ。AUPの各イテレーションでは、次の活動を実行するよ。\nモデリング。ビジネスや問題領域のモデル表現を作成する。これらのモデルは、チームが先に進むのに「十分良い」ものであればいいんだ。 実装。モデルをソースコードに変換する。 テスト。XPと同じように、チームは一連のテストを設計・実行してエラーを発見し、ソースコードが要件を満たしていることを保証するんだ。 デプロイ。ソフトウェアインクリメントの提供と、エンドユーザーからのフィードバックの取得。 構成管理とプロジェクト管理。変更管理、リスク管理、そしてチームのあらゆる成果物の制御に焦点を当てる。プロジェクト管理は開発チームの作業進捗を追跡・制御し、チーム活動を調整するんだ。 環境管理。標準、ツール、そして開発チームに適用されるサポート技術などのプロセスインフラを調整する。 ","date":"2023-03-28T15:45:47+08:00","permalink":"https://blog.yexca.net/ja/archives/96/","title":"ソフトウェア工学 - ソフトウェアプロセスとソフトウェアプロセスモデル"},{"content":" 📢 この記事は ChatGPT によって翻訳されました 自分が学んだ Git の内容をまとめておくよ。\n1. インストール Windows に Git をインストール 公式サイトからダウンロード： https://git-scm.com/download/win インストール後、Git Bash を一度起動しておく。\nLinux に Git をインストール Debian: sudo apt-get install git Fedora: dnf install git CentOS: yum install git 他は公式参照： https://git-scm.com/download/linux macOS に Git をインストール Homebrew 経由でインストールするのが一般的。詳細： http://brew.sh/ または、AppStore で Xcode をインストール → Xcode を開いて\nXcode \u0026gt; Preferences \u0026gt; Downloads \u0026gt; Command Line Tools を選んでインストール。\n2. 初期設定 インストール直後、以下でユーザー情報を設定：\n1 2 git config --global user.name \u0026#34;Your Name\u0026#34; git config --global user.email \u0026#34;email@example.com\u0026#34; 3. リポジトリの作成 適当なフォルダで以下を実行：\n1 git init これで .git フォルダができ、Git 管理の対象になる。中は直接編集しないこと。\nリモートリポジトリのクローン 他人のリポジトリ 1 git clone https://github.com/yexca/typecho-theme-book.git コミット権限がないなら HTTPS で問題なし。編集・プルリクしたいなら自分のリポジトリへ fork しよう。\n自分のリポジトリ（SSH） 事前に GitHub の SSH キー設定： https://github.com/settings/keys その後：\n1 git clone git@github.com:yexca/typecho-theme-book.git 参考：\n大佬にお茶を渡す方法（GitHubでの貢献） 初めての Pull Request 4. ファイルのコミット（ローカル） ファイル変更後：\n1 2 3 git add filename # すべて追加する場合 git add . 追加後、コミット：\n1 git commit -m \u0026#34;変更内容の説明\u0026#34; .gitignore で除外ファイルを設定 例：\n1 2 3 test/ # testフォルダ *.py[cod] # .pyc, .pyo, .pyd !app.pyc # app.pycだけ除外しない 無視してても強制追加可：\n1 git add -f test.pyc .gitignore 変更時はキャッシュクリアが必要：\n1 2 3 git rm -r --cached . git add . git commit -m \u0026#34;update .gitignore\u0026#34; 5. 状態確認と取り消し 1 2 3 4 git status # 状態確認 git diff # 差分表示 git log # コミット履歴 git log --pretty=oneline バージョンを戻す 一つ前：git reset --hard HEAD^ 特定のバージョンへ： 1 git reset --hard コミットID（先頭数桁でもOK） 戻しすぎた場合は：\n1 git reflog でログを確認して戻す。\n6. GitHub にリンク GitHub 上でリポジトリを作成後：\n1 git remote add origin git@github.com:username/repo.git ローカルで編集したら：\n1 git push origin master main/master の違い VS Code は master を使うが GitHub は main。 変更したい場合：\n1 git branch -m master main 初期ブランチを main に設定：\n1 git config --global init.defaultBranch main 毎回 --set-upstream するのが面倒なら：\n1 git push --set-upstream origin main 以降は git push origin だけで OK。\nリモートの再設定 1 2 git remote -v # 確認 git remote rm origin # 削除 7. ブランチ操作 1 2 3 4 5 git branch # 一覧 git branch new_branch # 作成 git switch new_branch # 切り替え git checkout new_branch # 同上 git push origin new_branch # プッシュ ブランチ作って機能開発 → main にマージする流れ：\n1 2 3 4 5 git switch -c search # ...編集、テスト、コミット... git switch main git merge search git branch -d search 8. Git サーバー構築 参考： Gitサーバーを構築し、指定ディレクトリに同期する方法 9. その他 GitLab \u0026amp; GitHub 両方使いたい人向け：\nGit 同期設定（GitLab + GitHub） 参考資料 Git チュートリアル（廖雪峰） GitHubにローカルリポジトリを接続する方法 main ブランチへのプッシュエラー対処 .gitignore 更新後の反映方法 ","date":"2023-03-05T15:03:43+08:00","permalink":"https://blog.yexca.net/ja/archives/95/","title":"Git 学習メモ"},{"content":" この記事は Google 翻訳を使用して処理されました\n「ハードドライブに保存されていないものはあなたのものではない」という原則に従い、個人の携帯電話に保存されている写真の数が増えているため、携帯電話のメモリ危機を緩和するために、緊急に整理してハードドライブに保存する必要があるため、アーティストによるダウンロード・保存方式を採用する。そのため、便利な記録と迅速な検索および変更の方法が必要です。アーティストの数が増えると、Markdown を使用した元のリストは必然的に非常に遅くなる可能性があります。\n2 日後に振り返ってみると、何かを記録する最良の方法はデータベースを使用することです。\nダウンロードとインストール 考えた結果、MySQLを使うことにしました。ダウンロードについては、 MySQL下载与安装 - 知乎 を参照してください。一部変更されていますが、ほぼ同じ。\nインストールはデフォルトのままで完了するまでクリックし続けました （面倒すぎる）\nサービスを開始し、win+Rを押してservices.mscと入力し、サービスを見つけて開始します。\nデータベース設計 正直に言うと、ここでデザインすることはあまりありません。今のところ、主に Pixiv からアーティストをダウンロードし、いくつかは Twitter からダウンロードしているので、1 つのテーブルしか使用できないはずです。\nID name downloadDate lastDownloadID platform url アーティスト固有ID 名前 ダウンロード日 最後にダウンロードした作品ID プラットフォーム リンク このデザインはどのようなパラダイムですか? コードは次のとおりです\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 -- データベースを作成する create database hello; -- データベースを選択 use hello; -- テーブルを作成 create table pic ( ID varchar(99), name varchar(255), downloadedDate datetime, lastDownloadID varchar(255), platform varchar(50), url varchar(255), primary key(ID) ); 作品をダウンロード Pixiv Powerful Pixiv Downloader 拡張機能 Chrome App Store リンク を使用する\nGithub リンク： xuejianxianzun/PixivBatchDownloader 必ず低速クロールを有効にしてください。そうしないと、ダウンロード速度が速すぎたり、一度にダウンロードする量が多すぎたりした場合に、IP が一時的にブロックされます。\nTwitter Twitter Media Downloader 拡張機能 Chrome App Store リンク を使用する\n公式ウェブサイトのリンク： Twitter メディアダウンローダ：ユーザータイムラインの原寸画像や動画をまとめてダウンロードするユーザースクリプト(PC用Google Chrome・Firefox等対応) - 風柳メモ データ挿入 1 2 3 4 5 6 -- データベースを選択 use hello; -- データの挿入 insert into pic values (\u0026#39;6049901\u0026#39;, \u0026#39;鬼针草\u0026#39;, \u0026#39;2023-02-09\u0026#39;, \u0026#39;105176620\u0026#39;, \u0026#39;pixiv\u0026#39;, \u0026#39;https://www.pixiv.net/users/6049901\u0026#39;) 複数行のデータの場合、データは , で区切られます。\nデータの更新 1 2 3 update pic set downloadedDate = \u0026#39;2023-03-02\u0026#39;, lastDownloadID = \u0026#39;105716156\u0026#39; where ID = \u0026#39;6049901\u0026#39; 詳細： データベースの学習 3 SQL言語 – yexca\u0026rsquo;Blog データベースについてもっと知りたいですか? 私が書いた (完全に翻訳しないけど)： データベース学習 1 データベース入門 – yexca\u0026rsquo;Blog 中国語（簡体字）: SQL 教程-菜鸟教程 参照記事 MySQL常见建表选项及约束 - GeaoZhang - 博客园 ","date":"2023-03-02T10:16:38+08:00","permalink":"https://blog.yexca.net/ja/archives/94/","title":"データベースにはダウンロードされたアーティストの作品が記録されます"},{"content":" 📢 この記事は gemini-3-flash-preview によって翻訳されました オブジェクト指向 (Object-Oriented, OO) は、すごく実用的なシステム化されたソフトウェア開発手法なんだ。\n手続き型とオブジェクト指向 一つの問題から考えてみよう。「ゾウを冷蔵庫に入れるには、何ステップ必要かな？」\n普通は、まず冷蔵庫を開けて、次にゾウを中に入れて、最後に冷蔵庫を閉めるよね。\n手続き型 「どうやってやるか」を気にするスタイル。機能を一歩ずつ実現していくんだ。\nさっきの問題なら：\n自分が冷蔵庫を開ける 自分がゾウを冷蔵庫の中に押し込む 自分が冷蔵庫のドアを閉める オブジェクト指向 「誰にやらせるか」を気にするスタイル。オブジェクトの操作を呼び出すことで機能を実現するんだ。\nさっきの問題なら：\nオブジェクトを作る：ゾウ、冷蔵庫\n冷蔵庫がドアを開ける ゾウが冷蔵庫の中に入る 冷蔵庫がドアを閉める オブジェクト指向の基礎 オブジェクト指向 ＝ オブジェクト ＋ 分類 ＋ 継承 ＋ メッセージによる通信\nこの 4 つの概念を使って開発されたソフトウェアシステムが、オブジェクト指向だと言えるよ。\nオブジェクト 現実世界は、たくさんの具体的なモノ、出来事、概念、ルールで成り立っていて、これらはすべてオブジェクトと見なすことができる。\nオブジェクト指向システムにおいて、オブジェクトは基本的な実行時のエンティティなんだ。データ（属性）と、そのデータに作用する操作（振る舞い）の両方を含んでいる。一つのオブジェクトは、通常「オブジェクト名」「属性」「メソッド」の 3 つの部分で構成されるよ。\nメッセージ オブジェクト間で通信するための仕組みをメッセージと呼ぶ。あるメッセージを特定のオブジェクトに送るとき、それには受信側のオブジェクトに特定の活動を実行させるための情報が含まれている。メッセージを受け取ったオブジェクトは、それを解釈して応答するんだ。\nメソッド呼び出しの引数渡しみたいなものだね。\nクラス クラスは、大体似たようなオブジェクトの集まりを定義するものだ。一つのクラスに含まれるメソッドとデータは、オブジェクトのグループに共通する振る舞いと属性を記述している。オブジェクトの共通の特徴を抽象化してクラスに保存することは、オブジェクト指向技術の最も重要なポイントなんだ。充実したクラスライブラリがあるかどうかは、そのオブジェクト指向プログラミング言語が成熟しているかどうかの重要な指標になる。\nクラスはオブジェクトを抽象化したものであり、**オブジェクトはクラスを具体化したもの（インスタンス）**なんだ。分析や設計のときは、具体的なオブジェクトではなく、通常はクラスに注目する。オブジェクトを一つずつ定義する必要はなくて、クラスを定義して、その属性に異なる値を割り当てるだけで、そのクラスのオブジェクトインスタンスが手に入るんだ。\nクラスは 3 つに分けられる：エンティティクラス、インターフェースクラス（境界クラス）、コントロールクラス。コントロールクラスのオブジェクトは、処理の流れを制御し、コーディネーターの役割を果たすよ。\nクラスの中には「一般と特殊」の関係を持つものがある。あるクラスが別のクラスの特殊なケースだったり、逆に一般的なケースだったりする。特殊なクラスは一般なクラスの「サブクラス」で、一般的なクラスは特殊なクラスの「スーパークラス（親クラス）」になるんだ。\n通常、一つのクラスとそのクラスのすべてのオブジェクトをまとめて「クラスとオブジェクト」またはオブジェクトクラスと呼ぶこともある。\nメソッドのオーバーロード メソッドをオーバーロードする方法：\nメソッド名は同じで、引数の数が異なる メソッド名は同じで、引数の型が異なる メソッド名は同じで、引数の型の順番が異なる Java を例にすると、関数の書式はこんな感じ：\n1 2 3 4 5 6 /* アクセス修飾子 戻り値の型 メソッド名(引数の型1 引数名1, 引数の型2 引数名2, ···) { メソッドの本体 } */ 例を挙げるね：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public class Test { // 元のメソッド public void sum(int a, double b) { System.out.println(a + b); } // 1. メソッド名は同じで、引数の数が異なる public void sum(int a, double b, int c) { System.out.println(a + b + c); } // 2. メソッド名は同じで、引数の型が異なる public void sum(int a, int b) { System.out.println(a + b); } // 3. メソッド名は同じで、引数の型の順番が異なる public void sum(double a, int b) { System.out.println(a + b); } } オブジェクト指向の三大特徴 オブジェクト指向の 3 つの基本特徴は、カプセル化、継承、多態性（ポリモーフィズム）だよ。\nカプセル化 カプセル化は情報を隠蔽する技術で、オブジェクトの利用者と作成者を切り離し、定義と実装を分けることが目的なんだ。設計者から見ればオブジェクトはプログラムモジュールだけど、ユーザーから見れば期待通りの振る舞いを提供してくれるものに見える。\nつまり、現実のモノを抽象的なクラスにまとめ、自分自身のデータやメソッドを信頼できるクラスやオブジェクトだけに操作させ、信頼できないものからは情報を隠すことなんだ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public class Person{ private String name; // private を使ってアクセスを制限する private int age; public void setName(String name){ // public メソッドを通じて属性を変更する手段を提供する this.name = name; } public String getName(){ // public メソッドを通じて属性を取得する手段を提供する return name; } public void setAge(int age){ if (age \u0026gt;= 0 \u0026amp;\u0026amp; age \u0026lt;= 150) this.age = age; } public int getAge(){ return age; } public void run(){ System.out.println(\u0026#34;走る！\u0026#34;); } } 継承 継承は、親クラスと子クラスの間でデータとメソッドを共有する仕組みだ。これはクラス間の関係の一つで、新しいクラスを定義・実装するときに、すでにある親クラスをベースにできるんだ。既存のクラスの内容を自分のものとして取り込み、そこに新しい内容を追加する感じだね。\n一つの親クラスは複数の子クラスを持つことができて、これらの中身はすべて親クラスの特殊なケースになる。親クラスは子クラスの共通の属性やメソッドを記述しているんだ。子クラスは親クラス（または祖先クラス）の属性やメソッドを引き継げるから、子クラスでそれらを再定義する必要はない。もちろん、子クラス独自の属性やメソッドを追加することもできるよ。\nもし子クラスが一つの親クラスからしか継承しないなら「単一継承」、二つ以上の親クラスから継承するなら「多重継承」と呼ぶ。\n注：Java では一つの子クラスは一つの親クラスしか持てない（単一継承）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // 前のコードの続き public class Student extends Person{ // キーワード extends を使って継承する親クラスを指定する private int id; public void setId(int id){ this.id = id; } public int getId(){ return id; } public void study(){ System.out.println(getName() + \u0026#34;は勉強中\u0026#34;); } // 親クラスのメソッドをオーバーライド（書き換え） public void run(){ System.out.println(getName() + \u0026#34;は逃げたい\u0026#34;); } } 多態性 (ポリモーフィズム) メッセージを受け取ったとき、オブジェクトはそれに応答する。異なるオブジェクトが同じメッセージを受け取っても、全く異なる結果を生じることがある。この現象を多態性と呼ぶんだ。多態性を使うと、ユーザーは一般的なメッセージを送るだけで、具体的な実装の詳細は受信側のオブジェクトに任せることができる。こうして、同じメッセージで異なるメソッドを呼び出せるようになるんだ。\n多態性の実現は継承に支えられている。クラスの継承階層を利用して、共通の機能を持つメッセージを高い階層に置き、その機能を実現する異なる振る舞いを低い階層に置く。そうすることで、低い階層で生成されたオブジェクトが共通のメッセージに対して異なる応答を返せるようになるんだ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 // 親クラス public class Person{ public void work(){ System.out.println(\u0026#34;仕事をする\u0026#34;); } } // 子クラス 1 public class Student extends Person{ // メソッドのオーバーライド public void work(){ System.out.println(\u0026#34;学校に行く\u0026#34;); } public void run(){ System.out.println(\u0026#34;Only the young CAN RUN!\u0026#34;); } } // 子クラス 2 public class Worker extends Person{ // メソッドのオーバーライド public void work(){ System.out.println(\u0026#34;出社する\u0026#34;); } public void sleep(){ System.out.println(\u0026#34;寝る\u0026#34;); } } // main public class Main{ public static void main(String[] args){ // コンパイル時は左（型）を見て、実行時は右（中身）を見る Person stu = new Student(); stu.work(); // \u0026#34;学校に行く\u0026#34; と出力される // stu.run(); は呼び出せない（Person 型には run がないから） Person wok = new Worker(); wok.work(); // \u0026#34;出社する\u0026#34; と出力される // wok.sleep(); は呼び出せない } } // 実行結果： // 学校に行く // 出社する 多態性の形式 多態性にはいくつかの形式があって、Cardelli と Wegner は 4 つに分類しているよ。\nパラメータ多態 (Parametric polymorphism)：広く使われている多態性で、最も純粋な多態性と言われている。 包含多態 (Inclusion polymorphism)：多くの言語に存在し、最も一般的な例はサブタイプ化だ。つまり、ある型が別の型のサブタイプであること。 過負荷多態 (Overloading polymorphism)：同じ名前が異なるコンテキスト（文脈）で異なる意味を持つこと。 強制多態 (Coercion polymorphism)：型変換などによって実現される多態性。 動的バインディングと静的バインディング バインディング（結合）とは、プロシージャの呼び出しと、その呼び出しに応答して実行されるコードを関連付けるプロセスのこと。一般的なプログラミング言語では、バインディングはコンパイル時に行われ、これを静的バインディングと呼ぶ。一方で、動的バインディングは実行時に行われる。つまり、呼び出しが発生するまで、どのコードが実行されるか決まらないんだ。\n動的バインディングはクラスの継承や多態性と深く関わっている。継承関係において、子クラスは親クラスの特殊なケースだから、親クラスが使える場所には子クラスのオブジェクトも置ける。そのため実行中に、あるオブジェクトがメッセージを送ってサービスを要求したとき、受信側のオブジェクトの具体的な状況に応じて、要求された操作と実装メソッドを接続する、つまり動的接続が行われるんだ。\nオブジェクト指向分析 オブジェクト指向分析 (Object-Oriented Analysis, OOA) の目的は、アプリケーションの問題を理解することだ。理解の目的は、システムの機能や性能要件を確定させることにある。\nOOA には 5 つの活動がある：オブジェクトの認定、オブジェクトの組織化、オブジェクト間の相互作用の記述、オブジェクトの操作の確定、オブジェクトの内部情報の定義。\nオブジェクト指向設計 オブジェクト指向設計 (Object-Oriented Design, OOD) は、OOA で作成された分析モデルを設計モデルに変換すること。その目標は、システムの構築図（ブループリント）を定義することなんだ。通常、概念モデルから生成された分析モデルを実行環境に組み込む際、実装上の問題を考慮して調整や補充が必要になる。例えば、使用するプログラミング言語が多重継承をサポートしているかどうかに合わせてクラス構造を調整したりする。OOA と OOD の間には大きな隔たりはなく、一貫した概念と表現方法が使われる。OOD も同様に、抽象化、情報隠蔽、機能の独立、モジュール化などの設計原則に従うべきだね。\nオブジェクト指向設計の活動 OOD は OOA のモデルを再利用した上で、OOA に対応する以下の 5 つの活動を含んでいるよ。\nクラスとオブジェクトの識別 属性の定義 サービスの定義 関係の識別 パッケージの識別 オブジェクト指向設計の原則 単一責任の原則 (Single Responsibility Principle) 一つのクラスにとって、それを変更する理由はたった一つであるべきだ。つまり、あるクラスを修正する必要があるときはその理由が一つだけで、一つのクラスには一種類だけの責任を持たせるようにする。\n開放・閉鎖の原則 (Open-Closed Principle) ソフトウェアのエンティティ（クラス、モジュール、関数など）は拡張に対して開いているべきだけど、修正に対しては閉じているべきだ。\nリスコフの置換原則 (Liskov Substitution Principle) サブタイプは、その基本（親）タイプと置換可能でなければならない。つまり、親クラスが登場するどんな場所でも、子クラスのインスタンスを親クラスの参照に代入できなければならない。子タイプのインスタンスがそのスーパークラスのどのインスタンスとも置き換えられるとき、それらは \u0026ldquo;is-a\u0026rdquo; 関係にあると言える。\n依存関係逆転の原則 (Dependency Inversion Principle) 抽象は詳細に依存すべきではなく、詳細は抽象に依存すべきだ。つまり、高層モジュールは低層モジュールに依存すべきではなく、両者は抽象に依存すべきなんだ。\nインターフェース分離の原則 (Interface Segregation Principle) クライアントが利用しないメソッドに依存することを強制してはいけない。インターフェースはクライアントに属するもので、それが置かれているクラス階層に属するものではない。つまり、具体的なものではなく抽象に依存し、かつ抽象レベルにおいて詳細への依存があってはいけない。こうすることで、変化に最大限対応できるようになる。\n以上がオブジェクト指向における五大原則（SOLIDの一部）だ。これらに加えて、Robert C. Martin は以下の原則も提唱しているよ。\n再利用・リリース等価の原則 (Release-Reuse Equivalency Principle) 再利用の単位はリリースの単位と等価である。\n共通閉鎖の原則 (Common Closure Principle) パッケージ内のすべてのクラスは、同じ種類の変更に対して共に閉じているべきだ。一つの変更があるパッケージに影響を与えるなら、そのパッケージ内のすべてのクラスに影響し、他のパッケージには影響を与えないようにする。\n共通再利用の原則 (Common Reuse Principle) パッケージ内のすべてのクラスは共に再利用されるべきだ。パッケージ内の一つのクラスを再利用するなら、そのパッケージ内のすべてのクラスを再利用することになる。\n非循環依存関係の原則 (Acyclic Dependencies Principle) パッケージの依存関係グラフに循環があってはいけない。つまり、パッケージ間の構造は直接的な非循環グラフでなければならない。\n安定依存の原則 (Stable Dependencies Principle) より安定した方向へ依存するようにする。\n安定抽象の原則 (Stable Abstractions Principle) パッケージの抽象度は、その安定度と一致すべきだ。\nオブジェクト指向テスト テストに関して言えば、オブジェクト指向で開発されたシステムのテストも、他の手法で開発されたものと大きな違いはないよ。\n一般的に、オブジェクト指向ソフトウェアのテストは以下の 4 つのレベルで行われる。\nアルゴリズム層 クラス層 テンプレート層 システム層 オブジェクト指向プログラミング プログラミングパラダイム (Programming Paradigm) は、プログラミングをするときの基本的な考え方のモデルだ。考え方や使うツールを決定し、一定の適用範囲を持っている。歴史的には、手続き型、モジュール化、関数型、論理型と進化してきて、今のオブジェクト指向プログラミングパラダイムに至っているんだ。\nオブジェクト指向プログラミング (Object-Oriented Programming, OOP) の本質は、オブジェクト指向プログラミング言語 (OOPL) を選び、オブジェクト、クラス、および関連する概念を用いてプログラミングを行うこと。カギとなるのは、クラスと継承を導入したことで抽象度がさらに高まった点だね。特定の OOP の概念は、通常 OOPL の特定の言語メカニズムを通じて体現されるんだ。\n今では OOP はシステム分析やソフトウェア設計の範囲まで拡張されて、オブジェクト指向分析 (OOA) やオブジェクト指向設計 (OOD) という概念が登場している。これについては、さっき説明した通りだよ。\n","date":"2023-02-25T19:34:30+08:00","permalink":"https://blog.yexca.net/ja/archives/93/","title":"オブジェクト指向の基礎"},{"content":" 📢 この記事は gemini-2.5-flash によって翻訳されました SQLシリーズ\nデータベース学習その1 データベース入門: https://blog.yexca.net/ja/archives/86 データベース学習その2 リレーションモデル: https://blog.yexca.net/ja/archives/87 データベース学習その3 SQL言語: https://blog.yexca.net/ja/archives/88 データベース学習その4 リレーショナルデータベース理論: https://blog.yexca.net/ja/archives/89 データベース学習その5 正規形: https://blog.yexca.net/ja/archives/90 データベース学習その6 データベース設計: https://blog.yexca.net/ja/archives/91 データベース学習その7 データベースの制御機能: この記事\nトランザクション管理 トランザクションって、一連の操作のことで、「全部やるか、何もやらないか」っていうものなんだ。\nトランザクションとプログラムは別物で、通常、一つのプログラムが複数のトランザクションを含んでることもあるよ。\nSQL言語では、トランザクションを定義するステートメントは次の3つがあるんだ。\n1 2 3 4 5 6 -- トランザクション開始 BEGIN TRANSACTION -- トランザクションコミット COMMIT -- トランザクションロールバック ROLLBACK トランザクションはACID特性っていうのを持ってて、原子性 (Atomicity)、一貫性 (Consistency)、独立性 (Isolation)、永続性 (Durability) があるんだ。\n1 原子性 トランザクションはアトミックだから、全部やるか、何もやらないか、どっちかなんだ。\n2 一貫性 トランザクションを実行した結果、データベースは必ず一貫性のある状態から別の、一貫性のある状態に変わるようにしないといけないよ。\nだから、データベースに成功したトランザクションのコミット結果だけが含まれてるとき、データベースは一貫性のある状態だっていうんだ。\n3 独立性 トランザクションは互いに独立してるんだ。\n複数のトランザクションが同時に実行されるとき、あるトランザクションの更新操作は、それが正常にコミットされるまでの間、他のトランザクションからは見えないんだ。\n4 永続性 トランザクションが一度成功してコミットされちゃえば、たとえデータベースがクラッシュしたとしても、そのデータベースへの更新操作はずっと有効だよ。\nデータベースのバックアップとリカバリ データベースを運用していると、コンピューターシステムのソフトウェアやハードウェアの障害はどうしても避けられないよね。これらの障害はデータベースのデータの正確さに影響を与えたり、最悪データベースを破壊して、データの一部または全部を失わせることもあるんだ。だから、データベースの肝となる技術は、冗長データ、つまりバックアップデータを作ることだよ。システム障害が発生した後に、データベースを障害前の正しい状態に迅速に戻す方法、それがデータベースリカバリ技術なんだ。\n障害の種類 データベースにおける4種類の障害\n1 トランザクション内部障害 REDO（再実行）とUNDO（取り消し）技術を使うよ。\n2 システム障害 (DBMS) システムが突然停止しちゃって、再起動が必要になるケースだね。\n3 メディア障害 ハードウェアの破損のこと。\n4 コンピューターウイルス バックアップ方法 リカバリの基本原理は「データ冗長性の構築」（重複保存）だよ。冗長データを作る方法としては、データダンプとログファイルの記録があるんだ。データダンプは、静的ダンプと動的ダンプ、全量ダンプと増分ダンプに分けられるし、ログファイルも重要だよ。\n1 静的ダンプと動的ダンプ 静的ダンプは、ダンプ中にデータベースへのいかなるアクセスや変更操作も許さない方法だよ。\n動的ダンプは、ダンプ中もデータベースへのアクセスや変更操作を許可する方法なんだ。\nだから、ダンプとユーザーのトランザクションは並行して実行できるってことだね。\n2 全量ダンプと増分ダンプ 全量ダンプは、毎回すべてのデータをダンプすることだよ。\n増分ダンプは、前回ダンプされてから更新されたデータだけをダンプすることなんだ。\n3 ログファイル トランザクション処理の過程で、DBMS（データベース管理システム）は、トランザクションの開始、終了、そしてデータベースへの挿入、削除、変更といった一つ一つの操作をログファイルに書き込むんだ。もし障害が発生したら、DBMSのリカバリサブシステムはログファイルを使って、トランザクションによるデータベースの変更を取り消し、トランザクションの初期状態に戻すんだよ。だから、DBMSはログファイルを使ってトランザクション障害からのリカバリやシステム障害からのリカバリを行うし、バックアップコピーと連携してメディア障害からのリカバリも手助けできるんだ。\nリカバリ トランザクションリカバリには次の3つのステップがあるよ。 ファイルのログを逆方向にスキャンして（つまり、ログファイルを最後から前に向かってスキャンするってこと）、そのトランザクションの更新操作を探す。 トランザクションの更新操作に対して逆操作を実行する。 引き続きログファイルを逆方向にスキャンして、そのトランザクションの他の更新操作を探し、同じ処理を行う。これをトランザクションの開始マークに到達するまで続けるんだ。 つまり、トランザクションが異常終了したら、それまでの操作を全部取り消すってことだね。\nシステム障害からのリカバリ まだ実行し終わってないトランザクションはUNDO、失われたトランザクションはREDOするんだ。\nメディア障害からのリカバリ データベースを再ロードして、すでに完了したトランザクションを再実行するよ。\n並行性制御 並行操作がもたらす問題 1 ロストアップデート（更新の消失） 僕が変更したものが反映されないんだ。例えば、ウェブサイトのロゴを変えたのに、元のままだったりとかね。\n2 ファジーリード（再現不可能な読み取り） 一つのトランザクションの中で、連続して2回データを読んだのに、違うデータが返ってきちゃうこと。 例えば、最初に銀行の残高が10元だったとするよね。そのとき、会社から突然100元の給料が振り込まれたら、2回目に読んだときには110元になっちゃう、みたいな感じ。\n3 ダーティリード（未コミット読み取り） フィールドAとBを読み取りたいんだけど、読み取ろうとしたときに他のユーザーがそれらのフィールドを更新中だった場合。 もし、相手が更新の途中で（Aは更新済み、Bは更新中）僕が読み取っちゃったら、そのとき読み取ったデータはダーティデータって言われるんだ。\n並行性制御技術 並行性制御の主な技術はロックだよ。基本的なロックのタイプには排他ロック（Xロックまたは書き込みロックって略す）と共有ロック（Sロックまたは読み取りロックって略す）があるんだ。\n1 排他ロック もしトランザクションTがデータオブジェクトAにXロックをかけたら、TだけがAを読み書きできて、他のトランザクションはTがAのロックを解放するまで、Aにどんな種類のロックもかけられなくなるんだ。\n2 共有ロック もしトランザクションTがデータオブジェクトAにSロックをかけたら、TだけがAを読み取れて、Aを変更することはできないんだ。他のトランザクションは、TがAのSロックを解放するまで、AにSロックをかけることしかできないよ。これで、他のトランザクションがAを読み取ることはできるけど、TがAのSロックを解放するまではAを何も変更できないことが保証されるんだね。\nロックプロトコル 一段ロックプロトコル（ロストアップデートを解決） 変更するときは、終了するまでXロックをかける必要があるよ。\n二段ロックプロトコル（ダーティリードを解決） 読み取るときはSロックをかけて、使い終わったらすぐ解放する。\n三段ロックプロトコル（ファジーリードを解決） 読み取るときはSロックをかけて、終了するまで解放しないんだ。\n直列化可能性 色々な状況が考えられて、それから結果が得られると仮定するね。 もし並行実行の結果が、上の結果のどれか一つと同じであればOKなんだ。\nトランザクションT1：Bを読み込み、A=B+1、Aを書き戻す トランザクションT2：Aを読み込み、B=A+1、Bを書き戻す\nじゃあ、例えばT1が先に、次にT2が実行されたとすると、A=4、B=3になるね。 もしT2が先に、次にT1が実行されたとすると、A=3、B=4になるんだ。 この並行実行は直列化可能性を満たしてるよ。\n分散データベース フラグメンテーション透過性 ユーザーやアプリケーションは、論理的にアクセスするテーブルが具体的にどうやって分割されて保存されてるかを知る必要がないんだ。\nレプリケーション透過性 レプリケーション技術を使った分散方法では、ユーザーはデータがどのノードに、どのように複製されてるかを知る必要がないよ。\nロケーション透過性 ユーザーはデータが物理的にどこに保存されているかを知る必要がないんだ。\n論理透過性 ユーザーやアプリケーションは、個々のサイトがどのデータモデルを使っているかを知る必要がないよ。\n共有性 データが異なるノードに保存されていても、データを共有できること。\n自律性 各ノードが自分のローカルデータを独立して管理できること。\n可用性 あるサイトで障害が発生しても、システムは他のサイトにあるレプリカを使って、システム全体が停止することなく機能し続けられること。\n分散性 データが異なるサイトに保存されていること。\n","date":"2023-02-12T08:15:00+08:00","permalink":"https://blog.yexca.net/ja/archives/92/","title":"データベース学習その7 データベースの制御機能"},{"content":" SQL シリーズ\nデータベース学習 1 データベース導入: https://blog.yexca.net/ja/archives/86 データベース学習 2 関係モデル: https://blog.yexca.net/ja/archives/87 データベース学習 3 SQL 言語: https://blog.yexca.net/ja/archives/88 データベース学習 4 関係データベース理論: https://blog.yexca.net/ja/archives/89 データベース学習 5 正規形: https://blog.yexca.net/ja/archives/90 データベース学習 6 データベース設計: この記事\nデータベース学習 7 データベースの制御機能: https://blog.yexca.net/ja/archives/92 📢 この記事は gemini-3-flash-preview によって翻訳されました データベース設計の戦略 トップダウン（上から下へ）とボトムアップ（下から上へ）の2つの方法があって、たいていはこの2つを組み合わせて使うよ。\nデータベース設計のステップ ニューオーリンズ法は、現在広く認められている、かなり完成度が高くて権威のあるデータベース設計手法なんだ。これはデータベース設計を主に4つの段階に分けているよ。\nユーザ要件分析：ユーザのニーズを集めて、システムの境界を決める。 概念設計：概念モデルを記述する。E-R 法を使うのが理想的だね。 論理設計：E-R 図を関係スキーマに変換して、正規化を行う。 物理設計：論理モデルをコンピュータ上で具体的にどう実現するか決める。 その後に、データベースの実施段階と、運用・保守段階へと進むんだ。\n要件分析段階 要件分析は、プロジェクトが決まった後に、ユーザと設計者が「どんなデータ（内容）を扱うか」「どんな機能（動作）が必要か」を整理して記述すること。つまり、ユーザの視点からシステムを理解する作業だね。\nこのプロセスは、その後の論理設計や物理設計、それにアプリケーション設計のすべての根拠になる、とっても大事な基礎なんだ。\n要件分析段階の作業 組織の状況調査 → 業務活動の把握 → ユーザ要件の明確化 → システムの境界決定 → システム機能の分析 → システムデータの分析 → 分析報告書の作成\n要件分析段階のドキュメント 調査で得られたデータは断片的だったり局所的だったりするから、分析担当者と設計者はさらに分析を進めてユーザの要望を表現し、要件定義書、データ辞書、データフロー図 (DFD) を作る必要があるよ。\nE-R モデル E-R (実体-関連) モデルは概念モデルの一つで、現実世界を表現するために使われるよ。\n実体 (Entity) 長方形で表して、枠の中に実体名を書くよ。\n関連 (Relationship) ひし形で表して、枠の中に関連名を書く。実体と無向線（矢印のない線）でつなぎ、線の横に関連のタイプ (1 : 1、1 : n、m : n) を書き込むんだ。\n\u0026lt;1\u0026gt; 2つの異なる実体間の関連\n1対1 (1 : 1)：実体集合 E1 の1つの実体が、実体集合 E2 の最大1つの実体と関連していること。 1対多 (1 : n)：実体集合 E1 の1つの実体が、実体集合 E2 の複数の実体と関連できること。 多対多 (m : n)：実体集合 E1 の複数の実体が、実体集合 E2 の複数の実体と関連できること。 \u0026lt;2\u0026gt; 3つ以上の異なる実体集合間の関連\n3つ以上の実体集合の間でも、1 : 1 : 1、1 : 1 : n、1 : m : n、r : n : m といった関連が存在するよ。\n\u0026lt;3\u0026gt; 同一実体集合内のバイナリ関連\n同じ実体集合の中の実体同士でも、1 : 1、1 : n、m : n の関連があるんだ（例：上司と部下など）。\n属性 (Attribute) 属性は実体の持つ特徴のことで、楕円で表すよ。枠の中に属性名を書き（主キーには下線を引く）、実体と線でつなぐ。\nそれぞれの属性には値の範囲（ドメイン）があるんだ。同じ実体集合なら属性やドメインは同じだけど、具体的な値は実体ごとに異なるよ。\nE-R モデルの属性には、こんな分類がある：\n単純属性と複合属性 単純属性は、それ以上分解できない最小単位のもの。複合属性は、さらに小さな部分（別の属性）に分けられるもの。 特に断りがない場合は、ふつう単純属性を指すよ。\n単値属性と多値属性 単値属性は、ある特定の実体に対して値が1つだけ決まるもの。 多値属性は、値が複数あるもの。\nNULL 属性 実体がある属性の値を持っていない、あるいは不明なときに NULL 値を使うよ。「意味がない」か「わからない」ってことだね。\n派生属性 他の属性から計算して導き出せる属性のこと。 例えば、社員に「入社日」と「勤続年数」という属性があるとき、「勤続年数」は「現在の日付」と「入社日」の差から計算できるよね。この場合「勤続年数」が派生属性になるんだ。\n弱実体 (Weak Entity) 現実世界には、実体間の従属関係を表す特殊な関連があるんだ。例えば「社員」と「家族」の関連。家族は常に特定の社員に属しているよね。このように、ある実体の存在が別の実体の存在を前提としている場合、その実体を「弱実体」と呼ぶよ。\nE-R 図では、弱実体は二重線の長方形で表すんだ。\nスーパークラスとサブクラス 例えば「職員」という実体は、「パイロット」「整備士」「管理者」という実体のスーパークラス（親クラス）になれる。スーパークラスとサブクラスの間には継承関係があるよ。\nサブクラスの長方形は両端に縦線があり、スーパークラスとの連結線には丸印（○）がつくんだ。\n概念構造設計段階 E-R 法を使って概念モデルを構築する段階だよ。\n要件分析で得られたデータを分類・整理して、実体、属性、関連を特定していく。具体的なステップとしては、局所的な応用範囲を選び、個別の E-R 図（部分 E-R 図）を設計し、それらを最後に統合するんだ。\n要件分析 → データの抽象化 → 部分ビューの設計 → 統合と衝突の解消 → 冗長性の排除と修正 → 論理構造設計へ\n局所的な応用の選択 データフロー図 (DFD) の適切なレベルを選んで、その各部分を1つの局所的な応用に対応させ、特定の機能を実現するようにするよ。\n部分 E-R 図の設計 各応用範囲を分けた後、それぞれに対して E-R 図（部分 E-R 図、またはローカル E-R 図）を設計していくんだ。\nE-R 図の統合 部分 E-R 図ができあがったら、それらを1つにまとめる。このとき、図の間で起きている衝突を解決するのが目的だよ。最終的に1つのグローバル E-R 図を完成させるんだ。\n衝突には主に次の3つのタイプがある：\n属性の衝突 同じ属性が別の部分 E-R 図にあるとき、設計者や視点の違いで、型、値の範囲、単位などが一致しないことがある。コンピュータには1つの形式でしか保存できないから、ここで統一する必要があるんだ。\n命名の衝突 意味は同じなのに名前が違う、あるいは名前は同じなのに意味が違う、といったケース。これも統一が必要だね。\n構造の衝突 同じ実体が別の図で違う属性を持っていたり、ある図では「実体」として扱われているのに別の図では「属性」として扱われていたりすること。これも調整が必要だよ。\n論理構造設計段階 概念設計をもとにして、具体的なデータモデル（階層型、網型、関係型など）に合わせて設計する段階。ここでは、グローバル E-R 図から関係モデルの論理構造を作る方法を説明するね。主なステップは、データモデルの決定、E-R 図からの変換、完全性制約（実体完全性、参照完全性、ユーザ定義完全性）の決定、そしてユーザビューの作成だよ。\n概念設計 → データモデルへの変換 → 正規化 → スキーマの最適化 → ユーザサブスキーマの設計 → 物理設計へ\nE-R 図から関係スキーマへの変換 E-R 図は情報の世界を記述したもので、そのままではコンピュータで処理しにくいんだ。だから関係データベースで扱えるように「関係スキーマ」に変換するよ。E-R 図の3要素（実体、属性、関連）を、関係スキーマという唯一の構造に変換していくんだ。\n一、実体から関係スキーマへの変換 E-R 図の各実体を、それぞれ1つの関係スキーマに変換する。実体名がスキーマ名になり、実体の属性がスキーマの属性になる。実体の識別子（ID）が関係のキーになるよ。\n二、関連から関係スキーマへの変換 1対1関連の変換 1つの方法は、関連をどちらか一方の実体のスキーマに統合すること。統合先の属性セットに、もう一方の実体の主キーと、関連自体が持っている属性を追加すればOK。主キーは元のままだよ。\nもう1つの方法（あまり使われないけど）は、関連を独立した1つの関係スキーマにすること。名前は関連名にして、属性には関連する両方の実体の主キーと関連自体の属性を入れる。キーはどちらか一方の主キーを選べばいい。\n1対多関連の変換 1つの方法は、関連を「多」側の実体のスキーマに統合すること。「多」側の属性セットに、「1」側の実体の主キーと関連の属性を追加する。主キーは「多」側のもののままだよ。\nもう1つの方法（これもあまり使われない）は、独立したスキーマを作ること。属性は両方の実体の主キーと関連の属性。キーは「多」側の実体の主キーになるよ。\n多対多関連の変換 多対多の場合は、必ず独立した関係スキーマにする必要があるんだ。スキーマ名は関連名。属性は、関連する両方の実体の主キーと、関連自体の属性。キーは、両方の主キーを組み合わせたものになるよ。\n多対多対多（3元以上）関連の変換 3つの場合とだいたい同じだよ。\nスーパークラスとサブクラスの変換 スーパークラスもサブクラスも、それぞれ1つの関係に変換できる。このとき、スーパークラスの主キーをサブクラスの関係にも追加してあげるんだ。\n関係スキーマの正規化 意味論（セマンティクス）にもとづいて、各スキーマのデータ依存性を特定する。 データ依存性にもとづいて、正規形（第1〜第5正規形など）を確認する。 条件を満たしていない場合は、分解アルゴリズムを使って、3NF、BCNF、あるいは 4NF まで分解する。 関係スキーマの評価と修正を行う。 物理設計段階 論理設計 → データベースの物理構造（物理モード）の決定 → 物理構造の評価 → 実施段階へ\nデータベースの実施と保守 物理設計 → データベースの定義 → データの流し込みとアプリ作成 → 試運転 → 運用・保守段階へ\n","date":"2023-02-11T08:15:00+08:00","permalink":"https://blog.yexca.net/ja/archives/91/","title":"データベース学習 6 データベース設計"},{"content":" SQLシリーズ\nデータベース学習その1 データベース入門: https://blog.yexca.net/ja/archives/86 データベース学習その2 リレーショナルモデル: https://blog.yexca.net/ja/archives/87 データベース学習その3 SQL言語: https://blog.yexca.net/ja/archives/88 データベース学習その4 リレーショナルデータベース理論: https://blog.yexca.net/ja/archives/89 データベース学習その5 範式: この記事\nデータベース学習その6 データベース設計: https://blog.yexca.net/ja/archives/91 データベース学習その7 データベースの制御機能: https://blog.yexca.net/ja/archives/92 📢 この記事は gemini-2.5-flash によって翻訳されました リレーショナルデータベースにおけるリレーションは、一定の正規化要件を満たす必要があるよ。異なる正規化の程度は、範式（ノーマルフ​​ォーム）で測ることができるんだ。現在、主に6種類の範式があるよ：1NF、2NF、3NF、BCNF、4NF、5NF。\n最低限の要件を満たすものを1NFと呼び、1NFをベースにさらにいくつかの要件を満たすものが2NF、といった具合だね。これらの範式の中で、最も重要なのは3NFとBCNFで、これらが正規化を行う上での主要な目標になるよ。\nより低い範式のリレーションスキーマは、スキーマ分解によって、いくつかのより高い範式のリレーションスキーマの集合に変換できるんだ。このプロセスを正規化と呼ぶよ。\n第一正規形 (1NF) 定義：Rをリレーションスキーマとするね。Rが第一正規形に属するのは、R内のすべての属性Aの値域が原子項、つまり分割不可能なデータ項目のみを含む場合、かつその場合に限るよ。\n1NFでは、データの冗長性、更新（挿入、削除）異常、変更の複雑さといった問題を排除できないんだ。なぜなら、部分関数従属が存在する可能性があるからね。\n第二正規形 (2NF) 定義：Rをリレーションスキーマとするね。Rが第二正規形に属するのは、Rが1NFであり、かつすべての非主キー属性が候補キーに完全関数従属している場合、かつその場合に限るよ。\n2NFに属するリレーションスキーマRでも、データの冗長性や更新異常といった問題が発生する可能性があるんだ。なぜなら、推移的関数従属が存在する可能性があるからね。\n第三正規形 (3NF) 定義：Rをリレーションスキーマとするね。Rが第三正規形に属するのは、Rが2NFであり、かつすべての非主キー属性が候補キーに非推移的従属している場合、かつその場合に限るよ。\n3NFに属するリレーションスキーマRでは、主キー属性がキーに対して部分従属したり、推移的従属したりする可能性があるんだ。\nBC正規形 (BCNF) 定義：Rをリレーションスキーマ、Fをその従属関係の集合とするね。RがBCNFに属するのは、Rが3NFであり、かつF内の各従属関係の決定因子が必ずRのいずれかの候補キーを含む場合、かつその場合に限るよ。\nBCNFの定義から、BCNFを満たすリレーションスキーマには以下の特徴があることがわかるよ：\nすべての非主キー属性が、各キーに対して完全関数従属している すべての主キー属性が、自分自身を含まない各キーに対しても完全関数従属している いかなる属性も、非キーのいかなる属性集合に対しても完全関数従属していない BCNFを満たすリレーションスキーマRは、挿入異常と削除異常をすでに解消しているんだ。\n2つの属性しかないリレーションスキーマは、必ずBCNFだよ\n第四正規形 (4NF) 定義：リレーションスキーマ R\u0026lt;U, F\u0026gt; が1NFであるとするね。もしRの各非自明な多値従属 X →→ Y (Y ⊈ X) について、XがRのいずれかの候補キーを含んでいる場合、Rは第四正規形であると言うよ。\n多値従属 与えられたリレーションスキーマ R\u0026lt;U, F\u0026gt; において、X、Y、ZがUの部分集合で、かつZ = U - X - Yとするね。リレーションスキーマRにおける多値従属 X →→ Y が成立するのは、Rの任意のリレーションrに対して、(x, z) の値のペアが与えられたとき、Yの値の集合が存在し、その集合がxの値のみによって決定され、zの値とは無関係である場合、かつその場合に限るよ。\n自明な多値従属 もし上記の多値従属の定義において X →→ Y が成立し、かつZが空集合である場合、X →→ Y を自明な多値従属と呼ぶよ。\n正規形まとめ 1NF（第一正規形） すべてのフィールド値が分割不可能な原子値であること\n2NF（第二正規形） 非主キー属性がキーに対して部分関数従属を含まないこと。一つのテーブルには一つの種類のデータしか保存できず、複数の種類のデータを同じデータベーステーブルに保存してはいけないよ。\n3NF（第三正規形） 非主キー属性がキーに対して推移的関数従属を含まないこと。データテーブルの各列データが主キーに直接関連していることを保証し、間接的には関連しないようにするんだ。\nBCNF（BC正規形） 各属性の候補キーに対する推移的従属を解消すること。BCNFは修正された3NFだよ。\n1NF → 2NF：非主キー属性のキーに対する部分関数従属を解消する\n2NF → 3NF：非主キー属性のキーに対する推移的関数従属を解消する\n3NF → BCNF：主キー属性のキーに対する部分関数従属と推移的関数従属を解消する\nBCNF → 4NF：非自明かつ非関数従属の多値従属を解消する\n候補キーが単一属性の場合、少なくとも2NFだよ\nリレーションスキーマの分解 データ冗長性、挿入異常、削除異常の問題があるリレーションスキーマに対しては、一つのリレーションスキーマを複数のリレーションスキーマに分解する方法で処理するべきだよ。それに応じて、元々一つの2次元テーブルに格納されていたデータは、複数の2次元テーブルに分散されることになるね。この分解が意味を持つためには、少なくとも後者が前者の情報を失わないことが最低限の要件となるんだ。\n分解処理ではいくつかの新しい問題が出てくることがあるよ。分解後のスキーマが元のスキーマが満たしていた特性を維持するためには、スキーマ分解が無損失分解性と関数従属保存性を持っていることが基本的な要件なんだ。\n無損失分解 無損失分解とは、リレーションスキーマを分解する際、元のリレーションスキーマ下の任意の有効なリレーションインスタンスが、分解後に自然結合演算によって復元できることを指すよ。\nつまり、分解されたリレーションが自然結合によって元のリレーションに復元できるってことだね。\n関数従属保存性 スキーマ分解後のF\u0026rsquo;（各サブスキーマの関数従属の和集合）がF（元の関数従属集合）と等価かどうか、F\u0026rsquo;がF中のすべての関数従属を含んでいれば、関数従属保存性があると言えるよ（十分条件）。\nつまり分解後も従属関係は変わらないってこと。\n参考： スキーマ分解における関数従属保存性の判断—データベース試験復習_guoyp2126のブログ-CSDNブログ R (ABCDEGH), F={A-\u0026gt;D, E-\u0026gt;D, D-\u0026gt;B, BC-\u0026gt;D,DC-\u0026gt;A} が与えられているね。関数従属を保存する3NF分解を求めてみるよ。\n1）最小関数従属集合を求める\n2）Fに含まれない属性をすべて見つけ出し、個別に分類する\n3）各従属関係の左側が同じものを一組にまとめる。同じものがない場合は、A-\u0026gt;Dを{AD}のように変更する。もし{A-\u0026gt;B,A-\u0026gt;C}のように同じものがあれば、{ABC}のようにするんだ。\n4）候補キーが分離されたものの中に現れない場合、任意の候補キーを一つの分類とする。\n最小関数従属集合Fmin={A-\u0026gt;D, E-\u0026gt;D, D-\u0026gt;B, BC-\u0026gt;D, DC-\u0026gt;A}\nGHはFに含まれていないから、{GH}として個別に分類するよ。\n候補キー：CE\nAE\n{AD}{ED}{DB}{BCD}{DCA}{CE}{GH}\n","date":"2023-02-10T08:13:00+08:00","permalink":"https://blog.yexca.net/ja/archives/90/","title":"データベース学習その5 範式"},{"content":" 📢 この記事は gemini-3-flash-preview によって翻訳されました SQL シリーズ\nデータベース学習1 データベース導入: https://blog.yexca.net/ja/archives/86 データベース学習2 関係モデル: https://blog.yexca.net/ja/archives/87 データベース学習3 SQL言語: https://blog.yexca.net/ja/archives/88 データベース学習4 関係データベース理論: この記事\nデータベース学習5 正規形: https://blog.yexca.net/ja/archives/90 データベース学習6 データベース設計: https://blog.yexca.net/ja/archives/91 データベース学習7 データベースの制御機能: https://blog.yexca.net/ja/archives/92 関係スキーマ 関係スキーマ（リレーショナルスキーマ）は、5つの要素（5組）で構成されるものなんだ（関係名を含む）。\nR\u0026lt;U, D, dom, F\u0026gt;\nR は関係名で、記号化されたタプルの意味を表すよ。 U は属性の集合。 属性集合 U の中の属性はドメイン D から来ている。 dom は属性リストからドメインへのマッピング。 F は属性集合 U 上のデータ依存性（関数従属性）の集合。 3番目と4番目のポイントはスキーマ設計にはあまり関係ないから、普通は関係スキーマを3つの要素（三つ組）として扱うよ：R\u0026lt;U, F\u0026gt;。U 上のある関係 r が F を満たすとき、r を関係スキーマ R\u0026lt;U, F\u0026gt; の一つの関係と呼ぶんだ。\n例えば：R を成績表、U を (学籍番号, 氏名, コース番号, 成績)、F を {学籍番号 → 氏名, コース番号 → コース名, (学籍番号, コース番号) → 成績} とする。\n関数従属性 関数従属性は、最も重要で基本的なデータ依存性の一つだよ。\nR(U) を属性集合 U 上の関係スキーマ、X、Y を U の部分集合とする。R(U) のどんな関係 r においても、r の中に X の属性値が等しいのに Y の属性値が異なる2つのタプルが存在し得ないとき、X は Y を関数的に決定する、または Y は X に関数従属していると言い、X → Y と書くよ。\n非自明な関数従属性 X → Y だが Y ⊈ X の場合、X → Y を非自明な関数従属性と呼ぶ。普通、議論するのはこの非自明な関数従属性だよ。\n自明な関数従属性 X → Y かつ Y ⊆ X の場合、X → Y を自明な関数従属性と呼ぶ。\n完全関数従属性 R(U) において X → Y であり、かつ X のいかなる真部分集合 X\u0026rsquo; に対しても X\u0026rsquo; が Y を決定できないとき、Y は X に完全関数従属していると言い、X -F-\u0026gt; Y と書く。\n部分関数従属性 X → Y だが、Y が X に完全関数従属していない場合、Y は X に部分関数従属していると言い、X -P-\u0026gt; Y と書く。\n推移的従属性 R(U, F) において X → Y、Y ⊈ X、Y → Z のとき、Z は X に推移的に従属していると言うよ。\n参考： Untitled Document (pop0726.github.io) キー (码) K を R(U, F) の属性の組み合わせとする。もし K → U であり、かつ K のいかなる真部分集合 K\u0026rsquo; に対しても K\u0026rsquo; が U を決定できないなら、K は R の候補キー（Candidate Key）になる。候補キーが複数ある場合は、その中から1つを主キー（Primary Key）として選ぶよ。\n主属性と非主属性 いずれかの候補キーに含まれる属性を主属性と呼び、そうでないものを非主属性と呼ぶ。\n外部キー (Foreign Key) R(U) の属性または属性集合 X が R のキーではないが、別の関係のキーである場合、X を外部キーと呼ぶ。\n超キー (Super Key) すべての属性を表すことができる集合のこと。候補キーは最小の超キーなんだ。\n全キー (All-Key) すべての属性が主属性である場合のこと。\n関数従属性の公理系 (Armstrong の公理系) 関係スキーマ R(U, F) において、U を属性集合、F を U 上の関数従属性の集合とすると、以下の推論規則があるよ。\n反射律：Y ⊆ X ⊆ U ならば、X → Y は F から導かれる。 増強律：X → Y が F から導かれ、かつ Z ⊆ U ならば、XZ → YZ は F から導かれる。 推移律：X → Y と Y → Z が F から導かれるならば、X → Z は F から導かれる。 これら3つの規則から、さらに以下の規則も導き出せるんだ。\n合併規則：X → Y かつ X → Z ならば、X → YZ は F から導かれる。 擬推移律：X → Y かつ WY → Z が F から導かれるならば、XW → Z は F から導かれる。 分解規則：X → Y かつ Z ⊆ Y ならば、X → Z は F から導かれる。 属性の閉包計算 閉包計算は候補キーを見つけるために使うよ。どうやって候補キーを選ぶかというと：\n左側にしか現れない属性は、必ず候補キーに含まれる。 右側にしか現れない属性は、絶対に候補キーにはならない。 両方に現れる属性は、含まれるかもしれないし、含まれないかもしれない。 どちらにも現れない属性は、必ず候補キーに含まれる。 確定した属性の閉包を求めて、すべての属性が導き出せればそれが候補キー。そうでなければ、可能性のある属性を組み合わせて閉包を求めていくよ。 例えば：\nR\u0026lt;U, F\u0026gt;、U(A, B, C, D, E, G)、F = {AB → C, CD → E, E → A, A → G} の候補キーを求める。\n左側にしか現れない：B, D（必ず候補キーに入る） 右側にしか現れない：G（絶対に入らない） 両方に現れる：A, C, E（わからない） 閉包を求める BD → 何も導き出せない。だから、可能性のある属性を一つずつ足して閉包を求めてみる。\n(BDA)+：C, E, A, G が導ける。よって ABCDEG すべて導き出せる。\n(BDC)+：E, A, G が導ける。よって ABCDEG すべて導き出せる。\n(BDE)+：A, G, C が導ける。よって ABCDEG すべて導き出せる。\nというわけで、最終的な候補キーは {(BDA), (BDC), (BDE)} になるよ。\n最小関数従属性集合を求める 最小依存集合（最小カバー）はどうやって求めるのかな？\n1）右辺を単一属性にする（例えば A → BC を A → B と A → C に分ける）。\n2）現在の従属性を除外してその属性の閉包を求め、冗長なものを消していく。\n3）左辺を最小化する（属性を一つ隠しても、他の属性でその属性が導き出せるか確認する）。\n例えば BCD で、B を隠して CD から B が導き出せるか、C を隠して BD から C が導き出せるか、D を隠して BC から D が導き出せるかを見るんだ。\n例：\n関係 R\u0026lt;U, F\u0026gt;、U{A, B, C, D, E, F, G}\nF = {BCD-\u0026gt;A, BC-\u0026gt;E, A-\u0026gt;F, F-\u0026gt;G, C-\u0026gt;D, A-\u0026gt;G} の最小依存集合を求める。\n解：\n// (1) 右辺の分解と冗長性のチェック\n(BCD)+ = BCDED\n(BC)+ = BCD\n(A)+ = AG\n(F)+ = F\n(C)+ = C\n(A)+ = AFG (A-\u0026gt;G は A-\u0026gt;F と F-\u0026gt;G から導けるので削除)\n// (2) 左辺の最小化\nBCD-\u0026gt;A において C-\u0026gt;D なので、BC-\u0026gt;A に簡略化できる。\n結果：\nBC-\u0026gt;A\nBC-\u0026gt;E\nA-\u0026gt;F\nF-\u0026gt;G\nC-\u0026gt;D\n","date":"2023-02-09T08:10:00+08:00","permalink":"https://blog.yexca.net/ja/archives/89/","title":"データベース学習その4 関係データベース理論"},{"content":" 📢 この記事は Google 翻訳を使用して処理されました SQL シリーズ\nデータベース学習1 データベース導入: https://blog.yexca.net/ja/archives/86 データベース学習2 関係モデル: https://blog.yexca.net/ja/archives/87 データベース学習3 SQL言語: この記事\nデータベース学習4 関係データベース理論: https://blog.yexca.net/ja/archives/89 データベース学習5 正規形: https://blog.yexca.net/ja/archives/90 データベース学習6 データベース設計: https://blog.yexca.net/ja/archives/91 データベース学習7 データベースの制御機能: https://blog.yexca.net/ja/archives/92 SQL言語の分類 DDL（データ定義言語） データベースシステムでは、データベース内の各データベース、テーブル、ビュー、インデックスなどがデータベースオブジェクトです。データベースオブジェクトを作成または削除するには、SQL 言語を使用します。 DDL には CREATE、ALTER、DROP などが含まれます。\nDML（データ操作言語） DML は、INSERT、DELETE、UPDATE など、データベース内のデータを追加、変更、削除するために使用されるステートメントを指します。\nDQL (データクエリ言語) クエリはデータベースの基本機能であり、クエリ操作は SQL データ クエリ言語を通じて実装されます。たとえば、テーブルの内容を照会するにはSELECTを使用します。\nDCL（データ制御言語） DCL には、データベース オブジェクトの権限管理やトランザクション管理などが含まれます。\n(I) DDLデータ定義言語 1. データベースを作成する 1 create database \u0026lt;データベース名\u0026gt; 2。基本テーブルを作成します 1 2 3 4 5 6 7 create table \u0026lt;テーブル名\u0026gt; ( \u0026lt;列名\u0026gt; \u0026lt;データ型\u0026gt; [列レベルの整合性制約], [···,] [テーブルレベルの整合性制約,] [···] ) \u0026lt;1\u0026gt; データタイプ INT / INTEGER : 整数 FLOAT(n): 少なくともn桁の精度を持つ浮動小数点数 NUMERIC(p, d) / DECIMAL(p, d) / DEC(p, d): p桁（符号と小数点を除く）のd桁の固定小数点数小数点以下の数字 CHAR(n): 長さnの固定長文字列 DATETIME: 日付と時刻の型 1 2 3 4 5 6 -- 例えば create table test ( f1 char(10), f2 int ) \u0026lt;2\u0026gt; ラインレベルの整合性の制約 not null: 空ではない\nunique: ユニーク\nnot null unique: 空ではなくユニーク\ndefault: デフォルト値を定義する\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 -- 例えば create table test ( f1 int not null, -- この列は空にできません f2 int unique, -- この列の値は空でも構いませんが、各行は異なる必要があります f3 int not null unique, -- 列は空ではなく、各行は異なります f4 char(5) default \u0026#39;nashi\u0026#39; -- 新しく追加された行に値が割り当てられていない場合、この列はデフォルトで「nashi」になります。 ) \u0026lt;3\u0026gt; テーブルレベルの整合性の制約 名前 条項 通信の完全性 主キー句 PRIMARY KEY エンティティの整合性 チェック条項 CHECK ユーザー定義の整合性 外部キー句 FOREIGN KEY 参照整合性 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 -- 例えば create table student ( sid int, primary key(sid) -- not null unique ) -- または create table student ( sid int primary key ) create table course ( cid int, sid int, score int, check(score \u0026gt;= 0 and score \u0026lt;= 100), foreign key(sid) references student(sid) ) 整合性の検査 アサート（通常は推奨されません） 1 2 3 4 CREATE ASSERTION \u0026lt;アサーション名\u0026gt; \u0026lt;チェック条項\u0026gt; -- チェック句は、where 句の式に似ています。 -- アサーション名を削除 DROP ASSERTION \u0026lt;断言名\u0026gt;; トリガー テーブルが追加、削除、または変更されると、トリガー内の条件がチェックされます。条件が満たされている場合はトリガー内のアクションが実行され、満たされていない場合はアクションは実行されません。\n1 2 3 4 5 6 7 8 9 10 11 12 13 CREATE TRIGGER \u0026lt;トリガー名\u0026gt; -- トリガー イベントが発生するたびに、トリガーがアクティブになります。 {BEFORE|AFTER} \u0026lt;トリガーイベント\u0026gt; ON \u0026lt;テーブル名\u0026gt; -- トリガー イベントの実行前または実行後にトリガーがアクティブ化されるかどうかを示します。 REFERERCING NEW|OLD ROW AS \u0026lt;変数\u0026gt; -- REFERENCINGは参照される変数を示す FOR EACH{ROW|STATEMENT} -- トリガーの種類を定義し、アクション本体の実行頻度を指定します。 [WHEN \u0026lt;トリガーイベント\u0026gt;] \u0026lt;トリガーアクション本体\u0026gt; -- トリガーアクションはトリガー条件が真の場合にのみ実行されます -- トリガーの削除 DROP TRIGGER \u0026lt;トリガー名\u0026gt; ON \u0026lt;テーブル名\u0026gt; 3。基本的なテーブル構造を変更します 新しい列を追加する 1 2 3 4 alter table \u0026lt;テーブル名\u0026gt; add \u0026lt;列名\u0026gt; \u0026lt;タイプ\u0026gt; -- 例えば alter table test add f3 datetime 列を変更する* 1 2 3 4 5 6 7 alter table \u0026lt;テーブル名\u0026gt; alter column \u0026lt;列名\u0026gt; \u0026lt;新しいタイプ\u0026gt; -- MySQL -- alter table \u0026lt;テーブル名\u0026gt; modify \u0026lt;列名\u0026gt; \u0026lt;新しいタイプ\u0026gt; -- 例えば alter table test alter column f3 float -- alter table test modify f3 float 列の削除 1 2 3 4 5 6 7 alter table \u0026lt;テーブル名\u0026gt; drop column \u0026lt;列名\u0026gt; -- MySQL -- alter table \u0026lt;テーブル名\u0026gt; drop \u0026lt;列名\u0026gt; -- 例えば alter table test drop column f3 -- alter table test drop f3 4。基本テーブルを削除します 1 2 3 4 drop table \u0026lt;テーブル名\u0026gt; -- 例えば drop table test (二)、DML データ操作言語 次のコンテンツの例は、これらのテーブルに基づいています\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 -- 注: 理解しやすいように中国語を使用しています。実際の開発では英語を使用してください。 -- 学生テーブル create table student ( 学号 char(5) not null unique, 姓名 char(8), 性别 char(2), 出生日期 datetime, 班号 char(5) ) -- 成績テーブル create table score ( 学号 char(5), 课程号 char(5), 分数 int ) -- 教師テーブル create table teacher ( 教师编号 char(5) not null unique, 姓名 char(8), 性别 char(2), 出生日期 datetime, 职称 char(6), 系别 char(10) ) -- コーススケジュール create table course ( 课程号 char(5) not null unique, 课程名 char(20), 任课教师编号 char(5) ) 1. INSERT ステートメントを挿入 SQL基本テーブルにデータを挿入する方法は2つあります。タプル値を直接挿入するか、クエリの結果値を挿入するかです。\nタプル値を直接挿入する 1 2 3 4 5 6 7 8 9 10 11 12 13 insert into テーブル名[(列名の順序)] values (タプル値)[, ···] -- 或者 insert into テーブル名[(列名の順序)] (table (タプル値)[, (タプル値), ···]) -- 例如 insert into student values (\u0026#39;108\u0026#39;, \u0026#39;张三\u0026#39;, \u0026#39;男\u0026#39;, \u0026#39;2000-01-01\u0026#39;, \u0026#39;09033\u0026#39;), (\u0026#39;109\u0026#39;, \u0026#39;李四\u0026#39;, \u0026#39;男\u0026#39;, \u0026#39;2000-05-05\u0026#39;, \u0026#39;09034\u0026#39;) -- 指定した列を挿入する insert into student(学号，姓名，性别，出生日期) values (110, \u0026#39;王五\u0026#39;, \u0026#39;男\u0026#39;, \u0026#39;2000-04-18\u0026#39;) クエリの結果値を挿入する 1 2 3 4 5 insert into テーブル名[(列名の順序)] select \u0026lt;クエリステートメント\u0026gt; -- 例えば insert into student select 111, \u0026#39;赵六\u0026#39;, \u0026#39;男\u0026#39;, \u0026#39;2000-03-19\u0026#39;, \u0026#39;09035\u0026#39; 2. DELETE 削除ステートメント 1 2 3 4 5 6 7 delete from \u0026lt;テーブル名\u0026gt; [where \u0026lt;条件式\u0026gt;] -- 例えば delete from student -- テーブル全体を削除する -- 生徒番号111のタプルを削除します delete from student where 学号 = 111 3. UPDATE ステートメントを修正 1 2 3 4 5 6 7 8 9 10 11 12 update \u0026lt;テーブル名\u0026gt; set \u0026lt;列名\u0026gt; = \u0026lt;価値表現\u0026gt;[, ···] [where \u0026lt;条件式\u0026gt;] -- 例えば update student set 班号 = \u0026#39;09058\u0026#39; where 学号 = 110 -- または update student set 班号 = \u0026#39;09057\u0026#39;, 性别 = \u0026#39;女\u0026#39; where 学号 = 110 and 班号 = \u0026#39;09058\u0026#39; (三)、DQL データクエリ言語 SQL データクエリ機能は SELECT 文を通じて実装されます。完全な構文は次のとおりです。\n1 2 3 4 5 6 select \u0026lt;対象テーブルの列名または列式のシーケンス\u0026gt; from \u0026lt;リレーションテーブルシーケンス\u0026gt; [where \u0026lt;行条件式\u0026gt;] [group by \u0026lt;列名の順序\u0026gt;] [having \u0026lt;グループ条件式\u0026gt;] [order by \u0026lt;列名\u0026gt; [asc|desc]] 1. 投影クエリ クエリ テーブル内の任意の列を選択するには、SELECT コマンドを使用します。複数の列がある場合は、カンマ , を使用して区切ります。 FROM句に複数のリレーショナルテーブルがある場合、各テーブルの名前を記述する必要があります。\n1 2 3 4 5 6 7 8 9 -- 例えば select 1 + 1 select 学号 * 100 from student -- 学生IDとスコアを照会する select student.学号, score.分数 from student, score -- すべての列をクエリする select * from student 重複行を削除するには DISTINCT を使用します\n1 2 3 -- 重複行を削除し、選択したコースを照会する select distinct 课程号 from score クエリ結果の列名をカスタマイズするには AS を使用します\n1 2 3 -- 例えば select 学号 as \u0026#39;sno\u0026#39; from student 2. クエリを選択 選択クエリは、クエリ条件を指定し、ソース テーブルからクエリ条件を満たすレコードのみを抽出または表示します。\n選択クエリでは通常、次の種類の操作が使用されます。\nオペレーター コード 説明する セットメンバーシップ演算子 IN\nNOT IN セット内\nセットに含まれない 文字列マッチング演算子 LIKE _ および % を使用した単一または複数の文字の一致 NULL比較演算子 IS NULL\nIS NOT NULL 空の\n空にすることはできません 算術演算子 \u0026gt;\n\u0026gt;=\n\u0026laquo;br /\u0026gt;\u0026lt;=\n=\n\u0026lt;\u0026gt; より大きい\nより大きいか等しい\n未満\n以下\n等しい\n等しくない \u0026lt;1\u0026gt; 条件式の比較演算 1 2 3 4 5 6 --- スコアが60～80のレコードを検索する select * from score where 分数 between 60 and 80 -- 60と80を含めるにはbetweenを使用します。つまり[60, 80]です。 -- スコア \u0026gt;= 60 かつスコア \u0026lt;= 80 の場合と同等 \u0026lt;2\u0026gt; 文字列マッチング操作 1 where [not] like \u0026#39;一致する文字列\u0026#39; [escape \u0026#39;一致する文字列\u0026#39;] '一致文字列' は完全な文字列にすることも、ワイルドカード文字 % と _ を含めることもできます。\n%: 任意の長さの文字を表します _ : 任意の1文字を表す \u0026lt;3\u0026gt; 集合の比較演算 1 2 3 4 -- スコアが85、86、または88のレコードをクエリします select * from score where 分数 in (85, 86, 88) \u0026lt;4\u0026gt; 論理的結合演算 1 2 3 4 -- クラス09031の女子生徒全員を照会する select * from student where 班号 = \u0026#39;09031\u0026#39; and 性别 = \u0026#39;女\u0026#39; 3. 並べ替えクエリ クエリ結果はORDER BY句を使用して並べ替えることができます。\n1 2 3 4 5 6 7 8 -- 昇順 asc (デフォルト、省略可能) select 学号, 姓名 from student order by 学号 -- 降順 desc select 学号, 姓名 from student order by 学号 desc 複数の列を指定して並べ替えることもできます。最初の列が最初に並べ替えられ、次に2番目の列が並べ替えられます。\n1 2 3 4 -- コース番号の昇順とスコアの降順で検索結果を表示します select * from score order by 课程号 asc, 分数 desc ORDER BY 句はクエリの最後に配置する必要があります。\n4. 集計関数 集計関数は、データ統計やその他の機能を実装します。一連の値を計算し、単一の値を返すために使用されます。\n通常は group by 句とともに使用される一般的な集計関数は次のとおりです。\n関数名 説明 AVG 平均値 COUNT 指定された式で選択された項目の数をカウントします\nCOUNT(*)はクエリによって出力された行数をカウントします MIN 最小値 MAX 最大値 SUM 値の合計 STDWV 指定された式のすべてのデータの標準偏差を計算します STDEVP 母集団標準偏差 集計関数の引数の一般的な形式は次のとおりです。\n1 [all|distinct] expr このうち、ALL はすべての値に対して集計関数演算を実行することを意味し、これがデフォルト値となります。また、DISTINCT は、すべての一意の値が考慮されることを指定します。 exprは式です\n1 2 3 4 -- クラス「09031」の生徒数を照会する select count(*) as \u0026#39;人数\u0026#39; from student where 班号 = \u0026#39;09031\u0026#39; 5. データのグループ化 集計関数は1つの結果しか出力しないため、列をクエリして集計関数をまとめるとエラーが報告されます。\n特定のカテゴリの集計関数の結果は、データをグループ化することで計算できます。つまり、集計関数の範囲は各グループ内のすべてのレコードになります。\n集計関数をフィルター条件として使用する場合は、それを HAVING 句の後に置く必要があります。\n1 2 3 4 5 6 -- 最低スコアが 70 を超え、最高スコアが 90 未満の学生の学生 ID を照会します。 select 学号 from score where 分数 is not null group by 学号 having min(分数) \u0026gt; 70 and max(分数) \u0026lt; 90 クエリ内に WHERE 句、GROUP BY 句、HAVING 句、および集計関数が同時に出現する場合、SELECT コマンドの実行順序は次のようになります。\nWHERE句を実行してテーブルから行を選択します 選択した行を「GROUP BY」でグループ化する 集計関数を実行する HAVING句を実行して条件を満たすグループを選択します。 1 2 3 4 -- 各コースの平均スコアを照会する select 课程号, avg(分数) from score group by 课程号 集計関数は条件として HAVING 句の後にのみ配置でき、 WHERE 句の後には配置できません。\nSELECT句が列名と集計関数で構成されている場合、すべての列名をグループ化する必要があります。\n6. テーブル接続クエリ FROM 句では結合するテーブルを指定し、WHERE 句では結合条件を指定します。\n1 2 3 select \u0026lt;列名1\u0026gt;[, ···] from \u0026lt;表1\u0026gt;[, ···] where 接続条件 2つのテーブルの共通列には、student.学号などのプレフィックスを指定する必要があります。\nSQL Server では、接続は内部接続と外部接続に分けられます。\n\u0026lt;1\u0026gt; 内部結合 Θ 結合、等価結合、自然結合\n内部結合は最も基本的な結合方法です。INNER JOIN キーワードを使用します。このキーワードを使用しない場合、デフォルトは内部結合になります。\n等接続 つまり、2つのテーブル間の接続関係は「等しい」です。\n1 2 3 4 5 6 7 8 9 -- すべての学生の名前、コース番号、スコアの列を照会する select student.姓名, score.课程号, score.分数 from student, score where student.学号 = score.学号 -- したがって select student.姓名, score.课程号, score.分数 from student inner join score on student.学号 = score.学号 入力を簡略化するために、テーブルエイリアスを使用することができます。\n1 2 3 4 -- 前の例の簡略化 select x.姓名, y.课程号, y.分数 from student x, score y where x.学号 = y.学号 非等価結合 つまり、2つのテーブル間の接続関係は「等しい」ではない。\n自己接続 同じテーブルを結合することを自己結合と呼びます。\n1 2 3 4 5 6 -- \u0026#39;3-105\u0026#39; を受験し、そのスコアが生徒 \u0026#39;109\u0026#39; のスコアより高い生徒の記録を照会します。 select x.课程号, x.学号, x.分数 from score x, score y where x.课程号 = \u0026#39;3-105\u0026#39; and x.分数 \u0026gt; y.分数 and y.学号 = \u0026#39;109\u0026#39; and y.课程号 = \u0026#39;3-105\u0026#39; order by x.分数 desc \u0026lt;2\u0026gt; 外部結合 OUTER JOIN 左外部結合: LEFT OUTER JOIN または LEFT JOIN\n右外部結合: RIGHT OUTER JOIN または RIGHT JOIN\n完全外部結合: FULL OUTER JOIN または FULL JOIN\n1 2 3 4 5 -- 左外部結合の例 -- すべてのコースの教師の名前を照会する select course.课程名, teacher.姓名 from course left join teacher on (course.任课教师编号 = teacher.教师编号) 7. サブクエリ \u0026lt;1\u0026gt; 一般的なサブクエリ あるクエリが別のクエリの条件である場合、つまり、テーブルから行を選択する条件がテーブル自体または他のテーブルの結合情報に依存する場合、サブクエリを実装する必要があります。\nサブクエリは、SELECT ステートメントの WHERE 句で最もよく使用されます。\n1 2 3 4 5 6 7 8 -- 学生番号「105」の学生と同じ年に生まれた学生を検索します select 学号, 姓名, year(出生日期) as \u0026#39;出生年份\u0026#39; from student where year(出生日期) = ( select year(出生日期) from student where 学号 = \u0026#39;105\u0026#39; ) \u0026lt;2\u0026gt; 相関サブクエリ 通常のサブクエリでは、各サブクエリは 1 回だけ実行され、返された値はメインクエリの WHERE 句で使用されます。\nメイン クエリが各行を選択するかどうかを判断するときは、サブクエリを「起動」し、メイン クエリにフィードバックする必要があります。つまり、内部条件に外部属性が含まれるサブクエリは相関サブクエリと呼ばれます。\n1 2 3 4 5 6 7 8 9 -- コースの平均スコアよりも低いスコアを持つ学生を照会する select 学号, 课程号, 分数 from score a where 分数 \u0026lt; ( select avg(分数) from score b where a.课程号 = b.课程号 and 分数 is not null ) \u0026lt;3\u0026gt; EXISTS テストを含むサブクエリ EXISTS は存在量指定子 ∃ を表し、論理真または論理偽の値のみを返します。\n1 2 3 4 5 6 7 8 -- すべての教師の名前と部門を照会する select 姓名, 系别 from teacher a where exists ( select * from course b where a.教师编号 = b.任课教师编号 ) あるいは、結果を否定する「NOT EXISTS」がある。\n8. クエリ結果の結合、交差、差の演算 次の演算子を使用して、2 つの SELECT クエリの結果に対して操作を実行できます。\nUNION : および 交差: 例外: 差異 1 2 3 4 5 6 7 8 -- ANDの例 -- すべての教師と生徒の名前、性別、生年月日を照会する select 姓名, 性别, year(出生日期) as \u0026#39;出生年份\u0026#39; from teacher union select 姓名, 性别, year(出生日期) as \u0026#39;出生年份\u0026#39; from student -- order by 生年 (四)、DCL データ制御言語 データ制御は、ユーザーのデータ保存権限を制御し、DBA（データベース管理者）によって決定されます。\nデータベースセキュリティ 不安要素:\nデータベースへの不正アクセスと破壊 データベースから重要なデータが漏洩 安全保障環境の脆弱性 セキュリティコントロール:\nユーザーID認証: 静的パスワード認証、動的パスワード認証、生体認証、スマートカード認証 アクセス制御 自律的なアクセス制御方式（ユーザーが操作権限をカスタマイズし、他のユーザーに割り当てることができる） 自律アクセス制御 DBMS（データベース管理システム）データ制御には以下の機能が必要です\nGRANTとREVOKEを通じてシステムに権限を通知し、データ辞書に保存する ユーザーがリクエストを行った場合、認可ステータスに基づいて操作リクエストを実行するかどうかを確認します。 SQL 標準には、DELETE、INSERT、SELECT、および UPDATE 権限が含まれます。 SELETE 権限は READ 権限に対応します。SQL には REFERENCES 権限も含まれており、これはリレーションを作成するときにユーザーが外部キーを定義する機能を制限するために使用されます。\n1. 認可ステートメントの形式 1 2 3 4 grant \u0026lt;権限\u0026gt;[, ···] on \u0026lt;オブジェクトタイプ\u0026gt; \u0026lt;オブジェクト名\u0026gt;[, ···] to \u0026lt;ユーザー\u0026gt;[, ···] [with grant option] 操作オブジェクトの種類によって権限は異なります。一般的な権限は次のとおりです。\nオブジェクト オブジェクトタイプ 操作権限 属性列 TABLE SELECT、INSERT、UPDATE、DELETE、\nALL PRIVILEGES (4つの権限の合計) ビュー TABLE SELECT、INSERT、UPDATE、DELETE、\nALL PRIVILEGES (4つの権限の合計) 基本テーブル TABLE SELECT、INSERT、UPDATE、DELETE、ALTER、INDEX\nALL PRIVILEGES (6つの権限の合計) データベース DATABASE CREATETAB テーブルを作成する権限。DBA が一般ユーザーに付与できます。 PUBLIC: 権限を受け取るユーザーは、単一のユーザーまたは複数の特定のユーザーです。PUBLIC パラメータは、すべてのユーザーに権限を付与できます。 GRANT OPTION付き: この句が指定されている場合、権限を取得したユーザーは他のユーザーに権限を付与することもできます。 2. 権限取り消しステートメントの形式 1 2 3 revoke \u0026lt;権限\u0026gt;[, ···] on \u0026lt;オブジェクトタイプ\u0026gt; \u0026lt;オブジェクト名\u0026gt;[, ···] from \u0026lt;ユーザー\u0026gt;[, ···] データベースの役割 役割とは、CEO、取締役、一般従業員など、人物のタイプを指します。人物のタイプを承認できます。\nキャラクター作成 1 create role \u0026lt;キャラクター名\u0026gt; ロールの承認 1 grant \u0026lt;権限\u0026gt; on \u0026lt;オブジェクトタイプ\u0026gt; \u0026lt;オブジェクト名\u0026gt; to \u0026lt;役割1\u0026gt;[, ···] 他のユーザーまたはロールにロールを付与する 1 2 grant \u0026lt;役割\u0026gt; to \u0026lt;役割\u0026gt;または\u0026lt;ユーザー名\u0026gt; [with admin option] with admin option は、このユーザーが他のロールまたはユーザーにこの権限を付与できることを意味します。\nロール権限の取り消し 1 revoke \u0026lt;権限\u0026gt; on \u0026lt;オブジェクト名\u0026gt; from \u0026lt;キャラクター名\u0026gt; ビューのメカニズム ビューは、1 つ以上の基本テーブルまたはビューから派生したテーブルです。これは仮想テーブルです。\nユーザーごとに異なるビューを定義し、ユーザーが間違いを起こさないように不要なデータを非表示にします。\nビューの作成 1 2 3 create view \u0026lt;ビュー名(リスト名)\u0026gt; as select \u0026lt;クエリ句\u0026gt; [with check option] サブクエリのSELECT文には通常、ORDER BY句とDISTINCT文を含めることはできません。 WITH CHECK OPTION は、UPDATE、INSERT、および DELETE 操作の場合、操作対象の行がビュー定義の述語条件 (つまり、サブクエリの条件式) を満たす必要があることを意味します。 ビューを構成する属性列名がすべて省略されているか、すべて指定されています。省略した場合、ビューは SELECT サブクエリのターゲット列のプライマリ属性で構成されていることが暗黙的に示されます。 1 2 3 4 5 6 7 8 -- 関係モデル：student(sno, sname, sex, SD, email) -- 「コンピュータサイエンス（CS）」の学生向けのビューを作成し、変更操作を実行する場合 -- ビュー内のコンピュータサイエンスの学生のみが影響を受けるようにする create view cs-student as select sno, sname, sex from student where SD = \u0026#39;CS\u0026#39; with check option ビューの削除 1 2 3 4 drop view \u0026lt;ビュー名\u0026gt; --例えば drop view cs-student 監査 データベースに対するすべての操作は監査ログに記録され、そのログを使用して不正な動作があるかどうかを確認できます。\n1 2 3 4 -- 「SC」データを変更する監査操作 AUDIT UPDATE ON SC; -- 「SC」テーブルのすべての監査をキャンセルします NOAUDIT UPDATE ON SC; データ暗号化 いくつかの暗号化アルゴリズムにより、プレーンテキストは暗号テキストに変換され、他の人が閲覧できなくなります。\n＃＃ 索引\nインデックスを使用すると、データベース プログラムはテーブル全体をスキャンしなくても、テーブル内の必要なデータを見つけることができます。\nデータベースのインデックスは、テーブルの 1 つ以上の列の値のコレクションと、これらの値を物理的に識別するテーブル内のデータ ページへの論理ポインターの対応するリストです。\n内部スキーマによって定義されます（内部スキーマはすべての内部レコードタイプ、インデックス、およびファイル構成を定義します）\nインデックスを作成する 1 2 create [unique] [cluster] index \u0026lt;インデックス名\u0026gt; on \u0026lt;テーブル名\u0026gt;(列名[順序], ···) 順序：オプションASC（デフォルト）または DSC\nUNIQUE ：このインデックスの各インデックス値が 1 つのデータ レコードのみに対応することを示します。\nCLUSTER ：作成されるインデックスがクラスター化インデックスであることを示します。つまり、インデックス項目の順序は、テーブル内のレコードの物理的な順序と一致します。\nインデックスの削除 1 drop index \u0026lt;インデックス\u0026gt; ","date":"2023-02-08T08:00:00+08:00","permalink":"https://blog.yexca.net/ja/archives/88/","title":"データベースの学習 3 SQL言語"},{"content":" 📢 この記事は Google 翻訳を使用して処理されました SQL シリーズ\nデータベース学習1 データベース導入: https://blog.yexca.net/ja/archives/86 データベース学習2 関係モデル: この記事\nデータベース学習3 SQL言語: https://blog.yexca.net/ja/archives/88 データベース学習4 関係データベース理論: https://blog.yexca.net/ja/archives/89 データベース学習5 正規形: https://blog.yexca.net/ja/archives/90 データベース学習6 データベース設計: https://blog.yexca.net/ja/archives/91 データベース学習7 データベースの制御機能: https://blog.yexca.net/ja/archives/92 リレーショナルモデルの基本用語 リレーショナル データベース システムは、リレーショナル モデルをサポートするデータベース システムです。リレーショナル モデルに関連する基本的な用語は次のとおりです。\nリレーションシップ: リレーションシップは2次元テーブルであり、各リレーションシップにはリレーションシップ名があります。 タプル: テーブル内の行はタプルであり、ストレージファイル内のレコード値に対応します。 属性: テーブル内の列は属性と呼ばれます。各列には属性名があり、属性値はレコード内のデータ項目またはフィールド値に相当します。 ドメイン: 属性の値の範囲、つまり異なるタプル内の同じ属性の値の範囲 リレーションシップモデル: リレーションシップの説明はリレーションシップモデルと呼ばれ、リレーションシップ名とその属性セットで構成されます。リレーションシップモデルの形式は次のとおりです: リレーションシップ名(属性名 1，···，属性名 n) 通常、リレーショナルモデルはリレーショナルファイルの結果に対応する。\n候補キー: タプルを一意に識別する値を持つ属性または属性の組み合わせ 主キー: 関係には複数の候補キーが存在する場合があり、そのうちの1つが主キーとして選択されます。 主属性: 候補コード に含まれる属性は主属性と呼ばれ、候補コード に含まれない属性は非主属性と呼ばれます。 外部キー: リレーション内の属性または属性グループがリレーションのキーではないが、別のリレーションのキーである場合、その属性または属性グループをリレーションの外部キーと呼びます。 フルコード: リレーショナルスキーマのすべての属性グループは、このリレーショナルスキーマの候補コードであり、フルコードと呼ばれます。 スーパーコード（スーパーキー）：コードを含む属性のセットはスーパーコードと呼ばれます 関係モデルの定義 関係の記述はリレーショナルモデルと呼ばれ、正式には次のように表現されます: R(U, D, dom, F)\nここで、Rは関係名、Uは関係を構成する属性名のセット、Dは属性グループUの属性の由来となるドメイン、domは属性からドメインへのマッピングのセット、Fは属性データ間の依存関係のセット。\nこれは通常、R(U)またはR($A_1$, $A_2$, ···)と略記されます。ここで、Rは関係名、Uは属性名セット、$A_1$、···は個々の属性です。名前。\nリレーショナル モデルは、リレーショナル データ構造、リレーショナル操作セット、リレーショナル整合性制約の 3 つの部分で構成されます。\nリレーショナルデータ構造 リレーショナルモデルにおけるデータの論理的な関係は2次元のテーブルである\n関係演算セット リレーショナルモデルは関係を操作する機能を提供する\n一般的なリレーショナル操作には、選択、投影、接続、除算、結合、積、差などのクエリ操作、および追加操作と削除操作が含まれます。\nリレーショナル整合性制約 リレーショナル モデルの 3 つの整合性ルールは次のとおりです。\nエンティティの整合性: リレーションシップの主キーの値は空または部分的に空にすることはできません。つまり、主キーの属性、つまり主属性は空の値を取ることはできません。 参照整合性: リレーション $R_2$ の外部キーXがリレーション $R_1$ の主キーに対応する場合(基本リレーション $R_1$ と $R_2$ は必ずしも異なるリレーションではなく、同じリレーションである可能性があります)、次に、外部キー X の各値は、リレーション $R_1$ の主キーの値内に見つかる必要があります。見つからない場合は null になります。 ユーザー定義の整合性: 特定のデータに対してユーザーが指定した制約の検証を指します。 関係代数演算子 オペレーター シンボル 意味 集合演算子 ∪\n–\n∩\n× 連合\n違い\n交差点\nデカルト積 特殊な関係演算子 σ\nπ\n⋈\n÷ 選ぶ\n投影\n接続\n分割 比較演算子 ＞\n≥\n＜\n≤\n＝\n≠ より大きい\nより大きいか等しい\n未満\n以下\n等しい\n等しくない 論理演算子 ¬\n∧\n∨ 否\n及び\nまたは 従来の集合計算 専門的な関係オペレーター 接続 θ 接続、等接続と自然接続\nθ 接続：接続条件が等しくない 等価接続：接続条件は等価です 自然接続: 重複するプロパティの等価接続を削除します。最もよく使用される接続計算。 プロジェクター 投影計算は関係の垂直方向から計算を実行し、関係 R で新しい関係を構成するいくつかの属性列 A を抽出し、$π_A(R)$ を計算します。\n选择 選択計算は関係の水平方向からの計算であり、関係 R の中から所定の条件を満たす要素を選択し、$σ_F(R)$ として計算します。\n外部接続 外部接続計算は接続計算の拡張であり、接続計算によってメッセージが失われる可能性があります。\n左外部接続: 左側関係関係のすべてと右側関係関係のいずれかの要素グループが一致しない要素グループを取り出し、右側関係関係からのすべての属性を空の null で埋めます。 外部接続: 右側関係系のすべてと左側関係系のいずれかの元組が一致しない元組を取り出し、左側関係系からのすべての属性を空の null で埋めます。 ※全外部接続：左外部接続と右外部接続の操作を完了します。 除法 シンボルからSQL言語へ 関係 R：\nA B C 1 2 3 4 5 6 7 8 9 SQL言語への投影 $π_?(?)$\n1 select ? from ? $π_{A, B, C}(R)$ 或者 $π_{1, 2, 3}(R)$\n1 select A, B, C from R 注：SQL 语言不サポート列 (プロパティ) の順序番号\n選択からSQLへ $π_?(σ_?(?))$\n1 select ? from ? where ? $π_{A, B, C}(σ_{B \u003e= '5'}(R))$ 或者 $π_{1, 2, 3}(σ_{2 \u003e= '5'}(R))$\n1 2 3 select A, B, C from R where B \u0026gt;= \u0026#39;5\u0026#39; # または select A, B, C from R where B \u0026gt;= 5 デカルト積からSQLへ $π_{R.A, R.B, R.C, S.A, S.B, S.D}(R×S)$\n1 2 3 4 select R.A, R.B, R.C, S.A, S.B, S.D from R, S # 昇順で並べ替え order by R.A asc SQL言語への自然接続 関係 R(A, B, C) および S(B, C, D)\n$π_{R.A, R.B, R.C, S.D}(σ_{R.B = S.B ∩ R.C = S.C}(R×S))$\n1 2 3 select R.A, R.B, R.C, S.D from R, S where R.B = S.B and R.C = S.C ","date":"2023-02-07T06:00:00+08:00","permalink":"https://blog.yexca.net/ja/archives/87/","title":"データベース学習 2 リレーショナル モデル"},{"content":" 📢 この記事は Google 翻訳を使用して処理されました SQL シリーズ\nデータベース学習1 データベース導入: この記事\nデータベース学習2 関係モデル: https://blog.yexca.net/ja/archives/87 データベース学習3 SQL言語: https://blog.yexca.net/ja/archives/88 データベース学習4 関係データベース理論: https://blog.yexca.net/ja/archives/89 データベース学習5 正規形: https://blog.yexca.net/ja/archives/90 データベース学習6 データベース設計: https://blog.yexca.net/ja/archives/91 データベース学習7 データベースの制御機能: https://blog.yexca.net/ja/archives/92 導入 以前のデータベースはうまく書かれていなかったので、見直して書き直しました（ただし、これもかなり乱雑です）\nデータベース4つの基本概念 データ 物事を記述する象徴的な記録\nデータベース 一般に、データベース データには、永続的な保存、整理、共有という 3 つの基本的な特性があります。\n厳密に言えば、データベースとは、長期間コンピューターに保存され、整理され、共有可能な大量のデータの集合です。データベース内のデータは、特定のデータ モデルに従って整理、記述、保存され、冗長性が低く、データの独立性が高く、スケーラビリティが容易で、さまざまなユーザーが共有できます。\nデータベース管理システム これは、ユーザーとオペレーティング システムの間に位置するデータ管理ソフトウェアのレイヤーです。オペレーティングシステムと同様に、コンピュータの基本ソフトウェアです。\n主な機能:\nデータ定義機能\nデータの整理、保存、管理\nデータ操作機能\nデータベースのトランザクション管理と運用管理\nデータベースの構築と保守機能\nその他の機能（通信機能、データ変換機能、相互アクセス・相互運用機能等）\nデータベースシステム これは、データベース、データベース管理システム (およびそのアプリケーション開発ツール)、アプリケーション、およびデータベース管理者 (DBA) で構成され、データを保存、管理、処理、および維持するシステムです。\nコンピューターデータ管理の開発 手動管理段階（1950年代半ば以前） データは保存、共有、独立していない\nファイル システム フェーズ (1950 年代後半から 1960 年代中期から後半) 保存はできるが、共有が不十分、冗長性が高く、独立性が低い\nデータベース システムの段階 (1960 年代後半から) データベースシステムの登場により、情報システムはデータ処理プログラム中心から共有データベース中心へと移行し、データ全体の構造化が実現しました。\nデータは高度に共有され、冗長性が低く、拡張が容易です。データの冗長性を大幅に削減し、ストレージスペースを節約し、データの独立性を高めることができます。\nデータモデル分類 モデル適用の目的の違いにより、モデルは2つのカテゴリまたは2つのレベルに分けられます。情報世界から抽象化されたデータモデルは概念データモデルと呼ばれ、DBMS（データベース管理システム）によってサポートされるデータモデルは情報世界から抽象化されます。コンピュータの世界では、構造データモデル（またはデータモデル）と呼ばれています。\nコンセプトデータモデル（概念モデル） 概念データモデルは、コンピュータシステムから独立したモデルです。システム内の情報の表現にはまったく関係しません。特定の組織が関心を持つ情報構造を記述するためにのみ使用されます。つまり、データをモデル化します。情報世界モデリングは、一般的にエンティティ・リレーションシップ法（E-R法）を用いて表現されます。主にデータベース設計に使用\n概念データ モデルでよく使用される用語は次のとおりです。\nエンティティ: 客観的に存在し、互いに区別できるものをエンティティと呼びます\n属性: エンティティを記述する特性を属性と呼びます。\nコード: エンティティを一意に識別する属性のセットはコードと呼ばれます。\nエンティティタイプ: エンティティ名と属性セットを使用して、類似のエンティティを抽象化し、特徴付けます。\nエンティティセット: 同じタイプのエンティティのコレクション\nドメイン: 属性の値の範囲は、属性のドメインと呼ばれます。\n関係: エンティティ間の対応する関係を関係と呼びます\n2つのエンティティ間の関係には3つの種類がある\n1対1のコンタクト 1対多の連絡 多対多の接続 実体関連法によって表現される概念データ モデルは、E-R 図と呼ばれます。エンティティは四角形で表され、属性は楕円形で表され、無向エッジはそれらを関連するエンティティに接続するために使用されます。\n構造データモデル（ロジックモデル） 構造データ モデルは、データベースの論理構造に直接関係します。すべての DBMS は構造データ モデルに基づいています。主にデータベース管理システムの実装に使用されます\n構造データモデルには主に、階層型、ネットワーク型、リレーショナル型、オブジェクト指向型などがある。\n階層モデル 階層モデルは、データ間の関係を表すために「ツリー構造」を使用します。そのデータ構造は「有向ツリー」です。\nメッシュモデル ネットワークモデルは「グラフ構造」を使用してデータ間の関係を表します。\nリレーショナルモデル リレーショナル モデルは、2 次元のテーブル構造を使用してエンティティとエンティティ間の関係を表すデータ モデルです。各 2 次元テーブルは行と列で構成され、これらは関係とも呼ばれます。リレーショナル モデルは、関係を記述したものです。したがって、リレーショナル モデルはリレーショナル パターンの集合であると言えます。\n物理モデル これはデータの抽象化の最低レベルです。システム内のデータの表現とアクセス方法、またはディスクやテープ上のデータの保存とアクセス方法を記述します。これはコンピュータシステム指向です。\nデータベースシステム構造 ストレージ構造が異なるデータベース製品は数多くあるが、アーキテクチャはすべて「3レベルモデルと2レベルイメージ」を採用しており、同じ特徴を持っている。\n3番目のレベルモード 概念モデル（基本表） スキーマまたは論理スキーマとも呼ばれ、データベース内のすべてのデータの論理構造と特性を記述したもので、すべてのユーザーに共通のデータ ビューです。\n外部モード（表示） ユーザー モードまたはサブモードとも呼ばれ、ユーザーとデータベース システム間のインターフェイスであり、ユーザーが使用するデータの説明です。\n内部モード（保存ファイル） ストレージ モードとも呼ばれ、データベースには 1 つの内部モードのみがあります。これは、データの物理的な構造と保存方法を記述したもので、データベース内でデータが整理される方法です。\n2 レベルの画像 データベース システムは、3 つのレベルのモデル間に、モデル/内部モデル マッピングと外部モデル/モデル マッピングという 2 つのレベルのマッピングを提供します。\nこれら 2 つのレベルのイメージがあるからこそ、データベース内のデータは高度な論理的独立性と物理的独立性を持つことになります。\nモード/内部モードイメージ（ストレージ） 概念レベルと内部レベルの間に存在し、概念モデルと内部モデルの相互変換を実現する\nデータベースのストレージ構造が変更された場合、データベース管理者はスキーマ/内部スキーマに対応する変更を加えてスキーマを変更しないようにできるため、アプリケーションを変更する必要がありません。データとプログラムの物理的な独立性を保証します\n外観モデル/モデルイメージ（表示） 外部レベルと概念レベルの間に存在し、外部モデルと概念モデルの相互変換を実現する\nスキーマが変更された場合、データベース管理者は各外部スキーマ/スキーマ イメージに対応する変更を加え、外部スキーマを変更せずに維持することができます。アプリケーションを変更する必要はありません。データとプログラムの論理的独立性を保証します\nデータの独立性とは、データがプログラムから独立しており、データの定義がプログラムから分離されていることを意味します。 DBMSの二次イメージング機能によりデータの独立性が確保されます。データの独立性には、データの物理的な独立性と論理的な独立性が含まれます。\nデータの物理的な独立性: ユーザーのアプリケーションとデータベース内のデータの物理的な保存は互いに独立しています。\nデータの論理的独立性: ユーザーのアプリケーションとデータベース内の論理構造は互いに独立しています。\nデータとプログラムが独立しているため、データの定義と記述をアプリケーション プログラムから分離できます。さらに、データアクセスはデータベース管理システムによって管理されるため、アプリケーションプログラムのコンパイルが簡素化され、アプリケーションプログラムの保守や修正にかかる手間が大幅に軽減されます。\nデータベースシステム構成 ハードウェアプラットフォームとデータベース 十分な大きさのメモリ、ディスクまたはディスクアレイ、その他のデバイス、データ転送速度を向上させるための高いチャネル容量\nソフトウェア データベース管理システム、データベース管理システムの動作をサポートするオペレーティングシステム、データベースインターフェースを備えた高級言語とそのコンパイルシステム、データベース管理システムを中核とするアプリケーション開発ツール、特定のアプリケーション環境向けに開発されたデータベースアプリケーションシステム\n人事 データベースを開発、管理、使用する人には、主にデータベース管理者、システムアナリスト、データベース設計者、アプリケーションプログラマー、エンドユーザーが含まれます。\nデータベース管理者の責任: データベースの情報内容と構造を決定し、データベースのストレージ構造とアクセス戦略を決定し、データのセキュリティ要件と整合性制約を定義し、データベースの使用と操作を監視し、データベースを改善および再編成します。 、データベースを再構築します。\n","date":"2023-02-06T19:57:35+08:00","permalink":"https://blog.yexca.net/ja/archives/86/","title":"データベース学習 1 データベース入門"},{"content":" 📢 この記事は gemini-2.5-flash によって翻訳されました 第12章 ディスクとファイルシステムの管理 12.1 ディスクストレージについて知ろう ほとんどのモダンなOSで、データストレージの基本的な仕組みは同じだよ。ディスクは永続的なストレージとして使われて、RAM（Random Access Memory、ランダムアクセスメモリ）とスワップ領域は一時的なストレージとして使われるんだ。例えば、コマンドを実行するとき、そのコマンドはハードディスクからRAMにコピーされるんだ。そうすると、コンピューターのプロセッサ（CPU）がもっと速くコマンドにアクセスできるようになるからね。\nハードディスクからデータにアクセスするより、CPUはRAMからの方がずっと速くアクセスできるんだ。でも、RAMは値段が高いし、電源が切れるとデータが消えちゃうから、ディスクの容量はRAMよりはるかに大きいんだよ。\nたくさんのプロセスを動かしたり、メモリリークのあるプロセスを動かしてRAMがいっぱいになっちゃったとき、システムにメモリを拡張する方法がないと、新しいプロセスが起動できなくなることがあるんだ。そこでスワップ領域が登場するってわけ。いくつかのアルゴリズムを使って、一部のデータをRAMからディスクに移動させて、必要になったらまたRAMに戻すんだよ。\n異なる種類のOS間でファイルをやり取りする必要があるときは、通常VFATファイルシステムが使われることが多いよ。\n12.2 ハードディスクをパーティション分割しよう パーティションの変更はシステムが起動しなくなる原因になることもあるから、まずは空のハードディスクでしっかり慣れてから、実際に使うことをおすすめするよ。\n12.2.1 パーティションテーブルを理解しよう 昔から、PCアーキテクチャのコンピューターは、MBR（Master Boot Record）パーティションテーブルを使ってハードディスクのパーティションサイズと配置情報を保存してきたんだ。だけど、最近ではGUID（Global Unique Identifier）パーティションテーブルっていう新しい規格が、一部のUEFIコンピューターアーキテクチャのコンピューターで使われるようになって、古いBIOSシステム起動方法に取って代わってるんだ。\nMBRの仕様が持つ限界が、GUIDパーティションを必要とさせたんだよね。MBRパーティションのサイズは2TBまでに制限されているけど、GUIDパーティションだと最大9.4ZBのパーティションが作れるんだよ。\nfdiskコマンドはGPTパーティションに対応してないから、partedコマンドを使うことができるよ。\n12.2.2 ディスクパーティションを確認しよう fdisk -l /dev/sda または parted -l /dev/sdb\nsd?デバイス（sda、sdbなど）で表されるSCSIやUSBストレージデバイスは、最大16個のマイナーデバイス（例えばメインの/dev/sdcデバイスと/dev/sdc1から/dev/sdc15まで）を持つことができるんだ。だから全部で15個のパーティションがあるってことになるね。\nnvmeデバイス（nvme0、nvme1など）で表されるNVMe SSDストレージデバイスは、1つ以上のネームスペース（ほとんどのデバイスは最初のものだけを使うけどね）とパーティションに分割できるんだ。例えば/dev/nvme0n1p1は、最初のnvmeデバイス上の最初のネームスペースの最初のパーティションを表してるよ。\nx86コンピューターの場合、ディスクには最大4つのプライマリパーティションを持つことができるんだ。だから、4つ以上のパーティションが欲しいなら、少なくとも1つは拡張パーティションにしておく必要があるよ。4つのプライマリパーティション以外のパーティションはすべて論理パーティションで、拡張パーティションの領域を使っているんだ。\n12.2.3 シングルパーティションのハードディスクを作成しよう 一般的に、ストレージメディアを追加する手順はこうだよ：\n新しいハードディスクを取り付けるか、新しいUSBフラッシュドライブを挿し込む。\n新しいハードディスクをパーティション分割する。\n新しいハードディスク上にファイルシステムを作成する。\nファイルシステムをマウントする。\nもしpartedコマンドを使って変更する場合は、一歩一歩慎重に進めてね。なぜかっていうと、partedコマンドの変更はすぐに反映されちゃうからだよ。 一方でfdiskコマンドは取り消し可能で、変更を確定するときに初めて実際に反映されるんだ。\nデータは宝物、慎重に操作してね。\n新しく追加したデバイスの名前を確認する。\n方法はたくさんあるけど、例えばシステムログを見る方法があるよ。\njournalctl -f\n例えば、割り当てられた名前が/dev/sdbだったとするね。\nもしデバイスが自動でマウントされちゃってたら、まずアンマウントする必要があるよ。\n/dev/sdbがマウントされているか確認するには：mount | grep sdb\nパーティションをアンマウントするには：umount /dev/sdb1\npartedコマンドを使ってパーティションを作成する。\nparted /dev/sdb\n実行するとpartedコマンドモードになるから、partedのシングルレターコマンドでパーティションを設定できるよ。\nパーティションを削除する。\n単一コマンドpで、全てのパーティションをリスト表示する。\nrmコマンドを使って、Enterを押してから該当するNumberを入力すれば、そのパーティションを削除できるよ。\nGPTパーティションテーブルを作成する。\nmklabel gptコマンドを使うんだ。\n新しいパーティションを作成する。\nmkpartコマンドを入力すると、パーティション名、ファイルシステムの種類、そしてパーティションの開始と終了を入力するよう促されるよ。\n例えば、yexca-UDisk と名付けて、ファイルタイプを xfs に、パーティションを1MBから123GBまでと設定するなら、こうだよ：\n1 2 3 4 5 (parted) mkpart Partition name? []? yexca-UDisk File system type? [ext2]? xfs Start? 1 End? 123GB パーティションが正しく作成されたか確認する。\n単一コマンドpで、全てのパーティションをリスト表示する。\nパーティションの作成が終わったら、そのパーティション上にファイルシステムを作成する必要があるよ。\n例えばXFSファイルシステムを作成するには：mkfs -t xfs /dev/sdb1\n-tオプションがない場合、デフォルトでext2ファイルシステムが作成されるんだ。\nファイルシステムをマウントする。\n1 2 3 4 # マウント用のフォルダを作る mkdir /mnt/tmp # /dev/sdb1を/mnt/tmpにマウントする mount /dev/sdb1 /mnt/tmp ファイルシステムをアンマウントする。\numount /dev/sdb1コマンドを使うよ。\nデフォルトでは、USBデバイスを挿すとたいてい自動でマウントされることが多いよ。\nもし手動でマウントしたいなら、/etc/fstabに一行追加すればいいんだ。\n1 /dev/sdb1 /mnt/tmp xfs defaults 0 1 全部で6つのセクションがあるよ。\nパーティション\nマウントするフォルダ\nファイルシステム\nパーティション起動時のマウントオプション\ndumpコマンドでパーティションファイルをバックアップするかどうか（0はバックアップしない）\n特定のマウント回数の後にパーティションのエラーチェックを行うかどうか\n12.2.4 マルチパーティションディスクを作成しよう fdiskコマンドを使った説明だよ。\nfdiskコマンドモードに入る。\nfdisk /dev/sdb\nパーティションを作成する。\n単一コマンドnを入力して、次にプライマリパーティションのpか拡張パーティションのeを選んで、パーティションの位置を選ぶんだ（デフォルトで大丈夫だよ）。\nそれから割り当てるスペースなんだけど、開始スペースはデフォルトでいいとして、Enterを押した後、終了スペースを入力するんだ。例えば5GBのスペースを割り当てるなら+5Gと入力するよ。もし直接数字を入れると、セクタとして認識されちゃうから気をつけてね。\n4番目のパーティション、つまり拡張パーティションは、スペースの割り当てを2回ともデフォルトで大丈夫だよ。\nパーティションを確認する。\n単一コマンドp。\nデフォルトのパーティションタイプはLinuxなんだけど、もしパーティションタイプを変更したいなら。\ntコマンドを使って、パーティション番号を選んでからLを入力してパーティションタイプのリストを見るんだ。目的の16進コードを見つけたら、それを入力して変更するよ。\n変更を確認して保存する。\n単一コマンドpで確認して、単一コマンドwで変更を保存するよ。\n変更が終わったら、カーネルがパーティションテーブルの変更を認識しているか確認するんだ。\n1 2 3 4 5 grep sdb /proc/partitions # もし期待通りの結果が出なかったら、以下のコマンドを実行してね。 partprobe /dev/sdb # もう一度確認する grep sdb /proc/partitions ファイルシステムを作成する。\n1 2 3 4 5 6 7 8 9 10 # ext4ファイルシステムを作成する mkfs -t ext4 /dev/sdb1 # スワップ領域を作成する mkswap /dev/sdb2 # ext2ファイルシステムを作成する（デフォルトだよ） mkfs /dev/sdb3 # VFATファイルシステムを作成する mkfs -t vfat /dev/sdb4 # このパーティションをLVM物理ボリュームにする pvcreate /dev/sdb5 12.3 論理ボリューム管理でパーティションを管理しよう もしディスクの容量が足りなくなったら、データを別のより大きなディスクにコピーするしかないだろうね。でも、そのプロセスはシステムを停止する必要があるし、効率も悪いんだ。\nLVM（Logical Volume Management、論理ボリューム管理）を使うと、ストレージの変更に柔軟かつ効率的に対応できるんだ。LVMを使えば、物理ディスクパーティションを「ボリュームグループ」と呼ばれる領域のプールに追加できるんだよ。論理ボリュームは、必要に応じてボリュームグループから領域を割り当てるんだ。\n12.3.1 既存のLVMを確認しよう fdisk -l /dev/sdaコマンドを使って、Linux LVMパーティションがあるか確認するんだ。例えば/dev/sda2がLVMパーティションだと仮定するね。\nそのLVMパーティションがLVMグループで使われているか確認する。\npvdisplay /dev/sda2\nボリュームグループ（VG Name）がvg_abcだと仮定して、そのボリュームグループの情報を確認するよ。\nvgdisplay vg_abc\n物理ボリュームが使う最小のストレージ単位はPE（Physical Extent）サイズってわかるよ。\nボリュームグループのPEがどこに割り当てられているか確認する。\nlvdisplay vg_abc\n出力には複数の論理ボリューム名が表示されるんだけど、これらの論理ボリュームは物理ボリュームと同じように名前を使って直接マウントできるんだよ。\n12.3.2 LVM論理ボリュームを作成しよう LVM論理ボリュームの利用はトップダウンだけど、作成プロセスはボトムアップなんだ。まず1つ以上の物理ボリューム（PV）を作成して、次にその物理ボリュームを使ってボリュームグループ（VG）を作成し、最後にボリュームグループから論理ボリューム（LV）を作成するんだ。\nLVMパーティションを持つストレージデバイスを準備する。\n作成プロセスについては12.2.4で触れたよね。\nその物理ボリュームをボリュームグループに追加する。\nvgcreate myvg0 /dev/sdb5\nボリュームグループを確認する。\nvgdisplay myvg0\nパーティションが400Mだったら、396Mのスペース（4M単位で）を使うことができるよ。\n1 2 3 4 5 6 # ボリュームグループの一部領域から論理ボリュームを作成する。例えば1Gの論理ボリュームを作成するなら。 lvcreate -n name -L 1G myvg0 # その論理ボリュームが存在するか確認する。 ls /dev/mapper/myvg0* # 以下の出力があれば作成成功だよ。 /dev/mapper/myvg0-name ファイルシステムを入れてマウントする。\n1 2 3 4 5 6 7 8 # ext4ファイルシステムを作成する mkfs -t ext4 /dev/mapper/myvg0-name # マウント用フォルダを作成する mkdir /mnt/tmp # マウントする mount /dev/mapper/myvg0-name /mnt/tmp # マウントが成功したか確認する df -h /mnt/tmp もしくは/etc/fstabに書き込んで自動マウントさせることもできるよ。\n12.3.3 LVM論理ボリュームを拡張しよう もし論理ボリュームの容量を使い切っちゃったら、その論理ボリュームをアンマウントせずに容量を追加できるよ。そのためには、ボリュームグループに利用可能なスペースがある必要があって、それから論理ボリュームを拡張するんだ。\n残りの容量を確認する。\n1 2 3 4 # ボリュームグループの利用可能スペースを確認する vgdisplay myvg0 # 論理ボリュームの利用可能スペースを確認する df -h /mnt/tmp 論理ボリュームを拡張する。\nlvextend -L +1G /dev/mapper/myvg0-name\nファイルシステムのサイズを調整する。\nresize2fs -p /dev/mapper/myvg0-name\n調整が成功したか確認する。\ndf -h /mnt/tmp\n12.4 ファイルシステムをマウントしよう 実は前の2つのセクションで、ファイルシステムをマウントするコマンドmountや自動マウントの設定（/etc/fstabファイル）についてはすでに触れてるんだ。\n12.4.1 サポートされているファイルシステム cat /proc/filesystemsコマンドを入力して、サポートされているファイルシステムタイプを確認できるよ。以下はその一部だね。\nファイルシステム 説明 ext4 人気のext3ファイルシステムの後継だよ。最大1EBのボリュームと最大16TBのファイルをサポートしてるんだ。 iso9660 High Sierraファイルシステム（CD-ROMの元々の標準規格だよ）から発展したもの。データCD-ROMでよく使われるファイルシステムだね。 Minix UNIXのMinix版で最初に使われたもの。最大30文字までのファイル名しかサポートしてないんだ。 msdos MS-DOSのファイルシステムタイプで、Windows OSのフロッピーディスクをマウントするのに使えるよ。 vfat Microsoftが拡張したFATファイルタイプだね。 exfat SDカード、USBドライブ、その他のフラッシュメモリ向けに最適化された拡張FATファイルシステムだよ。 proc 本当のファイルシステムじゃないんだ。Linuxカーネルのファイルシステムインターフェースだよ。/procのマウントポイントはprocファイルシステムであるべきだね。多くのユーティリティが/procに依存してLinuxカーネル情報にアクセスしてるんだ。 ReiserFS ジャーナリングファイルシステムだよ。かつて複数のLinuxディストリビューションでデフォルトのファイルシステムタイプだったけど、今ではextやxfsが主流だね。 swap スワップパーティションに使われるよ。 squashfs 圧縮されていて読み取り専用のファイルシステムタイプだよ。 NFS Network Filesystemの略で、他のLinuxやUNIXコンピューター上のファイルシステムをマウントするのに使うんだ。 ntfs Windows NTファイルシステムだね。 xfs 元々はSilicon Graphicsが開発した高性能ファイルシステムで、大きなファイルの扱いにとても優れてるんだ。 gfs2 共有ディスクファイルシステムの一種だよ。複数のコンピューターがCIFSやNFSのようなネットワークファイルシステム層を介さずに、共通の共有ディスクを使えるようにするものだね。 man fsと入力して、さらに詳しいLinuxファイルシステム関連の情報を知ることができるよ。\n12.4.2 スワップ領域を起動しよう 1 2 3 4 5 6 # スワップパーティションの数を確認する free -m # スワップパーティションを作成する mkswap /var/opt/myswap # スワップパーティションを有効にする swapon /var/opt/myswap もし/etc/fstabにスワップパーティション関連の項目を追加しているなら、例えばこうだね：\n/var/opt/myswap swap swap defaults 0 0\nswapon -aで有効にできるよ。\n12.4.3 スワップ領域を無効にしよう swapoff /var/opt/myswap\n12.4.4 fstabファイルを使ってマウント可能なファイルシステムを定義しよう 12.2.3で説明済みだけど、2番目のフィールドはデバイス名ではなくUUIDを使ってもいいんだ。デバイス名は変わる可能性があるからね。\nUUIDを確認するには：blkid\n12.4.5 mountコマンドを使ってファイルシステムをマウントしよう これも12.2.3で説明済みだよ。\n12.4.6 ループバック方式でディスクイメージをマウントしよう つまりISOイメージファイルをマウントするってことだね。\n1 2 3 4 # マウント用フォルダを作る mkdir /mnt/tmp # マウントする mount -o loop name.iso /mnt/tmp 12.4.7 umountコマンドを使おう デバイスパーティション名かディレクトリ名を入力できるよ。\nデバイスパーティション名なら：umount /dev/sdb1\nディレクトリ名なら：umount /mnt/tmp\n通常は、ディレクトリ名を使うのがいいよ。\nもしディレクトリが使用中でアンマウントできない場合は、こうできるよ：\n遅延アンマウント：umount -l\n強制アンマウント：umount -f\n12.5 Cockpitを使ってストレージを管理しよう GUIだよ。起動の仕方は第8章を見てね。\n","date":"2023-01-03T13:37:48+08:00","permalink":"https://blog.yexca.net/ja/archives/85/","title":"Linux 学習 第12章 ディスクとファイルシステムの管理"},{"content":" 📢 この記事は gemini-3-flash-preview によって翻訳されました 第11章 ユーザーアカウントの管理 ユーザーアカウントは、システムを利用する人間と、システム内で動いているプロセスの間の境界線を守るものなんだ。そしてグループっていうのは、システムの権限を一度に複数のユーザーへ割り当てるための方法だよ。\n11.1 ユーザーアカウントの作成 Linuxシステムを使う人は、みんな自分専用のアカウントを持つべきなんだ。アカウントがあれば、ファイルを保存するための自分だけの場所が持てるし、GUIやパス、環境変数なんかを自分好みにカスタマイズして、使いやすく調整することもできるからね。\nCockpitっていうGUIを使ってアカウントを作ることもできるよ。もしインストールされてなかったら、こんな感じで入れられる：\n1 2 yum install cockpit -y systemctl enable --now cockpit.socket それから、ブラウザで localhost:9090 を開けば操作できるよ。\n11.1.1 useradd コマンドでユーザーを追加する 多くの場合、GUIを使うのはちょっと面倒だから、useradd コマンド（root権限が必要）でユーザーを追加するのが一般的だね。必須の引数はユーザーのログイン名だけで、他にも色々なオプションがあるよ：\nオプション 説明 -c \u0026ldquo;comment\u0026rdquo; 新しいアカウントの説明を入れる。普通はユーザーのフルネームだね。 -d home_dir ホームディレクトリを設定する。デフォルトはログイン名で /home の中に作られるよ。 -D アカウントを作るんじゃなくて、指定した情報をデフォルト設定として保存する。 -e expire_date YYYY-MM-DD 形式でアカウントの有効期限を決める。例：-e 2024-08-01 -f -1 パスワードが切れてから何日後にアカウントを完全にロックするか。-1 は無効設定だよ。 -g group プライマリグループを設定する（/etc/group に存在する必要あり）。指定しないとユーザー名と同じ名前のグループが作られて、それがプライマリになるよ。 -G grouplist ユーザーをサブグループに追加する。カンマ区切りで指定するんだ。例：-G wheel, sales, tech -k skel_dir ホームディレクトリにコピーするファイルの雛形ディレクトリを指定する。デフォルトは /etc/skel。 -m ホームディレクトリを自動で作る。FedoraやRHELではデフォルトだけど、Ubuntuだとそうじゃないこともあるよ。 -M ホームディレクトリを作らない。-m オプションがあっても無視する。 -n ユーザー名と同じグループを自動で作る機能を無効にする。 -o -u uid と一緒に使って、他のユーザーと同じUIDを持つアカウントを作れるようにする。 -p passwd パスワードを設定する（MD5などでハッシュ化されたもの）。指定しない場合は後で passwd user で設定できる。ハッシュ化には openssl passwd とかが使えるね。 -s shell デフォルトのシェルを設定する。例：-s /bin/csh -u user_id ユーザーIDを指定する。指定しなければ自動で割り振られるよ（普通のユーザーは1000から始まる）。 よく使うのはこんな感じ：\n1 2 3 # root権限で useradd yexca passwd yexca yexca というアカウントを作る時、useradd コマンドは裏でこんなことをやってるんだ：\n/etc/login.defs と /etc/default/useradd を読み込んで、デフォルト値を確認する。\nコマンドライン引数をチェックして、どのデフォルト値を上書きするか決める。\nデフォルト値と引数に基づいて、/etc/passwd と /etc/shadow に新しいユーザーのエントリを作る。\n/etc/group に新しいグループのエントリを作る。\n/home ディレクトリの中に、ユーザー名のホームディレクトリを作る。\n/etc/skel ディレクトリの中身を新しいホームディレクトリにコピーする。これにはログインスクリプトとか設定ファイルが含まれてるよ。\n/etc/passwd ファイルの中身はこんな風になってる：\nyexca:x:1001:1001::/home/yexca:/bin/bash\nコロンで区切られていて、左から：ログイン名、パスワード、ユーザーID、プライマリグループID、コメント、ホームディレクトリ、デフォルトシェル、だよ。\nパスワード欄が x になってるのは、実際の中身が暗号化されて /etc/shadow に保存されてるからなんだ。\n/etc/group ファイルはこんな感じ：\nyexca:x:1001:\nこれもコロン区切りで、グループ名、グループパスワード、グループID、そのグループに属するユーザーリスト、という順番だよ。\n11.1.2 ユーザーのデフォルト値を設定する useradd コマンドは /etc/login.defs と /etc/default/useradd を見てデフォルト値を決めてるから、このファイルをいじればデフォルトを変えられるよ。\nLinuxの種類によって login.defs の中身は違うけど、一部を紹介するね：\n1 2 3 4 5 6 7 8 9 10 11 12 13 PASS_MAX_DAYS 99999 PASS_MIN_DAYS 0 PASS_MIN_LEN 5 PASS_WARN_AGE 7 UID_MIN 1000 UID_MAX 60000 SYS_UID_MIN 200 SYS_UID_MAX 999 GID_MIN 1000 GID_MAX 60000 SYS_GID_MIN 201 SYS_GID_MAX 999 CREATE_HOME yes その他の設定は /etc/default/useradd で確認できる。useradd -D を叩けば今の設定が見れるよ。\n-D と他のオプションを組み合わせれば、/etc/default/useradd の中身を書き換えることもできるんだ：\n-b default_home \u0026mdash; ホームディレクトリを作る親ディレクトリを設定する（普通は /home）。\n-e default_expire_date \u0026mdash; アカウントが無効になるデフォルトの期日を設定する（YYYY-MM-DD）。\n-f default_inactive \u0026mdash; パスワード期限が切れてから何日でアカウントを無効にするか。\n-g default_group \u0026mdash; デフォルトのグループ。\n-s default_shell \u0026mdash; デフォルトのシェル。\n11.1.3 usermod を使ってユーザー情報を変更する usermod コマンドを使えば、既存のアカウントの設定を簡単に変えられるよ。\nオプション 説明 -c \u0026ldquo;username\u0026rdquo; コメント（説明）を変える。 -d home_dir ホームディレクトリを変える。 -e expire_date 新しい有効期限（YYYY-MM-DD）を設定する。 -f -1 パスワード期限切れ後のロックまでの日数を変える。 -g group プライマリグループを変える（存在するグループに限る）。 -G grouplist サブグループを上書きする。今のグループを残したいなら -Ga を使うんだ。 -l login_name ログイン名を変える。 -L アカウントをロックする（/etc/shadow のパスワードの前に「!」がつくよ）。 -m 元のホームディレクトリの中身を新しい場所へコピーする（-d と一緒に使う）。 -o UIDの重複を許可する（-u と一緒に使う）。 -s shell シェルを変える。 -u user_id ユーザーIDを変える。 -U ロックを解除する（「!」を消す）。 11.1.4 userdel でユーザーを削除する 例えば userdel -r yexca と打てば、yexcaというユーザーを /etc/passwd から消せるよ。-r をつければホームディレクトリの /home/yexca も一緒に消してくれるんだ。\nユーザーを消す前に、そのユーザーが残したファイルを find で探しておくといいかもね。 例：find / -user yexca -ls とか find / -uid 1001 -ls。\n持ち主がいないファイルが残ってるとセキュリティのリスクになることもあるから、実在するユーザーに持ち主を変えるか、find / -nouser -ls で持ち主不明のファイルを探して整理するのがおすすめだよ。\n11.2 グループアカウントを理解する 複数のユーザーでファイルを共有したい時、グループアカウントはすごく便利なんだ。\nchgrp グループ名 ファイル名orディレクトリ名 で、持ち主グループを変えられるよ。\n11.2.1 グループアカウントの使い方 全てのユーザーは一つの「プライマリグループ」に属してる。これは /etc/passwd の4番目のフィールドにある数字で決まってるんだ。\nそれ以外に「サブグループ（増補グループ）」にも所属できるよ。もし yexca が yexca グループと hi グループの両方のメンバーなら、/etc/group はこんな感じになる：\nyexca:x:1001:yexca\nhi:x:1002:yexca\nグループの変更ができるのはroot権限がある人だけ。普通のユーザーは自分のグループを変えたり、誰かを自分のグループに入れたりはできないんだ。\nもし一時的に特定のグループとしてファイルを作りたいなら、newgrp コマンドで一時的にそのグループに切り替えることができるよ。\nroot権限があれば、gpasswd コマンドでグループにパスワードを設定することもできる。\n11.2.2 グループアカウントの作成 作成：groupadd グループ名\nグループIDを指定して作成：groupadd -g gid グループ名\n既存のグループ情報を変える時は：\ngroupmod -g gid ユーザー名\ngroupmod -n グループ名 ユーザー名\nサブグループの変更は、さっきの usermod を使ってね。\n11.3 企業でのユーザー管理 ACL（アクセス制御リスト）という技術を使えば、特定のユーザーやグループに対して、ファイルやディレクトリの権限を細かく設定できるんだ。\n11.3.1 ACLで権限を設定する 使うのは setfacl（設定）と getfacl（確認）の2つ。\n設定する時は -m（修正・追加）や -x（削除）を使うよ。例えば：\nsetfacl -m u:ユーザー名:rwx ファイル名\n11.3.2 共同作業用のディレクトリを作る chmod で権限を変える時、普段はあんまり気にしないけど、特殊な3つの権限ビットがあるんだ。これを使うと便利なことができるよ。\n例えば chmod 775 /home/yexca/tmp.txt は、実は 0775 っていう意味なんだ。\n名前 数値 記号 セットユーザーID (SUID) 4 u+s セットグループID (SGID) 2 g+s スティッキービット 1 o+t グループ共同作業ディレクトリを作る（SGIDを設定） 1 2 3 4 5 6 7 8 9 10 11 # 共同作業用のグループを作る groupadd -g 301 cooperation # ユーザーをグループに入れる usermod -aG cooperation yexca # ディレクトリを作る mkdir /mnt/co-tmp # グループをcooperationに変える chgrp cooperation /mnt/co-tmp # 権限を設定（2はSGIDのこと） chmod 2775 /mnt/co-tmp # 権限を確認すると rwxrwsr-x になってるはず これで、ユーザー yexca が /mnt/co-tmp 内でファイルを作ると、そのファイルのグループは自動的に cooperation になるんだ。自分のプライマリグループにならないから共有が楽になるよ。\n削除制限付きディレクトリを作る（スティッキービット） コマンド：chmod 1775 /mnt/tmp\nこの設定をすると、たとえ書き込み権限があっても、rootユーザーかそのファイルの持ち主以外はファイルを消せなくなるんだ。\n/tmp ディレクトリがまさにこれ（権限は rwxrwxrwt）だね。\nセットユーザーID (SUID) について\n実行ファイルにこれが設定されていると（rwsr-xr-x）、誰が実行しても「そのファイルの持ち主」の権限で動くことになるんだ。\n例えば su コマンド。誰でも実行できるけど、動いてるプロセスはrootユーザーのものとして扱われるよ。\n11.4 ユーザーアカウントの一元管理 Linuxのデフォルトの認証は /etc/passwd と /etc/shadow を使うけど、他にも色々な方法があるよ。\n例えば LDAP (Lightweight Directory Access Protocol) や NIS (Network Information Service)、Windowsと連携する Winbind なんかが有名だね。\n","date":"2023-01-02T12:29:03+08:00","permalink":"https://blog.yexca.net/ja/archives/84/","title":"Linux学習 第11章 ユーザーアカウントの管理"},{"content":" 📢 この記事は gemini-3-flash-preview によって翻訳されました 第十章 ソフトウェアの取得と管理 10.1 デスクトップでのソフトウェア管理 ソフトウェアセンターやGUIを使って管理する方法だよ。\n10.2 Software ウィンドウを超えて 「Software」で検索できるソフトウェアには限りがあるんだ。\n10.3 Linux の RPM と DEB パッケージについて知ろう パッケージは tarball（圧縮ファイル）と呼ばれていて、実行ファイル（コマンド）、ドキュメント、設定ファイル、そしてライブラリが含まれているよ。\nDEB (.deb) パッケージ Debian GNU/Linux プロジェクトが作成したパッケージ形式。Debian や、それをベースにしたディストリビューション（Ubuntu、Linux Mint、KNOPPIX など）で使われているんだ。apt や dpkg コマンドを使って、インストール、管理、更新、削除を行うよ。\nRPM (.rpm) パッケージ もともとは Red Hat Package Manager だったけど、後に RPM Package Manager と命名されたんだ。RPM は SUSE、Red Hat 系（RHEL、Fedora）、そしてその他の派生版（CentOS、Oracle Linux など）で標準的に使われているパッケージ形式だよ。元々の rpm や、それを強化した yum、そして現在の dnf コマンドを使ってソフトウェアを管理するんだ。\nyum は最終的に dnf コマンドに置き換わる予定だよ。\n10.3.1 DEB パッケージを理解する Debian パッケージは、多くのファイルとソフトウェアに関連するメタデータをアーカイブ形式で保存しているんだ。ファイルには実行ファイル（コマンド）、設定ファイル、その他のプロジェクトファイルが含まれるよ。メタデータには依存関係、ライセンス、パッケージサイズ、説明文などの情報が入っているんだ。\napt* コマンドを使って、取得（apt-get）、検索（apt-cache search）、詳細表示（apt-cache show）、インストール（apt-get install）、アップグレード（apt-get upgrade）、インストール済みリストの表示（apt-cache pkgnames）などができるよ。\naptitude コマンドを使えば、シェルの中で画面ベースのメニューを使ってインストールすることもできるんだ。\n10.3.2 RPM パッケージを理解する RPM パッケージはいろいろなファイルを一つにまとめたもので、それぞれのファイルが特定の機能を提供しているんだ。RPM の中身は、ソフトウェアを構成するコマンド、設定ファイル、ドキュメント、あるいはメタデータ（パッケージの内容、ソース、実行に必要な条件など）だよ。\nrpm -q -i パッケージ名 コマンドを使えば、特定のソフトウェアの情報を確認できるよ。\n10.4 yum を使った RPM パッケージの管理 10.4.1 yum から dnf への移行 DNF は「Dandified yum」の略称なんだ。 https://github.com/rpm-software-management/dnf/ dnf は yum と基本的なコマンドラインの互換性を保っているけど、大きな違いの一つは、厳格な API に従っていて、拡張機能やプラグインの開発が推奨されている点だね。\n以下の yum コマンドは、すべて dnf コマンドとしてそのまま使えるよ。\ndnf についてもっと詳しく知りたいときは、 https://dnf.readthedocs.io/ を見てみて。\n10.4.2 yum の仕組みを理解する 基本構文は yum [オプション] コマンド だよ。\n例えば Firefox をインストールする場合は：yum install firefox\n/etc/yum.conf のチェック ファイルの中身はこんな感じ：\ngpgcheck パッケージの検証を行うかどうか。\ninstallonly_limit=3 システムに保存できる同じパッケージの最大バージョン数（カーネルパッケージを少なくとも2つ確保するために、2未満には設定しないほうがいいよ）。\nclean_requirements_on_remove=True ソフトウェアをアンインストールするとき、他のソフトで使われていない依存関係も一緒に削除する設定。\nbest=True アップグレード時に、できるだけ最新バージョンを優先して試みる設定。\ncachedir キャッシュの場所。\nkeepcache キャッシュを保持するかどうか。\ndebuglevel ログに書き出す詳細レベル。高いほど詳しい。\nmetadata_expire メタデータの有効期限。\n詳しく知りたいときは、 man yum.conf コマンドを使ってみて。\n/etc/yum.repos.d/*.repo ファイルのチェック 特定のソフトウェアリポジトリを有効にしたいときは、このディレクトリに .repo ファイルを置くんだ。内容はだいたいこんな感じ：\n1 2 3 4 5 6 7 [myrepo] # 始まり、`[]` 内がリポジトリ名 name=My repo # 詳細な説明 baseurl=https://rpmrepo.yexca.net/ # 架空のURLだよ # RPMファイルを含むURLは http://, ftp://, file:// が使えるよ enabled=1 # このリポジトリを有効にするか。書かなければデフォルトで有効 gpgcheck=1 # パッケージの署名をチェックするか gpgkey=file:///etc/MYKEY # パッケージチェック用のキーの場所 リポジトリは好きなだけ有効にできるけど、yum コマンドを実行するたびに全部チェックしてメタデータをダウンロードするから、あまり増やしすぎないようにね。\nYUM リポジトリから RPM パッケージとメタデータをダウンロードする rpm ディレクトリには repodata ディレクトリがあって、有効なすべてのリポジトリのメタデータがここに集約されるんだ。\nメタデータは /var/cache/yum に保存されて、有効期限が切れると最新のものが取得されるよ。yum はデフォルトで 6時間、dnf は 48時間だね。\nRPM パッケージを Linux ファイルシステムにインストールする 関連するソフトがキャッシュにダウンロードされたら、yum は内部で rpm コマンドを走らせてインストールするんだ。スクリプトが含まれている場合は先にそれを実行し、そのあとパッケージの内容（コマンド、設定、ドキュメントなど）をメタデータで指定された場所にコピーする。最後にインストール後処理のスクリプトを動かすよ。\nYUM リポジトリのメタデータをローカルの RPM データベースに保存する 各 RPM リポジトリに含まれるメタデータは、最終的にローカルの RPM データベースにコピーされるんだ。このデータベースは /var/lib/rpm ディレクトリ内の複数のファイルに保存されているよ。\n10.4.3 サードパーティのリポジトリを利用する 安定性を考えるなら公式リポジトリだけを使うのがおすすめだけど、使い勝手を優先するなら RPM Fusion などのサードパーティリポジトリを有効にしてもいいと思うよ。 https://rpmfusion.org/ を参考にしてみて。\n10.4.4 yum コマンドでソフトウェアを管理する パッケージを検索する yum search キーワード\nソフトウェアの詳細情報を取得する yum info firefox\nコマンドや設定ファイル名、ライブラリ名はわかるけど、パッケージ名がわからないとき yum provides キーワード\nlist サブコマンドを使っていろいろな形式でパッケージ名を表示する yum list firefox\nyum list available\nyum list installed\nyum list all\nパッケージの依存関係や提供元などを確認する yum deplist firefox | less\nパッケージのインストールと削除 install サブコマンドで一つ以上のパッケージと依存関係をインストールする yum install firefox または yum -y install firefox （確認なしでインストールする場合）\nreinstall サブコマンドで再インストールする yum reinstall firefox\nremove サブコマンドでソフトと不要になった依存関係を削除する yum remove firefox\nまたは、履歴から取り消すこともできるよ。\nyum history でインストール履歴を確認して、yum history info 12 で ID 12 の詳細を見て、yum history undo 12 でその操作を取り消せるんだ。\nパッケージを更新する yum check-update で更新があるか確認、yum update で全部更新、yum update firefox で Firefox だけ更新するよ。\nパッケージグループを更新する 一連のパッケージをまとめて管理するために、yum はパッケージグループをサポートしているんだ。\nyum grouplist | less でグループ一覧を表示。\nyum groupinfo LXDE で LXDE デスクトップ関連のグループ詳細を確認。\nyum groupinstall LXDE で LXDE グループをインストール。\nyum groupremove LXDE でグループごと削除。\nRPM データベースとキャッシュのメンテナンス yum clean packages インストールパッケージを削除。\nyum clean metadata メタデータを削除。\nyum clean all 全部削除。\nめったにないけど、RPM データベースが壊れることもあるんだ。\nyum check キャッシュとデータベースの状態をチェック。\nrpm --rebuilddb データベースを再構築。\n注：ローカルの RPM データベースを操作するなら、普通は rpm コマンドを使うのが一番適しているよ。\nYUM リポジトリから RPM をダウンロードする インストールせずに、現在のディレクトリにダウンロードだけする場合：\nyumdownloader firefox\ndnf download firefox\n10.5 rpm コマンドを使ったインストール、照会、検証 ほとんどの場合、rpm コマンドは手元にあるパッケージファイルに対して使うよ。\n10.5.1 rpm を使ったパッケージのインストールと削除 インストール rpm -i パッケージ名\nファイル名（ベース名、バージョン、カーネルなどを含むフルネーム）を指定する必要があるよ。\nアップグレード rpm -Uhv パッケージ名\n-h は進行状況を # で表示、-v は詳細出力を意味するよ。\n更新 今のディレクトリにたくさん rpm があって、すでにインストールされているものだけ更新したいとき：\nrpm -Fhv *.rpm\n再インストール rpm -Uhv --replacepkgs パッケージ名\nダウングレード rpm -Uhv --oldpackage パッケージ名\n削除 削除のときはベース名だけで OK。例えば Firefox を消すなら：\nrpm -e firefox\nただし、そのソフトの依存関係までは消してくれないから注意してね。\n10.5.2 rpm 情報の照会 インストール後に -q オプションを使って情報を調べるよ。説明なら -qi、ファイルリストなら -ql、設定ファイルなら -qc だね。\n照会はベース名で大丈夫： rpm -qi firefox\n他にも、依存関係（-q --requires）、提供しているバージョン（-q --provides）、実行スクリプト（-q --scripts）、変更履歴（-q --changelog）なんかも見れるよ。\n--queryformat で表示形式を変えたり、--querytags で使えるタグを確認できたりするんだ。\nこれらはローカルの RPM データベースへの照会だけど、-p オプションを付ければ今のディレクトリにあるファイルに対しても照会できるよ。この場合はフルネームが必要： rpm -qip zsh-5.7.1-1.fc30.x86_64.rpm\n10.5.3 rpm パッケージの検証 注：この機能について他の資料であまり見かけなかったし、今自分の Linux 環境がないから検証できてないんだ（前使ってた時は再現しなかった記憶がある）。でも一応メモしておくね。\n-V オプションを使うと、インストール済みのパッケージが最初から変更されていないかチェックできるよ。もしバイナリファイル（/bin 以下など）が変更されていたら、システムがハッキングされている可能性があるんだ。設定ファイルの変更はよくあることだけどね。\nFirefox の状態をチェックするなら： rpm -V firefox\nもし以下の文字が出たら、その項目が変更されているってことだよ。何も出なければオリジナルと同じ状態だね。\n文字 説明 S ファイルサイズが一致しない M モードが一致しない（権限やファイルタイプ） 5 MD5 チェックサムが一致しない D デバイスのメジャー/マイナー番号が不一致 L readLink (2) のパスが不一致 U 所有ユーザーが一致しない G 所有グループが一致しない T mTime（修正時刻）が一致しない P caPabilities（機能）が一致しない これらのインジケーターは rpm マニュアルの Verify セクションに載っているよ。\n--replacepkgs を使えば、元の状態に戻すことができるんだ。\nセキュリティを極限まで高めるなら、RPM データベース（/var/lib/rpm）をバックアップして読み取り専用メディアに保存しておくといいよ。もしデータベース自体が改ざんされたら、検証の意味がなくなっちゃうからね。\n10.6 企業でのソフトウェア管理 Kickstart ファイル、PXE 起動、Satellite サーバー (Spacewalk) 、コンテナイメージなどがあるよ。\nこれらを使えば、大量のインストールを自動化できるんだ。\n","date":"2022-12-08T16:35:57+08:00","permalink":"https://blog.yexca.net/ja/archives/83/","title":"Linux学習 第10章 ソフトウェアの取得と管理"},{"content":" 📢 この記事は gemini-3-flash-preview によって翻訳されました 第8章 システム管理を学ぶ 8.1 システム管理を理解する su コマンド \u0026mdash; rootユーザーとしてシェルを開く\nsudo コマンド \u0026mdash; 一般ユーザーがこのコマンドを通して他のコマンドを実行するときに、root権限が与えられる\n8.2 グラフィカル管理ツールを使う Cockpit はブラウザベースのシステム管理ツールだよ。\nCockpit をインストールする 1 sudo dnf install cockpit root ユーザーでログインして、Cockpit のソケットを有効にする 1 sudo systemctl enable --now cockpit.socker ブラウザでインターフェースを開く： localhost:9090 8.2.1 system-config-* ツールを使う ツール コマンド 説明 ドメイン名システム (DNS) system-config-bind コンピュータをDNSサーバーにするなら、ゾーン(Zone)を作成・設定する HTTP system-config-httpd Apache Web サーバー NFS system-config-nfs 他のNFSサービスを使っているコンピュータと共有するディレクトリを設定する Rootパスワード system-config-rootpassword rootのパスワードを変更する Samba NFS system-config-samba Windows共有フォルダを設定する サービス system-config-services Fedoraの異なるランレベルでのサービスを表示・変更する 認証 authconfig-gtk システムのユーザー認証方法を変更する 日付と時刻 system-config-date 日付と時刻を設定したり、NTPサーバーと同期したりする ファイアウォール system-config-firewall ファイアウォールを設定する 言語 system-config-language 言語を選択する 印刷 system-config-printer ローカルやネットワークプリンタを設定する SELinux管理 policycoreutils-gui SELinuxの強制モードとデフォルトポリシーを設定する ユーザーとグループ system-config-users ユーザーアカウント関連 8.3 rootユーザーアカウントを使う 8.3.1 シェル経由でrootユーザーになる su コマンドを使えば root ユーザーになれるけど、このままだと環境変数は元のユーザーのままだよ。\nsu - を使えば、環境変数も root ユーザーのものに切り替わるんだ。\nちなみに、 su - ユーザー名 で指定したユーザーに切り替えることもできるよ。\n8.3.2 sudo で管理権限を取得する sudo で実行するコマンドは root 権限を持つよ。root のパスワードは必要なくて、そのユーザーに権限を与えておくだけでいいんだ。\nsudo 権限を与える方法は以下の通り：\nroot ユーザーで visudo コマンドを実行する\n次のような行を追加する\n1 2 3 4 5 yexca ALL=(ALL) ALL # あるいは、sudoを使うときにパスワードを不要にする場合 # (rootのパスワードではなく、そのユーザー自身のパスワードのこと) yexca ALL=(ALL) NOPASSWD:ALL これで yexca ユーザーに sudo 権限が与えられるよ。\nファイルを保存して閉じる 8.4.2 設定ファイルを管理する ほとんどの設定ファイルは /etc ディレクトリの中にテキスト形式で保存されているよ。主なものは以下の通り：\nディレクトリ 説明 /etc/cron* crond がスケジュール実行するプログラムを定義。cron.daily、cron.hourly など /etc/cups CUPS 印刷サービスの設定ファイル /etc/default いろいろなユーティリティのデフォルト値を設定するファイル /etc/httpd Apache Web サーバーの動作設定 /etc/rc?.d システムの状態（ランレベル）ごとに用意されたディレクトリ：rc0.d (停止)、rc1.d (シングルユーザー)、rc2.d (マルチユーザー)、rc3.d (マルチユーザー＋ネットワーク)、rc4.d (ユーザー定義)、rc5.d (マルチユーザー＋ネットワーク＋GUIログイン)、rc6.d (再起動) /etc/skel 新しいユーザーを作成するとき、このディレクトリのファイルがユーザーのホームディレクトリにコピーされる /etc/sysconfig いろいろなサービスが作成・維持する重要なシステム設定ファイルが含まれる /etc/systemd systemd ユーティリティ（起動プロセスやシステムサービスの管理用）に関連するファイル /etc/xinetd.d xinetd デーモンが特定のポートで待ち受けるオンデマンドネットワークサービスを定義するファイル群 8.4.3 ログファイルと Systemd.Journal の管理 rsyslogd と systemd の journalctl コマンドを使うよ。\nrsyslogd とその前身の syslogd は、ログファイルを /var/log ディレクトリに置くんだ。\n8.5 その他の管理用アカウントを使う 例えば lp、apache、bin などのユーザーは、デフォルトではログインできないようになっているよ。\nもしログインしたいなら、デフォルトのシェルを /sbin/nologin や /bin/false から /bin/bash などの実際のシェルに変更する必要があるんだ。\n8.6 ハードウェアの確認と設定 8.6.1 ハードウェアを確認する dmesg や journalctl コマンドを使って、Linux 起動時のハードウェア検出情報やドライバのロード情報を確認できるよ。\nlspci コマンドで PCI バスと接続デバイスを、lsusb コマンドで USB デバイス情報を、lscpu でプロセッサ情報を表示できるんだ。\n8.6.2 ローダブルモジュールの使用 正しく認識されないハードウェアを追加したいときは、手動でモジュールをロードする必要があるかもしれない。\nロード可能なモジュールをリストアップする lsmod コマンドを使うよ。特定のモジュールの詳細を知りたいときは modinfo -d モジュール名 コマンドを使おう。\nモジュールをロードする modprobe コマンドを使って、コンパイルされて実行中のカーネルにインストールされているモジュールをロードできるよ。\nモジュールを削除する rmmod コマンドを使うか、依存モジュールも一緒に削除したいときは modprobe -r を使おう。\n8.7 小結 Linux では、セキュリティを確保するために、各サービス（http、git など）ごとに専用のユーザーを作成して、ログイン権限を制限するのがいいよ。\n第9章 Linux のインストール 特になし\nグラフィカルなインストールについては言うまでもないし、他のインストール方法については Arch Wiki のインストールガイド を参考にするといいよ。\n僕も Arch Wiki よりはクオリティが低いけど、記事を書いてみた： 仮想マシンへの Arch Linux インストール記録 – yexca\u0026rsquo;Blog 他にも PXE 起動などのリモートインストールがあるけど、再現環境がないから今はちょっと理解しにくいかな。\n","date":"2022-12-07T16:29:05+08:00","permalink":"https://blog.yexca.net/ja/archives/82/","title":"Linux学習 第8・9章 システム管理とLinuxのインストール"},{"content":" 📢 この記事は gemini-3-flash-preview によって翻訳されました 第7章 簡単なシェルスクリプトを書いてみよう もし何度も繰り返すタスクがあって、そのたびに大量のコマンドを打ち込まないといけないなら、シェルスクリプトを書いて一つのコマンドで全部済ませちゃうのがいいよ。\n7.1 シェルスクリプトを理解する シェルスクリプトは、コマンド、関数、変数、その他シェルで使える機能をひとまとめにしたもの。これらをプレーンテキストファイルに書き込むことで、一つのコマンドとして実行できるようになるんだ。\nWindowsのバッチファイル (.bat) みたいなものだね。\n7.1.1 シェルスクリプトの実行とデバッグ シェルスクリプトのいいところは、どんなテキストエディタでも開いて中身を確認できること。逆に欠点は、大きくて複雑なスクリプトだと、コンパイル済みのプログラムより実行が遅くなりがちなことかな。実行方法は基本的に2つあるよ。\nスクリプト名を bash の引数として渡す。例：bash myscript\nシェルスクリプトの1行目にインタプリタの名前 (#!/bin/bash) を書いて、そのファイルに実行権限を付けてから (chmod +x myscript)、コマンドラインでスクリプトのパスを入力して実行する。例：(./myscript.sh)\n実行するとき、スクリプト名の後に続くのがコマンドライン引数だよ。\nコメントは # を使う。\nスクリプトの最初に set -x を入れるか、$ bash -x myscript と打つことで、実行中のコマンドを表示しながらデバッグできるよ。\n7.1.2 シェル変数を理解する シェル変数の名前はは大文字と小文字を区別するから注意してね。定義するときは等号 (=) の前後にスペースを入れないのがルールだよ。例：\nNAME=value\n変数にはテキスト、数字、アンダースコアなどの定数を代入できる。\nコマンドの結果を変数に入れることもできるよ。例：MYDATE=$(date) と書くと、date コマンドの出力が変数 MYDATE に入るんだ。\nこうすると、変数 MYDATE を使うたびに一回 date コマンドが動いて、その結果が MYDATE に代入される。代入時の実行結果が欲しいときは、コマンドを引用符 ' で囲めばOK。\n特殊なシェル文字：ドル記号 ($)、引用符 (')、アスタリスク (*)、感嘆符 (!) など。\nもしコマンドラインで $HOME という文字列をそのまま表示したいなら、$ をエスケープする必要がある。echo '$HOME' か echo \\$HOME を使えばいいよ。つまり：\nシェルに特定の文字をそのまま解釈させたいときは、バックスラッシュ \\ を使う。\n文字の集まりをそのまま解釈させたいときは、シングルクォート (') で囲む。\n一部の文字だけそのまま解釈させたいときは、ダブルクォート (\u0026quot;) で囲む。この場合、ドル記号 ($)、引用符 (')、感嘆符 (!) は解釈されるけど、アスタリスク (*) などの他の文字はそのまま扱われるよ。\n変数に値を代入するときはそのまま名前を使うけど、変数を参照（値を取得）するときは頭にドル記号 ($) をつけるのを忘れないで。\n例：ある変数の値を新しい変数に入れる：newVar=\u0026quot;$oldVar\u0026quot;\n特殊なシェル位置パラメータ 位置パラメータ、つまり コマンドライン引数 は、$0、$1、$2\u0026hellip;$n という名前になっているよ。\n$0 は呼び出されたスクリプト自身の名前で、それ以外はコマンドラインから渡された引数の値が入るんだ。例えば：\n1 2 3 4 5 6 #!/bin/bash echo \u0026#34;最初の引数は $1 、2番目の引数は $2 \u0026#34; echo \u0026#34;このスクリプトの名前は $0 \u0026#34; echo \u0026#34;全部で $# 個の引数が渡されたよ\u0026#34; echo \u0026#34;すべての引数はこれ：$@ \u0026#34; ./myscript hello bye というコマンドを実行すると、結果はこうなる：\n1 2 3 4 最初の引数は hello 、2番目の引数は bye このスクリプトの名前は /home/yexca/tmp/myscript 全部で 2 個の引数が渡されたよ すべての引数はこれ：hello bye もう一つ面白いのが $? で、これは最後に実行されたコマンドの終了ステータスを受け取る。普通、正常に終われば 0 が返ってくるよ。\n引数を読み取る read コマンドを使うと、ユーザーの入力を受け取ることができる。\n1 2 3 4 #!/bin/bash read -p \u0026#34;2つの単語を入力してね：\u0026#34; var1 var2 echo \u0026#34;今、 $var1 と $var2 が入力されたよ\u0026#34; Bash でのパラメータ展開 変数の値が欲しいときは頭にドル記号 ($) をつけて $var と書くけど、これは実は ${var} の短縮形なんだ。\nBash にはパラメータの値をいろいろな方法で展開するルールがある。よく使うものを ${var} を例に挙げておくね。\n例 説明 ${var:-value} もし変数が未設定か空なら、value として展開する ${var#pattern} var の値の 前方 から、pattern と 最短 で一致する部分を削る ${var##pattern} var の値の 前方 から、pattern と 最長 で一致する部分を削る ${var%pattern} var の値の 末尾 から、pattern と 最短 で一致する部分を削る ${var%%pattern} var の値の 末尾 から、pattern と 最長 で一致する部分を削る これを使うと、こんな便利なことができるよ：\n1 2 3 4 5 6 7 8 9 myFileName=/home/yexca/myfile.txt # file は myfile.txt になる file=${myFileName##*/} # dir は /home/yexca になる dir=${myFileName%/*} # name は myfile になる name=${file%.*} # extension は txt になる extension=${file##*.} 7.1.3 シェルスクリプトで計算をする Bash の変数は型が決まっていない（非型指定）。declare で明示しない限り、変数は文字列として扱われるんだ。でも計算するときは自動的に整数に変換されるから、代入時に型を気にする必要はないよ。\n内蔵の let コマンド、外部の expr コマンド、あるいは bc コマンドを使って整数の計算ができる。\n例：let result=$num/16 や let num=$RANDOM\nインクリメント演算子の i++ や ++i も使えるよ。\nlet コマンドは、演算子と数字の間にスペースを入れちゃダメ。\nexpr コマンドは逆に、演算子と数字の間にスペースが必要。\nbc コマンドはスペースを気にしなくていいし、浮動小数点（小数）の計算もできるよ。\n7.1.4 シェルスクリプトでプログラミング構造を使う \u0026ldquo;if\u0026hellip;then\u0026rdquo; 文 1 2 3 if [ $var -eq 1 ]; then echo \u0026#34;変数は 1 だよ\u0026#34; fi 数字を比べるなら -eq がいいけど、文字列を比べるなら等号 (=) のほうが使いやすいよ。\n1 2 3 if [ $str = \u0026#34;hello\u0026#34; ]; then echo \u0026#34;hello\u0026#34; fi 不等号 != もある。\nelif を使えば選択肢を増やせるし、else で「それ以外」の場合を指定できる。\n1 2 3 4 5 6 7 8 str=\u0026#34;$HOME\u0026#34; if [ -f \u0026#34;$str\u0026#34; ]; then echo \u0026#34;$str は普通のファイルだね\u0026#34; elif [ -d \u0026#34;$str\u0026#34; ]; then echo \u0026#34;$str はディレクトリだね\u0026#34; else echo \u0026#34;これは何かな？？？\u0026#34; fi よく使うテスト条件のリストだよ：\n演算子 テストの内容 -a file ファイルが存在するか（-e と同じ） -b file ブロックデバイスファイルか -c file キャラクタデバイスファイルか -d file ディレクトリか -e file ファイルが存在するか（-a と同じ） -f file 普通のファイルか（ディレクトリやデバイスファイルじゃないか） -g file SGID ビットがセットされているか -h file シンボリックリンクか（-L と同じ） -k file スティッキービットがセットされているか -L file シンボリックリンクか（-h と同じ） -n string 文字列の長さが 0 より大きいか -O file 自分がそのファイルの所有者か -p file 名前付きパイプか -r file 読み取り可能か -s file ファイルが存在して、サイズが 0 より大きいか -S file ソケットファイルか -t file ターミナルに接続されたディスクリプタか -u file SUID ビットがセットされているか -w file 書き込み可能か -x file 実行可能か -z string 文字列の長さが 0 か こっちは2つの変数を比べるとき：\n演算子 テストの内容 expr1 -a expr2 両方の式が真か expr1 -o expr2 どちらかの式が真か file1 -nt file2 ファイル1のほうが新しいか（タイムスタンプで比較） file1 -ot file2 ファイル1のほうが古いか（タイムスタンプで比較） file1 -ef file2 2つのファイルが同じ実体（ハードリンクかシンボリックリンク）か var1 = var2 2つの変数が等しいか var1 -eq var2 2つの変数が等しいか var1 -ge var2 var1 が var2 以上か var1 -gt var2 var1 が var2 より大きいか var1 -le var2 var1 が var2 以下か var1 -lt var2 var1 が var2 より小さいか var1 != var2 2つの変数が等しくないか var1 -ne var2 2つの変数が等しくないか さらに、テスト演算子を \u0026amp;\u0026amp;（AND）や ||（OR）と組み合わせて、C言語の三項演算子みたいに書くこともできるよ。\nC言語：a\u0026gt;b ? a : b\nShell：[ $a -gt $b ] \u0026amp;\u0026amp; echo $a || echo $b\n単独でも使える。例えば： [ $a -eq $b ] \u0026amp;\u0026amp; echo $a は「a と b が等しければ、a を表示する」。\n[ -d \u0026quot;$dirName\u0026quot; ] || mkdir \u0026quot;$dirName\u0026quot; は「$dirName というディレクトリがなければ、mkdir で作る」。\ncase コマンド C言語の switch 文みたいなもので、条件分岐に使うよ。基本の形はこんな感じ：\n1 2 3 4 5 6 7 8 9 10 11 case \u0026#34;VAR\u0026#34; in Result1) body ;; Result2 | Result3) body ;; *) body ;; esac for\u0026hellip;do ループ for ループはリストの中身を順番に処理するときに使うよ。\n1 2 3 4 5 6 7 8 9 10 for VAR in LIST do body done # またはこう書く for VAR in LIST ; do body done 例えば：\n1 2 3 4 5 6 7 8 9 10 for num in 0 1 2 3 4 do echo \u0026#34;数字は $num だよ\u0026#34; done # コマンドの出力をリストにすることもできる for file in $(ls /bin) ; do echo $file done while\u0026hellip;do と until\u0026hellip;do ループ 構造はこんな感じ：\n1 2 3 4 5 6 7 8 9 10 11 # while...do：条件が真の間繰り返す while condition do body done # until...do：条件が真になるまで繰り返す until condition do body done 7.1.5 便利なテキスト操作プログラムを使う よく使われるのは grep, cut, tr, awk, sed。ほとんどが標準入力と標準出力を使うように設計されているよ。\n一般正規表現アナライザー (grep) ファイルやテキストの中から特定のパターンを探す方法。強力な検索ツールとして使えるよ。\n形式：grep 探したい内容 入力元\n詳しくは man grep で確認してみて。\nテキストの切り出し (cut) cut コマンドはテキストやファイルから特定のフィールドを抜き出すことができる。例えば：\ngrep /home /etc/passwd | cut -d':' -f6 -\nまず grep で /etc/passwd から /home を含む行を探して、それを cut に渡す。cut は : を区切り文字として使って、6番目のセグメント (-f6) を取り出しているよ。\n文字の変換や削除 (tr) tr は文字ベースのコンバーターで、文字を置換したり削除したりできる。\n1 2 3 4 5 6 7 8 9 # 大文字を小文字に変換 FOO=\u0026#34;AbcDEF\u0026#34; echo $FOO | tr [A-Z] [a-z] # ファイル名の中のスペースをアンダースコアに変換する例 for file in *; do f=$(echo \u0026#34;$file\u0026#34; | tr \u0026#39; \u0026#39; \u0026#39;_\u0026#39;) [ \u0026#34;$file\u0026#34; = \u0026#34;$f\u0026#34; ] || mv -i -- \u0026#34;$file\u0026#34; \u0026#34;$f\u0026#34; done ストリームエディタ (sed) sed は簡単なスクリプトエディタ。特定のパターンに一致する行を消したり、文字を置換したりといった編集ができる。\nかなり奥が深いから、オンラインドキュメントで調べてみてね。\n7.1.6 簡単なシェルスクリプトを使ってみる 電話リストの例だよ：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #!/bin/bash # (@)/ph # とてもシンプルな電話リスト # \u0026#34;ph new 名前 番号\u0026#34; でリストに追加 # \u0026#34;ph 名前\u0026#34; で電話番号を検索できるよ PHONELIST=~/.phonelist.txt # 引数がない場合はエラーメッセージを出す if [ $# -lt 1 ]; then echo \u0026#34;誰の番号が知りたいの？\u0026#34; exit 1 fi # 新しい番号を追加する場合 if [ \u0026#34;$1\u0026#34; = \u0026#34;new\u0026#34; ]; then shift echo $* \u0026gt;\u0026gt; $PHONELIST echo \u0026#34;$* をデータベースに追加したよ\u0026#34; exit 0 fi # 検索。ファイルが空じゃないかチェック if [ ! -s $PHONELIST ]; then echo \u0026#34;まだ電話リストに誰もいないよ！\u0026#34; exit 1 else grep -i -q \u0026#34;$*\u0026#34; $PHONELIST # 静かに検索 if [ $? -ne 0 ]; then # 見つかったかな？ echo \u0026#34;残念、その名前はリストになかったよ\u0026#34; exit 1 else grep -i \u0026#34;$*\u0026#34; $PHONELIST fi fi exit 0 7.2 小結 シェルスクリプトを書けるようになると、よくあるシステム管理タスクを自動化できるようになって、すごく便利になるよ。\n","date":"2022-12-05T20:47:43+08:00","permalink":"https://blog.yexca.net/ja/archives/81/","title":"Linux学習 第7章 簡単なシェルスクリプトを書いてみよう"},{"content":" 📢 この記事は gemini-2.5-flash によって翻訳されました はじめに 最近、『マンガでわかるデジタル回路』っていう本を読んだんだ。軽くまとめとくね。\n本に書いてあったこと全部はここに書いてないよ。\n前置き デジタル回路は組み合わせ回路と順序回路に分かれるよ。\n組み合わせ回路：今の入力情報の組み合わせで出力が決まる回路。\n順序回路：『記憶』を持った回路。\nMIL記号 論理回路の ANDゲート と ORゲート の記号は、複数の入力に対して1つの出力がある形に拡張されてるんだ。\n記号の意味 ANDゲート (ALL) ：複数の入力が全部1のときに、出力が1になる。\nORゲート (EXIST) ：どれか1つでも入力が1のときに、出力が1になる。\n配線 丸が付いてるのは低レベル (0、L)。\n丸が付いてないのは高レベル (1、H)。\n組み合わせ回路の作り方 多数決回路 複数人で投票して2つの結果から1つを選ぶ回路だよ。\n真理値表を作る。つまり、ありうる全てのパターンを書き出す。\n真理値表のH出力のところに下線を引く。\n『入力の線』と『入力をNOTにする線』でフレームワークを組む。\n2列の縦方向の配線を用意して、2列目はNOT線、つまり1列目からNOTゲートを繋いで2列目にするんだ。\nANDゲートに接続する。\n入力がLのときは、入力をNOTにしたところ (2列目) から始める。\n入力がHのときは、一番最初のところ (1列目) から線を引く。\nそして、ANDに繋ぐ。\nこの手順を繰り返して、2番目で下線を引いたところを全部やる。\nANDの全ての出力をORに接続する。\n回路の簡略化 デジタル回路の設計フローは、問題整理 - 真理値表 - 簡略化 - 回路図作成、って感じ。\nカルノー図を使って簡略化するよ。\n真理値表をカルノー図に変換する。\n真理値表を作るときは、列を一番上から始める。例えば、[C、B、A] で、結果がZって感じ。\nカルノー図は二次元の真理値表で、一般的には0と1でレベルを表すんだ。\nもし入力が3つなら、行をB、A、列をCにして、その結果を二次元表に埋めていく。\n簡略化の前に知っとくこと\nカルノー図の左右と上下は繋がってるんだ。横方向も縦方向もビット (1ビット) 単位で変化するからね。\n簡略化\n一緒になってる1をひとつの集合としてまとめていく。\n行と列の共通点を探す。\nもし共通点が0だったら否定演算、つまり文字の上にバーを引く。\n例えば\nC\\BA 00 01 11 10 0 1 1 1 上の表で、共通点はCが0、Aが1だから、式は!C * Aになるね。\n簡略化のルール\n集合の形は、縦横が1、2、4の長方形 (または正方形) しかダメ。\n集合は重ねていいよ。\n集合の数は少ないほど、面積は大きいほどいい。\n注：左右と上下はひとつの集合として見れるよ。もしこれ以上『集合を作れない』ってなったら、その回路はもうそれ以上簡略化できないってこと。\n簡略化したら回路図を描くんだ。全ての式を、前の手順 (3番目から) で描けばOKだよ。\n回路の無視 (ドンケア) 入力を決めるとき、バイナリ数の特性上、考慮しなくていい入力が出てくることがあるんだ。\n例えば、入力が月だとして、4ビットのバイナリ数を使うと全部で16通りの入力があるけど、そのうち0、13、14、15なんかは考慮しなくていい入力だよね。\nこういう入力は、カルノー図では『-』で代用できて、簡略化のときに集合体に入れちゃってもいいんだ。\n順序回路の作り方 順序回路を作るには、組み合わせ回路とフリップフロップが必要になるよ。\n順序回路の『記憶』についてだけど、例えば自動販売機でお金を投入するとき、今までの合計金額を記憶してるよね。もし記憶がなかったら、最後のコインの額面だけになっちゃう。\nフリップフロップを導入するんだけど、例えばクロック (CLK) があって、CLKがトリガーされたときだけ、入力が出力に影響を与えるんだ。それ以外は出力は変わらないよ。\n電子サイコロを作るのを例に見てみよう。\n状態遷移図を描く。\n時間の変化に合わせて、電子サイコロがどう変わっていくか？\nもし停止が低レベルなら、1から6、そしてまた1に戻る。\nもし高レベルなら、どこかの点でずっと停止する。\nバイナリ数で状態を表す。\nそれぞれの状況、つまり状態をバイナリ数で表して、それから状態遷移表を作るんだ。\n状態遷移表から回路図を描くには、Dフリップフロップを使って状態を記憶できるよ。\n組み合わせ回路を設計する。\n『今の状態』から『次の状態』を決めるっていうのは、実は組み合わせ回路なんだ。\n","date":"2022-12-04T16:54:29+08:00","permalink":"https://blog.yexca.net/ja/archives/80/","title":"オーム社の『マンガでわかるデジタル回路』を読んだ感想"},{"content":" 📢 この記事は gemini-2.5-flash によって翻訳されました 第6章 実行中のプロセスを管理する Linuxって、マルチユーザーOSで、マルチタスクシステムでもあるんだ。マルチタスクってことは、複数のプログラムを同時に動かせるってこと。この動いてるプログラムのインスタンスのことを、通常「プロセス」って呼ぶんだよ。\nシェルからプロセスを起動したり、一時停止させたり、停止させたり、強制終了させたりできるんだ。それに、プロセスをバックグラウンドに置いたり、フォアグラウンドに戻したりもできるよ。\n6.1 プロセスを理解しよう プロセスっていうのは、コマンドが実行されたインスタンスのこと。システム中のプロセスは、プロセスID (PID) っていうので識別されてて、このPIDは現在のシステム上でユニークなんだ。PID以外にも、プロセスは特定のユーザーアカウントやグループアカウントと紐づいてて、そのプロセスがどんなシステムリソースにアクセスできるかを判断するのに役立つんだ。\nプロセス関連の情報を表示するコマンドは、主に/procファイルシステムに保存されてる生データから情報を取得してるよ。各プロセスは/proc内のサブディレクトリ（そのプロセスのPIDが名前になってる）に自分の情報を保存してるんだ。\n6.2 プロセスの一覧表示 psコマンドかtopコマンドを使うんだ。topコマンドの方が、より画面に特化した形でプロセスを一覧表示してくれるよ。\n6.2.1 psコマンドでプロセスを一覧表示しよう ps uを使うと、ユーザー名とか他の情報も表示してくれるよ。\nVSZ：仮想メモリサイズ (Virtual Set Size) で、イメージプロセスのサイズ（単位：KB）を表示するんだ。\nRSS：(Resident Set Size) で、メモリ中のプログラムのサイズを表示するよ。\nVSZはプロセスに割り当てられたメモリ量で、RSSはプロセスが実際に使ってるメモリ量（スワップできない物理メモリのこと）を表してるんだ。\nSTAT列：Sは現在実行中のプロセス、Rはスリープ中のプロセス、+はプロセスがフォアグラウンド操作と関連してることを示すんだ。\n現在のユーザーの全プロセスを見るには：ps ux | less\n全ユーザーのプロセスを見るには：ps aux | less\n出力列をカスタマイズしたり、特定の列でソートしたりもできるよ。例えばこんな感じ。\n1 ps -eo pid,user,uid,group,gid,vsz,rss,comm --sort=-vsz | less -eは実行中の全プロセスを表示するオプションで、-oの後ろには表示する列を指定するんだ。commはコマンドで、--sort=-vszはvsz列で大きい順にソートするって意味だよ。\n6.2.2 topコマンドでプロセスを一覧表示・変更しよう topコマンドを使うと、デフォルトではプロセスが現在使ってるCPUの割合でソートされて表示されるんだ。\ntopコマンドでできる操作はこれ！\nコマンド 説明 h ヘルプ M メモリ使用状況でソート 1 全CPUの使用状況表示を切り替え (システムに複数のCPUがある場合) R 逆順ソート u その後ユーザー名を入力すると、そのユーザーのプロセスを表示 r プロセスの優先度を変更 (nice値) k プロセスを強制終了 (killコマンド) 6.2.3 System Monitorでプロセスを一覧表示しよう GNOMEデスクトップのGUIツールだよ。\n6.3 バックグラウンドとフォアグラウンドのプロセスを管理しよう GUIがないシステムだと、全部シェルで操作するしかないよね。Bashシェルには複数のプログラムを管理するGUIはついてないけど、アクティブなプログラムをバックグラウンドとフォアグラウンドで直接移動させることができるんだ。こうすれば、たくさんのプログラムを動かしつつ、今やりたいプログラムを選んで作業できるってわけ。\n6.3.1 バックグラウンドプロセスを起動しよう コマンドをバックグラウンドに置くには：\nコマンドの後ろに\u0026amp;をつける\natコマンドを使って他のコマンドを実行する\n実行中のプロセスに対しては、Ctrl+Zで停止させて、それからfgでフォアグラウンドに戻すか、bgでバックグラウンドで実行を再開させる\nバックグラウンドの出力がフォアグラウンドの操作を邪魔しないように、空のデバイス2\u0026gt;/dev/nullにリダイレクトすることもできるよ。\njobsコマンドでバックグラウンドで動いてるコマンドを確認できるよ（-lを使うとPIDも見れる）。コマンド番号の前に+がついてるのは最近バックグラウンドに置かれたジョブで、-がついてるのはその前に置かれたジョブなんだ。\n6.3.2 フォアグラウンドとバックグラウンドのコマンドを使ってみよう バックグラウンドジョブを参照したいなら、%とジョブ番号（jobsコマンドの出力）を使うんだ。他にもこんな方法があるよ。\n% \u0026mdash; 最近バックグラウンドに置かれたジョブ（つまり番号の後ろに+がついてるやつ）を参照する\n%string \u0026mdash; stringで始まるジョブ（あいまいだとダメ、つまり一致結果がユニークじゃないと）\n%?string \u0026mdash; コマンドラインのどこかにstringが含まれるジョブ（これもあいまいだとダメ、一致結果がユニークじゃないと）\n%-- \u0026mdash; 最近バックグラウンドに置かれたジョブの前に置かれたジョブ（つまり番号の後ろに-がついてるやつ）を参照する\nfg %1を使うと、番号1のタスクをフォアグラウンドに持ってくることができるし、bg %5を使うと、停止中の番号5のコマンドをバックグラウンドで実行し続けさせることができるよ。\nviコマンドなんかは、バックグラウンドに置く前に自動的に停止しちゃうから、忘れちゃわないようにファイルを保存してからバックグラウンドに置くのを忘れずにね。\n6.4 プロセスを強制終了したり変更したりしよう プロセスにいろんなシグナルを送ってその挙動を変えることもできるし、プロセスのプロセッサ優先度を変更することもできるんだ。\n6.4.1 killとkillallコマンドでプロセスを強制終了させよう この2つのコマンドは、よく実行中のプロセスを終了させるのに使われるけど、実際にはプロセスに有効なシグナルを送ってるんだ。シグナルは数字か名前で表されるよ。\nシグナル 数字 説明 SIGHUP 1 設定ファイルを再読み込みする SIGINT 2 キーボードからの割り込み SIGQUIT 3 キーボードからの終了 SIGABRT 6 abort(3)呼び出しで生成される中断シグナル SIGKILL 9 強制終了シグナル SIGTERM 15 終了シグナル SIGCONT 19, 18, 25 停止中のプロセスを再開する SIGSTOP 17, 19, 23 プロセスを停止する 最後の2つのシグナルについては、最初の値はAlphaとSPARC向け、真ん中の値はx86向け、最後の値はMIPSアーキテクチャ向けだよ。\nデフォルトはSIGTERM (15) シグナルなんだ。異なるプロセスはいろんなシグナルに応答できるけど、SIGKILL (9) とSIGSTOPシグナルだけは、どんなプロセスもブロックできないんだよ。\nkillコマンドを使ってPIDに基づいてプロセスにシグナルを送る 1 kill [シグナル] [PID] 例えば、プロセスIDが2333のプロセスを強制終了するなら：kill -9 2333とかkill -SIGKILL 2333って感じ。\nkillallコマンドを使って名前に基づいてプロセスにシグナルを送る killコマンドと似てるけど、同じ名前のコマンドをたくさん強制終了したいときにすごく便利なんだ。でも、うっかり大事な同じ名前のプロセスを変えちゃわないように注意してね。\n例えば、gnome-shellを再起動するなら：killall -1 gnome-shellってやるよ。\n6.4.2 niceとreniceコマンドでプロセッサの優先度を設定しよう Linuxカーネルがどの実行中プロセスがCPUにアクセスできるかを決めるときに考慮する要素の一つが、プロセスについてるnice値なんだ。範囲は-20から19までで、デフォルトは0だよ。\nnice値が低いほど優先度が高くなるんだ。rootユーザーだけが負の値を設定して優先度を上げられる（値を低くする）けど、一般ユーザーは優先度を下げることしかできない（値を高くする）んだよ。\nniceコマンドを使って特定のnice値でコマンドを実行できるし、reniceコマンドとPIDを使ってすでに実行中のプロセスのnice値を変更することもできるんだ。例えばこんな感じ。\nnice -n +5 updatedb \u0026amp;ってやると、updatedbコマンドをバックグラウンドで優先度5で実行するよ。\nrenice -n 3 2333ってやると、PIDが2333のプロセスのnice値を3に変更するんだ。\n6.5 cgroupsを使ってプロセスを制限しよう あるプロセスに設定したnice値は子プロセスには適用されないんだ。つまり、niceでは特定のユーザーやアプリケーションが使えるLinuxシステムの総リソース量を制限することはできないってこと。\ncgroupsコマンドを使うと、プロセスをタスクとして特定して、特定のコントロールグループに所属させることができるんだ。タスクは階層構造で設定できて、その中にはデーモン（すべてのバックグラウンドサーバープロセスにデフォルトの制限が設定されてる）と呼ばれるタスクや、httpdやvsftpdなんかに対する特定の制限を設定するサブタスクが含まれるよ。\nあるタスクがプロセスを起動すると、その子プロセスは親プロセスの制限設定を継承するんだ。制限内容は、ストレージ、プロセッサスケジューリング、プロセスレポート、CPU割り当て、デバイスアクセス、メモリ使用状況なんかが含まれるよ。\ncgroupsの設定はかなり厄介かもしれないな。設定ファイルを編集してcgroupsを作成したり（/etc/cgconfig.conf）、特定のユーザーやグループを制限したり（/etc/cgrules.conf）するんだ。cgscreateコマンドを使ってcgroupsを作成し、それらのグループを/sys/fs/cgroup階層に追加することもできるよ。もし設定を間違えると、システムが起動できなくなる可能性もあるから注意してね。\n","date":"2022-12-03T15:07:03+08:00","permalink":"https://blog.yexca.net/ja/archives/79/","title":"Linux 学習 第6章 実行中のプロセスを管理する"},{"content":" 📢 この記事は gemini-3-flash-preview によって翻訳されました 第五章 テキストファイルを使ってみよう Linuxのほとんどの設定は、プレーンテキストファイルを編集することで行われるんだ。/etc ディレクトリのファイルを編集してローカルサービスを設定するのも、Ansible ディレクトリのファイルを編集してホストの構成を管理するのも、テキストファイルは今でもあらゆるタスクで使われているよ。\n5.1 vim と vi でファイルを編集する vim は vi の改良版で、使い方はだいたい同じだけど、vim にはガイドやコードハイライトなんかがあるから、基本的には vim を使うのがおすすめ。\n実際、一部の Linux ディストリビューションでは vi が vim のエイリアスになっていて、alias vi と打つと alias vi = 'vim' って表示されることもあるんだ。でも、root ユーザーだとエイリアスが設定されていないことも多いよ。\nちなみに Linux には他にもテキストエディタがあって、nano、gedit、jed、joe、kate、kedit、mcedit、nedit なんかがある。CUI で動くプレーンテキスト用だと jed や joe も有名だね。\n5.1.1 vi を使い始める vi には3つのモードがあるんだ。主なのは コマンドモード と 挿入モード、それと ex モードだね。ファイルを開いた直後（vi file を実行した後）は、デフォルトでコマンドモードになっているよ。\nコマンドモードは、テキストを変更する前に「何をしたいか」を伝えるコマンド（1〜2文字のアルファベットや数字）を入力するモードなんだ。\n注意：コマンドは大文字と小文字を区別するから気をつけてね。\nテキストの追加 挿入モード に入るには、以下の「入力」コマンドのどれかを打つんだ。\nコマンド 説明 a 追加。カーソルの右側にテキストを入力する A 行末に追加。現在の行の最後に移動して入力を始める i 挿入。カーソルの左側にテキストを入力する I 行頭に挿入。現在の行の最初に移動して入力を始める o 下に開く。現在の行の下に新しい行を作って挿入モードになる O 上に開く。現在の行の上に新しい行を作って挿入モードになる 挿入モードに入ると、画面の左下に --INSERT-- って表示されるよ。\n入力が終わったら、Esc キーを押してコマンドモードに戻ろう（たまに2回押す必要があるけど、とりあえず Esc を押せば大丈夫）。\nテキスト内の移動 1文字ずつ移動するときは以下のキーを使うよ。\nキー 説明 矢印キー 上下左右 h, j, k, l 左、下、上、右 Backspace, Space 左、右 もっと大きく移動するコマンドはこちら。\nコマンド 説明 w 次の単語の先頭に移動（スペース、タブ、記号区切り） W 次の単語の先頭に移動（スペース、タブ区切り） b 前の単語の先頭に移動（スペース、タブ、記号区切り） B 前の単語の先頭に移動（スペース、タブ区切り） 0 (ゼロ) 行頭に移動 $ 行末に移動 H 画面の一番上の行に移動 M 画面の中央の行の先頭に移動 L 画面の一番下の行に移動 テキストの削除、コピー、変更 これらのコマンドは、移動キー（矢印や PgUp、PgDn、アルファベットなど）や数字と組み合わせて、「何を」削除・コピー・変更するかを正確に指定できるんだ。\nコマンド 説明 x カーソル位置の文字を削除 X カーソルの前の文字を削除 d\u003c?\u003e テキストを削除 c\u003c?\u003e テキストを変更 y\u003c?\u003e テキストをコピー（ヤンク） 表の中の \u0026lt;?\u0026gt; には移動コマンドが入るよ。例えば：\ndw \u0026mdash; カーソル位置から単語の終わりまで削除 db \u0026mdash; カーソル位置から単語の始まりまで削除 dd \u0026mdash; 行全体を削除 c$ \u0026mdash; カーソル位置から行末まで削除して挿入モードへ（要は書き換え） c0 \u0026mdash; カーソル位置から行頭まで削除して挿入モードへ cl \u0026mdash; カーソル位置の1文字を削除して挿入モードへ cc \u0026mdash; 行全体を削除して挿入モードへ yy \u0026mdash; 行全体をバッファにコピー y) \u0026mdash; カーソル位置から文の終わりまでコピー y} \u0026mdash; カーソル位置から段落の終わりまでコピー 数字を使ってコマンドを繰り返すこともできるよ。\n3dd \u0026mdash; カーソル行から3行削除 3dw \u0026mdash; 次の3つの単語を削除 5cl \u0026mdash; 次の5文字を変更（削除して挿入モードへ） 12j \u0026mdash; 12行下に移動 5cw \u0026mdash; 次の5単語を削除して挿入モードへ 4y) \u0026mdash; 次の4文をコピー テキストの貼り付け（ペースト） バッファに保存された最新のテキストをファイルに戻すコマンドだよ。\nコマンド 説明 P カーソルの左側（行単位なら上の行）に貼り付け p カーソルの右側（行単位なら下の行）に貼り付け コマンドの繰り返し 削除や変更、貼り付けをした後、. を押すと同じ操作を繰り返せるんだ。例えば、単語 Joe を Jim に書き換えた（cw）後、次の場所を探して . を押せば同じように書き換えられるよ。\nvi を終了する コマンドモードで ZZ と打てば保存して終了できる。または : を押して ex モードに入ってから操作するよ。\nコマンド 説明 :w 保存する（終了しない） :wq 保存して終了（ZZ と同じ） :q 終了する（変更がない場合のみ） :q! 強制終了（変更を保存しない） その他のコマンド u \u0026mdash; 操作を取り消す（Undo） Ctrl+R \u0026mdash; 取り消しを取り消す（Redo） :!command \u0026ndash; :! の後に shell コマンドを打つと、直接実行できる。例えば :!date で日付を確認したり。:!bash で新しいシェルを起動もできるけど、戻るのを忘れないように保存してからやるのがおすすめ。 Ctrl+g \u0026mdash; ファイル名、現在の行番号、総行数、パーセンテージ、列番号を表示する。 5.1.2 ファイル内をジャンプする ファイルが長いときは、こっちの移動方法が便利だよ。\nコマンド 説明 Ctrl+f 1ページ進む Ctrl+b 1ページ戻る Ctrl+d 半ページ進む Ctrl+u 半ページ戻る G ファイルの最後の行へ移動 nG n 行目へ移動（数字を指定） 5.1.3 テキストを検索する / や ? を使って、前方や後方にテキストを検索できる。メタ文字も使えるよ。\n/hello* \u0026mdash; hello で始まる行を前方に検索 ?[pP]rint \u0026mdash; print または Print という単語を後方に検索 検索結果が出た後、n（次へ）や N（前へ）で同じ方向や逆方向に続けて検索できるよ。\n5.1.4 ex モードを活用する vi エディタはもともと ex エディタがベースになっているんだ。ex モードを使うと、1行または複数行のテキストをまとめて検索して変更できるよ。\nコマンドモードで : を入力して ex モードに入る。\n:g/Local \u0026mdash; \u0026ldquo;Local\u0026rdquo; という単語を検索して、該当する行を表示する。 :s/Local/Remote \u0026mdash; 現在の行で最初に見つかった \u0026ldquo;Local\u0026rdquo; を \u0026ldquo;Remote\u0026rdquo; に置換する。 :g/Local/s//Remote \u0026mdash; 各行の最初に見つかった \u0026ldquo;Local\u0026rdquo; をすべて \u0026ldquo;Remote\u0026rdquo; に置換する。 :g/Local/s//Remote/g \u0026mdash; ファイル内のすべての \u0026ldquo;Local\u0026rdquo; を \u0026ldquo;Remote\u0026rdquo; に置換する。 :g/Local/s//Remote/gp \u0026mdash; すべて置換して、その結果の行を表示する。 5.1.5 もっと詳しく知りたいなら vimtutor コマンドを打つと、vim の中でチュートリアルが始まるよ。これが一番の近道かも。\n5.2 ファイルを探す システム内のファイルを見つけるための便利なコマンドがいくつかあるよ。\nlocate \u0026mdash; 名前でファイルを探す find \u0026mdash; いろんな属性でファイルを探す grep \u0026mdash; ファイルの中身（テキスト）を検索する 5.2.1 locate コマンドで名前から探す ほとんどの Linux システムでは、毎日1回 updatedb コマンドが走って、ファイル名のリストをデータベースに保存しているんだ。locate はそのデータベースを検索するからめちゃくちゃ速い。データベースを手動で更新したいときは sudo updatedb を使おう。ただし、自分がアクセス権を持っているファイルしか表示されないからね。\n使い方は locate [検索文字列]。大文字小文字を無視したいときは -i を付けて locate -i [検索文字列]。例えば、名前に \u0026ldquo;yexca\u0026rdquo; が含まれるディレクトリを大文字小文字問わず探すなら locate -i yexca だね。\n注意：すべてのファイルがデータベースにあるわけじゃないよ。/etc/updatedb.conf で設定された除外リストにあるファイルは検索に引っかからないんだ。\n5.2.2 find コマンドでファイルを検索する find コマンドは、ファイルシステム内を検索する最強のコマンドだよ。所有者、サイズ、更新日時などの属性（メタデータ）で探せるし、見つけた後にそのまま別のコマンドを実行させることもできる。\n注：ファイルメタデータには、所有者、グループ、タイムスタンプ、サイズ、権限、inode情報なんかが含まれているよ。\nfind と locate の違い\nfind は実際にファイルシステムをスキャンするから locate よりは遅い。でも、今さっき作ったばかりのファイル（まだデータベースに載っていないもの）も見つけられる。検索範囲を絞るために、開始ディレクトリを指定するのがコツだよ。\nfind には特別なオプション -ls があって、ls -l みたいに詳細情報を表示してくれるんだ。\n注：一般ユーザーで検索すると権限エラーがたくさん出ることがあるから、エラーを無視したいときはコマンドの最後に 2\u0026gt;/dev/null を付けよう。\nファイル名で探す -name や -iname（大文字小文字無視）を使う。ワイルドカード（* や ?）も使えるよ。\n1 find /etc -iname \u0026#39;*passwd*\u0026#39; これで /etc 以下の \u0026ldquo;passwd\u0026rdquo; を含むファイルを全部探せる（ディレクトリを指定しないとカレントディレクトリが対象になるよ）。\n-type f（ファイルのみ）や -type d（ディレクトリのみ）で絞り込むのもよく使う手だね。\nファイルサイズで探す -size オプションに + や - を付けて範囲を指定する。例えば find /etc -size +10M は 10MB より大きいファイルを探す。\n1 find /bigdata -size +500M -size -5G -exec du -sh {} \\; これは /bigdata 以下の 500MB〜5GB のファイルを探して、それぞれのサイズを表示する例だよ。\nユーザーで探す -user や -group を使う。-not（〜以外）や -or（または）も組み合わせられる。\n1 find /home \\( -user yexca -or -user lemon \\) -ls これは /home 以下の yexca か lemon が持っているファイルを表示する。\n権限で探す -perm オプションを使う。数字の前に - を付けると指定したビットがすべて立っているもの、+（あるいは /）はどれか1つでも立っているもの、何も付けないと完全一致を探すよ。\n例えば find -perm /002 は、「その他(Others)」に書き込み権限があるファイルを探すときに便利。\n日時で探す time 系のオプション（-atime, -ctime, -mtime）は「日数」、min 系（-amin, -cmin, -mmin）は「分数」で探せる。\n数値の前に - を付けるとその時間以内、+ はそれより前（もっと昔）、何も付けないとぴったりその時間、という意味になるよ。\n10分以内に変更されたものを探す： 1 find /etc -mmin -10 3日以内に権限が変更されたものを探す： 1 find /bin /usr/bin -ctime -3 300日以上アクセスされていないファイルを探す： 1 find /var/www -atime +300 \u0026rsquo;not\u0026rsquo; や \u0026lsquo;or\u0026rsquo; を組み合わせる もっと細かく絞り込みたいときに。\nyexca が所有しているけど、yexca グループじゃないファイルを探す： 1 find /home -user yexca -not -group yexca -ls yexca が所有していて、かつ 1GB 以上のファイルを探す： 1 find /home -user yexca -and -size +1G -ls 見つけたファイルに対してコマンドを実行する -exec を使うと見つかったファイルすべてに自動でコマンドを実行できる。確認しながらやりたいときは -ok を使おう。構文はどっちも同じ。\n1 2 find [オプション] -exec コマンド {} \\; find [オプション] -ok コマンド {} \\; {} が見つかったファイル名に置き換わるよ。コマンドの最後には必ず \\; を付けるのがルール。例えば：\n1 find /etc -iname passwd -exec echo \u0026#34;I found {}\u0026#34; \\; これは名前が passwd のファイルを見つけるたびに \u0026ldquo;I found ファイル名\u0026rdquo; と表示する。\nもっと詳しく知りたいときは man find を見てみてね。\n5.2.3 grep コマンドでファイル内を検索する ファイルの中に特定の文字列が含まれているか探したいときは grep の出番。該当する行を表示したり、ファイル名だけ表示したりできるよ。パイプでつないで標準出力を検索するのにもよく使われるね。\nオプション 説明 -i 大文字小文字を無視する -v 指定した文字列を含まない行を探す -r ディレクトリ内を再帰的に検索する -l 文字列が含まれるファイル名だけを表示する \u0026ndash;color 見つかった部分に色を付ける（デフォルトは赤） /etc/sysconfig 以下のファイルから \u0026ldquo;root\u0026rdquo; という文字を再帰的に探す： 1 grep -ri --color root /etc/sysconfig/ 標準出力から \u0026ldquo;inet\u0026rdquo; を含む行だけ抜き出す： 1 ip addr show | grep inet ","date":"2022-11-19T21:07:03+08:00","permalink":"https://blog.yexca.net/ja/archives/78/","title":"Linux学習 第五章 テキストファイルを使ってみよう"},{"content":" 📢 この記事は gemini-2.5-flash-lite によって翻訳されました Windows11 での導入方法だよ。他のシステム（Linux とか）は、 AUTOMATIC1111/stable-diffusion-webui: Stable Diffusion web UI を参照してね。\n容量について プログラム：5.3GiB (モデル含まず)\n実行時：5.5GiB 以上\nC ドライブの空き容量が最低でも 6GiB あることを確認してから実行してね。そうじゃないと、PC がブラックアウトして固まっちゃうかもしれないから。\n環境構築 まず、インターネットに繋がってることを確認してね。\nGit\n公式サイト： https://git-scm.com/ Python 3.10.6 以上 (最新バージョンは不安定な場合があるよ)\n3.10.8 がおすすめ： https://www.python.org/downloads/release/python-3108/ 「Add python.exe to PATH」にチェックを入れるのを忘れずに！\nモデルのダウンロード\n公式モデル (リアル寄り)\nマグネットリンクからダウンロード (ちゃんとした torrent クライアントを使ってね)\n1 magnet:?xt=urn:btih:3a4a612d75ed088ea542acac52f9f45987488d1c\u0026amp;dn=sd-v1-4.ckpt\u0026amp;tr=udp%3a%2f%2ftracker.openbittorrent.com%3a6969%2fannounce\u0026amp;tr=udp%3a%2f%2ftracker.opentrackr.org%3a1337 その他のダウンロード方法\nAUTOMATIC1111/stable-diffusion-webui Wiki を見てみて。\nWaifu モデル (二次元系だよ)\nhakurei/waifu-diffusion-v1-3 at main にアクセスしてダウンロードしてね。\nその他\nStable Diffusion Models (cyberes.github.io) リポジトリのクローン 適当な場所を選んで、右クリックして「ターミナルで開く」を選んで、以下のコマンドを入力してね。\n1 git clone https://github.com/AUTOMATIC1111/stable-diffusion-webui.git 更新したいときは、このディレクトリ (stable-diffusion-webui) に移動してから git pull コマンドを使えば OK。\n設定 ダウンロードしたモデルを /models/Stable-diffusion ディレクトリに入れてね。\n/webui-user.bat ファイルを設定しよう。 set VENV_DIR= の後に適当な文字列を入れて、保存して終了してね。\n/webui-user.bat ファイルを実行しよう。\nダウンロードするファイルが大きい (6GiB くらい) から、結構時間がかかるかもしれない。その間、進捗バーとかは出ないよ (もしプログラムが終了したように見えても、ネットワーク帯域の使用状況でダウンロード中か判断できるはず)。\nもし、グラフィックカードが GTX1660 だったり、生成される画像が真っ黒だったら…\nwebui.bat を編集して、一番最初に追加するテキストはこれだよ。\n1 set COMMANDLINE_ARGS=--precision full --no-half その他 もっと詳しく知りたいなら： hua1995116/awesome-ai-painting: AI绘画资料合集（包含国内外可使用平台、使用教程、参数教程、部署教程、业界新闻等等） stable diffusion tutorial、disco diffusion tutorial、 AI Platform モデルのトレーニング： NovelAI hypernetwork 自訓練教程 - 知乎 NovelAI软件获取 - novelai 资源站 咩小咩壁纸|NovelAI资源站 プロンプトの例\n1 2 NSFW, Prhololive, uruha_rushia, 1girl, bangs, bare shoulders, red eyes, blue dress, blue green hair, blue sleeves, blush, bow, breasts, chick, collarbone, detached collar, detached sleeves, double bun, eyebrows visible through hair, frills, hair orhament, medium hair, off-shoulder dress 参考記事 最火的AI绘画教程！免费开源，包教会 - 零度解说 【心得】(NSFW) AI 色圖製作體驗 + 關鍵字 @場外休憩區 哈啦板 - 巴哈姆特 ","date":"2022-10-30T16:23:07+08:00","permalink":"https://blog.yexca.net/ja/archives/77/","title":"NovelAI 描画 (WebUI)"},{"content":" 📢 この記事は gemini-2.5-flash によって翻訳されました はじめに 仮想マシンにインストールするよ。使ったソフトはFedoraの「ボックス」だね。\nインストール前の準備 イメージのダウンロード 公式ダウンロードページ からダウンロードしてね。BTダウンロード（正規のtorrentクライアント、例えば qBittorrent を使ってね）がおすすめだよ。\nダウンロードしたら、仮想マシンに入れるんだ。\n起動モードの確認 efivarsディレクトリをリスト表示してみて。\n1 ls /sys/firmware/efi/efivars もしディレクトリがちゃんと表示されてエラーが出なければ、システムはUEFIモードで起動してるってこと。ディレクトリがなければ、たぶん BIOS モード（もしくはCSMモード）で起動してるんだ。\nこの仮想マシンではBIOSモードを使ったよ。\nインターネット接続 ネットワークインターフェースとDHCPサービスはデフォルトでオンになってるから、設定は特にいらないよ。\nシステム時刻の更新 ネットワークタイムサーバー（NTP）との同期を有効にするよ。\n1 timedatectl set-ntp true timedatectl statusコマンドでサービスの状態を確認できるよ。\nハードディスクのパーティション作成 伝統的なfdiskコマンドでパーティションを作成したよ（MBRパーティション）。起動がBIOSだから、公式のパーティション例に倣って、2つのパーティション（swap領域とその他）だけ作ったんだ。\nfdisk -lを使ってすべてのディスクをリスト表示してみてね（rom、loop、airootで終わるデバイスは無視してOK）。\nfdisk /dev/デバイス名でパーティションの作成を開始するよ。\nコマンド 説明 n 新しいパーティションを作成 p パーティションの確認 t パーティションタイプを変更 w 変更を保存 パーティションサイズを指定するときは ++num+K/M/G/T/P を使うよ。もしサフィックス（K/M/G/T/P）がなければセクタ単位で割り当てられるんだ。\nパーティションのフォーマット スワップ領域の作成 1 mkswap /dev/スワップ領域のパーティション ファイルシステムの作成 ファイルシステムによってコマンドが違うよ。例えばext4ファイルシステムならこれ。\n1 mkfs -t ext4 /dev/パーティション パーティションのマウント ルートパーティションを/mntにマウントするよ。もし複数のパーティションがある場合は、まずルートパーティションをマウントすることを忘れないでね。\n1 mount /dev/パーティション /mnt スワップ領域を有効にするよ。\n1 swapon /dev/スワップ領域のパーティション インストール ミラーの選択 ファイル/etc/pacman.d/mirrorlistには、どこからパッケージをダウンロードするかが定義されてるんだ。インターネットに接続すると自動で更新されるし、手動で変更することもできるけど、僕は変更しなかったよ。\nパッケージのインストール pacstrapスクリプトを使って、baseパッケージとLinuxカーネル、それにvimをインストールするよ。もし他のパッケージもインストールするなら、下のコマンドの後に名前を追加すればいいんだ。もちろん、後でpacmanを使ってインストールすることもできるよ。\n1 pacstrap /mnt base linux vim システム設定 Fstab /etc/fstabファイルは、システム起動時にパーティションをどのように自動マウントするかを記述しているんだ。以下のコマンドで自動生成できるよ（-Uまたは-LオプションでUUIDやボリュームラベルを設定して、UUIDを使うことでシステム起動時にエラーが出ないようにするんだ）。\n1 genfstab -U /mnt \u0026gt;\u0026gt; /mnt/etc/fstab 自動設定が正しいか確認してね。\n1 cat /mnt/etc/fstab Chroot 新しくインストールしたシステムにchrootするよ。\n1 arch-chroot /mnt タイムゾーン 上海時間を例にするね。\n1 ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime /etc/adjtimeを生成するよ。\n1 hwclock --systohc この時点でdateコマンドを使って時刻が正しいか確認できるよ。\nロケール設定 /etc/locale.genを編集して、en_GB.UTF-8のコメントアウトを外すんだ。\nそれからロケール情報を生成するよ。\n1 locale-gen /etc/locale.confファイルを作成して、LANG変数を編集してね。例えばLANG=en_GB.UTF-8って感じ。\nネットワーク設定 /etc/hostnameファイルを作成してホスト名を入力するよ。\n仮想マシンはDHCPを使ってるから、 ネットワーク設定 は特にしなかったよ。\nRootパスワード 1 passwd ブートローダーのインストール だいたいGRUBをインストールするよね。僕が使った仮想マシンはBIOS+MBRだったから、grubパッケージをインストールしたよ。\n1 pacman -S grub grubをインストールするよ（下のコマンドの/dev/デバイスはパーティションじゃないから注意してね）。\n1 grub-install --target=i386-pc /dev/デバイス 設定ファイルを生成するよ。\n1 grub-mkconfig -o /boot/grub/grub.cfg 再起動 exitかCtrl+Dでchroot環境から出るんだ。\numount -R /mntでマウントされたパーティションをアンマウントするよ。\n再起動は reboot でね。\n参考資料 インストールガイド (日本語) - ArchWiki ","date":"2022-10-02T13:39:26+08:00","permalink":"https://blog.yexca.net/ja/archives/76/","title":"仮想マシンでのArch Linuxインストール記録"},{"content":" 📢 この記事は gemini-3-flash-preview によって翻訳されました 第4章 ファイルシステム内での移動 Linuxのファイルシステムには、コンピュータ上のすべての情報が保存されてるんだ。\nディレクトリ 説明 /bin ls、sort、date、chmod みたいな、よく使うLinuxユーザーコマンドが入ってる。 /boot 起動可能なLinuxカーネル、初期RAMディスク、ブートローダーの設定ファイル (GRUB) が入ってる。 /dev システム内のデバイスへのアクセスポイントを表すファイルが入ってる。ターミナル (tty*)、ハードディスク (hd* や sd*)、RAM (ram*)、CD-ROM (cd*) などが含まれるよ。ユーザーはこれらのデバイスファイルから直接アクセスできるけど、普通はアプリが実際のデバイス名を隠してくれてるんだ。 /etc 管理用の設定ファイルが入ってる。ほとんどがテキストファイルで、適切な権限があればテキストエディタで編集できるよ。 /home ログインアカウントを持つ一般ユーザーごとのディレクトリが入ってる（rootユーザーだけは例外で、/root を使うよ）。 /media 自動マウントされるデバイス（特にリムーバブルメディア）の標準的な場所。メディアにボリューム名があれば、普通はその名前がマウントポイントになるんだ。 /lib /bin や /sbin にあるアプリがシステムを起動するのに必要な共有ライブラリが入ってる。 /mnt /media が標準になる前は、いろんなデバイスのマウントポイントとしてよく使われてた。今でも一部のシステムではハードディスクのパーティションやリモートファイルシステムのマウントに使われるし、一時的にマウントする場所として使ってる人も多いよ。 /misc リクエストに応じてファイルシステムを自動マウントするのに使われることがあるディレクトリ。 /opt 追加のアプリケーションソフトウェアを保存するためのディレクトリ構造。 /proc システムリソースに関する情報が入ってる。 /root rootユーザーのホームディレクトリ。セキュリティ上の理由で /home にはないんだ。 /sbin 管理用コマンドやデーモンが入ってる。 /sys ストレージのチューニングや cgroups 管理のためのパラメータが入ってる。 /tmp アプリケーションが使う一時ファイルが入ってる。 /usr ユーザー向けのドキュメント、ゲーム、画像ファイル (X11)、ライブラリ (lib)、その他起動に必須じゃないコマンドやファイルが入ってる。インストール後は基本的に変更されない場所で、理論上は読み取り専用でマウントすることもできるよ。 /var アプリケーションが使うデータディレクトリ。FTPサーバー (/var/ftp) や Webサーバー (/var/www) の共有ファイルを置いたりする。システムログ (/var/log) やスプールファイル (/var/spool、メールや印刷ジョブなど) もここ。頻繁に更新される場所だから、サーバーでは独立したファイルシステムとして作成されることが多いよ。 4.1 基本的なファイルシステムコマンドを使う cd 、pwd 、mkdir 、rmdir 、ls 、touch といったコマンドだね。\n4.2 メタ文字と演算子を使う いくつかの特殊な文字は「メタ文字」や「演算子」って呼ばれてるよ。\n4.2.1 ファイルマッチングメタ文字を使う メタ文字 説明 * 任意の数の文字にマッチする。 ? 任意の1文字にマッチする。 [\u0026hellip;] 括弧内のいずれかの文字にマッチする。ハイフンで範囲（文字や数字）を指定することもできるよ。 例えば ls [a-g]* って打つと、aからgで始まるファイルやディレクトリを表示してくれるんだ。\n4.2.2 ファイルリダイレクトメタ文字を使う メタ文字 説明 \u0026lt; ファイルの内容をコマンドに流し込む。デフォルトの動作だから省略できることも多いよ。例えば less bigfile は less \u0026lt; bigfile と同じだね。 \u0026gt; コマンドの標準出力をファイルに書き出す。ファイルが既にある場合は上書きされちゃうから注意。 2\u0026gt; 標準エラー（エラーメッセージ）をファイルに書き出す。 \u0026amp;\u0026gt; 標準出力と標準エラーの両方をファイルに書き出す。 \u0026raquo; コマンドの出力をファイルの末尾に追記する。 例えばこんな感じ：\n1 man chmod | col -b \u0026gt; /tmp/chmod これは、chmodのマニュアルを整形して、余計なバックスペースを削除してから /tmp/chmod に保存するコマンドだよ。\n1 echo \u0026#34;Hello World!\u0026#34; \u0026gt;\u0026gt; ~/hello これは ~/hello ファイルの最後に \u0026ldquo;Hello World!\u0026rdquo; を追記するんだ。\nリダイレクトのもう一つの形に here text (または here document) があるよ。\n1 2 3 4 5 6 7 ed /etc/resolv.conf \u0026lt;\u0026lt; resendit a nameserver 100.100.100.100 . w q resendit これは ed エディタを使って /etc/resolv.conf に DNS サーバーの IP を追加する例だね。2つの resendit の間にある内容が実行されるんだ。\n4.2.3 括弧展開を使う 大括弧 {} を使うと、ファイル名やディレクトリ名をまとめて展開できるから便利だよ。\n1 touch memo{1,2,3,4,5} これで memo1 から memo5 までの5つのファイルが一気に作れる。\n1 touch {John,Bill,Sally}-{Breakfast,Lunch,Dinner} これは9つのファイルができるね。\n1 touch {a..f}{1..5} これなら a1 から f5 まで、全部で30個のファイルができるよ。\n4.3 ファイルとディレクトリをリストアップする 普通、ls は ls --color=auto というエイリアス（別名）が設定されてるんだ。確認するにはこう打ってみて：\n1 alias ls ls -la を使えば、詳細情報 (-l) と隠しファイルを含むすべてのファイル (-a) が見れるよ。\n列 ファイル ディレクトリ 1 権限 権限 2 リンク数 リンク数 3 所有者 所有者 4 グループ グループ 5 バイトサイズ ディレクトリ情報自体のサイズ（中身の合計じゃないよ） 6 最終更新日時 最終更新日時 7 ファイル名 ディレクトリ名 メモ：\n日時のフォーマットは LANG 変数によって変わることがあるよ。 権限に s がついてる (-rwsr-sr-x) ことがあるけど、これは誰でも実行できるけど実行時の権限はそのファイルの所有者やグループになるって意味なんだ。 ディレクトリの権限の最後に t がある (drwxrwxr-t) のは「スティッキービット」。他のユーザーもファイルを置けるけど、自分が置いたファイル以外は消せない設定だよ。 ディレクトリに Set GID を設定すると、その中で作られたファイルは全部そのディレクトリと同じグループになるんだ。大文字の S や T が出ている場合は、実行権限がない状態でそれらが設定されてることを意味するよ。 権限の最後にプラス記号 (-rw-rw-r-+) があるなら ACL などの拡張属性がある証拠。ドット (.) なら SELinux が設定されてるってことだね。 cd ~yexca で yexca のホームへ、cd - で一つ前にいたディレクトリ ($OLDPWD) に戻れるよ。ちなみに `cd .` は今のディレクトリ ($PWD) のことだね。\nls コマンドの便利なオプション： -t 更新順に並べる； -F 種類がわかる記号（/ や *）を付ける； --hide=yexca 特定のファイルを表示しない； -S サイズ順に並べる； -d ディレクトリの中身じゃなくてディレクトリ自体の情報を表示する。\n4.4 ファイルの権限と所有権を理解する ls -l の最初の列について。\n1文字目はファイルタイプ：\n文字 タイプ - ファイル d ディレクトリ l シンボリックリンク b ブロックデバイス c キャラクタデバイス s ソケット p 名前付きパイプ その後の9文字が権限。3文字ずつ区切って、ユーザー (u)、グループ (g)、その他 (o) の順になってるよ。\nファイルとディレクトリで意味がちょっと違うんだ。\n権限 ファイル ディレクトリ Read 中身を見る 中のファイル一覧を見る Write 中身を書き換える、削除、名前変更 ファイルの追加や削除 Execute プログラムとして実行する そのディレクトリに移動する、中を検索する、メタデータ（サイズなど）にアクセスする 権限は ls -ld で確認できるよ。\nFedora や RHEL では、ユーザーを作るとそのユーザーと同じ名前のグループも作られるんだ。これは「ユーザー専用グループ」っていう仕組みだね。\n4.4.1 chmod (数値) で権限を変える r = 4, w = 2, x = 1 で計算するよ。\n1 chmod -R 755 ~/myfile これで ~/myfile とその中身全部 (-R) を 755 (rwxr-xr-x) にできる。\n4.4.2 chmod (文字) で権限を変える 1 chmod ug+rx files 1 chmod -R o-x ~/myfile こんなふうに直感的に指定もできるよ。\n4.4.3 umask でデフォルト権限を設定する 新しく作る時のデフォルト権限は、一般ユーザーならファイルは rw-rw-r\u0026ndash;、ディレクトリは rwxrwxr-x。rootだとファイル rw-r\u0026ndash;r\u0026ndash;、ディレクトリ rwxr-xr-x になる。これは umask の値で決まるんだ。\n例えば umask が 0002 なら、ディレクトリの最大権限 (777) から引いて 775 になるイメージだね（ファイルの場合は 666 から引いて 664。実行権限はデフォルトでオフになるよ）。\n一時的に変えるなら umask 000 みたいに打つ。 ずっと変えたいなら .bashrc に書いておこう。 4.4.4 ファイルの所有権を変える これは root ユーザーしかできないよ。\n1 chown user:group /etc/file これで所有者とグループを一気に変えられる。-R で中身もまとめて変えれるよ。\n4.5 ファイルを移動・コピー・削除する 使うのは mv, cp, rm, rmdir だね。\nmv に -i をつける（またはエイリアスにする）と、上書きする前に確認してくれるから安心。-b を使えば、上書きする前にバックアップを作ってくれるよ。\ncp で -a を使うと、日付やタイムスタンプを維持したままコピーできるんだ。\n何があっても強制的に実行したい時は -f を使うけど、慎重にね！ (例えば rm -rf /* とか絶対やっちゃダメだよ)。\n","date":"2022-09-25T20:35:02+08:00","permalink":"https://blog.yexca.net/ja/archives/75/","title":"Linux学習 第4章 ファイルシステム内での移動"},{"content":" 📢 この記事は gemini-2.5-flash によって翻訳されました はじめに 多分、最近のいじり倒しはこれで最後かな。でも、たくさんのプラグインを有効にすると起動後にデスクトップが表示されるまでかなり時間かかるんだ。だから、あんまり使わないのは後で無効にしなきゃ。\nテーマ この本 を読んで知ったんだけど、 GNOMEのテーマサイト があるんだ。そこをちょっと見て回ったら、最初に見つけたテーマに深く惹かれちゃったんだ。\nリンク テーマ： Fluent round gtk theme Github： vinceliuice/Fluent-gtk-theme: Fluent design gtk theme for linux desktops インストール GitHubのREADMEを読んだら、透明バージョンには Blur Me ってプラグインが必要らしい。でも、僕が見たときはそのプラグインが僕のGNOMEバージョンに対応してなかったんだ（この記事書いてる時点でも対応してないみたい）。そのときは透明バージョンは入れなかったんだけど、どうやったか忘れちゃったけど、サポートしてるのを見つけたんだ。 Blur my Shell ってやつ。（この透明感、マジで綺麗なんだよ！！！）\nGitでリポジトリをクローンする 1 git clone https://github.com/vinceliuice/Fluent-gtk-theme.git スクリプトを実行する 1 ./install.sh オプションを追加してカスタマイズできるよ。具体的な効果のプレビューはREADMEを見てみてね。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 -d, --dest DIR Specify destination directory (Default: /usr/share/themes) -n, --name NAME Specify theme name (Default: Fluent) -t, --theme VARIANT Specify theme color variant(s) [default|purple|pink|red|orange|yellow|green|grey|all] (Default: blue) -c, --color VARIANT Specify color variant(s) [standard|light|dark] (Default: All variants) -s, --size VARIANT Specify size variant [standard|compact] (Default: All variants) -i, --icon VARIANT Specify icon variant(s) for shell panel [default|apple|simple|gnome|ubuntu|arch|manjaro|fedora|debian|void|opensuse|popos|mxlinux|zorin] (Default: Windows icon) --tweaks Specify versions for tweaks [solid|float|round|blur|noborder|square] solid: no transparency version float: floating panel round: rounded windows blur: blur version for \u0026#39;Blur-Me\u0026#39; noborder: windows and menu with no border square: square windows button -h, --help Show help アイコン テーマには専用のアイコンがあるから、これは絶対入れるべきだよね。\nリンク Github： vinceliuice/Fluent-icon-theme: Fluent icon theme for linux desktops インストール テーマと似たようなもんで、まずリポジトリをクローンするんだ。\n1 git clone https://github.com/vinceliuice/Fluent-icon-theme.git それからスクリプトを実行する。\n1 ./install.sh もちろんオプションでカスタマイズもできるし、詳しいことはやっぱりREADMEを参考にするといいよ。\nDockバー 使うプラグイン： Dash to Dock for COSMIC テーマをインストールしたときにプレビューにあったDockバーはどうやって入れるのかわからなかったんだけど、このプラグインを見つけたんだ。設定でちょっと調整したら、透明効果も出せるよ。\n音楽プレイヤー Rhythmbox デフォルトの音楽プレイヤー、使う分には悪くないんだけど、一曲リピート機能がないのがちょっと、いや、かなり不便なんだ。\nGithub： fossfreedom/alternative-toolbar: Modern, minimal and music-focused interface for Rhythmbox インストール インストールもすごく簡単だよ。以下はFedoraでのインストール方法ね。\nまず Releases から圧縮ファイルをダウンロードして、それから環境をセットアップするんだ。\n1 sudo dnf install intltool git gnome-pkg-tools gobject-introspection glib2-devel pkg-config python3-gobject python3 その後、解凍してディレクトリに入って、以下のコマンドを順番に実行するよ。\n1 ./configure --prefix=/usr 1 make 1 sudo make install アンインストール インストールフォルダに行ってコマンドを実行する。\n1 sudo make uninstall デスクトップ背景 wallpaper engineの動画をデスクトップ背景にできないかなって思って、関連資料を検索してみたんだ。\n動画デスクトップ これ、どうもデュアルディスプレイだと画面に自動でフィットしないみたいで、あと、ループするたびに一瞬チカっとするから、使うのはやめたよ。\n環境構築 mplayer まずrpmfusionリポジトリを有効にする。\n1 sudo dnf install https://download1.rpmfusion.org/free/fedora/rpmfusion-free-release-32.noarch.rpm それからdnfを使ってインストールするんだ。\n1 sudo dnf install mplayer xwinwrap このソフト、Ubuntuのインストールパッケージしかないんだけど、実は直接解凍しても動かせるんだ。\nソースコードの場所： Github debダウンロード： xwinwrap_0.3.2git20171223_amd64.deb ファイルを抽出したら/usr/local/binにコピーして、実行権限を与えればOKだよ。\nコマンド シングルディスプレイの場合ね。\n1 xwinwrap -ni -o 1 -fdt -fs -s -st -sp -b -nf -- mplayer -framedrop -nosound -loop 0 -wid WID -quiet ~/Pictures/bg.mp4 デュアルディスプレイの場合、下記のコマンドは右側のディスプレイに表示されるよ。\n1 xwinwrap -g 1920x1080+1920+0 -fdt -ni -b -nf -- mplayer -framedrop -nosound -loop 0 -wid WID -quiet ~/Pictures/bg.mp4 具体的なコマンドオプションはxwinwrap --helpって打つか、 参考記事の2つ目 の関連部分を見てみてね。\n時間で自動壁紙変更 変更はできるんだけど、フォーマットを合わせるだけじゃなくて命名規則もあって、追加するたびにファイルを編集しなきゃいけないから、ちょっと面倒。だからやめたよ。\n壁紙のローテーション範囲を作成する 例えば、~/.backgrounds/pic.xmlっていうファイルを作成するんだけど、内容はこんな感じ。状況に応じて置き換えてね。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 \u0026lt;background\u0026gt; \u0026lt;starttime\u0026gt; \u0026lt;year\u0026gt;2022\u0026lt;/year\u0026gt; \u0026lt;month\u0026gt;9\u0026lt;/month\u0026gt; \u0026lt;day\u0026gt;17\u0026lt;/day\u0026gt; \u0026lt;hour\u0026gt;1\u0026lt;/hour\u0026gt; \u0026lt;minute\u0026gt;00\u0026lt;/minute\u0026gt; \u0026lt;second\u0026gt;00\u0026lt;/second\u0026gt; \u0026lt;/starttime\u0026gt; \u0026lt;static\u0026gt; \u0026lt;duration\u0026gt;4000.0\u0026lt;/duration\u0026gt; \u0026lt;file\u0026gt;~/.backgrounds/pic/00001.jpg\u0026lt;/file\u0026gt; \u0026lt;/static\u0026gt; \u0026lt;transition type=\u0026#34;overlay\u0026#34;\u0026gt; \u0026lt;duration\u0026gt;847.0\u0026lt;/duration\u0026gt; \u0026lt;from\u0026gt;~/.backgrounds/pic/00001.jpg\u0026lt;/from\u0026gt; \u0026lt;to\u0026gt;~/.backgrounds/pic/00050.jpg\u0026lt;/to\u0026gt; \u0026lt;/transition\u0026gt; \u0026lt;static\u0026gt; \u0026lt;duration\u0026gt;4000.0\u0026lt;/duration\u0026gt; \u0026lt;file\u0026gt;~/.backgrounds/pic/00050.jpg\u0026lt;/file\u0026gt; \u0026lt;/static\u0026gt; \u0026lt;/background\u0026gt; static は特定の壁紙を表示する時間（秒）とファイルの位置を指定するよ。\ntransition はローテーション範囲と切り替え時間を指定するんだ。\n設定ファイルを作成する 例えば、~/.backgrounds/pic-timed.xmlっていうファイルを作成する。\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE wallpapers SYSTEM \u0026#34;gnome-wp-list.dtd\u0026#34;\u0026gt; \u0026lt;!-- /usr/share/gnome-background-properties --\u0026gt;\u0026lt;wallpapers\u0026gt; \u0026lt;wallpaper deleted=\u0026#34;false\u0026#34;\u0026gt; \u0026lt;name\u0026gt;Default Background\u0026lt;/name\u0026gt; \u0026lt;filename\u0026gt;~/.backgrounds/pic.xml\u0026lt;/filename\u0026gt; \u0026lt;options\u0026gt;zoom\u0026lt;/options\u0026gt; \u0026lt;shade_type\u0026gt;solid\u0026lt;/shade_type\u0026gt; \u0026lt;pcolor\u0026gt;#3465a4\u0026lt;/pcolor\u0026gt; \u0026lt;scolor\u0026gt;#000000\u0026lt;/scolor\u0026gt; \u0026lt;/wallpaper\u0026gt; \u0026lt;/wallpapers\u0026gt; その後、そのファイルを/usr/share/gnome-background-properties/にコピーするかリンクを作ると、設定 - 背景で見れるようになるよ。\nそれか、GNOMEを再起動してみるのもアリ（Alt+F2を押してrと入力する）。\n画像フォーマットの変換 ImageMagickをインストールしたら、このコマンドを使うんだ。\n1 convert before.jpg after.png ランダム壁紙変更 すごく便利で実用的だよ。毎回手動で実行しなきゃいけないってこと以外はね（でも、多分アプリとして作成して自動起動させられるんじゃないかな）。\nスクリプトファイルを作成する 1 vi ran_wallpaper.sh 以下の内容を入力するんだけど、関連パスの変更に注意してね。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #!/bin/bash wallpaper_path=\u0026#34;~/wallpaper\u0026#34; # 壁紙パス sleep_time=1 # 変更間隔（単位：秒） find $wallpaper_path -name \u0026#39;*.*\u0026#39; | cat \u0026gt; /tmp/list # 画像リストを取得 img_range_max=`cat /tmp/list | wc -l` # 画像の数を取得し、ランダム範囲を設定 while true do n=$((RANDOM%$img_range_max+1)) # 乱数を取得 img_path=`awk NR==$n /tmp/list` # その壁紙のフルパスを取得 gsettings set org.gnome.desktop.background picture-uri file://$img_path # 壁紙変更コマンド sleep $sleep_time done 実行 実行権限を与える。\n1 chmod +x ran_wallpaper.sh バックグラウンドで実行する。\n1 setsid ./ran_wallpaper.sh 警告 このスクリプトを初期化デーモンサービスに入れるのは絶対にやめてね！！！\n終了 プロセスを検索する。\n1 ps -ef |grep ran_wallpaper 1列目：ユーザー名、2列目：PID、3列目：親PID、最後の列：コマンド名またはパス。\nプロセスを終了する。\n1 sudo kill -9 PID デスクトップアイコン 個人的にはあんまり必要ないんだけどね。Windows使ってた時もデスクトップはほとんどスッキリしてたし。\nアイコン表示 使うプラグイン： Gtk4 Desktop Icons NG (DING) このプラグインはマルチディスプレイでのアイコン表示に対応してないんだけど、透明な背景がすごく気に入ってるんだ。\nもしマルチディスプレイ対応が必要なら、やっぱりこのプラグインかな： Desktop Icons NG (DING) プラグインを使わない場合はこれを参考にしてね： Remove desktop support (#158) · Issues · GNOME / Files · GitLab アイコンを作成する 新しい.desktopファイルを作成して、例えばこんな風に書き込むんだ。\n1 2 3 4 5 6 7 8 [Desktop Entry] Name=Grey Hack # 表示される名前 Comment=Play this game on Steam # マウスホバー時のヒント（あんまり意味ないみたいだけど） Exec=steam steam://rungameid/605230 # 実行ファイルのパス（Bashでの起動方法） Icon=steam_icon_605230 # アイコンのパス/定義 Terminal=false # ターミナルで実行するかどうか Type=Application # アプリケーションの種類 Categories=Game; # カテゴリ その他のプラグイン 左上の アクティビティ をアイコン化 Activities Icons 左上にタスクアイコンを表示 App Icons Taskbar 音量部分にアプリの音量を表示 Application Volume Mixer クリップボード履歴 Clipman 左上にファイルシステム Files Menu 左上にアプリリスト Frippery Applications Menu GNOME Shellをカスタマイズ Just Perfection 右上にプロキシ切り替え Proxy Switcher ドロップダウンアプリ quake-mode デスクトップを表示 Show Desktop Applet サウンド入力＆出力デバイス切り替え Sound Input \u0026amp; Output Device Chooser トレイアイコン（Tray Icons）を右上に Tray Icons: Reloaded 参考記事 Fedora 视频桌面 - 一个曾经的小码农\u0026hellip; Video Livestream Wallpaper For Your GNOME, Xfce Or bspwm Desktop - Linux Uprising Blog 常用的GNOME Shell 扩展 - pipci - 博客园 Linux 命令行处理图片（图片格式转换、缩放、旋转等）_打工人小飞的博客-CSDN博客 Linux切换壁纸,Linux 随机换壁纸_毛社长的博客-CSDN博客 在linux后台运行脚本命令和程序的方法大全_豆豆技术派的博客-CSDN博客 「GNOME 3」- 桌面图标（显示、Ubuntu 20.10、隐藏） - K4NZ BLOG Fedora:Gnome创建桌面图标，以Eclipse和IDEA为例 ","date":"2022-09-18T11:10:58+08:00","permalink":"https://blog.yexca.net/ja/archives/74/","title":"Fedora デスクトップいじり"},{"content":" 📢 この記事は ChatGPT によって翻訳されました はじめに 人間って、ある程度満足するともっと上を目指したくなるものだよね。NAS を組みたいと思いつつ、予算の都合で断念した結果、自宅 PC に Docker でアニメ・漫画・音声・入口ダッシュボードを構築してみた。\n前回の記事： 前回の記事を読む 完成図 すべて Docker でデプロイ。理論上、Docker が動く環境なら再現できるはず。\nドメインは link.start.icu に設定。本当は .icu 無しで済ませたかったけど、ブラウザでうまく解決できなかったから結局付けた（結果オーライかも？）\nスマホで開くと中央寄せ表示になるけど、若干不満あり（とはいえ使えないほどではない）\nそのうちサーバーにもデプロイしてナビページ化したいけど、タイトルの書き換えが JS 必須でちょっと面倒\n※Docker Desktop で起動してるため、今回は手順省略。デプロイ手順は 前回 を参照。\nDocker Hub ログイン Docker Hub から docker pull でイメージを取得するにはログインが必要な場合もある。\nまずは Docker Hub でアカウント作成。\n次に鍵を初期化：\n1 gpg --generate-key pub の下に出てきた文字列を pass init [pub] に入れて初期化：\n1 pass init [pub] その後、Docker Desktop にログイン。\nアニメ管理 - Jellyfin Docker Hub: jellyfin/jellyfin 公式サイト: Jellyfin 1 docker pull jellyfin/jellyfin カバー画像の管理が微妙だけど、NAS じゃないしそこまでこだわらないならこれで十分。\n参考： Jellyfin + Bangumi でアニメライブラリを快適に管理 漫画管理 - Komga Docker Hub: gotson/komga 公式サイト: Komga 1 docker pull gotson/komga ※注意：漫画が多すぎるとスキャン時に PC が重くなることあり。\n音声管理 - kikoeru-express Docker Hub: muveex/kikoeru-express GitHub: kikoeru-project/kikoeru-express 使用バージョンは v0.6.2（某サイトにそっくりかも？）\n1 docker pull muveex/kikoeru-express:v0.6.2 最初は PLEX を使おうと思ったけど、ログイン必須だし、UI は魅力的だけど ローカルファイルの読み込みに専用クライアントが必要で、権限が強すぎて怖かった（特にマウントフォルダを読めなかったのが致命的）。結局アンインストール。NAS 専用でいいや。\nホームダッシュボード - Heimdall Docker Hub: linuxserver/heimdall 公式サイト: Heimdall 1 docker pull linuxserver/heimdall 参考記事の中で「統一認証」の話が出てたけど、自分はそこまで必要ないのでスルー。 （というか設定がめちゃくちゃ複雑そうでやる気出なかった）\n最後に この経験を通じて思ったのは、NAS 専用 OS を買わなくても、PC パーツを組み合わせて Linux 入れてオープンソース使えば、わりとイイ感じの環境が作れるってこと。\nコマンド操作が苦手なら、Xfce や JWM みたいな軽量 GUI を入れるのもアリ。\n参考リンク Docker で NAS を自作する方法 - なんでもあり版 NAS で SSO（統一認証）を構築 Docker × PLEX で自宅メディアサーバー構築 Jellyfin + Bangumi アニメライブラリ構築ガイド ","date":"2022-09-16T15:00:01+08:00","permalink":"https://blog.yexca.net/ja/archives/73/","title":"個人ローカルネットワーク環境の構築"},{"content":" 📢この記事は gemini-2.5-flash-lite によって翻訳されました はじめに あるプラグインを有効にしたら、管理画面が 502 エラーになっちゃったんだ。\nデータベースにアクセス wp_options テーブルを選択して入るよ。\nactive_plugins っていう項目を探す。だいたい2ページ目あたりにあるはず。\nこの項目の option_value の行を編集するんだ。\n不要なプラグインを削除 注意：削除する前に必ずバックアップを取ってね！！！\nいらないプラグインの名前を探す。\ni から ; までを削除するんだ。例えば i:1;s:23:\u0026quot;elementor/elementor.php\u0026quot;; みたいな感じ。\n連番を書き換える。つまり i, の後の数字だね。\n合計数を書き換える。つまり一番最初の a: の後の数字だよ。\n参考記事 WordPress のデータベースから 1 つのプラグインを無効化する - WordPress - GoDaddy ヘルプ SG ","date":"2022-09-15T22:17:02+08:00","permalink":"https://blog.yexca.net/ja/archives/72/","title":"WordPress のデータベースからプラグインを無効化する"},{"content":" 📢 この記事は gemini-3-flash-preview によって翻訳されました はじめに ローカルネットワークでもっと快適に漫画を読むために、サーバーを立ててみることにしたよ。\nIPの設定 ルーターは OpenWRT システムを使っている場合の設定。\nルーターの設定 ネットワーク - IP/MAC バインド で、パソコンに固定IPを割り当てる。\nFedoraの設定 自動割り当てとは違うIPに設定したから（有線接続）、手動で修正する必要があるんだ。\nネットワーク - 設定 の ID に MACアドレス を追加して、IPv4 を 手動 に変更。アドレスは順に IP、255.255.255.255、ルーターのIP を入力して、DNS にも ルーターのIP を追加。自動取得のチェックは外さないでおいたよ。\nドメイン名の設定（DNSハイジャック） IPアドレスで直接アクセスもできるけど、ドメイン名があったほうが覚えやすいよね。\nルーターの ネットワーク - ホスト名 の ホスト名 に好きなドメイン名を入れて、IPアドレス にパソコンのIPを入力する。\nDockerのインストール 今回はGUIが使える Docker Desktop をインストールしたよ。\nリポジトリの設定 1 dnf -y install dnf-plugins-core 1 2 3 sudo dnf config-manager \\ --add-repo \\ https://download.docker.com/linux/fedora/docker-ce.repo RPMパッケージのダウンロード 公式サイトのダウンロードページ からダウンロード。\nダウンロードが終わったら、ダブルクリックしてそのままインストール。\nKomgaのインストール Dockerの設定 ファイル共有の設定 Docker Desktopの Settings - Resources - File sharing で、漫画が置いてあるパスを追加する。\n注：もし共有したディレクトリが次回の起動時に存在しない（マウントされていない）場合、dockerが正常に起動できなくなるから注意してね。\nネットワークの設定 必須かどうかはわからないけど、Settings - Resources - Network で自分のネットワーク帯域に合わせて設定したよ。\nコマンドラインからインストール シェルで直接これを実行する。\n1 2 3 4 5 6 7 8 docker run \\ --name=komga \\ --user 1000:1000 \\ -p 2333:8080 \\ -v /home/yexca/komga/config:/config \\ -v /home/yexca/komga/data:/data \\ --restart unless-stopped \\ gotson/komga:latest -p 前がホスト側のポート、後ろがコンテナ側のポート。\n-v ファイルマッピング。ホストのディレクトリ（/home/yexca/komga/config）をコンテナの（/config）に紐付ける。\n注：ホスト側の隠しファイル（. で始まるファイル）はマッピングできないみたい。\nGUIでインストール さっきのステップが終わると、Docker Desktopの Images に gotson/komga が追加されるから、run をクリックして設定する。\n1行目：名前\nPorts：ホストに割り当てるポート。例えば 80 にすれば、ドメイン名だけでアクセスできるようになるよ。\nVolumes：パスのマッピング。\nEnvironment variables：環境変数。今回は使わない。\n動作確認 コマンドで確認してみる。\n1 docker ps -a ファイアウォールの設定 ポートを開放する。\n1 firewall-cmd --zone=public --add-port=80/tcp 設定を反映させる。\n1 firewall-cmd --reload ポートが開いているか確認。\n1 firewall-cmd --zone=public --query-port=80/tcp 必要ならサービスも追加しておく。\n1 firewall-cmd --add-service=http どうしてもコマンドでうまくいかないときは、GUIを使おう（最初から使えばよかったかもｗ）。\n1 sudo yum install firewall-config 参考記事 Install Docker Desktop on Fedora - Docker Documentation 【Docker】Error response from daemon: invalid mount config for type \u0026ldquo;bind\u0026rdquo;: bind source path does not exist - Qiita Run with Docker - Komga 简约但绝不简单的Komga-老苏的blog fedora 28 , firewalld 防火墙控制，firewall-cmd 管理防火墙规则 - xuyaowen - 博客园 Fedora防火墙配置 - 上官飞鸿 - 博客园 原神自动签到(Linux服务器Docker) - yexca\u0026rsquo;Blog Fedora 打开8080端口_chunqi zhi的博客-CSDN博客 ","date":"2022-09-14T18:47:16+08:00","permalink":"https://blog.yexca.net/ja/archives/71/","title":"FedoraにKomgaをインストールしてみた記録"},{"content":" 📢 この記事は gemini-3-flash-preview によって翻訳されました はじめに 毎回サーバーに接続するたびにパスワードを打つのって、正直かなり面倒だよね (忘れちゃったからなんだけど\nワンクリックで設定 もし自分のPCに公開鍵がないなら、まずは生成する必要があるよ。大体 ~/.ssh/id_rsa.pub にあるはず。\n1 ssh-keygen そしたら、自分のPCで次のコマンドを実行してみて。\n1 ssh-copy-id username@RemoteIP username はログインしたいアカウントに、RemoteIP はログイン先のIPアドレスに置き換えてね。\nパスワードの入力を求められるから、入力して待つ。\nあとは直接 SSH 接続するだけでログインできちゃうよ。\n1 ssh username@RemoteIP めっちゃ便利！\nファイルに書き込む 他の人の公開鍵を追加したい時や、パスワードを忘れちゃった時はこの方法が使えるかも。\n設定ファイル（あらかじめファイル権限を変える必要があるかも）の ~/.ssh/authorized_keys を編集して公開鍵を追記するんだ。1行に1つずつね。書き終わったら保存すればOK。（もしファイル権限を変えたなら、600に戻すのを忘れずに）\n実はこれだけでもうパスワードなしでログインできるようになってるんだけど、一応設定ファイルを確認しておくと安心かも。\n/etc/ssh/sshd_config を編集しよう。\n1 2 3 PasswordAuthentication yes　# パスワード認証 RSAAuthentication yes　# RSA認証 PubkeyAuthentication yes　# 公開鍵認証 もし公開鍵とパスワード認証の両方を必須にしたい場合は、\n上述の設定ファイルをこう書き換える。\n1 AuthenticationMethods publickey,password 最後に SSHD サービスを再起動してね。\n1 sudo service sshd restart 参考記事 SSH 公钥登录 - starnight_cyber - 博客园 ","date":"2022-09-12T19:24:25+08:00","permalink":"https://blog.yexca.net/ja/archives/70/","title":"SSH 公開鍵ログイン"},{"content":" 📢 この記事は gemini-3-flash-preview によって翻訳されました 第3章 shellを使う この章で紹介する Linux shell は Bash shell と呼ばれるもので、正式名称は Bourne Again shell だよ。他にも、BSD UNIX ユーザーに人気の C shell (csh) や、UNIX System V ユーザーに普及している Korn shell (ksh) 、Ubuntu でデフォルトで起動する Dash shell (Bash より高速) 、改良版 C shell の Tcsh shell 、Bourne shell によく似た Ash shell などがあるんだ。\n3.1 shell と Terminal ウィンドウ Terminal ウィンドウを使う GUI 上でターミナルエミュレータ (Terminal ウィンドウとも呼ばれる) を実行することで、shell を起動できるよ。\nだいたいのシステムは Ctrl+Shift+T のショートカットで開けるし、Fedora ならプログラム一覧から探すか、Alt+F2 を押した後に gnome-terminal と入力すればOK。\n仮想コンソールを使う GUI を備えた Linux システムの多くは、起動時に複数の仮想コンソールを動かしている。仮想コンソールを使えば、GUI 以外にも複数の shell セッションを開けるんだ。\nCtrl+Shift+F1〜F6 で仮想コンソールを切り替えられるよ。例えば Fedora だと、tty1 が gdm (ログイン画面) 、tty2 が最初のデスクトップ、tty3 が2番目のデスクトップ (テキストのみ) って感じになっている。\nコマンドプロンプト 一般ユーザーの場合、デフォルトのプロンプトはシンプルなドル記号だよ。\n$\nroot ユーザー (管理者) の場合は、シャープ記号 (ナンバーサインやハッシュタグとも呼ばれる) になるんだ。\n#\nアメリカのルーツがイギリスにあることを絶妙に表してるね（笑）\n3.2 shell を選ぶ who コマンドを使えば、今ログインしているユーザー名、仮想コンソール、ログイン時間が表示されるよ。\ngrep ユーザー名 /etc/passwd コマンドを叩くと、出力の最後にデフォルトで使っている shell が表示される。\nksh、tcsh、csh、sh、dash などのコマンドを入力すれば、別の shell に切り替えることもできるよ (インストールされていればの話だけど) 。\nBash shell を学ぶのは、それが多くのディストリビューションでデフォルトなだけじゃなく、ほとんどの Linux 認定試験で使われるからなんだ。\n3.3 コマンドを実行する コマンド名を入力するだけで動くものも多いけど、コマンドの後に何かを付け足して挙動を変えるのが一般的だよ。後ろに続く文字や単語は「オプション」や「引数」と呼ばれるんだ。\n3.3.1 コマンドの構文を知る ほとんどのコマンドには、動作を変えるためのオプションが1つ以上ある。 だいたいのオプションは1つのアルファベットで、前にハイフン - を付ける。複数のオプションを一度に使うときは、まとめて書くこともできるし、1つずつハイフンを付けてもいいよ。\n単語形式のオプションもあって、その場合はダブルハイフン -- を使うのが一般的。例えば --help と入力するところを -help としちゃうと、-h 、-e 、-l 、-p という4つのオプションとして解釈されちゃうことがあるんだ。\nまた、オプションの後やコマンドラインの最後に「引数」を渡すこともできる。 引数は、ファイル名、ディレクトリ、ユーザー名、デバイスなどの追加情報のこと。コマンドラインが許容する長さなら、いくつでも引数を指定できるよ。\n引数が特定のオプションと結びついている場合は、そのオプションの直後に置く必要がある。1文字オプションならスペースを空けて、単語オプションならイコール = で繋ぐことが多いかな。\n例えば：\n1 tar -cvf backup.tar /home/yexca これは、「/home/yexca ディレクトリの全ファイルを backup.tar というファイル名で作成 (c) し (f) 、作成が終わったら詳細を表示 (v) する」という意味。backup.tar は f オプションの引数だから、f の直後に書く必要があるんだ。\n1 ls --hide=Desktop --hide オプションは ls コマンドに「Desktop という名前のファイルやディレクトリを表示しない」ように伝えるもの。オプションと引数の間にスペースがないことに注目してね。\n他にもこんなコマンドを試してみよう。 uname コマンドは実行中のシステムタイプを表示する。-a オプションを付けるとホスト名やカーネルバージョンも見られるよ。\nLinux にログインすると、システムは君のユーザー名、グループ名、ユーザーID、グループID などの「識別情報」を認識する。さらに、ログイン時間やアイドル時間、どこからログインしたかも追跡しているよ。id コマンドで自分の情報を確認してみよう。\nSELinux (Security Enhanced Linux) が有効なディストリビューションだと、id の出力の最後に context などの追加情報が表示されるよ。SELinux はセキュリティをガチガチに固めるための仕組みなんだ。\nwho -uH を使うと、アイドル時間やプロセスID (u) 、見出し (H) も表示できる。\nアイドル (IDLE) は、何も入力せずに shell を放置している時間。プロセス番号 (PID) は shell のプロセスID。備考 (COMMENT) は、リモートからログインしているならそのコンピュータ名、ローカルならディスプレイ名 (*:0.0 など) が表示されるよ。\n3.3.2 コマンドを探す仕組み 入力されたコマンドを実行するために、shell は「パス (PATH) 」と呼ばれる場所を探しに行く。パスに含まれていないコマンドを動かすには、フルパスで場所を指定してあげないといけない。\necho $PATH で、今の shell の環境変数 PATH を確認できるよ。\n参考： Linuxのbinディレクトリについて - yexca\u0026rsquo;Blog 他のOSと違って、Linux はデフォルトではカレントディレクトリ (今いる場所) を探しに行かないんだ。すぐに PATH を検索し始める。カレントディレクトリにあるファイルを実行したいなら、PATH に追加するか、相対パスや絶対パスで指定する必要があるよ。\nすべてのコマンドが PATH 内のディレクトリにあるわけじゃない。shell に組み込まれているものもあるし、エイリアス (別名) で上書きされていることもある。shell がコマンドを探す順番はこんな感じ：\nエイリアス (Alias)：alias コマンドで設定された別名。 shell 予約語：shell が特別な用途で予約している単語。 関数：今の shell 内でまとめて実行されるコマンド群。 組み込みコマンド (Built-in)：cd、echo、exit、pwd、history、fg、set、type など、ファイルシステム上には存在しない shell 内部のコマンド。 ファイルシステムコマンド：PATH 変数で指定されたディレクトリに保存されている実行ファイル。 コマンドがどこから来ているか知るには、type や which を使う。type -a を使えば、そのコマンドの候補を全部出してくれるよ。\nもしコマンドが PATH 内に見つからないときは、locate コマンドで探してみるのも手だね。システム全体からファイルを探してくれるよ。\n最近追加したばかりのファイルが見つからないときは、root ユーザーで updatedb を実行してデータベースを更新してみて。\n3.4 使用命令历史记录重复执行命令 長くて複雑な、打ち間違えそうなコマンドを何度も打つのは面倒だよね。履歴を使えば楽ができるよ。\n3.4.1 コマンドライン編集 デフォルトでは、Bash shell は Emacs ベースのエディタ操作が使えるようになっている。vi のほうが好きなら、ホームディレクトリの .bashrc に set -o vi を書き込めばいいよ。\nコマンドライン移動のショートカット キー 名称 意味 Ctrl+F 1文字進む カーソルを右に移動 Ctrl+B 1文字戻る カーソルを左に移動 Alt+F 1単語進む カーソルを次の単語へ移動 Alt+B 1単語戻る カーソルを前の単語へ移動 Ctrl+A 行頭へ コマンドラインの先頭に移動 Ctrl+E 行末へ コマンドラインの末尾に移動 Ctrl+L 画面クリア 画面を綺麗にして、カーソルを一番上へ コマンドライン編集のショートカット キー 名称 意味 Ctrl+D 1文字削除 カーソル位置の文字を消す Backspace 前の文字を削除 カーソルの前の文字を消す Ctrl+T 文字を入れ替え カーソル位置と前の文字を入れ替える Alt+T 単語を入れ替え カーソル位置と前の単語を入れ替える Alt+U 大文字化 単語を大文字にする Alt+L 小文字化 単語を小文字にする Alt+C 先頭大文字化 単語の最初の文字だけ大文字にする Ctrl+V 特殊文字挿入 Tab などの特殊な文字をそのまま入力する コピー＆ペースト (カット＆ヤンク) キー 名称 意味 Ctrl+K 行末までカット カーソルから後ろを全部消す Ctrl+U 行頭までカット カーソルから前を全部消す Ctrl+W 前の単語をカット カーソルの前の1単語を消す Alt+D 後の単語をカット カーソルの後の1単語を消す Ctrl+Y ペースト 最後にカットしたテキストを貼る Alt+Y 過去分をペースト さらに前にカットしたものを貼る Ctrl+C 行削除 今打っている内容を全部捨てる 3.4.2 コマンドライン補完 キー入力を減らすために、Bash は「補完」機能を持っているよ。文字を数個打ってから Tab キーを押すだけ。補完できるのはこんなもの：\nコマンド、エイリアス、関数：普通の文字で始まるとき。 変数：ドル記号 $ で始まるとき。 ユーザー名：チルダ ~ で始まるとき。~username はそのユーザーのホームディレクトリを指すよ。 ホスト名：アットマーク @ で始まるとき。/etc/hosts から補完される。 他のファイルからホスト名を補完したいときは、HOSTFILE 変数にそのファイルパスを設定すればいいよ。\n候補が複数あるときは、Tab を2回叩けばリストが表示されるんだ。\n3.4.3 コマンドの再実行 実行したコマンドは shell の履歴リストに保存されるよ。\nhistory コマンドで一覧が見られるし、数字を付ければ直近の数件だけ表示できる。\n感嘆符 ! を使うと、履歴からコマンドを直接実行できるけど、確認なしで動いちゃうから注意してね。\n!n \u0026mdash; 番号指定で実行。例えば !255 なら255番目のコマンドが動く。 !! \u0026mdash; 1つ前のコマンドを実行。 !?string? \u0026mdash; 指定した文字列を含む直近のコマンドを実行。 履歴をただ実行するだけじゃなくて、編集してから動かすこともできるよ。\nキー 機能 説明 矢印キー またはCtrl+P / Ctrl+N 履歴を辿る 上下キーで過去のコマンドを1つずつ呼び出せる。 Ctrl+R インクリメンタル検索 過去のコマンドを文字入力で検索できる。入力するそばからヒットするよ。 Ctrl+S 前方検索 Ctrl+R の逆。あんまり使わないし、設定によっては効かないこともある。 Alt+P 非同期検索 検索文字列を入れて Enter を押すと、そのコマンドが表示される。 Alt+N 前方非同期検索 上記の逆バージョン。 fc コマンドを使う方法もある。fc 233 255 みたいに番号を指定すると、テキストエディタ (デフォルトは vi) でその範囲のコマンドが開く。エディタを閉じると、それらが順番に実行されるよ。\nshell を閉じるとき、履歴はホームディレクトリの .bash_history に保存される。デフォルトは1000件まで。\n履歴を残したくないときは、普通にログアウトせずに kill -9 PID で shell を強制終了させると、保存をスキップできる裏技があるよ。\nHISTFILE=/dev/null にしたり HISTSIZE を空にしても、正常終了すると保存されちゃうことがあるから、強制終了が確実だね。\n3.5 コマンドの連結と拡張 shell の本当の強さは、コマンドの入出力を他のコマンドやファイルに繋げられることにあるんだ。\nコマンドを繋ぐには「メタ文字 (metacharacter) 」を使う。これは shell にとって特別な意味を持つ記号のこと。\nよく使うメタ文字：パイプ | 、アンパサンド \u0026amp; 、セミコロン ; 、括弧 () 、不等号 \u0026lt; \u0026gt; など。\n3.5.1 コマンド間のパイプ パイプ | は、前のコマンドの出力を次のコマンドの入力に渡すよ。\n1 cat /etc/passwd | sort | less これは passwd ファイルの中身を出し、それを並び替えて (sort) 、最後にスクロール表示 (less) する、という流れ。\n3.5.2 連続実行 セミコロン ; を使えば、1行で複数のコマンドを順番に実行できるよ。\n1 date ; troff -me VertLargeDocument | lpr ; date 大きな文書を処理する前後に date を置いて、どれくらい時間がかかったか測る、なんて使い方ができるね。\n3.5.3 バックグラウンド実行 時間がかかる処理は、後ろに \u0026amp; を付けてバックグラウンドで動かそう。\n1 troff -me VertLargeDocument | lpr \u0026amp; 処理が終わる前に shell を閉じたりプロセスを殺したりすると、途中で止まっちゃうから気をつけて。\n3.5.4 コマンド置換 あるコマンドの実行結果を、別のコマンドの引数として使うことができるんだ。\n形式は $(command) または `command` (バッククォート) 。\n1 vi $(find /home | grep xyzzy) これは、まず /home から xyzzy という名前を含むファイルを全部探し出して、その結果を vi コマンドに渡して開く、という動作になる。\n注意：ルートディレクトリ / から grep したりすると、数千個のファイルを一気に開こうとして大変なことになるから気をつけてね。\n3.5.5 算術式の拡張 計算結果をコマンドに渡したいときは、$[expression] や $((expression)) を使うよ。\n1 echo \u0026#34;I am $[2022-1957] years old\u0026#34; 出力は I am 65 years old になる。\n1 echo \u0026#34;There are $(ls | wc -w) files in this directory\u0026#34; 今のディレクトリのファイル数を数えて、それをメッセージに組み込んで表示する例だね。\n3.5.6 変数の拡張 ドル記号 $ を使って変数の値を呼び出す。\n1 ls -l $BASH これは bash コマンドの実行ファイルの詳細情報を表示するよ。\n3.6 shell 変数を使う shell は変数を使って、ユーザーのセッションに役立つ情報を保存しているんだ。set コマンドを使えば、今設定されているすべての変数が見られるよ。\nその中でも、別の shell にも引き継がれる変数を「環境変数」と呼ぶ。これは env コマンドで確認できる。\n変数の値を参照するときは、頭に $ を付けるのを忘れずに。\nshell 起動時に自動で設定される主な変数をまとめてみたよ。\n変数 説明 BASH Bash コマンドのフルパス。だいたいは /bin/bash BASH_VERSION Bash のバージョン番号 EUID 現在のユーザーの有効なユーザーID FCEDIT fc コマンドで使うエディタ。デフォルトは vi HISTFILE 履歴ファイルの場所。通常は $HOME/.bash_history HISTFILESIZE 保存する履歴の最大件数。デフォルトは 1000 HISTCMD 履歴リストの中での今のコマンド番号 HOME ホームディレクトリ HOSTTYPE システムのアーキテクチャ (x86_64 など) MAIL メールボックスの場所 OLDPWD 1つ前にいたディレクトリ OSTYPE オペレーティングシステムの種類 (Linux など) PATH コマンドを探すディレクトリのリスト (コロン : 区切り) PPID 親プロセスのID PROMPT_COMMAND プロンプトを表示する直前に実行されるコマンド PS1 メインのプロンプトのデザイン PWD 今いるディレクトリ (カレントディレクトリ) RANDOM 0〜32767 の乱数を生成する SECONDS shell を起動してからの経過秒数 SHLVL shell の深さレベル。su や bash を叩くたびに増える TMOUT 無操作時に自動ログアウトするまでの秒数 3.6.1 エイリアスの作成と利用 alias コマンドを使えば、長いコマンドに短いニックネームを付けられるよ。\n1 alias p=\u0026#39;pwd ; ls -CF\u0026#39; これで p と打つだけで、今の場所を表示してからファイル一覧をカラム表示してくれるようになる。\n消したいときは unalias を使えばOK。\n3.6.2 shell を終了する exit と打つか、Ctrl+D を押せば終了できるよ。\n3.7 自分好みの shell 環境を作る 設定をいじって、もっと効率よく作業できるようにしよう。\n3.7.1 shell を設定する Bash の挙動はいくつかの設定ファイルで決まっているんだ。\nファイル 説明 /etc/profile 全ユーザー共通の設定。ログイン時に一度だけ読み込まれる。パスの設定などもここ。 /etc/bashrc Bash を開くたびに読み込まれる全ユーザー共通設定。プロンプトやエイリアスのデフォルトなど。 ~/.bash_profile ユーザー個別のログイン時設定。環境変数を追加するならここがおすすめ。 ~/.bashrc ユーザー個別の Bash 起動時設定。エイリアスを書くのに最適。 ~/.bash_logout ログアウト時に実行される。デフォルトでは画面を消去したりする。 /etc/ 以下のファイルをいじるには root 権限が必要だよ。システム全体の設定を変えたいときは、元のファイルを直接いじるより /etc/profile.d/custom.sh みたいなファイルを作って追加するのがお作法。\nnano エディタ 初心者にも使いやすいエディタだよ。Ctrl+O で保存、Ctrl+X で終了。\n3.7.2 プロンプトの設定 プロンプト (入力待ちの記号) は PS1 という変数でカスタマイズできる。\n特殊文字 説明 \\! 履歴番号を表示 \\# 今のセッションでのコマンド番号 \\$ 一般ユーザーなら $ 、root なら # を表示 \\W 今いるディレクトリ名だけを表示 \\[ 表示されない文字の開始 (色付けとかに使う) \\] 表示されない文字の終了 \\\\ バックスラッシュを表示 \\d 日付を表示 \\h ホスト名を表示 \\n 改行 \\s shell の名前を表示 \\t 現在時刻 (HH:MM:SS) \\u ユーザー名を表示 \\w 今いる場所のフルパスを表示 一時的に変えるだけなら export PS1=\u0026quot;[\\t\\w]\\$\u0026quot; みたいに打てばいいし、ずっとその設定にしたいなら ~/.bashrc に書き込もう。\n詳しく知りたいなら： Bash Prompt HOWTO 3.7.3 環境変数を追加する よく .bashrc に追加される設定例を紹介するね。\nTMOUT \u0026mdash; 自動タイムアウトの設定。\nPATH \u0026mdash; コマンドを探す場所の追加。例えば ~/bin を追加したいなら：\nPATH=$PATH:~/bin ; export PATH\n今のパス ($PATH) の後ろに ~/bin をくっつけて、それを新しい PATH としてエクスポートしているよ。\nセキュリティのリスクがあるから、カレントディレクトリを表す . を PATH に入れるのはやめておこうね。\n独自変数 \u0026mdash; 自分の作業用ショートカットも作れる。\nMYWORKDIR=/home/yexca/work ; export MYWORKDIR\nこうしておけば、cd $MYWORKDIR で一発で作業ディレクトリに飛べるよ。\n3.8 コマンドの情報を調べる shell に組み込まれたコマンドなら、help コマンドが使える。help | less で一覧を見たり、help cd みたいに特定のコマンドの使い方を見たりできるよ。\n多くのコマンドは --help や -h オプションを付けて叩くと、簡単なヘルプを出してくれる。\nもっと詳しく知りたいなら info や man コマンドを使おう。\n「マニュアルページ (man page) 」は、Linux で一番よく使われる調べ方だよ。\nman には 8 つのセクション (章) があるんだ。\n章番号 章の名前 説明 1 ユーザーコマンド 一般ユーザーが実行できるコマンド 2 システムコール プログラムからカーネルを呼び出す関数 3 C ライブラリ関数 プログラミング用のライブラリ関数 4 デバイスと特殊ファイル デバイス関連のファイルなど 5 ファイル形式と慣習 設定ファイルの書き方とか 6 ゲーム システムに入っているゲーム 7 その他 プロトコルやファイルシステムの概説 8 システム管理ツール root 権限が必要な管理用コマンド man -k キーワード で、マニュアルのデータベースを検索できるよ。もし検索に失敗するなら、root で mandb を実行してデータベースを作ってね。\n特定のセクションを見たいときは、man 5 passwd みたいに番号を指定するんだ。\n操作は Page Down / Page Up でページめくり、Enter や矢印キーで1行移動。/ を押してから文字を打つと検索できて、n で次を検索、N で前を検索できるよ。終わるときは q を押せばいいよ。\n","date":"2022-09-12T15:04:10+08:00","permalink":"https://blog.yexca.net/ja/archives/69/","title":"Linux学習 第3章 shellを使う"},{"content":" 📢 この記事は gemini-3-flash-preview によって翻訳されました はじめに Windowsのコマンドライン版があるなら、Linux版がないわけないよね。\nWindows版の記事はこちら： コマンドラインでYouTube動画をダウンロードする yt-dlpをダウンロードする Python環境を整えてから、 Releases · yt-dlp/yt-dlp · GitHub で yt-dlp をダウンロードするのがおすすめ。Pythonの設定が面倒なら yt-dlp_linux をダウンロードすればOK。\nダウンロードが終わったら、実行権限を与えて /usr/local/bin/ に置いておこう。\nffmpegをダウンロードする 公式サイトの Download FFmpeg を参考にしてね。\nFedoraなら以下のコマンドを使うよ。\n1 sudo dnf install ffmpeg 設定ファイル 設定ディレクトリに移動する。\n1 cd ~/.config フォルダを作って中に入る。\n1 2 mkdir yt-dlp cd yt-dlp 設定ファイルを作成。\n1 vi config 僕の設定はこんな感じ。\n1 -f bv+ba/b -o ~/Videos/%(uploader)s/%(upload_date)s%(title)s%(id)s.%(ext)s --continue --merge-output-format mp4 ちょっと解説するね。\n1 2 3 4 5 6 7 8 9 10 11 12 -f bv+ba/b # 最高画質と最高音質をターゲットに -o # 出力フォルダの設定 /%(uploader)s/ # チャンネル名ごとにフォルダを作成 %(upload_date)s # アップロード日 %(title)s # 動画タイトル %(id)s # 動画ID .%(ext)s # 拡張子 --continue # レジューム（中断したところから再開） --merge-output-format mp4 # mp4形式にマージする 参考記事 ffmpegで動画形式を一括変換する というか、自分の記事をわざわざリンクする意味あるのかな（笑）\n","date":"2022-09-10T19:29:58+08:00","permalink":"https://blog.yexca.net/ja/archives/68/","title":"LinuxでYouTube動画をダウンロードする方法"},{"content":" 📢 この記事は Gemini-3-flash によって翻訳されました はじめに この「黒塗り（黒幕）」、すごく面白いんだよね。本当に面白いんだけど、残念ながらトップページでは反映されないし、Markdownで書くのもちょっと手間がかかるんだ。\n使い方 記事を書くときに「HTMLとして編集」を選んで、次のコードを挿入してね。\n1 \u0026lt;span class=\u0026#34;heimu\u0026#34; title=\u0026#34;黒塗りの上にマウスを置いた時に出る文字\u0026#34;\u0026gt;隠したい文字\u0026lt;/span\u0026gt; CSSの挿入 本当はトップページでも黒塗りが表示されるようにしたかったんだけど、実際にテストしてみたらトップページでは反映されなかったんだ…… (なんで反映されないのぉぉぉぉぉ！！！！！！！ Warmaの声を想像してみて)\n管理画面の設定から「フッター」設定を見つけて、以下のコードを入力するか、WordPressのカスタムCSSに挿入してね。ただし、カスタムCSSの場合は \u0026lt;style\u0026gt; タグを外す必要があるよ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 \u0026lt;style\u0026gt; .heimu, .heimu a, a .heimu, .heimu a.new { background-color: #252525; color: #252525; text-shadow: none; } .heimu:hover, .heimu:active, .heimu:hover .heimu, .heimu:active .heimu { color: white !important; } .heimu:hover a, a:hover .heimu, .heimu:active a, a:active .heimu { color: lightblue !important; } .heimu:hover .new, .heimu .new:hover, .new:hover .heimu, .heimu:active .new, .heimu .new:active, .new:active .heimu { color: #BA0000 !important; } \u0026lt;/style\u0026gt; 注：Argonテーマではコメントがレンダリングされないから、以下の内容はコードの中には入れてないよ：\n/*詳細：https://zh.moegirl.org/MediaWiki:Mobile.css 本文は萌娘百科(https://zh.moegirl.org)より引用。テキスト内容はクリエイティブ・コモンズ 表示 - 非営利 - 継承 3.0 非移植 (CC BY-NC-SA 3.0) ライセンスに基づきます。*/\n参考記事 Re：萌娘百科上的黑幕实现 – Vanilla_chan – 博客园 萌百黑幕CSS代码-Hiyoung’blog ","date":"2022-09-05T21:51:23+08:00","permalink":"https://blog.yexca.net/ja/archives/67/","title":"ArgonテーマのWordPressで萌娘百科（MoeGirlPedia）風の「黒塗り」を実装する"},{"content":" 📢 この記事は gemini-2.5-flash-lite によって翻訳されました はじめに OpenWRTルーターを使って学校のネットワークに接続しようとした奮闘の記録だよ。結果はまあ、なんとも言えないけど、この過程で色々勉強になったな。\nスタート ブラウザで openwrt通过深澜认证 って検索して、 恩山無線フォーラム の投稿で紹介されていたオープンソースプロジェクトを見つけたんだ。 coffeehat/BIT-srun-login-script っていうプロジェクト。それを見て、複数のプラットフォーム（OpenWRTも含む）に対応したGo言語版があるって知って、早速いじってみることにしたんだ。\nプロジェクト作者の記事はこちら： 深澜校园网登录的分析与python实现-北京理工大学版 奮闘前 OpenWRTのバージョンでコンパイル済みのバージョン、つまりIPKファイルが提供されてなかったんだ。それに、僕のスキルじゃREADMEが読めなくて、友達に聞いてみたらLinuxのコマンドだってことだった。でも、実際にやってみたら、それはLinuxカーネルをコンパイルするコマンドだってことがわかって、物理マシンでやるのは諦めて仮想マシンでやることにしたんだ。\n参考： Building a custom kernel/zh-cn - Fedora Project Wiki 奮闘開始 友達にこれもらったんだけど、 configuration - How to fix make error \u0026ldquo;No rule to make target \u0026lsquo;menuconfig\u0026rsquo;\u0026rdquo; when building a kernel for Beagleboard? - Unix \u0026amp; Linux Stack Exchange っていう記事。これを参考に試してみたんだ。\n仮想マシンの作成 僕が使ってるFedoraには、仮想マシンソフト 盒子 が標準で入ってる。まずはCentOS 8をインストールしようとしたんだ。イメージファイルが外付けHDDに入ってたから、直接マウントして選択。そしたら、作成失敗ってエラーが出た。次にCentOS 7を試したけど、失敗。Ubuntuも失敗。\n次々と失敗して、前にこのソフトでWin10をインストールできたから、ソフト自体がおかしいんじゃないかって疑っちゃったよ。エラーログを開いてみたけど、やっぱり意味不明。でも、パスに日本語が含まれてることに気づいたから、パスを英語に変えてもう一度試してみた。失敗。\nで、次の日、カーネルを編集するんだから、Kaliを使ってみようかなって思ったんだ。USBメモリに入ってたKaliのイメージをPCにコピーして、最終的にインストールは失敗したけど、実行はできたんだ。もしかして、システムをローカルに置かないとダメなのかな？\nだから、CentOS 7のイメージを ~/Documents/ にコピーして、インストール成功。IPKをコンパイルするだけだから、rootユーザーで十分だと思ったんだ。\nネットワーク接続 LinuxでLinux仮想マシンを作ったら、ネットワークは直接共有できると思ってたんだ。だから、直接 wget https://cdn.kernel.org/pub/linux/kernel/v5.x/linux-5.19.6.tar.xz ってコマンドを入力した。そしたら、IPアドレスが見つからないって結果に。ifconfigコマンドを使ってもIPがない。\n参考記事 在虚拟机中设置静态IP (centos为例) を参考に仮想マシンをネットワークに接続したんだ。でも、最後にファイルを編集する時は、ONBOOT の値を yes に変えて、DNSを2つ追加すればOKだった。\ngitのインストール ネットに繋がったら、まずgitをインストールしたんだ。yum install git で簡単にできた。それから、名前とメールアドレスを設定した。\n1 git config --global user.name \u0026#34;Name\u0026#34; 1 git config --global user.email \u0026#34;email@example.com\u0026#34; ファイル転送 引き続き wget でLinuxカーネルをダウンロード。3〜4回試したけど、ほとんど50%くらいでダウンロード失敗するし、速度も遅かった。\n注：wget -c URL を使うと、中断したところから再開できるよ。\n次に、盒子 というソフトが直接ドラッグ＆ドロップでファイルを転送できるみたいだったから、PCでダウンロードしたファイルをそのままドラッグしてみた。失敗。ファイルは転送されなかった。転送後のファイルが ~/Downloads/ にあることを考えて、rootユーザーを使ってるから、 Linux 添加用户和管理员用户 を参考にしてユーザーを作成したんだ。（最後にユーザーを削除する手順まで実行しそうになったよ）\nsu username コマンドでユーザーを切り替えて、~/Downloads/ フォルダを作成。もう一度ドラッグしてみたけど、また失敗。\n盒子 の共有機能でPCの ~/Public を共有しようとしたんだけど、どう操作しても仮想マシンで見えなかった。（このソフトはRHELとFedoraにしか対応してないのかな？）\nSSH転送 それで、SSHで転送することを思いついたんだ。（ftpコマンドを入力したら、入ってなかったから、インストールするのが面倒くさくて）\nローカルでSSH接続を有効にして、scp コマンドでSSHを使ってファイルを転送した。\n1 scp username@servername:/path/filename ~/Downloads/ まず、IPアドレスを確認。仮想マシンで ip route コマンドを入力すると、IPは10.0.2.2だとわかった。\nそれから scp コマンドで転送。\nファイル解凍 tar コマンドでファイルを解凍した。\n1 tar -xzvf filename.tar.xz あれ、gzipで圧縮されてないファイルだ。これ、どうやって解凍すればいいかわからないな。\nSSH転送 やっぱりSSHで転送しよう。scp コマンドに -r を追加すればフォルダも転送できるはず。\n試行錯誤 手順通りに、解凍したファイルを /usr/src/ に置いて、/boot のconfigファイルを /usr/src/linux-5.19.6/.config に置いた。でも、.config/ の下に置いても、.config の下に置いても、make menuconfig コマンドが実行できなかった。\nまとめ 奮闘は失敗。また今度挑戦しよう。\nでも、この記事を書きながら、元の投稿でOpenWRTで直接Pythonを実行しようとしてたことに気づいたんだ。時間があったら試してみようかな。\n再挑戦 それから、認証を突破したことがある友達（普通のルーターだけど）に相談してみたんだ。彼はルーターのMACアドレスを自分のPCのものに変えたらしい。そしたら、LANケーブルを繋いだら認証ページが自動的にPCに転送されて、認証後につながるようになったんだ。でも、锐捷（Ruijie）のウェブ認証だった。\n深澜（Senao）はPortal認証、つまりWebページ認証を使ってるってことは、WebだからHTTPを使ってるはずだよね。HTTPヘッダーを編集すれば認証を突破できるのかな？LinuxにはHTTPヘッダーを送信できるコマンドってあるんだろうか？調べてみたら、curl と wget コマンドで get や post リクエストをシミュレートできるってわかった。（それでFiddlerを開いてパケットキャプチャを始めて、認証プロセスを再現しようとしたんだ）\n嘘だよ。ルーターを学校のネットワークに繋いで、PCをルーターに繋いで、認証ページのIPを入力したら、認証完了。ルーターにつながったよ。\nLinuxコマンドでHttpのgetやpostリクエストをシミュレートする 使わなかったけど、せっかく見つけたから記録しておくね。\nGET リクエスト curl 1 2 3 4 5 6 7 8 ## もしここのURLがファイルを示していたら、直接ローカルにダウンロードできるよ curl URL ## 全ての情報を表示 curl -i URL ## ヘッダー情報だけ表示 curl -l URL ## GETリクエストの全過程の解析を表示 curl -v URL wget 1 wget URL POST リクエスト curl 1 2 3 4 5 6 ## -d パラメータを使って、アクセスするパラメータを中に記述するよ curl -d \u0026#34;param1=value1\u0026amp;param2=value2\u0026#34; \u0026#34;URL\u0026#34; curl -d\u0026#39;param1=value1\u0026amp;param2=value2\u0026#39; -X POST URL curl -d \u0026#39;param1=value1\u0026#39; -d \u0026#39;param2=value2\u0026#39; -X POST URL wget 1 2 ## --post-data パラメータで実現できるよ wget --post-data \u0026#39;user=name\u0026amp;passwd=passwd\u0026#39; URL 再度まとめ 時々、物事を複雑に考えすぎちゃいけないんだね。単純なことなのに、考えただけで実行せずに可能性を否定してしまうのは間違いだった。今回は、僕が最初に最後の再挑戦の部分を否定してしまったから、こんなに手間取ってしまったんだ。（もしデータ通信量が制限されてなかったら、こんなに試さないよ）\nこの記事を書きながら、二つの名言を思い出したよ。\n学而不思則罔、思而不学則殆（学んで思わざれば則ち罔し、思いて学ばざれば則ち殆うし）\n实践得真知（実践こそ真知）\nだから、時々はいろいろ考えすぎずに、大胆に挑戦するべきなんだ。考えすぎることが自分の可能性を狭めてしまうこともあるからね！\n参考記事 求助深澜校园网 Portal 认证应该怎么刷固件？-小米无线路由器以及小米无线相关的设备-恩山无线论坛 configuration - How to fix make error \u0026ldquo;No rule to make target \u0026lsquo;menuconfig\u0026rsquo;\u0026rdquo; when building a kernel for Beagleboard? - Unix \u0026amp; Linux Stack Exchange 在虚拟机中设置静态IP (centos为例) - yexca\u0026rsquo;Blog 安装 Git - 廖雪峰的官方网站 Linux 添加用户和管理员用户 - yexca\u0026rsquo;Blog linux 系统下如何进行用户之间的切换_M李丽的博客-CSDN博客_linux切换系统 使用 ssh 传输文件 - 思否 Linux tar 命令-菜鸟教程 Portal 认证原理-曹世宏的博客 Linux 命令发送 Http 的 get 或 post 请求 (curl 和 wget 两种方法)_cyl937的博客-CSDN博客 ","date":"2022-09-05T21:24:23+08:00","permalink":"https://blog.yexca.net/ja/archives/66/","title":"OpenWRTで深瀾ネットワーク認証を突破する奮闘記"},{"content":" 📢 この記事は gemini-2.5-flash によって翻訳されました はじめに YouTube-dl を使い始めてから、チャンネルの全コンテンツをダウンロードするのにすごく便利だってわかったんだけど、ダウンロードしたファイルがwebm形式で互換性があんまり良くなかったんだ。だからffmpegを使った形式変換コマンドを調べてみたよ。\n設定ファイル 後で設定ファイルをちょこっと変更するだけでいいって気づいたんだ。ファイルの後ろにこれを追加するだけ。\n1 --merge-output-format mp4 僕の設定ファイルはこれ。\n1 -o \u0026#39;C:/Users/yexca/Downloads/Video/%(uploader)s/%(upload_date)s%(title)s%(id)s.%(ext)s\u0026#39; --merge-output-format mp4 個別変換コマンド このコマンドを使えば、サクッとトランスコードできるよ。\n1 ffmpeg -i before.webm after.mp4 でも、一つずつ変換するのはさすがに遅すぎるから、バッチ処理を使うことを思いついたんだ。\nバッチ処理 メモ帳を新規作成して、以下のコードを入力してね。\n1 for %%a in (*.webm) do ffmpeg -i \u0026#34;%%~a\u0026#34; -vcodec copy -f mp4 \u0026#34;%%~na.mp4\u0026#34; ここで、(*.webm)は元のファイル形式で、\u0026quot;%%~na.mp4\u0026quot;は作成したいファイル形式のことだよ。\nそしてrun.batという名前で保存して、該当のフォルダに入れて実行すればOK。\nでもこれだと、毎回違うファイルを変換するたびに編集しなきゃいけないから、あんまり実用的じゃないんだよね（\nDOSコマンド（ちょっと改良） それでbatファイルのことちょっと調べて、簡単なプログラム書いてみたんだ（コマンドラインで日本語をちゃんと表示するにはGB2312エンコーディングを使う必要があるよ）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 echo off :0 echo 請輸入數字選擇操作 echo 1.轉碼 echo 2.刪除 echo 3.退出 set /p choice=請選擇 goto %choice% :1 set /p before=請輸入轉碼前文件格式 set /p after=請輸入轉碼後文件格式 echo 開始轉碼%before%到%after% for %%a in (*.%before%) do ffmpeg -i \u0026#34;%%~a\u0026#34; -vcodec copy -f %after% \u0026#34;%%~na.%after%\u0026#34; echo 轉碼完成 goto 0 :2 set /p delet=請輸入需要刪除的文件格式 echo 開始刪除%delet% del *.%delet% del %delet% echo 刪除完成 goto 0 :3 exit 該当するフォルダに入れて使えばいいよ。\n参考記事 youtube-dl のいくつかの実用的なテクニック · eisen blog 初心者向け！FFmpegコマンド例20選以上 - 知乎 FDMがダメになった、youtube-dlは激遅、肉焼き師の終末が来た！ における AnnMilne のコメント\nbatコマンドでffmpegをバッチ変換 - 五仁の記録 Batコマンド学習 - 陽光雨露\u0026amp; - ブログ園 bat setコマンド詳細解説_pythonベテラン初心者のブログ-CSDNブログ ","date":"2022-09-05T16:41:38+08:00","permalink":"https://blog.yexca.net/ja/archives/65/","title":"ffmpegで動画形式を一括変換"},{"content":" 📢 この記事は ChatGPT によって翻訳されました はじめに これは肖佳先生の書籍『HTTP抓包实战』を読んだ後にまとめた HTTP に関する学習メモです。主に HTTP メッセージ関連の内容を整理しました。（記録：読書＋本記事作成に5日間かかりました）\nHTTPメッセージ構造 HTTPメッセージには「リクエストメッセージ（Request）」と「レスポンスメッセージ（Response）」の2種類があります。\nHTTPリクエストメッセージ（Request） HTTPリクエストは以下の3つのパートで構成されます：\n開始行（Request line）：リクエストメソッド、URI、HTTPバージョン\n例：GET https://blog.yexca.net/ HTTP/2\nヘッダ部（Header）：追加情報や制御情報を含む\nボディ部（Body）：フォームデータやファイルなどの実データ（※省略される場合もあり）\n注意：ヘッダとボディの間には必ず空行が入ります。\nHTTPレスポンスメッセージ（Response） HTTPレスポンスも同様に3つのパートから成ります：\nステータス行（Response line）：HTTPバージョン、ステータスコード、ステータスメッセージ\n例：HTTP/2 200 OK\nヘッダ部（Header）\nボディ部（Body）\nこちらもヘッダとボディの間には空行が入ります。\nHTTPリクエストメソッドとステータスコード URLの構造 URL（Uniform Resource Locator）は、インターネット上のリソースを一意に識別するためのものです。\n基本構成：\n1 2 スキーム://ホスト\\[:ポート]/パス\\[?クエリ]\\[#アンカー] 項目 説明 スキーム http, https, ftp などの通信プロトコル ホスト ドメインまたは IP アドレス ポート番号 通常 HTTP は 80、HTTPS は 443（省略可） パス リソースのパス クエリ文字列 ?以降のパラメータ（例：?id=1\u0026amp;name=test） アンカー ページ内リンク（例：#top） 主なHTTPメソッド No. メソッド 説明 1 GET サーバーからデータを取得する 2 HEAD GETと似ているが、レスポンスボディは返されない（ヘッダのみ） 3 POST サーバーにデータを送信（例：フォーム送信、ファイルアップロードなど） 4 PUT リソースを新しく作成または完全に置き換える 5 DELETE 指定したリソースを削除する GETとPOSTの違い データの送信位置\nGET は URL の末尾（?以降）に付ける。POST はボディに含まれる。\nサイズ制限\nGET は URL 長に制限あり（ブラウザ依存）。POST は基本的に制限なし。\n取得方法\nGET は request.queryString、POST は request.form などを使う。\nHTTPステータスコード HTTPレスポンスの中に含まれる数字で、リクエストの結果を示すものです。\nコード範囲 意味 1XX 情報（処理中） 2XX 成功 3XX リダイレクト 4XX クライアントエラー 5XX サーバーエラー よく使われるステータスコード コード 説明 200 OK リクエストが成功した 301/302 恒久的/一時的リダイレクト。Location ヘッダに新しいURLが含まれる 304 コンテンツが更新されていない（キャッシュ利用可能） 401 認証が必要（Basic認証など） 403 アクセス禁止（アクセスは認識されたが拒否された） 404 リソースが見つからなかった 500 サーバー内部エラー（スクリプトエラーなど） 503 一時的にサービス利用不可（メンテ中など） 206 Partial Content（部分的コンテンツ） サーバーがリクエストされた一部のコンテンツを返した場合 動画のストリーミングやダウンロード再開などに使われる ヘッダに Range（要求）や Content-Range（応答）が含まれる 301 vs 302（リダイレクト） 301: 永続的な移動 → 検索エンジンもリンク先を更新 302: 一時的な移動 → ユーザーセッションやログイン時など 304 Not Modified（未更新） ブラウザキャッシュが最新 → サーバーは新しいデータを送らない 400 Bad Request（不正リクエスト） リクエストの構文エラー（例：クッキー不正、フォーム誤送信など） 401 Unauthorized（認証エラー） 認証ヘッダがない/不正な場合。Basic 認証などで返される 403 Forbidden（禁止） サーバーがリクエストを明示的に拒否したい時に使用（理由は非公開） 404 Not Found（見つからない） 該当リソースなし 例：非ログイン状態では一部URLが 404 を返す（実際は制限付き） 500 Internal Server Error（サーバー内部エラー） プログラムのバグ、DB接続エラー、例外など 503 Service Unavailable（サービス一時停止） 過負荷やメンテナンス時など その他のコードを見るには HTTP ステータスコード一覧 - 菜鸟教程 HTTP ヘッダー構成 ヘッダーの形式は「キー: 値」で 1 行ずつ記述され、それぞれが特定の機能を持ちます。\nキャッシュ関連ヘッダー HTTP リクエスト・レスポンスの両方にキャッシュ制御に関連するヘッダーがあります。\nHTTP キャッシュとは、同じリソースを再び取得する際にローカルのキャッシュを使用して、再ダウンロードを避ける仕組みです。\nCookie Cookie は HTTP のキャッシュ制御手段のひとつで、key=value 形式のデータです。\nブラウザ → サーバー：Cookie: ヘッダーで Cookie を送信 サーバー → ブラウザ：Set-Cookie: ヘッダーで Cookie を設定 例：ip_country=CN\nAccept Accept ヘッダーは、クライアントが受け入れ可能な MIME タイプを通知します。\n例：Accept: text/html は HTML を受信可能という意味です。\nワイルドカード（*）を使って任意タイプを表現できます。\n例：Accept: text/html, */*;q=0.8\nAccept-Encoding 圧縮方式に関するヘッダーで、クライアントが対応する圧縮形式を通知します。\n例：Accept-Encoding: gzip, deflate\nAccept-Language Accept-Language は、クライアントが受け入れられる言語の一覧を通知します。\n例：Accept-Language: en-US,en;q=0.8,zh-CN;q=0.6,zh;q=0.4,zh-TW;q=0.2\n言語（日本語、中国語など）と文字コード（UTF-8、GBK など）は別物です。\nUser-Agent User-Agent は、クライアントの環境情報（OS、CPU、ブラウザバージョンなど）を通知する文字列です。\n例：User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:103.0) Gecko/20100101 Firefox/103.0\nこれを書き換えることで、他のブラウザやデバイスを装ったリクエストも可能になります。\nReferer（リファラー） リファラーはアクセス元の URL を示し、どこから来たのかをサーバー側が判断できます。\nアクセス解析や不正リンク検出などに利用されます。\nConnection HTTP/1.1 以降は、デフォルトで Connection: Keep-Alive によって TCP 接続が継続されます。\nこの接続維持時間は Web サーバー側（Apache など）で設定可能です。\nHost Host ヘッダーは、リクエスト対象のホスト名とポート番号を明示します。HTTP/1.1 以降は必須です。\nポートが 80 の場合は省略可能です。\nHTTP キャッシュの仕組み HTTP のキャッシュは、主にブラウザやプロキシサーバーで動作します。\nキャッシュの利点 不要なデータ転送の削減 レスポンス速度の向上 サーバー負荷の軽減 キャッシュの鮮度判断方法 方法①：If-Modified-Since / Last-Modified クライアントが If-Modified-Since ヘッダーでローカルの更新日時を通知します。\nサーバーが Last-Modified ヘッダーと比較し、変更がなければ 304 Not Modified を返します。\n方法②：If-None-Match / ETag クライアントが If-None-Match で ETag（ハッシュ値）を送信し、サーバーが照合して同一なら 304 を返します。\nキャッシュ関連ヘッダー一覧 リクエスト側 ヘッダー名 説明 Cache-Control: max-age=0 キャッシュの有効期限（秒） If-Modified-Since: Tue, 28 Jun 2022 \u0026hellip; 最終更新日時 If-None-Match: \u0026ldquo;etag-value\u0026rdquo; キャッシュの ETag Cache-Control: no-cache キャッシュを使用しない Pragma: no-cache 上記と同じ（HTTP/1.0 用） レスポンス側 ヘッダー名 説明 Cache-Control: public 共有キャッシュ可（プロキシ等） Cache-Control: private ユーザー固有キャッシュ Cache-Control: no-cache 必ず再検証 Cache-Control: no-store 完全非キャッシュ（機密データ用） Cache-Control: max-age=60 相対時間での有効期限（秒） Date: Thu, 01 Sep 2022 \u0026hellip; サーバー送信日時 Expires: Thu, 01 Sep 2022 \u0026hellip; 絶対時間による有効期限 Last-Modified: Tue, 28 Jun 2022 \u0026hellip; 最終更新日時 ETag: \u0026ldquo;etag-value\u0026rdquo; キャッシュ判定用の識別子 ※ 通常は Cache-Control 優先、なければ Expires が参照されます。\nETag とは？ 「Entity Tag」の略で、ファイル内容から生成されるハッシュ文字列です 内容が変われば ETag も変わるので、更新判定が高精度 ETag は、Last-Modified では対応できない問題（ミリ秒単位の変更や内容が同じ等）を補います。\n強制再読み込みとキャッシュ Ctrl + Shift + R：強制リロード（キャッシュ無効） Ctrl + R：再読み込み（条件付き GET） アドレスバーから直接 URL 入力時は、ブラウザは「キャッシュ命中（cache hit）」としてサーバーと通信せず、ローカルキャッシュを使用します。\nパブリックとプライベートキャッシュ 種類 ヘッダー 説明 パブリック Cache-Control: public 共有可能（例：プロキシキャッシュ） プライベート Cache-Control: private 個別ユーザーのローカルキャッシュ HTTP 圧縮と URL エンコード HTTP 圧縮の概要 Web サーバーとブラウザ間で送受信される「テキストデータ」を圧縮する技術です。\n例：HTML / CSS / JavaScript など → gzip 圧縮\n圧縮とエンコードの違い HTTP ボディの「Content-Encoding」は、単にサイズ削減の gzip 圧縮だけでなく、暗号化なども可能です。\nつまり、HTTP 圧縮は HTTP エンコーディングの一種です。\n圧縮の流れ クライアントは Accept-Encoding: gzip, deflate で対応可圧縮形式を提示\nサーバー側は\n元のレスポンスを生成 ボディ部分を gzip 圧縮 Content-Encoding: gzip を付与 ブラウザへ返却 ブラウザは Content-Encoding を見てデコードし、元データを表示\n※リクエストの圧縮は一般的ではない\nContent-Encoding 種類 エンコーディング 内容 gzip GNU Gzip 形式 compress UNIX compress deflate zlib 圧縮 identity 無圧縮（指定なし時のデフォルト） gzip / deflate は一般的な可逆圧縮で、gzip のほうが効率が良く広く使われています。\nCookieメカニズムの仕組み HTTPはステートレスなプロトコルであり、同じブラウザからの複数のリクエストでもサーバー側では独立したものとして扱われ、関連性は持ちません。\nセッションとCookie サーバーがクライアントの識別を行うには、状態管理が必要になります。HTTPがステートレスであるため、クライアントとサーバーが共同で状態を管理する「セッションメカニズム」が使用されます。\nクライアントが初めてアクセスした際、サーバーはセッションIDを生成し、レスポンスに含めて返す ブラウザはセッションIDを保存し、以後のリクエストに含める サーバーはセッションIDによって同じクライアントかどうかを判別する このセッションの仕組みにCookieが使われています。\nCookieとは Cookieとは、ブラウザが少量のデータを key=value の形式で保持する仕組みです。複数のCookieは ; で区切られ、リクエスト時に自動的に送信されます。\n主に認証情報やユーザー設定の保持、または広告追跡・ターゲティングなどに利用されます。\n現在では、EUなどの国ではCookieの使用に関する法的制限があり、ユーザーの同意が必要です。\nCookieの属性 Expires\n有効期限を指定。未指定の場合、ブラウザを閉じると削除されます。\nPath\nCookieが有効なパス範囲を指定します。例：/test/ に設定すると、/test/ 配下でのみ有効。\nHttpOnly\nJavaScript からアクセス不可にする属性で、XSS対策に効果的。ログイン用Cookieには必須。\nCookieの種類と保存場所 種類 説明 セッションクッキー 一時的なCookie。ブラウザを閉じると削除される 永続クッキー 有効期限があり、再起動しても保持される ブラウザごとに保存場所は異なり、例：Linux + Firefox の場合\n~/.mozilla/firefox/xxxxxxxx.default-release/cookies.sqlite\nHTTP基本認証 HTTPはステートレスであるため、Cookieによる認証のほか、Basic認証（基本認証）も用いられます。\nクライアントは ユーザー名:パスワード をBase64でエンコードし、Authorization ヘッダーに含めて送信します。\n基本認証の流れ サーバーが 401 Unauthorized を返し、WWW-Authenticate ヘッダーで認証を要求 ブラウザがログインダイアログを表示し、認証情報を取得 入力されたユーザー名とパスワードをBase64エンコードし、リクエストに含めて送信 家庭用ルーターや一部のREST APIではこの方式がよく使われます。\n例：curl -u ユーザー名:パスワード https://example.com\n基本認証の欠点 ステートレスなので、リクエストごとに認証が必要 Base64は簡単に復号できるため、パスワードが平文で送信されるのと同等。HTTPS必須 明示的にログアウトできない（Cookieと違って期限切れの仕組みがない） リプレイ攻撃 に弱い Digest認証（要約認証） Digest認証は、基本認証のセキュリティ上の欠点を補った改良方式です。\nパスワードの代わりにハッシュ値を送信することで、平文送信を回避 サーバー側で nonce（ワンタイムトークン）を生成してリプレイ攻撃を防止 クライアントも nonce を用いることでサーバー認証が可能 コンテンツの整合性チェックにも対応 参考リンク 『図解HTTP』読書メモ HTTP ステータスコード一覧（菜鸟教程） 各ブラウザにおける Cookie の保存場所 「ログイン」と「登陆」の違い（知乎） リプレイ攻撃（Wikipedia） REST APIとは？（Red Hat） 表現層の状態遷移（Wikipedia） ","date":"2022-09-05T16:03:36+08:00","permalink":"https://blog.yexca.net/ja/archives/64/","title":"HTTP 学習メモ"},{"content":" 📢 この記事は gemini-2.5-flash によって翻訳されました はじめに FedoraにはJava環境が最初から入ってるけど、それはOpenJDKなんだよね。時々、Oracle版を使いたくなることもあるでしょ？\nダウンロード 公式サイトからダウンロードするよ： Java Downloads | Oracle (ダウンロードにはログインが必要だよ)\njava8-Linux を見つけて、x64 Compressed Archive (64ビットの圧縮ファイル版) をダウンロードしよう。\nこの記事を書いた時のファイル名は jdk-8u341-linux-x64.tar.gz だったよ。\n適切なディレクトリに移動する まず、/usr/local にJava用のディレクトリを作ろう。 1 sudo mkdir -p /usr/local/java ファイルをこのディレクトリにコピーする。 ダウンロードしたファイルが ~/Downloads にあると仮定して、ダウンロードディレクトリに移動するよ。\n1 cd Downloads そしたら、さっき作ったディレクトリにコピーするんだ。\n1 sudo cp -r jdk-8u341-linux-x64.tar.gz /usr/local/java インストールファイルを解凍する Javaディレクトリに移動する。 1 cd /usr/local/java インストールファイルを解凍する。 1 sudo tar xvzf jdk-8u341-linux-x64.tar.gz $PATHを設定する /etc/profile の最後に以下の内容を追加する。 1 2 3 4 JAVA_HOME=/usr/local/java/jdk1.8.0_341 PATH=$PATH:$HOME/bin:$JAVA_HOME/bin export JAVA_HOME export PATH 利用可能なJavaバージョンのリストを更新する 直接以下のコマンドを実行するよ。 1 sudo update-alternatives --install \u0026#34;/usr/bin/java\u0026#34; \u0026#34;java\u0026#34; \u0026#34;/usr/local/java/jdk1.8.0_341/bin/java\u0026#34; 1 1 sudo update-alternatives --install \u0026#34;/usr/bin/javac\u0026#34; \u0026#34;javac\u0026#34; \u0026#34;/usr/local/java/jdk1.8.0_341/bin/javac\u0026#34; 1 1 sudo update-alternatives --install \u0026#34;/usr/bin/javaws.itweb\u0026#34; \u0026#34;javaws.itweb\u0026#34; \u0026#34;/usr/local/java/jdk1.8.0_341/bin/javaws.itweb\u0026#34; 1 設定ファイルを有効にする まず、システム全体のPATHファイルを再読み込みする。 1 source /etc/profile システムを再起動する。 1 reboot Javaバージョンを切り替える Javaバージョンを確認するには、コマンドを実行すればいいよ。\n1 java -version 以下のコマンドで切り替える。 1 sudo alternatives --config java 現在使ってるJavaバージョンの前には+が付いてるから、該当するバージョンを見つけて、数字を入力して選ぶだけだよ。\n参考記事 Fedora {OpenJDK と Oracle JDK} に Java をインストールする方法 ","date":"2022-09-02T17:37:51+08:00","permalink":"https://blog.yexca.net/ja/archives/63/","title":"Fedora に Java 8 (Oracle JDK) を入れる"},{"content":" 📢 この記事は Gemini-3-flash によって翻訳されました この記事は Hiyoung が執筆したよ。\n元の記事はこちら: https://blog.hiyoung.icu/2022/09/01/906d191f9a59/ Aria2はLinux向けのダウンロードツールなんだけど、ここではWindowsでのインストールと設定方法を紹介するね。公式のAria2にはGUI（画面）がないから、AriaNGっていうWebインターフェースを組み合わせて、ブラウザから操作できるようにしていくよ。\nAriaNgは、aria2をもっと使いやすくしてくれるモダンなWebフロントエンドなんだ。純粋なHTMLとJavaScriptで開発されているから、コンパイラや実行環境は一切不要だよ。\nAria2+AriaNGの最新インストールパッケージをダウンロード まずは公式サイトからインストールパッケージをダウンロードしよう。\nAria2のGithubページ – Aria2公式ドキュメント AriaNGのGithubページ – AriaNG公式ドキュメント Aria2は自分のOSに合った圧縮ファイルをダウンロードすればOK。AriaNGは解凍してAria2と同じフォルダに入れておこう。\nAriaNgには現在、標準版、単一ファイル版、AriaNg Nativeの3つのバージョンがあるよ。\n標準版：Webサーバーにデプロイするのに向いていて、リソースのキャッシュやオンデマンド読み込み機能がある。\n単一ファイル版：ローカルで使うのに最適。ダウンロードした唯一のhtmlファイルをブラウザで開くだけで使える。\nAriaNg Native：これもローカル利用向け。ブラウザを使わずにアプリとして動かせるよ。\n設定ファイルの追加 ファイルをディレクトリに解凍したら、新しく4つの空ファイルを作る必要があるよ（まずは空のtxtファイルを作ってから拡張子を変えるのが簡単）。\nAria2.log （ログファイル） aria2.session （ダウンロード履歴を記録して、レジュームできるようにするファイル） aria2.conf （設定ファイル） HideRun.vbs （cmdウィンドウを隠して実行するためのファイル） 設定ファイルの編集 さっき作った空の aria2.conf を開いて、以下の内容を貼り付けてね（メモ帳で開けば大丈夫）。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 ## \u0026#39;#\u0026#39;で始まる行はコメントだよ。オプションには説明がついているから、必要に応じて変更してね ## ## コメントアウトされているオプションはデフォルト値。変更したい時だけコメントを外すのがおすすめ ## ## ファイル保存関連 ## # ファイルの保存先パス(絶対パスか相対パスが使える)。デフォルト: 現在の起動位置 dir=E:\\Aria2Download # ログファイルの保存先パス log=D:\\aria2-1.36.0-win-64bit-build1\\Aria2.log # ディスクキャッシュを有効にする。0は無効。1.16以上が必要。デフォルト:16M #disk-cache=32M # ファイルの事前割り当て方式。ディスクの断片化を抑えられる。デフォルト:prealloc # 割り当てにかかる時間: none \u0026lt; falloc ? trunc \u0026lt; prealloc # fallocとtruncはファイルシステムとカーネルのサポートが必要 # NTFSならfalloc、EXT3/4ならtruncがおすすめ。MACの場合はこの項目をコメントアウトすること #file-allocation=none # 断点からの再開（レジューム）を有効にする continue=true ## ダウンロード接続関連 ## # 同時ダウンロードタスクの最大数。実行中に変更可能。デフォルト:5 #max-concurrent-downloads=5 # 同一サーバーへの接続数。タスク追加時に指定可能。デフォルト:1 max-connection-per-server=5 # 最小ファイル分割サイズ。タスク追加時に指定可能。範囲1M -1024M。デフォルト:20M # 例: size=10Mでファイルが20MiBなら2つのソースからダウンロード、15MiBなら1つからダウンロードする min-split-size=10M # 1タスクあたりの最大スレッド数。タスク追加時に指定可能。デフォルト:5 #split=5 # 全体のダウンロード速度制限。実行中に変更可能。デフォルト:0 #max-overall-download-limit=0 # 1タスクあたりのダウンロード速度制限。デフォルト:0 #max-download-limit=0 # 全体のアップロード速度制限。実行中に変更可能。デフォルト:0 #max-overall-upload-limit=0 # 1タスクあたりのアップロード速度制限。デフォルト:0 #max-upload-limit=0 # IPv6を無効にする。デフォルト:false #disable-ipv6=true # タイムアウト時間。デフォルト:60 #timeout=60 # 最大リトライ回数。0は無制限。デフォルト:5 #max-tries=5 # リトライ待ち秒数。デフォルト:0 #retry-wait=0 ## 進捗保存関連 ## # セッションファイルからダウンロードタスクを読み込む input-file=D:\\aria2-1.36.0-win-64bit-build1\\aria2.session # Aria2終了時に「エラー/未完了」のタスクをセッションファイルに保存する save-session=D:\\aria2-1.36.0-win-64bit-build1\\aria2.session # セッションを定期的に保存する。0は終了時のみ。1.16.1以上が必要。デフォルト:0 #save-session-interval=60 ## RPC関連の設定 ## # RPCを有効にする。デフォルト:false enable-rpc=true # すべてのソースからのアクセスを許可する。デフォルト:false rpc-allow-origin-all=true # 外部以外のアクセスも許可する。デフォルト:false rpc-listen-all=true # イベントループ方式。システムによってデフォルトが異なる #event-poll=select # RPCリスニングポート。ポートが使われている場合は変更可能。デフォルト:6800 #rpc-listen-port=6800 # RPC認証トークンの設定。v1.18.4の新機能。--rpc-user と --rpc-passwd の代わり #rpc-secret=\u0026lt;TOKEN\u0026gt; # RPCユーザー名の設定。新バージョンでは非推奨。--rpc-secretを使うこと #rpc-user=\u0026lt;USER\u0026gt; # RPCパスワードの設定。新バージョンでは非推奨。--rpc-secretを使うこと #rpc-passwd=\u0026lt;PASSWD\u0026gt; # RPCサービスでSSL/TLS暗号化を有効にするかどうか # 有効にするとRPC接続にはhttpsまたはwssプロトコルが必要になる #rpc-secure=true # RPCでSSL/TLS暗号化を使う時の証明書ファイル # PEM形式の場合、--rpc-private-keyで秘密鍵を指定する必要がある #rpc-certificate=/path/to/certificate.pem # RPCでSSL/TLS暗号化を使う時の秘密鍵ファイル #rpc-private-key=/path/to/certificate.key ## BT/PTダウンロード関連 ## # torrentファイルをダウンロードした時、自動でBTタスクを開始する。デフォルト:true #follow-torrent=true # BTリスニングポート。ポートがブロックされている時に使用。デフォルト:6881-6999 listen-port=51413 # 1タスクあたりの最大ピア数。デフォルト:55 #bt-max-peers=55 # DHT機能を有効にする。PTの場合は無効にする。デフォルト:true enable-dht=false # IPv6 DHT機能を有効にする。PTの場合は無効にする #enable-dht6=false # DHTネットワークのリスニングポート。デフォルト:6881-6999 #dht-listen-port=6881-6999 # ローカルピア探索（LPD）。PTの場合は無効にする。デフォルト:false #bt-enable-lpd=false # ピア交換（PEX）。PTの場合は無効にする。デフォルト:true enable-peer-exchange=false # 各ピアの速度制限。シードが少ないPTで有用。デフォルト:50K #bt-request-peer-speed-limit=50K # クライアント偽装。PTで必要 peer-id-prefix=-TR2770- user-agent=Transmission/2.77 # シードの共有率がこの値に達したら自動で停止する。0はずっとシードし続ける。デフォルト:1.0 seed-ratio=0.7 # タスク完了後でも強制的にセッションを保存する。デフォルト:false # 新しめのバージョンで有効にすると、完了後も.aria2ファイルが残る #force-save=false # BTハッシュチェック関連。デフォルト:true #bt-hash-check-seed=true # 前回のBTタスクを再開する時、再度ハッシュチェックをしない。デフォルト:false bt-seed-unverified=true # マグネットリンクのメタデータをtorrentファイルとして保存する。デフォルト:false bt-save-metadata=true 注意：以下の4行は自分の環境に合わせて、実際のファイルがあるパスに書き換えてね：\n1 2 3 4 5 6 7 8 # ファイルの保存先パス dir=E:\\Aria2Download # ログファイルの保存先パス log=D:\\aria2-1.36.0-win-64bit-build1\\Aria2.log # セッションファイルから読み込む input-file=D:\\aria2-1.36.0-win-64bit-build1\\aria2.session # セッションファイルへ保存する save-session=D:\\aria2-1.36.0-win-64bit-build1\\aria2.session 最後の2行はダウンロード履歴を保存するためのものだよ。もしAria2が起動しなくなった時は、そのファイルの中身を空にすれば直ることがあるよ。\nHideRun.vbs ファイルの編集 HideRun.vbsを開いて、これを追加してね。\n1 CreateObject(\u0026#34;WScript.Shell\u0026#34;).Run \u0026#34;aria2c.exe --conf-path=aria2.conf\u0026#34;,0 次に HideRun.vbs をクリックして実行してみて（注意：実行ファイル本体じゃなくて、必ず HideRun.vbs を実行してね！）。エラーが出なければ、下の補足は読み飛ばして大丈夫だよ。\nちょっと注意点なんだけど、ここには実行ファイルのフルパスを書くこともできるんだ。でも、そのパスの中にスペースが入っていると動かないから気をつけて。\n例えば：\n1 CreateObject(\u0026#34;WScript.Shell\u0026#34;).Run \u0026#34;C:\\Users\\he ne\\Downloads\\aria2c.exe --conf-path=aria2.conf\u0026#34;,0 この場合、he ne というフォルダ名にスペースが入っているから、システムが認識できなくてエラーになるんだ。よくあるのは D:\\Program Files (x86) とかだね。解決策は、vbsファイルをaria2のフォルダと同じ場所に置いて、パスの指定をファイル名だけにする（パスを除去する）ことだよ。\nindex.html を開く フォルダ内の index.html を開いて、「接続済み」と表示されていれば設定完了！\nPC起動時に自動実行する HideRun.vbs のショートカットを作成して、Windowsのスタートアップフォルダに入れておこう。\n実行ウィンドウ（Win + R）で shell:startup と入力してみて。\nこれでスタートアップフォルダが開くから、そこにさっき作ったショートカットを放り込めばOKだよ。\n参考記事:\nAria2+AriaNG 設定ガイド（Win10編） AriaNGドキュメント ","date":"2022-09-01T23:06:38+08:00","permalink":"https://blog.yexca.net/ja/archives/62/","title":"Aria2+AriaNG の設定と使い方"},{"content":" 📢 この記事は gemini-2.5-flash-lite によって翻訳されました はじめに FiddlerはデフォルトではHTTPパケットしかキャプチャできないから、HTTPSをキャプチャするには設定が必要なんだ。最近のWebサイトのほとんどがHTTPSを使っているか、HSTSを採用しているから、HTTPSパケットのキャプチャを有効にするのはとっても重要だよ。\nFiddlerの設定 「設定」→「HTTPS」 の項目で、「HTTPSトラフィックをキャプチャする」 にチェックを入れるだけでOK。「サーバー証明書エラーを無視する(安全ではありません)」 もチェックできるけど、ちょっと安全じゃないかもしれないから注意してね。その後、保存するのを忘れずに。\nブラウザの設定 HTTPSキャプチャを有効にした後、ブラウザでサイトにアクセスすると証明書エラーが出ることがあるんだ。「接続が安全ではありません」とか「プライベートではありません」みたいな警告が出たりするんだけど、この時は関連する証明書をインポートする必要がある。Firefoxを例に説明するね。\nまず、Fiddlerの証明書をダウンロードしよう。さっきの設定画面にあった 「ルート証明書をデスクトップにエクスポート」 っていうボタンをクリックすると、証明書がデスクトップにエクスポートされるよ (~/Desktop/ のあたり)。\n次に、Firefoxの設定画面を開く。「プライバシーとセキュリティ」→「証明書」の項目で証明書を表示させたら、さっきダウンロードした証明書をインポートしよう。出てくるダイアログで「このサイトを信頼する」みたいな項目に全部チェックを入れてね。\nこれでインポートは完了！普通にサイトにアクセスできるようになるし、FiddlerでもHTTPSのリクエストとレスポンスをちゃんとキャプチャできるようになるはずだよ。\n","date":"2022-09-01T08:17:32+08:00","permalink":"https://blog.yexca.net/ja/archives/61/","title":"FiddlerでHTTPSパケットをキャプチャする方法"},{"content":" 📢 この記事は gemini-3-flash-preview によって翻訳されました はじめに ぶっちゃけ、コマンドファイルをどこに置くかは自分で決められるんだよね。つまり好きな場所に置いていいってこと。これらのディレクトリはただの約束事に過ぎないんだけど、やっぱりルールを守ったほうがいいよ。自分のPC、特にLinuxがめちゃくちゃになるのは誰も嫌でしょ？\n優先順位 Linuxにあるこれらのbinディレクトリは全部コマンドを置く場所なんだ。もし違うディレクトリに同じ名前の実行ファイルがあったら、優先順位によってどっちが先に実行されるか決まるよ。echo $PATH っていうコマンドを使えば、環境変数を確認して実行の優先順位をチェックできるんだ。例えば、僕のシステムの出力はこんな感じ：\n1 2 [yexca@yexca-PC ~]$ echo $PATH /home/yexca/.local/bin:/home/yexca/bin:/usr/local/bin:/usr/local/sbin:/usr/bin:/usr/sbin 前から後ろに : で区切られていて、前にあるほど優先順位が高くなるよ。\n/bin システムの基本的なコマンドが入ってる場所。binはbinary（バイナリ）の略で、主にシステムの必須実行ファイルが置かれているよ。例えば、cat、cp、chmod、df、dmesg、gzip、kill、ls、mkdir、more、mount、rm、su、tarなどなど。\n/usr/bin システムにあらかじめインストールされている実行プログラムで、システムのアップグレードに伴って中身が変わることがあるよ。\nあとからインストールしたソフトウェアの実行スクリプトなんかもここ。主にアプリケーションツールの必須実行ファイルが置かれているんだ。例えば、c++、g++、gcc、chdrv、diff、dig、du、eject、elm、free、gnome*、gzip、htpasswd、kfm、ktop、last、less、locale、m4、make、man、mcopy、ncftp、newaliases、nslookup、passwd、quota、smb*、wgetとかだね。\n/usr/local/bin ユーザーが自分で作った（あるいは手動で入れた）実行ファイルを置く場所。ここを使うのがおすすめだよ。システムのアップグレードで同名のファイルが上書きされる心配もないからね。\n/sbin 一般的にスーパーユーザー（root）向けのコマンドを指すよ。主にシステム管理に必須なプログラムが置いてあるんだ。例えば、cfdisk、dhcpcd、dump、e2fsck、fdisk、halt、ifconfig、ifup、ifdown、init、insmod、lilo、lsmod、mke2fs、modprobe、quotacheck、reboot、rmmod、runlevel、shutdownとか。\n/usr/sbin ユーザーがインストールした、システム管理用の必須プログラムを置く場所。例えば、dhcpd、httpd、imap、in.*d、inetd、lpd、named、netconfig、nmbd、samba、sendmail、squid、swap、tcpd、tcpdumpなどが入るよ。\n参考記事 Linux /usr/bin与/usr/local/bin区别_学亮编程手记的博客-CSDN博客 /bin,/sbin,/usr/sbin,/usr/bin 目录之简单区别_IT农夫的博客-CSDN博客 ","date":"2022-08-31T00:27:09+08:00","permalink":"https://blog.yexca.net/ja/archives/60/","title":"Linuxのbinディレクトリについて"},{"content":" 📢 この記事は gemini-2.5-flash によって翻訳されました はじめに 個人的にFedoraをインストールした後に導入したあれこれだよ。\nターミナルショートカットキーの変更 設定 - キーボード を開いて、一番下の ショートカットキーの表示とカスタマイズ をクリック。\nショートカットキーをカスタマイズする\n名前：シェルターミナル\nコマンド：gnome-terminal\nショートカットキー：自分で設定してね\nシステムの更新 1 sudo dnf update スクリーンショットのショートカットキーを変更 やっぱりWindowsのショートカットキーが慣れてるんだよね。\n上記のスクリーンショットのところ、対話的なスクリーンショットをWin+Shift+Sに変更しよう。\nユーザーディレクトリを英語に変更 日本語のディレクトリって、ターミナルで操作するのがすごく大変なんだよね。\nまず言語を英語に変更するよ。\n1 export LANG=en_US それからユーザーディレクトリを更新。\n1 xdg-user-dirs-gtk-update この時、ユーザーディレクトリ下のフォルダを英語に変更するかどうか聞かれるから、「はい」を選んでね。\n次にシステム言語を日本語に戻すよ。\n1 export LANG=zh_CN.UTF-8 もう一度ユーザーディレクトリの更新コマンドを実行。\n1 xdg-user-dirs-gtk-update もう一度上のコマンドを入力すると、日本語に変更するかどうか聞かれるから、「いいえ」を選んで、「今後表示しない」にチェックを入れればOK。\nVsCode 環境設定\n1 sudo rpm --import https://packages.microsoft.com/keys/microsoft.asc 1 sudo sh -c \u0026#39;echo -e \u0026#34;[code]\\nname=Visual Studio Code\\nbaseurl=https://packages.microsoft.com/yumrepos/vscode\\nenabled=1\\ngpgcheck=1\\ngpgkey=https://packages.microsoft.com/keys/microsoft.asc\u0026#34; \u0026gt; /etc/yum.repos.d/vscode.repo\u0026#39; キャッシュを更新\n1 dnf check-update dnfでインストールするなら\n1 sudo dnf install code yumを使うなら\n1 2 yum check-update sudo yum install code Edgeブラウザ Windowsから移行してきて、まだFirefoxに慣れないし、マルチデバイス同期もしたいからね （でも一番安全なのはやっぱりIEブラウザだよね）\nMicrosoft Edge Web ブラウザーをダウンロード | Microsoft .rpmをダウンロードしてね。\nMarkText 全プラットフォーム対応のMarkdownエディタだよ。\nGitHub - marktext/marktext: 📝A simple and elegant markdown editor, available for Linux, macOS and Windows. 7-zip インストール\n1 yum install -y p7zip p7zip-plugins 圧縮\n1 7z a after.7z before 解凍\n1 7z x after.7z FeedReader RSSリーダーだよ。僕はFedoraに付属のソフトウェアで検索してダウンロードしたんだ。\nTelegram /opt/Telegramの下に置いてから実行するのを忘れずにね。\nTelegram Messenger 網易雲音楽 flatpakのインストールと設定\n1 sudo dnf install flatpak 1 flatpak remote-add --if-not-exists flathub https://flathub.org/repo/flathub.flatpakrepo netease.CloudMusicのインストール\n1 flatpak install flathub com.netease.CloudMusic 実行／アイコンをクリックして実行\n1 flatpak run com.netease.CloudMusic アンインストール\n1 flatpak uninstall com.netease.CloudMusic Nvidiaドライバーのインストール インストール\n1 sudo dnf install akmod-nvidia オプションだよ\n1 sudo dnf install xorg-x11-drv-nvidia-cuda インストールが終わったら再起動してね。\n1 reboot ノート：もし再起動後に「Nvidia kernel module missing falling back to Nouveau」と表示されたら\nまずBIOSでセキュアブートが無効になっているか確認してね\nrpm -qa akmodsを実行して、インストールされているakmodsパッケージのバージョンをチェック。\nsudo akmods --force \u0026amp;\u0026amp; sudo dracut --forceを実行して、カーネルモジュールをビルドしてね。\n参考にしたのはここ： Fedora 34 NVIDIA kernel module missing. Falling back to nouveau - #4，来自 vk2bea - Ask Fedora もし上記の方法でダメだったら、以下の方法を試してみてね。\nNvidia関連のものを全部アンインストールするよ。sudo dnf remove \\*nvidia\\*\nドライバーをインストール。sudo dnf install akmod-nvidia\n参考にしたのはここ： Nvidia kernel module missing falling back to Nouveau (Fedora 36 PR) : Fedora デスクトップの最適化 僕のノートPCだと、デフォルトのフォントがちょっと小さすぎるんだよね。\n1 sudo dnf install gnome-tweak-tool インストールが終わったら、ツールの中に最適化っていうアプリが入るよ。\nQQ/Icalingua++ まさかこのQQ for Linuxを使う人なんていないよね？いないよね？\nログインすると他のサードパーティと同じくエラーが出るなんてありえないよ。\nIcalingua++サードパーティ： GitHub - Icalingua-plus-plus/Icalingua-plus-plus: A client for QQ and more. GNOME拡張機能 何をするのかよくわからないけど、たぶん役立つ感じがするやつ。\nホストコネクタのインストール\n1 sudo dnf install chrome-gnome-shell gnome-extensions-app Latest extensions in GNOME Shell Extensions にアクセスしてインストールしてね。\nspeedtest 以下のコマンドを順番に入力してね。\n1 curl -s https://packagecloud.io/install/repositories/ookla/speedtest-cli/script.rpm.sh | sudo bash 1 sudo yum install speedtest Fedoraに既にインストールされているもの git, gcc, gdb, python, OpenSDK java\nLibreOffice\n参考記事 Fedoraのユーザーディレクトリを英語に変更する – テンセントクラウド開発者コミュニティ-テンセントクラウド CentOS Fedoraでp7zipを使ってファイルを圧縮・解凍する_hkNarutoのブログ-CSDNブログ Running Visual Studio Code on Linux fedora-netease-fedora網易雲音楽インストールスクリプト。このスクリプトはFedora上でNetease Cloud Musicをワンクリックでインストールするためのもので、FedoraKDE30でテスト済み。 Howto/NVIDIA - RPM Fusion Fedora 36インストール後に# やっておくべき8つのこと デスクトップアプリ - GNOME Shell拡張機能の使い方 Howto/Secure Boot - RPM Fusion SPEEDTEST CLI: Internet connection measurement for developers ","date":"2022-08-24T12:13:30+08:00","permalink":"https://blog.yexca.net/ja/archives/59/","title":"Fedoraインストール後"},{"content":" 📢 この記事は Gemini-3-flash によって翻訳されました はじめに 今日、Git でプッシュしようとしたら fatal: unable to access 'https://github.com/yexca-VRChat/yexca-VRChat.github.io.git/': Failed to connect to 127.0.0.1 port 1081 after 2074 ms: Connection refused ってエラーが出ちゃったんだ。PC を再起動してもダメだったから、解決策を探すことにしたよ（自分のリポジトリになんでアクセスさせてくれないんだよ）。\n解決までの道のり 調べてみたところ、プロキシに関係があるみたいなんだけど、プロキシはルーター側で設定してるはずなんだよね。\nそこで、別の普通のルーターに繋ぎ直してもう一度プッシュしてみたけど、やっぱり同じ問題が発生。\n次に Git のプロキシ設定を解除してみたけど、これも効果なし。\n1 2 git config --global --unset http.proxy git config --global --unset https.proxy 最後に、そういえば WinXray を使ってたかも…？と思い出して確認してみたら、案の定 PAC モードがオンになってた。それをオフにしたら、無事にプッシュできたよ！\n参考記事 fatal: unable to access \u0026lsquo;https://github.com/fmoraless/e-commerce.git/\u0026rsquo;: Failed to connect to 127.0.0.1 port 56832: Connection refuse · Issue #11981 · desktop/desktop 解决git下载出现：Failed to connect to 127.0.0.1 port 1080: Connection refused拒绝连接错误_点亮～黑夜的博客-CSDN博客 git 报错:解决拒接接入问题_Huang_milk的博客-CSDN博客 ","date":"2022-08-15T02:44:47+08:00","permalink":"https://blog.yexca.net/ja/archives/58/","title":"Github へのアクセス拒否 Connection refused"},{"content":" 📢 この記事は ChatGPT によって翻訳されました はじめに Gitを使えば、友人とのコード管理や同期が簡単になります。特に静的サイトが好きな筆者にとっては、GitでWebファイルを同期できるのは非常に便利です。\nGitのインストール ROOTユーザーで以下のコマンドを順に実行：\n1 2 yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel perl-devel yum install git ユーザーの作成 Gitサービス用に専用のユーザーとグループを作成します。\n1 2 groupadd git useradd git -g git 公開鍵の取得 ローカルPC（Windows）の公開鍵は %UserProfile%/.ssh/ にある id_rsa.pub ファイルです。\nファイルが存在しない場合、cmdで以下を実行：\n1 ssh-keygen これにより鍵ペアが生成されます。\n公開鍵の登録 生成した公開鍵を /home/git/.ssh/authorized_keys に1行ずつ追加します。ファイルが存在しない場合は以下で作成：\n1 2 3 4 5 cd /home/git/ mkdir .ssh chmod 755 .ssh touch .ssh/authorized_keys chmod 644 .ssh/authorized_keys vi などで鍵を貼り付けて保存します。\nGitリポジトリの初期化 Gitリポジトリのディレクトリを /home/gitrepo/repo.git にします：\n1 2 3 4 5 cd /home mkdir gitrepo chown git:git gitrepo cd gitrepo git init --bare repo.git その後、リポジトリの所有者を変更：\n1 chown -R git:git repo.git リポジトリのクローン 1 git clone git@サーバーIP:/home/gitrepo/repo.git ディレクトリへの自動同期 Gitのhook機能を使います。\n1 2 cd /home/gitrepo/repo.git/hooks vi post-receive 以下のように記述：\n1 2 #!/bin/sh git --work-tree=/home/www/hexo --git-dir=/home/gitrepo/repo.git checkout -f ファイルに実行権限を付与：\n1 2 chmod +x post-receive chown -R git:git /home/gitrepo/repo.git コードの更新 単純にローカルコードを更新するだけなら：\n1 git pull 正式な手順：\n1 2 3 4 5 git status git checkout -- [ファイル名] git branch git checkout リモートブランチ名 git pull その他コマンド 1 2 3 4 git branch # ブランチ一覧 git checkout aaa # aaaブランチへ切り替え git branch aaa # aaaブランチ作成 git checkout -b aaa # aaaブランチ作成＆切り替え gitユーザーのシェルログインを禁止 セキュリティ上の理由から、git ユーザーのシェルログインを無効化：\n1 vi /etc/passwd 以下のように変更：\n1 2 -git:x:1004:1004::/home/git:/bin/bash +git:x:1004:1004::/home/git:/usr/bin/git-shell これでgitユーザーはSSHでGitを使用できますが、シェルにはログインできません。\n参考リンク Linux chown コマンド（菜鸟教程） Gitサーバー構築（菜鸟教程） SSHキーの生成（git-scm.com） GitにおけるSSHキーの使い方（简书） Gitサーバー構築（git-scm.com） Gitでローカルにコードを更新（CSDN） サーバー上にHexoを配置する（阿里云） Linuxパーミッションの解説 /etc/passwdファイルの詳細 ","date":"2022-08-13T10:28:50+08:00","permalink":"https://blog.yexca.net/ja/archives/57/","title":"Gitサーバーの構築と指定ディレクトリへの同期"},{"content":" 📢 この記事は gemini-3-flash-preview によって翻訳されました この記事は Hiyoung が書いたものだよ。\n元の記事はこちら: https://blog.hiyoung.icu/2022/08/11/607cac6fe835/ 今の主流なストリーミングサイトはどれも外部埋め込みコードに対応しているけど、Bilibili（いつ潰れるの？）の今の仕様（2022/8/11時点）だと、デフォルトの埋め込みリンクは360P固定で、しかも画質調整ができないんだ。これが本当に使い勝手が悪くて、YouTubeと比べるとその差は歴然。というわけで、今回はBilibiliの埋め込みパラメータとその方法について詳しく紹介するね。\nBilibiliの埋め込み参照 元の埋め込みリンク：\n1 \u0026lt;pre class=\u0026#34;language-html\u0026#34; data-info=\u0026#34;HTML\u0026#34; data-role=\u0026#34;codeBlock\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token tag\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token tag\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026lt;\u0026lt;/span\u0026gt;iframe\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token attr-name\u0026#34;\u0026gt;src\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token attr-value\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation attr-equals\u0026#34;\u0026gt;=\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;//player.bilibili.com/player.html?aid=80433022\u0026amp;bvid=BV1GJ411x7h7\u0026amp;cid=137649199\u0026amp;page=1\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token attr-name\u0026#34;\u0026gt;scrolling\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token attr-value\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation attr-equals\u0026#34;\u0026gt;=\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;no\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token attr-name\u0026#34;\u0026gt;border\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token attr-value\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation attr-equals\u0026#34;\u0026gt;=\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;0\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token attr-name\u0026#34;\u0026gt;frameborder\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token attr-value\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation attr-equals\u0026#34;\u0026gt;=\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;no\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token attr-name\u0026#34;\u0026gt;framespacing\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token attr-value\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation attr-equals\u0026#34;\u0026gt;=\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;0\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token attr-name\u0026#34;\u0026gt;allowfullscreen\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token attr-value\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation attr-equals\u0026#34;\u0026gt;=\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;true\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token tag\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token tag\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026lt;/\u0026lt;/span\u0026gt;iframe\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; 修正後の埋め込みリンク：\n1 \u0026lt;pre class=\u0026#34;language-html\u0026#34; data-info=\u0026#34;HTML\u0026#34; data-role=\u0026#34;codeBlock\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token tag\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token tag\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026lt;\u0026lt;/span\u0026gt;iframe\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token attr-name\u0026#34;\u0026gt;src\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token attr-value\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation attr-equals\u0026#34;\u0026gt;=\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;//player.bilibili.com/player.html?aid=80433022\u0026amp;bvid=BV1GJ411x7h7\u0026amp;cid=137649199\u0026amp;page=1\u0026amp;as_wide=1\u0026amp;high_quality=1\u0026amp;danmaku=1\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token attr-name\u0026#34;\u0026gt;scrolling\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token attr-value\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation attr-equals\u0026#34;\u0026gt;=\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;no\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token attr-name\u0026#34;\u0026gt;border\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token attr-value\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation attr-equals\u0026#34;\u0026gt;=\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;0\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token attr-name\u0026#34;\u0026gt;frameborder\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token attr-value\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation attr-equals\u0026#34;\u0026gt;=\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;no\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token attr-name\u0026#34;\u0026gt;framespacing\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token attr-value\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation attr-equals\u0026#34;\u0026gt;=\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;0\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token attr-name\u0026#34;\u0026gt;allowfullscreen\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token attr-value\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation attr-equals\u0026#34;\u0026gt;=\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;true\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token tag\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token tag\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026lt;/\u0026lt;/span\u0026gt;iframe\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; Bilibili埋め込み用キーの説明 キー 説明 aid 以前B站（Bilibili）で使用されていたAV番号 bvid 現在のBV番号 page 何番目の動画か。開始インデックスは1（デフォルトも1）。動画リストの中の何番目の動画かを指定する。 as_wide ワイド画面にするか 【1: ワイド, 0: 通常】 high_quality 高画質にするか 【1: 高画質(最大1080p) / 0: 最低画質(デフォルト)】 danmaku 弾幕を有効にするか 【1: 有効(デフォルト), 0: 無効】 vd_source=XXX\u0026amp;t=XXX 特定の時間へのジャンプ（空降）位置を追加可能 YouTubeの埋め込み参照 YouTubeはデフォルトの埋め込みコードを使えば大丈夫。もっと高度な機能を知りたい場合は、 公式チュートリアル で学んでみてね。\n1 \u0026lt;pre class=\u0026#34;language-html\u0026#34; data-info=\u0026#34;HTML\u0026#34; data-role=\u0026#34;codeBlock\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token tag\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token tag\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026lt;\u0026lt;/span\u0026gt;iframe\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token attr-name\u0026#34;\u0026gt;width\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token attr-value\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation attr-equals\u0026#34;\u0026gt;=\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;560\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token attr-name\u0026#34;\u0026gt;height\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token attr-value\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation attr-equals\u0026#34;\u0026gt;=\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;315\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token attr-name\u0026#34;\u0026gt;src\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token attr-value\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation attr-equals\u0026#34;\u0026gt;=\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;https://www.youtube.com/embed/OgcCOwj7wNY\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token attr-name\u0026#34;\u0026gt;title\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token attr-value\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation attr-equals\u0026#34;\u0026gt;=\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;YouTube video player\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token attr-name\u0026#34;\u0026gt;frameborder\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token attr-value\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation attr-equals\u0026#34;\u0026gt;=\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;0\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token attr-name\u0026#34;\u0026gt;allow\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token attr-value\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation attr-equals\u0026#34;\u0026gt;=\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token attr-name\u0026#34;\u0026gt;allowfullscreen\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token tag\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token tag\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026lt;/\u0026lt;/span\u0026gt;iframe\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; 動画デモ 実際の表示効果は https://blog.hiyoung.icu/2022/08/11/607cac6fe835/ で確認してみて。\nYoutube 1 2 3 4 5 6 7 8 9 \u0026lt;iframe allow=\u0026#34;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\u0026#34; allowfullscreen=\u0026#34;\u0026#34; frameborder=\u0026#34;0\u0026#34; height=\u0026#34;315\u0026#34; loading=\u0026#34;lazy\u0026#34; src=\u0026#34;https://www.youtube.com/embed/ucbx9we6EHk\u0026#34; title=\u0026#34;YouTube video player\u0026#34; width=\u0026#34;560\u0026#34;\u0026gt;\u0026lt;/iframe\u0026gt; ### Bilibili(修正前) \u0026lt;iframe allowfullscreen=\u0026#34;true\u0026#34; border=\u0026#34;0\u0026#34; frameborder=\u0026#34;no\u0026#34; framespacing=\u0026#34;0\u0026#34; scrolling=\u0026#34;no\u0026#34; src=\u0026#34;//player.bilibili.com/player.html?aid=499408391\u0026amp;bvid=BV16K411N7qj\u0026amp;cid=230404689\u0026amp;page=1\u0026amp;as_wide=1\u0026#34;\u0026gt; \u0026lt;/iframe\u0026gt; ### Bilibili(修正後) \u0026lt;iframe allowfullscreen=\u0026#34;true\u0026#34; border=\u0026#34;0\u0026#34; frameborder=\u0026#34;no\u0026#34; framespacing=\u0026#34;0\u0026#34; scrolling=\u0026#34;no\u0026#34; src=\u0026#34;//player.bilibili.com/player.html?aid=499408391\u0026amp;bvid=BV16K411N7qj\u0026amp;cid=230404689\u0026amp;page=1\u0026amp;high_quality=1\u0026amp;danmaku=1\u0026#34;\u0026gt; \u0026lt;/iframe\u0026gt; 参考資料: Sanarous ブログ と Google 埋め込み API チュートリアル ","date":"2022-08-12T00:11:17+08:00","permalink":"https://blog.yexca.net/ja/archives/56/","title":"ブログの動画埋め込み（外部リンク）の参照"},{"content":" 📢 この記事は gemini-3-flash-preview によって翻訳されました はじめに RSSに初めて触れたのは、神社（hacg）をぶらぶらしてた時だったかな。でも、その存在を知った頃にはRSSはもう廃れ始めてた。RSSHubみたいなプロジェクトが頑張ってくれてはいたけど、ネットワークの問題で繋がらなかったりして、だんだん使わなくなっちゃったんだよね。でも、最近お気に入りのブログが増えてきて、更新を逃さないためにも、あと自分が何を読んで何を読んでないかを記録するためにも、またRSSを使い始めることにしたよ。\nRSSについて RSSは「Really Simple Syndication（簡易情報配信）」の略。ニュースフィードの形式の一つで、ウェブサイト側が記事のタイトル、概要、全文なんかをこの形式で提供してくれる。ユーザーは色んなサイトのRSSリンクを登録して、一つのツールでまとめて情報をチェックできるんだ。\n言い換えれば、今の主流メディアみたいに「おすすめ」されるがままに受動的に情報を得るんじゃなくて、RSSは自分から知識を探しに行くプロセス。自分から情報源を見つけなきゃいけないけど、その代わり自分が購読した内容だけが表示されるんだ。\nなぜRSSを使うのか スマホを手に取ってアプリを開くと、トップにはおすすめが並んでて、いくらスクロールしても終わらないデザイン。ビッグデータに基づいた好みの押し売り。放っておくと、偏った考えや中身のないコンテンツに一日中時間を吸い取られちゃう。そういう風に時間が消えていく感覚、あんまり好きじゃないんだよね。勉強の合間にリラックスするのは大事だけど、リラックスする時だって自分のコントロール下に置いておきたいし、受動的に流されるのは嫌なんだ。だから、RSSを使うのは、自分なりの「情報のごみ箱（情報繭房）」への抵抗でもあるかな。\n身近な理由で言えば、未読の記事を管理したり、フォローしてるブログの更新をチェックしたり、すごい人の記事を見逃さないため。\nもっと大きな視点で見れば、アルゴリズムが進化して正確になればなるほど、情報の偏りはひどくなっていく。そうすると、自分から情報を掴みに行く力が弱まって、視野が狭くなって、最終的には学ぶ力さえ失っちゃうかもしれないからね。\n使い方 まずはRSSリーダーが必要。俺はオープンソースの QuiteRSS を使ってる。\n次に購読するソースが必要だけど、これは自分で探してみてね。サイトが提供してない場合は、 RSSHub で探すと見つかるかも（ネット環境がちゃんとしてる前提だけど）。\n探し方の参考： Feedzy RSS Feedsと一緒に使うRSSフィードURLの見つけ方 例えば、このブログのRSSはこれ： https://blog.yexca.net/feed.xml ソースが正しいかチェックするにはここ： Feed Validator for Atom and RSS URLをコピーして、ソフトを開いて、新しいソースとして追加すればOK。\nあとがき あーあ、本当はもっといい感じに書きたかったんだけど、いざ書こうとすると伝えたい感情をうまく言葉にできないや。言葉が使えないっていうか、ネットの変な情報に毒されすぎてて、もうまともな文章が書けなくなっちゃったのかもな……。\n書く前はいろいろ考えてたのに、いざ書き出すとどう表現していいか分からなくなっちゃう。まあ、今回はこんな感じで！\n参考記事/おすすめの読み物 求問神社的rss是啥啊 効率的に情報を得るために、RSS入門ガイドが必要だ - Tencent Cloud Developer Community RSS - Wikipedia RSSの衰退——能動的な情報取得からプッシュ通知の時代へ RSSとは？ ","date":"2022-08-09T16:08:14+08:00","permalink":"https://blog.yexca.net/ja/archives/55/","title":"RSS"},{"content":" 📢 この記事は gemini-2.5-flash によって翻訳されました はじめに 昨日プレイして、最初のミッションを受けた時の記録だよ。思い出しながら書いてるから、細かいところが実際と違うかもしれないね。\nミッション受注 ある謎の人物の試練をクリアして、HackShop のサイトを手に入れた後、最初のミッションを受けたんだ。\nミッションの内容は「The client wants the login credentials of the user Daronane. The remote ip of the victim is 54.44.37.52. It\u0026rsquo;s important that you access the correct machine behind the public ip. The victim\u0026rsquo;s ip LAN is 172.16.6.7」って感じ。\nミッション分析 ミッションの要求は Daronane のログイン情報で、ターゲットのパブリックIPは 54.44.37.52、LAN内IPは 172.16.6.7 だったよ。\n最初の試み まずは、 Grey Hack 单人模式游戏攻略（1）-MapleGe の記事の方法を試してみたよ。\n最初に whois コマンドを使って管理者メールアドレス Eggett@sabmi.net をゲット。そのメールアドレスに Login issue って件名でメールを送ったら、Daronane のパスワードが pierra って分かったんだ。\n早速 SSH で 54.44.37.52 に接続しようとして、ssh Daronane@pierra 54.44.37.52 ってコマンドを打ったんだけど、接続失敗。エラーメッセージは incorrect user/password だった。\nもしかして入力ミスかなって（手打ちだしね）、何回か試したんだけど、コピペしてもやっぱりアカウントかパスワードが間違ってるって言われるから、諦めたんだ。\nブラウザでそのIPにアクセスしてみたけど、当然何も手がかりはなし。Metlifegroup. Everything you need for your tech company っていう一行の文字と、画像（多分ラズベリーパイかな？）があるだけ。このサイト、もしかしてフォーラムで、Daronane はそのユーザーなのかなって思ったよ。\nゲームの日本語化 HackShop にアクセスした時に出てきた Exploits のチュートリアルが一部分からなかったから、ゲームの日本語化を探してみたんだ。クリエイターズワークショップを開いたら、やっぱり [简体中文](simplified Chinese) っていう日本語化パッチを見つけたよ。サブスクライブしてゲームを再起動したんだけど、インターフェースは日本語化されてなかったんだよね。\nクリエイターズワークショップのダウンロードアドレスを探して、steamフォルダ\\steamapps\\workshop\\content\\605230\\2825584160 にたどり着いた。README.md を読んでみたら、このフォルダの中身を C:\\Users\\%UserName%\\AppData\\LocalLow\\Loading Home\\Grey Hack\\ フォルダに入れる必要があるって分かったよ。\n実際は custom_lang.json を上記のフォルダに入れるだけでOKだったみたい。\nもう一度ゲームに入って、左側の language で Chinese を選べば日本語化できたよ。\nマニュアルを読む 日本語化した後のマニュアルの Exploits の部分を読んだんだけど、（日本語化してもあんまり変わらないことに気づいたけど）、やっぱりこれが何をするものなのか、いまいちピンとこなかったんだ。\nさらに調査 引き続き攻略法を探したんだけど、何も見つからなくて、 Grey Hack: 一个比较简单的任务 - 哔哩哔哩 っていう記事を見つけるまではね。\nこの記事の「スクリプトキディ」っていう言葉で、この Exploits が現実世界の攻撃スクリプトみたいなものだって理解できたんだ。\n誤った探索 HackShop でツール scanlib と scanrouter をダウンロードしたよ。\nscanlib 54.44.37.52 ってコマンドを試したら、Missing metaxploit って出て、意味が分からなかったんだ。\nnmap 54.44.37.52 コマンドを使ってみたら、そのサーバーは22と80の2つのポートを開放していて、それぞれSSHとHTTPサービスを提供してるって分かった。\nscanrouter コマンドを使ったら、そのサーバーに Kernel_router.so:V1.0.0 があるって分かったから、関連するスクリプトを探してみたんだ。そしたら Get access to a shell っていう説明のスクリプトが見つかったんだけど、特に要件はなかったよ。\nそのスクリプトを /home/yexca/hacktool にダウンロードして、ターミナルでそのフォルダに入って KernelRouterAccess 54.44.37.52 ってコマンドを打ったら、Can't find metaxploit library in the /lib path or the current folder ってエラーが出た。\n注：最初はリネームしてなかったんだけど、後で KernelRouterAccess にリネームしたから、この記事ではこの名前で書いてるよ。他のスクリプトも後でリネームしたもので、ショップの元々の名前とは違うからね。\nエラーからするとファイルが足りないみたいで、/lib って見ると、もしかして相手のサーバーに該当するファイルがなくて認識できないから入れないのかなって思ったんだ。\nもう一度考える nmap コマンドでこのサーバーが22と80番ポートを開放しているって分かったし、それにさっき被害者がフォーラムユーザーだって推測したから、HackShop で http スクリプトを探してみたんだ。そしたら Grant access to the file /etc/passwd and decipher its contents っていう説明のスクリプトが見つかった。要件は Minimum number of 1 users registered in the computer、つまり最低1人のユーザー登録が必要ってことだね。このサイトはフォーラムだし、まさかrootアカウントで直接開発してないだろうし、複数のユーザーで開発してるだろうなって思ったんだ。\nスクリプトをダウンロードして HttpPasswd 54.44.37.52 80 ってコマンドを打ったら、前のスクリプトと同じで Can't find metaxploit library in the /lib path or the current folder って言われたよ。\nこれには驚かなかった。だって scanrouter コマンドでスキャンした時に Kernel_router.so:V1.0.0 しかなくて、libhttp.so みたいなのはなかったからね。\n実はHTTPスクリプトを選んだのは、さっきの記事に**「ミッションをクリアするだけなら、リモート接続は必要ないし、ローカルでスクリプトを実行しても痕跡は残らない」**って書いてあったからなんだ。\nそれから、SSHも試してみようと思って、HackShop で該当するスクリプトを探したよ。Take advantage of a vulnerability in the ssh service to inject a new password to a registered user って説明のスクリプトが見つかった。要件は Any user logged in the computer、つまり誰かがログインしていればいいってことだね。このサイトを開発するならログインは必須だろうから、この要件は満たせるはずだ。\nスクリプトをダウンロードして SSHPasswd 54.44.37.52 22 ってコマンドを打ったんだけど、やっぱり Can't find metaxploit library in the /lib path or the current folder って言われたよ。\nこれどうすりゃいいの？？？ そっちのサーバーの /lib には何も入ってないってこと？じゃあ、/lib に何があるか確かめるために、全種類のスクリプトを試さなきゃいけないってこと？そしたら破産しちゃうじゃん！\n正しい方向へ そこで検索エンジンで攻略法を探してみたんだけど、見つからなかったんだ。\nまたあのエラーメッセージ Can't find metaxploit library in the /lib path or the current folder を思い返したんだ。最初は前の /lib と意味不明な metaxploit しか目に入らなかったんだけど、よく見たら後ろに or the current folder って書いてあるじゃん。この「カレントフォルダ」って何のこと？もしかして僕のPC上のスクリプトがあるフォルダのこと？だとすると、攻撃するために libssh.so みたいな該当するイメージを全部ダウンロードしなきゃいけないってこと？\nブラックマーケットを開いたけど、libssh.so みたいなイメージはなかったんだ。このゲームには apt-get コマンドがあるのを思い出して、現実のLinuxだと関連プログラムをダウンロードできるから、ゲーム内で apt-get search ssh ってコマンドを打ってみたんだ。そしたら案の定 libssh.so があった！ apt-get install libssh.so コマンドを使ってSSHをインストールしたよ。\nインストールが終わってから SSHPasswd 54.44.37.52 22 ってコマンドを打ったんだけど、やっぱり Can't find metaxploit library in the /lib path or the current folder って言われるんだ。\nもう、ほんとに呆れたよ！！！\nもう一度 HackShop を開いて、Tools の下の全商品を全部見てみたんだ。そしたら metaxploit.so が目に留まった。これ、エラーメッセージに出てた metaxploit じゃん！エラーメッセージの current folder と合わせて考えると、もしかしてこれが足りないからエラーになってたのかなって思ったんだ。\nスクリプトのあるフォルダ (/home/yexca/hacktool) にダウンロードして、scanrouter コマンドで Kernel_router.so しかスキャンされなかったことを考慮して、KernelRouterAccess 54.44.37.52 を実行してみたんだ。そしたら、なんと！アクセス権を手に入れたよ！\n権限取得 アクセス権を手に入れた後、まずはログを削除しようと思って FileExplorer.exe コマンドを入力して /var/system.log にアクセスしたら、Permission denied って出て、権限が足りないって。このスクリプトで手に入れたのはゲスト権限だったみたい。じゃあパスワードファイルを探そうと思って /etc/passwd にアクセスしたけど、やっぱり Permission denied （実際、そのコンピューターのファイルはほとんど全部見て回ったよ）。\nいやいや、このスクリプト、何の役にも立たないじゃん！\nSSHスクリプトはパスワード変更だからリスクが高いし、HTTPスクリプトでパスワードを取得しようと思ったんだ。HttpPasswd 54.44.37.52 80 ってコマンドを打ったら、結果は can't read /etc/passwd. Permission denied。取得した権限が guest って表示されてるし、もう**。\n結局、SSHスクリプトを使うことにしたんだ。SSHPasswd 54.44.37.52 22 ってコマンドを入力して、新しいパスワード 114514 を入れたら、Farraze のパスワード変更に成功したよ！\nssh Farraze@114514 54.44.37.52 ってコマンドを入力したら、ターゲットのマシンに無事入れたんだ。そこで cat /etc/passwd ってコマンドを打ったら、rootの暗号化されたパスワード情報を手に入れたよ。\nローカルでファイル（touch mima.txt）を新規作成して、そこにrootパスワード情報をコピー。それから decipher mima.txt で復号したら、rootのパスワードが「44444」だって分かったんだ（このパスワードでいいのかよって感じだね）。\nexit コマンドで接続を切って、次に ssh root@44444 54.44.37.52 を入力したら、root権限でログイン成功！\nマシンに侵入 入ってまず最初にログを削除。そのマシンのユーザーは Ralancl と Farraze がいて、ターゲットの Daronane はいなかった。やっぱりフォーラムユーザーだったのかな、でもこのマシンをくまなく探したけど、関連するものは見つからなかったよ（ついでにこの2人の持ってたお金、僕の口座に送金しちゃったけどね〜）。\nミッションの内容を思い出すと、IP 172.16.6.7 って書いてあったな。\nping 172.16.6.7 ってコマンドを打ったら、Ping successful って表示された。僕のPCからはPingできないけど（当たり前だよね、内部ネットワークのPCはPingできないもん）。\nnmap 172.16.6.7 ってコマンドで開放ポートを確認しようとしたら、command not found って出て、コマンドが見つからないって。\nあらら、それじゃあ僕のコンピューターのコマンドファイルをそのコンピューターの /bin ディレクトリに置くしかないな。\nコピーしてからもう一度 nmap 172.16.6.7 ってコマンドを打ったら、3306番ポートが開放されていて、サービスは employees って書いてあった。これ、何だろう？\n検索エンジンで調べたら、3306番ポートは一般的にデータベースのポートだって分かったから、SQLのスクリプトを使う必要があるってことだね。\nパスワード取得 HackShop に入って、関連するスクリプトを探したよ。そしたら Take advantage of a vulnerability in the sql service to inject a new password to a registered user っていう説明のスクリプトが見つかった。要件は Any user logged in the computer、つまり誰かがログインしていればいいってことだね。データベースを作成するなら、必ずユーザーがログインしてるはずだもん。\nダウンロードしてから SqlChangePasswd 172.16.6.7 3306 ってコマンドを打ったら、Connection refused. Address unreachable って言われた。アクセス拒否か、そりゃそうだ、データベースはホワイトリスト制だろうな。\nスクリプトと metaxploit.so をターゲットのマシン /root ディレクトリに置いて、もう一度コマンドを入力。パスワードを 114514 に変更して、ユーザーは Osquel にしたよ。\nで、問題はここから。パスワードを変更したとして、その後どうするの？このサーバーは3306番ポートしか開放してないし、僕も入れないじゃん XD\nよし、もう一度 HackShop に入って、関連スクリプトを検索。Prints the contents of the file /etc/passwd っていう説明のスクリプトを見つけたよ。要件は Any user logged in the computer、つまり誰かがログインしていればいいってことで、さっきのスクリプトと同じだね。\nスクリプトをターゲットのマシン /root ディレクトリに置いて、SqlPrintPasswd 172.16.6.7 3306 ってコマンドを入力したら、そのマシンの全ユーザーのパスワードが手に入ったんだ。その中にターゲットの Daronane のも入ってた！\n自分のPCにコピーして復号したら、パスワードは pierra だったよ！\n？？？このパスワードをクライアントに送ったら、肯定的な返事が来たんだけど？？？\n僕、**。\nすごい！ (YouTuber 黑镖客 のネタから引用)\nあとがき 最初からメールでパスワードは手に入ってたのに、僕はいろいろ苦労してもう一度パスワードを手に入れたってわけさ （ほんと、呆れるよね）。\n収入は200だったんだけど、スクリプトの購入費用は200をはるかに超えてたから （トータルで見るとかなり損してるな）。でもスクリプトは繰り返し使えるし、探索のプロセス自体がすごく面白かったから良しとしよう！\nこのゲームの攻略情報って、ほとんどないんだよね。もしこの記事が、攻略を探している誰かの役に立ったら嬉しいな。\n","date":"2022-08-03T22:41:06+08:00","permalink":"https://blog.yexca.net/ja/archives/54/","title":"Grey Hack最初のミッション（パスワード取得）の記録"},{"content":" 📢 この記事は Gemini-3-flash によって翻訳されました この記事は Hiyoung が書いたものだよ。\n元の記事はこちら: https://blog.hiyoung.icu/2022/08/03/0b5e2db181ab/ 最近、勉強したコードを保存するのにGithubをよく使ってるんだけど、フォルダをそのまま直接アップロードできないことに気づいたんだ。それでネットでGitを使ったアップロード方法を調べてみたから、忘れないようにブログにまとめておくね。\nGithub側の操作 1. リポジトリのURLをコピーする ローカル側の操作 1. ローカルに新しい空のフォルダを作る 僕はもうクローンしちゃった状態だけど、こんな感じ。\n2. フォルダの中で Git Bash を開く 3. リモートリポジトリをクローン（Clone）する 1 2 \u0026lt;pre class=\u0026#34;language-bash\u0026#34; data-info=\u0026#34;bash\u0026#34; data-role=\u0026#34;codeBlock\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token function\u0026#34;\u0026gt;git\u0026lt;/span\u0026gt; clone + 君のリポジトリURL \u0026lt;span class=\u0026#34;token function\u0026#34;\u0026gt;git\u0026lt;/span\u0026gt; clone https://github.com/hiyoung3937/study_code.git //例だよ 4. アップロードしたいファイルをそのままドラッグ＆ドロップで入れる 5. アップロード実行 1 2 3 4 5 \u0026lt;pre class=\u0026#34;language-bash\u0026#34; data-info=\u0026#34;bash\u0026#34; data-role=\u0026#34;codeBlock\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token builtin class-name\u0026#34;\u0026gt;cd\u0026lt;/span\u0026gt; study_code.git //自分のリモートリポジトリ名を入力してね \u0026lt;span class=\u0026#34;token function\u0026#34;\u0026gt;git\u0026lt;/span\u0026gt; init \u0026lt;span class=\u0026#34;token function\u0026#34;\u0026gt;git\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token function\u0026#34;\u0026gt;add\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token builtin class-name\u0026#34;\u0026gt;.\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token function\u0026#34;\u0026gt;git\u0026lt;/span\u0026gt; commit -m “君のコミットメッセージ” \u0026lt;span class=\u0026#34;token function\u0026#34;\u0026gt;git\u0026lt;/span\u0026gt; push コマンドの説明 コマンド 説明 clone + リポジトリURL リポジトリをローカルに複製するよ cd + リモートリポジトリ名 リモートリポジトリのフォルダに入る（自分のリポジトリ名を入れてね） git init Gitを初期化するよ git add . ファイルをステージングエリアに追加する（\u0026quot;.\u0026quot; は今のディレクトリにある全ファイルのこと。フォルダ名だけ指定もできるよ） git commit -m “メッセージ” ステージングしたファイルをローカルリポジトリに記録するよ git push リモートリポジトリに送信する（ユーザー名とパスワードを聞かれるかもしれないよ） ","date":"2022-08-03T12:49:27+08:00","permalink":"https://blog.yexca.net/ja/archives/53/","title":"Gitを使ってファイルをGithubにアップロードする方法"},{"content":" この記事は Google 翻訳を使用して処理されました\n導入 コマンドラインから何かを実行して自慢したいと思わない男の子がいるでしょうか?以前から youtube-dl については知っていましたが、複雑すぎるようだったので使用していませんでした。今日試してみたところ、とても便利だとわかりました。\n環境 Python 3.7以降をインストールする Python の公式サイト でダウンロードしていい、インストールのとき、Add Python x.x to PATH をチェックしてね\nyt-dlp をインストール yt-dlp は youtube-dl に基づいて変更され、ダウンロード速度が速い\nダウンロード releases で yt-dlp.exe をダウンロードする\n構成 ダウンロードしたファイルを固定の場所に置き、マイコンピュータのプロパティを開き、システムの詳細設定 - 環境変数 - システム変数に移動し、Path を選択して編集をクリックし、新しいウィンドウで新規をクリックします。yt -dlp.exe のファイルを入力して\n次に、「はい」を 3 回クリックしてすべてのウィンドウを閉じる。\nテスト Win+R を押して「cmd」と入力し、Enter を押す。\ncmd に yt-dlp と入力します。Usage: yt-dlp [OPTIONS] URL [URL...] が表示されたら、設定は成功だ。\n更新 cmdに「yt-dlp -U」と入力するといい\n動画をダウンロード ダウンロードを開始するには、cmd に「yt-dlp」+「スペース」+「YouTube ビデオ リンク」と入力するだけです。\nデフォルトのダウンロードは720Pで、保存場所はC:/Users/%UserName%/です。\nダウンロード保存場所を変更する C:\\Users\\%UserName%\\AppData\\Roaming に新しいフォルダを作成し、yt-dlp という名前を付け、新しく作成したフォルダに入り、新しいファイル config.txt を作成します。\nファイルに次のコードを入力してください\n1 -o \u0026#39;C:/Users/%UserName%/Downloads/Video/%(title)s.%(ext)s\u0026#39; このうち、C:/Users/%UserName%/Downloads/Video/はダウンロードディレクトリです。\n%(title)s.%(ext)sは、ビデオのタイトルであるファイル名を保存する形式で、ビデオのタイトル.ビデオの拡張子名\n1080Pをダウンロード 1080P以上の動画は音声と動画が分離されているため、まずffmpegをダウンロードする必要があります。\nffmpeg 公式サイト にアクセスし、左下隅のシステムタイプを選択してから、ダウンロードを選択します。\nReleases · BtbN/FFmpeg-Builds を選択し、ffmpeg-n5.0-latest-win64-gpl-5.0.zipをダウンロードしました。\n次に、それを固定フォルダに配置し、システム変数に「bin」ファイルディレクトリを配置します。\nテスト cmd を開いて ffmpeg -version と入力します。バージョン番号が表示されれば、設定は成功です。\nクエリコマンド 現在のビデオの完全な形式を表示するには、yt-dlp -D [URL]と入力します (クエリのみ、ダウンロードは行われません)\nダウンロードコマンド 指定した形式でビデオをダウンロードするには、yt-dlp -f [ID] [URL]と入力します。ビデオとオーディオをダウンロードするには、[ID]+[ID]の組み合わせを使用できます。つまり、yt-dlp -f [ID]+[ID] [URL]はダウンロード後に自動的に結合されます\n注: 最高品質のビデオとオーディオをダウンロードします: -f \u0026quot;bv+ba/b\u0026quot;\naria2 を呼び出す ダウンロード コマンドの後に--external-downloader aria2c --external-downloader-args \u0026quot;-x 16 -k 1M\u0026quot; を追加するだけです。\n字幕をダウンロード 1 2 3 4 5 6 7 outube-dl --write-sub [url] //これはvtt形式の英語字幕とmkv形式の1080pビデオをダウンロードします youtube-dl --write-sub --skip-download [url] //ビデオをダウンロードせずに別の vtt 字幕ファイルをダウンロードします youtube-dl --write-sub --all-subs [url] //すべての言語の字幕をダウンロードします（ある場合） youtube-dl --write-auto-sub [url] //自動生成された字幕をダウンロードする（YouTubeのみ） ビデオリストをダウンロード 1 2 3 4 5 6 7 youtube-dl -f [format code] [palylist_url] //この方法では、指定された解像度のmp4ビデオをダウンロードできます youtube-dl [playlist_url] //ビデオ リストをダウンロードします。この方法でダウンロードされたビデオは、mkv または webm 形式である可能性があります。 youtube-dl -cit [playlist_url] //ビデオ リストをダウンロードします。この方法でダウンロードされたビデオは、mkv または webm 形式である可能性があります。 youtube-dl --yes-playlist [url] //リンクがビデオリストの場合、リスト内のビデオをダウンロードします。上記と同じですが、mkv または webm 形式である可能性があります。 視覚化 Releases · jely2002/youtube-dl-gui 参考文献 yt-dlp - Github 【备份】youtube-dl使用介绍 - 简书 一文搞懂Windows系统【目录变量】的相关知识_黑就黑到底的博客-CSDN博客_username变量 ","date":"2022-07-25T12:52:27+08:00","permalink":"https://blog.yexca.net/ja/archives/52/","title":"コマンドラインからYouTube動画をダウンロードする"},{"content":" 📢 この記事は gemini-2.5-flash によって翻訳されました はじめに 最近ネットサーフィンしてたら、なんか良い感じのフォントを見つけたから、変え方を探してみたよ。でも実際に使ってみたら、そこまで感動はなかったかな\n方法1 左下の管理 -\u0026gt; 設定（またはショートカットキーCTRL+,）で設定画面に入って、Editor:Font Familyを探すんだ。\nデフォルトの Consolas, 'Courier New', monospace を、変えたいフォントに変えればOK。\n方法2 Ctrl + Shift + Pを押して -\u0026gt; settings.jsonと入力 -\u0026gt; Preferences:Open Settings(JSON)を選んでsettings.jsonファイルを開く。そしたら、\u0026quot;editor.fontFamily\u0026quot;: \u0026quot;変更したいフォント\u0026quot;を {} の中に追加して保存すればいいよ。\n日本語と英語のフォントを分ける VS Codeのデフォルトフォントは3つあって、Consolas, 'Courier New', monospaceみたいに**,**で区切られてるのがわかるよね。日本語と英語で別のフォントを設定したいなら、最初の2つをそれぞれ英字フォントと和字フォント（英字フォント, 和字フォント）にするだけでいいんだ。例えば、SF NS Mono, '楷体'みたいにね。\n","date":"2022-07-13T17:47:57+08:00","permalink":"https://blog.yexca.net/ja/archives/51/","title":"VS Code フォントの変更"},{"content":" 📢 この記事は gemini-2.5-flash によって翻訳されました 解決策はなさそうだけど、クイックアクセスに自分で追加したのを全部消すことはできるよ（デフォルトに戻すってことね）。\nC:\\\\Users\\\\ユーザー名\\\\AppData\\\\Roaming\\\\Microsoft\\\\Windows\\\\Recent\\\\AutomaticDestinations の場所に行って、このフォルダの中身をバックアップしたら、全部消しちゃって大丈夫。\n参考記事 ftpアドレスがクイックアクセスから削除できない、他のフォルダはできる – Microsoft Community ","date":"2022-06-27T13:31:58+08:00","permalink":"https://blog.yexca.net/ja/archives/50/","title":"Windows ネットワークアドレス (FTPアドレス) クイックアクセスから削除"},{"content":" 📢 この記事は Gemini-3-flash によって翻訳されました はじめに 前に試した無線中継を今日またやってみたんだけど、やり方を忘れちゃってた。やっぱり、何かやったら記事を書いて記録しておくのが一番だね。\nこの記事では、OpenWRTルーターが接続するWi-Fiを「親機」、OpenWRTルーター自身を「ルーター」と呼ぶことにするよ。\n前提 ルーターと親機のLAN側IPアドレス（ルーターの管理画面に入るためのアドレス）が同じにならないように注意して。同じだとインターネットに繋がらなくなっちゃうから。\nルーターのLAN側IPアドレスを変更する ルーター管理画面の「ネットワーク」-「インターフェース」に入って、「LAN」の「編集」をクリック。そこで「IPv4 アドレス」を変更すればOK。\n例えば、親機のアドレスが 192.168.1.1 なら、ルーターは 192.168.5.1 とかに変えるといいよ。\n変更して「保存＆適用」を押した後は、ブラウザに新しいアドレスを入力して管理画面にアクセスしてね。\nルーターをWi-Fiに接続する 「ネットワーク」-「無線」に入って、「スキャン」をクリック。繋ぎたいWi-Fiを見つけたら「ネットワークに接続」を押してね。Wi-Fi名とパスワードを入力して「送信」をクリック。最後に「保存＆適用」をすれば完了。\nルーターでWi-Fiを飛ばす もしルーターが2.4Gと5Gの両方の周波数帯に対応しているなら、前の手順で接続したのとは別の周波数帯でWi-Fiを作ると、互換性が一番高くなるよ（もしもう片方の周波数帯ですでにWi-Fiが設定されているなら、それがそのまま使えるはず）。\nシングルバンド（片方の周波数だけ）の場合は、同じ周波数帯で新しく作成する必要があるよ。ただ、ルーターによっては1つの無線チップで受信と送信を同時にできないこともあるから、うまくいかない可能性もあるかもしれない。\nWi-Fiを飛ばす手順はいつも通り。「ネットワーク」-「無線」から追加して、SSID（Wi-Fiの名前）とパスワードを入力して「保存＆適用」するだけ。\n参考記事 OpenWrt进阶教程之无线中继配置指南 - 爱一枝梅 ","date":"2022-06-23T14:50:21+08:00","permalink":"https://blog.yexca.net/ja/archives/49/","title":"OpenWRTでWi-Fi中継"},{"content":" 📢 この記事は gemini-2.5-flash によって翻訳されました この記事は Hiyoung が書いたものだよ\n元記事: https://blog.hiyoung.icu/2022/08/18/5be9517606f2/ PSの自動化スクリプトで画像をバッチ処理する メニューバーの「ウィンドウ」-\u0026gt;「アクション」をクリック（ショートカットキーは Alt+F9） タブの下にある「新規フォルダ」（新規グループ）をクリックして、「画像サイズ変更」と名前を付ける（名前は自由に変えてもOK） 次に隣の「新規アクションを作成」をクリックすると、下部の丸が赤くなるのがわかるよ 「ファイル」、「開く」をクリックして、処理したい画像の中から1枚開く。画像サイズを変更し、「OK」をクリック。次に「別名で保存」し、名前を付けて保存する。（「書き出し」は使わないでね。そうしないとアクションに記録されず、無限ループになっちゃうよ） 「ファイル」、「自動処理」、「バッチ」をクリック 設定 実行するアクションセットとアクションを選ぶ ソースで変更したい画像ファイルの場所を選ぶ ターゲットで変更後の画像を保存する場所を選ぶ **「アクションの‘開く’コマンドを上書き」と「アクションの‘別名で保存’コマンドを上書き」**にチェックを入れる 内容はインターネットを参考にしているよ\n","date":"2022-06-10T00:54:44+08:00","permalink":"https://blog.yexca.net/ja/archives/48/","title":"PSの自動化スクリプトで画像をバッチ処理する"},{"content":" 📢 この記事は Gemini-3-flash によって翻訳されました はじめに テンセントクラウド（Tencent Cloud Function）が6月から有料になったから、使うのをやめて自分のサーバーに構築することにしたよ。\nなんで6月から有料なのに今さら記事を書いてるかって？ それは、まだ3ヶ月の無料トライアルがあるかもしれないから 米遊社（miHoYo BBS）のCookieが切れて更新したついでに、忘れないように記録しておこうと思ったからなんだ。\nツール＆元のチュートリアル 原神签到小助手 每日福利不用愁 - 银弾ブログ 原文では色々な使い方が紹介されているんだけど、ちょっと読むのが大変だったから、自分用にまとめてみたよ。\nテンセントクラウド関数の処理 料金が発生しないように、テンセントクラウド関数を凍結（停止）しておこう。\nもちろん、他に使う予定がなければアカウントごと解約してもいいけど、解約には身分証を持った写真が必要になるから注意してね。\n前提条件 サーバーからミホヨのサーバー https://mihoyo.com に接続できる必要があるよ。\nSSHのコマンドラインで ping mihoyo.com と入力して、接続できるか確認してみて。\n僕のサーバーの一つが繋がらなくて、結局別のサーバーに変えたんだよね、やれやれ。\nDockerのインストール ワンクリックでインストールできるスクリプトを使うのが楽だよ。Debian 10 と CentOS 7 で動作確認済み（rootアカウントで実行してね）。\nインストールコマンドはこれ：\n1 curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun 中国国内の daocloud を使う場合はこっち：\n1 curl -sSL https://get.daocloud.io/docker | sh スクリプトのインストール 以下のコマンドを実行するだけ。\n1 docker pull yindan/genshinhelper CentOS でのエラー CentOS でインストールしたときに Can't Connect to Docker Daemon というエラーが出たことがあったんだ。\nその時は、rootアカウントを使っているか確認してから、次のコマンドを入力してみて。\n1 systemctl start docker 簡単な使い方 Cookie の取得 米遊社のCookie取得方法については、この記事を参考にしてね： 原神 樹脂確認/通知 – yexca\u0026rsquo;Blog 注意：Cookie には account_id と cookie_token の2つのフィールドが含まれている必要があるよ。\n複数アカウントがある場合は、Cookie同士を # で繋げばOK。例：Cookie1#Cookie2#Cookie3\n簡単な設定 1 2 3 4 docker run -d --name=genshinhelper \\ -e COOKIE_MIHOYOBBS=\u0026#34;\u0026lt;COOKIE_MIHOYOBBS\u0026gt;\u0026#34; \\ --restart always \\ yindan/genshinhelper:latest \u0026lt;COOKIE_MIHOYOBBS\u0026gt; の部分を自分の Cookie に書き換えて実行してね。\n再設定・Cookieの更新 再設定したいときは、一度アンインストールしてから再インストールして設定し直すのが確実かな。\nもしくは、設定ファイルを使っていればCookieを書き換えるだけでいいはず（僕は使ったことないけど、Cookieの有効期限は長いからね）。\nよく使うコマンド 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # Docker の全コンテナを表示 docker ps -a # ログを確認 docker logs -f genshinhelper --tail 100 # 再起動 docker restart genshinhelper # 更新 docker pull yindan/genshinhelper docker rm -f genshinhelper # この後、簡単な使い方か高度な使い方の手順で再デプロイ # アンインストール docker rm -f genshinhelper docker image rm yindan/genshinhelper 高度な使い方 サンプルファイルをダウンロードして編集して使うこともできるよ。\nGithub: config.json Telegram: https://t.me/genshinhelperupdates/5 インストール 設定ファイルがサーバーの /etc/genshin/config.json にあると仮定して、以下のコマンドで設定をマッピングして実行するよ。\n1 2 3 4 docker run -d --name=genshinhelper \\ -v /etc/genshin:/app/genshincheckinhelper/config \\ --restart always \\ yindan/genshinhelper:latest 設定 設定ファイルは必要なパラメータだけ残して、不要なものは削除しても大丈夫。例えば Cookie だけ必要な場合とか。\n完全に書く以外に、こんな感じでシンプルにも書けるよ：\n1 2 3 { \u0026#34;COOKIE_MIHOYOBBS\u0026#34;: \u0026#34;\u0026lt;COOKIE_MIHOYOBBS\u0026gt;\u0026#34;, } 設定ファイルの項目 RANDOM_SLEEP_SECS_RANGE: ランダム待機秒数の範囲。単位は秒。\u0026ldquo;0-0\u0026rdquo; にすると遅延なし。 CHECK_IN_TIME: 毎日の自動ログイン実行時間。実行環境の時間に依存するよ。Dockerなら TZ=Asia/Tokyo でタイムゾーンを設定できる。 CHECK_RESIN_SECS: 原神の「天然樹脂」確認の間隔。単位は秒。 COOKIE_RESIN_TIMER: 樹脂確認を有効にするアカウントのCookie。 SHOPTOKEN: WeChatポイントモールのトークン（パケットキャプチャで取得）。 ONEPUSH: 通知設定。notifier に通知サービス名、params に必要なパラメータを入れるよ。詳細は後述。 OnePush 通知パラメータ一覧 通知名 / notifier: bark\nパラメータ / params:\n{\u0026lsquo;required\u0026rsquo;: [\u0026lsquo;key\u0026rsquo;], \u0026lsquo;optional\u0026rsquo;: [\u0026rsquo;title\u0026rsquo;, \u0026lsquo;content\u0026rsquo;, \u0026lsquo;sound\u0026rsquo;, \u0026lsquo;isarchive\u0026rsquo;, \u0026lsquo;icon\u0026rsquo;, \u0026lsquo;group\u0026rsquo;, \u0026lsquo;url\u0026rsquo;, \u0026lsquo;copy\u0026rsquo;, \u0026lsquo;autocopy\u0026rsquo;]}\n通知名 / notifier: custom\nパラメータ / params:\n{\u0026lsquo;required\u0026rsquo;: [\u0026lsquo;url\u0026rsquo;], \u0026lsquo;optional\u0026rsquo;: [\u0026lsquo;method\u0026rsquo;, \u0026lsquo;datatype\u0026rsquo;, \u0026lsquo;data\u0026rsquo;]}\n通知名 / notifier: dingtalk\nパラメータ / params:\n{\u0026lsquo;required\u0026rsquo;: [\u0026rsquo;token\u0026rsquo;], \u0026lsquo;optional\u0026rsquo;: [\u0026rsquo;title\u0026rsquo;, \u0026lsquo;content\u0026rsquo;, \u0026lsquo;secret\u0026rsquo;, \u0026lsquo;markdown\u0026rsquo;]}\n通知名 / notifier: discord\nパラメータ / params:\n{\u0026lsquo;required\u0026rsquo;: [\u0026lsquo;webhook\u0026rsquo;], \u0026lsquo;optional\u0026rsquo;: [\u0026rsquo;title\u0026rsquo;, \u0026lsquo;content\u0026rsquo;, \u0026lsquo;username\u0026rsquo;, \u0026lsquo;avatar_url\u0026rsquo;, \u0026lsquo;color\u0026rsquo;]}\n通知名 / notifier: pushplus\nパラメータ / params:\n{\u0026lsquo;required\u0026rsquo;: [\u0026rsquo;token\u0026rsquo;, \u0026lsquo;content\u0026rsquo;], \u0026lsquo;optional\u0026rsquo;: [\u0026rsquo;title\u0026rsquo;, \u0026rsquo;topic\u0026rsquo;, \u0026lsquo;markdown\u0026rsquo;]}\n通知名 / notifier: qmsg\nパラメータ / params:\n{\u0026lsquo;required\u0026rsquo;: [\u0026lsquo;key\u0026rsquo;], \u0026lsquo;optional\u0026rsquo;: [\u0026rsquo;title\u0026rsquo;, \u0026lsquo;content\u0026rsquo;, \u0026lsquo;mode\u0026rsquo;, \u0026lsquo;qq\u0026rsquo;]}\n通知名 / notifier: serverchan\nパラメータ / params:\n{\u0026lsquo;required\u0026rsquo;: [\u0026lsquo;sckey\u0026rsquo;, \u0026rsquo;title\u0026rsquo;], \u0026lsquo;optional\u0026rsquo;: [\u0026lsquo;content\u0026rsquo;]}\n通知名 / notifier: serverchanturbo\nパラメータ / params:\n{\u0026lsquo;required\u0026rsquo;: [\u0026lsquo;sctkey\u0026rsquo;, \u0026rsquo;title\u0026rsquo;], \u0026lsquo;optional\u0026rsquo;: [\u0026lsquo;content\u0026rsquo;, \u0026lsquo;channel\u0026rsquo;, \u0026lsquo;openid\u0026rsquo;]}\n通知名 / notifier: telegram\nパラメータ / params:\n{\u0026lsquo;required\u0026rsquo;: [\u0026rsquo;token\u0026rsquo;, \u0026lsquo;userid\u0026rsquo;], \u0026lsquo;optional\u0026rsquo;: [\u0026rsquo;title\u0026rsquo;, \u0026lsquo;content\u0026rsquo;, \u0026lsquo;api_url\u0026rsquo;]}\n通知名 / notifier: wechatworkapp\nパラメータ / params:\n{\u0026lsquo;required\u0026rsquo;: [\u0026lsquo;corpid\u0026rsquo;, \u0026lsquo;corpsecret\u0026rsquo;, \u0026lsquo;agentid\u0026rsquo;], \u0026lsquo;optional\u0026rsquo;: [\u0026rsquo;title\u0026rsquo;, \u0026lsquo;content\u0026rsquo;, \u0026rsquo;touser\u0026rsquo;, \u0026lsquo;markdown\u0026rsquo;]}\n通知名 / notifier: wechatworkbot\nパラメータ / params:\n{\u0026lsquo;required\u0026rsquo;: [\u0026lsquo;key\u0026rsquo;], \u0026lsquo;optional\u0026rsquo;: [\u0026rsquo;title\u0026rsquo;, \u0026lsquo;content\u0026rsquo;, \u0026lsquo;markdown\u0026rsquo;]}\n通知設定の例 1 2 3 4 5 telegram ONEPUSH={\u0026#34;notifier\u0026#34;:\u0026#34;telegram\u0026#34;,\u0026#34;params\u0026#34;:{\u0026#34;markdown\u0026#34;:false,\u0026#34;token\u0026#34;:\u0026#34;xxxx\u0026#34;,\u0026#34;userid\u0026#34;:\u0026#34;xxx\u0026#34;}} discord ONEPUSH={\u0026#34;notifier\u0026#34;:\u0026#34;discord\u0026#34;,\u0026#34;params\u0026#34;:{\u0026#34;markdown\u0026#34;:true,\u0026#34;webhook\u0026#34;:\u0026#34;https://discord.com/api/webhooks/xxxxxx\u0026#34;}} Docker の設定ファイルマッピングディレクトリは /etc/genshin:/app/genshincheckinhelper/config だよ。\n","date":"2022-06-09T13:33:42+08:00","permalink":"https://blog.yexca.net/ja/archives/47/","title":"原神自動ログイン (Linux サーバー Docker)"},{"content":" 📢 この記事は Gemini-3-flash によって翻訳されました はじめに Markdownの使い方 を学んでから、すごく使い勝手がいいなって感じてる（最近の記事は全部Markdownで書いてるんだ）。プログラミングや GitHubでのサイト作成 でMarkdownに触れる機会も多いし、普段プログラミングでVS Codeを使ってるから（嘉然を見てるし）、リアルタイムプレビューができるか調べてみたよ。\nショートカットキー Markdownファイル（.mdファイル）の画面で、ファイル内を一度クリックして（カーソルをファイルの中に置いて）、CTRL+K を押した後に V を押せばOK。この時、英字入力モードになっているか注意してね。\nこれがリアルタイムプレビューで、CTRL+Shift+V を押すと新しいウィンドウでプレビューを開くことができるよ。\nボタン Markdownファイルの右上に「側面にプレビューを表示」ボタンがあるから、それをクリックするだけでも大丈夫。\nコマンドパレット CTRL+Shift+P を押してコマンドパレットを開いて、markdown と入力すれば、いくつかコマンドが表示されるよ。\n参考記事 Visual Studio Code 编写并实时预览 Markdown ","date":"2022-06-09T00:03:34+08:00","permalink":"https://blog.yexca.net/ja/archives/46/","title":"VS CodeでMarkdownをリアルタイムプレビューする方法"},{"content":" 📢 この記事は gemini-2.5-flash によって翻訳されました はじめに まず、俺は嘉心糖じゃないんだ。ただめっちゃ可愛いなって思っただけ（最初、嘉然ってことすら知らなかったんだよね）。あと、このバグ多くて、自動起動が毎回は発動しないんだけど、それでも彼女が可愛すぎるんだよな〜。\nそれと、この拡張機能は背景も変えられるんだけど、個人的にはあんまり好きじゃないから変えてないや。\nプレビューはこちら インストール VS Code を開いて、拡張機能 で A-SOUL-live2d を検索してインストールしてね。\n拡張機能のURLはこちら： A-SOUL-live2d - Visual Studio Marketplace ぶっちゃけ、直接拡張機能のページ見ればインストール方法載ってるから、俺の書いたクソ記事読まなくても大丈夫だよ\n簡単な使い方 インストールが終わったら VS Code を再起動してね。そしたらリソースビューの一番下に LIVE2D-A-SOUL って表示されるから、そこを展開（開いて）して。（もし開かなかったら、VS Codeをもう一度再起動してみてね）\n次に、追加設定 のところでプラグインの依存ファイルを生成して、VS Codeを再起動したら、live2dを起動をクリック。\nそうすると右下に嘉然が出てくるよ！マウスを上に持って行って、右上の三番目のアイコンをドラッグすると位置を動かせるし、一番目をクリックするとサイズを変えられるんだ。\n位置とサイズを調整したら、設定情報 のところで自動起動をオンにして、現在の設定を保存 をクリックすれば、VS Codeを開くたびに嘉然に会えるようになるよ〜。\nその他 以下はプラグインの説明からコピペしてきたよ。\n基本操作\nlive2dの起動、停止： 文字通り、看板キャラクターを起動するよ。初期位置は右下。 現在の設定を保存： live2dのサイズ変更や位置のドラッグ調整後、情報を保存できる。次回起動時に自動で反映されるよ。 デフォルト位置にリセット： 現在の位置がおかしくて、ドラッグで動かせない時にリセットして使うことができるよ。【拡大縮小サイズもリセットされる】 背景画像 クリックで切り替え： ボタンはキャラクターの右側にある二番目のアイコンだよ。 背景画像を保存： 現在の背景画像が存在する場合のみ有効になるよ。一枚しか保存できなくて、再度クリックすると古いものが上書きされる。 背景画像を読み込む： 保存した背景画像を読み込むよ。 定期的に切り替え： 文字通り。切り替えボタンが回転しているか見て、定期切り替え機能がオンになっているか判断できるよ。 背景画像のスタイル設定 背景画像をダウンロード 設定情報\n自動起動： 文字通り。オンにすると、VS Code起動時にlive2dも自動で起動するよ。 位置固定： キャラクターの位置を決める基準になる隅。 追加設定\nプラグイン依存ファイル： プラグイン依存ファイルは、プラグインを初めてインストールして起動した時に自動で生成されるよ。 生成： live2dが正常に起動しない時、このボタンをクリックして、強制的に設定情報を上書きして再生成を試してみてね。 削除： このプラグインをアンインストールする前に、できるだけ先にこの操作を実行してみてね。プラグインによるVS Codeファイルへの全ての変更を削除できるよ。 キャラクター機能\nマウスに視線追従【欠点：ページ全体への追従はまだできないよ】 クリックでインタラクション A-SOULファン向けナビゲーションサイトへの入り口 背景画像を切り替え モデルを切り替え スケートリンク オーディオテスト A-SOUL二次創作サイトへの入り口 モデルの出典 警告について 使うとCode破損の警告が出るんだけど、原作者さんがこう言ってるよ。\nこのプラグインはVS CodeのJSファイルを変更して動作するんだ。 だから、初回インストール時やVS Codeのアップデート時に、以下の警告が出るけど、【今後表示しない】を選択してね。\n音声サポート 現在のプラグインは簡単な音声テストだけだから、今のところこの機能は気にしなくて大丈夫。\nVS Codeが使ってるElectronのバージョンにはffmpegが含まれてないんだ 。だから、付属のffmpegダイナミックリンクライブラリを置き換えないと正常に再生できないよ（VS Codeがアップデートされるたびに、また置き換えなきゃいけないんだ）。\nVS Code for Windows 1.31.0 - 1.35.1 では置き換え不要だったけど、1.36.0 以降はそういう特典はなしだよ\nVS Code for macOS 1.43+ は置き換え後にクラッシュするよ 解決策 アンインストール まず追加設定で削除を実行してから、拡張機能の画面でプラグインをアンインストールすればOKだよ。\n","date":"2022-06-01T06:01:00+08:00","permalink":"https://blog.yexca.net/ja/archives/45/","title":"VS Code 右下の嘉然"},{"content":" 📢 この記事は ChatGPT によって翻訳されました はじめに 最近 Github Pages を使って個人ページを作りました（今は削除済み）。この記事では Github Pages でのサイト構築方法および独自ドメインの設定について記録します。\n本記事では CMS 等は使用せず、Markdown ファイル1つで書いた簡易なものです。\nGithub リポジトリの作成 まず Github に登録し、 新しいリポジトリを作成 します。\nこのときの Repository name は username.github.io としてください。たとえば自分のユーザー名が yexca の場合、yexca.github.io とします。\nGit 環境のインストール Windows では Git の公式サイトから インストーラをダウンロード してインストールすればOKです。\nインストール後、Git Bash を開き以下を入力します：\n1 2 git config --global user.name \u0026#34;Your Name\u0026#34; git config --global user.email \u0026#34;email@example.com\u0026#34; 自分の場合はこうです：\n1 2 git config --global user.name \u0026#34;yexca\u0026#34; git config --global user.email \u0026#34;yexca@duck.com\u0026#34; Github Desktop の利用 インストール Git 操作に慣れていればスキップしても構いません（慣れてる人はこの記事を読まない気がしますが）\nGithub Desktop 公式サイト からダウンロードしてインストールします。\nリポジトリをクローン Github Desktop を起動し、ログイン後に空フォルダを選択し、先ほど作成したリポジトリをクローンします。\nソフトウェア右側に変更履歴と各種操作が表示されます。\nここでは VS Code で開く（Open in Visual Studio Code）を選びます。\nサイトの作成 README.md を作成して Markdown で編集します（ついでに自分の Markdown ノートも見てね）。\n編集後に保存し、Github Desktop で Commit to main を押し、続けて Push origin をクリックします。\nこれで https://username.github.io にアクセスすれば自分のサイトが表示されます（しばらく反映に時間がかかることがあります）\n独自ドメインの設定 Github Pages 側設定 リポジトリページの Settings → 左側 Pages → Custom domain 欄に独自ドメインを入力し Save。\n※同画面で Jekyll テーマも選べます。\nDNS 側設定 ドメイン管理パネルにて CNAME レコードを追加し、username.github.io に向けます（username は自分の Github アカウント名）\nHTTPS の設定 Github 公式の HTTPS がうまく機能しなかったため、 Cloudflare を使用しました。\nCloudflare の DNS 管理で「プロキシを有効化」し、「SSL/TLS」→「エッジ証明書」→「常時 HTTPS」をオンにします。\n他の構築方法 私はブログ用途ではないため、Markdown 1枚の簡易ページで済ませましたが、本格的なブログを作る場合は以下のような静的サイトジェネレータを使うと便利です。\nJekyll ：Github 公式サポート VuePress 日本語 Gitbook：ドキュメント向き LOFFER Gridea ：GUI ベースの静的ブログクライアント Hexo ：高速・簡潔なブログフレームワーク Hugo ：ビルド速度最強クラス 参考リンク GitHub Pages クイックスタート - GitHub Docs GitHub Pages ブログ：独自ドメイン・HTTPS・CAA GitHub Pages 構築チュートリアル Git インストール - 廖雪峰の公式サイト ","date":"2022-05-28T15:30:43+08:00","permalink":"https://blog.yexca.net/ja/archives/44/","title":"Github Pages でのサイト構築と独自ドメインの設定"},{"content":" 📢 この記事は ChatGPT によって翻訳されました はじめに 最近、 クラウドサイト を作る過程で Markdown に触れましたが、非常に使いやすいことに気付き、学習ノートとしてまとめることにしました。\nオンラインエディタ を使いながら学んでもよいし、 ローカルエディタ を導入してもよいでしょう。\n私自身は Typora を使用しています。\n復習には Markdown チートシート をどうぞ。\n見出し # + 半角スペース + 見出し名で作成し、1～6段階（HTML の h1～h6）に対応します。\n1 2 3 4 5 6 # 見出し1 ## 見出し2 ### 見出し3 #### 見出し4 ##### 見出し5 ###### 見出し6 一般的なウェブページでは、h1 はページタイトル、h2 以下が本文になります。h4 まであれば十分です。\n改行 前の行の末尾に「半角スペースを2つ以上 + 改行」で改行できます。一部エディタでは自動的に処理されます。\n1 2 これは1行目（スペースあり） これは2行目 結果：\nこれは1行目（スペースあり） これは2行目\n斜体・太字 斜体は *テキスト*、太字は **テキスト**、両方なら ***テキスト***。\n1 2 3 *斜体* **太字** ***斜体かつ太字*** 結果：\n斜体 太字 斜体かつ太字\n引用 行頭に \u0026gt; を付けます。\n1 2 3 \u0026gt; 引用レベル1 \u0026gt;\u0026gt; 引用レベル2 \u0026gt;\u0026gt;\u0026gt; 引用レベル3 結果：\n引用レベル1\n引用レベル2\n引用レベル3\nリスト 番号付きリスト 数字. 半角スペース 内容\n1 2 3 1. 項目1 2. 項目2 3. 項目3 箇条書きリスト -、+、* のいずれかを使用（統一推奨）、インデントで階層化。\n1 2 3 4 5 - 第一項目 - 子項目1 - 子項目2 - 孫項目 - 第二項目 コード インラインコード `コード` で囲みます。\n1 2 `コード` ``これは \\` を含むコードです`` ブロックコード 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ```c #include\u0026lt;stdio.h\u0026gt; int main() { printf(\u0026#34;Hello World\u0026#34;); } ``` ``` 結果： ```c #include\u0026lt;stdio.h\u0026gt; int main() { printf(\u0026#34;Hello World\u0026#34;); } 水平線 3つ以上の *、-、_ のみを使って改行。\n1 *** 結果：\nリンク 簡易リンク 1 2 \u0026lt;https://yexca.net\u0026gt; \u0026lt;yexca@duck.com\u0026gt; 結果：\nhttps://yexca.net yexca@duck.com テキスト付きリンク 1 2 [ブログ](https://blog.yexca.net) [ブログ](https://blog.yexca.net \u0026#34;実は Hiyoung と共同\u0026#34;) 参照型リンク 1 2 3 4 [blog]: https://blog.yexca.net [contact]: \u0026lt;mailto:yexca@duck.com\u0026gt; これは [ブログ][blog] です。連絡は [こちら][contact] 画像 1 ![alt](画像URL \u0026#34;タイトル\u0026#34;) 例：\n1 ![背景](https://cdn.statically.io/gh/yexca/picx-images-hosting@master/2023/04-网站背景/blog-background.2p10z489pjc0.webp \u0026#34;背景画像\u0026#34;) 画像 + リンク：\n1 [![画像](URL)](リンク先) エスケープ Markdown の記号をそのまま表示したい時は \\ をつけます。\n1 2 これは * 斜体になります これは \\* そのまま表示 HTML挿入 1 2 3 4 \u0026lt;details\u0026gt; \u0026lt;summary\u0026gt;クリックで展開\u0026lt;/summary\u0026gt; 本文です \u0026lt;/details\u0026gt; Hugoテーマによっては HTML を正しく表示できないことがあります。\n表 1 2 3 | ヘッダ | 内容 | 備考 | |:------|:----:|----:| | 左寄せ | 中央 | 右寄せ | 結果：\nヘッダ 内容 備考 左寄せ 中央 右寄せ 打ち消し線 1 私は ~~戦争文学博士~~ Warma が好き 結果：\n私は 戦争文学博士 Warma が好き\nチェックリスト 1 2 - [ ] 未完了 - [x] 完了 結果：\n未完了 完了 絵文字 コピー貼り付け Emojipedia から絵文字をコピーして貼るだけ。\nショートコード : で囲みます（要対応環境）\n1 :blush: :smiley: 結果：\n😊 😃\n脚注 1 2 3 4 5 参考[^1]、GitHub[^2]、ユーザー[^yexca] [^1]: 注釈テキスト [^2]: [GitHub](https://github.com/yexca) [^yexca]: [プロフィール](https://lit.link/yexca) 参考リンク Markdown公式ガイド Markdown学習資料 ","date":"2022-05-28T00:59:23+08:00","permalink":"https://blog.yexca.net/ja/archives/43/","title":"Markdown 概要（学習ノート）"},{"content":" 📢 この記事は gemini-3-flash-preview によって翻訳されました はじめに 俺の環境だと、直接接続ならゲームに入れるんだけど、加速器（アクセラレータ）とかを通すと入れなくなっちゃうんだ。毎回ゲームを起動するたびにVPNを切るのも面倒だし、いろいろ調べてみたけど解決策が見つからなかったから、この記事を書くことにしたよ。（ちなみにゲームはiOSの日本版）\n本題 ログファイルを確認して、ゲームに入るときに接続されるドメインを特定したよ。\n以下のドメインを「DIRECT」に追加すればOK。\n1 sekai.colorfulpalette.org あとがき 本当はもっと詳しく書こうと思ったんだけど、グローバル版とか台湾版も出てるみたいなんだよね。全部詳しく書いて検証するとなるとかなり時間がかかりそうだし……まあ、面倒だからこのへんで（笑）\n","date":"2022-05-19T15:01:25+08:00","permalink":"https://blog.yexca.net/ja/archives/42/","title":"プロセカのIPルール"},{"content":" 📢 この記事は gemini-3-flash-preview によって翻訳されました この記事は Hiyoung が書いたものだよ。\n管理者ユーザーを追加する： 1、ユーザーを新しく作成する。ここでは temp_test というユーザーを作るよ。\nadduser temp_test **2、新しいユーザーのパスワードを設定する** passwd temp_test\n3、sudoers ファイルの権限を編集可能に変更する\nchmod -v u+w /etc/sudoers\n4、vim を使って sudoers ファイルを編集する\nvim /etc/sudoers\n5、sudoers ファイルに以下の内容を追加する\nroot ALL=(ALL) ALL という行を探して、\nその後に temp_user ALL=(ALL) ALL を追加しよう。\nもし、新しいユーザーが sudo を使うときにパスワードを入力したくない場合は、最後の ALL を NOPASSWD:ALL に変えるだけでOKだよ。\n6、sudoers ファイルの権限を書き込み不可（読み取り専用）に戻す\nchmod -v u-w /etc/sudoers\n7、ユーザーを削除する\nuserdel temp_test\n","date":"2022-05-16T15:29:21+08:00","permalink":"https://blog.yexca.net/ja/archives/41/","title":"Linuxでユーザーと管理者ユーザーを追加する方法"},{"content":" 📢 この記事は gemini-3-flash-preview によって翻訳されました この記事は Hiyoung が書いたよ。\nLinuxは存在しないフォルダを自動で作ってくれないんだ。mv コマンドを使うときは、移動先のフォルダがあるかどうか気をつけないと、ただのファイル名の変更になっちゃうよ。 ファイルのハードリンクを作るのは、実際にはそのファイルに別の名前を割り当てるようなもの（データ部分は変わらない）。C言語でそのファイルへのポインタを作るのと似てるね。 シンボリックリンクを作るのは、Windowsのショートカットみたいな感じかな。ls -li コマンドを使うと、違いがはっきりわかるよ。ハードリンクは元のファイルとバイト数が同じだけど、シンボリックリンクは違うんだ。 エイリアス（alias）でコマンドを作る：同じ行で複数のコマンドを同時に実行するときは ; で区切る。type を使えば、そのコマンドがすでにシステムにあるか調べられるよ。注意点は、alias で作ったコマンドはシェルセッションを閉じると消えちゃうこと（設定ファイルに書き込んでないからね）。消したいときは unalias を使おう。 \u0026gt; を使ったリダイレクトは元のファイルを上書きしちゃうけど、\u0026gt;\u0026gt; ならファイルの末尾に追記してくれるよ。 エラーメッセージを（画面に出さずに）ファイルに書き込みたいときは 2\u0026gt; が使える。 標準出力と標準エラーを同じファイルにリダイレクトする方法は2つ：1つ目は、リダイレクトするファイル名の後に 2\u0026gt;\u0026amp;1 を付けること。2つ目は、リダイレクト記号の前に \u0026amp; を付けること。 方法1（古いバージョンのシェルでも使えるよ）\n方法2\n","date":"2022-04-30T04:24:07+08:00","permalink":"https://blog.yexca.net/ja/archives/40/","title":"Linux 備忘録"},{"content":" 📢 この記事は gemini-3-flash-preview によって翻訳されました この記事は Hiyoung が書いたものだよ。\n元の記事: https://blog.hiyoung.xyz/2022/09/03/3256bd2afccc/ 一、仮想マシンの設定 メニューバーから「編集」→「仮想ネットワークエディター」を選んでダイアログを開く。NAT 接続を選択して、サブネット IP を適当に設定したら、「NAT 設定」をクリックしてサブネットマスクとゲートウェイを確認しよう。これは後で固定 IP を設定する時に使うからね。\nVMnet8 モードで NAT 接続を選んで、DHCP サービスのチェックを外す。\n「NAT 設定」をクリックして、その時のゲートウェイをメモしておく。\nシステムのネットワーク設定で、VMnet8 のネットワーク構成を確認してね。\n二、Linux ホストの設定 root 権限で cd /etc/sysconfig/network-scripts と入力してフォルダに移動。ls コマンドでフォルダ内のファイルを確認して、下の画像のように ifcfg-en*** というファイルを探そう。\nvim ifcfg-en*** でファイルを開く。\nBOOTPROTO=\u0026quot;dhcp\u0026quot; を BOOTPROTO=\u0026quot;static\u0026quot; に、ONBOOT=\u0026quot;no\u0026quot; を ONBOOT=\u0026quot;yes\u0026quot; に書き換える。\nそして、その下に以下の項目を追加してね。\nIPADDR=your ip（固定 IP アドレス）\nNETMASK=your netmask（サブネットマスク、普通は 255.255.255.0）\nGATEWAY=your gateway（ゲートウェイアドレス）\nDNS1=8.8.8.8（国内外のパブリック DNS で大丈夫）\nDNS2=8.8.4.4\n最後に :wq と入力して保存して終了すれば OK！\n","date":"2022-04-22T18:13:42+08:00","permalink":"https://blog.yexca.net/ja/archives/39/","title":"仮想マシンで固定 IP を設定する（CentOS を例に）"},{"content":" 📢 この記事は gemini-3-flash-preview によって翻訳されました この記事は Hiyoung によって執筆されたよ。\n元の記事: https://blog.hiyoung.xyz/2022/08/01/84a03702e5a9/ （参考動画： https://www.bilibili.com/video/BV1WY4y1H7d3?p=1 ）\n一、基礎編 1.1 Linuxファイルシステムのディレクトリ構造 出典：菜鳥教程 (Runoob) 図の中の小さな矢印は、そのファイルの実際の場所が別の場所にあることを示しているよ。\n/bin： binはBinaries（バイナリ）の略で、このディレクトリには最も頻繁に使用されるコマンドが格納されているよ。 /boot：\nここにはLinuxを起動する際に使用されるコアファイルが置かれているよ。接続ファイルやイメージファイルも含まれるんだ。 /dev ：\ndevはDevice（デバイス）の略。このディレクトリにはLinuxの外部デバイスが置かれているよ。Linuxではデバイスへのアクセス方法とファイルへのアクセス方法は同じなんだ。 /etc：\netcはEtcetera（エトセトラ）の略。このディレクトリは、システム管理に必要なすべての設定ファイルとサブディレクトリを格納するために使われるよ。 /home：\nユーザーのホームディレクトリだね。Linuxでは各ユーザーに自分のディレクトリが割り当てられていて、通常はユーザーのアカウント名がディレクトリ名になるよ（上の図のalice、bob、eveのようにね）。 /lib：\nlibはLibrary（ライブラリ）の略。このディレクトリには、システムで最も基本的な動的リンク共有ライブラリが格納されているよ。WindowsでいうDLLファイルみたいな役割だね。ほとんどすべてのアプリケーションがこれらの共有ライブラリを必要とするんだ。 /lost+found：\nこのディレクトリは通常は空だけど、システムが不正に終了した後に、いくつかのファイルがここに置かれることがあるよ。 /media：\nLinuxシステムはUSBメモリや光学ドライブなどのデバイスを自動的に識別するんだ。識別されると、Linuxはそのデバイスをこのディレクトリの下にマウントするよ。 /mnt：\nシステムが提供しているこのディレクトリは、ユーザーが他の一時的なファイルシステムをマウントするためのものだよ。光学ドライブを /mnt/ にマウントして、そのディレクトリに入れば中身を確認できるってわけ。 /opt：\noptはoptional（オプション）の略。これはホストに追加でインストールするソフトウェアを置くためのディレクトリだよ。例えばORACLEデータベースをインストールするならここに入れることができるね。デフォルトは空だよ。 /proc：\nprocはProcesses（プロセス）の略。/procは擬似ファイルシステム（仮想ファイルシステム）の一種で、現在のカーネルの実行状態に関する一連の特殊なファイルを格納しているよ。このディレクトリは仮想的なもので、システムメモリの構成を反映しているんだ。ここを直接覗くことでシステム情報を取得できるよ。\nこのディレクトリの内容はハードディスク上ではなくメモリ上にあるんだ。中の特定のファイルを直接修正することもできるよ。例えば、次のコマンドでホストへのpingをブロックして、他の人が自分のマシンにpingできないように設定したりできるんだ：echo 1 \u0026gt; /proc/sys/net/ipv4/icmp_echo_ignore_all /root：\nこのディレクトリはシステム管理者、つまりスーパーユーザー（特権ユーザー）のホームディレクトリだよ。 /sbin：\nsはSuper Userの意味で、Superuser Binaries（スーパーユーザー用バイナリ）の略。ここにはシステム管理者が使用するシステム管理プログラムが格納されているよ。 /selinux：\nこのディレクトリはRedhat/CentOS特有のもの。SELinuxはWindowsのファイアウォールのようなセキュリティ機構だけど、仕組みはかなり複雑だよ。このディレクトリにはSELinux関連のファイルが置かれているんだ。 /srv：\nこのディレクトリには、いくつかのサービスが起動した後に必要となるデータが格納されるよ。 /sys：これはLinux 2.6カーネルの大きな変更点の一つ。このディレクトリには、2.6カーネルで新しく登場したsysfsというファイルシステムがインストールされているよ。sysfsは、プロセス情報のproc、デバイス情報のdevfs、擬似端末のdevptsという3つのファイルシステムの情報を統合したものなんだ。このファイルシステムはカーネルデバイスツリーを直感的に反映しているよ。カーネルオブジェクトが作成されると、対応するファイルやディレクトリもカーネルオブジェクトサブシステム内に作成されるんだ。 /tmp：\ntmpはtemporary（一時的）の略。このディレクトリは一時的なファイルを置くために使われるよ。 /usr：\nusrはunix shared resources（共有リソース）の略。これは非常に重要なディレクトリで、ユーザーの多くのアプリケーションやファイルがここに置かれているよ。Windowsの Program Files ディレクトリみたいなものだね。 /usr/bin：\nシステムユーザーが使用するアプリケーション。 /usr/sbin：\nスーパーユーザーが使用する、より高度な管理プログラムやシステムデーモン。 /usr/src：\nカーネルソースコードのデフォルトの配置場所。 /var：\nvarはvariable（変数）の略。このディレクトリには、絶えず拡張され続けるものが格納されているよ。頻繁に修正されるディレクトリはここに入れるのが一般的だね。各種ログファイルも含まれるよ。 /run：\n一時的なファイルシステムで、システム起動時からの情報を保存しているよ。システムを再起動すると、このディレクトリ内のファイルは削除されるかクリアされる必要があるんだ。もしシステムに /var/run ディレクトリがあるなら、それは /run を指すようにしておくべきだね。 1.2 ファイルの基本属性 1.2.1 基本属性 Linuxでは、最初の文字がそのファイルがディレクトリなのか、普通のファイルなのか、あるいはリンクファイルなのかを表しているよ。\nd であればディレクトリ – であればファイル l であればリンクファイル (link file) b であればデバイスファイル内のストレージインターフェースデバイス（ランダムアクセス可能デバイス） c であればデバイスファイル内のシリアルポートデバイス（キーボードやマウスなど、一方向の読み取りデバイス） 続く文字は3つで1セットになっていて、すべて rwx の3つのパラメータの組み合わせなんだ。r は読み取り可能 (read)、w は書き込み可能 (write)、x は実行可能 (execute) を表しているよ。この3つの権限の位置は固定で、権限がない場合はマイナス記号 – が表示されるんだ。\n各ファイルの属性は、左側の最初の部分にある10文字で決まるよ（下の図のようにね）。\n左から右に 0-9 の数字で表すとこうなるよ。\n第0位はファイルタイプ。第 1-3 位は所有者（そのファイルのオーナー）が持つ権限。第4-6位は所有グループ（オーナーと同じグループのユーザー）が持つ権限。第7-9位はその他のユーザーが持つ権限。\nその中で、第 1, 4, 7 位は読み取り権限。r なら権限あり、– なら権限なし。\n第 2, 5, 8 位は書き込み権限。w なら権限あり、– なら権限なし。第 3, 6, 9 位は実行権限。x なら権限あり、– なら権限なし。\n1.2.2 Linuxファイルの所有者とグループ 1、chgrp：ファイルグループを変更する 構文：\n1 chgrp [-R] グループ名 ファイル名 パラメータオプション\n-R：ファイルグループを再帰的に変更する。つまり、あるディレクトリのグループを変更する際、-Rを付ければ、そのディレクトリ下のすべてのファイルのグループも変更されるよ。 2、chown：ファイル所有者を変更する（同時にグループも変更可能） 構文：\n1 2 chown [–R] 所有者名 ファイル名 chown [-R] 所有者名：グループ名 ファイル名 /root ディレクトリ（~）に移動して、install.log の所有者を bin アカウントに変更する例：\n1 2 3 4 [root@www ~] cd ~ [root@www ~]# chown bin install.log [root@www ~]# ls -l -rw-r--r-- 1 bin users 68495 Jun 25 08:53 install.log install.log の所有者とグループを root に戻す例：\n1 2 3 [root@www ~]# chown root:root install.log [root@www ~]# ls -l -rw-r--r-- 1 root root 68495 Jun 25 08:53 install.log 3、chmod：ファイルの9つの属性を変更する Linuxのファイル属性の設定方法には、数字による方法と記号による方法の2種類があるよ。\nLinuxファイルの基本権限は9つあって、owner/group/others (所有者/グループ/その他) の3つの身分それぞれに read/write/execute の権限があるんだ。\nさっきのデータを復習しよう。ファイルの権限文字が -rwxrwxrwx の場合、この9つの権限は3つずつセットになっているよね！数字を使って各権限を表すことができるんだけど、それぞれのスコア対応表は以下の通りだよ：\nr: 4 w: 2 x: 1 各身分 (owner/group/others) ごとの3つの権限 (r/w/x) のスコアを合算するんだ。例えば、権限が -rwxrwx— の場合、スコアはこうなるよ：\nowner = rwx = 4+2+1 = 7 group = rwx = 4+2+1 = 7 others = \u0026mdash; = 0+0+0 = 0 だから、権限を変更する時、そのファイルの権限数字は 770 になるんだ。権限変更コマンド chmod の構文はこんな感じ：\n1 chmod [-R] xyz ファイルまたはディレクトリ オプションとパラメータ：\nxyz : さっき説明した数字タイプの権限属性で、rwx の数値の合計だよ。 -R : 再帰的 (recursive) に変更を適用する。サブディレクトリ内のすべてのファイルも一緒に変更されるよ。 例えば、.bashrc というファイルのすべての権限を有効にしたい場合、コマンドはこうなるよ：\n1 2 3 4 5 [root@www ~]# ls -al .bashrc -rw-r--r-- 1 root root 395 Jul 4 11:45 .bashrc [root@www ~]# chmod 777 .bashrc [root@www ~]# ls -al .bashrc -rwxrwxrwx 1 root root 395 Jul 4 11:45 .bashrc もし権限を -rwxr-xr– にしたいなら？スコアは [4+2+1][4+0+1][4+0+0]=754 になるね。\n4、記号タイプによるファイル権限の変更 もう一つの変更方法があるよ。これまでの紹介からわかる通り、基本的には9つの権限が3つのグループに分かれているよね：\nuser：ユーザー group：グループ others：その他 そこで、u, g, o を使ってこれら3つの身分の権限を表すことができるんだ。\nさらに、a は all（すべての身分）を表すよ。読み書きの権限は r, w, x と書けるから、下の表のような感じで使えるよ：\n| chmod | u g o a | +(追加) -(削除) =(設定) | r w x | ファイルまたはディレクトリ | |---|---|---|---|---| もしファイル権限を -rwxr-xr– に設定したいなら、chmod u=rwx,g=rx,o=r ファイル名 とすれば設定できるよ：\n1 2 3 4 5 6 touch test1 // test1 ファイルを作成 ls -al test1 // test1 のデフォルト権限を確認 #-rw-r--r-- 1 root root 0 Nov 15 10:32 test1 chmod u=rwx,g=rx,o=r test1 // test1 の権限を修正 ls -al test1 -rwxr-xr-- 1 root root 0 Nov 15 10:32 test1 特定の権限だけを外して、他の権限は変えたくない場合はどうするかって？例えば、全員の実行権限を外したいならこうするよ：\n1 2 3 chmod a-x test1 ls -al test1 #-rw-r--r-- 1 root root 0 Nov 15 10:32 test1 1.3 vimテキスト編集 1.3.1 vimの3つのモード 基本的に vi/vim は3つのモードに分かれているよ。コマンドモード、編集モード、そして**一般モード（末行モード）**だね。\n1.3.2 vimショートカットコマンド 外部サイトを参考にしてみて： https://www.runoob.com/linux/linux-vim.html 1.4 ネットワーク設定 1.4.1 VMwareの3つのネットワーク接続モード ブリッジモード：仮想マシンが直接外部ネットワークに接続されるよ（外部から見える状態）。ホストがブリッジ（橋渡し）の役割をして、仮想マシンはホストと同じ立場でルーターから独立したIPアドレスを割り当てられるんだ。\nNATモード：ホストと仮想マシンで専用のネットワークを構築して、NATを使って仮想マシンのIP変換を行うよ（外部からは直接は見えない）。この時、仮想マシンだけで一つのローカルネットワーク（LAN）を構成するから、ホストと仮想マシンは同じネットワークセグメントにはいなくて直接通信できないんだ。そこで、仮想のネットワークカード（VMnet8）を使って、仮想マシンがいるLANに接続する仕組みになっているよ。\nホスト専用モード：このモードは仮想マシンとホストの間だけで通信させるもので、インターネットには接続しないよ。\n1.4.2 静的IPの設定 サイト内の記事を参考にしてね： 仮想マシンで静的IPを設定する（CentOSの例） 1.4.3 ホスト名の設定 1 2 3 4 5 6 7 8 9 hostname #現在のホスト名を確認 vim /etc/hostname #ホスト名を修正 #修正後に再起動すれば新しいホスト名が表示されるよ #方法二 hostnamectl set-hostname ... #即座に反映されるよ 1 2 #hostsファイルを修正 vim /etc/hosts 1.5 システム管理 1.5.1 service サービス管理 実行中のプログラムやコマンドのことを「プロセス」と呼ぶんだ。\n起動後にずっと存在し続け、メモリに常駐しているプロセスのことを、一般的に「サービス」と呼ぶよ。\n1 2 3 systemctl start|stop|restart|status サービス名 #基本構文 /usr/lib/systemd/system/ #サービスが置かれているディレクトリ ","date":"2022-04-19T02:53:27+08:00","permalink":"https://blog.yexca.net/ja/archives/38/","title":"Linuxを体系的に学ぶノート"},{"content":" 📢 この記事は Gemini-3-flash によって翻訳されました はじめに 2022年3月22日にOBSがSteamでリリースされたね。アップデートが楽になったのはいいんだけど、使うたびにSteamを起動しなきゃいけないのは、正直ちょっと面倒。\n本編 Steamライブラリの画面で OBS Studio を右クリックして、管理 -\u0026gt; ローカルファイルを閲覧 を順に選択する。\nエクスプローラーが開くから、bin/64bit または bin/32bit のパスに入って、obs64 または obs32 を見つけよう。\nこのファイルを直接クリックすればOBSが起動するよ。だから、これを「スタート」画面にピン留めしたり、ショートカットを作成したりすればOK。\n右クリックでショートカットを作成して、そのショートカットをデスクトップに置くだけで完了！\n","date":"2022-04-11T22:19:48+08:00","permalink":"https://blog.yexca.net/ja/archives/37/","title":"Steamを起動せずにOBSを開く方法"},{"content":" 📢 この記事は gemini-2.5-flash によって翻訳されました 1. タイムスタンプを調べる ウェブページを開いてみて https://member.bilibili.com/x2/creative/h5/calendar/event?ts=0 CTRL+Fを押してjointimeって入力してみて。jointimeの後ろにある数字がタイムスタンプだよ。\nタイムスタンプをコピーしてね\n2. タイムスタンプを変換する サイトを開いてみて タイムスタンプ (Unix timestamp) 変換ツール – オンラインツール 該当の場所でタイムスタンプを入力して変換ボタンをクリックすればOKだよ。\n参考文献 UPが教える！自分のBilibili登録時間を秒単位で確認する方法！哔哩哔哩 ","date":"2022-04-09T13:47:52+08:00","permalink":"https://blog.yexca.net/ja/archives/36/","title":"Bilibiliの登録時間を秒単位で調べる方法"},{"content":" 📢 この記事は Gemini-3-flash によって翻訳されました はじめに 今日記事を書いてたら、PicX が使えなくなってて \u0026ldquo;Bad credentials\u0026rdquo; って表示されたんだよね。だから解決策を探してみたよ。\n結論 結局、GitHub のトークンの有効期限が切れちゃっただけなんだ。メールボックスを確認すると、[GitHub] Your personal access token has expired っていう件名のメールが届いているはず。\nメールは3行くらいで、2行目の If this token is still needed の後にリンクがあるから、そこをクリックしてトークンを再作成すればOK。\nその時、Expiration（トークンの有効期限）の設定を忘れないようにね。 再作成した後は、PicX 側で画像ホスティングの設定を更新（リセット）する必要があるよ。\n詳しい手順はここを参考にしてね： PicX で自分専用の無料画像ホスティングを作る – yexca’Blog ","date":"2022-03-22T16:30:12+08:00","permalink":"https://blog.yexca.net/ja/archives/35/","title":"PicX で画像をアップロードする時に \"Bad credentials\" って出る問題"},{"content":" 📢 この記事は gemini-2.5-flash によって翻訳されました あと、アバター改変のチュートリアルも書いたから、これ見てね: https://vrchat.yexca.net/ はじめに 最近、友達からVRChatのピアノって自分で弾けるんだよって教えてもらったんだ。それでちょっと勉強してみたから、メモとしてこの記事を書くね。 注：たぶんPCモードでしか自動演奏できないと思う。もちろん、VRでデスクトップを投影して試してみるのもアリかもね（doge\nMIDIファイルを使わない場合 1. 準備するもの ピアノの自動演奏を実現するには、ソフトを2つとプラグインを1つインストールする必要があるよ。\n1) loopMIDI このソフトは公式サイトから直接ダウンロードできるよ。公式サイトのリンクはこれ： loopMIDI-Tobias Erichsen (tobias-erichsen.de) ファイルへの直リンク： loopMIDISetup_1_0_16_27.zip （バージョンアップで使えなくなる可能性もあるよ）\n2) Jazz-Plugin インストールするときは、デフォルトのインストールパスのままにしてね。そうしないと、ちゃんと動かないかもしれないから。\nWindows: ここからダウンロード（プラグインの公式サイトへ） （もし公式サイトのリンクからダウンロードできなかったら、 ここからもダウンロードできるよ ）\nMac OS X: ここをクリックしてダウンロード Linux版: ここをクリックしてダウンロード 3) ブラウザプラグイン Jazz-MIDI Chrome、Opera、またはその他のデュアルエンジンブラウザ（360安全ブラウザとかね）： Chromeウェブストアへ行ってインストール Chromeウェブストアにアクセスできない場合 Chrome 73より前のバージョンなら Jazz-MIDI-crx2.crx をダウンロードして使ってね。Chrome 73以降のバージョンなら Jazz-MIDI-crx3.crx をダウンロードして使ってね。\nChromeで拡張機能を開く アドレスバーに(またはここを直接クリックしてね) chrome://extensions って入力してEnterキーを押して拡張機能画面に入ってね。\nこんな感じだよ\nEdgeで拡張機能を開く アドレスバーに(またはここを直接クリックしてね) edge://extensions/ って入力してEnterキーを押して拡張機能画面に入ってね。\nこんな感じだよ\nもしポップアップが出たら、拡張機能を管理 をクリックしてね。\n拡張機能画面を開いたら まず、「開発者モード」をオンにしてね。Chromeなら右上に、Edgeなら左中にあるよ。\nあとはダウンロードしたcrxファイルを拡張機能画面に直接ドラッグ＆ドロップすればOK！\n2. 手順 1) loopMIDIを開いて、新規プロジェクトを作成 新規プロジェクトは、まず右下の New port-name に名前を入力して、それから左下の + （プラス）をクリックすれば作れるよ。\n完了するとプロジェクトが上に表示されるよ。ここでは Hello World をプロジェクト名にするね。\n2) 再生開始 \u0026lt;1\u0026gt; 再生したい曲を見つける まず、このサイトを開いてみて。 MidiShow – 業界をリードするMIDI音楽交流＆ダウンロードサイト 登録してログインしたら、再生したい曲を検索してね。\n\u0026lt;2\u0026gt; 再生設定をする こんな感じで、 Hand in Hand を例にすると、再生設定ボタンをクリックするよ。\n設定はこんな感じ。 MIDI出力デバイス は、さっきloopMIDIで新規作成したプロジェクトを選んでね。ここでは Hello World だよ。\n\u0026lt;3\u0026gt; 再生を始める そしたら、中国語圏ワールドのピアノの隣に行って、椅子を選んで座ってね。それからウェブページで再生ボタンをクリックすればOK。\nMIDIファイルを使う場合 まず、MIDIファイルがピアノ譜であることを確認してね。多重トラックのファイルだとごちゃごちゃになるかもしれないから、自分で編集してね。\n1. 準備するもの 1) loopMIDI このソフトは公式サイトから直接ダウンロードできるよ。公式サイトのリンクはこれ：\nこのソフトは公式サイトから直接ダウンロードできるよ。公式サイトのリンクはこれ： loopMIDI-Tobias Erichsen (tobias-erichsen.de) ファイルへの直リンク： loopMIDISetup_1_0_16_27.zip （バージョンアップで使えなくなる可能性もあるよ）\n2) MidiPiano このソフトは、とあるダウンロードサイトで手に入れたよ（Google検索で一番上に出てきたやつ）。\nサイトリンク： MidiPiano – Download (softonic.com) 2. 手順 1) loopMIDIで新規プロジェクトを作成 新規プロジェクトは、まず右下の「New port-name」に名前を入力して、それから左下の「+」（プラス）をクリックすれば作れるよ。\n完了するとプロジェクトが上に表示されるよ。ここでは「Hello World」をプロジェクト名にするね。\n2) MidiPianoを開いて、設定をする プレイリストをクリックして、ファイルを直接ドラッグ＆ドロップできるよ。オプションをクリックして、出力デバイスをさっきloopMIDIで作成したプロジェクトに設定してね。ここでは Hello World だよ。\nもし「MIDI入出力は同じにできません、システムがフリーズします！」ってポップアップが出たら オプションの中の MIDI入力デバイス をクリックして、さっきloopMIDIで作成したプロジェクトの選択を解除してね。それから MIDI出力デバイス に切り替えて、それをオンにしてね。\n3) 再生開始 そしたら、中国語圏ワールドのピアノの隣に行って、椅子を選んで座ってね。それから プレイリスト の中から再生したい曲を選んで、再生をクリックすればOK。\n参考資料 【VRChat】中国語圏ワールドでピアノを自動演奏する方法教えちゃうよ 哔哩哔哩 プレイヤーの選び方とプラグインのインストール方法 ","date":"2022-03-22T16:11:47+08:00","permalink":"https://blog.yexca.net/ja/archives/34/","title":"VRchatで中国語圏ワールドのピアノを自動演奏する"},{"content":" 📢 この記事は Gemini-3-flash によって翻訳されました はじめに この記事は、僕が自分で集めた無料の画像ホスティングサイト（いわゆる図床）のまとめだよ。いくつか実際に使ったことがあるものも含まれてる。もちろん、もし自分で画像ホスティング環境を作ってみたいなら、こっちの記事を読むのがおすすめだよ： PicXを使って無料で自分専用の図床を作ろう – yexca’Blog 一、路过图床 (ImgTU) 公式サイト： 路过图床 – 無料画像アップロード, 専門的な画像リンク, 無料公共画像ホスティング 高速で安定してる。1枚最大10MBまで。\n二、ImgURL 公式サイト： ImgURL 無料画像ホスティング ゲストユーザーは1日10回までアップロード可能。1枚最大5MBまで。\n三、SM.MS 公式サイト： Image Upload – SM.MS – Simple Free Image Hosting 老舗のサイト。今はゲストのアップロードは禁止されてて、一般ユーザーは1枚最大5MBまで、ストレージ容量は5GB。\n（ちなみに、このサイトの画像直リンクのドメインは loli.net なんだ）\n四、KinhPicture 公式サイト： KinhPicture – アグリゲーター図床 島主（開発者）によるアグリゲーター型の画像ホスティング。アリババ、バイドゥ、AWS S3など15種類のインターフェースに対応していて、1枚あたりの制限は2〜32MB。\n五. 极兔图床 (JituDisk) 公式サイト： 极兔图床 – 無料図床, 匿名図床, 無料CDN図床, 図床API, 専門的な画像ホスティング 最大10MBまでの画像をアップロードできる。\n六、Gimhoy 图床 公式サイト： Gimhoy 图床 - 無制限・永久無料 七、bayimg 公式サイト： bayimg – free uncensored image hosting ","date":"2022-03-20T16:54:36+08:00","permalink":"https://blog.yexca.net/ja/archives/33/","title":"画像ホスティングサイト（図床）まとめ"},{"content":" 📢 この記事は gemini-3-flash-preview によって翻訳されました はじめに この記事で紹介する方法は一般的な用途向けだよ。特別なニーズがある場合は自分で調べてみてね。\n1. Win10/Win11の標準機能を使う 1）システム標準のスクリーンショットソフト Win10/Win11には「Snipping Tool（切り取り領域とスケッチ）」っていうスクリーンショット用のソフトが入ってるんだ。使い方は2通りあるよ。\n\u0026lt;1\u0026gt; ソフトを開いて使う Win キーを押して、すべてのアプリから「Snipping Tool」を探して開くんだ。\n上の画像がソフトを開いた時の画面だよ。「新規作成」をクリックすればスクリーンショットが撮れるよ。\n\u0026lt;2\u0026gt; ショートカットキーを使う 実は上のソフトの画面にもショートカットキーが書いてあるんだけど、Win+Shift+S の3つのキーを同時に押せば、すぐにスクリーンショットを開始できるよ。\n撮った後の保存 スクリーンショットが終わると、右下の通知センターにポップアップが出るんだ。\nもしチャットツールとかで送りたいだけなら、そのままチャットの入力欄で Ctrl+V を押せば画像を貼り付けられるよ。\nローカルに保存したい場合は、通知センターの通知をクリックして、画像が表示されたら Ctrl+S で保存先を選んでね。 他の機能については、いろいろいじってみて！\n2）システム標準の Xbox Game Bar を使う Win+G を押すと Xbox Game Bar が開くよ。空白の部分をクリックするか、もう一度 Win+G を押せば閉じられるんだ。\n\u0026lt;1\u0026gt; Xbox Game Bar でスクリーンショットと録画をする 画像のように、赤枠の1番目のボタンがスクリーンショット、3番目のボタンが画面録画だよ。もう一度押すと録画終了（または画面に出ているフローティングウィンドウの停止ボタンを押す）。 もし「キャプチャ」ウィンドウが出てこなかったら、上の画像の青枠のボタンを押してみて。\n\u0026lt;2\u0026gt; ファイルの保存場所 上の画像にある赤枠の中に「全キャプチャを表示」があるから、それをクリックすると Xbox Game Bar で撮ったファイルが全部確認できるよ。それぞれのファイルの下に「ファイルの場所を開く」があるから、そこから保存フォルダに飛べるんだ。\nちなみに、デフォルトの保存パスは PC \u0026gt; ビデオ \u0026gt; キャプチャ （つまり C:\\Users\\%username%\\Videos\\Captures）だよ。スクリーンショットも録画もここに入ってる。\n2. サードパーティ製のアプリを使う サードパーティ製なら選択肢はたくさんあるけど、ここでは2つだけ紹介するね。普通はシステム標準の機能だけで十分だと思うけど。\n1）QQ/TIM/WeChat（微信）でスクリーンショットや録画をする QQ/TIM のショートカットは、スクリーンショットが Ctrl+Alt+A、画面録画が Ctrl+Alt+S。\nWeChat（微信）は Alt+A でスクリーンショットが撮れるけど、録画機能は見当たらないな。\nどちらもチャット欄の上にあるハサミアイコンの右側にある小さな矢印から、「スクリーンショット時に現在のウィンドウを隠す」の設定を変更できるよ。\n2）OBS で画面録画をする OBS の紹介 この記事のメインテーマじゃないから、公式の紹介を載せておくね。公式サイトからダウンロードしてインストールすればOK。\nOBS Studio – Free and open source software for live streaming and screen recording\n公式サイト： Open Broadcaster Software-OBS Github： obsproject/obs-studio: OBS Studio 画面録画のやり方 \u0026lt;1\u0026gt; OBS で録画する OBSを開くとこんな画面。左から2番目の「ソース」ウィンドウの下にある「＋」をクリック。\n画像のように「画面キャプチャ」を選んで、2回「OK」を押せばデスクトップ画面が表示されるよ。\n右側の「録画開始」を押せば、今のデスクトップの録画が始まるんだ。\n\u0026lt;2\u0026gt; ファイルの保存場所 左上の「ファイル」から「録画を表示」をクリックすれば、録画したファイルの保存先が開くよ。\nよくある問題：画面が表示されない場合 もし画面が真っ暗な場合は、「NVIDIA コントロールパネル」の「3D 設定の管理」で、OBS の「このプログラム用の優先グラフィックス プロセッサ」を「統合型グラフィックス」に変更してみて。\n下の画像みたいに、僕のPCはデフォルトで「統合型」になってたから、変更はしてないよ。\nこれで解決しない場合は、他の方法をググってみてね。\n","date":"2022-03-19T13:57:39+08:00","permalink":"https://blog.yexca.net/ja/archives/32/","title":"Windowsでのスクリーンショットと画面録画"},{"content":" 📢 この記事は gemini-2.5-flash-lite によって翻訳されました はじめに 最近、Beat Saber を購入した（もちろん、アルゼンチンリージョンでね）。それで、カスタム楽曲を追加したいなと思って、Steam のコメント欄で、WGzeyu さんっていうすごい人がチュートリアルを出してるって知ったんだ。でも、俺の目的はシンプルだから、そのチュートリアルはちょっと詳細すぎるんだよね。だから、この記事で要点をまとめてみることにしたよ。\n一、準備 ※注： 2022.03.25 追記：今日、関連ファイルをチェックしたら、バージョン 1.20.0 でも Mod が使えるようになったみたい！だから、直接ステップ 2 を見てね。あと、データ復旧の部分も更新したよ。\n1）ダウングレード 現在最新のバージョン 1.20.0 では Mod が使えないから、まずはダウングレードする必要があるんだ。Mod が更新されたら、またアップグレードすればいいからね。\n＜1＞バージョン 1.19.0 またはそれ以前をダウンロード WGzeyu さんが提供してるネットワークドライブからダウンロードできるよ。 WGzeyu大佬提供的网盘 で、欲しいバージョンを選んでダウンロードしてね。\nファイル直リンク： 1.19.0 steam版 ＜2＞バージョン 1.20.0 を置き換える ダウンロードしたファイルを解凍して、Steam でゲームのインストールフォルダを開く。一つ上の階層に戻って、「Beat Saber」フォルダの名前を「Beat Saber 1.20.0」に変更する。そして、さっきダウンロードしたファイルを「Beat Saber」にリネームして、このフォルダに移動させるんだ。\n＜3＞データの復旧方法 ＜1＞Steam でゲームのフォルダを開いて、UserData フォルダの中にある Beat Saber IPA を削除する。 ＜2＞以下のフォルダをコピーする（必要に応じてコピーしてね）。\nUserData （Mod の設定） CustomSabers （ライトセーバーのモデル） CustomPlatforms （ステージのモデル） CustomAvatars （アバターのモデル） CustomNotes （ブロックのモデル） ＜3＞次に、「Beat Saber 1.20.0」フォルダを開いて、コピーしたフォルダを貼り付ける。確認画面が出たら、「置き換える」を選択する。 ＜4＞「Beat Saber」フォルダを開いて、「Beat Saber_Data」フォルダに入る。CustomLevels フォルダを切り取る。 ＜5＞「Beat Saber 1.20.0」フォルダを開いて、「Beat Saber_Data」フォルダに入る。切り取ったフォルダを貼り付ける。確認画面が出たら、「置き換える」を選択する。\n最後に、「Beat Saber」フォルダを削除して、「Beat Saber 1.20.0」フォルダの名前を「Beat Saber」に変更する。\n2）関連ソフトウェア ＜1＞Mod マネージャー「ModAssistant」 このソフトウェアには英語版と中国語版があるから、好きな方を選んでダウンロードしてね。ネットワークドライブからダウンロードできるよ： 網盤連結 ファイル直リンク： ModAssistant中国語拡張版Modインストーラー、PC対応Quest非対応 ＜2＞BeatSaber 楽曲パスマネージャー これもさっきのネットワークドライブからダウンロードできるよ。ファイル直リンク： BeatSaber 楽曲パスマネージャー （バージョン 5.3、アップデートで使えなくなってるかも）\n＜3＞ResilioSync これもさっきのネットワークドライブからダウンロードできるよ。公式サイトはこちら： ResilioSync ファイル直リンク： ResilioSync 64bit 3）フォルダ さっき紹介したソフトウェアは、ResilioSync 以外は単一ファイルで動くものが多いから、よく使うフォルダにまとめておくといいよ。\nあとは、曲を置きたい場所にフォルダを作っておこう。例えば、「E:\\games\\Beat Saber Song\\」みたいに、好きな場所でOK。\n二、手順 1）Beat Saber を一度起動する 2）「ModAssistant」を開く 「同意する」をクリックすると、左側の「Mod」画面に入れるよ。画面左下でゲームのバージョンを選択して、Mod をインストールするか、そのままインストールを開始してね。\nもしダウンロードが遅い場合は、「オプション」からソフトウェアのソースを国内のものに変更するといいよ。\n3）Beat Saber をもう一度起動する 4）ResilioSync を開く この部分の手順は、こちらの記事を参考にしてね： Beat Saber 曲パックリソース同期 – ResilioSync (wgzeyu.com) どうせこのウェブサイトは開くことになるから、すでに手順が書いてあるし、俺は書かないよ（めんどくさがり）。\nフォルダのダウンロード先は、さっき作ったフォルダを選ぶんだ。\n5）BeatSaber 楽曲パスマネージャーを開く 初めて開くときは、指示に従って進んでね。「ディレクトリを追加」をクリックして、曲を置くディレクトリ（さっきダウンロードしたフォルダの場所）を選択する。\nそして、「リストを保存」をクリックすれば完了！\n三、その後 もし他にやりたいことがあるなら、 WGzeyu さんの チュートリアル を参考にしてみてね。\n","date":"2022-03-18T17:46:00+08:00","permalink":"https://blog.yexca.net/ja/archives/31/","title":"Beat Saber にカスタム楽曲を追加する方法"},{"content":" 📢 この記事は ChatGPT によって翻訳されました はじめに Beat Saber や VRChat などの VR ゲームをプレイしたあと、I社の一部ゲームが VR に対応していることを思い出し、一番好きな「恋活（Koikatu）」を試してみたところ、いくつか問題に直面しました。本記事はその記録です。なお、VR 版にはストーリーがなく、筆者は無改造のオリジナル版を使用しているため、発生する問題は少なめです。\n前提条件 以下の画像と一部の説明は Oculus 公式サポートページ から引用しています。翻訳は筆者によるものなので、正確な内容は公式を参照してください。\nケーブル要件 Oculus Link には、データ転送と給電の両方に対応した高品質な USB ケーブルが必要です。快適にプレイするには、長さ 3m（10フィート）以上が推奨されています。\nPC 推奨スペック パーツ 推奨構成 CPU Intel i5-4590 / AMD Ryzen 5 1500X 以上 GPU 対応表を参照 メモリ 8GB 以上 OS Windows 10 USB ポート 1つ必要 Oculus Link 対応 GPU NVIDIA GPU スポット スポットではない NVIDIA Titan Z X NVIDIA Titan X X NVIDIA GeForce GTX 970 X NVIDIA GeForce GTX 1060 Desktop, 3GB X NVIDIA GeForce GTX 1060 Desktop, 6GB X NVIDIA GeForce GTX 1060M X NVIDIA GeForce GTX 1070(all) X NVIDIA GeForce GTX 1080(all) X NVIDIA GeForce GTX 1650 X NVIDIA GeForce GTX 1650 Super X NVIDIA GeForce GTX 1660 X NVIDIA GeForce GTX 1660 TI X NVIDIA GeForce RTX 20-series (all) X NVIDIA GeForce RTX 30-series (all) X AMD GPU スポット スポットではない AMD 200 Series X AMD 300 Series X AMD 400 Series X AMD 500 Series X AMD 5000 Series X AMD 6000 Series X AMD Vega Series X 詳しくは 公式互換ページ をご確認ください。\n一、ゲーム起動について Koikatu VR を起動するには、KoikatuVR.exe を直接実行してください。Steam のストリーミング機能を使っている場合は、事前に SteamVR を立ち上げておくとスムーズです。\n問題1：SteamVR に入れない 1. 必要ソフトの確認 SteamVR のインストール Steam を開いた状態で Win+R を押し、steam://run/250820 を入力して Enter を押すと自動でインストールが開始されます。\nOculus ソフトのインストール 公式サイト からダウンロード＆インストール。初回起動時にアカウントログインが必要です。支払い方法の入力を求められた場合、「スキップ」可能です。\nログインが終わらない・ずっと読み込み中 hosts ファイルを編集することで解決可能です。火絨（Huorong）などのツールが便利ですが、手動でも以下を追加してください。\n1 2 3 4 157.240.11.49 graph.oculus.com 157.240.11.49 www2.oculus.com 157.240.8.49 scontent.oculuscdn.com 157.240.8.49 securecdn.oculus.com ファイル：C:\\Windows\\System32\\drivers\\etc\\hosts をメモ帳で開き、末尾に追加。\n2. Link ケーブルが正常か確認 Oculus ソフトで「Quest2 および Touch - USB 接続のテスト」を実行してください。接続時のポップアップでも確認可能です。\n3. 設定が正しいか確認 Quest2 本体のポップアップ → 「データへのアクセスを許可」は「拒否」を選択\nOculus ソフトの「設定 \u0026gt; 一般 \u0026gt; 不明なソースを許可」をオンにする\n4. それでもダメなら別ルートで起動 Quest2 側で「Oculus Link を有効化」→「有効にする」 SteamVR を手動で起動（Steam ライブラリ内にあります） 二、ゲーム開始 KoikatuVR.exe をダブルクリックすると自動で SteamVR が起動します。Oculus Link 接続後に直接起動すれば OK。\n注意：ゲーム画面がデスクトップにもウィンドウ表示されます。Win+D などで最小化可能ですが、HMD を一度外すと再表示される場合があります。\n問題2：ゲームが開始できない / 操作方法が不明 一部ネット上では「対応デバイスのみ有効」といった情報がありますが、実際には次のように操作可能です：\n「スティック押し込み」で選択レーザー表示、「トリガー」で決定。\n詳細操作は次項で紹介します。\n問題3：白画面のまま開始できない、PC 側で読み込みが止まる コイカツ！DL 版の公式ページ 下部から「コイカツ VR パッチ」をダウンロードしてください：\n直リンク： vr_patch.zip 解凍後、setup フォルダの中身をゲームフォルダに上書きしてください。\n注：この方法では「体位数が3つに制限される」可能性があります。\n回避策：ストーリーモードで体位をすべて実行 → 夜にセーブ → VR モードでロードすれば、すべて解放されます。\n参考スレッド： 兄弟们有没有玩了 vr 的 三、基本操作 筆者がプレイして確認した範囲の操作を以下に記載します。\n1）ゲーム起動後の選択 「スタート（Start）」「エンド（End）」の2つがあります。\nスティック押し込み：レーザー表示 前側トリガー：決定 2）プレイ中の操作 両手コントローラーの手首あたりに表示が出ます。\n日本語 英語 内容 操作 アクション Action 行動 前トリガー：メニュー表示・実行、側面トリガー：詳細 システム System 設定 前トリガー：位置リセット 移動 Move 移動 前トリガー押しっぱなしで視点変更 ※「アクション」中のみスティック押し込みで選択可能\n参考リンク Oculus Link 公式ページ 兄弟们有没有玩了 vr 的 Oculus クライアントがログインできない時の対処法 ","date":"2022-03-18T16:54:23+08:00","permalink":"https://blog.yexca.net/ja/archives/30/","title":"Quest2 でコイカツを VR プレイする際の問題とその解決"},{"content":" 📢 この記事は gemini-2.5-flash によって翻訳されました この記事は Hiyoung が書いたものだよ\n第一章：Webとネットワークの基本を知ろう 1.1 はじめに HTTPを理解するには、まずTCP/IPプロトコルスタックについて知っておくべきだね。僕たちが普段使っているネットワーク（インターネットも含む）はTCP/IPプロトコルスタックに基づいて動いていて、HTTPはその中のサブセットなんだ。インターネット上のデバイスが相互に通信するためには、両者が同じルールに従う必要がある。これらのルールをプロトコルと呼ぶんだ。（TCP/IPは、インターネット関連の様々なプロトコルスタックの総称で、PPPoE、HTTP、TCP、IP、UDP、IEEE 802.3などが含まれるけど、これらに限らないよ。）\nTCP/IPプロトコルスタックは、階層的に上から順に、アプリケーション層、トランスポート層、ネットワーク層、データリンク層に分かれているんだ。\nインターネット・プロトコル・スイート - Wikipedia TCP/IPプロトコルスタックを使って通信する時、クライアントはアプリケーション層から下に進み、サーバーはデータリンク層から上に進むんだ。クライアントが層間をデータ転送する際、各層を通過するたびにその層のヘッダー情報が付加されるよ。逆に、サーバーは層ごとにヘッダーを一つずつ取り除いていく。このようにデータ情報を包み込む方法をカプセル化と呼ぶんだ。\n1.2 IP、TCP、DNS 1.2.1 IPプロトコル IPプロトコルはネットワーク層に位置するんだ。TCP/IPのIPはIPプロトコルを指していて、IPアドレスとは別物だよ。IPプロトコルの役割は、様々なデータパケットを相手に送ること。様々なIPアドレスはMACアドレスとペアにできるんだ。IPアドレスは変わる可能性があるけど、MACアドレスは基本的には変わらない。IPアドレスはノードに割り当てられたアドレスを示し、MACアドレスはネットワークカードに属する固定アドレスを指すよ。\n1.2.2 MACアドレス IP間の通信はMACアドレスに依存するんだ。通常、 ARPプロトコル を使って、通信相手のIPアドレスから対応するMACアドレスを逆引きするよ。\n1.2.3 TCPプロトコル 階層的に見ると、TCPはトランスポート層に位置していて、バイトストリームサービスを提供するんだ。これは、大きなデータを転送しやすくするために、セグメントという単位のデータパケットに分割して管理すること。簡単に言えば、TCPプロトコルは大量のデータを送りやすくするためにデータを分割するし、データが最終的に相手に届いたかどうかを確認できるんだ。\nデータが相手に届いたかを確認するために、TCPはスリーウェイハンドシェイクという戦略を採用しているよ。ハンドシェイクの過程では、TCPのフラグであるSYN（synchronize）とACK（acknowledgement）が使われるんだ。\n1.2.4 ドメイン名解決を担うDNSサービス コンピューターにはIPアドレスだけでなく、ホスト名やドメイン名も割り当てられるよ。DNSプロトコルは、ドメイン名からIPアドレスを検索したり、逆にIPアドレスからドメイン名を逆引きしたりするサービスを提供するんだ。\n1.3 URLとURI 1.3.1 違いと関係性 URI（統一リソース識別子）に比べると、僕たちはURL（Uniform Resource Locator、統一リソースロケータ）の方に馴染みがあるよね。URLはまさにWebブラウザなどでWebページにアクセスする時に入力するウェブアドレスのこと。例えば、 https://www.bilibili.com/ はURLだよ。URIは文字列でインターネット上の特定のリソースを識別し、URLはリソースの場所（インターネット上のどこにあるか）を示す。だから、URLはURIのサブセットなんだ。URIはロケータ（URL）、名前（URN）、またはその両方と見なせる。 統一リソース名 （URN）は人の名前のようなもので、 統一リソースロケータ （URL）は人の住所を表す。言い換えれば、URNはあるもののアイデンティティを定義し、URLはそのものを見つける方法を提供するんだ。\n1.3.2 URIのフォーマット 指定されたURIを表すには、必要な情報すべてを含む絶対URI、絶対URL、そして相対URLを使うんだ。\n相対URLは、ブラウザの基本URIから指定されるURLで、/image/logo.gifのような形をしているよ。\n絶対URIのフォーマット：\nログイン情報（認証）：サーバーからリソースを取得する際に必要なログイン情報（身元認証）として、ユーザー名とパスワードを指定するよ。これはオプション項目だね。\nサーバーアドレス：絶対URIを使う場合、アクセス先のサーバーアドレスを必ず指定する必要があるんだ。アドレスはhackr.jpのようなDNSで解決可能な名前でもいいし、192.168.1.1のようなIPv4アドレス名でもいいし、[0:0:0:0:0:0:0:1]のように角括弧で囲まれたIPv6アドレス名でもいいよ。\nサーバーポート番号：サーバーに接続するネットワークポート番号を指定する。これもオプション項目で、省略すると自動的にデフォルトのポート番号が使われるんだ。\n階層的なファイルパス：サーバー上のファイルパスを指定して、特定のリソースを特定する。これはUNIXシステムのファイルディレクトリ構造と似ているね。\nクエリ文字列：指定されたファイルパス内のリソースに対して、クエリ文字列を使って任意のパラメータを渡せるよ。これはオプション項目だね。\nフラグメント識別子：フラグメント識別子を使うと、通常、取得したリソース内のサブリソース（ドキュメント内の特定の位置）をマークできる。でも、 RFC ではその使用方法が明確に規定されているわけではないんだ。これもオプション項目だよ。\n第二章：シンプルなHTTPプロトコル 2.1 HTTPの概要 HTTPはステートレスプロトコルだね。ステートレスというのは、HTTPプロトコル自体が、それぞれのリクエストとレスポンス間の通信状態を保存しないってこと。だから、通信状態を保存するためにCookie技術が導入されたんだ。（注：このHTTPに関する本は比較的古いから、現在使われている状態保存技術は、 Cookie、Session、Token が組み合わさって実現されているよ。）\n2.2 よく使われるHTTPメソッド GET：リソースを取得する\nGETメソッドはURLで指定されたリソースをリクエストするために使われるんだ。指定されたリソースはサーバー側で解析された後、レスポンス内容が返されるよ。\nPOST：エンティティボディを送信する\nPOSTはサーバーにデータを送信するために使われるよ。取得するデータが大きすぎる場合にもPOSTメソッドが使われることがあるんだ。\nGETとPOSTの違い：\n結論から言うと、GETとPOSTメソッドに本質的な違いはない。ただメッセージのフォーマットが違うだけなんだ。\nリクエストパラメータの長さ制限：GETリクエストの長さは最大1024KBだけど、POSTはリクエストデータに制限がないよ。\nリクエストパラメータ：GETリクエストのパラメータはURLを介して渡され、複数のパラメータは\u0026amp;で連結される。POSTリクエストはリクエストボディに格納されるんだ。 リクエストキャッシュ：GETリクエストはキャッシュされるけど、POSTリクエストは手動で設定しない限りキャッシュされないよ。 安全性：POSTの方がGETより安全だね。GETリクエストはブラウザで戻るボタンを押しても無害だけど、POSTは再度リクエストが送信されてしまうからね。 履歴：GETリクエストのパラメータは閲覧履歴に完全に残るけど、POSTのパラメータは残らないよ。 エンコード方式：GETリクエストはURLエンコードしかできないけど、POSTは複数のエンコード方式をサポートしてるんだ。 パラメータのデータ型：GETはASCII文字しか受け付けないけど、POSTには制限がないよ。\n他にも、 HTTPにはPUT、HEAD、DELETEなどのメソッドがある けど、ここでは詳しく触れないでおくね。\n2.3 HTTPの持続的接続（スリーウェイハンドシェイクとフォアウェイハンドシェイク） 持続的接続の特徴は、どちらかの端が明示的に接続を切断すると言わない限り、TCP接続状態を維持することなんだ。\nスリーウェイハンドシェイク：TCP接続を確立する フォアウェイハンドシェイク：TCP接続を切断する\n持続的接続では、パイプライン化技術を使うことで、応答を待たずに次のリクエストを直接送信できるんだ。\n2.4 Cookieを使った状態管理 Cookieは、サーバーから送られてくるレスポンスメッセージ内のSet-Cookieというヘッダーフィールド情報に基づいて、クライアントにCookieの保存を通知するんだ。次回クライアントがそのサーバーにリクエストを送る際、クライアントは自動的にリクエストメッセージにCookie値を追加して送信するよ。\nCookie情報はサーバー側で生成され、クライアントに送られて保存されるんだ。\n第三章 HTTPメッセージ情報 3.1 HTTPのリクエストとレスポンスメッセージの構造 HTTPプロトコルのやり取りに使われる情報をHTTPメッセージと呼ぶよ。リクエスト側（クライアント）のHTTPメッセージはリクエストメッセージ、レスポンス側（サーバー）のHTTPメッセージはレスポンスメッセージと呼ばれるね。8ビットのバイトストリームで構成されていて、HTTP通信で転送されるんだ。\nリクエストライン：リクエストに使われるメソッド、リクエストURI、HTTPバージョンを含むよ。\nステータスライン：レスポンス結果を示すステータスコード、理由フレーズ、HTTPバージョンを含むんだ。\nヘッダーフィールド：リクエストとレスポンスの様々な条件や属性を示す各種ヘッダーを含む。一般的に、汎用ヘッダー、リクエストヘッダー、レスポンスヘッダー、エンティティヘッダーの4種類があるよ。\nその他：HTTPのRFCで定義されていないヘッダー（Cookieなど）が含まれることもあるね。\n3.2 エンコード転送とチャンク転送 HTTPはデータ転送の過程でエンコードすることで転送速度を向上させるんだ。\n3.2.1 メッセージボディとエンティティボディの違い エンティティ：リクエストまたはレスポンスのペイロードデータ（補足項目）として転送され、その内容はエンティティヘッダーとエンティティボディで構成されるんだ。\nHTTPメッセージのボディは、リクエストまたはレスポンスのエンティティボディを転送するために使われる。通常、メッセージボディはエンティティボディと同じ。転送中にエンコード操作が行われた場合にのみ、エンティティボディの内容が変化し、それがメッセージボディとの差異を生むんだ。\n3.2.2 エンティティボディの分割送信 HTTP通信中に大容量データを転送する際、データを複数に分割することで、ブラウザがページを段階的に表示できるようになるんだ。エンティティボディを分割する機能をチャンク転送エンコーディングと呼ぶよ。チャンク転送エンコーディングは、エンティティボディを複数のチャンクに分割する。各チャンクは16進数でチャンクのサイズがマークされ、エンティティボディの最後のチャンクは「0(CR+LF)」でマークされるんだ。\nいわゆるチャンクっていうのは、よく言うパケットのことだね。\n第四章 戻り結果のHTTPステータスコード 4.1 ステータスコードの種類 ステータスコードを使えば、サーバーがリクエストを正常に処理したかどうかを知ることができるんだ。ステータスコードは種類が多いけど、よく使うのはだいたい14種類くらいだよ。\n4.2 2XX 成功 4.2.1 200 OK クライアントから送られたリクエストがサーバーで正常に処理されたことを示すんだ。レスポンスメッセージ内で、ステータスコードと一緒に返される情報は、メソッドによって変わるよ。\n4.2.2 204 No Content このステータスコードは、サーバーが受け取ったリクエストが正常に処理されたけど、返されるレスポンスメッセージにはエンティティボディの部分が含まれていないことを示すんだ。\n4.3 3XX リダイレクト ここでは301リダイレクトと302リダイレクトについて重点的に説明するね。他のステータスコードは自分で調べてみて。\n4.3.1 301 Moved Permanently 301リダイレクトは恒久的なリダイレクトなんだ。このステータスコードは、リクエストされたリソースが新しいURIに割り当てられたことを示し、今後はリソースが現在指すURIを使用すべきだよってこと。例えば、以下に示すリクエストURIのように、指定されたリソースパスの最後にスラッシュ「/」を付け忘れると、301ステータスコードが生成されることがあるんだ。\nhttp://excample.com/sample\n4.3.2 302 Found 302リダイレクトは一時的なリダイレクトだよ。このステータスコードは、リクエストされたリソースが新しいURIに割り当てられたことを示し、ユーザー（今回だけ）に新しいURIでアクセスしてほしいってこと。301 Moved Permanentlyステータスコードと似てるけど、302ステータスコードが表すリソースは永久に移動したわけじゃなくて、一時的な性質のものなんだ。\n4.4 4XX クライアントエラー 400 Bad Request、401 Unauthorized、403 Forbidden、404 Not Foundがあるね。ここでは404 Not Foundについて重点的に説明するよ。\n4.4.1 404 Not Found このステータスコードは、サーバー上でリクエストされたリソースが見つからなかったことを示すんだ。それ以外にも、サーバー側がリクエストを拒否したけど、理由を説明したくない場合にも使われることがあるよ。\n4.5 5XX サーバーエラー 5XXのレスポンス結果は、サーバー自体でエラーが発生したことを示すんだ。\n第五章 Webサーバー 5.1 通信データ転送プログラム：プロキシ、ゲートウェイ、トンネル 5.1.1 プロキシ プロキシサーバーの基本的な動作は、クライアントから送られてきたリクエストを受け取って、それを他のサーバーに転送することだね。プロキシはリクエストURIを変更せず、直接前方にあるリソースを持つターゲットサーバーに送信するんだ。ちなみに、プロキシはクライアントに対するプロキシ（フォワードプロキシとも呼ばれる）を指すけど、リバースプロキシはサーバーに対するプロキシを指すよ。\nプロキシサーバーを使うと、キャッシュ技術を利用してネットワーク帯域幅のトラフィックを削減できるし、情報セキュリティのためにプロキシを使うこともあるんだ。\nキャッシュプロキシ プロキシが応答を転送する際、キャッシュプロキシ（Caching Proxy）は、あらかじめリソースのコピー（キャッシュ）をプロキシサーバーに保存しておくんだ。同じリソースへのリクエストが再びプロキシに届いた場合、オリジンサーバーからリソースを取得するのではなく、以前キャッシュしたリソースを応答として返すことができるんだよ。\nリバースプロキシ リバースプロキシにはたくさんの利点があるんだ。\nクライアントからサーバー（クラスター）のIPアドレスを隠せる\nセキュリティ： アプリケーション層ファイアウォール として、ウェブベースの攻撃（例えば DoS / DDoS ）からウェブサイトを保護し、 マルウェア などの特定を容易にする\nバックエンドサーバー（クラスター）に対して、暗号化と SSL アクセラレーション（SSL終端プロキシなど）を統一的に提供する\nロードバランシング ：サーバークラスター内に負荷の高いものがある場合、リバースプロキシは URL書き換え を通じて、接続リクエストに応じて負荷の低いサーバーから必要な同じリソースを取得したり、予備を提供したりする\n静的コンテンツや短期間に大量のアクセスリクエストがある動的コンテンツに対して、 キャッシュサービス を提供する\nいくつかのコンテンツを 圧縮 して、 帯域幅 を節約したり、ネットワーク帯域幅が不十分なネットワークにサービスを提供したりする\n5.1.2 ゲートウェイ ゲートウェイの仕組みはプロキシとすごく似てるんだ。ゲートウェイは、通信回線上のサーバーがHTTP以外のプロトコルサービスを提供できるようにするよ。\n","date":"2022-03-16T23:56:48+08:00","permalink":"https://blog.yexca.net/ja/archives/29/","title":"『図解HTTP』読後まとめと簡単な考察"},{"content":" 📢 この記事は Gemini-3-flash によって翻訳されました 注意 この記事は 《unity学习笔记》——将MMD模型导入unity の内容をコピーしたもので、個人用のメモとして残しているよ。一部の内容は修正してある。\n方法1：Unityプラグインを使って直接読み込む 第一歩：プラグイン「MMD4Mecanim (Beta)」をインストール プラグインのURL： Stereoarts Homepage （作者の意向により、GitHubなどへの二次配布は禁止されているよ）\n直リンク： MMD4Mecanim_Beta_20200105.zip 第二歩：Unityを開いて、ダウンロードしたプラグイン内の「MMD4Mecanim.unitypackage」をダブルクリック 第三歩：MMDモデルのファイルを（全部まとめて）Unityにインポート 自動生成された .MMD4Mecanim ファイルを選択して、同意（Agree）をクリック（この時にアニメーションや音楽なども追加できるよ）。\nこの方法のいいところは、MMD本来のレンダリング効果を最大限に再現できること。自分でシェーダーを細かく設定し直す必要がないし、Unity以外のソフトを使わなくて済むから便利だよ。\n方法2：BlenderプラグインでMMDモデルをfbxに変換してインポート 第一歩：Blenderプラグインをインストール GitHub: cats-blender-plugin このプラグインを使うと、BlenderでMMDのpmxファイルを読み込めるようになるんだ。そこから必要に応じてfbxやstlなどの形式（Unityで使うならfbx）に書き出せるよ。\n第二歩：書き出したfbxモデルと、元のモデルのテクスチャを全部Unityにインポート Unityに持ってきた時に、見た目やレンダリングの感じが元と違ってしまうことがあるから、その時は自分でシェーダーを調整してね。\n自分でシェーダーを設定するメリットは、Unity内で異なるモデル同士のアートスタイルを統一できることかな。手っ取り早く済ませたいなら、Asset Storeで似た雰囲気のモデルをダウンロードして、そのシェーダーをインポートしたMMDモデルに適用しちゃうのもアリ（モーションも流用できるし、色も自分で変えられるよ）。\n","date":"2022-03-10T13:15:26+08:00","permalink":"https://blog.yexca.net/ja/archives/28/","title":"MMDモデルをUnityにインポートする方法"},{"content":" 📢 この記事は gemini-2.5-flash によって翻訳されました はじめに 普段ブログ記事を書くとき、よく画像を挿入する必要があるよね（最近の記事には画像がないけど）。でも、自分のサーバーを使うとトラフィックを食うし、読み込み速度もそんなに速くないから、画像ホスティングサービスが必要になるんだ。だけど、多くの無料画像ホスティングは、時々画像が消えたり、速度が遅かったりする問題があるから、自分で画像ホスティングを構築する方法を探し始めたんだ。\nでも、画像をホストするためにわざわざお金を払ってクラウドサーバーを借りるのは高すぎるし、割に合わない。有料の画像ホスティングもたいていトラフィックや容量の制限があるしね。そんな時に、ふとあるプロジェクトを見つけたんだ。GitHub APIとjsDelivrをベースに開発された、CDN高速化機能付きの画像ホスティング管理ツールだよ。\nPicX 画像ホスティングの紹介 公式サイト： PicX画像ホスティング プロジェクトページ： XPoet/picx: GitHub API \u0026amp; jsDelivrをベースに開発された、CDN高速化機能付きの画像ホスティング管理ツール 公式ドキュメント： クイックスタート - PicX画像ホスティング 特徴：GitHubリポジトリを画像ホスティングとして選ぶだけで、あとは** PicX公式サイト **でトークンを紐付けたり必要な設定を完了すればすぐに使えるようになるんだ。ダウンロードもインストールも不要、すごく簡単だよ。\nクイックスタート まず、GitHubリポジトリを新規作成しよう Create a New Repository のリンクをクリックしてね\nRepository nameに名前を入力して（例：image-hosting）\nリポジトリの属性は必ず Public を選んでね\n次に、repo権限を持つGitHubトークンを作成しよう New personal access token のリンクをクリックしてね\nNote（名前、例：picx-image-hosting）を入力してね\n注意：「Expiration」はこのトークンの有効期限だよ。選ぶときは気をつけてね。 もしこの記事を早く見て設定してないなら、これを参考にしてね： PicX画像ホスティングでの画像アップロード時に「Bad credentials」と表示される場合 – yexca’Blog Select scopesでrepoにチェックを入れて、トークンを作成してね\n注意：新しく生成されたトークンは一度しか表示されないから、しっかり保存しておいてね。もしなくしたら、再生成すれば大丈夫だよ。\n最後に、公式サイトでトークン設定をしよう PicX公式サイト を開いて、画像ホスティング設定に入って、トークンを入力してね。\nそれから、リポジトリとディレクトリの方式を選ぼう\n新規ディレクトリ：手動で新しいディレクトリを入力する必要があるよ。（/ を使うと複数階層のディレクトリを作成できる。例えば、A01/A02 は2階層のディレクトリを作成したことになるよ。最大で3階層まで対応してる。） ルートディレクトリ：画像はリポジトリのルートディレクトリに直接保存されるよ。 自動ディレクトリ：YYYYMMDD の日付形式でディレクトリが自動生成されるよ。例えば：20200909。 OK、画像ホスティングの設定は完了だ。さあ、使い始めよう！\nその他 デフォルトで画像圧縮がオンになってるけど、「マイ設定」で変更できるよ。\n","date":"2022-02-17T23:02:13+08:00","permalink":"https://blog.yexca.net/ja/archives/27/","title":"PicXを使って無料で画像ホスティングを構築する方法"},{"content":" 📢 この記事は gemini-2.5-flash によって翻訳されました はじめに 学校の教務システムで時間割を見るのが正直言ってあんまり便利じゃないし、サードパーティ製の時間割アプリはセキュリティ上のリスクもある上に広告がめちゃくちゃ多いんだよね。だから、時間割をカレンダーにインポートしてみようと思ったんだ。僕はOutlookカレンダーにインポートすることにしたよ。これでiOS、Windows、Androidでマルチデバイス同期ができるようになるはず。\n準備するもの PC Androidスマホ PCにChromeブラウザをインストール: 公式サイトリンク スマホにWakeUp時間割アプリをインストール: 公式サイトリンク ステップ1：時間割のエクスポート Chromeで教務システムのURLを開き、時間割画面に移動する\nHTMLファイルのエクスポート\nまず、以下のコードをコピーしてね。\n1 javascript:void(function(u,s){s=document.body.appendChild(document.createElement(\u0026#39;script\u0026#39;));s.src=u+\u0026#39;?ts=\u0026#39;+Date.now();s.charset=\u0026#39;UTF-8\u0026#39;}(\u0026#39;https://the-red-hat-was-uncovered.gitee.io/supwisdom-course-table/dist.js\u0026#39;)) 次に、ブックマークを追加するよ。WindowsならショートカットキーはCtrl + Dね。\nショートカットキーを押したら、「その他」ボタンを直接クリックして、今追加したブックマークを編集できるよ。ここで名前とURL（アドレス）を変更できるんだ。名前は覚えやすいもの（例えば「WakeUp 時間割エクスポート」とか）にして、URL（アドレス）のところにさっきコピーしたコードを貼り付けてね！それから保存するのを忘れずに。\n最後に、さっきブックマークに追加したURLをクリックすると、ブラウザが自動的に「教务.html」ファイルをダウンロードするはずだよ（これが次のステップで使うファイルね）。\nステップ2：WakeUp時間割アプリへのインポート 前のステップでエクスポートしたファイルをスマホに送る\nWakeUp時間割アプリに時間割をインポートする\nスマホでWakeUp時間割アプリを開いて、「新しい時間割をインポート」（右上から2番目）を選んで、「HTMLファイルからインポート」をタップするよ。\n「学校/教務システムの種類を選択」で「樹維教務（簡易インポート）」を選んでね。学校を選ぶ必要はないから。それからファイルを選んで、右下をタップするだけ。\nインポートが完了したら、正しい学期開始日か現在の週数を設定するのを忘れないでね。\nステップ3：カレンダーへのインポート WakeUp時間割アプリの右上から3番目の「エクスポート」をタップして、「ICS（カレンダー用）形式でエクスポート」を選ぶんだ。\nAndroidスマホなら、ファイルディレクトリを見つけて、そのファイルをタップして、カレンダーアプリで開けばOK。\niOSスマホの場合、添付ファイル付きのメールをスマホでログインしているメールアドレスに送って、添付ファイルをタップしてインポートできるよ。\n参考文献 樹維教務簡易インポート ","date":"2022-02-16T17:53:16+08:00","permalink":"https://blog.yexca.net/ja/archives/26/","title":"時間割をカレンダーにインポートする（樹維教務システム）"},{"content":" 📢 この記事は gemini-2.5-flash-lite によって翻訳されました 国内ツール 站长工具のポートスキャンを使ってみよう。IPアドレスかドメイン名とポート番号を入力して、「開始スキャン」をクリックするんだ。\nもし「クローズ」と表示されたら、ポートが開いていないか接続できないってことだね。\nツールリンク： ポートスキャン – 站长工具 海外ツール you get signal の Port Forwarding Tester でスキャンしてみよう。\nアクセスすると、自動的に君のIPアドレスと80番ポートが入力されるけど、これはスキャンしたいIPアドレスとポート番号に変更できるから、「Check」をクリックしてみて。\nもし赤い旗が表示されて「port ** is closed on ...」って出たら、ポートが開いていないか接続できないってことだよ。\nツールリンク： Open Port Check Tool – Test Port Forwarding on Your Router ","date":"2022-02-13T19:46:38+08:00","permalink":"https://blog.yexca.net/ja/archives/25/","title":"サーバーポートが開いているか確認する方法"},{"content":" 📢 この記事は gemini-3-flash-preview によって翻訳されました はじめに QQ はソフト自体が重すぎるし、権限も多すぎる。おまけに頻繁にフリーズして読み込めなくなるから、別の方法を探してたんだ。最初は Telegram で QQ メッセージを送受信しようとしたんだけど、設定がかなり複雑で不安定だったから断念。結局、VS Code を使うことにしたよ。\nプラグインの紹介 名称: QQ\nID: takayama.vscode-qq\n説明: lite qq for chat in working\nバージョン: 1.4.2\nパブリッシャー: takayama\nVS Marketplace リンク: VS Code QQ Extension Github プロジェクト: vscode-qq 注：このプログラムはローカルにメッセージ履歴や画像を保存しないよ。今のところ一時的なチャット（臨時会話）には対応していないみたい。\nインストール まずは VS Code をインストールしよう。 公式サイト にアクセスして Download をクリックすればインストールできるよ。\n次に、さっきの VS Code QQ Extension のリンクから「Install」をクリックして自動的に VS Code を開いてインストールする。\nもしくは、VS Code を開いて左側の「拡張機能」（または CTRL+SHIFT+X）から「QQ」を検索（大文字に注意）して、一番上のものをインストールしてね。\n機能 ショートカットキー「CTRL+SHIFT+P」でコマンドパレットを開く。\n「QQ Explorer: Login」と入力（「login」とだけ打てば候補が出るはず）してエンター。\nあとは指示に従ってアカウントとパスワードを入力すればログイン完了。ログインすると各機能が表示されるよ。\n「QQ Explorer: 搜索好友」でフレンド検索。\n「QQ Explorer: 搜索群」でグループ検索ができるよ。\n設定 ログインに成功すると、コントロールパネルから設定ができるようになる。設定は json ファイルの編集で、内容はこんな感じ：\n1 2 3 4 5 6 7 8 9 { \u0026#34;account\u0026#34;: ***********, // QQ番号 \u0026#34;password\u0026#34;: \u0026#34;********************************\u0026#34;, // QQパスワード \u0026#34;platform\u0026#34;: 5, // ログインプラットフォーム。変更可能「1:スマホ, 3:ウォッチ(機能不完全), 4:PC, 5:pad(デフォルト)」 \u0026#34;show_me_add_group_request\u0026#34;: false, \u0026#34;theme\u0026#34;: \u0026#34;default\u0026#34;, // UIテーマ。変更可能「default(デフォルト) と console(コンソール風)」 \u0026#34;theme_css\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;theme_js\u0026#34;: \u0026#34;\u0026#34; } テーマのカスタマイズもできるから、詳しくはここを参考にしてみて： UIテーマの変更/カスタマイズ ","date":"2022-02-11T21:47:56+08:00","permalink":"https://blog.yexca.net/ja/archives/24/","title":"VS Code で QQ メッセージを送受信する"},{"content":" 📢 この記事は gemini-2.5-flash によって翻訳されました はじめに Potplayerはすごく優秀な動画プレイヤーだよね。でも最近のバージョン、右下からポップアップ広告が出てきて、すごく困るんだ。この記事では、その右下ポップアップを解決する2つの方法を紹介するよ。\nポップアップなしの古いバージョンを使う（おすすめ） 広告ポップアップがない最後のバージョンは1.7.18958だよ。\n古いPotPlayerの全バージョンは、以下のURLからダウンロードできるよ： PotPlayer Old Versions Downloads バージョン1.7.18958の直接ダウンロードリンクはこちら： 64ビット版 | 32ビット版 インストール完了後、設定（F5）を開いて、「基本 - 自動更新」で「自動更新を使用しない」を選ぶことができるよ。\nポータブル版を使う 注意：このバージョンの使い心地は個人的にあまり良くないと感じるな。例えば、ウィンドウの吸着機能が使えなかったり、元ファイル比率で開けなかったりするんだ。\nLanzou Cloudのリンク by zdBryan\n通常起動 = インストール版（スタートメニューのショートカットやプログラムのアンインストール項目も含まれるよ）\n右クリックで解凍 = ポータブル版（元々ポータブル版として提供されていないソフトは、手動でポータブル化処理をする必要があるよ）\nバージョンの特徴\n1、チェック機能を削除、右下の空白広告ポップアップを削除！アンインストール時に設定のバックアップをオプションで選択できるよ。 2、バックグラウンドでのネットワーク接続リクエストを禁止：海外広告、ログ送信、アップグレードチェック 3、追加のオーディオデコーダーとビデオデコーダーコンポーネントが統合されてるよ。 4、プリセット設定：通常のセッティング + カスタムデコーダーH.265/HEVCとハードウェアアクセラレーションがデフォルトで有効になってるよ。 5、TVライブリスト、ログインプログラム、ログ管理、メッセージ通知、多言語などの不要なファイルは削除されてる。 参考記事 Potplayerの右下ポップアップ広告に関する解決策について PotPlayer v1.7.21589 ポータブル版 ","date":"2022-02-06T21:37:45+08:00","permalink":"https://blog.yexca.net/ja/archives/23/","title":"Potplayerの右下ポップアップを消す"},{"content":" 📢 この記事は gemini-2.5-flash-lite によって翻訳されました はじめに（どうでもいい話） 暇だったので、ルーターをゲートウェイとしていじってみようと思ったんだ（でも後でわかったんだけど、このルーターは容量が小さすぎて、あまりプラグインをインストールできなかった。午後いっぱい無駄にした感じだよ）。\n2022.02.17 更新：偶然にも、FIR300M 向けのゲートウェイ搭載ファームウェアを見つけたんだけど、サポートしている method が古すぎるから、書き換える場合は注意してね。\n元のスレッド： 更新编译方法 - FIR300M/FIR302M の Openwrt 固件 免拆机刷 百度網盤： 提取码: vouv OpenWRT について OpenWRT は Linux ベースのルーター用システムで、たくさんの強力なプラグインと高い拡張性があって、SSH で接続することもできるんだ。\n公式サイト： OpenWrt Wiki - Welcome to the OpenWrt Project OpenWRT 一般的なチュートリアル： 從零開始學習 OpenWrt: 刷機 + 使用 + 編譯教程 準備するもの １．ソフトウェア HFS ２．FIR300M 用の OpenWRT ファームウェア： 百度網盤 ３．PC で Telnet サービスを有効にする。参考： win10 怎么开启 telnet 服务 （Win11 でもできるよ、コントロールパネルは設定で検索して入ってね） 簡単な手順 １．ルーターの管理画面にログインする (192.168.1.1) ２．http://192.168.1.1/goform/Diagnosis?pingAddr=192.168.1.100|echo\u0026quot;\u0026quot;|telnetd にアクセスする ３．cmd を開いて、telnet 192.168.1.1 と入力する ４．ファームウェアをルーターに転送し、完了を待つ ５．これでルーターの管理画面に入ると OpenWRT になっている（初期パスワードなし、そのままログインできるよ） ６．System-Language and Style をクリックすると、言語を中国語に変更できる 詳細な手順（４番目のステップ） HFS を開いて、「準備するもの」の２番目のステップにあるファームウェアを「1.bin」にリネームしてウィンドウにドラッグ＆ドロップする。\ncmd で「telnet 192.168.1.1」と入力して接続できたら、以下のコマンドを順番に入力してね。\n1 2 3 cd /tmp wget http://192.168.1.100/1.bin // \u0026#34;192.168.1.100\u0026#34; は自分の PC の IP アドレスに置き換えてね mtd_write -r write 1.bin Kernel // （注意、「K」は大文字だよ） 実行が成功したらルーターは自動的に再起動するから、「接続が切断されました」と表示されるよ。\nプラグインのインストール OpenWRT の管理画面で「システム - パッケージ」をクリックすると、対応するプラグインをインストールできるよ。\nGithub で対応するプラグインを探すのがおすすめ。もちろん自分で作成することもできる。\nプラグインをインストールするにはネットワークアドレスが必要だから、Github の対応プロジェクトの Release から ipk パッケージへのリンクを直接コピーすればいい。\n自分で作成した場合のインストール方法は？自分で作成できるなら、これくらいできないわけないよね？（doge）\n注意点 プラグインのインストールにはルーターとの互換性が必要だよ。一部のプラグインは環境依存（つまり、他のプラグインを先にインストールする必要がある）の場合がある。\nエラーメッセージを見て判断するといいよ。\n参考記事 FIR300M 免拆机刷 Openwrt 教程 路由器刷固件——斐讯路由器 FIR300M 刷 OpenWrt 固件教程 HFS – 超好用的本地文件分享利器，快速从电脑传文件到手机等设备 许迎果 第 215 期 OpenWrt 插件的安装与卸载 ","date":"2022-02-06T20:44:10+08:00","permalink":"https://blog.yexca.net/ja/archives/22/","title":"FIR300M ルーターを OpenWRT でファームウェア書き換え"},{"content":" 📢 この記事は gemini-3-flash-preview によって翻訳されました はじめに（ちょっとした雑談） たまにWord文書にコードを載せたいときってあるよね。でも、そのままコードをコピペすると見た目があまり良くないし、ハイライトがないとすごく読みづらくて困っちゃうんだ。\nツールその1 CodeInWord Wordでエレガントにコードを表示/コードハイライト/Wordにコード挿入/コード整形 ツールその2 Syntax Highlight Code In Microsoft Word 使い方 特に説明することもないくらい簡単だよ。コードをサイトに貼り付けて、対応する言語を選んで、生成ボタンを押してからWordにコピー＆ペーストするだけ。\nおまけ もし上のサイトが使えなくなっていたら、検索エンジンで「syntax highlight code in word」って調べてみてね。\n参考にさせてもらった記事 如何优雅的在 Microsoft word中插入代码 ","date":"2022-01-20T14:28:52+08:00","permalink":"https://blog.yexca.net/ja/archives/21/","title":"Microsoft Word にコードを挿入する方法（ハイライト付き）"},{"content":" 📢 この記事は gemini-2.5-flash によって翻訳されました はじめに 海外の小さいゲームで遊んでると、文字化けして遊べなかったり、エラーで起動しなかったりすることってよくあるよね。そんなときは、正しい文字に合わせるために地域設定を変える必要があるんだ。\nWindowsの地域設定を変えれば動くことは動くけど、この方法って結構めんどくさいし、PC再起動も必要になるんだ。それに、遊び終わった後に元に戻しとかないと、普段使ってるソフトが使えなくなっちゃう可能性もあるから、こういうときに関連の地域設定変更ソフトが必要になるってわけ。\nソフトを手に入れる ソフトの公式サイト： Locale Emulator GitHubプロジェクトのアドレス(リリース)： Locale Emulator – GitHub 設定について ダウンロードして解凍したら、「LEInstaller」をクリックして、必要に応じて現在のユーザーか全てのユーザー用にインストールしてね。\nインストールが終わったら、「LEGUI」をクリックして地域設定の環境を設定するんだ (日本のゲームで遊ぶなら必要ないよ。デフォルトで自動設定されてるから)。\n使い方 開きたいゲームを見つけて、実行ファイル（.exe）を右クリック。\nそしたらLocale Emulatorを選んで、該当する環境で起動するだけだよ (Win11なら「その他のオプションを表示」をクリックしてね)。\n余談 自分用にメモしとくだけだよ。公式サイトにも使い方は載ってるからさ。\n","date":"2022-01-14T15:53:40+08:00","permalink":"https://blog.yexca.net/ja/archives/20/","title":"地域設定変更ソフト Locale Emulator"},{"content":" 📢 この記事は gemini-2.5-flash によって翻訳されました この記事は Hiyoung が書いたんだ。\n背景知識：\nLinuxの時刻についてざっくりと Linuxシステムには2つの時計があるんだ。1つはハードウェアクロック、つまりBIOS時間。もう1つはシステムクロックで、LinuxシステムのKernel（カーネル）時間のことだよ。 Linuxシステムでプログラムが動くときに読み込む時間は、全部システムKernel（カーネル）時間なんだ。 Linuxが起動するたびに、システムKernel（カーネル）はまずハードウェアクロックの設定を読み込むんだけど（このときのハードウェア時間が正確とは限らない）、その後、システムクロックはハードウェアとは関係なく動き続けるんだ。 だから、Linuxの時間を永続的に変更して正確にしたいなら、ハードウェア時間を永続的に変更しないといけないんだ。そうしないと、Linuxを再起動するたびにシステム時間が元のハードウェア時間に戻っちゃうよ。 Linuxの時刻関連コマンド システムKernel（カーネル）クロックに関するコマンドは timedatectl か date だね。 ハードウェアBIOSクロックに関するコマンドは hwclock か clock だよ。\n1. LinuxのGLIインターフェースで data を入力して現在のLinuxシステム時間をチェック 1 data 次に hwclock --show を入力してハードウェア時間をチェックするよ。\n1 hwclock --show 2. Linuxシステム時間の校正（NTPサービスを使うときはシステムがネットに繋がってる必要があるよ） CentOSでのNTPサービスインストールと設定の手順はこんな感じ： 1 2 # NTPサービスパッケージをインストール sudo yum install ntp 1 2 # NTPサービスをデフォルトで起動するように設定 sudo chkconfig ntp on 1 2 # 起動パラメータを変更して、-g -x オプションを追加。これでシステム時間の誤差が大きくてもNTPサービスがちゃんと動くようになるよ。 sudo vi /etc/sysconfig/ntpd 1 2 # NTPサービスを起動 sudo service ntpd restart Ubuntu/DebianでのNTPサービスインストールと設定の手順はこんな感じ： 1 2 # NTPサービスパッケージをインストール sudo apt-get install ntp 1 2 # 起動パラメータを変更して、-g -x オプションを追加。これでシステム時間の誤差が大きくてもNTPサービスがちゃんと動くようになるよ。 sudo vi /etc/default/ntp 1 2 # NTPサービスを起動 sudo service ntp restart ハードウェアクロックをシステムクロックに合わせる 1 hwclock --systohc --localtime (こっちの方が効果的みたいだよ) または\n1 timedatectl set-local-rtc 1 最後に、日付をCMOSに書き込んで永続化するよ。 1 clock -w または\n1 hwclock -w 3. Google BBRアクセラレーションを有効にする この記事で紹介する方法は、Debian 9以降のDebian Linuxが対象だよ。他のOSだとどうなるか分からないんだ。\n注意してほしいのは、ここでの設定パラメータはGoogle BBRを有効にするだけじゃなくて、ネットワークパラメータの一連の最適化も含まれてるってこと。そのままコピーして実行すればOKだよ。\nGoogle BBRでVPSサーバーをワンクリックで高速化するのはすごく簡単なんだ。SSHでVPSにログインしたら、次の2つのコマンドをそれぞれ実行するだけ（ハイライト表示された部分をマウスで選択して、右クリックでコピー、rootユーザーの#の後に貼り付けてエンターを押してね）。\nコマンド1 1 wget https://raw.githubusercontent.com/bannedbook/fanqiang/master/v2ss/server-cfg/sysctl.conf -O -\u0026gt; /etc/sysctl.con もし wget: command not found というエラーが出たら、それはシステムにwgetがインストールされてないからだよ。先にwgetをインストールする必要があるんだ。 \u0026lt;strong\u0026gt;apt-get install -y wget\u0026lt;/strong\u0026gt;\nコマンド2 1 sysctl -p 実行に成功したら、だいたいこんな感じの出力になるはずだよ（個人の状況によって違うけど）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 fs.file-max = 51200 net.ipv4.conf.lo.accept_redirects = 0 net.ipv4.conf.all.accept_redirects = 0 net.ipv4.conf.default.accept_redirects = 0 net.ipv4.ip_local_port_range = 10000 65000 net.ipv4.tcp_fin_timeout = 15 net.ipv4.tcp_fastopen = 3 net.ipv4.tcp_keepalive_time = 1200 net.ipv4.tcp_rmem = 32768 436600 873200 net.ipv4.tcp_syncookies = 1 net.ipv4.tcp_synack_retries = 2 net.ipv4.tcp_syn_retries = 2 net.ipv4.tcp_timestamps = 0 net.ipv4.tcp_max_tw_buckets = 9000 net.ipv4.tcp_max_syn_backlog = 65536 net.ipv4.tcp_mem = 94500000 91500000 92700000 net.ipv4.tcp_max_orphans = 3276800 net.ipv4.tcp_mtu_probing = 1 net.ipv4.tcp_wmem = 8192 436600 873200 net.core.netdev_max_backlog = 250000 net.core.somaxconn = 32768 net.core.wmem_default = 8388608 net.core.rmem_default = 8388608 net.core.rmem_max = 67108864 net.core.wmem_max = 67108864 net.ipv4.tcp_congestion_control = bbr ","date":"2022-01-14T01:30:54+08:00","permalink":"https://blog.yexca.net/ja/archives/19/","title":"Linuxサーバー（ネットワーク関連）"},{"content":" 📢 この記事は gemini-3-flash-preview によって翻訳されました 注意：この方法は一時的な接続だよ。仮想マシンを再起動したりシャットダウンしたりすると、また再設定が必要になるから気をつけてね。\n仮想マシンのネットワークアダプター設定 仮想マシンのネットワークアダプターには、主に3つの設定があるんだ。\nブリッジモード：ホストマシンと同じネットワークセグメントを使うモード。 NATモード：VMware Network Adapter VMnet8 のネットワークセグメントを使うモード。 ホストオンリーモード：VMware Network Adapter VMnet1 のネットワークセグメントを使うモード。 IPセグメントを確認しよう VMwareの左上にある「編集 -\u0026gt; 仮想ネットワークエディター」を開くと、VMnet1とVMnet8に対応するセグメントのアドレス（サブネットアドレス）が確認できるよ。\nブリッジモードのセグメントを確認するには、「設定 -\u0026gt; ネットワークとインターネット -\u0026gt; ネットワークの詳細設定」から、実際に接続されているホストマシンのネットワークを探してね。\nWiFiを使っているなら、「Wi-Fi -\u0026gt; プロパティを表示」でIPアドレスが見れるよ。 有線（LAN）を使っているなら、「イーサネット -\u0026gt; プロパティを表示」でIPアドレスが見れるよ。 注意：もしホストマシンが有線とWiFiの両方に繋がっているなら、VMwareの「仮想ネットワークエディター」で関連する設定が必要になるかもしれない。\nVMwareを管理者権限で実行して、画像のようにVMwareで使いたいネットワークカードを選択してね。\n仮想マシンのIPアドレスを設定する 注：僕はブリッジモードを使っているよ。僕のホストマシンのIPが 192.168.1.116 だから、仮想マシンには 192.168.1.0 〜 192.168.1.255 の範囲内で、192.168.1.116 以外のアドレスを自由に割り当てられるんだ。つまり、最初の3つの数字を同じにして、最後の数字だけ変えればいいってことだね。\nまずは仮想マシンを起動して root ユーザーでログインし、「ifconfig」コマンドでネットワークカードの設定を確認しよう。\nもし画像のように「ens33」と「lo」、あるいは「その他」と「lo」が表示されたら、\n次のコマンドを入力してね：\n1 2 # ifconfig デバイス名（この例では \u0026#34;ens33\u0026#34;） 割り当てたいアドレス（ここでは 192.168.1.110 を選択） ifconfig ens33 192.168.1.110 もし「lo」しか表示されない場合は、\n次のコマンドを入力してね：\n1 2 # ifconfig デバイス名（一般的には \u0026#34;eth0\u0026#34;） 割り当てたいアドレス（ここでは 192.168.1.110 を選択） ifconfig eth0 192.168.1.110 設定が終わったら、もう一度「ifconfig」コマンドを入力して確認してみよう。\n上の画像みたいに、IPが 192.168.1.110 に無事変わっていればOK。\nWindowsのターミナルを開いて、「ping 192.168.1.110」と入力して、ちゃんと繋がるか試してみて。\nこんな感じで返ってくれば、IPの変更が成功してアクセスできる状態だよ。\nXshellで接続する Xshellを開いて「新規」をクリック。名前は好きなもので大丈夫。ホストの欄にさっきのIPを入力して「接続」をクリックしてね。\n「受け入れて保存」を選んで、あとは画面の指示に従ってユーザー名（root）とパスワードを入力すれば完了！\n","date":"2021-12-26T15:34:59+08:00","permalink":"https://blog.yexca.net/ja/archives/18/","title":"Xshellを使って仮想マシンのCentOS 7に接続する方法"},{"content":" 📢 この記事は gemini-2.5-flash によって翻訳されました 順序スタック (配列実装) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #include \u0026lt;stdio.h\u0026gt; // 要素 elem をスタックに入れるよ。a は配列で、top が現在のスタックトップの位置だよ。 int push(int* a,int top,int elem) { a[++top]=elem; return top; } // データ要素をスタックから出す処理だよ。 int pop(int * a,int top) { if (top==-1) { printf(\u0026#34;スタックは空だよ\u0026#34;); return -1; } printf(\u0026#34;ポップされた要素：%d\\n\u0026#34;,a[top]); top--; return top; } int main(void) { int a[100]; int top=-1; top = push(a, top, 1); top = push(a, top, 2); top = push(a, top, 3); top = push(a, top, 4); top = pop(a, top); top = pop(a, top); top = pop(a, top); top = pop(a, top); top = pop(a, top); return 0; } 出力結果：\nポップされた要素：4\nポップされた要素：3\nポップされた要素：2\nポップされた要素：1\nスタックは空だよ\n連結スタック 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; typedef struct lineStack{ int data; struct lineStack * next; }lineStack; // stack は現在の連結スタックで、a はスタックに入れる要素を示すね。 lineStack* push(lineStack * stack,int a) { // 新しい要素を格納するノードを作成するよ。 lineStack * line=(lineStack*)malloc(sizeof(lineStack)); line-\u0026gt;data=a; // 新しいノードと先頭ノードを論理的に繋ぐんだ。 line-\u0026gt;next=stack; // 先頭ポインタの指す先を更新するね。 stack=line; return stack; } // スタックトップの要素を連結スタックから出す実装関数だよ。 lineStack * pop(lineStack * stack) { if (stack) { // スタックトップのノードを指す新しいポインタを宣言するね。 lineStack * p=stack; // 先頭ポインタを更新するよ。 stack=stack-\u0026gt;next; printf(\u0026#34;ポップされた要素：%d \u0026#34;,p-\u0026gt;data); if (stack) { printf(\u0026#34;新しいスタックトップの要素：%d\\n\u0026#34;,stack-\u0026gt;data); } else { printf(\u0026#34;スタックは空になったよ\\n\u0026#34;); } free(p); } else { printf(\u0026#34;スタックの中に要素がないよ\u0026#34;); return stack; } return stack; } int main(void) { lineStack * stack=NULL; stack=push(stack, 1); stack=push(stack, 2); stack=push(stack, 3); stack=push(stack, 4); stack=pop(stack); stack=pop(stack); stack=pop(stack); stack=pop(stack); stack=pop(stack); return 0; } 出力結果：\nポップされた要素：4 新しいスタックトップの要素：3\nポップされた要素：3 新しいスタックトップの要素：2\nポップされた要素：2 新しいスタックトップの要素：1\nポップされた要素：1 スタックは空になったよ\nスタックの中に要素がないよ\n","date":"2021-11-21T22:19:04+08:00","permalink":"https://blog.yexca.net/ja/archives/17/","title":"データ構造 スタックのコード"},{"content":" 📢 この記事は gemini-3-flash-preview によって翻訳されました コード 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; // malloc()、exit() #define Size 5 // Sizeをマクロ定義。シーケンシャルリストの初期メモリサイズを表すよ typedef struct Table { int * head; // headという名前の、長さが決まっていない配列（動的配列）を宣言するよ int length; // 現在のシーケンシャルリストの長さを記録するよ int size; // シーケンシャルリストに割り当てられたストレージ容量を記録するよ }table; // 初期化関数 table initTable() { table t; t.head = (int*)malloc(Size * sizeof(int)); // 空のシーケンシャルリストを作成して、メモリを動的に確保するよ if (!t.head) // もしメモリの確保に失敗したら、メッセージを出してプログラムを終了するよ { printf(\u0026#34;初期化に失敗したよ\u0026#34;); exit(0); } t.length = 0; // 空のリストの長さを0で初期化 t.size = Size; // 空のリストの初期容量をSizeにするよ return t; } // 挿入関数。elemは挿入する要素、addは挿入する場所だよ table addTable(table t, int elem, int add) { int i; // 挿入位置が正しいかチェックするよ（リストの長さ+1より大きいか、1より小さい場合はエラー） if (add \u0026gt; t.length + 1 || add \u0026lt; 1) { printf(\u0026#34;挿入位置に問題があるよ\u0026#34;); return t; } // 挿入する前に、空き容量があるか確認。足りなければメモリを再確保するよ if (t.length == t.size) { t.head = (int *)realloc(t.head, (t.size + 1) * sizeof(int)); if (!t.head) { printf(\u0026#34;メモリの再割り当てに失敗したよ\u0026#34;); return t; } t.size += 1; } // 挿入位置以降の要素を、一つずつ後ろにずらすよ for (i = t.length - 1; i \u0026gt;= add - 1; i--) { t.head[i + 1] = t.head[i]; } // ずらし終わったら、指定の位置に要素を入れるよ t.head[add - 1] = elem; // 要素が増えたから、長さを+1するよ t.length++; return t; } // 削除関数 table delTable(table t, int add) { int i; if (add \u0026gt; t.length || add \u0026lt; 1) { printf(\u0026#34;削除する要素の位置がおかしいよ\u0026#34;); exit(0); } for (i = add; i \u0026lt; t.length; i++) { t.head[i - 1] = t.head[i]; } t.length--; return t; } // 検索関数。elemは探したいデータの値だよ int selectTable(table t, int elem) { int i; for (i = 0; i \u0026lt; t.length; i++) { if (t.head[i] == elem) { return i + 1; } } return -1; } // 更新関数。elemを新しい要素newElemに書き換えるよ table amendTable(table t, int elem, int newElem) { int add = selectTable(t, elem); t.head[add - 1] = newElem; return t; } // リストの中身を表示する関数 void displayTable(table t) { int i; for (i = 0; i \u0026lt; t.length; i++) { printf(\u0026#34;%d \u0026#34;, t.head[i]); } printf(\u0026#34;\\n\u0026#34;); } int main() { int i, add; table t1 = initTable(); // シーケンシャルリストに要素を追加していくよ for (i = 1; i \u0026lt;= Size; i++) { t1.head[i - 1] = i; t1.length++; } printf(\u0026#34;元のシーケンシャルリスト：\\n\u0026#34;); displayTable(t1); printf(\u0026#34;要素1を削除：\\n\u0026#34;); t1 = delTable(t1, 1); displayTable(t1); printf(\u0026#34;2番目の位置に要素5を挿入：\\n\u0026#34;); t1 = addTable(t1, 5, 2); displayTable(t1); printf(\u0026#34;要素3の位置を検索：\\n\u0026#34;); add = selectTable(t1, 3); printf(\u0026#34;%d\\n\u0026#34;, add); printf(\u0026#34;要素3を6に変更：\\n\u0026#34;); t1 = amendTable(t1, 3, 6); displayTable(t1); return 0; } 実行結果 プログラムを実行すると、こんな感じになるよ：\n元のシーケンシャルリスト：\n1 2 3 4 5\n要素 1 を削除：\n2 3 4 5\n2 番目の位置に要素 5 を挿入：\n2 5 3 4 5\n要素 3 の位置を検索：\n3\n要素 3 を 6 に変更：\n2 5 6 4 5\n","date":"2021-11-20T23:01:47+08:00","permalink":"https://blog.yexca.net/ja/archives/16/","title":"データ構造：シーケンシャルリスト（順次リスト）のコード"},{"content":" 📢 この記事は gemini-3-flash-preview によって翻訳されました 簡易的な連結リスト 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include \u0026lt;stdio.h\u0026gt; struct student { long num; float score; struct student *next; }; void main() { struct student a, b, c, *head, *p; a.num = 99101; a.score = 89.5; b.num = 99103; b.score = 90; c.num = 99107; c.score = 85; // ノードの num と score メンバに値を代入 head = \u0026amp;a; // ノード a の開始アドレスを頭ポインタ head に代入 a.next = \u0026amp;b; // ノード b の開始アドレスをノード a の next メンバに代入 b.next = \u0026amp;c; c.next = NULL; // ノード c の next メンバには他のノードのアドレスを入れない p = head; // ポインタ p をノード a に向ける do { printf(\u0026#34;%ld %5.1f\\n\u0026#34;, p-\u0026gt;num, p-\u0026gt;score); // p が指しているノードのデータを出力 p = p-\u0026gt;next; // p を次のノードに向ける }while(p != NULL); // ノード c を出力し終わった後、p の値は NULL になる system(\u0026#34;pause\u0026#34;); } メモリ割り当て関数 malloc 関数 1 void *malloc(unsigned int size); メモリの動的記憶域内に、長さ size の連続した空間を割り当てる役割があるんだ。この関数の値（戻り値）は、割り当てられた空間の開始アドレスを指すポインタ（基底型は void）だよ。もし関数が正常に実行されなかった場合（メモリ空間が足りないときなど）は、空のポインタ NULL を返すんだ。\ncalloc 関数 1 void *calloc(unsigned n, unsigned size); メモリの動的領域内に、長さ size の連続した空間を n 個割り当てるよ。関数は割り当てられた空間の開始アドレスを指すポインタを返して、割り当てに失敗した場合は NULL を返す。calloc 関数を使えば一次元配列のための動的ストレージ空間を確保できるね。n は配列の要素数で、各要素の長さが size になるよ。\nfree 関数 1 void free(void *p); p が指すメモリ領域を解放して、その部分のメモリを他の変数で再利用できるようにする関数だよ。p は、最後に calloc や malloc 関数を呼び出したときに返された値である必要があるんだ。free 関数に戻り値はないよ。ちなみに、昔の C のバージョンでは malloc と calloc 関数が返すのは文字型データへのポインタだったけど、ANSI C では void * 型と規定されているんだ。\n動的な連結リストの実装 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #define NULL 0 #define LEN sizeof(struct student) struct student { long num; float score; struct student *next; }; struct student *create() { struct student *p1, *p2, *head; int num; float score; int n = 0; head = NULL; p1 = p2 = (struct student *)malloc(LEN); printf(\u0026#34;please input num and score.\\n\u0026#34;); scanf(\u0026#34;%d,%f\u0026#34;, \u0026amp;p1-\u0026gt;num, \u0026amp;p1-\u0026gt;score); while(p1-\u0026gt;num != 0) { n ++; if(n == 1) head = p1; else p2-\u0026gt;next = p1; p2 = p1; p1 = (struct student *)malloc(sizeof(struct student)); printf(\u0026#34;please input num and score.\\n\u0026#34;); scanf(\u0026#34;%d,%f\u0026#34;, \u0026amp;p1-\u0026gt;num, \u0026amp;p1-\u0026gt;score); } p2-\u0026gt;next = NULL; return head; } void printlist(struct student *head) { struct student *p; p = head; if(head != NULL) { do { printf(\u0026#34;num=%d score=%f\\n\u0026#34;, p-\u0026gt;num, p-\u0026gt;score); p = p-\u0026gt;next; }while(p != NULL); } } void main() { struct student *head; head = create(); printlist(head); system(\u0026#34;pause\u0026#34;); } // 連結リストを印刷 void printlist(struct student *head) { struct student *p; p = head; if(head != NULL) { do { printf(\u0026#34;num=%d score=%5.2f\\n\u0026#34;, p-\u0026gt;num, p-\u0026gt;score); p = p-\u0026gt;next; } while (p != NULL); } /* while(p -\u0026gt; next != NULL) { printf(\u0026#34;num=%d score=%f\\n\u0026#34;, p-\u0026gt;num, p-\u0026gt;score); p = p-\u0026gt;next; }*/ } // ノードを削除 struct student *delNode(struct student *head, int num) { printf(\u0026#34;delNode.\\n\u0026#34;); struct student *p1, *p2; if(head == NULL) { printf(\u0026#34;The List is NULL.\\n\u0026#34;); } else { p1 = head; while(p1-\u0026gt;next != NULL \u0026amp;\u0026amp; p1-\u0026gt;num != num) { p2 = p1; p1 = p1-\u0026gt;next; } if(p1-\u0026gt;num == num) { if(p1 == head) head = p1-\u0026gt;next; else p2-\u0026gt;next = p1-\u0026gt;next; } else printf(\u0026#34;Can not find list num.\\n\u0026#34;); } return head; } // ノードを更新 struct student *update(struct student *head, int index, int num, float score) { printf(\u0026#34;update.\\n\u0026#34;); struct student *p; if(head == NULL) { printf(\u0026#34;The List is NULL.\\n\u0026#34;); } else { p = head; while(p-\u0026gt;next != NULL \u0026amp;\u0026amp; p-\u0026gt;num != index) { p = p-\u0026gt;next; } if(p-\u0026gt;num == index) { p-\u0026gt;num = num; p-\u0026gt;score = score; } else printf(\u0026#34;Can not find list index.\\n\u0026#34;); } return head; } // ノードを追加 struct student *add(struct student *head, int index, int num, float score) { printf(\u0026#34;add.\\n\u0026#34;); struct student *p1, *p2, *p3; if(head == NULL) { printf(\u0026#34;The List is NULL.\\n\u0026#34;); } else { p1 = p2 = head; while(p1-\u0026gt;next != NULL \u0026amp;\u0026amp; p1-\u0026gt;num != index) { p1 = p1-\u0026gt;next; p2 = p1; } if(p1-\u0026gt;num == index) { p3 = (struct student *)malloc(LEN); p3-\u0026gt;num = num; p3-\u0026gt;score = score; if(p2-\u0026gt;next == NULL) { p2-\u0026gt;next = p3; p3-\u0026gt;next = NULL; } else { p3-\u0026gt;next = p2-\u0026gt;next; p2-\u0026gt;next = p3; } } else printf(\u0026#34;Can not find list index.\\n\u0026#34;); } return head; } ","date":"2021-11-17T12:00:49+08:00","permalink":"https://blog.yexca.net/ja/archives/15/","title":"データ構造 連結リストのコード"},{"content":" 📢 この記事は gemini-2.5-flash によって翻訳されました この記事は Hiyoung が書いたよ\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 //配列スタックの実装 #include\u0026lt;stdio.h\u0026gt; #define MaxSize 50 typedef struct Stack_Array{ int data[MaxSize]; int top; }Sqstack,*pSqstack; void Initstack(); //初期化 int Isempty(); //スタックが空かチェック int Push(); //プッシュ（スタックに要素を追加） int Pop(); //ポップ（スタックから要素を取り出す） int Gettop(); //スタックのトップ要素を取得 int main(void) //テスト { int val; Sqstack s1; pSqstack ps1=\u0026amp;s1; Initstack(\u0026amp;s1); //初期化 if(Isempty(\u0026amp;s1)) //スタックが空かチェック printf(\u0026#34;スタックは空だよ！\\n\u0026#34;); else printf(\u0026#34;スタックは空じゃないよ！\\n\u0026#34;); printf(\u0026#34;プッシュする要素の値を入力してね\u0026#34;); //プッシュ 1 scanf(\u0026#34;%d\u0026#34;,\u0026amp;val); Push (ps1,\u0026amp;val); printf(\u0026#34;プッシュする要素の値を入力してね\u0026#34;); //プッシュ 2 scanf(\u0026#34;%d\u0026#34;,\u0026amp;val); Push (ps1,\u0026amp;val); if(Isempty(ps1)) //スタックが空かチェック printf(\u0026#34;スタックは空だよ！\\n\u0026#34;); else printf(\u0026#34;スタックは空じゃないよ！\\n\u0026#34;); if(Gettop(ps1,\u0026amp;val)) //スタックのトップ要素を取得 printf(\u0026#34;スタックのトップは%dだよ\\n\u0026#34;,val); else printf(\u0026#34;スタックのトップ要素を見つけられなかったよ！\\n\u0026#34;); if(Pop(ps1,\u0026amp;val)) //ポップ printf(\u0026#34;ポップ成功！取り出した要素は%dだよ\\n\u0026#34;,val); else printf(\u0026#34;ポップ失敗！\\n\u0026#34;); return 0; } //初期化 void Initstack (pSqstack ps1) { ps1-\u0026gt;top=-1; return; // スタックが空か判断 int Isempty(pSqstack ps1) if(ps1-\u0026gt;top==-1) return 1; else return 0; // スタックが満杯じゃなければプッシュするよ int Push(pSqstack ps1,int *val)//*val:アドレスを受け取る (int *(\u0026amp;val ) if(ps1-\u0026gt;top==MaxSize) return 0; else { ps1-\u0026gt;top++; ps1-\u0026gt;data[ps1-\u0026gt;top]=*val;//ここで渡されるのは値。ここの*valは*(\u0026amp;val)で、\u0026amp;valはメイン関数から入力される //ps1-\u0026gt;data[++ps1-\u0026gt;top]=*val; とも書ける。必ず++ps1-\u0026gt;top return 1; } } //スタックが空じゃなければポップして、valでトップ要素を返すよ int Pop(pSqstack ps1,int *val) { if(Isempty(ps1)) return 0; else { *val=ps1-\u0026gt;data[ps1-\u0026gt;top--]; return 1; } } //スタックのトップ要素を取得して、valで返すよ int Gettop(pSqstack ps1,int *val) { if(Isempty(ps1)) return 0; else { *val=ps1-\u0026gt;data[ps1-\u0026gt;top]; return 1; } } 図でシンプルに説明するよ\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 //スタックの連結リスト実装 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #define Stack_Init_Size 10 // 初期化スタックの最大長 #define StackIncrement 10 // スタックの最大スペースが足りない場合に増やす長さ typedef int ElemType; typedef int Status; typedef struct { ElemType *base; // スタックのベースポインタ ElemType *top; // スタックのトップポインタ int stack_size; // スタックの最大長 } SqStack; // スタックの初期化 Status InitStack(SqStack *S) { // 初期スペースを割り当てるよ S-\u0026gt;base = (ElemType *) malloc(Stack_Init_Size * sizeof(ElemType)); if (!S-\u0026gt;base) { exit(0); } S-\u0026gt;top = S-\u0026gt;base; /// トップとベースのポインタは同じだよ S-\u0026gt;stack_size = Stack_Init_Size; // スタックの最大長は初期長と同じ return 1; } // スタックが空かどうかを判断するよ。スタックのトップとベースのポインタが同じなら空だね。 Status EmptyStack(SqStack *S) { return S-\u0026gt;base == S-\u0026gt;top; } // スタックの実際の長さを取得するよ。トップポインタからベースポインタを引くと長さがわかる。 Status LengthStack(SqStack *S) { if (S-\u0026gt;top == S-\u0026gt;base) { return 0; } return (Status) (S-\u0026gt;top - S-\u0026gt;base); } // スタックのトップにある要素を取得するよ。引数eにトップの要素を入れる。 Status GetTopStack(SqStack *S, ElemType *e) { if (S-\u0026gt;top == S-\u0026gt;base) { return 0; } *e = *(S-\u0026gt;top - 1); return 1; } // プッシュ（スタックに要素を追加）。引数eは追加する要素。 Status PushStack(SqStack *S, ElemType e) { // スタックの最大長が足りなくなったら、新しい領域を確保して長さを増やすよ。 if (S-\u0026gt;top - S-\u0026gt;base \u0026gt;= S-\u0026gt;stack_size) { S-\u0026gt;base = (ElemType *)realloc(S-\u0026gt;base, (S-\u0026gt;stack_size + StackIncrement) * sizeof(ElemType)); if (!S-\u0026gt;base) { return 0; } // スタックのトップポインタは、ベースポインタに以前のスタック最大長を足したものになる。 S-\u0026gt;top = S-\u0026gt;base + S-\u0026gt;stack_size; // スタックの現在の最大長は、以前の最大長と増やした長さの合計になる。 S-\u0026gt;stack_size += StackIncrement; } *S-\u0026gt;top++ = e; // まず値を代入して、その後にトップポインタを上にずらす。 return 1; } // ポップ（スタックから要素を取り出す）。引数eに取り出した要素を入れる。 Status PopStack(SqStack *S, ElemType *e) { if (S-\u0026gt;base == S-\u0026gt;top) { return 0; } *e = *--S-\u0026gt;top; // まずトップポインタを下にずらして、その後に値を代入する。 return 1; } // スタックを破棄するよ。領域を解放して、トップとベースのポインタをNULLにして、長さを0にする。 Status DestroyStack(SqStack *S) { free(S-\u0026gt;base); S-\u0026gt;base = S-\u0026gt;top = NULL; S-\u0026gt;stack_size = 0; return 1; } // スタックを巡回して、各要素を順番に表示するよ。 Status StackTraverse(SqStack *S) { ElemType *p; if (S-\u0026gt;top == S-\u0026gt;base) { printf(\u0026#34;スタックはNULLだよ。\\n\u0026#34;); return 0; } p = S-\u0026gt;top; // スタックのトップから順番に下へ巡回する。 while (p \u0026gt; S-\u0026gt;base) { p--; printf(\u0026#34;%d \u0026#34;, *p); } printf(\u0026#34;\\n\u0026#34;); return 1; } int main() { SqStack q, *S; S = \u0026amp;q; int i, n, e; printf(\u0026#34;NULLスタックを作成するよ:\\n\u0026#34;); InitStack(S); printf(\u0026#34;スタックの長さを入力してね:\\n\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (i = 1; i \u0026lt;= n; i++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;e); PushStack(S, e); } printf(\u0026#34;スタックはNULLかな？\\n\u0026#34;); if (EmptyStack(S)) { printf(\u0026#34;うん！\\n\u0026#34;); } else { printf(\u0026#34;ううん！\\n\u0026#34;); } printf(\u0026#34;スタックの長さは %d だよ。\\n\u0026#34;, LengthStack(S)); printf(\u0026#34;スタックの中身はこれ:\\n\u0026#34;); StackTraverse(S); GetTopStack(S, \u0026amp;e); // eにトップの値を格納 printf(\u0026#34;トップのデータは %d だよ。\\n\u0026#34;, e); printf(\u0026#34;スタックに入れるデータを入力してね:\\n\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;e); PushStack(S, e); printf(\u0026#34;新しいスタックはこれ:\\n\u0026#34;); StackTraverse(S); printf(\u0026#34;トップのデータを削除するよ: \u0026#34;); PopStack(S, \u0026amp;e); // eに削除した値を格納 printf(\u0026#34;%d\\n\u0026#34;, e); printf(\u0026#34;新しいスタックはこれ:\\n\u0026#34;); StackTraverse(S); printf(\u0026#34;スタックを破棄するよ:\\n\u0026#34;); DestroyStack(S); StackTraverse(S); return 0; } ","date":"2021-11-11T23:03:27+08:00","permalink":"https://blog.yexca.net/ja/archives/14/","title":"C言語 データ構造コード"},{"content":" この記事は ctxbb が書きました、写真だけですから、翻訳出来ません。\n","date":"2021-11-11T18:01:33+08:00","permalink":"https://blog.yexca.net/ja/archives/13/","title":"扬州杏雨后"},{"content":" 📢 この記事は gemini-3-flash-preview によって翻訳されました miHoYoの「米遊社（HoYoLAB）」で原神の樹脂を確認できるけど、PCを使っている時にいちいちスマホを取り出してアプリを開くのは、正直言ってめちゃくちゃ不便だよね。\n元記事： 樹脂記録ソフトを自作してみた 元ソフトのリンク： パスワード：1w5b ダウンロードして開くと、UIDとCookieの入力を求められるよ。ここからは、米遊社のCookieを取得する方法を説明するね。\nまずは 米遊社 を開いてログインしよう。\n次に F12 キーを押してデベロッパーツールを開き、ページを更新してね。\n「ネットワーク（Network）」タブの「ys/」をクリックして、「リクエストヘッダー（Request Headers）」の中にあるCookieを右クリックしてコピーしよう。\n注意：必要なCookieのフィールドは account_id=xxx; cookie_token=xxx だから、適宜自分で修正して使ってね。\n**2022-6-6 修正 ( hiyoung )**\nmiHoYoがBBSで取得できるCookieの仕様を変更したせいで、一度に取得できるCookieが足りなくなっちゃったみたい。だから、以下の手順を追加してね。\nキーボードの F12 を押すか右クリックの「検証」でデベロッパーツールを開いて、「コンソール（Console）」をクリックして。\n以下を入力してね：\n1 var cookie=document.cookie;var ask=confirm(\u0026#39;Cookie:\u0026#39;+cookie+\u0026#39;\\n\\nDo you want to copy the cookie to the clipboard?\u0026#39;);if(ask==true){copy(cookie);msg=cookie}else{msg=\u0026#39;Cancel\u0026#39;} エンターキーで実行して、内容に間違いがなければ「OK」をクリック。これで、Cookieがクリップボードにコピーされるよ。\n注意：ブラウザは Chrome を使ってね。Edgeだと取得内容が不完全になるみたい ( yexca )。\n","date":"2021-11-10T15:21:30+08:00","permalink":"https://blog.yexca.net/ja/archives/12/","title":"原神の樹脂確認とプッシュ通知"},{"content":" 📢 この記事は gemini-3-flash-preview によって翻訳されました まずはダウンロードしたい動画を見つける（当たり前だね）。画像で赤く囲んである部分のリンクをコピーして。\n次に、 動画ダウンロード解析サイト を開いて、コピーしたリンクを入力したら「動画・画像の解析（解析视频图片）」をクリックしてね（検証が必要な場合は、サイトの指示に従えばOK）。\nあとは「動画をダウンロード（下载视频）」をクリックするだけ。\n// 今回の記事、内容薄すぎかな（笑）\n","date":"2021-11-10T11:29:51+08:00","permalink":"https://blog.yexca.net/ja/archives/11/","title":"Weiboの動画をダウンロードする方法"},{"content":" 📢 この記事は gemini-3-flash-preview によって翻訳されました だいたいの場合は、ブラウザやシステムに付いている「戻る」機能を使うと思うけど、たまにUIの動線がめちゃくちゃ使いにくいシステムってあるよね。そんな時、ページ内に「前のページに戻る」ボタンを自前で追加しておくと、ブラウジング体験がグッと良くなるよ。\nまず、WordPress の管理画面から「外観 - カスタマイズ」をクリックして、カスタマイズ画面を開こう。\n左側のメニューから「追加 CSS」を探してね（だいたい一番下にあるはず）。\nそしたら、そこに下のコードを貼り付けて。\n1 2 3 4 5 6 7 8 .float-button { position: fixed; height: 90px; width: 40px; bottom: 90px; right: 50px; /* 数値は自分の好みに合わせて調整してね */ } 入力が終わったら保存して、次はテーマの該当する箇所を編集していくよ。\nもしサーバーのファイルに直接アクセスできないなら、WordPress 管理画面の「外観 - テーマファイルエディター」から、ボタンを追加したいページを探して編集してね。\nサーバーのファイルにアクセスできるなら、パス サイトのルートディレクトリ/wp-content/themes/\u0026lt;あなたのテーマ名\u0026gt;/ を開いて、該当するページファイルを編集しよう。\nあとは、ボタンを表示させたい場所に下のコードを挿入して保存するだけ。\n1 2 3 4 \u0026lt;div class=\u0026#34;float-button\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; name=\u0026#34;Submit\u0026#34; value=\u0026#34;戻る\u0026#34; onclick=\u0026#34;javascript:history.back(-1);\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- 必要に応じて説明文とかも修正してみてね --\u0026gt; 参考記事 网页上的“返回上一页”的几种实现代码 div 套路之悬浮的 button ","date":"2021-11-10T11:06:27+08:00","permalink":"https://blog.yexca.net/ja/archives/10/","title":"WordPress に「前のページに戻る」ボタンを追加する方法"},{"content":" 📢 この記事は gemini-2.5-flash によって翻訳されました この記事は Hiyoung が書いたよ\n準備するもの：Win11 Pro以上、システム地域をアメリカに設定しといてね\n設定 -\u0026gt; アプリ -\u0026gt; オプション機能 -\u0026gt; Windowsの機能の有効化または無効化 で「仮想マシン プラットフォーム」にチェックを入れて、システムを再起動すればOKだよ\nそしたら、インストールパッケージをダウンロードしよう。リンク: https://pan.baidu.com/s/1215GlKeDCHcbE0I2SgtWLg 抽出コード: frkx\nダウンロードが終わったら、下の2つのファイルが見えるはずだよ。下から2つ目がAndroidサブシステムのインストールパッケージで、一番下がAPKファイルをインストールするためのWSAツールボックスだね\n一番下の2つのファイルだよ\nじゃあ、Windows PowerShellを管理者として開こう\nコマンドを実行するよ：add-appxpackage スペース + Androidサブシステムのファイルパス（コマンドとパスの間にスペースを入れるのを忘れずにね！）\n!Win11android_4 これが表示されたらインストール成功ってことだよ\nそしたら、スタートメニューにインストール済みのAndroidサブシステムが見えるはず。クリックして実行して、「開発者モード」にチェックを入れておこう\nもう一つのZIPファイルを解凍して実行すれば、APKファイルをインストールできるよ\nこれでインストールは完了だよ\n以下の内容は yexca が追記したよ\nもしツールボックスがインストールできなかったり、下の図のような状況になったりしたら、サブシステム設定を開いて、最初のオプション「ファイル」を開いてから、もう一度ツールボックスを開いてみてね\nファイルパスの取得 ファイルの上で右クリックして「プロパティ - セキュリティ」を選んでみて。最初の行の「オブジェクト名」がファイルパスになるよ\nWSAツールボックス 元の投稿アドレス ","date":"2021-11-09T23:45:42+08:00","permalink":"https://blog.yexca.net/ja/archives/9/","title":"Win11 公式Androidサブシステムインストール"},{"content":" 📢 この記事は gemini-3-flash-preview によって翻訳されました この記事は Hiyoung が書いたよ。\n1. SQL ORDER BY キーワード ORDER BY キーワードは、結果セットを1つまたは複数の列でソートするために使うんだ。\nORDER BY キーワードはデフォルトで昇順（小さい順）にレコードを並べ替えるよ。もし降順（大きい順）にしたいなら、DESC キーワードを使えばOK。\nSQL ORDER BY の構文 1 2 3 SELECT *column\\_name*,*column\\_name* FROM *table\\_name* ORDER BY *column\\_name*1,*column\\_name*2 ASC|DESC; – ASC は昇順、DESC は降順を意味するよ。\n– ORDER BY 文を使うときは、すべての文の最後に置くのがルール。複数の列でソートするときは、まず column\\_name1 で並べ替えて、その次に column\\_name2… という順序で処理されるよ。\n2. すべてのデータを削除する（DELETE と DROP TABLE） テーブル自体を削除せずに、テーブル内のすべての行だけを削除することができるよ。これなら、テーブルの構造、属性、インデックスはそのまま残るんだ。\nDELETE FROM table\\_name;\nまたは\nDELETE * FROM table\\_name;\n注意： レコードを削除するときはマジで気をつけて！やり直しはきかないからね！\nDROP TABLE 文 DROP TABLE 文はテーブルそのものを削除するために使うよ。\nDROP TABLE table\\_name\n注意： DELETE と違うのは、DROP TABLE はテーブルのデータも構造も丸ごと削除しちゃうこと。これも後戻りできない操作だよ！\nDROP DATABASE 文 DROP DATABASE 文はデータベースを削除するために使うんだ。\nDROP DATABASE database\\_name\nTRUNCATE TABLE 文 もしテーブル内のデータだけを削除したくて、テーブル自体は残しておきたい場合はどうすればいいかな？\nそんなときは TRUNCATE TABLE 文を使おう。\nTRUNCATE TABLE table\\_name\n3. SQL JOIN SQL の JOIN は、2つ以上のテーブルの行を組み合わせるために使われるよ。\n下の図は、LEFT JOIN、RIGHT JOIN、INNER JOIN、OUTER JOIN に関連する 7 種類の使い方を示しているんだ。\nINNER JOIN：テーブル間に少なくとも1つのマッチがあれば行を返す（INNER JOIN と JOIN は同じ意味だよ） LEFT JOIN：右のテーブルにマッチするものがなくても、左のテーブルのすべての行を返す RIGHT JOIN：左のテーブルにマッチするものがなくても、右のテーブルのすべての行を返す FULL JOIN：どちらかのテーブルにマッチがあれば行を返す 注意：SQL の JOIN 文は、実はデータベース理論における「結合」の概念に対応しているんだ。LEFT JOIN、RIGHT JOIN、INNER JOIN は自然結合に、FULL JOIN はデカルト積に対応しているよ。\n4. SQL 制約 (Constraints) 1 2 3 4 5 6 7 CREATE TABLE table_name ( column_name1 data_type(size) constraint_name, column_name2 data_type(size) constraint_name, column_name3 data_type(size) constraint_name, .... ); NOT NULL – その列に NULL 値を保存できないようにする。 UNIQUE – その列の各行が必ず一意（ユニーク）な値であることを保証する。（1つのテーブルに複数の UNIQUE 制約を設定できるけど、PRIMARY KEY は1つだけ。PRIMARY KEY には自動的に UNIQUE 制約が含まれるよ） PRIMARY KEY – NOT NULL と UNIQUE を組み合わせたもの。その列（または複数列の組み合わせ）に一意の識別子を持たせ、特定のレコードを素早く簡単に見つけられるようにするんだ。（主キー） FOREIGN KEY – あるテーブルのデータが別のテーブルの値と一致することを保証し、参照整合性を守るためのもの。（外部キー） CHECK – 列の値が指定された条件を満たしているか確認する。 DEFAULT – 列に値が指定されなかったときのデフォルト値を決めておく。 5. AUTO INCREMENT フィールド 新しいレコードを挿入するたびに、主キーの値を自動的に生成したいことってよくあるよね。\nそんなときは、テーブルに auto-increment フィールドを作成すればいいんだ。\n次の SQL 文は、\u0026ldquo;Persons\u0026rdquo; テーブルの \u0026ldquo;ID\u0026rdquo; 列を auto-increment の主キーとして定義しているよ。\n1 2 3 4 5 6 7 8 CREATE TABLE Persons ( ID int IDENTITY(1,1) PRIMARY KEY, LastName varchar(255) NOT NULL, FirstName varchar(255), Address varchar(255), City varchar(255) ) 上の例では、IDENTITY の開始値は 1 で、新しいレコードが追加されるたびに 1 ずつ増えていく設定になっているよ。\nヒント： もし \u0026ldquo;ID\u0026rdquo; 列を 10 から始めて 5 ずつ増やしたいなら、IDENTITY を IDENTITY(10,5) に変えれば OK。\n\u0026ldquo;Persons\u0026rdquo; テーブルに新しいレコードを挿入するとき、\u0026ldquo;ID\u0026rdquo; 列に値を指定する必要はないよ（自動的にユニークな値が割り振られるからね）。\n1 2 INSERT INTO Persons (FirstName,LastName) VALUES (\u0026#39;Lars\u0026#39;,\u0026#39;Monsen\u0026#39;) この SQL 文を実行すると、\u0026ldquo;Persons\u0026rdquo; テーブルに新しいレコードが挿入され、\u0026ldquo;ID\u0026rdquo; 列には自動で値が入り、\u0026ldquo;FirstName\u0026rdquo; は \u0026lsquo;Lars\u0026rsquo;、\u0026ldquo;LastName\u0026rdquo; は \u0026lsquo;Monsen\u0026rsquo; に設定されるんだ。\n6. トリガー 参考： SqlServer 基礎之(触发器) – wangchuang2017 – 博客园 ","date":"2021-11-08T11:51:18+08:00","permalink":"https://blog.yexca.net/ja/archives/8/","title":"SQL文のいくつかの構文詳細 (SQL Server編)"},{"content":" 📢 この記事は gemini-3-flash-preview によって翻訳されました この記事は Hiyoung が書いたよ。\nSQL Server と Navicat をインストールした後、Navicat にデータベースを追加する手順はこんな感じ：\n接続名は特に決まりはないから、自分の好きな名前を付けてね。\nインストールした SQL Server 構成マネージャーを開く。\n注意：SQL Server（SQLEXPRESS）が実行中であることを確認してね。そうじゃないと Navicat から接続できないんだ。 ダブルクリックで開いて「サービス」をクリックすると、自分のホスト名が確認できるよ。\nNavicat を開いて、ホストのところに「ホスト名 \\SQLEXPRESS」の形式で入力する。\nユーザー名は「sa」を入力してね（これは SQL Server インストール時のデフォルトのユーザー名。具体的な SQL Server の使い方はネットにたくさんチュートリアルがあるから、そっちを参考にしてみて）。パスワードは自分で設定したもの（これもインストール時に決めたやつだね）を入力。\n接続テストをして成功すれば、もう使えるよ。\n注：これはあくまで僕がインストール中に遭遇した問題についてのメモだから、詳しいインストール手順はネットで調べてみてね。\nNavicat 15 とレジストリツールのリンクも貼っておくよ： https://pan.baidu.com/s/1cJ1EZ9Gyz6Jp6J03VqcDHA 抽出コード：3n7g\n","date":"2021-11-07T23:41:46+08:00","permalink":"https://blog.yexca.net/ja/archives/7/","title":"Navicat で SQL Server に接続する際に困ったこといくつか"},{"content":" 📢 この記事は gemini-3-flash-preview によって翻訳されました この記事は Hiyoung によって書かれたよ。\n元の記事: https://blog.hiyoung.icu/2022/12/15/997871bc263d/ VSC はあくまでテキストエディタであって、IDE（統合開発環境）じゃないんだ。だからコンパイラやその他の機能は含まれていない。コンパイラは自分でインストールする必要があるよ。\n第一歩：まずは VS Code の公式サイトからソフトをダウンロードしよう。リンク： Visual Studio Code – Code Editing. Redefined 第二歩：コンパイラをダウンロードするよ。C 言語には gcc を使う。リンク： MinGW-w64 – for 32 and 64 bit Windows download | SourceForge.net 。最新バージョンの中の x86_64-posix-seh を選べば OK。公式サイトからのダウンロードは遅いかもしれないから、一応百度網盤（Baidu Netdisk）のリンクも載せておくね。\n（以下、百度網盤の秒伝リンク：b48357234368d9ba439fc0db6e86531d#84cbf1dc60abe4fff77d035540ea3132#140697937#mingw64.zip）\n（通常の百度網盤リンク：リンク: https://pan.baidu.com/s/17FYT\\_Y-s-I2yajFc2MICqw 抽出コード: ewis ）\n第三歩：E:\\mingw64\\bin をシステム環境変数に追加する（ドライブ文字などは自分がコンパイラをインストールした場所に合わせてね）。\nWin11 を例にすると：設定 -\u0026gt; システム -\u0026gt; バージョン情報 -\u0026gt; システムの詳細設定 -\u0026gt; 環境変数 -\u0026gt; システム環境変数 -\u0026gt; Path をクリック -\u0026gt; 編集 -\u0026gt; 参照 -\u0026gt; 該当するフォルダを追加すれば OK。\n第四歩：\nWin+R キーを押して cmd を実行（この手順は飛ばさないで）。gcc と入力してみて。no input files と表示されれば成功。「内部コマンドまたは外部コマンド\u0026hellip;として認識されていません」とか「\u0026lsquo;gcc\u0026rsquo; という名前は、cmdlet、関数\u0026hellip;として認識されません」と出たら失敗だよ。もし後者のエラーが出るなら、gcc があるフォルダが環境変数の Path に入っていない証拠だから、追加し直してね。追加したのにダメな場合は、再起動してみて（再起動を忘れずに）。再起動してもダメなら、どこかの操作が間違っているはずだよ。\ngcc -v と入力すると、gcc のバージョンが表示される。もし表示されたバージョンが今ダウンロードしたものより古い、あるいは違う場合は、Path の中に古いバージョンのコンパイラが残っている可能性がある（他の IDE を入れた時に一緒に入ったのかも）。その場合は、Path から古い gcc のパスを削除する必要があるよ。\nこの 2 つの検証は必ずパスさせること。そうじゃないと環境変数を修正しなきゃいけない。間違えて他の大事なパスを消さないように気をつけてね。\n第五歩：VS Code を開いて、関連するプラグインをダウンロードしよう。\n第六歩：2 つの json ファイルを作成する必要がある。以下は launch.json と tasks.json だよ（ファイル名はこの通りにする必要がある）。コード内のコメントをよく読んで、自分のコンパイラのパスに書き換える場所がいくつかあるから注意してね。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 { // IntelliSense を使用して属性を詳しく知る。 // 既存の属性の説明を表示するにはホバーする。 // 詳細については次を参照: https://go.microsoft.com/fwlink/?linkid=830387 \u0026#34;version\u0026#34;: \u0026#34;0.2.0\u0026#34;, \u0026#34;configurations\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;gcc.exe - アクティブファイルの生成とデバッグ\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;cppdbg\u0026#34;, \u0026#34;request\u0026#34;: \u0026#34;launch\u0026#34;, \u0026#34;program\u0026#34;: \u0026#34;${fileDirname}\\\\bin\\\\${fileBasenameNoExtension}.exe\u0026#34;,//生成されたバイナリを現在のファイルの bin フォルダに入れるという意味。自分で bin フォルダを作成しておく必要があるよ。 \u0026#34;args\u0026#34;: [], \u0026#34;stopAtEntry\u0026#34;: false, \u0026#34;cwd\u0026#34;: \u0026#34;${fileDirname}\u0026#34;, \u0026#34;environment\u0026#34;: [], \u0026#34;externalConsole\u0026#34;: false, \u0026#34;MIMode\u0026#34;: \u0026#34;gdb\u0026#34;, \u0026#34;miDebuggerPath\u0026#34;: \u0026#34;E:\\\\mingw64\\\\bin\\\\gdb.exe\u0026#34;, \u0026#34;setupCommands\u0026#34;: [ { \u0026#34;description\u0026#34;: \u0026#34;gdb のプリティプリントを有効にする\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;-enable-pretty-printing\u0026#34;, \u0026#34;ignoreFailures\u0026#34;: true } ], \u0026#34;preLaunchTask\u0026#34;: \u0026#34;C/C++: gcc.exe アクティブファイルの生成\u0026#34; } ] } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 { \u0026#34;tasks\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;cppbuild\u0026#34;, \u0026#34;label\u0026#34;: \u0026#34;C/C++: gcc.exe アクティブファイルの生成\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;E:\\\\mingw64\\\\bin\\\\gcc.exe\u0026#34;,//自分のファイルパスに変更してね \u0026#34;args\u0026#34;: [ /*\u0026#34;${fileDirname}\\\\*.c\u0026#34;, \u0026#34;-o\u0026#34;, \u0026#34;${fileDirname}\\\\bin\\\\${fileBasenameNoExtension}.exe\u0026#34;, \u0026#34;-g\u0026#34;//複数ファイルコンパイル*/ \u0026#34;-g\u0026#34;, \u0026#34;${file}\u0026#34;, \u0026#34;-o\u0026#34;, \u0026#34;${fileDirname}\\\\bin\\\\${fileBasenameNoExtension}.exe\u0026#34;//生成されたバイナリを現在のファイルの bin フォルダに入れるという意味。自分で bin フォルダを作成しておく必要があるよ。 ], \u0026#34;options\u0026#34;: { \u0026#34;cwd\u0026#34;: \u0026#34;${fileDirname}\u0026#34; }, \u0026#34;problemMatcher\u0026#34;: [ \u0026#34;$gcc\u0026#34; ], \u0026#34;group\u0026#34;: { \u0026#34;kind\u0026#34;: \u0026#34;build\u0026#34;, \u0026#34;isDefault\u0026#34;: true }, \u0026#34;presentation\u0026#34;: { \u0026#34;echo\u0026#34;: true, \u0026#34;reveal\u0026#34;: \u0026#34;always\u0026#34;, // タスク実行時にターミナルパネルにジャンプするかどうか。always, silent, never が選べる。詳細は VSC のドキュメントを参照。 \u0026#34;focus\u0026#34;: true, // true にするとタスク実行時にターミナルにフォーカスが当たる。でも C/C++ のコンパイルではあまり意味がないかも。 \u0026#34;panel\u0026#34;: \u0026#34;shared\u0026#34; // 異なるファイルのコンパイル情報を一つのターミナルパネルで共有する。 }, \u0026#34;detail\u0026#34;: \u0026#34;デバッガーによって生成されたタスク。\u0026#34; }, { \u0026#34;type\u0026#34;: \u0026#34;cppbuild\u0026#34;, \u0026#34;label\u0026#34;: \u0026#34;(複数ファイル)gcc.exe - アクティブファイルの生成とデバッグ\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;E:\\\\mingw64\\\\bin\\\\gcc.exe\u0026#34;,//自分のファイルパスに変更してね \u0026#34;args\u0026#34;: [ \u0026#34;${fileDirname}\\\\*.c\u0026#34;, \u0026#34;-o\u0026#34;, \u0026#34;${fileDirname}\\\\bin\\\\${fileBasenameNoExtension}.exe\u0026#34;,//生成されたバイナリを現在のファイルの bin フォルダに入れるという意味。自分で bin フォルダを作成しておく必要があるよ。 \u0026#34;-g\u0026#34; ], \u0026#34;options\u0026#34;: { \u0026#34;cwd\u0026#34;: \u0026#34;${fileDirname}\u0026#34; }, \u0026#34;problemMatcher\u0026#34;: [ \u0026#34;$gcc\u0026#34; ], \u0026#34;group\u0026#34;: { \u0026#34;kind\u0026#34;: \u0026#34;build\u0026#34;, \u0026#34;isDefault\u0026#34;: true }, \u0026#34;presentation\u0026#34;: { \u0026#34;echo\u0026#34;: true, \u0026#34;reveal\u0026#34;: \u0026#34;always\u0026#34;, // タスク実行時にターミナルパネルにジャンプするかどうか。 \u0026#34;focus\u0026#34;: true, \u0026#34;panel\u0026#34;: \u0026#34;shared\u0026#34; }, \u0026#34;detail\u0026#34;: \u0026#34;デバッガーによって生成されたタスク。\u0026#34; } ], \u0026#34;version\u0026#34;: \u0026#34;2.0.0\u0026#34; } これで設定作業はだいたい終わり！VS Code には便利なプラグインがたくさんあるから、いろいろ探してみてね。また今度、おすすめのプラグインを紹介する記事も書くつもりだよ。\n","date":"2021-11-07T23:32:26+08:00","permalink":"https://blog.yexca.net/ja/archives/6/","title":"VS Code で C 言語環境を構築する"},{"content":" 📢 この記事は gemini-2.5-flash によって翻訳されました 本文 VS CodeとPythonのインストールと環境変数の設定が終わったら、\nVS Codeを開いて、拡張機能でPythonを検索してダウンロードしてね。\nエクスプローラーでPythonのソースファイル（.py）を新しく作ると、.vscodeフォルダの下にsetting.jsonファイルが生成されるよ（自動で生成されなかったら自分で作っても大丈夫）。\nsetting.jsonファイルを開いて、以下のコードに置き換えてね。\n1 2 3 4 5 6 { \u0026#34;python.linting.flake8Enabled\u0026#34;: true, \u0026#34;python.linting.flake8Args\u0026#34;: [\u0026#34;--max-line-length=248\u0026#34;], \u0026#34;python.linting.pylintEnabled\u0026#34;: false } ここでPythonファイルに戻ると、VS Codeの右下に警告が出るから、ダウンロードをクリックしてね。\nCTRL+SHIFT+Pを押して、「Python: Select Interpreter」（つまりPython：インタープリターを選択）って入力するんだ。\nそしたら、ダウンロードしたインタープリターを選べばOK。\nもし.vscodeフォルダの下にlaunch.jsonファイルがある場合は、そのファイルのconfigurationsに以下のコードを追加する必要があるよ。\n1 2 3 4 5 6 7 { \u0026#34;name\u0026#34;: \u0026#34;Python: 現在のファイル\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;python\u0026#34;, \u0026#34;request\u0026#34;: \u0026#34;launch\u0026#34;, \u0026#34;program\u0026#34;: \u0026#34;${file}\u0026#34;, \u0026#34;console\u0026#34;: \u0026#34;integratedTerminal\u0026#34; } 参考記事 VsCode Python環境設定初心者向けチュートリアル VSCode Python設定チュートリアル ","date":"2021-11-07T11:28:58+08:00","permalink":"https://blog.yexca.net/ja/archives/5/","title":"VsCode で Python 環境を設定する"},{"content":" 📢 この記事は gemini-3-flash-preview によって翻訳されました この記事は Hiyoung によって書かれたよ。\nmailto: を使うと、システムのデフォルトのメールクライアントを自動で起動して、宛先、CC、BCC、件名、本文を自動で入力できるんだ。\nパラメーターの説明：\nmailto： 宛先（複数は「;」で区切る）\ncc： CC（複数は「;」で区切る）\nbcc： BCC（複数は「;」で区切る）\nsubject： 件名\nbody： 本文\n各パラメーターは「\u0026amp;」で繋げばOK。\n例えば：\u0026lt;a mailto:***@***.com?subject=this is subject\u0026amp;body=this is body\u0026gt;…\u0026lt;a\u0026gt;\n注：Elementor を使う場合は、テキストエディターのハイパーリンク設定に直接「mailto:***@***.com?subject=this is subject\u0026amp;body=this is body」と入力すれば大丈夫だよ。\n","date":"2021-11-06T17:05:36+08:00","permalink":"https://blog.yexca.net/ja/archives/4/","title":"システムのデフォルトメールクライアントを自動で起動する方法"},{"content":" 📢 この記事は gemini-3-flash-preview によって翻訳されました 本文 まずは、埋め込みたい動画のページに行って、共有ボタンの上にマウスを置いてみて（クリックはしなくていいよ）。\nそれから「埋め込みコード」のところまで移動してコピーしてね。\n（今回の例だとこんな感じのコードになるよ）\n1 \u0026lt;iframe src=\u0026#34;//player.bilibili.com/player.html?aid=583631611\u0026amp;bvid=BV1Tz4y1X7Bg\u0026amp;cid=206708397\u0026amp;page=1\u0026#34; scrolling=\u0026#34;no\u0026#34; border=\u0026#34;0\u0026#34; frameborder=\u0026#34;no\u0026#34; framespacing=\u0026#34;0\u0026#34; allowfullscreen=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;/iframe\u0026gt; このコードの中にある「aid」と「cid」の部分（つまり aid=583631611 と cid=206708397 ）が必要なんだ。\n次に、aidとcidを下のコードの対応する場所に書き込もう。\n1 2 3 \u0026lt;div style=\u0026#34;position: relative; padding: 30% 45%;\u0026#34;\u0026gt; \u0026lt;iframe style=\u0026#34;position: absolute; width: 100%; height: 100%; left: 0; top: 0;\u0026#34; src=\u0026#34;https://player.bilibili.com/player.html?cid=206708397\u0026amp;aid=583631611\u0026amp;page=1\u0026amp;as_wide=1\u0026amp;high_quality=1\u0026amp;danmaku=0\u0026#34; frameborder=\u0026#34;no\u0026#34; scrolling=\u0026#34;no\u0026#34;\u0026gt;\u0026lt;/iframe\u0026gt; \u0026lt;/div\u0026gt; （上のコードはaidとcidを書き換え済みだよ）\n記事を書いてる時に動画を入れたくなったら、ブロックを「カスタムHTML」にして、aidとcidを書き換えたコードを貼り付けるだけでOK。\n実際のサンプル動画はこんな感じ。\n参考記事 关于博客园内嵌入bilibili视频 ","date":"2021-11-06T16:43:20+08:00","permalink":"https://blog.yexca.net/ja/archives/3/","title":"WordPressでBilibili動画を埋め込む方法"},{"content":" 📢 この記事は gemini-3-flash-preview によって翻訳されました デフォルトでは、WordPressは投稿者がサイトのメディアライブラリにあるすべての画像を見ることができるようになっているんだ。つまり、投稿者がライブラリ内の全ファイルを確認できてしまうってこと。管理者や編集者、他の投稿者がアップロードした画像までも見ることができちゃうんだよね。\n多くのサイトではそれほど重要じゃないかもしれないけど、もし複数の投稿者がいるサイトを運営しているなら、ここを制限したいこともあると思う。\nまずは、サイトのルートディレクトリ/wp-content/themes/現在使っているテーマ名/ に移動してね。\nそこで functions.php ファイルを見つけて編集し、最後に以下のコードを挿入すればOKだよ。\n1 2 3 4 5 6 7 8 9 10 11 12 // Limit media library access add_filter( \u0026#39;ajax_query_attachments_args\u0026#39;, \u0026#39;wpb_show_current_user_attachments\u0026#39; ); function wpb_show_current_user_attachments( $query ) { $user_id = get_current_user_id(); if ( $user_id \u0026amp;\u0026amp; !current_user_can(\u0026#39;activate_plugins\u0026#39;) \u0026amp;\u0026amp; !current_user_can(\u0026#39;edit_others_posts \u0026#39;) ) { $query[\u0026#39;author\u0026#39;] = $user_id; } return $query; } 参考にさせていただいた記事 如何限制媒体库对 WordPress 中用户自己上传的内容的访问 ","date":"2021-11-06T14:31:04+08:00","permalink":"https://blog.yexca.net/ja/archives/2/","title":"WordPressでユーザーのメディアライブラリアクセスを制限する"},{"content":"WordPress へようこそ。これが最初の投稿です。編集または削除して書き込みを始めてください。\n","date":"2021-11-06T14:15:19+08:00","permalink":"https://blog.yexca.net/ja/archives/1/","title":"Hello World！"}]