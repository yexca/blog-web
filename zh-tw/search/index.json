[{"content":" 📢 本文由 ChatGPT 翻譯 引言：飄零的學習感 為了讓自己的英文程度能稍微提升，我在一些不太重要的地方會盡量使用英文，例如遊戲或日常的應用軟體。可是每次使用時，總會有一種沒有真正掌握到什麼的感覺，彷彿整段經歷都是飄浮不定的，甚至好像自己根本沒經歷過。\n仔細想想，這或許是從「翻譯」到「融入」之間的落差。當母語中文介入時，這段經歷會被牢牢地繫在我的語言與思維裡；但在完全非母語的環境下，這段經歷卻無法與母語產生連結。而我平常又是依靠母語思考，自然就忽視了非母語的思考過程。\n類比：控制的執行感 就我實際的體驗來說，在完全英文的遊戲環境裡，我常常覺得自己什麼都不懂，就算是最簡單的單字也一樣。但如果是和朋友一起連線遊玩，並用中文溝通，感覺又完全不同。那種狀態像是重新切回翻譯模式，讓我瞬間輕鬆了許多，從一片慌亂中轉為多少有點掌握感。\n這也讓我聯想到在東京的生活。即使用日文對話，心裡卻常常沒有什麼實感，總覺得自己像是在執行預先設定好的指令，而不是在「活著」。也因此，我甚至喜歡上聽中文歌，因為只有那樣，在街頭閒逛時才會覺得自己還真實地存在。\n矛盾：理論最優與現實退縮 不過話說回來，這樣的狀態不就是語言學習所推崇的「完全脫離母語思考」的理想環境嗎？當我全身心沉浸在英文遊戲裡，沒有任何中文干擾，理論上應該是最好的學習方式吧？畢竟，這幾乎就等於所謂的 Thinking in English。\n然而，實際感受卻完全相反。當遇到一個不認識的單字時，我立刻會覺得自己什麼都做不了、什麼都不會。這種感覺會自然地引發退縮，讓我乾脆什麼都不做。結果是，我覺得自己的英文程度完全沒有進步，甚至反而更加沒有自信。\n反思：完美奇點的幻覺 回顧我的學習歷程，我突然意識到，自己好像一直沒有真正「學習」過。更多時候，我只是在依靠直覺與經驗判斷。在遊戲或日常生活中，能取得的資訊並不只有語言，還有動作、提示、環境等線索。也許我只是靠這些訊號來決定下一步該做什麼，於是給了自己「聽懂了」的錯覺，但語言本身卻成了被忽略的部分，所以說到底並沒有真正學到語言。\n那麼，我以前的學習方式（不只語言）又是如何呢？似乎總是要等到一個「完美的時機」再投入。除非一切條件都很「完美」，否則我就會主觀認為這樣的努力毫無意義。這大概就像是那句話——「收藏從未停止，學習從未開始。」\n這種心態不只體現在感受上，也表現在對環境與教材的要求。幾乎就像「廣度優先演算法」，在每一個階段都想要達到某種「最優」才肯繼續。否則就會覺得完全沒有意義，就算勉強自己去做，結果也只是無果。\n生活：理性與感性的錯位 這又讓我想起生活方式。對於某些不順心的事情（不管是事件還是物品），短期與長期往往呈現出完全不同的心態。短期內它會擾亂心情，但從長期來看，好像根本不那麼重要。\n就像有些物品，長遠看或許會有用，但眼下完全用不上。只是因為「未來可能需要」就讓自己一直處在不舒服的狀態，最後的結果卻是根本沒派上用場。\n整理東西也是同樣的情況。理性上覺得整理會更好，感性上卻提不起勁，或者總想等到一個「完美的時機」再整理。於是，在這個「完美時機」到來之前，每次想到這件事都會覺得煩躁。\n結論：貌似沒有「正解」 那麼，有沒有一個答案能讓學習或生活變得高效呢？\n我想……大概是沒有的吧。生活中充滿了理性決策與感性決策。也許我打算在某段時間內提升某項能力，但由於未來不可預測，加上情緒狀態不同，每一次執行計畫時的結果，都可能超出或低於預期。\n不過，這並不代表毫無技巧可循。既然新的資訊可能隨時推翻原本的計畫，那麼也許可以嘗試換個角度來約束自己：放棄某個面向，卻在另一個面向補足。比如固定時間，讓學習量浮動；或者設定最少的學習量，再讓時間浮動。\n引申：目的性與新鮮感 說到這裡，我忽然又有個想法。只要一件事情帶有「目的性」，在感性上就會變得難以持續。就算是娛樂，像玩遊戲也是。當我帶著「為了釋放壓力」的目的去玩時，腦子裡反而一直在想：「我有沒有真的放鬆下來？」這種意識本身就成了一種壓力。結果不但沒有舒壓，反而越玩越累，甚至出現類似「電子陽痿」的感覺。\n所以有人提出「多培養一些興趣比較好」。這的確是個不錯的方法。因為在不同情境下，可以選擇不同的釋壓方式（以興趣為前提），就能避免過度依賴單一手段。\n不過，或許本質其實更簡單：就是因為「新鮮感」吧。新事物會帶來新鮮的能量。\n結語：「不可控」的未來 那麼，這篇文章到底寫了什麼呢？老實說，我也不確定。也許只是我混亂思緒下的產物罷了。\n但或許，這才是真正的答案——接受生活的「不可控」。我總妄想用理性架構一切，但似乎……任何理性都無法解釋全部。\n就像「狀態—行為理論」所說，只有在掌握所有變數的情況下，才能百分之百預測結果。但我們怎麼可能獲得生活中的「所有變數」呢？\n也許，無法完全掌握變數，本身就是生活的一個變數吧。\n","date":"2025-08-18T18:27:12+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/252/","title":"漂浮的學習，錯位的人生"},{"content":" 📢 本文由 ChatGPT 翻譯。并且，該軟件只有簡體字 原本只是想隨便寫個小工具，打算用兩天就放著（以前大多都是這樣），沒想到在沒出錯的情況下幫我省下不少時間，越用越順手。\n慢慢地也喚起我以前那個「為什麼不用 SQLite 呢」的想法。確實，每次開 MySQL 真的太麻煩了，於是就誕生了這個版本，終於不用每次都啟動資料庫服務了 （也終於變得比較像給人用的了）\n使用方法 專案位址： https://github.com/yexca/PixivDownloader-SQLite GUI 跟前一代差不多，可以參考 https://blog.yexca.net/archives/211/ 設定說明 使用前需要先設定以下項目：\nrefresh token（Pixiv 登入驗證，參考： Pixiv OAuth Flow ） 下載路徑（預設 D:\\Downloads） 下載說明 使用時只需輸入：\n畫師 ID，或是 作品 ID（若兩者皆輸入，將以畫師 ID 為主） 點擊下載即可下載所有作品並記錄到資料庫（若該畫師尚無記錄則下載所有作品，已有記錄則只下載未下載的部分）\n錯誤處理 目前僅對爬取錯誤進行處理。若出現錯誤提示，有可能是以下原因：\n未設定 refresh token 或 token 已失效 畫師帳號不存在 作品不存在 我沒有加上詳細錯誤說明，如出錯請先檢查以上三點。\n至於其他錯誤（例如軟體直接閃退），可以將 程式根目錄/logs/app_*-*-*.log 中最新的 log 檔寄給我，並說明情況。\n聯絡方式：PixivDownloader#yexca.net（請將 # 換成 @）\n新特性：從 MySQL 改為 SQLite 這次最大變動就是不再需要自建 MySQL，改用輕量化的 SQLite。\n因此也移除了原本不必要的資料庫設定，將設定與 Pixiv 的驗證 Token 整合在一起。\n加了個 icon（隨便請 ChatGPT 畫的），UI 稍作調整，變動不大。\n程式碼初步進行架構化處理……雖然寫到最後又有點亂了就是了 不過說不定哪天我又回來重構一次啦。\n舊版 MySQL 資料庫的遷移方法 雖然我覺得應該沒人用上一版，但還是說一下：由於資料結構不同，最推薦的方式是查詢導出並轉為 INSERT 語法，例如：\n1 2 3 SELECT ID, name, downloadedDate, lastDownloadID, url FROM pic WHERE platform = \u0026#39;pixiv\u0026#39;; 將結果導出為 SQL 語法（我使用的是 Dataflare，它支援這個功能）。\n然後建立一個 Python 檔案，寫入以下內容：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 import sqlite3 conn = sqlite3.connect(\u0026#34;pixiv.db\u0026#34;) cursor = conn.cursor() cursor.execute(\u0026#39;\u0026#39;\u0026#39; Create Table If Not Exists pic ( ID TEXT PRIMARY KEY, name TEXT, downloadedDate TEXT, lastDownloadID TEXT, url TEXT ) \u0026#39;\u0026#39;\u0026#39;) conn.commit() cursor.execute(\u0026#34;\u0026#34;\u0026#34; INSERT INTO `pic` (`ID`, `name`, `downloadedDate`, `lastDownloadID`, `url`) VALUES (\u0026#39;123\u0026#39;, \u0026#39;name1\u0026#39;, \u0026#39;2024-06-08 00:00:00\u0026#39;, \u0026#39;1234\u0026#39;, \u0026#39;https://www.pixiv.net/users/123\u0026#39;), (\u0026#39;234\u0026#39;, \u0026#39;name2\u0026#39;, \u0026#39;2025-02-12 00:05:36\u0026#39;, \u0026#39;2345\u0026#39;, \u0026#39;https://www.pixiv.net/users/234\u0026#39;), (\u0026#39;345\u0026#39;, \u0026#39;name3\u0026#39;, \u0026#39;2025-01-11 17:26:17\u0026#39;, \u0026#39;3456\u0026#39;, \u0026#39;https://www.pixiv.net/users/345\u0026#39;); \u0026#34;\u0026#34;\u0026#34; ) conn.commit() cursor.execute(\u0026#34;\u0026#34;\u0026#34; Select * from pic \u0026#34;\u0026#34;\u0026#34; ) rows = cursor.fetchall() for row in rows: print(row) conn.close() 其中 cursor.execute 的內容請自行替換為你的備份資料。我這裡提供三筆示範資料。\n最後，將產生的資料庫檔案 pixiv.db 放到 程式根目錄/resources 即可。\n一點開發感想：從「亂寫」到「理解混亂」 老實說這次重構是因為上次寫得太亂，覺得非整頓不可，結果改著改著我終於明白為什麼上次會那麼亂了 😂\n不如說，這次的結構也沒好到哪去，寫到一半直接放棄重構，乾脆複製貼上，導致現在有駝峰式命名也有底線命名，真是懶得再改，唉。\n總之算是一個能正常運作的半成品，能用就好了啦～\n","date":"2025-05-18T16:20:33+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/248/","title":"Pixiv 下載器重構記：從亂寫到理解混亂"},{"content":" 📢 本文由 ChatGPT 翻譯 引言 最近在思考自己要繼續做什麼或學些什麼的時候，老是看到「DevOps」這個詞。一開始隨手查了一下，發現裡面提到的技術棧自己差不多都有碰過，還以為這只是像「全端」那樣多掌握幾個工具就好（雖然其實也差不多啦）\n但因為當時沒什麼興趣就耽擱了（其實是沒開發熱情了）\n直到最近躺了快四個月，覺得該掙扎一下，結果又想到這個詞。再深入了解後，只能說\u0026hellip;\u0026hellip;這根本是「捲」到極致了吧，前後端分離就算了，現在是連開發和運維分離都不分人了。\n不過話說回來，當我看到自動流程有 GitHub Action 的時候，就讓我想起以前用 Jekyll 建部落格時也能自動部署。但因為我那時候從其他部落格系統轉過來，習慣用子資料夾分類，而那套部署方式不支援子資料夾，所以我也沒深入研究。既然這次想好好整一整，就來看看現在的 Hugo 部落格能不能自動部署吧 畢竟每次都從容器下回來再上傳真的蠻麻煩的\n工作流程 建立一個 Workflow 的方式是，在 Git 倉庫根目錄的 .github/workflows/ 中建立一個 yaml 檔案，檔名隨意。我這次是部署用途，就命名為 deploy.yml\n整個檔案結構主要分為：名稱、觸發器與工作內容\n名稱 這個就隨意取名即可\n1 name: Build and Deploy Hugo Blog 觸發器 GitHub Action Workflow 支援多種觸發方式，我這裡設成每次 push 都觸發，畢竟通常都是更新文章然後進行構建\n另外加上手動觸發功能，以備有時候 GitHub 出錯需要手動啟動 Workflow\n1 2 3 4 5 on: push: # 當 Git Push 時觸發 branches: - main # 監聽主分支 workflow_dispatch: # 手動觸發 工作內容 我這邊只有一個工作（job），但其實 jobs 可設定多個並行執行。\n先命名這個工作\n1 2 jobs: build-deploy: 接著定義執行的作業環境，我這裡選用 ubuntu：\n1 2 3 jobs: build-deploy: runs-on: ubuntu-latest 接下來定義各步驟，第一步：檢出原始碼\n1 2 3 4 5 6 7 jobs: build-deploy: runs-on: ubuntu-latest steps: - name: Checkout source uses: actions/checkout@v4 安裝 Hugo：\n1 2 3 4 5 6 steps: - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#39;0.140.1\u0026#39; # 这里是我本地的版本，兼容性应该高点 extended: true # 因为我的主题使用了 SCSS 所以必须使用 extended 版本 執行建構指令：\n1 2 3 steps: - name: Build Hugo Site run: hugo --minify 將建構後的內容部署到另一個 GitHub Pages 倉庫：\n1 2 3 4 5 6 7 8 steps: - name: Deploy to BlogWeb repo uses: peaceiris/actions-gh-pages@v3 with: external_repository: yexca/Blog-Web-Hugo publish_branch: main # 推送到目标仓库 yexca/Blog-Web-Hugo 的 main 分支 publish_dir: ./public # 推送的当前仓库的文件夹，Hugo 默认是生成到这个文件夹 personal_token: ${{ secrets.PERSONAL_TOKEN }} 完整合併如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 name: Build and Deploy Hugo Blog on: push: branches: - main workflow_dispatch: jobs: build-deploy: runs-on: ubuntu-latest steps: - name: Checkout source uses: actions/checkout@v4 - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#39;0.140.1\u0026#39; extended: true - name: Build Hugo site run: hugo --minify - name: Deploy to blogWeb repo uses: peaceiris/actions-gh-pages@v3 with: external_repository: yexca/Blog-Web-Hugo publish_branch: main publish_dir: ./public personal_token: ${{ secrets.PERSONAL_TOKEN }} 設定 Token 由於存取其他倉庫需要權限，因此需先產生 Token。\n在 GitHub 的 Settings -\u0026gt; Developer Settings -\u0026gt; Personal access tokens -\u0026gt; Fine-grained tokens 中，產生一組擁有目標倉庫讀寫權限的 Token。\n然後回到原始碼倉庫（例如 yexca/Blog-Source-Hugo），進入 Settings -\u0026gt; Secrets and variables -\u0026gt; Actions -\u0026gt; Repository secrets，新增剛才建立的 Token，名稱需對應 PERSONAL_TOKEN。\n處理自訂網域 若你為 GitHub Pages 設定了自訂網域，需建立一個 CNAME 檔，內容為你的網域。\n但 GitHub Action 的部署會清空再覆蓋內容，因此 CNAME 也會被刪除，所以要在部署前手動加上，可採以下兩種方式：\n方法一：工作流中建立檔案 1 2 3 steps: - name: Add CNAME run: echo \u0026#39;blog.yexca.net\u0026#39; \u0026gt; public/CNAME 方法二：在 Hugo 的 static 資料夾放置 CNAME 因為 static 資料夾會被原樣複製到輸出目錄，也能達成目的。\n主題子模組處理 我原本的主題是以 Git Submodule 引入的，但因為我做了不少修改，若不處理這部分，推送上去的將會是原始 repo 的內容，而非我修改過的版本。\n備份主題 1 cp -r themes/Hugo-Theme-Stack tmp/Hugo-Theme-Stack-Backup 移除子模組 1 2 3 4 git submodule deinit -f themes/Hugo-Theme-Stack git rm -f themes/Hugo-Theme-Stack rm -rf .git/modules/themes/Hugo-Theme-Stack rm .gitmodules 恢復主題 1 2 cp -r tmp/Hugo-Theme-Stack-Backup themes/Hugo-Theme-Stack rm -rf tmp 修復 JS 語法錯誤 我以前為部落格添加了網站執行時間顯示，但當時用了舊的八進位語法：\n1 Date.UTC(2021, 10, 06, 14, 15, 19) 而 Hugo 的 --minify 壓縮指令會對其報錯，改成以下即可：\n1 Date.UTC(2021, 10, 6, 14, 15, 19) 結語 終於不再需要手動編譯了。自從我開始使用 Docker，就習慣將開發環境與本機系統隔離，這樣換電腦或搬服務器只需搬容器即可，也養成了環境潔癖。\n現在好了，連建構與部署也搬到雲端去了，以前是隔離到容器，現在是隔離到 GitHub，算是徹底根治了這毛病。\n不過再回頭看看 DevOps，我倒覺得這其實也是當代技術演進過快導致的產物。\n從早年的機器碼、組合語言，到高階語言，再到容器化部署，一次次技術的「門檻下降」實際上也在偷偷「拉高起跑線」。\n雖然讓程式開發越來越便利，但也使這行的入門門檻不知不覺變高，讓像我這樣的人加速被淘汰啦。\n不過話說回來，工作是工作，生活是生活。技術變快歸變快，世界的節奏、行業的變遷應該還沒快到讓人沒喘息的空間。還是會有留一口氣的餘地吧。\n","date":"2025-05-16T18:14:06+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/247/","title":"擁抱 DevOps：把我的部落格建構與部署丟給 GitHub 處理"},{"content":" 📢 本文由 ChatGPT 翻譯 引言 又一次的自我介紹時，我不由得又想到了我的部落格。\n過去我總是直接打開 Google 搜尋 yexca，點開第一個結果進入我的部落格。\n但自從更換網域後，無數次搜尋 yexca，我的網站卻始終消失在搜尋結果之外。\n起初我並沒有太在意，以為可能有某種懲罰機制吧。畢竟 Google 建議更換網域後最好做一年的 301 重導向，而我當時只做了半年，舊網域就到期了。\n但，已經兩年了吧，再怎麼說，也該恢復了吧？\n而且更離譜的是，搜尋前幾的反而是一些早已不再維護的網站，\n而我，每天更新、調整、折騰的這個部落格，卻彷彿被世界遺忘了一般。\n於是，我開始尋找原因 打開我的部落格，查看 \u0026lt;head\u0026gt; 區塊。\n嗯？\u0026lt;meta name='description'\u0026gt; 怎麼是網頁左邊那句標語？\n啊這，當時配置的時候只是說那句話會出現在那邊，我以為跟 Argon 主題設定一樣呢。那麼也就是說，這網站的描述根本毫無意義啊。\n不過，這句話幾乎陪伴了我整個部落格歷程，我不想輕易放棄它。\n既然如此，那就讓 JSON-LD 來承擔結構化描述的任務吧！\n於是我在主題自定義 \u0026lt;head\u0026gt; 區段加入了：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;script type=\u0026#34;application/ld+json\u0026#34;\u0026gt; { \u0026#34;@context\u0026#34;: \u0026#34;https://schema.org\u0026#34;, \u0026#34;@type\u0026#34;: \u0026#34;Blog\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;yexca\u0026#39;Blog\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;{{ .Site.BaseURL }}\u0026#34;, \u0026#34;inLanguage\u0026#34;: \u0026#34;{{ .Site.Language.Lang }}\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;{{ .Site.Params.description }}\u0026#34;, \u0026#34;author\u0026#34;: { \u0026#34;@type\u0026#34;: \u0026#34;Person\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;yexca\u0026#34; } } \u0026lt;/script\u0026gt; 嗯，同時考慮到是多語言網站，部分內容當然還是使用變數適配會比較好。\n在語言的迷宮中探索 說到多語言網站，那我換個語系搜尋會如何呢？\n於是我在 google.com.hk、google.com.tw、google.com.jp 搜尋 yexca。\n結果日文版可以搜尋到部落格，但中文版卻搜尋不到；英文內容不多，就算了。\n這就很奇怪了，說明 Google 是有把 https://blog.yexca.net 辨識為 yexca，\n那為什麼其他語言版本這麼慘捏？\n繼續排查下去，我發現可能是少了 hreflang 設定，於是我補上了：\n1 2 3 4 5 \u0026lt;link rel=\u0026#34;alternate\u0026#34; hreflang=\u0026#34;x-default\u0026#34; href=\u0026#34;https://blog.yexca.net/\u0026#34; /\u0026gt; \u0026lt;link rel=\u0026#34;alternate\u0026#34; hreflang=\u0026#34;zh-CN\u0026#34; href=\u0026#34;https://blog.yexca.net/\u0026#34; /\u0026gt; \u0026lt;link rel=\u0026#34;alternate\u0026#34; hreflang=\u0026#34;zh-TW\u0026#34; href=\u0026#34;https://blog.yexca.net/zh-tw/\u0026#34; /\u0026gt; \u0026lt;link rel=\u0026#34;alternate\u0026#34; hreflang=\u0026#34;ja\u0026#34; href=\u0026#34;https://blog.yexca.net/ja/\u0026#34; /\u0026gt; \u0026lt;link rel=\u0026#34;alternate\u0026#34; hreflang=\u0026#34;en\u0026#34; href=\u0026#34;https://blog.yexca.net/en/\u0026#34; /\u0026gt; 明確告訴搜尋引擎：不同語言的用戶可以拜訪不同語系版本，但這些都是同一網站。\n順帶一提，這段 \u0026lt;link\u0026gt; 同樣會出現在文章頁面，因為我沒有加條件判斷。雖然不是每篇文章都有多語版本，不過 Google 是可以自己理解的。\n一點點地補上遺漏 但我隨意點開一篇文章，哎呀，裡面還是 JSON-LD 的網站描述，多少有點奇怪。\n於是我加上了條件邏輯：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 {{ if .IsHome }} \u0026lt;!-- 首頁 JSON-LD --\u0026gt; \u0026lt;script type=\u0026#34;application/ld+json\u0026#34;\u0026gt; { \u0026#34;@context\u0026#34;: \u0026#34;https://schema.org\u0026#34;, \u0026#34;@type\u0026#34;: \u0026#34;Blog\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;yexca\u0026#39;Blog\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;{{ .Site.BaseURL }}\u0026#34;, \u0026#34;inLanguage\u0026#34;: \u0026#34;{{ .Site.Language.Lang }}\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;{{ .Site.Params.description }}\u0026#34;, \u0026#34;author\u0026#34;: { \u0026#34;@type\u0026#34;: \u0026#34;Person\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;yexca\u0026#34; } } \u0026lt;/script\u0026gt; {{ else if .IsPage }} \u0026lt;!-- 文章頁 JSON-LD --\u0026gt; \u0026lt;script type=\u0026#34;application/ld+json\u0026#34;\u0026gt; { \u0026#34;@context\u0026#34;: \u0026#34;https://schema.org\u0026#34;, \u0026#34;@type\u0026#34;: \u0026#34;BlogPosting\u0026#34;, \u0026#34;mainEntityOfPage\u0026#34;: { \u0026#34;@type\u0026#34;: \u0026#34;WebPage\u0026#34;, \u0026#34;@id\u0026#34;: \u0026#34;{{ .Permalink }}\u0026#34; }, \u0026#34;headline\u0026#34;: \u0026#34;{{ .Title }}\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;yexca\u0026#39;Blog\u0026#34;, \u0026#34;author\u0026#34;: { \u0026#34;@type\u0026#34;: \u0026#34;Person\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;yexca\u0026#34; }, \u0026#34;publisher\u0026#34;: { \u0026#34;@type\u0026#34;: \u0026#34;Person\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;yexca\u0026#39;Blog\u0026#34; }, \u0026#34;datePublished\u0026#34;: \u0026#34;{{ .Date.Format \u0026#34;2006-01-02\u0026#34; }}\u0026#34;, \u0026#34;dateModified\u0026#34;: \u0026#34;{{ .Lastmod.Format \u0026#34;2006-01-02\u0026#34; }}\u0026#34;, \u0026#34;inLanguage\u0026#34;: \u0026#34;{{ .Site.Language.Lang }}\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;{{ .Params.description | default .Site.Params.description }}\u0026#34; } \u0026lt;/script\u0026gt; {{ end }} 如此一來，首頁與文章就會產生不同的 JSON-LD，不僅語義更正確，也更符合 Google 結構化資料的建議。\n小小的期盼 現在，一切終於補齊了。\n雖然成效不會立刻出現，但我知道，那個訊號，已經送出去了。\n我希望，下次在介紹我的部落格時，\n可以直接打開 Google，搜尋 yexca。\n","date":"2025-04-27T17:38:16+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/246/","title":"為了能搜到自己的名字：一次小站 SEO 排查實踐"},{"content":" 此頁面有使用機器翻譯喲\n並不是所有刷卡的人都是羊毛黨，也不是所有設計系統的人都是工程師。有些人，刷卡像在設計，設計系統像在過生活\n1. 引子：什麼是卡粉？ 說到這，不得不提到之前看到的卡友七大愛好：\n這裡的「中國大陸」是指資金出入受限地區\n想辦法在中國大陸使用外匯 想辦法在境外使用人民幣 想辦法把人民幣匯出中國大陸 想辦法把外匯匯入中國大陸 辦一些在中國大陸幾乎沒用的卡 辦一些在國外更沒用的卡 想辦法讓那些連密碼位數都不到的資金，在一些幾乎沒什麼實際用途的卡片之間來回周轉 中國大陸的銀行密碼慣例為六位數，這裡是卡粉們自嘲「錢比密碼短，還在努力搬」的梗。其他地區可能不適用\n聽起來像是玩金融遊戲，乍看之下就是辦一堆銀行卡、追求回饋、省手續費、划算換匯……好像只是一種「不值錢的小聰明」\n但對真正的卡粉來說：\n卡粉，不是為了省幾塊錢，而是在尋找一個多通道、多節點、多限制下的資金最優路徑設計\n他們不是在薅羊毛，而是在探索這個世界的架構，在做生活系統的最佳化設計\n2. 系統架構設計到底在做什麼？ 為了考取系統架構師資格，往往需要學會很多相關術語，例如模組解耦、效能最佳化、介面規範等等。但拋開這些術語，其實系統架構師的本質任務非常明確：\n在複雜的限制條件下，合理分配資源、規劃路徑、連接各個系統，最終建構出一個既穩定又彈性的整體\n所以系統架構師考慮的不是某行程式碼寫得漂不漂亮，也不只是畫設計圖，而是整個系統能否在現實限制下順利運行。比方說：\n系統之間該如何分工？ 各個服務之間如何呼叫？ 介面要怎麼定義，才能方便未來擴充？ 出現問題時怎麼定位、怎麼隔離影響？ 在預算有限的情況下，怎麼權衡效能與成本？ 系統架構師的角色，有點像在搭積木、也像在修橋鋪路，更像在補丁系統。他們往往不是一開始就擁有完美藍圖，而是在一個混亂甚至破碎的現實中，一點一點規劃路線、加固結構、替換模組、最佳化通路\n簡單來說，就是要在現實條件下，設計出跑得穩、改得動、養得起的系統。不追求「完美設計」，只追求「跑得通」，這就是系統架構師的美學\n雖然我當初只是為了應考而接觸這些知識，但在備考過程中，卻不知不覺重新燃起了我對卡片路徑設計的熱情\n3. 卡粉世界的「架構問題」 卡粉不是無意義的「省點小錢」，系統架構師也不是在搞「高大上的工程設計」。雖然他們活動的場景完全不同，但本質上，他們都在面對同一種問題：\n在規則複雜、成本有限、目標不明的情況下，尋找最優的通路與結構\n卡粉不是單純在辦卡，而是在設計資金流動路徑；\n系統架構師也不是單純在寫程式，而是在規劃資訊流與控制流。\n卡粉常常在思考「怎麼少付手續費、不被風控、還能順利流轉」；\n而架構師則在考量「怎麼減少故障、提升擴展性、讓系統跑得穩」。\n雖然我只是為了考試而認識架構師的思維方式，但回頭一看，這不就是我在玩卡時思考的那些事情嗎？\n卡粉世界 系統架構世界 核心邏輯 手續費 延遲／效能開銷 成本管理 通道限制 API 調用限制 協議相容 卡組織規則 模組規範 合規性 境內外匯差 跨平台相容損耗 多環境適配 卡種多樣性 技術棧多樣性 多模組整合 銀行風控 系統安全策略 風險控制 多卡流轉路徑 資料流向控制 路由與架構設計 卡粉做的不是套利，而是在進行一場關於資金流動結構的設計遊戲\n他們不是在「做事」，而是在「做結構」：不只是找哪張卡回饋最高，而是設計一條路徑，讓資金在卡與卡之間以最小代價、最大效率地完成任務\n他們關注的不是「能不能跑」，而是「跑得是否優雅」；不是「能不能轉出去」，而是「這條流轉過程是否精巧、順暢」\n卡粉在找尋最優卡路徑，其實就像是在解一個「多重限制下的最短路徑問題」；而系統架構師在設計服務拓撲時，則是在權衡「模組耦合度＋SLA（服務等級協議）限制」下的最適組合\n這兩者之間，只是應用場景不同。\n4. 探索路徑的系統實踐 別人只在算哪張卡划算，我在設計一套金融流通系統\n每位卡粉的路徑都是獨一無二的，因為每個人面對的條件都不同：使用的銀行不同、帳戶幣別不同、生活地區不同、資金來源也不同\n真正的樂趣不在於抄別人的攻略，而是透過觀察、實驗、踩坑，找出最適合自己的資金架構\n我記得一開始只是想省點手續費，結果查了一堆資料，發現不同銀行之間轉帳的條件、時間、風控都不同。有些手續費低但轉帳速度慢，有些速度快但限額小，有些甚至完全無預警被退回。整個過程就像在玩一張起初全黑的地圖，一點一點探索通路、開通節點、註記跳板\n一次次的小額嘗試讓我慢慢拼湊出屬於我自己的可用資金路徑。隨著探索深入，我開始刻意繞開高手續費路徑，甚至在幣種兌換中也試圖利用波動換出一點浮盈\n有些一開始看起來「根本做不到」的事情，也在一次次嘗試與測試中漸漸被打通。像是透過虛擬貨幣交易所完成入金、在現實生活中直接使用虛擬貨幣、讓法幣自動轉換為穩定幣，或者使用專門的送金服務將資金匯往某些地區……這些方法繞過了傳統銀行體系，最終完成了原本被認為無法完成的目標\n這個過程，從「無解」到「打通」，就像是一場系統級網路架構的重建。我不是在單純轉帳，而是在重新定義一條資訊與價值的傳輸通路\n聽起來很複雜？但這不就是一個典型的系統流程設計題嗎：\n多個系統之間要如何建立連線、完成資料傳輸？ 不同格式（幣別）要怎麼轉換才能順利被識別？ 哪些節點是可靠的？哪些通路延遲低、失敗率小？ 如何將「資料包」（資金）透過合適的協定（出入金方式）送達最終節點（目標帳戶）？ 整個過程能不能讓用戶（也就是我）在體感上順暢無阻？ 說到底，這就是系統架構的感覺：你不是在堆疊功能，而是在設計一個清晰、穩定、可持續演進的結構網路\n每一張卡是一個節點；每一個匯款接口是一項協定；每一次路線的嘗試與調整，都是一次小規模的架構最佳化\n這背後說穿了就是：路徑規劃 + 接口適配 + 使用者體驗，這不就是系統架構師該做的事嗎？\n卡粉在玩的，從來不只是省錢，而是透過對現實金融網路的解構與重組，掌握系統級控制的樂趣與主導感\n5. 從卡粉中淬鍊出的架構素養 在一次次路徑選擇、失敗嘗試、成本權衡與風控試探中，卡粉其實也在鍛鍊一種架構思維。雖然沒有伺服器、沒有程式碼，但那種「為了結構穩定與效率美感而不斷打磨路徑」的過程，本質上就是一種系統設計能力的實踐\n這些實作經驗，不知不覺內化成了以下這幾類架構素養：\n能力 表現方式 核心精神 熟悉規則 銀行細則、限額通道 文件閱讀能力 整合能力 多卡串接與資金路徑整合 系統整合思維 成本意識 手續費最小化 效能／預算權衡 模型建構 規劃卡間流轉結構 架構建模能力 風控意識 多帳號、多備援設計 高可用性設計 審美追求 資金路徑也要優雅 工程美感 卡粉其實是在用現實世界，模擬訓練一個系統架構師該具備的思維模型\n6. 我的感悟 手續費是敵人，通道是信仰，路徑是藝術\n我之所以成為卡粉，不是因為熱衷刷卡，而是在一次次探索中感受到「結構之美」。也許我們沒有寫程式、沒有部署伺服器，但每一次資金的流動、每一條通路的設計，其實都蘊藏著系統性思考的影子\n從系統架構師的備考過程，到日常生活中設計自己的資金路徑，我漸漸意識到：\n我喜歡的不只是把事情做完，而是讓它的路徑設計得漂亮\n別人眼中的小聰明，是我心中的系統美學；\n別人眼中的羊毛黨，是我內心的生活架構師。\n卡粉不是單純為了省錢，更像是在現實中練習「系統設計」的能力：視覺化問題、逐步迭代、結構清晰、自我滿足\n這不是一種浪費時間，而是一種真實可觸、可日常實踐的「個人系統建構演練」\n卡粉不是在省錢，是在練手；架構不是在發明，是在選擇\n不論是在做架構設計還是在優化卡路徑，最重要的從來不是「能省多少」或「寫幾行程式」，而是那整個過程中，對系統、對結構，甚至對世界運行方式的理解與掌握\n而我，就是那個會在 ATM 前發呆 10 分鐘，只為算清哪條手續費路徑最優的生活架構師\n結語：生活就是最大的架構 我們每天刷卡、轉帳、判斷路徑、做出組合決策，其實就是在進行一場「無形的架構設計實踐」\n系統架構不只是伺服器與 API 的事，它也可能藏在我們的錢包、卡片選擇與支付策略之中\n卡粉的盡頭，也許就是一位生活中的系統架構師\n附錄：我的卡粉路徑偽代碼 這段程式碼並非真正的實作，而是我將現實中資金流轉路徑用架構思維重新建模的嘗試。它就像是一段可讀的生活流程圖，是我對每日卡片路徑操作背後邏輯的抽象化呈現\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // 我的主要跨境資金路徑設計（示意） func RouteCNYtoJPY(CNY float64) JPY float64 { HKD := BOCExchange(CNY, to=\u0026#34;HKD\u0026#34;) log.Printf(\u0026#34;Exchanged %.2f CNY to %.2f HKD\u0026#34;, CNY, HKD) Transfer(HKD, from=\u0026#34;BOC\u0026#34;, to=\u0026#34;BOCHK\u0026#34;, by=\u0026#34;pbservice\u0026#34;) log.Println(\u0026#34;Transferred via pbservice → BOCHK\u0026#34;) Transfer(HKD, from=\u0026#34;BOCHK\u0026#34;, to=\u0026#34;Wise\u0026#34;, by=\u0026#34;fpservice\u0026#34;) log.Println(\u0026#34;Transferred via fps → Wise\u0026#34;) JPY := WiseConvert(HKD, to=\u0026#34;JPY\u0026#34;) log.Printf(\u0026#34;Converted %.2f HKD to %.2f JPY via Wise\u0026#34;, HKD, JPY) Deposit(JPY, to=\u0026#34;Revolut\u0026#34;, with=\u0026#34;ApplePay\u0026#34;) return JPY } 這段偽代碼像是一座由邏輯堆疊出的通路結構，是我與系統架構師世界之間最自然而然的連接\n另註：本文僅為個人經驗與娛樂用途，並非任何財務或法律建議，請讀者自行判斷參考喔～\n","date":"2025-04-22T00:35:15+09:00","image":"https://github.com/yexca/picx-images-hosting/raw/master/2025/04-FromCardEnthusiastToArchitect/250422-TC.13lz2zi90i.webp","permalink":"https://blog.yexca.net/zh-tw/archives/245/","title":"從卡粉到架構師：生活中的系統設計哲學"},{"content":" 此頁面有使用機器翻譯喲\n2023 年 04 月，我開始記帳。2025 年 04 月，我停止了記帳。\n最後一筆記錄：¥0\n起點：為了省錢與掌控 起因很簡單——控制消費，提升金錢意識。剛開始的確非常有效，幫我遏制了一些不好的消費習慣。\n過程：一步步走向最優解與卡粉世界 但慢慢地，為了「更優」的消費，我開始比較、開始尋找最優解。最開始只是商品之間的比較，後來，是付款方式、支付工具，最後，進入了銀行優惠和開卡的世界。\n為了優惠而去開卡，為了便利而去開卡，但這玩意有點上頭，可以說我一步一步走向了卡粉的世界。\n一開始是為了省錢，後來是為了方便，最後——是為了集卡。\n反噬：記帳成為了負擔 於是，記帳本身，逐漸成了負擔。帳戶越來越多，場景越來越複雜，記帳的時間成本、心理成本，早已超過了實際收益。\n我常常為了可能只有幾塊錢的優惠，研究半天。剛開始當然開心，但多了之後，找到最優解不再讓我興奮，反而是一陣空虛取代了最初的喜悅。\n轉變：從最優解到舒服就好 也許是我變了，消費的心態也變了。\n從「按需按惠」，到「差不多就行，自己舒服就行」。\n我也發現，自己早就突破了原先設定的限額，卻沒有因此失控。反而越來越明白，比起省錢，時間和心情更重要。\n反思：我到底為什麼記帳？ 當我因為記帳，而開始：\n因為帳戶多而不斷翻找 因為貨幣轉換而頻繁在記帳軟體創建新帳號 因為商品該不該買而計較半天 因為和朋友出去遊玩消費而破壞心情 我不得不開始反思——我記帳，到底是為了什麼？\n這其中的收益，真的值得嗎？\n決定：放下，歸零，重新出發 於是我嘗試著放下，嘗試著不去管細節，只問自己：「我快樂嗎？」\n結果是——真的很快樂。而支出，也沒有想像中那麼高。\n或許，是習慣讓我潛移默化地比過價。或許，情緒的價值，本來就無法用優惠來衡量。\n所以，我想，是時候放手了。\n記帳，已經完成了它的使命。\n它不再是工具，而是成為了束縛。\n行為習慣是為了更好的生活，當它無法再靠熱情消解，當它反而阻礙了生活，那就該學會告別。\n尾聲：謝謝自己，繼續生活 雖然放棄了自己堅持了兩年的習慣，確實有些不捨。\n但這大概也是人生的一部分吧。沒有什麼可以陪伴一輩子，但只要在一起的那段時光是美好的，這，就足夠了。\n可以說我少了一個象徵性的「我很省」的工具。\n但，我更希望未來的自己，不再是靠數字和記錄來獲得安全感，而是靠真正的從容和自在。\n從可以掌控，到流入未知。\n希望自己能早點適應。\n希望能把省下來的時間，花在更有意義、更值得快樂的事情上。\n所以，\n最後一筆，¥0 附上一段小短文。\n謝謝這兩年認真記錄的自己。\n未來，希望把省下來的時間，花在更有意義、更快樂的事情上。\n就這樣，Archive 了這段經歷。\n記錄是結束，而生活才剛剛開始。\n","date":"2025-04-14T16:23:48+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/244/","title":"從省錢，到生活，再到告別"},{"content":" 此頁面有使用機器翻譯喲\n音之所感系列\n歌曲名稱 翻譯 連結 僕が死のうと思ったのは 曾經我也想過一了百了 https://blog.yexca.net/zh-tw/archives/214 あくあ色ぱれっと aqua 的調色板 https://blog.yexca.net/zh-tw/archives/219 恋の押し売り 戀愛推銷 https://blog.yexca.net/zh-tw/archives/220 17さいのうた 17 歲的歌曲 本文 引言 其實我一開始只是聽懂了有關「寫給自己的信」那部分，覺得跟我第一次聽到時的心情相當契合，所以就一直聽下去了。\n後來嘗試去翻譯這首歌，再加上最近的種種經歷，我感覺自己現在的狀態，好像跟ユイカ當時的情況很像。現在的我，就跟這首歌一樣，只有迷惘：究竟要成為什麼樣的人？未來會是什麼模樣？我又該往哪裡前進呢？\n正面一點，就像歌詞裡所說的，試著接受自己吧。離開那份迷惘，隨便找一件自己感覺喜歡的事情去做吧。\n最後，也想感謝一直鼓勵著我的人，以及那些雖然嘴上沒說鼓勵，但卻在行動上支持我的人。\n歌曲影片 歌詞 こんな私の未熟なうたを　聴いてくれてどうも有難うね 未熟: みじゅく\n感謝你來聽我還很青澀的歌\nもう少しで私は未熟な大人に　なるみたいです\n再過不久，我好像也要變成不成熟的大人了\nなんか笑っちゃうね\n總覺得有點好笑呢\n本当はね\n其實啊\nもっと前を向けるようなうたを　書くつもりだったけど\n本打算寫更加讓人積極的歌\n書けなくて\n卻怎麼也寫不出來\n私はまだ　他の誰かを支えられるほど\n我還沒有達到可以支撐別人的存在\n強くなかったみたい　ごめんね\n看起來並不怎麼要強，真是抱歉吶\n拝啓　未来の私へ　今そこで\n敬啟，未來的我啊，現在在那裡\nどんなことをして　生きていますか\n正做著什麼樣的事情，過著什麼樣的生活呢\n拝啓　今の私へ　今ここで\n敬啟，現在的我啊，現在在此刻\nどんなことをしたら　生きていけるんでしょうか\n我該做些什麼，才可以繼續活下去呢\n\u0026ldquo;好きだからかっこいい\u0026quot;とか　\u0026ldquo;そばにいる\u0026quot;とか\n曾經寫過「因為喜歡才覺得帥」、「想要待在身邊」\n\u0026ldquo;勝手に盗んだ\u0026quot;とか　書いてた\n還有「隨便就偷走你的心」之類的\nどうせだったらもうちょっと　貴方みたいに\n這樣的話，不如再向你\nやさしいうたを書けばよかったね\n寫首溫暖的歌就好了呢\n本当はね　好きなことだけして生きたいの\n其實啊，我只想做喜歡的事情吶\nでもそれは上手な生き方とは言えないから\n但那稱不上成熟的活法\n無駄になっても　意味がなくても\n即使顯得徒勞，毫無意義\n今はここから　離れなきゃいけないの　ごめんね\n現在還是不得不離開了，抱歉吶\n拝啓　未来の私へ　今そこで\n敬啟，未來的我啊，現在在那裡\nどんな大人になって　生きていますか\n變成了什麼樣的大人，過著什麼樣的生活呢\n拝啓　今の私へ　今ここで\n敬啟，現在的我啊，此刻在這裡\nどんな大人になりたいと　言えばいいんでしょうか\n說出「想要成為什麼樣的大人」可以嗎\n「さよなら」は悲しくなるからさ\n「再見」聽起來太悲傷了\n「またね」って言わせて\n請讓我說「下次見」吧\nいつか私が　今みたいな　うたを書けなくなっても\n就算未來哪天我寫不出來這樣的歌了\n怒らないでね\n也請不要怪我\n拝啓　過去の私へ　今の私は\n敬啟，過去的我啊，現在的我\nずっと夢見ていたこと叶えてるよ\n實現了一直以來的夢想喲\n拝啓　今の私へ\n敬啟，現在的我啊\nこんな情けない　うただって歌えばいいよ 情け: なさけ\n唱出這麼軟弱的歌也可以喲\nそれが私だから\n因為那就是我\n拝啓　未来の私へ　今そこは\n敬啟，未來的我啊，現在在那裡\nどんな綺麗な世界が　広がっていますか\n展開著怎樣絢麗多彩的世界呢\n拝啓　今の私へ　今ここが\n敬啟，現在的我啊，現在的時刻\nどんな世界よりも　幸せでした\n比任何世界都要幸福呀\nこんな私の未熟なうたを　聴いてくれてどうも有難うね\n感謝你來聽我還很青澀的歌\nこれから私は未熟な大人に　なる準備をします\n接下來我也要為成為不夠成熟的大人，而好好準備\n「じゃあ またね」\n「那麼，下次見」\n","date":"2025-01-25T16:57:49+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/224/","title":"音之所感 - 《17さいのうた》"},{"content":" 此頁面有使用機器翻譯喲\n音之所感系列\n歌曲名稱 翻譯 連結 僕が死のうと思ったのは 曾經我也想過一了百了 https://blog.yexca.net/zh-tw/archives/214 あくあ色ぱれっと aqua 的調色板 https://blog.yexca.net/zh-tw/archives/219 恋の押し売り 戀愛推銷 本文 17さいのうた 17 歲的歌曲 https://blog.yexca.net/zh-tw/archives/224 引言 其實早就翻譯了捏~(￣▽￣)~*\n歌曲影片 歌詞 ハートマーク作って\n畫個愛心的記號\n届け届け届け\n快一點、傳達到、你心裡\nきっと恋の押し売り\n這大概是戀愛的推銷\n好きで好きでごめん\n好喜歡，太喜歡，抱歉呀\n出会っちゃった！\n和你相遇了！\nときめいちゃった？ ときめく\n心跳加速了嗎？\n私だけ？ドキドキしてるの\n還是只有我？在砰砰心跳呢\nちゃんと気にかけて\n多多在意我啦\n私だけ！甘やかして\n只對我！好好寵愛吧\n(Ah)　君と話す理由欲しくて探している\n（啊）不斷尋找和你聊天的理由\n(なんで？)　強がっていても恋に負けちゃうんだね\n（為什麼？）就算裝作堅強，還是敗給了戀愛呀\nハートマーク作って\n畫個愛心的記號\n届け届け届け\n快一點、傳達到、你心裡\nきっと恋の押し売り\n這大概是戀愛的推銷\n好きで好きでごめん\n好喜歡，太喜歡，抱歉呀\nハートのレスください\n請回覆我的心意\n早く早く早くー！\n快一點、再快點、馬上做~！\nこれは恋の押し売り\n這可是戀愛的強制推銷\n返品なんてダメよ\n退貨？不可以！\n取られたくないんだよ…\n不想被搶走啊\u0026hellip;\n誰よりも可愛くなりたい\n想要變得比誰都可愛\n完全勝利して\n想完全勝利\n私だけって言わせてやる！\n讓你說出「只有我」！\n(Ah)　君の胸を狙う私の恋の銃口\n（啊）我的戀愛槍，瞄準著你的胸口\n(なんで？)　震えちゃうんだろう\n（為什麼？）會不由自主地顫抖呢\nいつか撃ち抜けるまで 撃ち抜く: うちぬく\n直到貫穿為止\nせーっの！BANG\n一、二、砰！\n期待させてよ\n讓我更加期待吧\nもっともっともっと\n多點、再多、更多\n私浮ついちゃって 浮つく: うわつく\n我有點飄飄然了\nバカだバカだごめん\n傻乎乎，真的是，抱歉呀\nハートは忙しくて\n心裡稍微有點忙\nあっちこっちどっちー？\n那裡？這裡？哪裡？\n今はまだまだプロローグ\n現在還只是序幕呢\n押して押して押すの\n按下去、快一點、去推進\n私、君に出会えて変わったの！\n我，和你遇見之後改變了！\nそりゃあ悩んじゃう事もあるけど…\n雖然也有會煩惱的時候。。。\nもっともっと可愛くなりたいって思うし\n但想要變得更加更加可愛\n何より君に好きって言ってもらいたい！\n沒有什麼比得上你對我說喜歡！\n笑顔の私(可愛い)\n笑著的我（可愛捏）\n泣いちゃう私(可愛い)\n哭著的我（可愛捏）\n怒った私(可愛い)\n生氣的我（可愛捏）\n恋する私…\n戀愛中的我。。。\n甘えさせてよ\n讓我撒嬌嘛\nずっとずっとずっと\n始終、一直、永遠\nきっと後悔させない\n一定不會讓你後悔的\nお願い　好きになって\n拜託了，喜歡我吧\nハートマーク作って\n畫一個愛心記號\n届け届け届け\n快一點、傳達到、你心裡\nきっと恋の押し売り\n大概是戀愛的小強推\n好きで好きでごめん\n喜歡你，超喜歡，抱歉呀\nハートのレスください\n請回覆我的心意\n早く早く早くー！\n快一點、再快點、馬上要！\nこれは恋の押し売り\n這可是戀愛的強制推銷\n返品なんてダメよ\n不可以、退貨哦\n","date":"2025-01-20T16:24:43+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/220/","title":"音之所感 - 《恋の押し売り》"},{"content":" 此頁面有使用機器翻譯喲\n音之所感系列\n歌曲名稱 翻譯 連結 僕が死のうと思ったのは 曾經我也想過一了百了 https://blog.yexca.net/zh-tw/archives/214 あくあ色ぱれっと aqua 的調色板 本文 恋の押し売り 戀愛推銷 https://blog.yexca.net/zh-tw/archives/220 17さいのうた 17 歲的歌曲 https://blog.yexca.net/zh-tw/archives/224 引言 第二首本來想選我的 2024 年度歌曲，不過不經意間聽到了 Aqua 的歌，便想到了這首，之前聽的時候只是中間的有一段和我的人生經歷有點類似，所以一直在聽，全曲認真翻譯後才知道染上 Aqua 顏色的梗從這裡來的啊（在 C105 聽到「想染上 aqua 的顏色的話」，還以為是來自《君色に染まる》）\n雖然經歷類似讓我開始慢慢聽上 Aqua 且慢慢喜歡上，但事實上我的「キミがいるから私　いつでも頑張れるんだ」是 Warma 捏，寫到這突然就意識到了一直在影響著我的到底是什麼了，以及如今是為何這樣，不過正如因這首歌的改變，當前的困惑也一定有契機可以化解\n我很克制得沒寫下去，畢竟是一首歡樂的歌，可以說對於偶像路線簡直是太絕了這首歌，同時用詞倒也不是太難（相對於外國人），是我都可以聽懂的程度（doge）\n因為我是去年（2024）接觸到 Aqua 的嘛，因為經常聽到這首歌（3D 直播），還以為是經歷了一些沉澱，然後出了這麼厲害的歌（因為一直在收聽榜第一），沒想到是出道即巔峰啊（《For the Win》是 bilibili 企劃的，暫且不記上），同時之後的歌曲，怎麼說呢，偶像類的都很好，可以說是直接讓我開始喜歡一些偶像風了，以此為契機，倒是喜歡上了偶像演唱會（雖然隨著 Aqua 的畢業也不怎麼感興趣了）\n同時，對比其他翻譯可能有出入，我的翻譯多數是有自己的感情吧，所以部分並不是歌詞本身的意思（事實上 上一首 也是），這個在可能下一个 2024 年度歌曲的翻譯中表現更明顯。我覺得如果只是照抄一個標準的翻譯多少沒啥意義，因為是真正熱愛的事物，多少想留存自己的特色 (染上我的色彩)\n最後捏，我也想染上 Aqua 的色彩捏，畢竟是我最愛的三個人之一 （C105 沒買到立牌真可惜了，結城的也沒買到（悲\n歌曲影片 歌詞 何をしても不器用で　何かとミスしてばっか\n什麼也做不到，做什麼都出錯\nダメダメな私だって\n一無是處的我\nできる事があるの\n也有可以做到的事喔\n凹んで悲しくたって　笑顔にしてあげるんだ 凹む: へこむ\n就算陷入低落，我也會讓你笑起來喔\nここにいるから　早く　私を見つけてね\n因為就在這裡，快一點，找到我吧\nLove You Love You, I love you\n愛你愛你，我愛你\nLove You Love You, Ah,I love you so much\n愛你愛你，我非常愛你\nLove You Love You, I love you\n愛你愛你，我愛你\nLove You Love You\n愛你愛你\n（あぁ　愛してもっと）\n(啊~，更加愛我吧)\nいつでも隣にいるし、いつでも一緒に笑える\n一直都陪在身邊，一直都一起歡笑\n私をたくさん知って　たくさん好きって言って\n多多了解我，多多對我說“喜歡”\nワガママで朝も苦手　ドジだし　ダメダメだけど\n任性也賴床，笨手笨腳還一無是處\nそれでも私の事を　見ててね\n就算那樣也請專注於我\n描く夢の未来へ続く\n向著描繪未來的路\n道をキミと歩けますように\n希望能和你一起走下去\nねぇもっと！好きになってもらいたいの！\n呐，想讓你多多喜歡我！\n頭の中は君ばっか！\n我的腦海裡只有你\nってゆーかそっぽなんて向いてないで！\n話說，別把頭轉開呀！\nあぁもう！ヤキモキしちゃうわ　Ah\n啊啊，真是的！急死人了\nずっとずっと好きがいいの\n一直一直喜歡下去吧\n心の奥もトキメイちゃうくらい\n內心深處都怦然心動的程度\nこっち向いててよね　ダーリン？\n看看我嘛，親愛的？\nあぁもう離さないから、絶対に！\n啊~，再也不會放開你，絕對不會！\nLove You Love You, I love you\n愛你愛你，我愛你\nLove You Love You\n愛你愛你\n（あぁ　愛してもっと）\n(啊~，多多愛我吧)\nキミがいるから私　いつでも頑張れるんだ\n因為有你在身邊，我才能努力下去\n落ち込んで悲しくたって　キミがいるから\u0026hellip;\n就算低落悲傷，因為有你在身邊。。。\nキミがいるから　歩いてこれた\n正因為有你在，我才能走到今天\nキミがいなくちゃ　前も見れない\n如果沒有你，我連前方也看不清\n嫌な事とか辛い事とかあったって\n即使有討厭的，痛苦的事\nキミの力でここまで笑ってこれたんだ\n有你的力量就可以笑著走到現在\n今度はもっと私がぐっとひっぱって　連れて行くんだ\n這次我會更加努力拉著你，一起走下去\nキミがいるから私がいるの\n因為有你在，我才能到這\nこんな私を　愛してくれる？\n你願意愛上這樣的我嗎？\nねぇもっと　ねぇもっと\n呐，多一點，再多點\nまだもっと　受け止めてよね！ねぇいい？\n更多地接受我吧！可以嗎？\nさぁ声を上げて！\n那麼，大聲地說出來吧！\nねぇもっと　ねぇもっと\n呐，多一點，再多點\n好きになってもらいたいの\n想讓你喜歡上我\nいつでも　そう私ばっか みたいにそっぽなんて向かせないわ\n無論何時，我都不允許你把目光移開，只讓我在你心裡\nね、ほら夢中にしちゃうわ　Ah\n呐，看到了吧，已經沉迷了呢~\nずっとずっと好きがいいの！心も体も染まっちゃうくらいに\n一直一直喜歡下去吧，直到你的身心都染上我的色彩\nこっち向いててよねダーリン?\n看向這邊呀，親愛的？\nあぁもう離さないから、絶対に　絶体ね　絶体よ　約束だよ\n啊~，我不會放開你，一定不會、肯定不會、絕對不會，約好了喔\n（あぁ 愛してもっと）\n(啊~，更多地愛我吧)\n","date":"2025-01-20T00:16:48+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/219/","title":"音之所感 - 《あくあ色ぱれっと》"},{"content":" 此頁面有使用機器翻譯喲\n音之所感系列\n歌曲名稱 翻譯 連結 僕が死のうと思ったのは 曾經我也想過一了百了 本文 あくあ色ぱれっと aqua 的調色板 https://blog.yexca.net/zh-tw/archives/219 恋の押し売り 戀愛推銷 https://blog.yexca.net/zh-tw/archives/220 17さいのうた 17 歲的歌曲 https://blog.yexca.net/zh-tw/archives/224 引言 有沒有一種聽力材料，可以讓人不是處於學習的狀態，可以反覆聽，並可以嘗試影子跟讀的呢？這不就是歌曲嗎！\n考慮到我聽歌時只是部分能聽懂，如果深入分析了解歌詞的話，說不定真的可以當成對語言的練習了\n第一首就從一首雖然有點沉重，但可以說陪伴了我大部分時間，我可以百聽不厭的歌曲開始吧\n歌曲影片 歌詞 僕ぼくが死しのうと思おもったのは　ウミネコが桟さん橋ばしで鳴ないたから\n我之所以想過一了百了，是因為黑尾鷗在碼頭啼鳴\n波なみの随意ずいいに浮うかんで消きえる　過去かこも啄ついばんで飛とんでいけ\n隨波浮沉又消逝，連過去也一併啄起飛向遠方\n僕ぼくが死しのうと思おもったのは　誕生日たんじょうびに杏あんずの花はなが咲さいたから\n我之所以想過一了百了，是因為生日時杏花開了\nその木こ漏もれ日びでうたた寝ねしたら　虫むしの死し骸がいと土つちになれるかな\n在那灑落的日影下小憩，是否能化作蟲的遺骸與黃土呢\n薄荷はっか飴あめ　漁港ぎょこうの灯台とうだい　錆さびたアーチ橋ばし　捨すてた自転車じてんしゃ\n薄荷糖、漁港的燈塔、生鏽的拱橋、被拋棄的自行車\n木造もくぞうの駅えきのストーブの前まえで　どこにも旅たび立だてない心こころ\n木造車站爐火前，踏不出旅途的心\n今日きょうはまるで昨日きのうみたいだ　明日あすを変かえるなら今日きょうを変かえなきゃ\n今天就好像昨天一樣，想改變明天的話要從今天開始\n分かってる　分かってる　けれど\n我知道啊，我明白啊，可是。。。\n僕ぼくが死しのうと思おもったのは　心こころが空からっぽになったから\n我之所以想過一了百了，是因為內心已經空寂了\n満みたされないと泣ないているのは　きっと満みたされたいと願ねがうから\n因空虛而哭泣，無非是渴望被填滿\n僕ぼくが死しのうと思おもったのは　靴紐くつひもが解ほどけたから\n我之所以想過一了百了，是因為鞋帶鬆開了\n結むすびなおすのは苦手にがてなんだよ　人ひととの繋つながりもまた然しかり\n重新繫上很麻煩，人際關係也同樣如此\n僕ぼくが死しのうと思おもったのは　少年しょうねんが僕ぼくを見みつめていたから\n我之所以想過一了百了，是因為少年注視著我\nベッドの上うえで土下座どげざしてるよ　あの日ひの僕ぼくにごめんなさいと\n在床上向我土下座，對那天的自己說抱歉\nパソコンの薄うす明あかり　上階じょうかいの部屋へやの生活音せいかつおん\n電腦螢幕的微光，上層房間的生活聲\nインターフォンのチャイムの音おと　耳みみを塞ふせぐ鳥とりかごの少年しょうねん\n門鈴的聲音，捂住耳朵的籠中少年\n見みえない敵てきと戦たたかってる　六畳ろくじょう一間ひとまのドンキホーテ\n在六坪房間的堂吉訶德，與無形之敵在戰鬥著\nゴールはどうせ醜みにくいものさ\n終點反正是醜陋的\n僕ぼくが死しのうと思おもったのは　冷つめたい人ひとと言いわれたから\n我之所以想過一了百了，是因為被人說成冷漠無情\n愛あいされたいと泣ないているのは　人ひとの温ぬくもりを知しってしまったから\n因渴望被愛而哭泣著，是因為已經嘗過人間冷暖\n僕ぼくが死しのうと思おもったのは　あなたが奇麗きれいに笑わらうから\n我之所以想過一了百了，是因為你的笑容如此溫暖\n死しぬことばかり考かんがえてしまうのは　きっと生いきる事ことに真面目まじめすぎるから\n總想着死亡，一定是活得太認真了吧\n僕ぼくが死しのうと思おもったのは　まだあなたに出会であってなかったから\n我之所以想過一了百了，是因為未曾遇見你\nあなたのような人ひとが生うまれた　世界せかいを少すこし好すきになったよ\n正因為有你這樣的人會誕生，才會有點喜歡這個世界\nあなたのような人ひとが生いきてる　世界せかいに少すこし期待きたいするよ\n正因為有你這樣的人存在著，才會對世界有些許期待\n","date":"2025-01-11T01:10:51+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/214/","title":"音之所感 - 《僕が死のうと思ったのは》"},{"content":" 此頁面有使用機器翻譯喲\n引言 今天想對最近設計的半透明、毛玻璃和圓角進行總結，突然想到 2023-12-01 好像做過一個什麼東西，就順便重整一下好了\n頁面背景 現代的 (二次元) 網頁要有一個背景\n1 2 3 4 5 6 7 8 body{ background-image: url(\u0026#39;../img/77194247_p0.jpg\u0026#39;); background-size: cover; background-attachment: fixed; /* 固定 */ background-repeat: no-repeat; /* 不重複 */ padding: 0; margin: 0; } 半透明與毛玻璃 然後在背景上加一個蒙版，實現半透明與毛玻璃效果\n1 2 3 4 5 6 7 8 9 10 11 .layout { /* display: flex; */ margin: 0; padding: 0; display: flex; width: 100vw; height: 100vh; backdrop-filter: blur(2px); /* 背景模糊效果 */ -webkit-backdrop-filter: blur(2px); /* Safari 支援 */ background: rgba(0, 0, 0, 0.4); /* 半透明黑色背景 */ } 網頁的重構 說起來寫文章還是很傷腦筋，做的時候寫會被打斷，做完再寫又會很累不想動，所以我就折衷一下，隨便寫寫就好\n專案地址: https://github.com/yexca/MusicPlayer-Twinkle 順便更新了之前的文章 (簡體中文) https://blog.yexca.net/archives/116/ 用這個方法加了一個範例: https://twinkle.yexca.net 卡片效果 這也屬於現代的設計\n1 2 3 4 5 6 7 8 9 10 .card { width: 300px; padding: 20px; background-color: rgba(255, 255, 255, 0.5); /* 半透明白色背景 */ border-radius: 15px; /* 圓角 */ box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); /* 陰影 */ backdrop-filter: blur(10px); /* 背景模糊效果 */ border: 1px solid rgba(255, 255, 255, 0.3); /* 邊框 */ color: pink; /* 前景文字顏色 */ } 嗯，之後有時間再以卡片為設計來完善這個專案 (又開新坑了)\nTwinkle 另外，專案的內容是 Twinkle 的音樂，具體介紹請參閱\nhttps://twinkle130527.wixsite.com/twinkle https://www.dojin-music.info/circle/1255 SoundCloud\nhttps://soundcloud.com/twintwinkles ","date":"2025-01-05T16:19:36+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/212/","title":"毛玻璃效果"},{"content":" 該文章使用 Google 翻譯處理。\nRedis 是一個基於記憶體的鍵值結構資料庫，是互聯網技術領域使用廣泛的儲存中間件\n官網： https://redis.io 簡體中文網： https://www.redis.net.cn/ Redis 基於記憶體存儲，讀寫效能高，適合儲存熱點資料 (商品、資訊、新聞) 。是用 C 語言開發的一個開源的高效能鍵值對資料庫，儲存 value 類型比較豐富，也被稱為結構化的 NoSql (Not Only SQL) 資料庫\nNoSql 泛指非關係型資料庫，不是要取代關係型資料庫，而是關係型資料庫的補充\n關係型資料庫 (RDBMS)：\nMySQL Oracle DB2 SQLServer 非關係型資料庫 (NoSQL)：\nRedis Mongo DB MemCached Redis 下載安裝與執行 下載地址：\nWindows: https://github.com/microsoftarchive/redis/releases Linux: https://download.redis.io/releases/ cn: http://www.redis.cn/download.html Windows 版直接解壓縮即可使用，Linux 版：\n解壓縮 tar -zxvf redis-4.0.0.tar.gz -C /usr/local 安裝依賴環境 yum install gcc-c++ 進入安裝目錄，編譯 make 進入 redis 的 src 目錄安裝 make install 相關文件說明：\n/usr/local/redis-4.0.0/src/redis-server：Redis 服務啟動腳本 /usr/local/redis-4.0.0/src/redis-cli：Redis 客戶端腳本 /usr/local/redis-4.0.0/redis.conf：Redis 設定檔 服務端啟動，以 Windows 版為例，啟動命令：\n1 redis-server.exe redis.windows.conf 默認端口號為 6379，默認無密碼，啟動完成後可以用客戶端連接\n命令行連接 通過 redis-cli.exe 進行連接\n1 redis-cli.exe -h ip -p port -a password 如果省略，則使用 127.0.0.1:6379\n可以通過修改配置文件 (redis.windows.conf) 設置密碼\n1 requirepass 123456 修改完成後重啟生效\n圖形化連接 Github： https://github.com/qishibo/AnotherRedisDesktopManager 下載安裝後新建連接，輸入相關信息後連接即可\nDocker 部署 拉取鏡像\n1 docker pull redis 獲取配置文件，下載對應版本，抽取配置文件即可，Linux 為 redis.conf\n創建 Redis 數據映射文件夾，例如\n1 2 mkdir /home/redis mkdir /home/redis/data 修改配置文件，傳送至部署機子，例如使用 scp 從 Win 傳至 Linux\n1 scp pathOfFile root@IP:/PathOfFile 啟動\n1 docker run -p 6379:6379 --name redis -v /home/redis/redis.conf:/etc/redis/redis.conf -v /home/redis/data:/data -d redis redis-server /etc/redis/redis.conf 參考資料： https://cloud.tencent.com/developer/article/1670205 Redis 數據類型 Redis 的 key 是字符串類型，value 有 5 種常用的數據類型\n字串 (string)：普通字串 哈希 (hash)：也叫散列 清單 (list)：依插入順序排序，可以有重複元素 集合 (set)：無序集合，不允許重複元素 有序集合 (sorted set/zset)：集合中每個元素關聯一個分數 (score)，根據分數升序排序 Redis 常用命令 Redis 大小寫不敏感\n字符串操作常用命令：\n1 2 3 4 5 6 7 8 # 設置指定 key 值 SET key value # 獲取指定 key 值 GET key # 設置指定 key 值，並將 key 的過期時間設為 seconds 秒 SETEX key seconds value # 只在 key 不存在時才設置 key 的值 SETNX key value hash 是一個 string 類型的 field 和 value 映射表，特別適合存儲對象，常用命令：\n1 2 3 4 5 6 7 8 9 10 # 將哈希表 key 中的 field 值設為 value HSET key field value # 取得儲存在哈希表中指定欄位的值 HGET key field # 刪除儲存在哈希表中的指定字段 HDEL key field # 獲取哈希表中所有字段 HKEYS key # 獲取哈希表中所有值 HVALS key 列表是簡單的字符串列表，按照插入順序排列，常用命令：\n1 2 3 4 5 6 7 8 9 10 11 # 將一個或多個值插入到清單頭部 LPUSH key value1 [value2] # 取得清單指定範圍內的元素 LRANGE key start stop # 移除並取得清單最後一個元素 RPOP key # 取得清單長度 LLEN key # 移出並取得清單的最後一個元素 # 如果清單沒有元素會阻塞清單直到等待逾時或發現可彈出元素為止 BRPOP key1 [key2] timeout 類似隊列，先進先出\n集合是字串型別的無序集合，集合成員唯一，常用指令：\n1 2 3 4 5 6 7 8 9 10 11 12 # 在集合中新增一個或多個成員 SADD key member1 [member2] # 傳回集合中的所有成員 SMEMBERS key # 取得集合的成員數 SCARD key # 傳回給定所有集合的交集 SINTER key2 [key2] # 傳回所有給定集合的並集 SUNION key1 [key2] # 移除集合中一個或多個成員 SREM key member1 [member2] 有序集合是字符串類型元素的集合，每個成員關聯一個 double 類型的分數，常用命令：\n1 2 3 4 5 6 7 8 # 在有序集合中新增一個或多個成員 ZADD key score1 member1 [score2 member2] # 透過索引區間傳回有序集合中指定區間內的成員 ZRANGE key start stop [WITHSCORES] # 有序集合中對指定成員的分數加上增量increment ZINCRBY key increment member # 移除有序集合中的一個或多個成員 ZREM key member1 [member2] 除了各數據類型專有，還有通用命令，即所有類型都可以使用的命令：\n1 2 3 4 5 6 7 8 # 尋找所有符合給定模式(pattern)的key KEYS pattern # pattern可以為* # 檢查指定key是否存在 EXISTS key # 傳回key所儲存的值的類型 TYPE key # 在key存在時刪除key DEL key 在 Java 中操作 Redis 如同使用 JDBC 操作 MySQL 資料庫一樣，需要使用 Redis 的 Java 用戶端進行操作 Redis\nRedis 的 Java 客戶端很多，常用的幾種：\nJedis Lettuce Spring Data Redis Jedis 封裝最好，與Redis 命令相同，是官方推薦；Lettuce 對線程呼叫更好，性能更好；Spring 對Redis 客戶端進行了整合，提供了Spring Data Redis，在Spring Boot 專案中還提供了對應的Starter，即spring-boot-starter-data-redis\nspring data Redis Spring Data Redis 是 Spring 的一部分，提供了在 Spring 應用中透過簡單的配置就可以存取 Redis 服務，對 Redis 底層開發包進行了高度封裝。在 Spring 專案中，可以使用Spring Data Redis來簡化 Redis 操作。網址： https://spring.io/projects/spring-data-redis Maven 座標：\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-data-redis\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; Spring Data Redis 中提供了一個高度封裝類 RedisTemplate 對相關 api 進行了歸類封裝，將同一類型的操作封裝為 operation 接口：\nValueOperations：string 資料操作 SetOperations：set 類型資料操作 ZSetOperations：zset 類型資料操作 HashOperations：hash 類型的資料操作 ListOperations：list 類型的資料操作 配置 Redis 資料來源，設定文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # application spring: profiles: active: dev redis: host: ${sky.redis.host} port: ${sky.redis.port} password: ${sky.redis.password} database: ${sky.redis.database} # -dev sky: redis: host: localhost port: 6379 password: 123456 # 使用哪個資料庫，不填預設為 0 database: 10 Redis 預設有 16 個資料庫 (0-15)，可以透過修改設定檔來指定資料庫的數量\n編寫配置類，建立 RedisTemplate 對象\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 @Configuration @Slf4j public class RedisConfiguration { @Bean public RedisTemplate redisTemplate(RedisConnectionFactory redisConnectionFactory){ log.info(\u0026#34;開始創建 Redis 對象\u0026#34;); RedisTemplate redisTemplate = new RedisTemplate(); // 設定 redis 的連接工廠對象 redisTemplate.setConnectionFactory(redisConnectionFactory); // 設定 redis key 的序列化器 redisTemplate.setKeySerializer(new StringRedisSerializer()); return redisTemplate; } } 此配置類別不是必須的，SpringBoot 框架會自動組裝 RedisTemplate 對象，不過預設的序列化器為 JdkSerializationRedisSerializer，儲存到 Redis 中的資料與原始資料有差別\n字串類型數據 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @SpringBootTest public class RedisTest { @Autowired private RedisTemplate redisTemplate; @Test public void testString(){ // set redisTemplate.opsForValue().set(\u0026#34;name\u0026#34;, \u0026#34;Tom\u0026#34;); // get String name =(String) redisTemplate.opsForValue().get(\u0026#34;name\u0026#34;); System.out.println(name); // setex redisTemplate.opsForValue().set(\u0026#34;code\u0026#34;, \u0026#34;1234\u0026#34;, 2, TimeUnit.MINUTES); // setnx redisTemplate.opsForValue().setIfAbsent(\u0026#34;lock\u0026#34;,\u0026#34;1\u0026#34;); redisTemplate.opsForValue().setIfAbsent(\u0026#34;lock\u0026#34;,\u0026#34;2\u0026#34;); } } 哈希類型數據 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @Test public void testHash(){ HashOperations hashOperations = redisTemplate.opsForHash(); // hset hashOperations.put(\u0026#34;100\u0026#34;, \u0026#34;name\u0026#34;, \u0026#34;Jerry\u0026#34;); hashOperations.put(\u0026#34;100\u0026#34;, \u0026#34;age\u0026#34;, \u0026#34;20\u0026#34;); // hget String name =(String) hashOperations.get(\u0026#34;100\u0026#34;, \u0026#34;name\u0026#34;); System.out.println(name); // hkeys Set keys = hashOperations.keys(\u0026#34;100\u0026#34;); System.out.println(keys); // hvals List values = hashOperations.values(\u0026#34;100\u0026#34;); System.out.println(values); // hdel hashOperations.delete(\u0026#34;100\u0026#34;, \u0026#34;name\u0026#34;); } 列表類型數據 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Test public void testList(){ ListOperations listOperations = redisTemplate.opsForList(); // lpush listOperations.leftPushAll(\u0026#34;mylist\u0026#34;, \u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;); listOperations.leftPush(\u0026#34;mylist\u0026#34;, \u0026#34;d\u0026#34;); // lrange List mylist = listOperations.range(\u0026#34;mylist\u0026#34;, 0, -1); System.out.println(mylist); // rpop listOperations.rightPop(\u0026#34;mylist\u0026#34;); // llen Long size = listOperations.size(\u0026#34;mylist\u0026#34;); System.out.println(size); } 集合類型數據 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 @Test public void testSet(){ SetOperations setOperations = redisTemplate.opsForSet(); // sadd setOperations.add(\u0026#34;set1\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;,\u0026#34;c\u0026#34;,\u0026#34;d\u0026#34;); setOperations.add(\u0026#34;set2\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;,\u0026#34;x\u0026#34;,\u0026#34;y\u0026#34;); // smembers Set members = setOperations.members(\u0026#34;set1\u0026#34;); System.out.println(members); // scard Long size = setOperations.size(\u0026#34;set1\u0026#34;); System.out.println(size); // sinter Set intersect = setOperations.intersect(\u0026#34;set1\u0026#34;, \u0026#34;set2\u0026#34;); System.out.println(intersect); // sunion Set union = setOperations.union(\u0026#34;set1\u0026#34;, \u0026#34;set2\u0026#34;); System.out.println(union); // srem setOperations.remove(\u0026#34;set1\u0026#34;, \u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;); } 有序集合類型數據 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Test public void testZset(){ ZSetOperations zSetOperations = redisTemplate.opsForZSet(); // zadd zSetOperations.add(\u0026#34;zset1\u0026#34;, \u0026#34;a\u0026#34;, 10); zSetOperations.add(\u0026#34;zset1\u0026#34;, \u0026#34;b\u0026#34;, 12); zSetOperations.add(\u0026#34;zset1\u0026#34;, \u0026#34;c\u0026#34;, 9); // zrange Set zset = zSetOperations.range(\u0026#34;zset1\u0026#34;, 0, -1); System.out.println(zset); // zincrby zSetOperations.incrementScore(\u0026#34;zset1\u0026#34;, \u0026#34;c\u0026#34;, 10); // zrem zSetOperations.remove(\u0026#34;zset1\u0026#34;, \u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;); } 通用命令操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @Test public void testCommon(){ // keys Set keys = redisTemplate.keys(\u0026#34;*\u0026#34;); System.out.println(keys); // exists Boolean name = redisTemplate.hasKey(\u0026#34;name\u0026#34;); System.out.println(name); // type for (Object key : keys) { DataType type = redisTemplate.type(key); System.out.println(type.name()); } // del redisTemplate.delete(\u0026#34;set2\u0026#34;); } ","date":"2024-02-23T16:40:34+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/157/","title":"Redis"},{"content":" 此頁面有使用機器翻譯喲\n引言 在玩了 Beat Saber 和 VRchat 等 VR 遊戲後突然想到 i 社有部分遊戲支援 VR，本人最喜歡玩戀活，於是試著進行遊玩，但卻遇到相關問題，本文僅作記錄。另 VR 版則無劇情，本人使用原版所以遇到問題較少。\n前提/條件 以下圖片和部分文字來自 Oculus 官網 Support ，部分英文自己進行了翻譯，鑑於本人英文不是太好，請以官方原內容為準，以下列出主要內容，詳情請參考 Oculus Link 的相容性要求 資料線要求 Oculus Link 需使用能夠支援資料和電源連接的優質 USB 資料線。為獲得最佳舒適體驗，您還應確保資料線長度至少為 3 米 (10 英尺)\n電腦要求 配件 推薦配置 CPU Intel i5-4590 / AMD Ryzen 5 1500X 或更高版本 顯卡 請參閱下面的 GPU 表 記憶體 8 GB+ 記憶體 作業系統 Win10 USB 介面 1 個 USB 介面 Oculus Link 支援的 GPU NVIDIA GPU 支援 暫時不支援 NVIDIA Titan Z X NVIDIA Titan X X NVIDIA GeForce GTX 970 X NVIDIA GeForce GTX 1060 Desktop, 3GB X NVIDIA GeForce GTX 1060 Desktop, 6GB X NVIDIA GeForce GTX 1060M X NVIDIA GeForce GTX 1070(all) X NVIDIA GeForce GTX 1080(all) X NVIDIA GeForce GTX 1650 X NVIDIA GeForce GTX 1650 Super X NVIDIA GeForce GTX 1660 X NVIDIA GeForce GTX 1660 TI X NVIDIA GeForce RTX 20-series (all) X NVIDIA GeForce RTX 30-series (all) X AMD GPU 支援 暫時不支援 AMD 200 Series X AMD 300 Series X AMD 400 Series X AMD 500 Series X AMD 5000 Series X AMD 6000 Series X AMD Vega Series X 一、進入遊戲 進入遊戲 VR 版本直接打開 KoikatuVR.exe 即可，由於使用 steam 串流，故可提前進入 steamVR\n進入遊戲前請確保戴上耳機，房門鎖緊等以預防突發情況，如不能做到請注意行為 XD\n問題一：無法進入 steamVR 一、確保安裝相關軟體 1）steamVR 安裝 首先打開 steam，然後按 Win+R，輸入 steam://run/250820，按下回車便會自動安裝 steamVR\n2）Oculus 安裝 訪問 官網下載 ，注意：安裝完成後會下載相關檔案，完成後會要求登錄帳號，請確保網絡環境正常 (台灣應該沒事 XD)\n如要求提供支付方式，可尋找 跳過 按鈕\n如果登入一直在加載，無法成功登入 可通過修改 Hosts 解決，推薦使用火絨打開 hosts 檔案進行修改\n如果不使用火絨，打開 C:\\Windows\\System32\\drivers\\etc，找到 hosts 這個檔案，用記事本打開\n在檔案末尾添加如下內容\n1 2 3 4 157.240.11.49 graph.oculus.com 157.240.11.49 www2.oculus.com 157.240.8.49 scontent.oculuscdn.com 157.240.8.49 securecdn.oculus.com 然後保存即可，如果不是使用火絨，請保存到一個地方然後移回原目錄並將副檔名 .txt 去除\n二、確保 Link 線正常 事實上，連接 Quest2 的時候 Oculus 軟體會有一步選擇是否檢測 Link 線，可通過此進行檢測，如果當時未進行檢測，可選擇 設備 - Quest2 和 Touch-USB 檢測 進行檢測\n三、確保設置正常 1）Quest2 設備設置 使用 USB 連接 PC 和 Quest2 時 Quest 會彈出 允許訪問資料，請選擇拒絕，如果選擇了 允許，請拔下再重新連接選擇 拒絕\n2）Oculus 軟體設置 其實直接打開 steamVR 會有彈窗 是否允許未知來源 此時選擇允許即可\n當然，可以在軟體的 設置 - 通用 - 未知來源 進行打開\n四、還是無法打開？換個姿勢試試 如果以上都沒問題但還是無法打開 steamVR，則可使用下述方式\n1）Quest2 設備 當連接 PC 後一般會有彈窗 啟用 Oculus Link，此時選擇 啟用 即可\n如果上述未選擇 啟用 或沒有彈窗，可在下方任務欄的最左方即 快速設置 中找到 Oculus Link，點擊即可打開\n2）啟動 steamVR 不會有人不知道 steamVR 怎麼啟動吧 (doge)\n如果先連接 VR 設備再打開 steam，那麼 steam 的介面右上方應該有 “VR” 標識，點擊即可打開\n如果無此標識，可在任務欄 (或者說右下托盤) 裡找到 steam 圖標，鼠標右擊，倒數第二個即為 steamVR\n當然，可以在 steam 庫中將 工具 也顯示，這樣可以在 steam 庫中看見 steamVR\n二、開始遊戲 我不知道這裡應該寫什麼，分這個標題是因為問題二與遊戲有關，那就寫其他的吧 (doge)\n點擊 KoikatuVR.exe 會自動打開 steamVR，所以可以在 Quest2 設備打開 Oculus Link 後直接打開 KoikatuVR 即可\n注意：遊戲會在桌面有一個視窗，可透過 Win+D 最小化所有視窗，但當摘下頭顯再次戴上時好像會再次出現，請注意\n問題二：無法開始遊戲/不知如何開始 如果您閱讀其他文章或觀看相關影片可能會得到僅支援部分設備 (支持啥我忘了)，如果和我一樣去測試了 VR kanojo 能否正常運行，也可能會以為是靠注視，其實不然 (我就是想多寫點)\n只需要按下 “搖桿” 即可出現選擇線，按下前 “扳機鍵” 即可選擇 (更多操作請看 三、操作說明)\n問題三：開始遊戲後一直白屏，電腦上 \u0026ldquo;LOADING\u0026rdquo; 一直在一半 可進 コイカツ！ DL 版 ，點擊下方 體験版・無料ダウンロード 中的 コイカツ VR パッチ 進行下載\n檔案直鏈： コイカツ VR パッチ 下載解壓後會有一個可執行檔，運行後會出現 コイカツ！VR_0531 更新版 資料夾，將裡面 setup 資料夾內容移到遊戲根目錄並覆蓋即可\n注意：此方法來源作者指出姿勢會變成只有三個，由於我並未遊玩，所以我沒有姿勢 (本來想著 VR 玩劇情的，但 VR 不能玩劇情)，以下為作者給出解決 (部分內容有修改)\n姿勢是在故事模式裡用過什麼姿勢，在 vr 裡才能用，所以在故事模式裡戰鬥的時候把所有姿勢都點一遍，點完就換就行，然後到晚上存檔，在退出換 vr，然後姿勢就齊了\n原文地址： 兄弟們有沒有玩了 vr 的 三、操作說明 此部分為自行遊玩得出，僅作部分說明，其他操作請自行參考其他文章\n1）開始遊戲 進入遊戲後會有俩選項，分別為\nスタート，即 start，即開始\nエンド，即 End，即結束\n按下 \u0026ldquo;搖桿\u0026rdquo;，會出現一條線，可進行選擇 (前 \u0026ldquo;扳機鍵\u0026rdquo;)\n2）進入本番 左右手手腕部分會出現文字，可通過左右控制器上方按鍵即 Y 和 B 進行切換\n一共有倆個，進入戰鬥後有三個 (多了一個 移動)，分別為\n日文 英文 中文 作用 アクション Action 行動 前 \u0026ldquo;扳機鍵\u0026rdquo; 可進行各種操作 側 \u0026ldquo;扳機鍵\u0026rdquo; 可打開菜單 按下 \u0026ldquo;搖桿\u0026rdquo; 可進行選擇 システム system 系統 前 \u0026ldquo;扳機鍵\u0026rdquo; 可重置位置 移動 Move 移動 前 \u0026ldquo;扳機鍵\u0026rdquo; 按住可改變視角 3）注意 僅可在 \u0026ldquo;アクション\u0026rdquo; 時按下 \u0026ldquo;搖桿\u0026rdquo; 可以進行選擇\n參考文章 Oculus Link 兄弟們有沒有玩了 vr 的 Oculus 用戶端在 Win10 上面無法安裝或登陸的解決方法_國韻的部落格 - CSDN 部落格_oculus 無法連接伺服器 中國移動的日文 (別問我為什麼會參考這個，問就是不會日文)\n","date":"2022-03-18T16:54:23+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/30/","title":"使用 Quest2 VR 玩戀愛活動 (戀活 / koikatu) 遇到的問題及解決"},{"content":" 該文章使用 Google 翻譯處理。\n順序棧 (數組實作) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #include \u0026lt;stdio.h\u0026gt; // 元素 elem 進棧，a 為數組，top 值為目前堆疊的棧頂位置 int push(int* a,int top,int elem) { a[++top]=elem; return top; } // 資料元素出棧 int pop(int * a,int top) { if (top==-1) { printf(\u0026#34;空堆疊\u0026#34;); return -1; } printf(\u0026#34;彈棧元素：%d\\n\u0026#34;,a[top]); top--; return top; } int main(void) { int a[100]; int top=-1; top = push(a, top, 1); top = push(a, top, 2); top = push(a, top, 3); top = push(a, top, 4); top = pop(a, top); top = pop(a, top); top = pop(a, top); top = pop(a, top); top = pop(a, top); return 0; } 輸出結果：\n彈棧元素：4 彈棧元素：3\n彈棧元素：2 彈棧元素：1 空堆疊\n鏈堆疊 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; typedef struct lineStack{ int data; struct lineStack * next; }lineStack; // stack 為目前的鏈棧，a 表示入棧元素 lineStack* push(lineStack * stack,int a) { // 建立儲存新元素的節點 lineStack * line=(lineStack*)malloc(sizeof(lineStack)); line-\u0026gt;data=a; // 新節點與頭節點建立邏輯關係 line-\u0026gt;next=stack; // 更新頭指標的指向 stack=line; return stack; } // 棧頂元素出鏈棧的實作函數 lineStack * pop(lineStack * stack) { if (stack) { // 宣告一個新指標指向棧頂節點 lineStack * p=stack; // 更新頭指針 stack=stack-\u0026gt;next; printf(\u0026#34;出棧元素：%d \u0026#34;,p-\u0026gt;data); if (stack) { printf(\u0026#34;新棧頂元素：%d\\n\u0026#34;,stack-\u0026gt;data); } else { printf(\u0026#34;堆疊已空\\n\u0026#34;); } free(p); } else { printf(\u0026#34;棧內沒有元素\u0026#34;); return stack; } return stack; } int main(void) { lineStack * stack=NULL; stack=push(stack, 1); stack=push(stack, 2); stack=push(stack, 3); stack=push(stack, 4); stack=pop(stack); stack=pop(stack); stack=pop(stack); stack=pop(stack); stack=pop(stack); return 0; } 輸出結果：\n出棧元素：4 新棧頂元素：3 出棧元素：3 新棧頂元素：2\n出棧元素：2 新棧頂元素：1\n出棧元素：1 堆疊已空 棧內沒有元素\n","date":"2021-11-21T22:19:04+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/17/","title":"資料結構 堆疊程式碼"},{"content":" 該文章使用 Google 翻譯處理。\n程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; // malloc()、exit() #define Size 5 // 對 Size 進行巨集定義，表示順序表申請空間的大小 typedef struct Table { int * head; // 宣告了一個名為head的長度不確定的數組，也叫“動態數組” int length; // 記錄當前順序表的長度 int size; // 記錄順序表分配的儲存容量 }table; // 初始化函數 table initTable() { table t; t.head = (int*)malloc(Size * sizeof(int)); // 建構一個空的順序表，動態申請儲存空間 if (!t.head) // 若申請失敗，作出提示並直接退出程序 { printf(\u0026#34;初始化失敗\u0026#34;); exit(0); } t.length = 0; // 空表的長度初始化為 0 t.size = Size; // 空表的初始儲存空間為 Size return t; } // 插入函數，其中，elem 為插入的元素，add 為插入到順序表的位置 table addTable(table t, int elem, int add) { int i; // 判斷插入本身是否有問題（如果插入元素位置比整張表的長度 +1 還大 (如果相等，是尾隨的情況)，或者插入的位置本身不存在，程序作為提示並自動退出) if (add \u0026gt; t.length + 1 || add \u0026lt; 1) { printf(\u0026#34;插入位置有問題\u0026#34;); return t; } // 做插入操作時，首先需要看順序表是否有多餘的儲存空間提供給插入的元素，如果沒有，則需要申請 if (t.length == t.size) { t.head = (int *)realloc(t.head, (t.size + 1) * sizeof(int)); if (!t.head) { printf(\u0026#34;儲存分配失敗\u0026#34;); return t; } t.size += 1; } // 插入操作，需要將從插入位置開始的後續元素，逐個後移 for (i = t.length - 1; i \u0026gt;= add - 1; i--) { t.head[i + 1] = t.head[i]; } // 後移完成後，直接將所需插入元素，新增至順序表的相應位置 t.head[add - 1] = elem; // 由於添加了元素，所以長度 +1 t.length++; return t; } // 刪除函數 table delTable(table t, int add) { int i; if (add \u0026gt; t.length || add \u0026lt; 1) { printf(\u0026#34;被刪除元素的位置有誤\u0026#34;); exit(0); } for (i = add; i \u0026lt; t.length; i++) { t.head[i - 1] = t.head[i]; } t.length--; return t; } // 尋找函數，其中，elem 表示要尋找的資料元素的值 int selectTable(table t, int elem) { int i; for (i = 0; i \u0026lt; t.length; i++) { if (t.head[i] == elem) { return i + 1; } } return -1; } // 更改函數，其中，elem 為要更改的元素，newElem 為新的資料元素 table amendTable(table t, int elem, int newElem) { int add = selectTable(t, elem); t.head[add - 1] = newElem; return t; } // 輸出順序表中元素的函數 void displayTable(table t) { int i; for (i = 0; i \u0026lt; t.length; i++) { printf(\u0026#34;%d \u0026#34;, t.head[i]); } printf(\u0026#34;\\n\u0026#34;); } int main() { int i, add; table t1 = initTable(); // 在順序表中新增元素 for (i = 1; i \u0026lt;= Size; i++) { t1.head[i - 1] = i; t1.length++; } printf(\u0026#34;原順序表：\\n\u0026#34;); displayTable(t1); printf(\u0026#34;刪除元素 1:\\n\u0026#34;); t1 = delTable(t1, 1); displayTable(t1); printf(\u0026#34;在第 2 的位置插入元素 5:\\n\u0026#34;); t1 = addTable(t1, 5, 2); displayTable(t1); printf(\u0026#34;尋找元素 3 的位置:\\n\u0026#34;); add = selectTable(t1, 3); printf(\u0026#34;%d\\n\u0026#34;, add); printf(\u0026#34;將元素 3 改為 6:\\n\u0026#34;); t1 = amendTable(t1, 3, 6); displayTable(t1); return 0; } 結果 程式運行結果為：\n原順序表： 1 2 3 4 5\n刪除元素 1:\n2 3 4 5\n在第 2 的位置插入元素 5:\n2 5 3 4 5\n尋找元素 3 的位置:\n3\n將元素 3 改為 6:\n2 5 6 4 5\n","date":"2021-11-20T23:01:47+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/16/","title":"資料結構 順序表程式碼"},{"content":" 該文章使用 Google 翻譯處理。\n簡單鍊錶 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include \u0026lt;stdio.h\u0026gt; struct student { long num; float score; struct student *next; }; void main() { struct student a, b, c, *head, *p; a.num = 99101; a.score = 89.5; b.num = 99103; b.score = 90; c.num = 99107; c.score = 85; // 對結點的 num 和 score 成員賦值 head = \u0026amp;a; // 將結點 a 的起始位址賦給頭指標 head a.next = \u0026amp;b; // 將結點 b 的起始位址賦給 a 結點的 next 成員 b.next = \u0026amp;c; c.next = NULL; // c 結點的 next 成員不存放其他結點位址 p = head; // 使 p 指標指向 a 結點 do { printf(\u0026#34;%ld %5.1f\\n\u0026#34;, p-\u0026gt;num, p-\u0026gt;score); // 輸出 p 指向的結點的數據 p = p-\u0026gt;next; // 使 p 指向下一個結點 }while(p != NULL); // 輸出完 c 結點後 p 的值為 NULL system(\u0026#34;pause\u0026#34;); } 記憶體分配函數 malloc 函數 1 void *malloc(unsigned int size); 作用是在記憶體的動態儲存區中分配一個長度為 size 的連接空間。有些函數的值（即傳回值）是一個指向分配空間起始位址的指標（基底型別為 void）。如果些函數未能成功地執行（例如記憶體空間不足）則傳回空指標 NULL。\ncalloc 函數 1 void *calloc(unsigned n, unsigned size); 其作用是在記憶體的動態區儲存中分配 n 個長度為 size 的連續空間。函數傳回一個指向分配空間起始位址的指針，如果分配不成功，則傳回 NULL。 用 calloc 函數可以為一維數組開啟動態儲存空間， n 為數組元素個數，每個元素長度為 size。\nfree 函數 1 void free(void *p); 其作用是釋放由 p 指向的記憶體區，使這部分記憶體區能被其它變數使用， p 是最後一次呼叫 calloc 或 malloc 函數時傳回的值。 free 函數無回傳值​​。請注意：以前的C版本提供的 malloc 和 calloc 函數得到的是指向字元型資料的指標。 ANSI C 提供的 malloc 和 calloc 函數規定為 void * 類型。\n動態鍊錶的實現 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #define NULL 0 #define LEN sizeof(struct student) struct student { long num; float score; struct student *next; }; struct student *create() { struct student *p1, *p2, *head; int num; float score; int n = 0; head = NULL; p1 = p2 = (struct student *)malloc(LEN); printf(\u0026#34;please input num and score.\\n\u0026#34;); scanf(\u0026#34;%d,%f\u0026#34;, \u0026amp;p1-\u0026gt;num, \u0026amp;p1-\u0026gt;score); while(p1-\u0026gt;num != 0) { n ++; if(n == 1) head = p1; else p2-\u0026gt;next = p1; p2 = p1; p1 = (struct student *)malloc(sizeof(struct student)); printf(\u0026#34;please input num and score.\\n\u0026#34;); scanf(\u0026#34;%d,%f\u0026#34;, \u0026amp;p1-\u0026gt;num, \u0026amp;p1-\u0026gt;score); } p2-\u0026gt;next = NULL; return head; } void printlist(struct student *head) { struct student *p; p = head; if(head != NULL) { do { printf(\u0026#34;num=%d score=%f\\n\u0026#34;, p-\u0026gt;num, p-\u0026gt;score); p = p-\u0026gt;next; }while(p != NULL); } } void main() { struct student *head; head = create(); printlist(head); system(\u0026#34;pause\u0026#34;); } // 列印鍊錶 void printlist(struct student *head) { struct student *p; p = head; if(head != NULL) { do { printf(\u0026#34;num=%d score=%5.2f\\n\u0026#34;, p-\u0026gt;num, p-\u0026gt;score); p = p-\u0026gt;next; } while (p != NULL); } /* while(p -\u0026gt; next != NULL) { printf(\u0026#34;num=%d score=%f\\n\u0026#34;, p-\u0026gt;num, p-\u0026gt;score); p = p-\u0026gt;next; }*/ } // 刪除節點 struct student *delNode(struct student *head, int num) { printf(\u0026#34;delNode.\\n\u0026#34;); struct student *p1, *p2; if(head == NULL) { printf(\u0026#34;The List is NULL.\\n\u0026#34;); } else { p1 = head; while(p1-\u0026gt;next != NULL \u0026amp;\u0026amp; p1-\u0026gt;num != num) { p2 = p1; p1 = p1-\u0026gt;next; } if(p1-\u0026gt;num == num) { if(p1 == head) head = p1-\u0026gt;next; else p2-\u0026gt;next = p1-\u0026gt;next; } else printf(\u0026#34;Can not find list num.\\n\u0026#34;); } return head; } // 更新節點 struct student *update(struct student *head, int index, int num, float score) { printf(\u0026#34;update.\\n\u0026#34;); struct student *p; if(head == NULL) { printf(\u0026#34;The List is NULL.\\n\u0026#34;); } else { p = head; while(p-\u0026gt;next != NULL \u0026amp;\u0026amp; p-\u0026gt;num != index) { p = p-\u0026gt;next; } if(p-\u0026gt;num == index) { p-\u0026gt;num = num; p-\u0026gt;score = score; } else printf(\u0026#34;Can not find list index.\\n\u0026#34;); } return head; } // 增加節點 struct student *add(struct student *head, int index, int num, float score) { printf(\u0026#34;add.\\n\u0026#34;); struct student *p1, *p2, *p3; if(head == NULL) { printf(\u0026#34;The List is NULL.\\n\u0026#34;); } else { p1 = p2 = head; while(p1-\u0026gt;next != NULL \u0026amp;\u0026amp; p1-\u0026gt;num != index) { p1 = p1-\u0026gt;next; p2 = p1; } if(p1-\u0026gt;num == index) { p3 = (struct student *)malloc(LEN); p3-\u0026gt;num = num; p3-\u0026gt;score = score; if(p2-\u0026gt;next == NULL) { p2-\u0026gt;next = p3; p3-\u0026gt;next = NULL; } else { p3-\u0026gt;next = p2-\u0026gt;next; p2-\u0026gt;next = p3; } } else printf(\u0026#34;Can not find list index.\\n\u0026#34;); } return head; } ","date":"2021-11-17T12:00:49+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/15/","title":"資料結構 鍊錶程式碼"},{"content":" 該文章使用 Google 翻譯處理。\n該文章由 Hiyoung 編寫，翻譯自 yexca\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 //數組堆疊的實現 #include\u0026lt;stdio.h\u0026gt; #define MaxSize 50 typedef struct Stack_Array{ int data[MaxSize]; int top; }Sqstack,*pSqstack; void Initstack(); //初始化 int Isempty(); //判斷棧空 int Push(); //入堆疊 int Pop(); //出堆疊 int Gettop(); //get 堆疊頂元素 int main(void) //測試 { int val; Sqstack s1; pSqstack ps1=\u0026amp;s1; Initstack(\u0026amp;s1); //初始化 if(Isempty(\u0026amp;s1)) //判斷棧空 printf(\u0026#34;棧為空！\\n\u0026#34;); else printf(\u0026#34;棧不為空！\\n\u0026#34;); printf(\u0026#34;輸入壓棧元素的值\u0026#34;); //壓棧 1 scanf(\u0026#34;%d\u0026#34;,\u0026amp;val); Push (ps1,\u0026amp;val); printf(\u0026#34;輸入壓棧元素的值\u0026#34;); //壓棧 2 scanf(\u0026#34;%d\u0026#34;,\u0026amp;val); Push (ps1,\u0026amp;val); if(Isempty(ps1)) //判斷棧空 printf(\u0026#34;棧為空！\\n\u0026#34;); else printf(\u0026#34;棧不為空！\\n\u0026#34;); if(Gettop(ps1,\u0026amp;val)) //get 堆疊頂元素 printf(\u0026#34;棧頂值為%d\\n\u0026#34;,val); else printf(\u0026#34;棧頂元素查找失敗！\\n\u0026#34;); if(Pop(ps1,\u0026amp;val)) //出棧 printf(\u0026#34;出棧成功，出棧元素為%d\\n\u0026#34;,val); else printf(\u0026#34;出棧失敗！\\n\u0026#34;); return 0; } //初始化 void Initstack (pSqstack ps1) { ps1-\u0026gt;top=-1; return; } //判斷棧空 int Isempty(pSqstack ps1) { if(ps1-\u0026gt;top==-1) return 1; else return 0; } //若棧不滿，則進行壓棧 int Push(pSqstack ps1,int *val)//*val:接受一個地址(int *(\u0026amp;val)) { if(ps1-\u0026gt;top==MaxSize) return 0; else { ps1-\u0026gt;top++; ps1-\u0026gt;data[ps1-\u0026gt;top]=*val;//這裡傳遞的是值，這裡的*val是*(\u0026amp;val),\u0026amp;val是由主調函數輸入 //也可写作ps1-\u0026gt;data[++ps1-\u0026gt;top]=*val; 一定是++ps1-\u0026gt;top return 1; } } //若棧不空，則進行出棧，用val返回棧頂元素 int\tPop(pSqstack ps1,int *val) { if(Isempty(ps1)) return 0; else { *val=ps1-\u0026gt;data[ps1-\u0026gt;top--]; return 1; } } //get棧頂元素，用val返回棧頂元素 int Gettop(pSqstack ps1,int *val) { if(Isempty(ps1)) return 0; else { *val=ps1-\u0026gt;data[ps1-\u0026gt;top]; return 1; } } 圖解簡化\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 //棧的鍊式存儲實現 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #define Stack_Init_Size 10 // 初始化堆疊的最大長度 #define StackIncrement 10 // 若堆疊最大空間不夠時，需要增加的長度 typedef int ElemType; typedef int Status; typedef struct { ElemType *base; // 堆疊底部指針 ElemType *top; // 堆疊頂指針 int stack_size; // 堆疊的最大長度 } SqStack; // 初始化堆疊 Status InitStack(SqStack *S) { // 分配初始空間 S-\u0026gt;base = (ElemType *) malloc(Stack_Init_Size * sizeof(ElemType)); if (!S-\u0026gt;base) { exit(0); } S-\u0026gt;top = S-\u0026gt;base; /// 棧頂與棧底相同 S-\u0026gt;stack_size = Stack_Init_Size; // 堆疊的最大長度等於初始長度 return 1; } // 判斷棧是否為空，只需要判斷棧頂指標與棧底指標是否相同即可 Status EmptyStack(SqStack *S) { return S-\u0026gt;base == S-\u0026gt;top; } // 取得棧的實際長度，棧頂減去棧底指標即為棧的長度 Status LengthStack(SqStack *S) { if (S-\u0026gt;top == S-\u0026gt;base) { return 0; } return (Status) (S-\u0026gt;top - S-\u0026gt;base); } // 取得棧頂的元素，參數e用來存放棧頂的元素 Status GetTopStack(SqStack *S, ElemType *e) { if (S-\u0026gt;top == S-\u0026gt;base) { return 0; } *e = *(S-\u0026gt;top - 1); return 1; } // 進棧，參數e是要進棧的元素 Status PushStack(SqStack *S, ElemType e) { // 若棧的最大長度不會夠用時，重新開闢，增大長度 if (S-\u0026gt;top - S-\u0026gt;base \u0026gt;= S-\u0026gt;stack_size) { S-\u0026gt;base = (ElemType *)realloc(S-\u0026gt;base, (S-\u0026gt;stack_size + StackIncrement) * sizeof(ElemType)); if (!S-\u0026gt;base) { return 0; } // 棧頂指標為棧底指標加上堆疊之前的最大長度 S-\u0026gt;top = S-\u0026gt;base + S-\u0026gt;stack_size; // 堆疊目前的最大長度等於堆疊之前的最大長度與增加的長度總和 S-\u0026gt;stack_size += StackIncrement; } *S-\u0026gt;top++ = e; // 先賦值，後棧頂指標上移 return 1; } // 出棧，參數e用來存放出棧的元素 Status PopStack(SqStack *S, ElemType *e) { if (S-\u0026gt;base == S-\u0026gt;top) { return 0; } *e = *--S-\u0026gt;top; // 棧頂指標先下移，後賦值 return 1; } // 銷毀棧，釋放棧空間，棧頂棧底指標置為NULL，長度置為0 Status DestroyStack(SqStack *S) { free(S-\u0026gt;base); S-\u0026gt;base = S-\u0026gt;top = NULL; S-\u0026gt;stack_size = 0; return 1; } // 遍歷棧，依序列印每個元素 Status StackTraverse(SqStack *S) { ElemType *p; if (S-\u0026gt;top == S-\u0026gt;base) { printf(\u0026#34;Stack is NULL.\\n\u0026#34;); return 0; } p = S-\u0026gt;top; // 由棧頂依序向下遍歷 while (p \u0026gt; S-\u0026gt;base) { p--; printf(\u0026#34;%d \u0026#34;, *p); } printf(\u0026#34;\\n\u0026#34;); return 1; } int main() { SqStack q, *S; S = \u0026amp;q; int i, n, e; printf(\u0026#34;Creat a NULL Stack :\\n\u0026#34;); InitStack(S); printf(\u0026#34;input the length of the Stack :\\n\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (i = 1; i \u0026lt;= n; i++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;e); PushStack(S, e); } printf(\u0026#34;Is the stack NULL?\\n\u0026#34;); if (EmptyStack(S)) { printf(\u0026#34;Yes!\\n\u0026#34;); } else { printf(\u0026#34;No!\\n\u0026#34;); } printf(\u0026#34;The length of stack is %d.\\n\u0026#34;, LengthStack(S)); printf(\u0026#34;The stack is :\\n\u0026#34;); StackTraverse(S); e = GetTopStack(S, \u0026amp;e); printf(\u0026#34;The top data is %d.\\n\u0026#34;, e); printf(\u0026#34;input the data to the stack :\\n\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;e); PushStack(S, e); printf(\u0026#34;The new stack is :\\n\u0026#34;); StackTraverse(S); printf(\u0026#34;Delete the top data : \u0026#34;); e = PopStack(S, \u0026amp;e); printf(\u0026#34;%d\\n\u0026#34;, e); printf(\u0026#34;The new stack is :\\n\u0026#34;); StackTraverse(S); printf(\u0026#34;Destroy the stack :\\n\u0026#34;); DestroyStack(S); StackTraverse(S); return 0; } ","date":"2021-11-11T23:03:27+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/14/","title":"C 資料結構程式碼"},{"content":" 該文章由 ctxbb 編寫，因為是圖片，沒翻譯\n","date":"2021-11-11T18:01:33+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/13/","title":"揚州杏雨後"},{"content":" 該文章使用 Google 翻譯處理。\n雖然米忽悠的米遊社提供了原神樹脂的查看，但是使用電腦時每次查看還要打開手機然後打開米遊社著實有億點不方便\n原作者文章： 自己做了一個樹脂記錄軟件 原文軟件鏈接： 提取碼：1w5b 下載完成後打開，會提示輸入 uid 和 cookie，下面是如何抓取米遊社的 cookie\n首先打開 米遊社 並登錄\n然後按 F12 打開開發者工具，這時刷新網頁\n然後點擊“網絡-ys/”，找到請求標頭，然後在 cookie 右擊複製\n注意：需要的 cookie 字段為 account_id=xxx; cookie_token=xxx，請自行修改\n**2022-6-6 修改 ( hiyoung )**\n由於米哈遊修改了 bbs 可以獲取的 Cookie，導致一次獲取的 Cookie 缺失，所以需要增加步驟\n按下鍵盤上的 F12 或右鍵檢查,開啟開發者工具,點選 Console\n輸入\n1 var cookie=document.cookie;var ask=confirm(\u0026#39;Cookie:\u0026#39;+cookie+\u0026#39;\\n\\nDo you want to copy the cookie to the clipboard?\u0026#39;);if(ask==true){copy(cookie);msg=cookie}else{msg=\u0026#39;Cancel\u0026#39;} 回車執行，並在確認無誤後點擊確定。此時 Cookie 已經復製到你的粘貼板上了\n注意：請使用 Chrome，Edge 獲取也是不完整的 ( yexca )\n","date":"2021-11-10T15:21:30+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/12/","title":"原神樹脂查看與推送"},{"content":" 該文章使用 Google 翻譯處理。\n首先我們找到要下載的視頻 (廢話)，複製圖中框選部分的鏈接\n然後打開 視頻下載解析網站 ，輸入複製的鏈接然後點擊解析視頻圖片 (如需驗證根據網站提示進行即可)\n然後點擊下載視頻即可\n// 這篇好水\n","date":"2021-11-10T11:29:51+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/11/","title":"微博影片下載"},{"content":" 該文章使用 Google 翻譯處理。\n多數情況下，我們瀏覽網頁一般使用瀏覽器或系統自帶的返回，但有些系統的交互邏輯及其不好用，這時在網頁添加一個返回上一頁按鈕可以極大改善瀏覽體驗\n首先，在 WordPress 的後台點擊“外觀-自定義”來到可視化編輯頁面\n在左方找到“額外CSS”選項（一般在最後）\n然後在裡面輸入下方代碼\n1 2 3 4 5 6 7 8 .float-button { position: fixed; height: 90px; width: 40px; bottom: 90px; right: 50px; /* 可以自行修改相關描述 */ } 輸入完成後儲存，然後編輯主題相關介面\n如果您不能訪問服務器文件，可以在 WordPress 後台的“外觀-主題編輯器”中找到要添加的界面修改\n如果您可以存取伺服器文件，可以開啟路徑 網站根目錄/wp-content/themes/\u0026lt;您的主題名稱\u0026gt;/ 然後開啟相應頁面修改\n只需在相關頁面文件插入下面代碼並保存即可\n1 2 3 4 \u0026lt;div class=\u0026#34;float-button\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; name=\u0026#34;Submit\u0026#34; value=\u0026#34;返回\u0026#34; onclick=\u0026#34;javascript:history.back(-1);\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- 可以自行修改相關描述 --\u0026gt; 參考文章 網頁上的「返回上一頁」的幾種實作程式碼 div 套路之懸浮的 button ","date":"2021-11-10T11:06:27+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/10/","title":"WordPress 新增返回上一頁按鈕"},{"content":" 該文章使用 Google 翻譯處理。\n該文章由 Hiyoung 編寫，翻譯自 yexca\n準備條件：win11 專業版及以上，將系統地區調至美國\n在設置-\u0026gt;應用 -\u0026gt; 可選功能 -\u0026gt; 更多Windows功能中勾選虛擬機平台，然後重啟系統即可\n然後下載安裝包，鏈接: https://pan.baidu.com/s/1215GlKeDCHcbE0I2SgtWLg 提取碼: frkx\n下載完成後我們可以看到下面兩個文件：倒數第二個是安卓子系統安裝包，倒數第一個是WSA工具箱用於安裝 apk 文件\n最下面兩份文件\n現在我們以管理員身份打開 Windows power shell\n執行指令：add-appxpackage 空格 + 安卓子系統的文件路徑 (切記指令與路徑之間加一個空格)\n!Win11android_4 出現上面這個即說明安裝成功\n然後在開始選單即可看到安裝完成的安卓子系統，點擊運行，勾選上開發者模式\n解壓縮另一個 zip 檔案運行，即可安裝 apk 文件\n至此即安裝完成\n**********以下內容由 yexca 添加**********\n如果工具箱無法安裝或出現下圖情況，請打開子系統設置，打開第一個選項“文件”，再打開工具箱即可 獲取文件路徑 在文件上鼠標右擊選擇“屬性-安全”，第一行對象名稱即為文件路徑\nWSA 工具箱 原發布地址 ","date":"2021-11-09T23:45:42+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/9/","title":"Win11 官方安卓子系統安裝"},{"content":" 該文章使用 Google 翻譯處理。\n該文章由 Hiyoung 編寫，翻譯自 yexca\n1.SQL ORDER BY 關鍵字 ORDER BY 關鍵字用於對結果集按照一個列或者多個列進行排序。\nORDER BY 關鍵字默認按照升序對記錄進行排序。如果需要按照降序對記錄進行排序，您可以使用 DESC 關鍵字\nSQL ORDER BY 語法 1 2 3 SELECT *column\\_name*,*column\\_name* FROM *table\\_name* ORDER BY *column\\_name*1,*column\\_name*2 ASC|DESC; –ASC 表示升序，DESC 表示降序\n–使用 order by 語句時應放在所有語句的最後使用，並且排序多個列時先排 column\\_name1 再 column\\_name2…\n2.刪除所有數據（delete 和 drop table） 您可以在不刪除表的情況下，刪除表中所有的行。這表示表格結構、屬性、索引將保持不變：DELETE FROM table\\_name;\n或\nDELETE * FROM table\\_name;\n**註釋：**在刪除記錄時要格外小心！因為您不能重來！\nDROP TABLE 語句 DROP TABLE 語句用於刪除表。DROP TABLE table\\_name\n**註釋：**與 elete 不同的是 drop table 會刪除表數據和結果，也是不可逆的！\nDROP DATABASE 語句 DROP DATABASE 語句用於刪除數據庫。DROP DATABASE database\\_name\nTRUNCATE TABLE 語句 如果我們僅僅需要刪除表內的數據，但並不刪除表本身，那麼我們該如何做呢？\n請使用 TRUNCATE TABLE 語句：TRUNCATE TABLE table\\_name\n3.SQL join SQL join 用於把來自兩個或多個表的行結合起來。\n下圖展示了 LEFT JOIN、RIGHT JOIN、INNER JOIN、OUTER JOIN 相關的 7 種用法。\nINNER JOIN：如果表中有至少一個匹配，則返回行(INNER JOIN 與 JOIN 是相同的) LEFT JOIN：即使右表中沒有匹配，也從左表返回所有的行 RIGHT JOIN：即使左表中沒有匹配，也從右表返回所有的行 FULL JOIN：只要其中一個表中存在匹配，則返回行 註釋：SQL 中的 join 語句其實對應數據庫理論中的連接概念，left join、right join 和 inner join 對應自然連接，full join 對應笛卡爾積\n4.SQL 約束 (Constraints) 1 2 3 4 5 6 7 CREATE TABLE table_name ( column_name1 data_type(size) constraint_name, column_name2 data_type(size) constraint_name, column_name3 data_type(size) constraint_name, .... ); NOT NULL – 指示某列不能存儲 NULL 值。 UNIQUE – 保證某列的每行必須有唯一的值。（一個表可以有多個 UNIQUE 約束但只能有一個 primary key，primary key 自動包含 unique 約束） PRIMARY KEY – NOT NULL 和 UNIQUE 的結合。確保某列（或兩個列多個列的結合）有唯一標識，有助於更容易更快速地找到表中的一個特定的記錄。（主鍵） FOREIGN KEY – 保證一個表中的數據匹配另一個表中的值的參照完整性。（外鍵） CHECK – 保證列中的值符合指定的條件。 DEFAULT – 規定沒有給列賦值時的默認值。 5.AUTO INCREMENT 字段 我們通常希望在每次插入新記錄時，自動地創建主鍵字段的值。\n我們可以在表中創建一個 auto-increment 字段。\n下面的 SQL 語句把 “Persons” 表中的 “ID” 列定義為 auto-increment 主鍵字段：CREATE TABLE Persons\n1 2 3 4 5 6 7 ( ID int IDENTITY(1,1) PRIMARY KEY, LastName varchar(255) NOT NULL, FirstName varchar(255), Address varchar(255), City varchar(255) ) 在上面的實例中，IDENTITY 的開始值是 1，每條新記錄遞增 1。\n**提示：**要規定 “ID” 列以 10 起始且遞增 5，請把 identity 改為 IDENTITY(10,5)。\n要在 “Persons” 表中插入新記錄，我們不必為 “ID” 列規定值（會自動添加一個唯一的值）：\n1 2 INSERT INTO Persons (FirstName,LastName) VALUES (\u0026#39;Lars\u0026#39;,\u0026#39;Monsen\u0026#39;) 上面的 SQL 語句會在 “Persons” 表中插入一條新記錄。”ID” 列會被賦予一個唯一的值。”FirstName” 列會被設置為 “Lars”，”LastName” 列會被設置為 “Monsen”。\n6.觸發器 參見： SqlServer 基礎之(觸發器) – wangchuang2017 – 博客園 ","date":"2021-11-08T11:51:18+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/8/","title":"SQL 語句的一些語法細節 (SQL SERVER 語句)"},{"content":" 該文章使用 Google 翻譯處理。\n該文章由 Hiyoung 編寫，翻譯自 yexca\n在安裝完 SQL server 和 navicat 後在 navicat 中添加數據庫：\n1.連接名無要求，按照自己需要命名\n2.打開安裝好的 SQL server 配置管理器\n注意 SQL Server（SQLEXPRESS）要保證在運行中，否則 navicat 無法連接\n雙擊開啟後點選服務，可以看到自己的主機名\n3.此時打開 navicat 在主機的地方填上：主機名 \\SQLEXPRESS (格式)\n4.用戶名填 sa (為安裝 SQL server 時的預設用戶名，具體 SQL server 網路教學很多可以自己參考) ，密碼是自己設定的 (同樣在 SQL server 安裝時設定的密碼)\n5.測試連接成功即可使用\n注：僅個人在安裝過程中遇到的問題，具體安裝教程請參考網絡\n附上 navicat 15 及註冊機： https://pan.baidu.com/s/1cJ1EZ9Gyz6Jp6J03VqcDHA 提取碼：3n7g\n","date":"2021-11-07T23:41:46+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/7/","title":"關於在使用 navicat 連接 SQL server 的一些問題"},{"content":" 該文章使用 Google 翻譯處理。\n該文章由 Hiyoung 編寫，翻譯自 yexca\n其文章 (簡體中文): https://blog.hiyoung.icu/2022/12/15/997871bc263d/ 正文 VSC只是一個純文本編輯器，不是 IDE (集成開發環境)，不含編譯器和許多其它功能，所以編譯器要自己裝好\n第一步：在 vscode 官網下載軟件，鏈接： Visual Studio Code – Code Editing. Redefined 第二步：我們需要下載一個編譯器，C 語言使用 gcc，鏈接： MinGW-w64 – for 32 and 64 bit Windows download | SourceForge.net ，選最新版本中的 x86\\_64-posix-seh 即可，網站下載可能較慢，下面給出百度網盤鏈接\n（以下附上百度網盤秒傳鏈接：b48357234368d9ba439fc0db6e86531d#84cbf1dc60abe4fff77d035540ea3132#140697937#mingw64.zip）\n（正常百度網盤鏈接：鏈接: https://pan.baidu.com/s/17FYT\\_Y-s-I2yajFc2MICqw 提取碼: ewis ）\n第三步：將 E:\\mingw64\\bin 添加到系統變量中（盤符根據自己編譯器安裝的位置）\n以 Win11 為例：打開設置-\u0026gt;系統-\u0026gt;關於-\u0026gt;高級系統設置-\u0026gt;環境變量-\u0026gt;系統變量-\u0026gt;點擊Path-\u0026gt;編輯-\u0026gt; 瀏覽-\u0026gt; 把對應文件加入即可\n第四步：\n按 Win+R，運行 cmd（不要跳這一步），輸入 gcc，應該會提示 no input files 而不是“不是內部命令或外部命令”或者“無法將“gcc” 項識別為cmdlet、函數、腳本文件或可運行程序的名稱”。如果是“不是內部命令或外部命令”，說明 gcc 在的文件夾沒有在環境變量的Path中，要加進去才行。如果加了還是這樣，重啟（不要忘記重啟）。如果重啟了還不行，那就是你自己進行的操作有問題。\n輸 gcc -v 可以顯示出 gcc 的版本。如果顯示出來的版本與你剛下的不同/更老，說明 Path 裡原本有老版本的編譯器，可能是安裝其它 IDE 時裝上的。則需要去掉 Path 裡原來的那一個 gcc 的路徑。\n這兩項驗證一定要符合，否則必須修改環境變量。小心別錯刪了。\n第五步：現在打開 vscode，下載相關插件\n第六步：我們需要寫兩個 json 文件，下面依次是 launch.json 和tasks.json（兩個文件名也必須是launch.json 和tasks.json ） 注意看代碼註釋，兩個文件都有幾處地方需要將路徑改為自己編譯器的路徑\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 { // 使用 IntelliSense 了解相關屬性。 // 懸停以查看現有屬性的描述。 // 欲了解更多信息，請訪問: https://go.microsoft.com/fwlink/?linkid=830387 \u0026#34;version\u0026#34;: \u0026#34;0.2.0\u0026#34;, \u0026#34;configurations\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;gcc.exe - 生成和調試活動文件\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;cppdbg\u0026#34;, \u0026#34;request\u0026#34;: \u0026#34;launch\u0026#34;, \u0026#34;program\u0026#34;: \u0026#34;${fileDirname}\\\\bin\\\\$ {fileBasenameNoExtension}.exe\u0026#34;,//這裡意思生成的二進制代碼會放入當前文件的bin文件夾中，我們需要自己新建一個bin文件夾 \u0026#34;args\u0026#34;: [], \u0026#34;stopAtEntry\u0026#34;: false, \u0026#34;cwd\u0026#34;: \u0026#34;${fileDirname}\u0026#34;, \u0026#34;environment\u0026#34;: [], \u0026#34;externalConsole\u0026#34;: false, \u0026#34;MIMode\u0026#34;: \u0026#34;gdb\u0026#34;, \u0026#34;miDebuggerPath\u0026#34;: \u0026#34;E:\\\\mingw64\\\\bin\\\\gdb.exe\u0026#34;, \u0026#34;setupCommands\u0026#34;: [ { \u0026#34;description\u0026#34;: \u0026#34;為 gdb 啟用整齊打印\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;-enable-pretty-printing\u0026#34;, \u0026#34;ignoreFailures\u0026#34;: true } ], \u0026#34;preLaunchTask\u0026#34;: \u0026#34;C/C++: gcc.exe 生成活動文件\u0026#34; } ] } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 { \u0026#34;tasks\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;cppbuild\u0026#34;, \u0026#34;label\u0026#34;: \u0026#34;C/C++: gcc.exe 生成活動文件\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;E:\\\\mingw64\\\\bin\\\\gcc.exe\u0026#34;,//改成自己的檔案路徑 \u0026#34;args\u0026#34;: [ /*\u0026#34;${fileDirname}\\\\*.c\u0026#34;, \u0026#34;-o\u0026#34;, \u0026#34;${fileDirname}\\\\bin\\\\${fileBasenameNoExtension}.exe\u0026#34;, \u0026#34;-g\u0026#34;//多檔編譯*/ \u0026#34;-g\u0026#34;, \u0026#34;${file}\u0026#34;, \u0026#34;-o\u0026#34;, \u0026#34;${fileDirname}\\\\bin\\\\${fileBasenameNoExtension}.exe\u0026#34;//這裡意思產生的二進位程式碼會放入目前檔案的 bin 資料夾中，我們需要自己新建一個 bin 資料夾 ], \u0026#34;options\u0026#34;: { \u0026#34;cwd\u0026#34;: \u0026#34;${fileDirname}\u0026#34; }, \u0026#34;problemMatcher\u0026#34;: [ \u0026#34;$gcc\u0026#34; ], \u0026#34;group\u0026#34;: { \u0026#34;kind\u0026#34;: \u0026#34;build\u0026#34;, \u0026#34;isDefault\u0026#34;: true }, \u0026#34;presentation\u0026#34;: { \u0026#34;echo\u0026#34;: true, \u0026#34;reveal\u0026#34;: \u0026#34;always\u0026#34;, // 執行任務時是否跳到終端面板，可以為 always，silent，never。具體參見 VSC 的文檔 \u0026#34;focus\u0026#34;: true, // 設為 true 後可以使執行 task 時焦點聚集在終端，但對編譯 C/C++ 來說，設為 true 沒有意義 \u0026#34;panel\u0026#34;: \u0026#34;shared\u0026#34; // 不同的檔案的編譯資訊共享一個終端面板 }, \u0026#34;detail\u0026#34;: \u0026#34;調試器生成的任務。\u0026#34; }, { \u0026#34;type\u0026#34;: \u0026#34;cppbuild\u0026#34;, \u0026#34;label\u0026#34;: \u0026#34;(多文件)gcc.exe - 生成和調試活動文件\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;E:\\\\mingw64\\\\bin\\\\gcc.exe\u0026#34;,//改成自己的檔案路徑 \u0026#34;args\u0026#34;: [ \u0026#34;${fileDirname}\\\\*.c\u0026#34;, \u0026#34;-o\u0026#34;, \u0026#34;${fileDirname}\\\\bin\\\\${fileBasenameNoExtension}.exe\u0026#34;,//這裡意思產生的二進位程式碼會放入目前檔案的 bin 資料夾中，我們需要自己新建一個 bin 資料夾 \u0026#34;-g\u0026#34; ], \u0026#34;options\u0026#34;: { \u0026#34;cwd\u0026#34;: \u0026#34;${fileDirname}\u0026#34; }, \u0026#34;problemMatcher\u0026#34;: [ \u0026#34;$gcc\u0026#34; ], \u0026#34;group\u0026#34;: { \u0026#34;kind\u0026#34;: \u0026#34;build\u0026#34;, \u0026#34;isDefault\u0026#34;: true }, \u0026#34;presentation\u0026#34;: { \u0026#34;echo\u0026#34;: true, \u0026#34;reveal\u0026#34;: \u0026#34;always\u0026#34;, // 執行任務時是否跳到終端面板，可以為 always，silent，never。具體參見 VSC 的文檔 \u0026#34;focus\u0026#34;: true, // 設為 true 後可以使執行 task 時焦點聚集在終端，但對編譯 C/C++ 來說，設為 true 沒有意義 \u0026#34;panel\u0026#34;: \u0026#34;shared\u0026#34; // 不同的檔案的編譯資訊共享一個終端面板 }, \u0026#34;detail\u0026#34;: \u0026#34;調試器生成的任務。\u0026#34; } ], \u0026#34;version\u0026#34;: \u0026#34;2.0.0\u0026#34; } 至此設置工作基本結束，vscode 有許多好用的插件可以自己探索，未來也會在寫一篇文章推荐一些好用的插件\n","date":"2021-11-07T23:32:26+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/6/","title":"VsCode 配置 C 語言環境"},{"content":" 該文章使用 Google 翻譯處理。\n正文 安裝完成 VS Code 和 Python 並配置環境變量後\n開啟 VS Code，進入拓展搜尋並下載 Python\n在資源管理器新建一個 Python 原始檔 (.py) 後，資源管理器會在.vscode 資料夾下產生 setting.json 檔案（若沒有自動產生可自行建立）\n開啟 setting.json 文件，並替換為以下程式碼\n1 2 3 4 5 6 { \u0026#34;python.linting.flake8Enabled\u0026#34;: true, \u0026#34;python.linting.flake8Args\u0026#34;: [\u0026#34;--max-line-length=248\u0026#34;], \u0026#34;python.linting.pylintEnabled\u0026#34;: false } 此時回到 python 文件，VS Code 右下會彈出警告，點擊下載\n按 CTRL+SHIFT+P 鍵，輸入 Python: Select Interpreter (即 Python：選擇編譯器)\n然後選擇您下載的編譯器即可\n如果 .vscode 資料夾下有 launch.json 文件，需要在該文件的 configurations 中加入以下程式碼\n1 2 3 4 5 6 7 { \u0026#34;name\u0026#34;: \u0026#34;Python: 目前文件\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;python\u0026#34;, \u0026#34;request\u0026#34;: \u0026#34;launch\u0026#34;, \u0026#34;program\u0026#34;: \u0026#34;${file}\u0026#34;, \u0026#34;console\u0026#34;: \u0026#34;integratedTerminal\u0026#34; } 參考文章 VsCode 配置 Python 環境小白教程 VSCode 配置 Python 教程 ","date":"2021-11-07T11:28:58+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/5/","title":"VsCode 配置 Python 環境"},{"content":" 該文章使用 Google 翻譯處理。\n該文章由 Hiyoung 編寫\nmailto：可以自動調用當前系統默認的郵件客戶端，並自動填充收件人、抄送人、密送人、主題、內容。\n參數說明:\nmailto： 收件人，多個以;分隔\ncc： 抄送人，多個以;分隔\nbcc： 密送人，多以;分隔\nsubject： 主題\nbody： 內容\n各參數間用\u0026amp;連接即可\n例如：\u0026lt;a mailto:***@***.com?subject=this is subject\u0026amp;body=this is body\u0026gt;…\u0026lt;a\u0026gt;\n注：在 elementor 中應在文本編輯器的超鏈接選項中直接填寫 mailto:***@***.com?subject=this is subject\u0026amp;body=this is body 即可\n","date":"2021-11-06T17:05:36+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/4/","title":"如何自動呼叫目前系統預設的郵件用戶端"},{"content":" 該文章使用 Google 翻譯處理。\n正文 首先到待嵌入的視頻將鼠標移到分享按鈕上（不用點擊）\n然後移到嵌入代碼並複制\n（本例代碼如下）\n1 \u0026lt;iframe src=\u0026#34;//player.bilibili.com/player.html?aid=583631611\u0026amp;bvid=BV1Tz4y1X7Bg\u0026amp;cid=206708397\u0026amp;page=1\u0026#34; scrolling=\u0026#34;no\u0026#34; border=\u0026#34;0\u0026#34; frameborder=\u0026#34;no\u0026#34; framespacing=\u0026#34;0\u0026#34; allowfullscreen=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;/iframe\u0026gt; 我們需要這串程式碼中的「aid」和「cid」部分（即 aid=583631611 和 cid=206708397 ）\n然後將 aid 和 cid 填入下方代碼的對應位置\n1 2 3 \u0026lt;div style=\u0026#34;position: relative; padding: 30% 45%;\u0026#34;\u0026gt; \u0026lt;iframe style=\u0026#34;position: absolute; width: 100%; height: 100%; left: 0; top: 0;\u0026#34; src=\u0026#34;https://player.bilibili.com/player.html?cid=206708397\u0026amp;aid=583631611\u0026amp;page=1\u0026amp;as_wide=1\u0026amp;high_quality=1\u0026amp;danmaku=0\u0026#34; frameborder=\u0026#34;no\u0026#34; scrolling=\u0026#34;no\u0026#34;\u0026gt;\u0026lt;/iframe\u0026gt; \u0026lt;/div\u0026gt; （以上代碼中 aid 和 cid 已替換）\n在寫文章的過程若插入影片只需將區塊設為「自訂 HTML」然後把替換好aid和cid的程式碼拷貝過去即可\n如下為示例視頻\n參考文章 關於博客園內嵌入 bilibili 視頻 ","date":"2021-11-06T16:43:20+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/3/","title":"WordPress 嵌入 BiLiBiLi 影片說明"},{"content":" 該文章使用 Google 翻譯處理。\n預設情況下，WordPress 允許作者查看您網站媒體庫中的所有圖像。允許作者查看媒體庫中的所有檔案。 他們還可以查看由管理員 ， 編輯或其他作者上傳的圖像。\n對於許多網站而言，這可能並不重要。 但是，如果您運行一個多作者網站 ，則可能需要更改它。\n首先，進入 網站根目錄/wp-content/themes/您目前使用的主題名稱/\n找到 functions.php 檔案並編輯，在末尾插入如下程式碼即可\n1 2 3 4 5 6 7 8 9 10 11 12 // Limit media library access add_filter( \u0026#39;ajax_query_attachments_args\u0026#39;, \u0026#39;wpb_show_current_user_attachments\u0026#39; ); function wpb_show_current_user_attachments( $query ) { $user_id = get_current_user_id(); if ( $user_id \u0026amp;\u0026amp; !current_user_can(\u0026#39;activate_plugins\u0026#39;) \u0026amp;\u0026amp; !current_user_can(\u0026#39;edit_others_posts \u0026#39;) ) { $query[\u0026#39;author\u0026#39;] = $user_id; } return $query; } 參考文章 如何限制媒體庫對 WordPress 中使用者自己上傳的內容的訪問 ","date":"2021-11-06T14:31:04+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/2/","title":"WordPress 限制使用者存取媒體庫"},{"content":" 該文章使用 Google 翻譯處理。\n歡迎使用 WordPress。這是您的第一篇文章。編輯或刪除它，然後開始寫作吧！\n","date":"2021-11-06T14:15:19+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/1/","title":"Hello World！"}]