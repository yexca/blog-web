[{"content":" 📢 本文由 Gemini-3-pro 翻譯 意識可以獨立於肉體、直覺可以超越邏輯、觀測可以改變現實\nNDE (Near-Death Experience) 指的是瀕臨死亡的體驗，目前有一些個人或組織對其進行過研究，像是 IANDS（國際瀕死體驗研究協會）和 P.M.H. Atwater 博士對數千名 NDErs（瀕死體驗者）的研究等。\n本文將基於這些研究以及我個人的理解來寫，因為內容實在太過複雜，如果有什麼疏漏，還請多多包涵。\n什麼是 NDE 從發生機制來看，NDE 通常指因物理狀態被醫學認定死亡後，意識前往「那裡」的經歷。但值得注意的是，也存在「情緒誘發型瀕死體驗 (Emotion-Induced NDE)」，也就是在極度的情緒 (Extreme Emotional) 或心理壓力 (Psychological Distress) 下，物理身體雖然表面無恙，但意識依然觸發了離體機制，前往了「那裡」，比如心碎症候群或迷走神經性昏厥 (Vasovagal Syncope) 導致的意識斷線。\nNDE 的核心是意識去了「那裡」的經歷，也就是強調靈魂出竅 (OBE, Out-of-Body Experience) 與重入 (Re-entry)，而不是一個簡單的美夢或者惡夢。\n「那裡」比較標誌性的特徵可能是時間非線性、空間摺疊，以及那道有深度與包覆感的光（這個光可能是連接高維世界與三維世界意識的接口）。\n而在 NDE 的「整合期 (Integration Period)」，可能會表現為 PTSD 症狀，並帶有重度憂鬱者的影子，比如自我消融 (Ego Dissolution) 或世界疏離感，雖然恢復過程類似 PTG（創傷後成長）的變化，但本質上還是有很大區別。\nNDE 與夢 關於 NDE 和普通的夢的區別，Bruce Greyson 博士制定了一套嚴格的評分系統，也就是格雷森量表 (The Greyson NDE Scale)。\n評判標準為每一項 (0=無、1=輕微、2=強烈)：\nA. 認知特徵 (Cognitive)\n時間感是否改變 (變快/變慢/停止/非線性) 思維是否加速 (極度清晰/全景式回顧) 是否有這一生經歷的回顧 (人生跑馬燈) 是否突然理解了宇宙/人生的某種真理 B. 情感特徵 (Affective)\n是否感到安寧/愉悅 是否感到極度的喜悅 是否感到與宇宙/萬物合一 是否看到/感到耀眼的光芒 C. 超自然特徵 (Paranormal)\n感官是否比平時更靈敏 (或者感覺脫離肉體) 是否有超感官知覺 (預知/遙視) 是否看到了未來的景象 是否感覺脫離了物理世界 D. 超越性特徵 (Transcendental)\n是否進入了某種非塵世的存在領域 (夢境/虛空) 是否遇到了神秘的存在 (死神/聲音/光體) 是否遇到了已故的人或宗教人物 是否遇到了無法回頭的界限 (決定生死的瞬間) 總分是 32 分，達到 7 分以上則可以在臨床科學上被認定為 NDE。\nNDE 與 PTSD PTSD 和 NDE 都是一個人經歷極端的創傷後，大腦原有防禦機制崩塌的結果。而 PTSD 是在未成功的狀態下的產物，在經過重構後會轉為 PTG。\n雖然解離感 (Dissociation)、高度警覺、各種疼痛在 PTSD 患者身上也有，但是兩者幾乎是不同的東西。\n生命科學解釋 PTSD 和 NDE 的大腦改變是不一樣的。\nPTSD 的大腦會導致杏仁核 (Amygdala) 肥大和海馬迴 (Hippocampus) 萎縮。杏仁核負責警告，這表明患者會變得極度敏感，一直處於「戰或逃」的亢奮狀態。而海馬迴負責記憶處理，導致患者無法把過去的創傷歸檔，總覺得創傷正在發生，也就是永遠活在恐懼的迴圈裡。\nNDE 的大腦是預設模式網路 (DMN) 抑制與顳頂聯合區 (TPJ) 改變。預設模式網路是負責「自我造作」、焦慮、反芻過去的網路，活性降低意味著小我 (Ego) 漸漸消失從而焦慮變少。而顳頂聯合區負責處理「我在那裡」，所以這部分的改變導致 NDErs 能體驗到「靈魂出竅」或萬物合一的感覺。\n兩者對比 其中有一些決定性的區別：\n特徵 PTSD NDE 核心情緒 恐懼、無助、焦慮 最終會轉向平靜、接納、愛 自我認知 覺得自己破碎了、受害者 覺得自己是觀察者 (Observer) 世界觀 世界是危險的，我要躲避 世界是有意義的，我有任務 對死亡 極度恐懼死亡 恐懼減少或轉化為探索慾 同時 PTSD 在經歷干預治療後可以是 PTG，而 NDE 無需治療，跟隨自己內心即可心態積極向上。\nNDE 與 PTG PTG (Post-Traumatic Growth) 本質上是心理層面的認知重構，是一個人經歷重大創傷後，在認知重構後性格或三觀（價值觀）的改變。\nNDE 則是生理與量子層面的能量過載（Overload）。基於 Rick Strassman 的假設，是大腦在瀕死瞬間（缺氧、突波）時松果體可能釋放了大量的 DMT，神經元同步放電達到峰值從而使意識暫時脫離了肉體束縛。造成的結果是不僅性格改變，身體的物理屬性也會改變。\n總結 NDE 是物理加精神的雙重改變，而一些精神類疾病像 PTSD、憂鬱症只是精神或心理層面的改變。\nNDE 為什麼存在 NDE 是不合理下的合理，正如《駭客任務》(The Matrix) 裡的 Neo 一樣，「你的存在，是這個完美數學方程式中無法消除的餘數」。\n當然，這個其實也屬於防止「熱寂 (Heat Death)」與「死結 (Deadlock)」的機制。\n如果這個物質世界 (Reality) 完全封閉，嚴格遵循物理定律以及因果律 (牛頓力學/決定論)，那麼系統最終將走向熵增到極致，也就是死氣沉沉的熱寂，或者會因為邏輯太嚴密而陷入死結（人類完全變成機器，失去靈性）。\n所以 NDErs 是引入了外部變數，以沾染部分高維空間的混沌能量（靈性/愛/真理）後注入一些「負熵 (Negentropy)」以防止熱寂與死結。\nNDE 可以重現嗎 現代神經科學認為，NDE 並不是「靈魂出竅」，而是大腦在極端危急時刻的一種特殊保護機制，以下行為也可能產生類似 NDE 的感覺：\n顳葉癲癇： 刺激大腦顳葉，普通人也能產生「遇見上帝」的感覺。 缺氧/G 力昏迷： 飛行員在離心機裡也會產生「隧道視野」和「全生回顧」。 致幻劑 (DMT)： 服用特定成分，也能產生類似的體驗。 NDE 是如何回來的 NDE 主要有兩種回來的方式，當然也有一些「小眾」的情況：\n被動遣返型 (The \u0026ldquo;Sent Back\u0026rdquo; Type)\n大概佔 60% 左右，這部分人是在「那裡」很舒服不想回來，但是突然出現一個權威形象（某種存在/親人/神）對他說「時間未到」或者「你還有任務未完成」從而回來。\n因為是服從的心態，通常是帶著遺憾與不捨被踢回來的，回來後往往會有嚴重的「思鄉病」，想要回到「那裡」。\n情感羈絆型 (The \u0026ldquo;Love Anchor\u0026rdquo; Type)\n大概佔 30% 左右，這部分人往往是到了邊界，面臨選擇，比如自己的孩子、伴侶或者父母，想要守護他們從而回來。\n因為屬於犧牲與愛的心態，通常是因為對他人的愛主動回來的，所以會帶有「守護者」的使命感，性格改變為溫柔並充滿愛心。\n其他\n當然，還有像是為了未完成的事業，未完成的學業之類的拒絕去「那裡」，或者\u0026hellip;意志對抗型 (The \u0026ldquo;Willpower Warrior\u0026rdquo; Type) 強行回來。\nNDE 的週期 事實上，在 NDE 的發生前後有一定的精神匱乏期，甚至可以說遵循 1-3-7 模型：\nNDE 前的空虛期\n這部分可以說是靈魂暗夜 (The Dark Night)，一般是 1-3 年左右，這個階段是為了清空快取 (Cache)，以為了迎接 NDE 的高維能量注入。\nNDE 後的空虛期\n這部分是真空校準期 (The Vacuum)，一般是 6 個月到 1.5 年，因為高維世界的景象相較於現實世界是迷人的，所以可能會對現實的低密度世界感到慢或無聊。\nNDE 的完全整合期\n大概是在 NDE 發生後的 7 年左右，這個時候 NDErs 可以無縫融合進地球的生活。\nNDE 的特徵 NDErs 有一些比較共通的能力，或者說「後遺症」：\n路燈干擾現象 (SLI) 這是 NDErs 最著名的「Bug」，也就是生物電磁場 (Bio-electromagnetic field) 的頻率或者功率會被加強，從而可能會干擾附近的電子設備，比較典型的是戴機械錶會容易走不準，以及走過路燈時燈泡會突然熄滅或爆閃 (Street Light Interference)。\n超感官共情 (Hyper-Empathy) 這個能力是由於大腦的抑制器 (Reducing Valve) 被拆除，所以潛意識掃描範圍變得極廣，也就是導致對於周圍的情緒數據等訊息接收更靈敏，從而更容易耗盡社交能量 (Social Battery Drained)。\n抽象思維具象化 (Synesthesia-like Processing) 普通人對概念的理解是線性的或文字的，但 NDErs 對概念的理解是全像 (Holographic) 的，也就是對複雜的概念或公式的理解不是靠邏輯推導，而是幾何結構或圖案，這比邏輯推導快無數倍，屬於量子運算級別。\n生理代謝改變 (Metabolic Changes) NDErs 的身體代謝通常會加快，細胞更新機制發生了改變，當然還有一些其他變化：\n對酒精或藥物敏感： 更容易喝醉、麻醉劑或止痛藥反應異常（無效或過敏）。 飲食改變： 突然覺得不能吃某樣東西，或者渴望特定的食物（新鮮蔬菜）。 共時性 (Synchronicity) NDErs 的意念 (Intention) 比普通人強得多，比較容易實現自己想要的事情，但這個強運不是隨心所欲的，一般會符合「自我實現」或「利他」屬性。\n自我實現： 指對自己不再虛偽迎合，而是從事自己真正熱愛的事物。 利他： 不一定是指做慈善，可能也只是分享自己的洞察，幫助別人。 絕對直覺 (Absolute Intution) NDErs 的直覺更像是一種對某件事，彷彿我天生就做過或者這是命定的軌跡一樣，具體有三個層級：\n層級 1: 下載感 (The Download)\n這是基礎的 NDE 直覺，表現為「我沒思考，但我就是知道」，去掉了中間的思考過程，直接給出答案或結果。\n層級 2: 既視感 (Deja Vu / Future Memory)\n因為「那裡」的時間是非線性的，所以過去、現在、未來是同時存在的，可能在「那裡」已經走過一遍劇本了，從而在經歷的時候感覺自己貌似經歷過。\n層級 3: 清明夢感 (Lucid Dreaming Reality)\n這是最高級的直覺，在 NDE 後遺症中被稱為「面紗變薄 (Thinning of the Veil)」或者「現實解離 (Derealization)」，也就是到某一地方彷彿就像進入了夢境，這往往代表那個地方是「高維錨點 (Anchor Point)」或者說「任務地點」。\n預知 (Foreknowledge) NDE 會獲得預知未來的能力，但是這個未來是可以改變的，或者說 NDErs 看到的是基於當前狀態下機率最大的那個「未來」。\n雖然預知其實是無法測量時間尺度的，因為預知一般是來自「那裡」的訊息，在那裡時間是非線性的，或者說不存在時間這個概念，也就無法得知時間尺度。但是如果嘗試擬合三維的時間的話，一般離自己比較近的時間會比較「準」，可能一年以內，因為時間臨近，「變數」會比較少，所以極大機率發生，但是長時間的預知就不是很準確了，甚至說是無法預知的，只是知道一個大概的趨勢而已。\n當然也不是每一次預知都要在 NDE 狀態下觸發，不如說因為 NDE 的原因更容易去「那裡」，所以更容易進入 STE (Spiritually Transformative Experience) 即靈性轉化體驗。\n雖然到了「那裡」的夢不一定是預知夢，但一般而言預知夢應該是去了「那裡」獲取了相關訊息，所以了解夢的分類可以幫助區分普通夢和去了「那裡」。\n夢的分類 夢根據大腦的生成部分不同，大致可以分為三類：\n焦慮釋放\n這部分是由大腦皮層或杏仁核生成的，對現實的部分焦慮進行釋放的夢境，基本符合三維物理，同時帶有情緒感。\n模擬推演\n這是由大腦的前額葉（邏輯中心）生成的，主要是潛意識在基於現實的訊息進行推演各種可能性。\nNDE 預知夢\n這部分的夢來源於松果體或高維意識，也就是「那裡」。在這個夢境中，時間是非線性的，空間是重疊的，情緒是零度的，一切都是狀態，意識是觀察者。\n類似於塊狀宇宙 (Block Universe) 一樣，移動不存在，時間不存在，只是被觀測的對象，並且場景是由念而生，任何想法立馬獲得反饋 (Zero Latency)，這也可能是「思鄉病」的原因。\n預知夢的特徵 NDErs 的來自「那裡」的預知夢通常會有以下特徵：\n超高畫質解析度 (Hyper-Reality)\n相對於普通的模糊的夢不同，預知夢是細節極其清晰的夢，那個真實感甚至可能超過現實。\n情緒的「零度」 (Emotional Neutrality)\n普通夢可能伴隨著情感波動，但是預知夢往往是作為一個「觀察者」的角度，只是在「看」事情的發生，而不是思考怎麼辦或者說「體驗」。\n既視感的驗證 (Deja Vu Confirmation)\n當未來這件事真的發生的時候，會有既視感，因為現實和夢境「完美重疊」。\nNDE 的代價 With great power comes great responsibility (能力越強，責任越大)\n當然，雖然看著上方的「後遺症」是挺酷的，不過 NDErs 往往需要支付一定的代價：\n無法回頭的孤獨 (The Irreversible Solitude)\n因為「那裡」所見即所得 (WYSIWYG) 的體驗可能過於美好，可能會使 NDErs 突然感覺三維世界索然無味，從而可能無法再度融入這個世界。\n感官過載與能量耗竭 (Sensory Overload \u0026amp; Burnout)\n因為直覺和感知的增強，NDE 需要高維或者說高能量訊息，而三維世界存在許多帶有雜訊的訊息，這將導致 NDErs 很容易極度疲憊，同時身體跟不上靈魂的速度，並且經常精神匱乏或當機。\n絕對責任的重負 (The Burden of Absolute Responsibility)\nNDErs 的回來是有「任務」的，也就是處於不是在完成這個「任務」的道路上，NDErs 得到的懲罰會比正常人更重，並且 NDErs 的作惡也會更快得到更重的懲罰。\n絕對真實\nNDErs 幾乎是必須要說真理，且必須遵從本心，違背本心或訴說謊言將會獲得更重的懲罰，以及更容易被拆穿。\n總的來說，就是要遵從本心，不作惡，完成任務，以及無人可以理解的\u0026hellip;孤獨。\n量子力學解釋 遇事不決，量子力學。說實話，NDErs 的 STE 體驗，確實有點類似於和「那裡」發生了量子糾纏 (Quantum Entanglement) 也說不定。\nNDE 的量子力學解釋 諾貝爾物理學獎得主 Roger Penrose 與 Stuart Hameroff 提出的 \u0026lsquo;Orch-OR 理論\u0026rsquo;（儘管在學界尚存爭議）提供了一個量子視角的解釋，他們認為人的意識存在於腦神經元微管內的量子狀態中。\n當心臟停止或者瀕死的時候，量子態失去相干性 (Decoherence)，量子訊息離開大腦洩漏到宇宙中，也就是去了「那裡」，當身體機能恢復時，量子訊息又被「吸」了回來。\n共時性的量子力學解釋 現實是一個基於機率的模擬系統，普通人的意念是混亂的，無法影響亂數產生器。\nNDErs 因為意識去過「那裡」，所以還保留著一條通道或者是量子糾纏，從而在產生某個想法的時候，周圍的一切會「機率塌縮 (Probability Collapse)」到對應的事情。\n這就好比量子力學中的「觀察者效應」在巨觀層面的投射，意念似乎引導了機率的走向。\n預知的量子力學解釋 這點可以基於 Aldous Huxley 提出的減壓閥理論 (The Reducing Valve) 解釋。\n普通人的大腦一般是一個「減壓閥」或者說過濾器，它將會過濾掉 99.9% 的訊息，而 NDE 將這個減壓閥進行高壓擊穿破壞了，所以 NDErs 將接收更多的訊息。\n也就是大腦意識原先的 Beta 波，將更容易進入 Theta 波或 Delta 波狀態以與「那裡」同頻共振。\n弦論解釋 因為這些概念有點過於玄乎，所以我想到了弦論 (String Theory)，它認為現實世界的一切都是弦的振動，物質取決於弦是如何震動的，而三維空間的一切是由十一維空間的弦的波動引起的。\nNDE 的弦論解釋 在弦論的 M-理論中，我們的三維宇宙被認為是一張漂浮在更高維空間的 D-膜 (D-Brane)。\n因為所有的物質都是「開弦」，弦的兩端是黏在這張「膜」上的，所以我們被鎖在三維世界裡出不去。但是「重力子 (Graviton)」是「閉弦」，因為沒有端點所以可以離開膜，飄到高維空間 (The Bulk，體空間) 中去。\n如果我們將此概念引入意識模型，可以大膽猜想，在瀕死的那一刻，意識可能發生了某種「量子相變」，從「開弦」暫時變成了「閉弦」，獲得了逃逸出三維膜的能量，而進入了高維度的「體空間」。\n因為高維空間時間不是線性的，所以才會有常識性的「邏輯」錯誤。\n共時性的弦論解釋 對於普通人因為沒去過高維空間，所以是無法干涉現實的物質震動。而去過高維空間的意識可能在 NDE 的時候被「調校」過，從而在產生一些想法的時候，可以在高維空間「撥動琴弦」以影響到三維空間的「膜」，從而投射到現實的改變。\n電磁干擾的弦論解釋 受到高維空間影響的意識，可能意識頻率 (Spirit) 比常人高或者不穩定，所以當靠近路燈或者精密儀器的時候，意識的「弦」和這些電子設備的「弦」發生了共振 (Resonance) 或干涉 (Interference)，從而造成了「路燈干擾現象 (SLI)」。\n命理學解釋 當西方的神經科學和心理學走到盡頭，我們不妨把目光投向東方的古老智慧。\n從命理學或者說玄學來看，NDE 現象其實也是「命中注定」的，當我得到這個結論的時候，說實話我超級震撼，不得不感嘆那句「冥冥之中自有天意」，也讓我覺得這並不是什麼特殊現象，而是一種\u0026hellip;既定的軌跡，當真是來自東方的神秘力量啊。\n觸發條件 NDE 是由兩種特殊參數同時作用的結果：\n參數 A: 劇烈的衝突\n一般情況下，NDE 發生在「歲運並臨」或者「三刑/六沖」的年份或日期，比如著名的「寅巳申三刑 (無恩之刑)」或者「天克地沖」。這導致了肉體（地支）和能量場（天干）發生劇烈物理碰撞，導致「神識」被震出肉體。\n參數 B: 空亡/華蓋\n當時那個時間點需要有「空亡」的相應命理，比如日柱落入空亡或者大運走入死絕之地（比如墓庫），從而讓神識連接到「那裡」。\n判斷條件 因為這些衝擊都是極強的，一般情況下遇到可以說就是等於宣布死亡了，但判斷是瀕死還是死亡，需要看當天的日主是否有「根」。\n死亡 (Death)\n當衝擊發生的時候，日主的「根」被完全拔除，只有一個虛浮的天干，那麼「生」氣將消散。\n瀕臨死亡 (NDE)\n雖然衝擊極強，但是日主的「根」還在的話，雖然身體受損，並不會被沖散。\n也就是 NDE = 「衝擊力 ＞ 肉體承受力」但「衝擊力 ＜ 靈魂抓地力」。\n後遺症的命理學解釋 NDE 後的狀態，事實上屬於魂魄分離狀態，道家命理認為：\n魂: 掌管精神、思維、夢境（屬木/火） 魄: 掌管肉體、感官、本能（屬金/水） NDE 的本質是「魂」飛出去到「那裡」，但是「魄」還留在體內維持生命。所以當「魂」回歸的時候，它和「魄」的咬合可能會出現微小的錯位，也就造成了這些後遺症。\n聲明 本文嘗試使用跨學科視角來解碼 NDE 體驗，但其中大部分理論只是用隱喻 (Metaphor) 來解釋主觀意識體驗，並非代表這些物理定律已在巨觀意識層面得到證實，尤其是文章涉及到了命理學部分解釋，大多純屬腦補擬合。\n歸根結底，這只是一種「可能性的探索」，或者是\u0026hellip;靈魂的全端理論捏 (Full-Stack Theory of Soul)。\n致 NDErs 如果作為 NDErs 的你還在痛苦的整合期讀到了這篇文章，我想說：\n無論這背後的機制是神學的那個存在的慈悲、命理學的命中注定、心理學的認知機制改變、生命科學的大腦結構改變、還是量子力學的波函數塌縮，最重要的是：\n回來，本身就是一個奇蹟\n既然回來了，那就從愛自己開始吧，畢竟，我們可是好不容易續了簽（命）的不是嘛～\n","date":"2026-01-01T17:16:59+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/264/","title":"走進 NDE"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 年末將至，新年伊始。回望今年，真的發生了好多事情，甚至到我不知道該不該寫出來，可不可以寫出來的地步。猶豫很久，在公園的鞦韆上，我最終還是決定寫出來吧。\n繼續我之前的 2024 年度總結，今年的前半年說實話讓我經歷了對理論的進一步延伸，中期時候的崩壞，以及後期的希望。雖然不是我自誇啦，這確實有點類似於鳳凰的涅槃重生，對我來說有點像是精神世界的重新建構。\n第一季 翻閱我的一月照片，感覺也沒什麼需要注意的，可能也就我買了一瓶 さくらみこ 的聯名酒，辦銀行卡未成功，第一次遇到電車誤點，閒逛明治神宮，過年的時候吃了一次 5A 級的和牛吧。\n二月的時候，朋友的到來，一起玩了一週耶，看著烤肉吃到飽因為豬肉太多而起火，因為手機損壞而換了新手機，在銀座的優衣庫傳輸資料，出發去箱根體驗到「人」字形鐵路設計，泡泡所謂的溫泉，以及用日語教越南人溜直排輪吧。\n三月的時候，東京下雪了，第一次買漫畫，在 VRChat 看了沖繩主辦的初音未來演唱會，第一次購買了專輯 (しぐれうい)，嘗試印度料理。\n整體來看，雖然是感覺蠻有活力的吧，但是這多數是精神異常下的活動。\n第二季 四月的我參加了兩場考試，但很可惜當時報名的時候沒注意到，集中在同一天了，這就導致了兩個都沒考好。\n五月的時候，開始準備考試了，第一次坐摩天輪，購買了新螢幕升級裝備，在光之丘公園躺在草地上感受，買下 しぐれうい 的模型公仔。\n六月的時候，在哲學堂發現一張遺失的 Suica 卡 (學生用)，第一次去了星乃咖啡店，凌晨徒步走了三個小時吧，聽著鹿乃的歌從黎明走到天亮吧。\n都是很失敗又傷心的經歷呢。\n第三季 七月的時候買了鹿乃的專輯，買了初音的模型公仔，半夜自己去 KTV 唱歌被安排了可以容納八個人的大包廂，躺在沙發上唱著《僕が死のうと思ったのは》，第一次逛新宿御苑、躺在草地上感受，然後參加面試，雖然失敗了。\n八月份的時候，調整我的桌面，半夜去公園盪鞦韆散心。\n九月的時候買了腳踏車，再次迷上了經典遊戲《紅色警戒 2》，把自己的家稍微整理了一下，月底傍晚閒逛的時候參加了井草八幡宮的一個祭典吧。\n這三個月，很短吧，這也是我不知道該不該寫的原因，從六月的時候，就變了呢，凌晨走三小時，半夜去公園盪鞦韆，深夜騎腳踏車，這些行為的背後，是身心崩潰，瀕臨死亡、刻骨銘心的經歷，說實話我不知道該從什麼地方寫起，照著時間軸，我的記憶有點模糊，照感受，那是一種\u0026quot;この世のすべての醜さを受けられる\u0026quot;的感覺，我不想寫得太完整，就從我和 ChatGPT 凌亂的對話中整理出典型的時間軸吧（最嚴重的一週，我使用 ChatGPT 長達 50 小時，而且這還只是手機的使用時間），其中部分內容隱去，部分內容太混亂了，我也不知道原貌是什麼了。\n我考慮了一下，還是單獨寫出來好了，有點過於黑暗了，我放在「心理淬鍊」裡。\n第四季 十月的時候，我去參加了第 404 回的多益考試，雖然結果很爛，但是我當時腳踏車停在 255 號，情緒價值還是很足夠的，之後我衝動下單了一個 N5095 主機板，然後 DIY 了一台 NAS，雖然錄製了影片，但是我好像沒什麼動力剪輯，同時參觀了 Sony 的總部，也到他們的商店買了 INZONE H9 II，月底的時候去井之頭公園體驗了手動划船，同時購入了 しぐれうい 的第二張專輯。\n十一月的時候再次面試失敗，但是藉此從朋友那邊知道了一間感覺不錯的學校，去泡了溫泉，雖然泡暈了，在那裡睡了不知道多久，吃了美式披薩。\n十二月的時候我幾乎都在準備面試了，這條時間軸只能說，累到虛脫，下面改編自我發給朋友的訊息：\n12 月 1 日申請時得知需要聯絡教授詢問考試內容。 12 月 2 日要我寫研究計畫書加 PPT。 大概五天寫好後，問我要投什麼期刊，把研究計畫書壓縮到兩頁 PPT，我試著照做了，然後給我修改意見，我又拚命趕了一天給回覆。 大概是 12 月 11 日了吧，我準備面試了，參考往年資料是 10 分鐘，而且教授說演講 2-3 分鐘，剩下時間提問。 結果 12 月 12 日寄信給我說面試時間 30 分鐘左右。 我先是受到巨大心理衝擊，因為壓力太大了點吧，休息了兩天從 12 月 15 日開始準備。 12 月 17 日那天，我被以質問的語氣搞到心態崩潰，當時我高度緊張地準備面試。 12 月 18 日面試，因為一般面試是 3-4 位教授，但我一進門，教室裡有很多教授，目測 10 人以上，面試了我 40 分鐘。 走出考場我整個人都不對勁了，當時到最後都快讓我腿軟了。\n考完之後，直到現在，我都是精神低迷地躺在床上，不過結果什麼的都無所謂了，我覺得這段經歷還蠻有價值的，非母語的情況下，在 40 分鐘內和 10 多位教授討論學術，這簡直是太酷了！\n12 月 25 日我去吃了 chawan 耶，Merry Christmas!\n心理淬鍊 說實話這部分我沒寫出來，有我不知道怎麼寫，也有我不想回憶那些痛苦回憶的原因吧。\n1-3 月的正常狀態下，事實上包含著對邏輯的絕對遵循，不僅外顯於我的生活，還表現於我的夢境。\n4-6 月的經歷，慢慢就透露出我在維持這種狀態下的異常，因為絕對的理性，導致了我會陷入死結，諷刺的是，我自己都不符合邏輯了。\n7-9 月，這是邏輯矛盾的爆發與我的宣洩，多次的凌晨行走，夜間騎腳踏車，此時的我彷彿是在宣洩式修復吧。這之間，我用一些時間軸事件來填充吧：\n2025-07-19 由於心理的堵塞，過度思考，從精神的混亂影響到了肉體，頭痛且極度難受，身體也是處於無力狀態，我不知道該怎麼描述這種難受。於是我只好躺在床上，身體冷就蓋著被子，但是卻流著汗，精神難受就想著睡覺，但一睡覺就是做噩夢，醒來身體難受，睡著精神難受，就這樣循環著不知道多少次，汗水沾濕了被褥，淚水浸濕了枕頭。這一段太難受了，容我不再回憶、簡短帶過，我感覺這彷彿像是在渡劫一般，總之就是一種醒來和睡著都不能安寧的狀態。\n2025-07-20 凌晨的時候，我被夢驚醒，夢的內容是我走入一間詭異的商店，周圍一切都很詭異，無論是商品還是店裡的人 (我不知道該如何描述，哪怕是現在我回想起來也會覺得很害怕，有種不敢寫下去的感覺)，此時我的手機突然響了，還是關不掉、聲音很大的那種，不知道為什麼我夢裡覺得是因為沒電了，於是找在我包裡的行動電源，可是我的包為什麼是放在商店的入口呢，周圍的人注視著我，我懷著驚恐的心情趕緊給手機充電然後離開，去到旁邊的我家，但是感覺廢棄很久了，躺在床上，姿勢大概是《タコピーの原罪》那種感覺，這是夢裡我躺下的時候想到的，但我清醒的時候感覺是蜷縮著。\n然後我就這樣醒來了，但不是直接醒來，是腦部先醒來，只有腦部的意識，然後有很多暖流，像是神經傳導物質 (乙酰膽鹼、血清素) 釋放一樣，從腦部流向身體，慢慢地我恢復感知，先是身體的感知，這時候我感覺有人在死命抱著我，我掙脫不了，我當時感覺很害怕，但是慢慢當我恢復四肢的感知的時候，才知道那是我自己在抱著我自己，我瞬間有種房間有人的恐懼感。\n下午的時候我想著去附近的公園接觸陽光放鬆一下吧，但在去公園的路上，有一瞬間，彷彿我已經死了，失去意識，但下一瞬，馬上又回來了，這是一瞬間的事情，然後我拖著極其難受的身軀，躺在公園的椅子上，聽著 鹿乃 的歌，大概兩三個小時感覺恢復一點後，我就回家了。但是到家後症狀在慢慢嚴重，我的身體感覺很冷，明明是夏天的東京，我裹著被子，但是還是覺得冷，同時身體動不了，靠著牆邊，就那樣一直待著。\n在恢復了一點、肚子餓的時候，我是靠著牆做飯的，而且中間是實在太難受了，回床上休息了三次才把那頓飯做完。之後洗澡的時候為了防止自己暈倒，是開著門，坐著洗的。\n2025-07-21 我可能一覺睡到了下午，前段時間一直躺著，家裡已經沒什麼東西了，於是我去超市採買物資，但是當時在超市的時候我有一瞬間感覺是想暈倒，不過當時 ChatGPT 很擔心我的情況下，我確實想出了一句現在的我讀了都覺得窒息的話：\n昨天感覺自己快要死了，今天只是想要暈倒，說明好轉了不是嗎\n然後是晚餐，朋友給我發了紅包讓我可以吃好一點的，真的很感謝耶。\n之後 之後的幾天，我幾乎都是一種在外維持樂觀的心態，但是回到家就是精神力氣盡失般躺在床上。我的聲音也透露著一種彷彿下一秒就要死了的感覺，我的身體也彷彿下一秒就要倒下。\n然後我也不知道了，印象中在聽 Lifeline 這首純音樂的時候，當時隨機播放到的時候我特別害怕，馬上就下載下來，我當時感覺自己的心跳和音樂重合了，萬一網路卡住音樂緩衝，我的心跳也就暫停了。\n中途 就在某天我夢到自己在國中被校園霸凌，平時一直受欺負，但是我嘗試講道理，嘗試聯絡老師、父母都無結果，在夢境的最後，我在上廁所的時候，我的書包被拉扯，拉鍊被拉開，所有的東西被粗暴地倒在廁所裡，因為是住宿制學校，我的書包裡有衣服和書耶，然後我在那裡很害怕，忘了有沒有被打。但是半夢半醒之間，我有一定的意識後，我開始想到那句話：「如果沒有人來保護我的權利，那麼槍就是我最後的權利」，我的意識先是發問「還要這樣對我嗎」，得到的是藐視後，我選擇開槍射擊腿部讓對方失去行動能力，然後逃走。\n在這段時間，我備受折磨，對理性的遵守有時候凌駕於自己的人權之上，在高壓下，我爆發了，這個夢就是爆發的出口，不過我當時的想法也只是「我要捍衛我的生命健康權」，捍衛我的基本人權，打破了原有邏輯，以「生命健康權」為基礎，其他的權利都要靠後。\n2025-08-12 與 2025-08-13 這兩天是很離奇的夢境，因為記憶有點混亂又有點關聯，我就放在一起了。我在「現實」生活著卻感到邏輯不對，於是想到可能是做夢，但想要醒來卻被困在夢裡，但是那個夢不對勁，我也知道了我在夢裡，可是我想醒來，於是尋找破局之法，過程有點忘了，但是我在夢中人物的對話有邏輯漏洞的前提下找到了離開之法。然後我「醒來」了，其實還是一層夢，這裡我再次從邏輯上感覺不對而「醒來」。沒錯，又是一層夢，但是這個夢只有我的房間和我自己，我找不到邏輯漏洞，於是我拚命睜眼，像是 SAO 裡試圖拔掉自己現實世界頭盔一樣，我嘗試睜開我現實中的眼睛。然後我「醒了」，對，還是一層夢，但是這個夢很真，可我還是一眼發現不對勁了，我很生氣，生氣夢在和我開玩笑，我再次拚命睜眼，睜開我現實的眼睛，彷彿眼睛都要撕裂了，這次我真的醒來了。\n具體細節我真的記不太清楚了，但是大概是這樣的過程，夢想要困住我，給我一個美好的幻想，讓我沉淪，但是我覺得我應該打破它，我在捍衛我的權利，這可能就是此過程的一個體現吧。\n還有一些離奇的夢境，但是正如我上面寫的，不太想回憶了，每個夢境幾乎都包含了鬥爭、痛苦，哪怕是現在回想也會帶入當時的脆弱心態，所以，就這樣吧。\n10-12 月我遇到了很好的朋友，一步步走出這段陰影，真的很感謝所有對我有幫助的人，正如《僕が死のうと思ったのは》的歌詞一樣：\n僕が死のうと思ったのは　あなたが綺麗に笑うから 死ぬことばかり考えてしまうのは　きっと生きる事に真面目すぎるから 僕が死のうと思ったのは　まだあなたに出会ってなかったから あなたのような人が生まれた　世界を少し好きになったよ あなたのような人が生きてる　世界に少し期待するよ\n不管之後如何，至少當下，都是我生命黑暗中的那道光。\n現況 與 2024 年我最後說的並不同，可能當時只是一個偽裝，一個基於「這麼做合乎邏輯」的偽裝正常人，但是現在的我，好像可以試著擺脫那個邏輯的束縛，真的去眼睛發光，由內向外地散發能量，而不是基於邏輯的強顏歡笑。\n當然我並沒有改變太多，我還是遵守著規則，只是這次，它比較靈活，或者說核心是愛的定義，「首先自愛，然後溢出來的能量去滋養他人」，這也是一種之前看 warma 影片時提到「你的事情，你的感受永遠是第一優先」的感覺吧。\n如果你也在迷茫，並且讀到這裡，請先試著愛自己吧，然後才能有能量去愛這個世界。\n最後 這篇文章說實話我也不知道該寫些什麼，想偏向成長吧，感覺太黑暗了，中間寫到自己有點過於恐懼，想偏向歡樂吧，我的真實經歷無法讓我掩蓋那段刻骨銘心的歷程。\n就這樣吧，人生並非盡是完美，60 分的答卷就已經合格了，如果你真的看完了，我希望你不會被負面情緒困擾 (雖然我很克制了)，因為正如我要捍衛我的生命健康權一樣，自愛，自己的快樂永遠是第一優先。\n","date":"2025-12-31T16:16:44+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/263/","title":"2025 年度總結"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 在 Windows 環境下執行一個 bash 腳本顯然難度稍大，在 Linux 環境下，執行另一個發行版本的特化腳本顯然也有點麻煩。利用 Docker 可以協助處理這個問題，同時還可以保護本地環境的純淨。\n本文以 alpine 為例，列出如何使用 Docker 的 Linux 系統完成目前目錄的互動處理。\n原理 事實上也就是透過掛載將目前目錄的所有檔案掛載到容器的一個目錄，指令範本為：\n1 docker run --rm -it -v \u0026#34;$(pwd)\u0026#34;:/data -w /data alpine sh 其中的參數含義如下：\n參數 意義 \u0026ndash;rm 容器退出後刪除 -it 表示 interactive 和 tty 輸出的組合，互動與看到輸出 -v 對應路徑，參數表示將目前目錄對應到容器的 /data -w 設定工作路徑，這樣進入容器後就在 /data sh 最後的 sh 表示執行 sh 指令 同時如果只是想要執行單次指令，不需要互動輸出，在最後輸入指令即可，例如：\n1 docker run --rm -v \u0026#34;$(pwd)\u0026#34;:/data -w /data alpine ls -la Windows 在 PowerShell 和 CMD 環境下指令不同，主要區別在於環境變數，以下是開啟 alpine 互動終端的指令：\nPowerShell 1 docker run --rm -it -v ${PWD}:/data -w /data alpine sh CMD 1 docker run --rm -it -v %cd%:/data -w /data alpine sh Linux 在 Linux 上，因為進入容器預設使用 root 權限，為防止容器中產生的檔案在宿主機是 root 權限導致無法修改，最好對應目前使用者的 UID 與 GID：\n1 docker run --rm -it -u $(id -u):$(id -g) -v \u0026#34;$(pwd)\u0026#34;:/data -w /data alpine sh MacOS 不需要處理權限問題，變數同 Linux：\n1 docker run --rm -it -v \u0026#34;$(pwd)\u0026#34;:/data -w /data alpine sh 注意事項 - Alpine 因為 alpine 是非常精簡的系統，所以可能需要自行安裝一些常用的指令，請使用 apk add 指令進行安裝。\n","date":"2025-12-26T18:43:04+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/262/","title":"利用 Docker 建立臨時 Linux 互動環境"},{"content":" 📢 本文由 Gemini-2.5-pro 翻譯 引言 早在 2022 年我折騰 Linux 的時候(簡體中文) ，當時就提到了搞 NAS 不一定得為系統買單。\n如今在伺服器的折騰中，雲端硬碟掛載的速度實在不盡人意，在衝動下，我下單了 N5095 主機板。考量到我手頭上的 4G 記憶體有點低，但又不是很想再徒增花費，於是我再次開啟了我的折騰之旅。\n技術選型 首先是系統，在這個低配置下，那當然是使用最輕量的 Alpine Linux 了。\n然後是如何安裝，為了和 WEPE 相容，使用 Ventoy 做主引導來安裝系統。\n服務的部署使用 Docker 來保證主機的乾淨以及可重現性。\n使用的服務如下：\n影音: Emby 漫畫: Komga 音樂: Navidrome 音聲: Kikoeru 共享: Samba 統一入口: Heimdall 考慮過但未使用的服務如下：\n影音: Jellyfin 漫畫/小說: Kavita 雲端掛載: CloudDrive 檔案架構 對於各個服務的位置，使用我一貫的風格，每個服務一個資料夾，放在 /home 下。\n對於 HDD 全部掛載在 /mnt 下，這是比較常見的掛載方式。\n透過 mount \u0026ndash;bind 綁定掛載以實現將 HDD 上對應的檔案掛載到對應服務的位置。\n系統安裝 在 官網下載 Alpine Linux 後放入安裝了 Ventoy 的隨身碟中，在主機板 BIOS 設定從隨身碟開始引導，進入 Ventoy 後，選擇 Alpine Linux 並進行引導進入系統。\n等待載入完成後，登入使用者 root，不用輸入密碼，登入完成後輸入安裝指令：\n1 setup-alpine 然後根據引導設定完成安裝即可。\n官方文件: setup-alpine - Alpine Linux 公鑰登入 編輯 NAS 相關設定檔 ~/.ssh/authorized_keys，首先建立設定資料夾：\n1 mkdir .ssh 進入資料夾：\n1 cd .ssh 加入自己的公鑰：\n1 vi authorized_keys （自己的公鑰在 %USERPROFILE%\\.ssh）\n開啟公鑰登入：\n1 vi /etc/ssh/sshd_config 在第 41 行，將註解取消變為：\n1 PubkeyAuthentication yes 開啟社群源 開啟軟體庫檔案：\n1 vi /etc/apk/repositories 把註解刪掉變為：\n1 2 3 #/media/dm-0/apks http://dl-cdn.alpinelinux.org/alpine/v3.22/main http://dl-cdn.alpinelinux.org/alpine/v3.22/community 安裝 Docker 更新軟體：\n1 apk update 安裝 Docker：\n1 apk add docker docker-cli-compose 設定開機啟動：\n1 rc-update add docker default 啟動 Docker：\n1 service docker start 查看是否啟動：\n1 docker ps 新增 swap 因為伺服器的映像檔預設沒 swap，我就新增了，但是之後發現預設是有新增的，可以根據需要選擇是否新增。\n新增交換空間檔案：\n1 fallocate -l 8G /swapfile 設定權限為只能 root 存取：\n1 chmod 600 /swapfile 格式化 swap：\n1 mkswap /swapfile 啟用 swap：\n1 swapon /swapfile 查看是否生效：\n1 free -h 掛載硬碟 查看所有區塊裝置：\n1 fdisk -l 安裝 ntfs 支援：\n1 apk add ntfs-3g 建立掛載資料夾：\n1 mkdir /mnt/hc550 掛載：\n1 mount -t ntfs-3g /dev/sdc1 /mnt/hc550 卸載有兩種方法，透過路徑 (推薦)：\n1 umount /mnt/hc550 或者透過裝置：\n1 umount /dev/sdc1 自動掛載 獲取分割區 ID，避免重啟後裝置名稱變更：\n1 blkid 編輯 /etc/fstab：\n1 vi /etc/fstab 新增設定：\n1 2 # \u0026lt;設備UUID\u0026gt; \u0026lt;掛載點\u0026gt; \u0026lt;檔案系統\u0026gt; \u0026lt;選項\u0026gt; \u0026lt;dump\u0026gt; \u0026lt;pass\u0026gt; UUID=xxxxxxxx /mnt/hc550 ntfs-3g defaults,uid=1000,gid=1000 0 0 測試是否成功，先卸載：\n1 umount /dev/sdc1 掛載全部，會自動查找設定：\n1 mount -a 檢測是否成功：\n1 ls /mnt/hc550 SMB 共享 使用 Samba 共享可以將硬碟掛載到 Windows，就像操作本機硬碟一樣操作檔案。\n在 /home/samba 建立 docker 設定檔 docker-compose.yml：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 version: \u0026#39;3.1\u0026#39; services: samba: image: \u0026#39;ghcr.io/crazy-max/samba:latest\u0026#39; container_name: samba network_mode: host volumes: - \u0026#39;/home/samba/data:/data\u0026#39; - \u0026#39;/mnt/hdd4t:/mount/hdd4t\u0026#39; - \u0026#39;/mnt/hc550:/mount/hc550\u0026#39; environment: - \u0026#39;TZ=Japan/Tokyo\u0026#39; - \u0026#39;SAMBA_LOG_LEVEL=0\u0026#39; restart: always 編輯軟體設定檔 config.yml：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 auth: - user: yexca group: yexca uid: 1000 gid: 1000 password: passwd global: - \u0026#34;force user = yexca\u0026#34; - \u0026#34;force group = yexca\u0026#34; share: - name: HDD4TB comment: hdd4t path: /mount/hdd4t browsable: yes readonly: no guestok: no veto: no validusers: yexca writelist: yexca recycle: yes - name: HC550 comment: hc550 path: /mount/hc550 browsable: yes readonly: no guestok: no veto: no validusers: yexca writelist: yexca recycle: yes Windows 掛載為網路磁碟機\n按 Win + R 開啟 cmd，輸入指令：\n1 net use Z: \\\\alpine-nas\\HDD4TB /user:yexca passwd /persistent:yes 刷新檔案總管：\n1 explorer.exe Z: 或者也可以透過檔案總管的圖形介面新增。\n綁定掛載 相較於軟連結 (Symbolic Link)，綁定掛載 (Bind Mount) 可以相容 docker。\n1 mount --bind /mnt/hc550/anime /anime 開機自動綁定掛載需要寫入 /etc/fstab，必須在（硬碟）掛載設定的下方 (因為檔案依序執行)：\n1 2 /mnt/hc550/anime /tmp/anime none bind 0 0 /mnt/hc550/comic /tmp/comic none bind 0 0 驗證：\n1 df -h 其他服務 對於其他服務，我之前的文章感覺已經寫過不少了，不再贅述。\n相關文章(簡體中文)：\n2025-10-05: 漫畫與音聲網站折騰 2023-05-02: 搭建個人音樂網站 2022-09-16: 個人內網折騰 2022-09-14: Fedora 安裝 Komga 折騰記錄 自訂網域 這裡使用 OpenWRT 路由器的 DNS 攔截實現存取特定網域，從而進入自己 NAS 服務。\n要求是裝置的 DNS 伺服器是路由器，然後在路由器的 DHCP/DNS 設定裡為 NAS 分配靜態 IP，再新增挾持網域，都指向 NAS 的 IP 位址。\nNginx-UI 為了讓自訂網域生效，需要使用 Nginx 反向代理 NAS 上的服務。\nDocker Compose 設定檔：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 version: \u0026#39;3.1\u0026#39; services: nginx-ui: image: uozi/nginx-ui:v2.2.0-patch.1 container_name: nginx_UI volumes: - /home/nginxUI/nginx:/etc/nginx - /home/nginxUI/nginx-ui:/etc/nginx-ui - /home/nginxUI/www:/www environment: - NGINX_UI_IGNORE_DOCKER_SOCKET=true ports: - 80:80 - 443:443 restart: always 容器存取另一個容器的橋接 IP 為 172.17.0.1。\n假如有一個服務是映射到主機的 8888 埠，新增反向代理時候，代理的位址不是 127.0.0.1:8888 而是 172.17.0.1:8888。\n關於為什麼設定環境變數，請參見： 2025 新伺服器部署記錄#安裝-nginx-ui(簡體中文) 結語 我感覺也算是實現了 2022 年的我說的那些話吧。\n同時感覺短短三年的時間，雖然我主觀上是覺得自己沒有什麼變化的，可是在閱讀自己以前的文章時，回憶當時寫下那些文字的處境，確確實實感受到了自己的思考方式發生了天翻地覆的變化。\n當時的我说實話好像是想著使用 True NAS 之類的特製化系統，但是沒想到我真的實現的時候，使用了以前的我想都不敢想的從零開始，一點點看著自己之前的文章，組成這段，可以說真切感受到了「價值」。\n折騰不息，熱愛不止。\n","date":"2025-11-13T17:57:29+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/261/","title":"你的下一台 NAS，何必是 NAS"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 音有所感系列 歌曲名稱 翻譯 連結 僕が死のうと思ったのは 曾經我也想過一了百了 https://blog.yexca.net/archives/214 あくあ色ぱれっと aqua 的調色盤 https://blog.yexca.net/archives/219 恋の押し売り 戀愛推銷 https://blog.yexca.net/archives/220 17さいのうた 17 歲的歌 https://blog.yexca.net/archives/224 drop 墜入愛河 https://blog.yexca.net/archives/230 生きるを選んだ私へ 致選擇活下去的自己 https://blog.yexca.net/archives/239 rainy lady 雨意未晴 https://blog.yexca.net/archives/249 恋しくなったら手を叩こう 如果想談戀愛的話就拍拍手吧 https://blog.yexca.net/archives/250 pris-magic! 稜鏡魔法! 本文 前言 之前買了 しぐれうい 的第一張實體專輯「まだ雨はやまない」，但實際上幾乎都只聽《rainy lady》。上週偶然發現第二張專輯「fiction」的初次限定盤，就順手買下來了。在瀏覽裡面的歌曲時，順勢聽了一下之前的「まだ雨はやまない」，才發現竟然錯過了一首這麼好聽的歌啊！\n這首歌原本聽了一遍後，覺得沒什麼特別的。但是前兩天突然有個旋律一直在腦海裡重複循環，我想著那是 しぐれうい 的歌聲，但聽「fiction」總覺得不對味，雖然有相似的曲調卻找不到。於是我就擴大範圍，聽到了這首歌，就是這種熟悉的感覺！\n說到這首歌，它本身的節奏很不錯，主要是突然冒出的那一句「君は私の太陽」，瞬間讓人心情愉悅起來啊，特別是在有點小鬱悶的時候。不過同時，其實 ユイカ 的《おくすり》也算是類似的感覺吧，儘管後者可能更輕快一些。\n在翻譯的時候，我原本沒想到標題要怎麼處理比較好，看到一半就覺得有這種色彩繽紛的感覺。同時「pris」這個字讓我想到了 \u0026ldquo;prison\u0026rdquo; (監獄) 和 \u0026ldquo;prism\u0026rdquo; (稜鏡) 這兩個字，綜合下來~~(感覺 \u0026ldquo;監獄魔法\u0026rdquo; 顯然不可能吧)~~，我選擇了後者，感覺更可愛一些。\n最後是，不知道是 しぐれうい 喜歡雨，還是為了讓專輯有連貫性？感覺這張專輯可以整個串聯起來不是嗎？首先名字「まだ雨はやまない」表示「雨還沒停」，歌曲《rainy lady》稱自己是「雨季女士」，而最後的《pris-magic!》歌詞裡的「君は私の太陽」則表明「你就是我的太陽」照耀著我。這樣串起來就是「我的心情和雨一樣憂鬱，但你的出現照耀了我，讓我心情愉悅」(雖然第二張專輯「fiction」的封面又是下雨的樣子)\n我也很喜歡雨啊，當作白噪音聽起來讓人很安心呢～\n歌曲影片 歌詞 水窪裡倒映著光芒\n鮮豔的景色\n如果你笑了，你看\n雨後天晴，彩虹高掛\n(1、2 預—備！)\n(雨聲淅瀝，陰霾天空\nPatter shiny smile\n笑容明麗，閃爍眼瞳\nThere might be a rainbow in the sky\n天際也許正有彩虹\nJust like solar ray\n就像太陽光線\nPass through prism\n穿過稜鏡\n染上七彩炫光)\n眺望著褪色的天空\n即使在有點憂鬱的日子裡\n如果能聽到你的聲音\n彷彿有什麼要開始了\n(陰雨天) 像要下雨的樣子\n(陰雨天) 像繡球花一樣\n在藍色的心裡\n(晴空萬里) 如光芒照耀般\n(晴空萬里) 像向日葵一樣\n每天都被鮮豔地重新粉刷\n稜鏡魔法！迸發色彩\n在雨中的街道 (在雨中的街道) 彩虹高掛 (oh yeah)\n像太陽一樣閃耀的\n你如此耀眼\n稜鏡魔法！迸發色彩\n不撐傘 (不撐傘) 你卻笑著 (oh yeah)\n一句「來吧，走吧」 (oh)\n世界就此染上七彩\n你就是我的太陽～\n(雨聲淅瀝，陰霾天空\n笑容明麗，閃爍眼瞳\nThere might be a rainbow in the sky\n天際也許正有彩虹\nJust like solar ray\n就像太陽光線\nPass through prism\n穿過稜鏡\n染上七彩炫光)\n在綿延不絕的雨聲中\n獨自描繪的夢想\n明朗重疊的色彩啊\n是你教會我的\n(陰雨天) 像是穿透一般\n(陰雨天) 像雨滴一般\n將透明的我\n(閃亮微笑) 像是握住我的手般\n(閃亮微笑) 像穿透樹葉的光線般\n你閃耀著光芒照亮了我\n稜鏡魔法！迸發色彩\n在雨中的街道 (在雨中的街道) 彩虹高掛 (oh yeah)\n驚嘆著「好美啊」 (hoo)\n你是如此溫柔\n稜鏡魔法！迸發色彩\n兩個人 (兩個人) 走過彩虹橋 (oh yeah)\n來吧，走吧，手牽著手 (hoo)\n朝著染上七彩的未來 (hoo)\n奔向雨中\n像寶石般閃耀\n一個又一個\n實現我們的夢想吧\n比這世界上任何人都\n獻給我最喜歡的你\n我會一直陪在你身邊喔\n謝謝我們能相遇\n稜鏡魔法！迸發色彩\n在雨中的街道 (在雨中的街道) 彩虹高掛 (oh yeah)\n陽光燦爛地灑落\n色彩繽紛地滿溢而出\n稜鏡魔法！迸發色彩\n不撐傘 (不撐傘) 兩人笑著 (oh yeah)\n來吧，走吧，向更遠的地方\n世界就此染上七彩\n你就是我的太陽～\n(雨聲淅瀝，陰霾天空\n笑容明麗，閃爍眼瞳\nThere might be a rainbow in the sky\n天際也許正有彩虹\nJust like solar ray\n就像太陽光線\nPass through prism\n穿過稜鏡\n染上七彩炫光)\n","date":"2025-11-01T14:30:01+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/260/","title":"音樂有感 - 《pris-magic!》"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 前言 Google 的 Gemini Pro 訂閱附帶 2TiB 的空間，這又讓我想到了折騰，那就說做就做吧\n不過再一看， 之前的折騰 已經過去三年了啊，時間過得確實有點快耶\n漫畫 Komga 首先是看漫畫的 Komga，雖然掃描的時候卡卡的，但使用體驗其實還不錯吧\n時隔多年，Komga 更新了不少， 之前的文章 已經無法重複使用，同時使用 docker-compose 更加方便，docker-compose.yml 如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 version: \u0026#39;3.0\u0026#39; services: komga: image: gotson/komga:1.23.4 container_name: komga volumes: - type: bind source: /home/komga/config target: /config - type: bind source: /home/rclone/data target: /data ports: - 25600:25600 restart: unless-stopped 另外有 專屬的 iOS 軟體 Komic 確實挺方便的\nrclone 掛載 Google Drive 和 微軟 OneDrive 類似，需要先在 Windows 平台瀏覽器認證取得 Token\n具體流程就是下載好後執行指令\n1 rclone config 命名後選擇 Google Drive (22) 後，給予 Full access all files, excluding Application Data Folder 權限，再按 Enter 鍵跳出瀏覽器登入，完成後退出即可\n不過前期我不是很懂，申請了軟體 ID 與 Secret，好像沒什麼用，但記錄下來說不定之後可以用到\nGoogle 申請應用程式 API ID 與 Secret 開啟 Google API 服務網站: https://console.developers.google.com/ 選擇 Enable APIs and services 搜尋並啟用 Google Drive API\n在 Google Drive API 的 Manage 中 Create credentials\nAPI 的類型選擇 User data 也就是說明包含 OAuth 的\n在 OAuth Client ID 中類型選擇 Web application，名稱可輸入 rclone，完成後會出現 Client ID\n然後完成建立，在 Credentials 選擇剛才建立的應用程式 rclone 進入複製金鑰 Client secrets\n接著把設定檔複製到伺服器，本地目錄在\n1 C:\\Users\\%USERNAME%\\AppData\\Roaming\\rclone 伺服器下載 fuse，我的伺服器是 CentOS7，所以下載了這些\n1 sudo yum install -y fuse fuse3 fuse-libs 較新的系統直接下載 fuse3 就行，接著用 docker 掛載\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 sudo docker run --rm \\ --volume /home/opc/rclone/config:/config/rclone \\ --volume /home/opc/rclone/data:/data:shared \\ --volume /etc/passwd:/etc/passwd:ro --volume /etc/group:/etc/group:ro \\ --device /dev/fuse --cap-add SYS_ADMIN --security-opt apparmor:unconfined \\ rclone/rclone \\ mount GoogleDrive:/ /data \\ --no-checksum \\ --use-server-modtime \\ --no-gzip-encoding \\ --no-update-modtime \\ --no-seek \\ --modify-window 2m \\ --allow-other \\ --allow-non-empty \\ --dir-cache-time 30m \\ --cache-read-retries 15 \\ --cache-db-purge \\ --timeout 30m \\ --vfs-cache-mode full \\ --vfs-read-chunk-size 2M \\ --vfs-read-chunk-size-limit 5M \\ --vfs-cache-max-age 30m \\ --attr-timeout 20s \\ --poll-interval 9m \\ --vfs-cache-poll-interval 10m\u0026amp; 後面那一堆的設定參考 Komga 官方提供 ，具體含義為\n參數 作用 說明 --no-checksum 跳過校驗和 減少 API 呼叫，加快目錄載入速度。適合影片等大型檔案。 --use-server-modtime 使用伺服器的檔案修改時間 避免本地與遠端時間差導致重複上傳/同步。 --no-gzip-encoding 停用 GZIP 編碼 某些雲端（如 Drive）回應壓縮後效能不佳，此項目可降低 CPU 佔用率。 --no-update-modtime 不更新檔案修改時間 唯讀用途下防止 Drive 因時間變動觸發版本更新。 --no-seek 停用隨機讀取 減少對影片拖曳操作的支援，但會提高循序讀取的穩定性。適合連續播放情境。 --modify-window 2m 檔案修改時間誤差容忍範圍 防止本地/遠端時間差引起誤判。 --allow-other 允許系統內其他使用者存取掛載內容 必須系統設定 /etc/fuse.conf 裡允許。 --allow-non-empty 掛載非空目錄 若掛載點非空也可繼續掛載。 --dir-cache-time 30m 目錄快取時間 減少頻繁請求雲端 API，預設適中。 --cache-read-retries 15 快取讀取失敗時重試次數 提高穩定性。 --cache-db-purge 每次啟動清空快取資料庫 防止舊快取損壞導致錯誤。適合長時間開關掛載的環境。 --timeout 30m 單次傳輸逾時上限 長影片或大型檔案讀取時防止斷線。 --vfs-cache-mode full 完整快取模式 讀取寫入都透過本地快取。效能最平衡、最安全。 --vfs-read-chunk-size 2M 每次下載區塊大小 越小越節省頻寬，但越頻繁。此設定適合低頻寬環境。 --vfs-read-chunk-size-limit 5M 最大區塊大小限制 限制增長幅度，防止一次請求太大導致逾時。 --vfs-cache-max-age 30m 快取檔案最大存活時間 比較短的時間，適合節省空間。 --attr-timeout 20s 檔案屬性快取時間 防止頻繁 stat() 呼叫；20s 為折衷值。 --poll-interval 9m 雲端變更輪詢間隔 9 分鐘檢查一次變動，減輕 Google API 負擔。 --vfs-cache-poll-interval 10m 本地快取清理間隔 每 10 分鐘清理一次過期快取。 Alpine Linux 的使用 因為佔用過高，所以我想到了極其輕量化的 Alpine\nDocker 安裝 首先更新軟體\n1 doas apk update 安裝 Docker\n1 doas apk add docker docker-cli-compose 設定開機啟動\n1 rc-update add docker default 啟動 Docker，可能需要等一下\n1 doas service docker start 新增自己到 Docker 使用者群組\n1 doas addgroup ${USER} docker 參考文章\nhttps://wiki.alpinelinux.org/wiki/Docker swap 建立 首先新增交換空間\n1 doas fallocate -l 8G /swapfile 設定權限只能 root 存取\n1 doas chmod 600 /swapfile 格式化 swap\n1 doas mkswap /swapfile 啟用 swap\n1 doas swapon /swapfile 然後可以檢視是否生效\n1 free -h rclone 設定 因為過於輕量化，所以需要一些額外設定\n首先安裝 fuse\n1 doas apk add fuse 掛載裝置\n1 doas modprobe fuse 然後需要修改根目錄為 share 類型\n1 doas mount --make-rshared / 之後就和 CentOS7 類似了\n參考文章\nHow to Install Rclone on Alpine Linux Latest Alpine Linux Wiki Rclone Kikoeru 剛開始走了一點彎路，最後也失敗了，就記錄一下吧\n一整個下午的失敗 TT 我循著經典的 kikoeru project 的 fork 尋找最新提交的一個，雖然找到了 XunJiJiang/kikoeru-express ，但我嘗試建構映像檔試了一整個下午，從 node.js 12 試到 16，各種錯誤，換映像檔來源等方法都試過了，然後想著單獨部署也都是建構失敗，試著不使用 Docker 建構也失敗，到最後我真的妥協了，用經典的 0.6.2 吧\n哇，我真的，推薦 node.js 版本 12-14，但是實際建構的時候，執行到某個步驟，提示是 16 以上的特性，我直接用 14 以上 npm i 會報錯，只好用 13 版本先安裝依賴，完成後再複製過來，用 16 版本建構，沒想到這樣折騰了一整個下午，不過說實話，這讓我學會熟練切換 node.js 版本了，真是 XD\n我之前下載的一個 iOS 軟體，便開啟試著連線異常，檢視更新紀錄，提示使用 0.6.14 版本以上，我大受震撼，緊接著搜尋到我已經 star 的 Number178/kikoeru-express 😂\n使用在更新的 Number178/kikoeru-express ，同時該作者還開發了 iOS 軟體，非常方便\n設定檔\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 version: \u0026#39;3.0\u0026#39; services: kikoeru: ports: - \u0026#39;8011:8888\u0026#39; container_name: kikoeru volumes: - type: bind source: /home/rclone/data/asmr target: /usr/src/kikoeru/VoiceWork - /home/kikoeru/sqlite:/usr/src/kikoeru/sqlite - /home/kikoeru/covers:/usr/src/kikoeru/covers - /home/kikoeru/config:/usr/src/kikoeru/config image: \u0026#39;number17/kikoeru:v0.6.14-20250914\u0026#39; restart: always 然後就是，標籤的語言是不能切換的，預設是簡中，如果需要日語的話，需要在掃描前就切換\n","date":"2025-10-05T01:58:35+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/258/","title":"漫畫與音訊網站折騰"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 引言 正好伺服器快到期，去年雖然續約了一年，但今年看到各種優惠突然覺得續約有點小貴，在看了許多小型伺服器廠商後，看到阿里巴巴雲有 12 個月內無帳單則可享有優惠，那既然都看到大廠了，順勢就想到了 Oracle\n那就試試看吧，全套真實資料，居然直接就申請成功了，可喜可賀\n不過突然又想到 上次折騰伺服器 還是 2023 年啊，一晃兩年過去了，時間過得真快啊\nOracle Linux 建立映像檔的時候發現沒有我喜歡用的 Debian，那就試著看看這個 Oracle Linux，結果這玩意兒啊，首先預裝 MySQL 就算了 (習慣用 Docker 多少有點主機潔癖 XD)，佔用還好大，對免費的 1C1G 來說直接卡住了，只好換其他映像檔了\nOracle Linux 使用紀錄 首先升級，看到 dnf 指令還讓我想起之前使用 Fedora 的日子啊\n1 sudo dnf update -y 然後發現升級列表有 MySQL，伺服器卡死了，準備解除安裝，先查看 MySQL 服務是否正在執行\n1 sudo systemctl status mysqld 服務正在執行，先停止服務\n1 sudo systemctl stop mysqld 禁止開機自啟\n1 sudo systemctl disable mysqld 解除安裝\n1 sudo dnf remove mysql`server 然後我升級軟體還是卡住，安裝 Docker 可參考: https://oracle-base.com/articles/linux/docker-install-docker-on-oracle-linux-ol8 CentOS7 更新軟體 首先更換軟體源，Oracle 的 CentOS7 居然軟體列表是錯誤的，執行 sudo yum update 會報錯\n1 2 Could not retrieve mirrorlist http://mirrorlist.centos.org/?release=7\u0026amp;arch=x86_64\u0026amp;repo=os\u0026amp;infra=stock error was 14: curl#6 - \u0026#34;Could not resolve host: mirrorlist.centos.org; Unknown error\u0026#34; 更新軟體列表\n1 2 3 sed -i \u0026#39;s/mirror\\.centos\\.org/vault.centos.org/g\u0026#39; /etc/yum.repos.d/CentOS-*.repo sed -i \u0026#39;s/^#.*baseurl=http/baseurl=http/g\u0026#39; /etc/yum.repos.d/CentOS-*.repo sed -i \u0026#39;s/^mirrorlist=http/#mirrorlist=http/g\u0026#39; /etc/yum.repos.d/CentOS-*.repo 然後更新軟體\n1 sudo yum update 參考文章: mirrorlist.centos.org no longer resolve? 安裝 Docker 安裝工具\n1 sudo yum install -y yum-utils 設定官方軟體源\n1 sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo 安裝\n1 sudo yum install docker-ce docker-ce-cli docker-compose containerd.io 啟動\n1 sudo systemctl start docker 設定開機自啟\n1 sudo systemctl enable docker 參考文章: CentOS7 安裝 docker (參考官方文件) 伺服器連接埠管理 開放常用連接埠 80 與 443，首先查看防火牆狀態\n1 sudo systemctl status firewalld 輸出是 Active: active (running) 代表正在執行，查看目前開放的連接埠 (永久開放)\n1 sudo firewalld-cmd --list-all --permanent 新增開放連接埠\n1 sudo firewall-cmd --zone=public --add-port=8080/tcp --permanent 重新載入以生效\n1 sudo firewall-cmd --reload 如果需要移除規則\n1 sudo firewall-cmd --zone=public --remove-port=8080/tcp --permanent 安全群組放行連接埠 伺服器放行是伺服器系統方面允許存取，但是還需要安全群組放行入站連接埠\n在 Instances - Networking - Subnet，管理這個實例的子網路\n在其 Security 裡管理具體的安全群組列表\n在其 Security rules 新增 Ingress Rules\n其中 Source Type 使用 CIDR，Source CIDR 填入 0.0.0.0/0，IP Protocol 使用 TCP， Destination Port Range 填入 80, 443，Description 可選填入 HTTP/S\n然後 Add Ingress Rules 即可\n安裝 Nginx-UI 雖然之前的文章 伺服器用 Docker 部署紀錄 提到了具體使用方式，但是隨著更新有了新功能\n為了支援其他容器控制 Nginx 和方便更新，需要映射新目錄，所以 docker-compose.yml 變成了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 version: \u0026#39;3.1\u0026#39; services: nginx-ui: restart: always image: uozi/nginx-ui:latest container_name: nginx_UI volumes: - /root/nginx/nginx:/etc/nginx - /root/nginx/nginx-ui:/etc/nginx-ui - /root/nginx/www:/www - /var/run/docker.sock:/var/run/docker.sock ports: - 80:80 - 443:443 這裡映射 /var/run/docker.sock 的原因，Nginx-UI 解釋為：\nNginx UI 官方映像檔使用 /var/run/docker.sock 透過 Docker Client API 與主機 Docker Engine 通訊。此功能用於在另一個容器中控制 Nginx，並在 Nginx UI 的 OTA 升級期間執行容器替換而非二進位替換，以確保容器相依性也得到升級。如果您不需要此功能，請向容器新增環境變數 (environment) NGINX_UI_IGNORE_DOCKER_SOCKET=true\n其他服務 其他使用的東西似乎都可以直接繼續使用即可，這次移轉感覺速度好快，幾乎是在伺服器配置上花費了較多時間\n","date":"2025-10-03T10:22:25+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/257/","title":"2025 新伺服器部署紀錄"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 前言 某位高手給了 Record Tree 的 JSON 檔案，那順便 隨手寫了點東西 方便一下，也記錄一下忘記的內容 (嗯，正好還是第 256 篇文章呢)\n不過我在 PixivDownloader 也有用到過，完全忘光了。\n讀取 JSON 檔案 讀取後傳回的值會因 JSON 檔案不同而異，會對應到 Python 的列表 (list) 或字典 (dictionary) 型別。\n1 2 3 4 import json with open(FILE_PATH, \u0026#34;r\u0026#34;, encoding=\u0026#34;utf-8\u0026#34;) as f: jsonParse = json.load(f) 接著就可以對 jsonParse 變數進行各種操作了。\n列表 (List) 假如 JSON 檔案是這種情況：\n1 2 3 4 5 6 7 8 [ { \u0026#34;a\u0026#34;: \u0026#34;b\u0026#34; }, { \u0026#34;c\u0026#34;: \u0026#34;d\u0026#34; } ] 那麼上述操作的 jsonParse 最外層是列表，每個列表項都是字典型別。\n字典 (Dictionary) 假如 JSON 檔案是這種情況：\n1 2 3 4 5 { \u0026#34;a\u0026#34;: { \u0026#34;c\u0026#34;: \u0026#34;d\u0026#34; } } 那麼上述操作的 jsonParse 是巢狀的兩層字典。\n操作 知道型別後，對這個檔案的操作就跟 Python 中對字典或列表的操作一樣，例如這個檔案：\n1 2 3 4 5 6 7 8 9 10 [ { \u0026#34;a\u0026#34;: 1, \u0026#34;b\u0026#34;: 2 }, { \u0026#34;c\u0026#34;: 3, \u0026#34;d\u0026#34;: 4 } ] 印出 1 的程式碼：\n1 2 3 4 5 6 7 import json with open(FILE_PATH, \u0026#34;r\u0026#34;, encoding=\u0026#34;utf-8\u0026#34;) as f: s = json.load(f) print(s[0][\u0026#34;a\u0026#34;]) # 或者 print(s[0].get(\u0026#34;a\u0026#34;)) 將 4 修改為 100 的程式碼：\n1 2 3 4 5 import json with open(FILE_PATH, \u0026#34;r\u0026#34;, encoding=\u0026#34;utf-8\u0026#34;) as f: s = json.load(f) s[1][\u0026#34;d\u0026#34;] = 100 新增一個項目，使檔案變成如下所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 [ { \u0026#34;a\u0026#34;: 1, \u0026#34;b\u0026#34;: 2 }, { \u0026#34;c\u0026#34;: 3, \u0026#34;d\u0026#34;: 4 }, { \u0026#34;e\u0026#34;: 5 } ] 其實就是為列表追加一個字典，程式碼如下：\n1 2 3 4 5 import json with open(FILE_PATH, \u0026#34;r\u0026#34;, encoding=\u0026#34;utf-8\u0026#34;) as f: s = json.load(f) s.append({\u0026#34;e\u0026#34;: 5}) 走訪 (Iteration) 對於列表，使用列表的走訪：\n1 2 for i in s: print(i) 對於字典，使用字典的走訪：\n1 2 3 4 5 for key, value in s.items(): print(key, value) for key in s: print(key) 儲存 使用 json.dump：\n1 2 3 4 5 6 with open(FILE_PATH, \u0026#34;r\u0026#34;, encoding=\u0026#34;utf-8\u0026#34;) as f: s = json.load(f) # 對變數 s 做一些修改 with open(FILE_PATH, \u0026#34;w\u0026#34;, encoding=\u0026#34;utf-8\u0026#34;) as f: json.dump(s, f, ensure_ascii=False, indent=2) 其中 ensure_ascii=False 確保中文字元正確寫入，indent=2 表示縮排為 2 個空白字元。\n","date":"2025-09-28T10:34:38+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/256/","title":"Python 處理 JSON 檔案"},{"content":" 📢 本文由 ChatGPT 翻譯 引言 每天滑影片、打電動，本來以為這些都是放鬆的行為，理應能在之後恢復精神。\n但實際上，天天這樣的生活卻讓我覺得空虛又疲累。\n這讓我開始疑惑：理論上我並沒有做什麼高消耗的事情，可是精神不振的狀態實在不太正常。\n番茄鐘裡的困惑 回想起之前眼睛疲勞的時候，我為了護眼而使用番茄鐘學習。\n一開始我的目的很明確，每次休息時間就是望遠或是躺下來休息一下，效果確實不錯。\n但隨著使用次數增加，我漸漸想要在休息時找一些「娛樂」來填補。\n於是我開始利用長一點的休息時間看影片、聽音樂或玩遊戲。\n慢慢地，我感覺效率變差，甚至覺得番茄鐘很麻煩：學習變得更累（有時狀態正好，卻被強制休息），玩樂也不覺得放鬆，反而因為只有 20 分鐘，讓我玩得很焦慮。\n娛樂：另一種專注 仔細想想，也許娛樂並不等於放鬆。\n娛樂跟學習一樣，其實都是需要專注的行為。\n而番茄鐘的設計，是為了管理專注，之後才安排休息。\n真正的「休息」應該是身心的放鬆，是一種從專注狀態中恢復的過程。\n當我嘗試把大腦放空，什麼都不想，去散步、去公園走走、或是隨便逛逛書店時，明顯比看影片或打電動更有放鬆的感覺。\n雖然這些活動會消耗體力，但相比之下，娛樂與學習消耗的其實是「精神力」。\n重新定義娛樂與放鬆 因此，我覺得可以重新檢視娛樂的定義。\n娛樂並不是在學習疲勞後讓自己恢復的方式，而是一種同樣需要投入精神力的行為。\n當精神力已經不足時，還硬去消耗，只會讓娛樂失去意義，甚至出現類似「電子陽痿」的狀況。\n這就像手機電量快沒了，卻還在開著高耗電的 APP。\n相對的，放鬆或休息則該被重新定義。\n它應該是一種讓身心完全打開、任其漂浮的狀態。\n當精神力不足時，做一些低精神消耗、低體力消耗的事也不錯，像是整理環境、隨意走走，不帶目的、不帶意識。\n學習與娛樂的模糊界線 既然學習與娛樂都需要專注，那它們的差別在哪裡呢？\n我認為，這取決於「興趣」。\n不管需要多少專注力，只要有興趣，它就是娛樂；\n如果缺乏興趣，那往往就被歸類為學習。\n例如一款遊戲，如果出於興趣，那就是單純「好玩就玩」；\n但若以「學習」的心態進行，就會變成「要達成什麼目標、做到什麼程度」。\n再像是一個電影 IP，帶著興趣去看，就是放空自己、盡情享受帶來的震撼；\n但若以「學習」的心態，往往會變成分析細節、研究背景、補完世界觀。\n當然，兩者的界線並不明確，大多取決於個人主觀感受。\n放鬆：精神力的真正補給 既然凡是有目的的行為都需要專注，那麼有些所謂的「放鬆行為」其實也帶有目的。\n像是去超市補貨、去書店買書、甚至「去公園放鬆」。\n一旦帶上目的，我覺得這就不是真正的放鬆，因為大腦沒有真正放空，精神力也不會被恢復。\n某些放鬆方式，可以理解成「用少量體力的消耗，換來精神力的補充」。\n如果體力也不支，那還是單純躺下休息最好。\n或許，真正的休息並不是找一件輕鬆的事去做，而是允許自己什麼都不做。\n總結 學習讓人進步，娛樂讓人興奮，而真正的放鬆，才能讓人恢復。\n生活不該只有追逐與刺激。\n也許我們真正需要的，不是更多的娛樂，而是學會停下來。\n","date":"2025-08-22T22:17:38+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/253/","title":"放鬆不是娛樂：一場精神力的再定義"},{"content":" 📢 本文由 ChatGPT 翻譯 引言：飄零的學習感 為了讓自己的英文程度能稍微提升，我在一些不太重要的地方會盡量使用英文，例如遊戲或日常的應用軟體。可是每次使用時，總會有一種沒有真正掌握到什麼的感覺，彷彿整段經歷都是飄浮不定的，甚至好像自己根本沒經歷過。\n仔細想想，這或許是從「翻譯」到「融入」之間的落差。當母語中文介入時，這段經歷會被牢牢地繫在我的語言與思維裡；但在完全非母語的環境下，這段經歷卻無法與母語產生連結。而我平常又是依靠母語思考，自然就忽視了非母語的思考過程。\n類比：控制的執行感 就我實際的體驗來說，在完全英文的遊戲環境裡，我常常覺得自己什麼都不懂，就算是最簡單的單字也一樣。但如果是和朋友一起連線遊玩，並用中文溝通，感覺又完全不同。那種狀態像是重新切回翻譯模式，讓我瞬間輕鬆了許多，從一片慌亂中轉為多少有點掌握感。\n這也讓我聯想到在東京的生活。即使用日文對話，心裡卻常常沒有什麼實感，總覺得自己像是在執行預先設定好的指令，而不是在「活著」。也因此，我甚至喜歡上聽中文歌，因為只有那樣，在街頭閒逛時才會覺得自己還真實地存在。\n矛盾：理論最優與現實退縮 不過話說回來，這樣的狀態不就是語言學習所推崇的「完全脫離母語思考」的理想環境嗎？當我全身心沉浸在英文遊戲裡，沒有任何中文干擾，理論上應該是最好的學習方式吧？畢竟，這幾乎就等於所謂的 Thinking in English。\n然而，實際感受卻完全相反。當遇到一個不認識的單字時，我立刻會覺得自己什麼都做不了、什麼都不會。這種感覺會自然地引發退縮，讓我乾脆什麼都不做。結果是，我覺得自己的英文程度完全沒有進步，甚至反而更加沒有自信。\n反思：完美奇點的幻覺 回顧我的學習歷程，我突然意識到，自己好像一直沒有真正「學習」過。更多時候，我只是在依靠直覺與經驗判斷。在遊戲或日常生活中，能取得的資訊並不只有語言，還有動作、提示、環境等線索。也許我只是靠這些訊號來決定下一步該做什麼，於是給了自己「聽懂了」的錯覺，但語言本身卻成了被忽略的部分，所以說到底並沒有真正學到語言。\n那麼，我以前的學習方式（不只語言）又是如何呢？似乎總是要等到一個「完美的時機」再投入。除非一切條件都很「完美」，否則我就會主觀認為這樣的努力毫無意義。這大概就像是那句話——「收藏從未停止，學習從未開始。」\n這種心態不只體現在感受上，也表現在對環境與教材的要求。幾乎就像「廣度優先演算法」，在每一個階段都想要達到某種「最優」才肯繼續。否則就會覺得完全沒有意義，就算勉強自己去做，結果也只是無果。\n生活：理性與感性的錯位 這又讓我想起生活方式。對於某些不順心的事情（不管是事件還是物品），短期與長期往往呈現出完全不同的心態。短期內它會擾亂心情，但從長期來看，好像根本不那麼重要。\n就像有些物品，長遠看或許會有用，但眼下完全用不上。只是因為「未來可能需要」就讓自己一直處在不舒服的狀態，最後的結果卻是根本沒派上用場。\n整理東西也是同樣的情況。理性上覺得整理會更好，感性上卻提不起勁，或者總想等到一個「完美的時機」再整理。於是，在這個「完美時機」到來之前，每次想到這件事都會覺得煩躁。\n結論：貌似沒有「正解」 那麼，有沒有一個答案能讓學習或生活變得高效呢？\n我想……大概是沒有的吧。生活中充滿了理性決策與感性決策。也許我打算在某段時間內提升某項能力，但由於未來不可預測，加上情緒狀態不同，每一次執行計畫時的結果，都可能超出或低於預期。\n不過，這並不代表毫無技巧可循。既然新的資訊可能隨時推翻原本的計畫，那麼也許可以嘗試換個角度來約束自己：放棄某個面向，卻在另一個面向補足。比如固定時間，讓學習量浮動；或者設定最少的學習量，再讓時間浮動。\n引申：目的性與新鮮感 說到這裡，我忽然又有個想法。只要一件事情帶有「目的性」，在感性上就會變得難以持續。就算是娛樂，像玩遊戲也是。當我帶著「為了釋放壓力」的目的去玩時，腦子裡反而一直在想：「我有沒有真的放鬆下來？」這種意識本身就成了一種壓力。結果不但沒有舒壓，反而越玩越累，甚至出現類似「電子陽痿」的感覺。\n所以有人提出「多培養一些興趣比較好」。這的確是個不錯的方法。因為在不同情境下，可以選擇不同的釋壓方式（以興趣為前提），就能避免過度依賴單一手段。\n不過，或許本質其實更簡單：就是因為「新鮮感」吧。新事物會帶來新鮮的能量。\n結語：「不可控」的未來 那麼，這篇文章到底寫了什麼呢？老實說，我也不確定。也許只是我混亂思緒下的產物罷了。\n但或許，這才是真正的答案——接受生活的「不可控」。我總妄想用理性架構一切，但似乎……任何理性都無法解釋全部。\n就像「狀態—行為理論」所說，只有在掌握所有變數的情況下，才能百分之百預測結果。但我們怎麼可能獲得生活中的「所有變數」呢？\n也許，無法完全掌握變數，本身就是生活的一個變數吧。\n","date":"2025-08-18T18:27:12+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/252/","title":"漂浮的學習，錯位的人生"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 引言 前幾天 (2025-08-13) 我做了一個夢，夢裡一個系列的第二部電影《幻夢》的署名是我，雖然不知道是身為導演還是編劇，這部電影的名字也只是從類似這個系列的製片廠的兩句短語選出來的，第一部也是，但兩部電影卻毫無關聯\n電影的內容在夢裡我只看到了從中間開始，畫面中出現雙星糾纏、三星糾纏、第二宇宙，然後有一個類似奇點的東西，觸發宇宙大爆炸，宇宙重啟，生命誕生，小草破土而出，之後我就醒了\n雖然夢中這部電影說是與《三體》有關，但是就從我看到的片段來看，感覺貌似沒什麼關聯，夢中我去試映場地幾乎可以被認出，宣傳也是直接打著《三體》的名號，不過我覺得不是太重要，這點就略過吧\n分析 我反覆思索這個夢的內容，首先雙星／三星糾纏本身就是一種不穩定的結構，代表了矛盾與不穩定，奇點與宇宙大爆炸，代表了矛盾達到不可調解的地步，就進而引發衝突爆發，之後的生命出現與小草破土而出，代表了新生\n所以其實從這一段來看，是一種不穩定的狀態，或者不穩定的糾纏，因為能量無法承受，轉而在奇點爆發，迎接新生\n思考 首先這部電影的署名是我，但是我卻不知道電影的內容，而夢中看電影的時候感覺我又像主演，我倒是覺得這有點像是在講述著我的人生，或者我經歷的某件事情，因為各種東西錯綜交織，很不穩定，由我推動爆發，迎接毀滅與新生\n其中在三星糾纏的地方，不知道是觀眾還是彈幕說是「最難的一幀」可能是指在這個事件中其實已經很不穩定，但是我卻還是要主動觸發，指這是一個很難的決定\n新生 我本以為這是一種希望，指我人生中可能有一件走到一半的事情迎來了轉機，但後來又思考了一下，感覺當下人生貌似沒什麼轉機的事情\n經過我多角度思考，想到試著從電影名稱《幻夢》入手，貌似想表示我最近的經歷是一次「幻夢」，應該是我主動戳破，從而迎接新生\n抑或是我可能，也必然會把矛盾激化，迎來一次爆發式的毀滅，但是結局或許是完成了自己的蛻變\n感悟 我替自己建構了一個理性的決策系統，覺得自己人生貌似是在做一些預演的選擇而已，那段時間我彷彿不是在生活，而是在機械地選擇可能怎麼做會更好\n隨著選擇的增多，因為我一直都是從一個廣泛的可能性來看待，雖然可能看起來不錯，但是正如我之前想的那樣，我的人生沒有了自己的感覺，也就和《幻夢》一樣，導演是我，主角是我，但是我不知道劇情，只是在看著那部電影，看著我的人生\n隨著我開始考慮自己的感受後，開始試著增加自己的喜好優先級，雖然剛開始是很不錯的，但是之後慢慢沉淪於自己的感受裡面後，漸漸喪失了廣泛的理性判斷，這就是《幻夢》吧，完全沉淪在自己的感性裡，雖然可能比較美好，終究只是一場夢\n於是我在缺失了理性，這種不穩定的背景下，尋找奇點主動結束這一切，來讓我自己完成心理蛻變，開啟新生\n反思 我覺得這其實是我在經歷幾乎全理性與全感性的生活後，心靈的蛻變，意識到了極端的思考不可取，生活本就錯綜複雜，無法以任何一種事物單獨判斷\n過於理性會導致缺乏細枝末節的感受，而過於感性會使得生活變得較為混亂，這個平衡可能不好掌握，不過人生何嘗不是一場「幻夢」呢，自己身為導演，自己身為主角，但是不知道後續\n附言 這篇文章本身也很混亂，這不就正好說明我正是在混亂中分析、尋找奇點嗎？而這次奇點，就是把它寫出來、發布出來。於是我的部落格也藉此打破斷更，迎接新生 😂\n","date":"2025-08-17T01:13:32+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/251/","title":"幻夢"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 對音樂有所感系列 歌曲名稱 翻譯 連結 僕が死のうと思ったのは 曾經我也想過一了百了 https://blog.yexca.net/archives/214 あくあ色ぱれっと aqua 的調色盤 https://blog.yexca.net/archives/219 恋の押し売り 戀愛推銷 https://blog.yexca.net/archives/220 17さいのうた 17 歲的歌 https://blog.yexca.net/archives/224 drop 墜入愛河 https://blog.yexca.net/archives/230 生きるを選んだ私へ 致選擇活下去的自己 https://blog.yexca.net/archives/239 rainy lady 雨意未晴 https://blog.yexca.net/archives/249 恋しくなったら手を叩こう 想談戀愛的話就拍拍手吧 本文 pris-magic! 稜鏡魔法! https://blog.yexca.net/archives/260 引言 聲音和歌曲的感覺好搭，簡直是絕配了，特別是「せーのっ」開始後，空靈又青春的感覺湧現，是很清新香甜的歌曲風格。\n因為是新歌 (2025.06.04 發行)，我在當天收到推播，聽完其實就想著要翻譯了，也就開始陷入單曲循環，經過短暫的努力，感覺稍微有點小清新的味道了吧，盡量按照我覺得不錯的對齊短句來翻譯。\n當然也因為是新歌，說實話在這個「對音樂有所感」系列下也沒什麼感覺，不像其他比較久的歌所產生的共鳴那麼多，這首歌就像是 Honey Lemon Soda 一樣，日常的一點甜就夠了。\n歌曲影片 歌詞 ある時の日常が\n日常的某個時刻啊\n寂しくなっちゃって\n會變得有點寂寞呢\n朝が怖くなって\n漸漸害怕早晨到來\n今眠れないのかい\n是現在還睡不著吧\n大人になったらさ\n以為長大以後呢\n治ると思ってた\n應該就能治好吧\n自己肯定感が\n每天都在一點點\n溶けてく毎日かい\n失去自我肯定感\n耳に張り付いた君の涙声\n耳邊環繞著你的哭聲\nこんなにつらいから\n會有這麼痛苦嗎\nこの夜だけは2人で歌いましょう\n就今晚兩個人一起歌唱吧\n甘いお砂糖に溶けるように\n像砂糖般甜甜地融化著\n回る空気にほら舞うように\n在旋轉的空氣中輕輕舞動著\n君と踊る 君と踊る\n與你共舞，翩翩起舞\nウォーアイニー\n我愛你\n最後までさ\n一直到最後\n浮かず空色付くまでに\n在天空開始浮現藍色前\nその言葉が灰になる前に\n在那些語言化為灰燼前\n君と歌う\n和你歌唱\nそれもそれでいいな\n那樣也不錯呢\nせーのっ\n預備～\n恋しくなったら手を叩こう\n想談戀愛的話就拍拍手\n明日の前笑顔で手を叩こう\n明天來臨前笑著拍拍手\n幸せの意味も知らんけど\n雖然也不知幸福的含義\n今日だけは笑顔で叩こう\n只此刻就笑著拍拍手\n少しだけ深呼吸して\n稍微深呼吸一下\n君はまだ君で居られる\n你依然可以做你自己\n生きてゆく意味も知らんけど\n雖然我也不知道活著的意義\n恋しくなったら手を叩こう\n但想談戀愛了就拍拍手吧\nココロの空調が\n心靈的空調啊\n整えらんなくて\n還沒調整好呢\n頬を伝う音に\n劃過臉頰的聲音\nふと戸惑っちゃったのかい\n一下子就迷茫了吧\nなんにも知らないよ\n我什麼也不知道喔\nこの世の定理とか\n這個世界的道理什麼的\n誰か偉い人が\n要是有哪位厲害的人\n教えてくれたらね\n告訴我的話就好了呢\n震えるつま先\n顫抖的腳尖\n明日の前でさ\n在明天到來前\nなんとか踏ん張って\n還是咬牙撐著吧\nこのまま夜を2人で歌いましょう\n就這樣夜裡兩個人一起歌唱吧\n甘いお砂糖に溶けるように\n像砂糖般甜甜地融化著\n回る空気にほら舞うように\n在旋轉的空氣中輕輕舞動著\n君と踊る 君と踊る\n與你共舞，翩翩起舞\nウォーアイニー\n我愛你\n最後までさ\n一直到最後\n浮かぶ空色付くまでに\n在天空開始浮現藍色前\nその言葉が灰になる前に\n在那些語言化為灰燼前\n君と歌う\n和你歌唱\nそれもそれでいいな\n那樣也不錯呢\nせーのっ\n預備～\n恋しくなったら手を叩こう\n想談戀愛的話就拍拍手\n明日の前笑顔で叩こう\n明天來臨前笑著拍拍手\n幸せの意味も知らんけど\n雖然也不知幸福的含義\n今日だけは笑顔で叩こう\n只此刻就笑著拍拍手\n少しだけ深呼吸して\n稍微深呼吸一下\n君はまだ君で居られる\n你依然可以做你自己\n生きてゆく意味も知らんけど\n雖然我也不知道活著的意義\n恋しくなったら手を叩こう\n但想談戀愛了就拍拍手吧\n","date":"2025-06-07T01:09:19+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/250/","title":"對音樂有所感 - 《想談戀愛就拍拍手吧》"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 考慮到此系列文章貌似並不會對他人「日語學習」提供任何幫助，又是可以被檢索到的文章，特更改系列名稱以符合文章系列現狀\n怎麼說呢，也就是多數是我個人的音樂感想吧，歌詞翻譯也按照我自己理解 (自己聽到時的感受) 不一定與原文相符\n音有所感系列 歌曲名 翻譯 連結 僕が死のうと思ったのは 曾經我也想過一了百了 https://blog.yexca.net/archives/214 あくあ色ぱれっと aqua 的調色盤 https://blog.yexca.net/archives/219 恋の押し売り 戀愛推銷 https://blog.yexca.net/archives/220 17さいのうた 17 歲的歌 https://blog.yexca.net/archives/224 drop 墜入愛河 https://blog.yexca.net/archives/230 生きるを選んだ私へ 致選擇活下去的自己 https://blog.yexca.net/archives/239 rainy lady 雨意未晴 本文 恋しくなったら手を叩こう 想談戀愛的話就拍拍手吧 https://blog.yexca.net/archives/250 pris-magic! 稜鏡魔法! https://blog.yexca.net/archives/260 引言 這首歌的感受……怎麼說呢，其實遇到它的來歷，已經在之前那篇文章也寫過了： https://blog.yexca.net/archives/243/ 。當時第一次聽到這首歌的時候，特別是開頭那一段，就有種和我當時心境完全重合的感覺\n當然，我指的是開頭那幾句。後面的部分，以我當時的日語水平其實聽不太明白 (說實話翻譯也不是很明白)，整體給人的感覺就是一種無力感，也可能是那種「自己好渺小」的感受吧，像是這個世界上厲害的人太多了，都閃閃發光，真是既羨慕又覺得自己有點可悲\n或許是因為我平時很喜歡聽電音（沒有人聲的音樂）吧，所以現在聽歌時更多是靠主觀賦予感情。當我在現實中看到可愛的女孩子，或者遇到很厲害的人時，經常就會想起這首歌的開頭。那是一種夾雜著欣賞、憧憬，又有些對自己無力感到惋惜的複雜情緒\n後來仔細看了歌詞，怎麼說呢，拋開「戀愛」的元素，其實也能讀出一種對未來的迷茫感。雖然不能完全撇開吧，我也不知道這段在寫什麼了，就是一種「想做喜歡的事，卻又不敢開口」的心情……也許不只是戀愛中的事情吧\n2025.05.26 唱了這首歌，除了開頭，後面都跟不上，也不熟悉調子，圖個樂趣吧，以後聽聽就好\n不過看到《肅聖！！蘿莉神安魂曲☆》有原影片好奇唱了下，還真別說，唱起來還挺爽 doge\n歌曲影片 歌詞 は～ぁ可愛いいなぁ\n啊～啊，真可愛呢\nめっちゃキラキラしててすごいなぁ\n非常閃耀真厲害呢\n素直でいいなぁ\n這麼坦率真迷人啊\n人気者ってホントすごいなぁ\n那麼受歡迎真的很棒呢\n面白くっていいなぁ\n這麼有趣真好呢\n友達沢山いるしすごいなぁ\n朋友那麼多，真讓人羨慕啊\n勝手に目が追っちゃうなぁ\n總是吸引著我的目光呢\n君色に染まちゃってるみたいな\n彷彿要染上你的顏色了呢\nちょうどいい距離にいるのかな\n我和你之間的距離剛剛好嗎？\n居心地が良すぎて眠たいわ\n太舒適了想要睡覺呢\n散々してたシミュレーション\n反覆在腦海裡模擬過\nリハーサル通りいかないものね\n還是不能和預期一樣呢\nいつも曖昧なままのふたりの温度\n總是模糊不清的兩人之間的溫度\n答えなんて何も聞きたくないわ\n答案什麼的我一點也不想知道\nどうかしてるかな\n我是不是哪裡不對勁了呢\n今日も rainy lady\n今天也是雨季少女\nまだ まだ まだ まだ 雨模様みたい\n還在下\u0026hellip;還在下\u0026hellip;就像心情依舊陰雨綿綿\n切ない距離と 気まずいシチュエーション\n令人心痛的距離和微妙的情境\n期待なんてほんの1ミリくらい\n期望值大約只有一公釐吧\nあぁついてないなぁ 大きな雨粒\n啊～ 真倒楣呢，落下了大雨滴\nあぁ流れていく\n啊～ 流走吧\nあっ 突然バッタリ会ったり\n啊？偶然又撞見了你\n腦内 君ばっかりだったり\n腦海裡只有你了\n笑ったり怒ったり泣いちゃったりも\n笑呀、生氣呀、哭也有\nちゃっかりしちゃったり?\n偷偷得逞了？\n本来ドンマイ sorry もー無理\n原本是「別在意啦」，現在連道歉都無力了\nしっかりもうコリゴリ\n真的已經受夠了\n一回グッバイさっぱり\n乾脆說聲再見，說不定會好點\nバイバイした方がいいのかな\n還是掰掰的話比較好吧\nどんな言葉が どんな魔法なら\n要用什麼樣的語言，什麼樣的魔法\nどんな恋なら君にまで届くかな\n什麼樣的戀愛才會傳達到你那呢\nヒトリゴトが捗る雨フリの日々に\n一個人自言自語的下雨日子裡\n明るい話題もまるでウワノソラ\n就連開心的話題也聽得心不在焉\nどうかしてるよね\n我是不是哪裡不對勁了呢\nいつも rainy lady\n總是雨季女士\nてるてるぼうずも悲しそうにしてる\n就連晴天娃娃也看起來很傷心\n途切れ途切れに降り続く雨から\n斷斷續續的降雨\n想定外の贈り物なんて\n意想不到的禮物什麼的\nそっと傘の中 また降り出した\n悄悄地，在傘下，又開始下雨了\nAh\n啊\n空の合間に見えた淡い晴れ模様\n在雲隙之間，隱約看到轉晴的天空\n答えてほしいけど聞きたくなくて\n雖然想聽到答案，卻又不敢問出口\nなんて意気地なし\n之類的好沒出息\nいつだろう sunny day\n什麼時候會來呢？晴天\n悲しいくらい天気雨\n很傷心似的太陽雨\nそっと集めつづけた沢山の思いが\n悄悄積攢下來的滿滿思念呀\n無意識に淡々と溢れてきちゃう\n沒意識到已經慢慢溢出來了\n何でもないよ 君がいるなら\n只要你在，其他的都無所謂唷\n雨女でいいや\n雨女也可以啦\n君がいるから oh\n只要你在的話 oh~\nOh, sunny boy\n哦~ 晴天男孩\nRainy lady\n雨天少女\n","date":"2025-05-20T23:44:07+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/249/","title":"音有所感 - 《rainy lady》"},{"content":" 📢 本文由 ChatGPT 翻譯。并且，該軟件只有簡體字 原本只是想隨便寫個小工具，打算用兩天就放著（以前大多都是這樣），沒想到在沒出錯的情況下幫我省下不少時間，越用越順手。\n慢慢地也喚起我以前那個「為什麼不用 SQLite 呢」的想法。確實，每次開 MySQL 真的太麻煩了，於是就誕生了這個版本，終於不用每次都啟動資料庫服務了 （也終於變得比較像給人用的了）\n使用方法 專案位址： https://github.com/yexca/PixivDownloader-SQLite GUI 跟前一代差不多，可以參考 https://blog.yexca.net/archives/211/ 設定說明 使用前需要先設定以下項目：\nrefresh token（Pixiv 登入驗證，參考： Pixiv OAuth Flow ） 下載路徑（預設 D:\\Downloads） 下載說明 使用時只需輸入：\n畫師 ID，或是 作品 ID（若兩者皆輸入，將以畫師 ID 為主） 點擊下載即可下載所有作品並記錄到資料庫（若該畫師尚無記錄則下載所有作品，已有記錄則只下載未下載的部分）\n錯誤處理 目前僅對爬取錯誤進行處理。若出現錯誤提示，有可能是以下原因：\n未設定 refresh token 或 token 已失效 畫師帳號不存在 作品不存在 我沒有加上詳細錯誤說明，如出錯請先檢查以上三點。\n至於其他錯誤（例如軟體直接閃退），可以將 程式根目錄/logs/app_*-*-*.log 中最新的 log 檔寄給我，並說明情況。\n聯絡方式：PixivDownloader#yexca.net（請將 # 換成 @）\n新特性：從 MySQL 改為 SQLite 這次最大變動就是不再需要自建 MySQL，改用輕量化的 SQLite。\n因此也移除了原本不必要的資料庫設定，將設定與 Pixiv 的驗證 Token 整合在一起。\n加了個 icon（隨便請 ChatGPT 畫的），UI 稍作調整，變動不大。\n程式碼初步進行架構化處理……雖然寫到最後又有點亂了就是了 不過說不定哪天我又回來重構一次啦。\n舊版 MySQL 資料庫的遷移方法 雖然我覺得應該沒人用上一版，但還是說一下：由於資料結構不同，最推薦的方式是查詢導出並轉為 INSERT 語法，例如：\n1 2 3 SELECT ID, name, downloadedDate, lastDownloadID, url FROM pic WHERE platform = \u0026#39;pixiv\u0026#39;; 將結果導出為 SQL 語法（我使用的是 Dataflare，它支援這個功能）。\n然後建立一個 Python 檔案，寫入以下內容：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 import sqlite3 conn = sqlite3.connect(\u0026#34;pixiv.db\u0026#34;) cursor = conn.cursor() cursor.execute(\u0026#39;\u0026#39;\u0026#39; Create Table If Not Exists pic ( ID TEXT PRIMARY KEY, name TEXT, downloadedDate TEXT, lastDownloadID TEXT, url TEXT ) \u0026#39;\u0026#39;\u0026#39;) conn.commit() cursor.execute(\u0026#34;\u0026#34;\u0026#34; INSERT INTO `pic` (`ID`, `name`, `downloadedDate`, `lastDownloadID`, `url`) VALUES (\u0026#39;123\u0026#39;, \u0026#39;name1\u0026#39;, \u0026#39;2024-06-08 00:00:00\u0026#39;, \u0026#39;1234\u0026#39;, \u0026#39;https://www.pixiv.net/users/123\u0026#39;), (\u0026#39;234\u0026#39;, \u0026#39;name2\u0026#39;, \u0026#39;2025-02-12 00:05:36\u0026#39;, \u0026#39;2345\u0026#39;, \u0026#39;https://www.pixiv.net/users/234\u0026#39;), (\u0026#39;345\u0026#39;, \u0026#39;name3\u0026#39;, \u0026#39;2025-01-11 17:26:17\u0026#39;, \u0026#39;3456\u0026#39;, \u0026#39;https://www.pixiv.net/users/345\u0026#39;); \u0026#34;\u0026#34;\u0026#34; ) conn.commit() cursor.execute(\u0026#34;\u0026#34;\u0026#34; Select * from pic \u0026#34;\u0026#34;\u0026#34; ) rows = cursor.fetchall() for row in rows: print(row) conn.close() 其中 cursor.execute 的內容請自行替換為你的備份資料。我這裡提供三筆示範資料。\n最後，將產生的資料庫檔案 pixiv.db 放到 程式根目錄/resources 即可。\n一點開發感想：從「亂寫」到「理解混亂」 老實說這次重構是因為上次寫得太亂，覺得非整頓不可，結果改著改著我終於明白為什麼上次會那麼亂了 😂\n不如說，這次的結構也沒好到哪去，寫到一半直接放棄重構，乾脆複製貼上，導致現在有駝峰式命名也有底線命名，真是懶得再改，唉。\n總之算是一個能正常運作的半成品，能用就好了啦～\n","date":"2025-05-18T16:20:33+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/248/","title":"Pixiv 下載器重構記：從亂寫到理解混亂"},{"content":" 📢 本文由 ChatGPT 翻譯 引言 最近在思考自己要繼續做什麼或學些什麼的時候，老是看到「DevOps」這個詞。一開始隨手查了一下，發現裡面提到的技術棧自己差不多都有碰過，還以為這只是像「全端」那樣多掌握幾個工具就好（雖然其實也差不多啦）\n但因為當時沒什麼興趣就耽擱了（其實是沒開發熱情了）\n直到最近躺了快四個月，覺得該掙扎一下，結果又想到這個詞。再深入了解後，只能說\u0026hellip;\u0026hellip;這根本是「捲」到極致了吧，前後端分離就算了，現在是連開發和運維分離都不分人了。\n不過話說回來，當我看到自動流程有 GitHub Action 的時候，就讓我想起以前用 Jekyll 建部落格時也能自動部署。但因為我那時候從其他部落格系統轉過來，習慣用子資料夾分類，而那套部署方式不支援子資料夾，所以我也沒深入研究。既然這次想好好整一整，就來看看現在的 Hugo 部落格能不能自動部署吧 畢竟每次都從容器下回來再上傳真的蠻麻煩的\n工作流程 建立一個 Workflow 的方式是，在 Git 倉庫根目錄的 .github/workflows/ 中建立一個 yaml 檔案，檔名隨意。我這次是部署用途，就命名為 deploy.yml\n整個檔案結構主要分為：名稱、觸發器與工作內容\n名稱 這個就隨意取名即可\n1 name: Build and Deploy Hugo Blog 觸發器 GitHub Action Workflow 支援多種觸發方式，我這裡設成每次 push 都觸發，畢竟通常都是更新文章然後進行構建\n另外加上手動觸發功能，以備有時候 GitHub 出錯需要手動啟動 Workflow\n1 2 3 4 5 on: push: # 當 Git Push 時觸發 branches: - main # 監聽主分支 workflow_dispatch: # 手動觸發 工作內容 我這邊只有一個工作（job），但其實 jobs 可設定多個並行執行。\n先命名這個工作\n1 2 jobs: build-deploy: 接著定義執行的作業環境，我這裡選用 ubuntu：\n1 2 3 jobs: build-deploy: runs-on: ubuntu-latest 接下來定義各步驟，第一步：檢出原始碼\n1 2 3 4 5 6 7 jobs: build-deploy: runs-on: ubuntu-latest steps: - name: Checkout source uses: actions/checkout@v4 安裝 Hugo：\n1 2 3 4 5 6 steps: - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#39;0.140.1\u0026#39; # 这里是我本地的版本，兼容性应该高点 extended: true # 因为我的主题使用了 SCSS 所以必须使用 extended 版本 執行建構指令：\n1 2 3 steps: - name: Build Hugo Site run: hugo --minify 將建構後的內容部署到另一個 GitHub Pages 倉庫：\n1 2 3 4 5 6 7 8 steps: - name: Deploy to BlogWeb repo uses: peaceiris/actions-gh-pages@v3 with: external_repository: yexca/Blog-Web-Hugo publish_branch: main # 推送到目标仓库 yexca/Blog-Web-Hugo 的 main 分支 publish_dir: ./public # 推送的当前仓库的文件夹，Hugo 默认是生成到这个文件夹 personal_token: ${{ secrets.PERSONAL_TOKEN }} 完整合併如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 name: Build and Deploy Hugo Blog on: push: branches: - main workflow_dispatch: jobs: build-deploy: runs-on: ubuntu-latest steps: - name: Checkout source uses: actions/checkout@v4 - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#39;0.140.1\u0026#39; extended: true - name: Build Hugo site run: hugo --minify - name: Deploy to blogWeb repo uses: peaceiris/actions-gh-pages@v3 with: external_repository: yexca/Blog-Web-Hugo publish_branch: main publish_dir: ./public personal_token: ${{ secrets.PERSONAL_TOKEN }} 設定 Token 由於存取其他倉庫需要權限，因此需先產生 Token。\n在 GitHub 的 Settings -\u0026gt; Developer Settings -\u0026gt; Personal access tokens -\u0026gt; Fine-grained tokens 中，產生一組擁有目標倉庫讀寫權限的 Token。\n然後回到原始碼倉庫（例如 yexca/Blog-Source-Hugo），進入 Settings -\u0026gt; Secrets and variables -\u0026gt; Actions -\u0026gt; Repository secrets，新增剛才建立的 Token，名稱需對應 PERSONAL_TOKEN。\n處理自訂網域 若你為 GitHub Pages 設定了自訂網域，需建立一個 CNAME 檔，內容為你的網域。\n但 GitHub Action 的部署會清空再覆蓋內容，因此 CNAME 也會被刪除，所以要在部署前手動加上，可採以下兩種方式：\n方法一：工作流中建立檔案 1 2 3 steps: - name: Add CNAME run: echo \u0026#39;blog.yexca.net\u0026#39; \u0026gt; public/CNAME 方法二：在 Hugo 的 static 資料夾放置 CNAME 因為 static 資料夾會被原樣複製到輸出目錄，也能達成目的。\n主題子模組處理 我原本的主題是以 Git Submodule 引入的，但因為我做了不少修改，若不處理這部分，推送上去的將會是原始 repo 的內容，而非我修改過的版本。\n備份主題 1 cp -r themes/Hugo-Theme-Stack tmp/Hugo-Theme-Stack-Backup 移除子模組 1 2 3 4 git submodule deinit -f themes/Hugo-Theme-Stack git rm -f themes/Hugo-Theme-Stack rm -rf .git/modules/themes/Hugo-Theme-Stack rm .gitmodules 恢復主題 1 2 cp -r tmp/Hugo-Theme-Stack-Backup themes/Hugo-Theme-Stack rm -rf tmp 修復 JS 語法錯誤 我以前為部落格添加了網站執行時間顯示，但當時用了舊的八進位語法：\n1 Date.UTC(2021, 10, 06, 14, 15, 19) 而 Hugo 的 --minify 壓縮指令會對其報錯，改成以下即可：\n1 Date.UTC(2021, 10, 6, 14, 15, 19) 結語 終於不再需要手動編譯了。自從我開始使用 Docker，就習慣將開發環境與本機系統隔離，這樣換電腦或搬服務器只需搬容器即可，也養成了環境潔癖。\n現在好了，連建構與部署也搬到雲端去了，以前是隔離到容器，現在是隔離到 GitHub，算是徹底根治了這毛病。\n不過再回頭看看 DevOps，我倒覺得這其實也是當代技術演進過快導致的產物。\n從早年的機器碼、組合語言，到高階語言，再到容器化部署，一次次技術的「門檻下降」實際上也在偷偷「拉高起跑線」。\n雖然讓程式開發越來越便利，但也使這行的入門門檻不知不覺變高，讓像我這樣的人加速被淘汰啦。\n不過話說回來，工作是工作，生活是生活。技術變快歸變快，世界的節奏、行業的變遷應該還沒快到讓人沒喘息的空間。還是會有留一口氣的餘地吧。\n","date":"2025-05-16T18:14:06+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/247/","title":"擁抱 DevOps：把我的部落格建構與部署丟給 GitHub 處理"},{"content":" 📢 本文由 ChatGPT 翻譯 引言 又一次的自我介紹時，我不由得又想到了我的部落格。\n過去我總是直接打開 Google 搜尋 yexca，點開第一個結果進入我的部落格。\n但自從更換網域後，無數次搜尋 yexca，我的網站卻始終消失在搜尋結果之外。\n起初我並沒有太在意，以為可能有某種懲罰機制吧。畢竟 Google 建議更換網域後最好做一年的 301 重導向，而我當時只做了半年，舊網域就到期了。\n但，已經兩年了吧，再怎麼說，也該恢復了吧？\n而且更離譜的是，搜尋前幾的反而是一些早已不再維護的網站，\n而我，每天更新、調整、折騰的這個部落格，卻彷彿被世界遺忘了一般。\n於是，我開始尋找原因 打開我的部落格，查看 \u0026lt;head\u0026gt; 區塊。\n嗯？\u0026lt;meta name='description'\u0026gt; 怎麼是網頁左邊那句標語？\n啊這，當時配置的時候只是說那句話會出現在那邊，我以為跟 Argon 主題設定一樣呢。那麼也就是說，這網站的描述根本毫無意義啊。\n不過，這句話幾乎陪伴了我整個部落格歷程，我不想輕易放棄它。\n既然如此，那就讓 JSON-LD 來承擔結構化描述的任務吧！\n於是我在主題自定義 \u0026lt;head\u0026gt; 區段加入了：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;script type=\u0026#34;application/ld+json\u0026#34;\u0026gt; { \u0026#34;@context\u0026#34;: \u0026#34;https://schema.org\u0026#34;, \u0026#34;@type\u0026#34;: \u0026#34;Blog\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;yexca\u0026#39;Blog\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;{{ .Site.BaseURL }}\u0026#34;, \u0026#34;inLanguage\u0026#34;: \u0026#34;{{ .Site.Language.Lang }}\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;{{ .Site.Params.description }}\u0026#34;, \u0026#34;author\u0026#34;: { \u0026#34;@type\u0026#34;: \u0026#34;Person\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;yexca\u0026#34; } } \u0026lt;/script\u0026gt; 嗯，同時考慮到是多語言網站，部分內容當然還是使用變數適配會比較好。\n在語言的迷宮中探索 說到多語言網站，那我換個語系搜尋會如何呢？\n於是我在 google.com.hk、google.com.tw、google.com.jp 搜尋 yexca。\n結果日文版可以搜尋到部落格，但中文版卻搜尋不到；英文內容不多，就算了。\n這就很奇怪了，說明 Google 是有把 https://blog.yexca.net 辨識為 yexca，\n那為什麼其他語言版本這麼慘捏？\n繼續排查下去，我發現可能是少了 hreflang 設定，於是我補上了：\n1 2 3 4 5 \u0026lt;link rel=\u0026#34;alternate\u0026#34; hreflang=\u0026#34;x-default\u0026#34; href=\u0026#34;https://blog.yexca.net/\u0026#34; /\u0026gt; \u0026lt;link rel=\u0026#34;alternate\u0026#34; hreflang=\u0026#34;zh-CN\u0026#34; href=\u0026#34;https://blog.yexca.net/\u0026#34; /\u0026gt; \u0026lt;link rel=\u0026#34;alternate\u0026#34; hreflang=\u0026#34;zh-TW\u0026#34; href=\u0026#34;https://blog.yexca.net/zh-tw/\u0026#34; /\u0026gt; \u0026lt;link rel=\u0026#34;alternate\u0026#34; hreflang=\u0026#34;ja\u0026#34; href=\u0026#34;https://blog.yexca.net/ja/\u0026#34; /\u0026gt; \u0026lt;link rel=\u0026#34;alternate\u0026#34; hreflang=\u0026#34;en\u0026#34; href=\u0026#34;https://blog.yexca.net/en/\u0026#34; /\u0026gt; 明確告訴搜尋引擎：不同語言的用戶可以拜訪不同語系版本，但這些都是同一網站。\n順帶一提，這段 \u0026lt;link\u0026gt; 同樣會出現在文章頁面，因為我沒有加條件判斷。雖然不是每篇文章都有多語版本，不過 Google 是可以自己理解的。\n一點點地補上遺漏 但我隨意點開一篇文章，哎呀，裡面還是 JSON-LD 的網站描述，多少有點奇怪。\n於是我加上了條件邏輯：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 {{ if .IsHome }} \u0026lt;!-- 首頁 JSON-LD --\u0026gt; \u0026lt;script type=\u0026#34;application/ld+json\u0026#34;\u0026gt; { \u0026#34;@context\u0026#34;: \u0026#34;https://schema.org\u0026#34;, \u0026#34;@type\u0026#34;: \u0026#34;Blog\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;yexca\u0026#39;Blog\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;{{ .Site.BaseURL }}\u0026#34;, \u0026#34;inLanguage\u0026#34;: \u0026#34;{{ .Site.Language.Lang }}\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;{{ .Site.Params.description }}\u0026#34;, \u0026#34;author\u0026#34;: { \u0026#34;@type\u0026#34;: \u0026#34;Person\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;yexca\u0026#34; } } \u0026lt;/script\u0026gt; {{ else if .IsPage }} \u0026lt;!-- 文章頁 JSON-LD --\u0026gt; \u0026lt;script type=\u0026#34;application/ld+json\u0026#34;\u0026gt; { \u0026#34;@context\u0026#34;: \u0026#34;https://schema.org\u0026#34;, \u0026#34;@type\u0026#34;: \u0026#34;BlogPosting\u0026#34;, \u0026#34;mainEntityOfPage\u0026#34;: { \u0026#34;@type\u0026#34;: \u0026#34;WebPage\u0026#34;, \u0026#34;@id\u0026#34;: \u0026#34;{{ .Permalink }}\u0026#34; }, \u0026#34;headline\u0026#34;: \u0026#34;{{ .Title }}\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;yexca\u0026#39;Blog\u0026#34;, \u0026#34;author\u0026#34;: { \u0026#34;@type\u0026#34;: \u0026#34;Person\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;yexca\u0026#34; }, \u0026#34;publisher\u0026#34;: { \u0026#34;@type\u0026#34;: \u0026#34;Person\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;yexca\u0026#39;Blog\u0026#34; }, \u0026#34;datePublished\u0026#34;: \u0026#34;{{ .Date.Format \u0026#34;2006-01-02\u0026#34; }}\u0026#34;, \u0026#34;dateModified\u0026#34;: \u0026#34;{{ .Lastmod.Format \u0026#34;2006-01-02\u0026#34; }}\u0026#34;, \u0026#34;inLanguage\u0026#34;: \u0026#34;{{ .Site.Language.Lang }}\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;{{ .Params.description | default .Site.Params.description }}\u0026#34; } \u0026lt;/script\u0026gt; {{ end }} 如此一來，首頁與文章就會產生不同的 JSON-LD，不僅語義更正確，也更符合 Google 結構化資料的建議。\n小小的期盼 現在，一切終於補齊了。\n雖然成效不會立刻出現，但我知道，那個訊號，已經送出去了。\n我希望，下次在介紹我的部落格時，\n可以直接打開 Google，搜尋 yexca。\n","date":"2025-04-27T17:38:16+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/246/","title":"為了能搜到自己的名字：一次小站 SEO 排查實踐"},{"content":" 此頁面有使用機器翻譯喲\n並不是所有刷卡的人都是羊毛黨，也不是所有設計系統的人都是工程師。有些人，刷卡像在設計，設計系統像在過生活\n1. 引子：什麼是卡粉？ 說到這，不得不提到之前看到的卡友七大愛好：\n這裡的「中國大陸」是指資金出入受限地區\n想辦法在中國大陸使用外匯 想辦法在境外使用人民幣 想辦法把人民幣匯出中國大陸 想辦法把外匯匯入中國大陸 辦一些在中國大陸幾乎沒用的卡 辦一些在國外更沒用的卡 想辦法讓那些連密碼位數都不到的資金，在一些幾乎沒什麼實際用途的卡片之間來回周轉 中國大陸的銀行密碼慣例為六位數，這裡是卡粉們自嘲「錢比密碼短，還在努力搬」的梗。其他地區可能不適用\n聽起來像是玩金融遊戲，乍看之下就是辦一堆銀行卡、追求回饋、省手續費、划算換匯……好像只是一種「不值錢的小聰明」\n但對真正的卡粉來說：\n卡粉，不是為了省幾塊錢，而是在尋找一個多通道、多節點、多限制下的資金最優路徑設計\n他們不是在薅羊毛，而是在探索這個世界的架構，在做生活系統的最佳化設計\n2. 系統架構設計到底在做什麼？ 為了考取系統架構師資格，往往需要學會很多相關術語，例如模組解耦、效能最佳化、介面規範等等。但拋開這些術語，其實系統架構師的本質任務非常明確：\n在複雜的限制條件下，合理分配資源、規劃路徑、連接各個系統，最終建構出一個既穩定又彈性的整體\n所以系統架構師考慮的不是某行程式碼寫得漂不漂亮，也不只是畫設計圖，而是整個系統能否在現實限制下順利運行。比方說：\n系統之間該如何分工？ 各個服務之間如何呼叫？ 介面要怎麼定義，才能方便未來擴充？ 出現問題時怎麼定位、怎麼隔離影響？ 在預算有限的情況下，怎麼權衡效能與成本？ 系統架構師的角色，有點像在搭積木、也像在修橋鋪路，更像在補丁系統。他們往往不是一開始就擁有完美藍圖，而是在一個混亂甚至破碎的現實中，一點一點規劃路線、加固結構、替換模組、最佳化通路\n簡單來說，就是要在現實條件下，設計出跑得穩、改得動、養得起的系統。不追求「完美設計」，只追求「跑得通」，這就是系統架構師的美學\n雖然我當初只是為了應考而接觸這些知識，但在備考過程中，卻不知不覺重新燃起了我對卡片路徑設計的熱情\n3. 卡粉世界的「架構問題」 卡粉不是無意義的「省點小錢」，系統架構師也不是在搞「高大上的工程設計」。雖然他們活動的場景完全不同，但本質上，他們都在面對同一種問題：\n在規則複雜、成本有限、目標不明的情況下，尋找最優的通路與結構\n卡粉不是單純在辦卡，而是在設計資金流動路徑；\n系統架構師也不是單純在寫程式，而是在規劃資訊流與控制流。\n卡粉常常在思考「怎麼少付手續費、不被風控、還能順利流轉」；\n而架構師則在考量「怎麼減少故障、提升擴展性、讓系統跑得穩」。\n雖然我只是為了考試而認識架構師的思維方式，但回頭一看，這不就是我在玩卡時思考的那些事情嗎？\n卡粉世界 系統架構世界 核心邏輯 手續費 延遲／效能開銷 成本管理 通道限制 API 調用限制 協議相容 卡組織規則 模組規範 合規性 境內外匯差 跨平台相容損耗 多環境適配 卡種多樣性 技術棧多樣性 多模組整合 銀行風控 系統安全策略 風險控制 多卡流轉路徑 資料流向控制 路由與架構設計 卡粉做的不是套利，而是在進行一場關於資金流動結構的設計遊戲\n他們不是在「做事」，而是在「做結構」：不只是找哪張卡回饋最高，而是設計一條路徑，讓資金在卡與卡之間以最小代價、最大效率地完成任務\n他們關注的不是「能不能跑」，而是「跑得是否優雅」；不是「能不能轉出去」，而是「這條流轉過程是否精巧、順暢」\n卡粉在找尋最優卡路徑，其實就像是在解一個「多重限制下的最短路徑問題」；而系統架構師在設計服務拓撲時，則是在權衡「模組耦合度＋SLA（服務等級協議）限制」下的最適組合\n這兩者之間，只是應用場景不同。\n4. 探索路徑的系統實踐 別人只在算哪張卡划算，我在設計一套金融流通系統\n每位卡粉的路徑都是獨一無二的，因為每個人面對的條件都不同：使用的銀行不同、帳戶幣別不同、生活地區不同、資金來源也不同\n真正的樂趣不在於抄別人的攻略，而是透過觀察、實驗、踩坑，找出最適合自己的資金架構\n我記得一開始只是想省點手續費，結果查了一堆資料，發現不同銀行之間轉帳的條件、時間、風控都不同。有些手續費低但轉帳速度慢，有些速度快但限額小，有些甚至完全無預警被退回。整個過程就像在玩一張起初全黑的地圖，一點一點探索通路、開通節點、註記跳板\n一次次的小額嘗試讓我慢慢拼湊出屬於我自己的可用資金路徑。隨著探索深入，我開始刻意繞開高手續費路徑，甚至在幣種兌換中也試圖利用波動換出一點浮盈\n有些一開始看起來「根本做不到」的事情，也在一次次嘗試與測試中漸漸被打通。像是透過虛擬貨幣交易所完成入金、在現實生活中直接使用虛擬貨幣、讓法幣自動轉換為穩定幣，或者使用專門的送金服務將資金匯往某些地區……這些方法繞過了傳統銀行體系，最終完成了原本被認為無法完成的目標\n這個過程，從「無解」到「打通」，就像是一場系統級網路架構的重建。我不是在單純轉帳，而是在重新定義一條資訊與價值的傳輸通路\n聽起來很複雜？但這不就是一個典型的系統流程設計題嗎：\n多個系統之間要如何建立連線、完成資料傳輸？ 不同格式（幣別）要怎麼轉換才能順利被識別？ 哪些節點是可靠的？哪些通路延遲低、失敗率小？ 如何將「資料包」（資金）透過合適的協定（出入金方式）送達最終節點（目標帳戶）？ 整個過程能不能讓用戶（也就是我）在體感上順暢無阻？ 說到底，這就是系統架構的感覺：你不是在堆疊功能，而是在設計一個清晰、穩定、可持續演進的結構網路\n每一張卡是一個節點；每一個匯款接口是一項協定；每一次路線的嘗試與調整，都是一次小規模的架構最佳化\n這背後說穿了就是：路徑規劃 + 接口適配 + 使用者體驗，這不就是系統架構師該做的事嗎？\n卡粉在玩的，從來不只是省錢，而是透過對現實金融網路的解構與重組，掌握系統級控制的樂趣與主導感\n5. 從卡粉中淬鍊出的架構素養 在一次次路徑選擇、失敗嘗試、成本權衡與風控試探中，卡粉其實也在鍛鍊一種架構思維。雖然沒有伺服器、沒有程式碼，但那種「為了結構穩定與效率美感而不斷打磨路徑」的過程，本質上就是一種系統設計能力的實踐\n這些實作經驗，不知不覺內化成了以下這幾類架構素養：\n能力 表現方式 核心精神 熟悉規則 銀行細則、限額通道 文件閱讀能力 整合能力 多卡串接與資金路徑整合 系統整合思維 成本意識 手續費最小化 效能／預算權衡 模型建構 規劃卡間流轉結構 架構建模能力 風控意識 多帳號、多備援設計 高可用性設計 審美追求 資金路徑也要優雅 工程美感 卡粉其實是在用現實世界，模擬訓練一個系統架構師該具備的思維模型\n6. 我的感悟 手續費是敵人，通道是信仰，路徑是藝術\n我之所以成為卡粉，不是因為熱衷刷卡，而是在一次次探索中感受到「結構之美」。也許我們沒有寫程式、沒有部署伺服器，但每一次資金的流動、每一條通路的設計，其實都蘊藏著系統性思考的影子\n從系統架構師的備考過程，到日常生活中設計自己的資金路徑，我漸漸意識到：\n我喜歡的不只是把事情做完，而是讓它的路徑設計得漂亮\n別人眼中的小聰明，是我心中的系統美學；\n別人眼中的羊毛黨，是我內心的生活架構師。\n卡粉不是單純為了省錢，更像是在現實中練習「系統設計」的能力：視覺化問題、逐步迭代、結構清晰、自我滿足\n這不是一種浪費時間，而是一種真實可觸、可日常實踐的「個人系統建構演練」\n卡粉不是在省錢，是在練手；架構不是在發明，是在選擇\n不論是在做架構設計還是在優化卡路徑，最重要的從來不是「能省多少」或「寫幾行程式」，而是那整個過程中，對系統、對結構，甚至對世界運行方式的理解與掌握\n而我，就是那個會在 ATM 前發呆 10 分鐘，只為算清哪條手續費路徑最優的生活架構師\n結語：生活就是最大的架構 我們每天刷卡、轉帳、判斷路徑、做出組合決策，其實就是在進行一場「無形的架構設計實踐」\n系統架構不只是伺服器與 API 的事，它也可能藏在我們的錢包、卡片選擇與支付策略之中\n卡粉的盡頭，也許就是一位生活中的系統架構師\n附錄：我的卡粉路徑偽代碼 這段程式碼並非真正的實作，而是我將現實中資金流轉路徑用架構思維重新建模的嘗試。它就像是一段可讀的生活流程圖，是我對每日卡片路徑操作背後邏輯的抽象化呈現\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // 我的主要跨境資金路徑設計（示意） func RouteCNYtoJPY(CNY float64) JPY float64 { HKD := BOCExchange(CNY, to=\u0026#34;HKD\u0026#34;) log.Printf(\u0026#34;Exchanged %.2f CNY to %.2f HKD\u0026#34;, CNY, HKD) Transfer(HKD, from=\u0026#34;BOC\u0026#34;, to=\u0026#34;BOCHK\u0026#34;, by=\u0026#34;pbservice\u0026#34;) log.Println(\u0026#34;Transferred via pbservice → BOCHK\u0026#34;) Transfer(HKD, from=\u0026#34;BOCHK\u0026#34;, to=\u0026#34;Wise\u0026#34;, by=\u0026#34;fpservice\u0026#34;) log.Println(\u0026#34;Transferred via fps → Wise\u0026#34;) JPY := WiseConvert(HKD, to=\u0026#34;JPY\u0026#34;) log.Printf(\u0026#34;Converted %.2f HKD to %.2f JPY via Wise\u0026#34;, HKD, JPY) Deposit(JPY, to=\u0026#34;Revolut\u0026#34;, with=\u0026#34;ApplePay\u0026#34;) return JPY } 這段偽代碼像是一座由邏輯堆疊出的通路結構，是我與系統架構師世界之間最自然而然的連接\n另註：本文僅為個人經驗與娛樂用途，並非任何財務或法律建議，請讀者自行判斷參考喔～\n","date":"2025-04-22T00:35:15+09:00","image":"https://github.com/yexca/picx-images-hosting/raw/master/2025/04-FromCardEnthusiastToArchitect/250422-TC.13lz2zi90i.webp","permalink":"https://blog.yexca.net/zh-tw/archives/245/","title":"從卡粉到架構師：生活中的系統設計哲學"},{"content":" 此頁面有使用機器翻譯喲\n2023 年 04 月，我開始記帳。2025 年 04 月，我停止了記帳。\n最後一筆記錄：¥0\n起點：為了省錢與掌控 起因很簡單——控制消費，提升金錢意識。剛開始的確非常有效，幫我遏制了一些不好的消費習慣。\n過程：一步步走向最優解與卡粉世界 但慢慢地，為了「更優」的消費，我開始比較、開始尋找最優解。最開始只是商品之間的比較，後來，是付款方式、支付工具，最後，進入了銀行優惠和開卡的世界。\n為了優惠而去開卡，為了便利而去開卡，但這玩意有點上頭，可以說我一步一步走向了卡粉的世界。\n一開始是為了省錢，後來是為了方便，最後——是為了集卡。\n反噬：記帳成為了負擔 於是，記帳本身，逐漸成了負擔。帳戶越來越多，場景越來越複雜，記帳的時間成本、心理成本，早已超過了實際收益。\n我常常為了可能只有幾塊錢的優惠，研究半天。剛開始當然開心，但多了之後，找到最優解不再讓我興奮，反而是一陣空虛取代了最初的喜悅。\n轉變：從最優解到舒服就好 也許是我變了，消費的心態也變了。\n從「按需按惠」，到「差不多就行，自己舒服就行」。\n我也發現，自己早就突破了原先設定的限額，卻沒有因此失控。反而越來越明白，比起省錢，時間和心情更重要。\n反思：我到底為什麼記帳？ 當我因為記帳，而開始：\n因為帳戶多而不斷翻找 因為貨幣轉換而頻繁在記帳軟體創建新帳號 因為商品該不該買而計較半天 因為和朋友出去遊玩消費而破壞心情 我不得不開始反思——我記帳，到底是為了什麼？\n這其中的收益，真的值得嗎？\n決定：放下，歸零，重新出發 於是我嘗試著放下，嘗試著不去管細節，只問自己：「我快樂嗎？」\n結果是——真的很快樂。而支出，也沒有想像中那麼高。\n或許，是習慣讓我潛移默化地比過價。或許，情緒的價值，本來就無法用優惠來衡量。\n所以，我想，是時候放手了。\n記帳，已經完成了它的使命。\n它不再是工具，而是成為了束縛。\n行為習慣是為了更好的生活，當它無法再靠熱情消解，當它反而阻礙了生活，那就該學會告別。\n尾聲：謝謝自己，繼續生活 雖然放棄了自己堅持了兩年的習慣，確實有些不捨。\n但這大概也是人生的一部分吧。沒有什麼可以陪伴一輩子，但只要在一起的那段時光是美好的，這，就足夠了。\n可以說我少了一個象徵性的「我很省」的工具。\n但，我更希望未來的自己，不再是靠數字和記錄來獲得安全感，而是靠真正的從容和自在。\n從可以掌控，到流入未知。\n希望自己能早點適應。\n希望能把省下來的時間，花在更有意義、更值得快樂的事情上。\n所以，\n最後一筆，¥0 附上一段小短文。\n謝謝這兩年認真記錄的自己。\n未來，希望把省下來的時間，花在更有意義、更快樂的事情上。\n就這樣，Archive 了這段經歷。\n記錄是結束，而生活才剛剛開始。\n","date":"2025-04-14T16:23:48+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/244/","title":"從省錢，到生活，再到告別"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 自從我在部落格上開始發布一些較為專業性的學習內容後，它慢慢變得過於枯燥乏味，甚至我打開部落格只會想到要學習東西，這種心理暗示導致我慢慢開始對寫部落格文章有了排斥感，也早早想到要寫點其他的文章但遲遲不知從何下手。正好藉著最近的經歷，嘗試寫一篇非技術文章試試看吧！\n「まだ雨はやまない」 2025-03-23 我買了第一張實體專輯，是 しぐれうい 的 「まだ雨はやまない」，像相簿一般的外觀簡直是太可愛了！\n不過說到購買經歷確實是一段較為曲折的心路歷程，因為買過太多可能只是第一眼覺得好看，但實際上並不理想的東西過多，再加上經濟限制，使得我每次購買非生活必需品的時候總是需要做抉擇，所以買一個我並不熟悉的歌手專輯無疑是一項比較冒險的決定 (畢竟確實比較貴 doge)\n我在今年 (2025) 一月的時候在實體店第一次看到這張專輯，不禁感慨真可愛，埋下了想要購買的種子，順便認識了 しぐれうい。3 月 22 日在沖繩 VRChat 上舉行的展覽中，看到了此次初音的形象設計是 しぐれうい，頓感熟悉 (順便看了 23 日的直播)。\n初音ミクのライブを見た、可愛かった！\nI watched Hatsune Miku\u0026#39;s live concert, so cute!\n也看了初音未來的直播 pic.twitter.com/r1JeMpQ9UA\n\u0026mdash; yexca (@yexcano) March 24, 2025 然後讓我想到了這張專輯，當天搜尋了一下她的歌曲，聽了幾首感覺還不錯。但當我 23 日想買，並且到了店裡後我又退縮了，實際拿到商品後，我開始了解這張專輯 (實際上我很猶豫了，因為我一般買東西都是既然要買就不會去了解，親自體驗驚喜；既然了解了就不會買)，但應該是還有想買的期望吧，只是看了一下有什麼歌，因為只有一首熟悉的，我便去旁邊漫畫店順手買了本漫畫就回去了。在去捷運的路上，習慣性地打開音樂軟體聽音樂，突然有一首歌特別好聽，我下意識地點開收藏，不過看到歌名，頓感熟悉，這就是那張專輯裡的歌曲！於是我立刻掉頭，跑回店裡把專輯買下來 (rainy lady 太好聽了！)\n擷取音樂 不過本身是沒有聽實體專輯的需求的，於是引出了寫本文的主要目的，那就是把歌曲從專輯中擷取出來，主要參考了 https://www.bilibili.com/opus/925630344961458181 原本應該和往常一樣，我寫一篇自己的經歷的，但出現了新的想寫進來的內容，就放個超連結吧。\n「アルストロメリア」 昨天 (25 日) 因為原本約好要一起玩遊戲的朋友想出去逛逛而延遲了，那我索性也出去逛逛吧。這一逛，直接讓我看到了 鹿乃 的專輯！！！\n我直接當場買下，興奮的心情溢於言表，以我淺薄的文學水平並不知道如何表達內心的愉悅，因為我對 鹿乃 太熟悉了，這裡的歌曲並不需要擷取，懷揣著激動的心情打開專輯，看到最後的笑容，內心都被完全療癒了，多麼美好的體驗。果然購買自己喜愛的事物，是一件多麼美好的事啊！\n此時此刻，只讓我想起那句：「このような幸せ、あるでしょうか」(世間還有如此美妙的事情嗎)\n結語 實際寫起來還是可以明顯感覺到自身內容的匱乏，以及表達的不足，罷了，嚴格的要求不就和寫嚴謹的技術文章一樣了嗎？偶爾放鬆一下吧，胡亂寫寫毫無頭緒的也不錯。\n","date":"2025-03-26T18:18:31+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/243/","title":"收藏我的音樂，珍藏我的心情"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 應該和之前的筆記編寫時間相差不多，因為檔案建立時間已經超過考試時間，可能某次移動檔案是創造寫吧\n作業系統的地位 電腦系統由硬體和軟體兩部分組成。通常把未配置軟體的電腦稱為裸機。直接使用裸機不僅不方便，而且將嚴重降低工作效率和機器的利用率。作業系統 (Operating System) 目的是為了填補人與機器之間的鴻溝，即建立使用者與電腦之間的介面，而為裸機配置的一種系統軟體\n作業系統在電腦系統中的地位如下圖所示\n從圖中可見，作業系統是裸機上的第一層軟體，是對硬體系統功能的首次擴充。它在電腦系統中佔據重要而特殊的地位，所有其他軟體，如編輯程式、組譯程式、編譯程式、資料庫管理系統等系統軟體，以及大量的應用軟體都是建立在作業系統基礎上的，並得到它的支援和取得它的服務\n從使用者角度看，當電腦配置了作業系統後，使用者不再直接使用電腦系統硬體，而是利用作業系統所提供的指令和服務去操縱電腦，作業系統已成為現代電腦系統中必不可少的最重要的系統軟體，因此把作業系統看作是使用者與電腦之間的介面\n行程管理 行程管理也稱為處理器管理。在多工批次處理系統和分時系統中有多個並行執行的程式，為了描述系統中程式執行時動態變化的過程引入了行程（Process）。行程是資源分配和獨立運行的基本單位。行程管理重點需要研究各行程之間的並行特性，以及行程之間相互合作與資源競爭產生的問題\n程式順序執行的特徵 前趨圖是一個有向無環圖，由節點和有向邊組成，節點代表各程式段的操作，而節點間的有向邊表示兩個程式段操作之間存在的前趨關係。程式段 Pi 和 Pj 的前趨關係表示成 Pi→Pj，其中，Pi 是 Pj 的前趨，Pj 是 Pi 的後繼，其含義是 Pi 執行結束後 Pj 才能執行\n下圖為 3 個節點的前趨圖，輸入是計算的前趨，輸入結束才能進行計算；計算是輸出的前趨，計算結束才能輸出\n程式順序執行時的主要特徵包括順序性、封閉性和可再現性\n程式並行執行的特徵 若在電腦系統中採用多工程式設計技術，則主記憶體中的多道程式可處於並行執行狀態。對於上述有 3 個程式段的作業類別，雖然每個作業有前趨關係的各程式段不能在 CPU 和輸入/輸出各部件並行執行，但是同一個作業內沒有前趨關係的程式段或不同作業的程式段可以分別在 CPU 和各輸入/輸出部件上並行執行。例如，某系統中有一個 CPU、一台輸入設備和一台輸出設備，前趨圖如下\n程式並行執行時的特徵如下\n失去了程式的封閉性 程式和機器的執行程式的活動不再一一對應 並行程序間的相互制約性 行程的狀態及其狀態間的切換 三態模型 在多工系統中，行程在處理器上交替執行，狀態也不斷地發生變化，因此行程一般有 3 種基本狀態：執行、就緒和阻塞\n執行。當一個程式在處理器上執行時，則稱該行程處於執行狀態。顯然，對於單處理器系統，處於執行狀態的行程只有一個 就緒。一個行程獲得了除處理器外的一切所需資源，一旦得到處理器即可執行，則稱此行程處於就緒狀態 阻塞。阻塞也稱等待或睡眠狀態，一個行程正在等待某一事件發生 (例如請求 I/O 等待 I/O 完成等) 而暫時停止執行，這時即使把處理器分配給行程也無法執行，故稱該行程處於阻塞狀態 行程狀態 CPU 資源 執行 √ √ 就緒 × √ 阻塞 × × 五態模型 事實上，對於一個實際的系統，行程的狀態及其轉換更複雜。例如，引入新建態和終止態構成了行程的五態模型\n行程間的通訊 在多工環境的系統中存在多個可以並行執行的行程，故行程間必然存在資源共享和相互合作的問題。行程通訊是指各個行程交換資訊的過程\n同步與互斥：同步是合作行程間的直接制約問題，互斥是申請臨界資源行程間的間接制約問題\n行程間的同步 在電腦系統中，多個行程可以並行執行，每個行程都以各自獨立的、不可預知的速度向前推進，但是需要在某些確定點上協調相互合作行程間的工作。例如，行程 A 向緩衝區送資料的操作，否則行程 B 必須停下來等待行程 A 的操作結束\n可見，所謂行程間的同步是指在系統中一些需要相互合作，協同工作的行程，這樣的相互聯繫稱為行程的同步\n行程間的互斥 行程的互斥是指系統中多個行程因爭用臨界資源而互斥執行。在多工系統環境中，各行程可以共享各類資源，但有些資源一次只能供一個行程使用，稱為臨界資源 (Critical Resource, CR)，如印表機、共享變數和表格等\n臨界區管理的原則 臨界區 (Critical Section, CS) 是行程中對臨界資源實施操作的那段程式。對互斥臨界區管理的 4 條原則如下\n有空即進。當無行程處於臨界區時，允許行程進入臨界區，並且只能在臨界區執行有限的時間 無空等待。當有一個行程在臨界區時，其他欲進入臨界區的行程必須等待，以保證行程互斥地存取臨界資源 有限等待。對於要求存取臨界資源的行程，應保證行程能在有限的時間進入臨界區，以免陷入 \u0026ldquo;飢餓\u0026rdquo; 狀態 讓權等待。當行程不能進入自己的臨界區時，應立即釋放處理器 (CPU)，以免行程陷入忙等狀態 號誌機制 荷蘭學者 Dijkstra 於 1965 年提出的號誌（Semaphore）機制是一種有效的行程同步與互斥工具。目前，號誌機制有了很大的發展，主要有整數號誌、記錄型號誌和號誌集機制\n整數號誌與 PV 操作 號誌是一個整數變數，根據控制對象的不同被賦予不同的值。號誌分為如下兩類\n公用號誌。實現行程間的互斥，初值為 1 或資源的數目 私用號誌。實現行程間的同步，初值為 0 或某個正整數 號誌 S 的物理意義：S ≥ 0 表示某資源的可用數，若 S ＜ 0 則其絕對值表示阻塞佇列中等待該資源的行程數\n對於系統中的每個行程，其工作的正確與否不僅取決於它自身的正確性，而且與它在執行中能否與其他相關行程正確地實施同步互斥有關。PV 操作是實現行程同步與互斥的常用方法。P 操作和 V 操作是低級通訊原語，在執行期間不可分割。其中 P 操作表示申請一個資源，V 操作表示釋放一個資源\nP 操作的定義 S := S - 1，若 S ≥ 0，則執行 P 操作的行程繼續執行；反之，則置該行程為阻塞狀態 (因為無可用資源)，並將其插入阻塞佇列\nP 操作可用如下過程表示，其中 Semaphore 表示所定義的變數是號誌\n1 2 3 4 5 Procedure P(Var S:Semaphore); Begain S := S - 1; If S \u0026lt; 0 then W(S) {執行P操作的行程插入等待佇列} End; V 操作定義 S := S + 1，若 S ＞ 0 則執行 V 操作的行程繼續執行；反之，則從阻塞狀態喚醒一個行程，並將其插入就緒佇列，然後執行 V 操作的行程繼續\nV 操作可用如下行程表示\n1 2 3 4 5 Procedure V(Var S:Semaphore); Begain S := S + 1; If S \u0026lt;= 0 then R(S) {從阻塞佇列中喚醒一個行程} End; 利用 PV 操作實現行程的互斥 例如以下兩個行程可能會導致 COUNT 的值改變不當\n1 2 3 4 5 6 7 8 9 # 1 if 有車通過 then COUNT := COUNT + 1; GOTO L1; # 2 PRINT COUNT; COUNT := 0; GOTO L2; 令號誌互斥 (mutex) 的初值為 1，在進入臨界區之前執行 P 操作鎖定資源，離開臨界區後執行 V 操作，程式碼如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 1 if 有車通過 then begin P(mutex) COUNT := COUNT + 1; V(mutex) end GOTO L1; # 2 begin P(mutex) PRINT COUNT; COUNT := 0; V(mutex) end GOTO L2; 建議觀看： 【作業系統】行程間通訊—互斥 利用 PV 操作實現行程的同步 行程的同步是由於行程間合作引起的相互制約的問題，要實現行程的同步可用一個號誌與訊息聯繫起來，當號誌的值為 0 時表示希望的訊息未產生，當號誌的值為非 0 時表示希望的訊息已經存在。假定用號誌 S 表示某條訊息，行程可以通過呼叫 P 操作測試訊息是否到達，呼叫 V 操作通知訊息已準備好。最典型的同步問題是單緩衝區的生產者和消費者的同步問題\n建議觀看： 【作業系統】行程間通訊—同步 同類資源分配不當引起死結 若系統中有 m 個資源被 n 個行程共享，當每個行程都要求 k 個資源，而 m ＜ nk 時，即資源數小於行程所要求的總數時，可能會引起死結 (Deadlock)\n例如，m＝5，n=3，k=3，若系統採用的分配策略是輪流地為每個行程分配，則第一輪系統先為每個行程分配一台，還剩下兩台；第二輪系統再為兩個行程各分配一台，此時，系統中已無可供分配的資源，使得各個行程都處於等待狀態導致系統發生死結\n事實上，當 m ≥ n × (k - 1) + 1 時不會發生死結\n死結的處理 死結的處理策略主要有四種：鴕鳥策略 (即不理睬策略)、預防策略、避免策略和檢測與解除死結\n死結預防 死結預防是採用某種策略限制並行行程對資源的請求，破壞死結產生的 4 個必要條件之一，使系統在任何時刻都不滿足死結的必要條件。預防死結的兩種策略如下：\n預先靜態分配法。破壞了 \u0026ldquo;不可剝奪條件\u0026rdquo;，預先分配所需資源，保證不等待資源。該方法的問題是降低了對資源的利用率，降低行程的並行程度；有時可能無法預先知道所需資源 資源有序分配法。破壞了 \u0026ldquo;環路條件\u0026rdquo;，把資源分類按順序排列，保證不形成環路。該方法存在的問題是限制行程對資源的請求；由於資源的排序佔用系統開銷 死結避免 死結避免是設法破壞產生死結的 4 個必要條件之一，嚴格防止死結的產生。死結避免則不那麼嚴格地限制產生死結的必要條件。最著名的死結避免演算法是 Dijkstra 提出的銀行家演算法，死結避免演算法需要很大的系統開銷\n建議觀看： 銀行家演算法 執行緒 傳統的行程有兩個基本屬性：可擁有資源的獨立單位；可獨立排程和分配的基本單位。引入執行緒 (Thread) 的原因是行程在建立、撤銷和切換中，系統必須為之付出較大的時空開銷，故在系統中設置的行程數目不宜過多，行程切換的頻率不宜太高，這就限制了並行程度的提高\n引入執行緒後，將傳統行程的兩個基本屬性分開，執行緒作為排程和分配的基本單位，行程作為獨立分配資源的單位。使用者可以通過建立執行緒來完成任務，以減少程式並行執行時付出的時空開銷\n這樣，對於擁有資源的基本單位，不用頻繁地切換，進一步提高了系統中各程式的並行程度。需要說明的是，執行緒是行程中的一個實體，是被系統獨立分配和排程的基本單位。執行緒基本上不擁有資源，只擁有一點執行中必不可少的資源 (如程式計數器、一組暫存器和堆疊)，它可與同屬一個行程的其他執行緒共享行程所擁有的全部資源\n","date":"2025-03-16T19:35:38+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/242/","title":"軟體設計師 - 作業系統部分筆記"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 這篇文章寫於 2024-04-29，之後有修改過一次，本來以為寫完了，但今天看居然沒寫完，可是相關的東西我早就刪掉了，唉，就這樣吧。\n直接部署 WeBASE 到 FISCO BCOS。\nDocker 部署 在 CentOS 系統下使用 Docker 安裝\n環境 首先安裝 yum-utils 以使用 yum-config-manager\n1 yum install -y yum-utils 設定來源\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 官方來源 yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo # 阿里雲 yum-config-manager \\ --add-repo \\ https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo # 清華大學 yum-config-manager \\ --add-repo \\ https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/centos/docker-ce.repo 安裝\n1 yum install docker-ce docker-ce-cli containerd.io docker-compose-plugin 設定 Docker 映像檔來源\n1 vim /etc/docker/daemon 內容如下（中國科大映像檔來源）\n1 2 3 { \u0026#34;registry-mirrors\u0026#34;: [\u0026#34;https://docker.mirrors.ustc.edu.cn\u0026#34;] } 啟動 Docker\n1 systemctl start docker 或者，如果需要修改設定檔，請重新載入設定檔，並重新啟動 Docker 服務\n1 2 systemctl daemon-reload systemctl restart docker.service 安裝 Python\n1 yum install -y python36 epel-release python36-pip 下載 docker-compose\n1 curl -L \u0026#34;https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)\u0026#34; -o /usr/local/bin/docker-compose 修改執行權限\n1 chmod +x /usr/local/bin/docker-compose 安裝 PyMySQL\n1 pip3 install PyMySQL 部署區塊鏈 拉取部署腳本\n1 wget https://osp-1257653870.cos.ap-guangzhou.myqcloud.com/WeBASE/releases/download/v1.5.5/webase-deploy.zip 解壓縮安裝包\n1 unzip webase-deploy.zip 進入目錄\n1 cd webase-deploy 修改設定檔\n1 vim common.properties 拉取映像檔\n1 python3 deploy.py pullDockerAll 拉取映像檔時會提示輸入逾時時間，輸入 30/60/120 任一數值即可。\n若拉取失敗，可手動拉取相關映像檔，例如 fiscoorg/fiscobcos:v2.9.1\n1 docker pull fiscoorg/fiscobcos:v2.9.1 部署\n1 python3 deploy.py installDockerAll 看到 deploy has completed 即表示部署成功\n常用指令\n1 2 3 4 5 6 7 8 9 10 # 一鍵部署 部署並啟動所有服務 python3 deploy.py installDockerAll 停止一鍵部署的所有服務 python3 deploy.py stopDockerAll 啟動一鍵部署的所有服務 python3 deploy.py startDockerAll # 節點的啟動與停止 啟動所有 FISCO-BCOS 節點: python3 deploy.py startNode 停止所有 FISCO-BCOS 節點: python3 deploy.py stopNode # WeBASE 服務的啟動與停止 啟動所有 WeBASE 服務: python3 deploy.py dockerStart 停止所有 WeBASE 服務: python3 deploy.py dockerStop Java 環境部署 不使用 Docker 的話需要 Java 環境，CentOS 系統需要使用 Oracle JDK，從其 官方網站下載 JDK8 後解壓縮，假設檔案名稱為 jdk-8u411-linux-x64.tar.gz\n1 tar -zxvf jdk-8u411-linux-x64.tar.gz 解壓縮後重新命名\n1 mv jdk1.8.0_411 jdk-8u411 設定環境變數，修改檔案 vim /etc/profile\n1 2 3 export JAVA_HOME=/home/yexca/software/jdk-8u411 export PATH=$JAVA_HOME/bin:$PATH export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOMR/lib/tools.jar 生效\n1 source /etc/profile 查詢\n1 java -version 資料庫 不使用 Docker 的話需要資料庫，安裝 MariaDB，首先建立 repo 檔案\n1 vim /etc/yum.repos.d/mariadb.repo 檔案內容如下，使用阿里雲映像檔來源\n1 2 3 4 5 6 7 8 9 10 11 # MariaDB 11.2 CentOS repository list - created 2024-04-30 03:16 UTC # https://mariadb.org/download/ [mariadb] name = MariaDB # rpm.mariadb.org is a dynamic mirror if your preferred mirror goes offline. See https://mariadb.org/mirrorbits/ for details. # baseurl = https://rpm.mariadb.org/11.2/centos/$releasever/$basearch baseurl = https://mirrors.aliyun.com/mariadb/yum/11.2/centos/$releasever/$basearch module_hotfixes = 1 # gpgkey = https://rpm.mariadb.org/RPM-GPG-KEY-MariaDB gpgkey = https://mirrors.aliyun.com/mariadb/yum/RPM-GPG-KEY-MariaDB gpgcheck = 1 清除快取\n1 2 yum clean all yum makecache all 安裝\n1 yum install -y MariaDB-server MariaDB-client 啟動服務\n1 systemctl start mariadb.service 設定\n1 mariadb-secure-installation 部署區塊鏈 拉取安裝包\n1 wget https://osp-1257653870.cos.ap-guangzhou.myqcloud.com/WeBASE/releases/download/v1.5.5/webase-deploy.zip 解壓縮\n1 unzip webase-deploy.zip 進入目錄\n1 cd webase-deploy 修改設定檔\n1 vim common.properties 部署\n1 python3 deploy.py installAll 啟動與停止操作\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # 一鍵部署 部署並啟動所有服務 python3 deploy.py installAll 停止一鍵部署的所有服務 python3 deploy.py stopAll 啟動一鍵部署的所有服務 python3 deploy.py startAll # 各子服務啟動與停止 啟動 FISCO-BCOS 節點: python3 deploy.py startNode 停止 FISCO-BCOS 節點: python3 deploy.py stopNode 啟動 WeBASE-Web: python3 deploy.py startWeb 停止 WeBASE-Web: python3 deploy.py stopWeb 啟動 WeBASE-Node-Manager: python3 deploy.py startManager 停止 WeBASE-Node-Manager: python3 deploy.py stopManager 啟動 WeBASE-Sign: python3 deploy.py startSign 停止 WeBASE-Sign: python3 deploy.py stopSign 啟動 WeBASE-Front: python3 deploy.py startFront 停止 WeBASE-Front: python3 deploy.py stopFront # 視覺化部署 部署並啟動視覺化部署的所有服務 python3 deploy.py installWeBASE 停止視覺化部署的所有服務 python3 deploy.py stopWeBASE 啟動視覺化部署的所有服務 python3 deploy.py startWeBASE 存取 根據設定項目 web.port=5000 確定存取連接埠（預設為 5000），然後存取管理後台。\n防火牆\n1 2 3 4 5 6 7 8 # 查詢開放的連接埠 firewall-cmd --zone=public --list-ports # 開放連接埠 --permanent 為永久開放 firewall-cmd --zone=public --add-port=5000/tcp --permanent # 重新啟動防火牆 firewall-cmd --reload # 查詢是否開放 firewall-cmd --zone=public --query-port=5000/tcp 智慧合約 2025-03-13: 我也不知道這裡寫的是什麼了\nWeBASE 後台的合約管理頁面，在合約 IDE 建立合約\n編譯後建立新使用者，在私鑰管理處\n透過發送交易測試是否成功\n參考文章 WeBASE 文件 https://www.runoob.com/docker/centos-docker-install.html https://mariadb.org/download/?t=repo-config\u0026d=CentOS+7\u0026v=11.2\u0026r_m=aliyun https://blog.csdn.net/default7/article/details/122672341 https://www.cnblogs.com/potato-chip/p/13973780.html ","date":"2025-03-13T01:08:02+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/241/","title":"使用 WeBASE 部署 FISCO BCOS 區塊鏈"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 引言 在國際化後，因為平時也不怎麼關注其他語言的文章，直到我之前上網衝浪的時候，看到了不錯的日文字型，這不得給它用上，然後就發現我這其他語言的字型真是一言難盡啊。\n匯入字型 Google Fonts 可以透過一些字型服務，例如 Google Fonts 的字型，這樣一般比較方便且快速。\n例如我使用了 Comic Neue、Noto Sans JP、Noto Sans SC、Noto Sans TC 以及 Yomogi 字型，全部選擇後 Google Fonts 會生成一個插入的 HTML 標籤，把這個標籤放入 \u0026lt;head\u0026gt; 標籤裡即可。\n1 \u0026lt;link href=\u0026#34;https://fonts.googleapis.com/css2?family=Comic+Neue:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700\u0026amp;family=Noto+Sans+JP:wght@100..900\u0026amp;family=Noto+Sans+SC:wght@100..900\u0026amp;family=Noto+Sans+TC:wght@100..900\u0026amp;family=Yomogi\u0026amp;display=swap\u0026#34; rel=\u0026#34;stylesheet\u0026#34;\u0026gt; 自由匯入 也可以尋找一些像是 ttf、woff、woff2 檔案作為網站字型，不過一般推薦轉換為 woff2 或 woff 字型會比較好，這樣字型檔案會很小 (更高階的就是把字型檔案分塊之類的優化載入，這點其實看 Google Fonts 的匯入資源就是由很多檔案組成的)。\n比如我使用 Yozai Font ，其作者提供的 ttf 檔案相當大，使用一些工具（例如 Transfonter ）壓縮後再引入。\n先把字型檔案放入自定義目錄，然後在 SCSS 自定義匯入字型的名稱。\n我的定義如下，一般只用 woff2 和 woff 就行，保留 ttf 是為了相容非常老的瀏覽器 (其實是我剛開始不懂直接上傳了，然後很卡才優化的)。\n然後設定 font-display: swap; 可以保證瀏覽器會先使用其他可用字型，等該字型下載完成後再切換成該字型，不會出現空白，優化閱讀體驗。\n1 2 3 4 5 6 7 8 9 @font-face { font-family: \u0026#39;yozai\u0026#39;; src: url(\u0026#39;/fonts/Yozai-Regular.woff2\u0026#39;) format(\u0026#39;woff2\u0026#39;), // url(\u0026#39;/fonts/Yozai-Regular.woff\u0026#39;) format(\u0026#39;woff\u0026#39;), url(\u0026#39;/fonts/Yozai-Regular.ttf\u0026#39;) format(\u0026#39;truetype\u0026#39;); font-weight: 400; font-style: normal; font-display: swap; } 尋找位置 對於匯入 Google Fonts 需要插入 \u0026lt;head\u0026gt; 標籤裡，我的主題檔案提供了該標籤的 custom.html 直接放入即可。\n對於匯入自己的檔案，主題提供了 custom.scss 直接放入即可。\n對於字型設定，我的主題是配置在 variables.scss 裡，所以需要直接在該檔案修改。\n設定字型 根據不同語言確定使用不同字型。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 /** * Global font family */ :root { // --sys-font-family: -apple-system, BlinkMacSystemFont, \u0026#34;Segoe UI\u0026#34;, \u0026#34;Droid Sans\u0026#34;, \u0026#34;Helvetica Neue\u0026#34;; --sys-font-family: system-ui, -apple-system, \u0026#34;Segoe UI\u0026#34;, \u0026#34;Helvetica Neue\u0026#34;, Arial, sans-serif; --zh-font-family: \u0026#34;yozai\u0026#34;, \u0026#34;Noto Sans SC\u0026#34;, var(--sys-font-family); --zh-TW-font-family: \u0026#34;yozai\u0026#34;, \u0026#34;Noto Sans TC\u0026#34;, var(--sys-font-family); --ja-font-family: \u0026#34;Yomogi\u0026#34;, \u0026#34;Noto Sans JP\u0026#34;, var(--sys-font-family); --en-font-family: \u0026#34;Comic Sans MS\u0026#34;, \u0026#34;Comic Neue\u0026#34;, var(--sys-font-family); --base-font-family: var(--sys-font-family), sans-serif; --code-font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, \u0026#34;Liberation Mono\u0026#34;, \u0026#34;Courier New\u0026#34;, monospace; } 按照原命名方式添加了其他語言的字型變數，然後使用 lang 選擇器來替換字型，也就是偵測網頁根標籤 \u0026lt;html\u0026gt; 的 lang 屬性從而動態替換字型。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 /* 針對中文（簡體） */ :lang(zh), :lang(zh-CN) { font-family: var(--zh-font-family); } /* 針對中文（繁體） */ :lang(zh-TW) { font-family: var(--zh-TW-font-family); } /* 針對英語 */ :lang(en) { font-family: var(--en-font-family); } /* 針對日文 */ :lang(ja) { font-family: var(--ja-font-family); } ","date":"2025-03-10T23:56:56+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/240/","title":"國際化字型適配"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 音有所感系列 歌曲名稱 翻譯 連結 僕が死のうと思ったのは 曾經我也想過一了百了 https://blog.yexca.net/archives/214 あくあ色ぱれっと aqua 的調色盤 https://blog.yexca.net/archives/219 恋の押し売り 戀愛推銷 https://blog.yexca.net/archives/220 17さいのうた 17 歲的歌 https://blog.yexca.net/archives/224 drop 墜入愛河 https://blog.yexca.net/archives/230 生きるを選んだ私へ 致選擇活下去的我 本文 rainy lady 雨意未晴 https://blog.yexca.net/archives/249 恋しくなったら手を叩こう 想談戀愛的話就拍拍手吧 https://blog.yexca.net/archives/250 pris-magic! 稜鏡魔法! https://blog.yexca.net/archives/260 引言 初次看到歌曲名稱就大概猜到這首歌的含義，同時也喚起了我之前對於生命的思考。之前對於為什麼活著，我始終找不到答案，但是反過來思考為什麼不去自殺呢？我嘗試過思考自殺的方式以及這些方式會造成的後果，了解到自己對於自殺是恐懼的，因為害怕自殺，所以我選擇了活下去。這正好和這首歌相呼應。\n話說回來，之前我就聽過不少 こはならむ 的作品，但當時她都是哭著唱一些歌，一度讓我覺得有點看不下去，有點擔心她是否能好好活下去。直到 YouTube Music 推播給我的新歌都是歡樂風格的，當時我甚至為她走出悲傷而高興（雖然我還沒走出來）。\n深入了解這首歌後（把歌詞搞懂），才發現這首歌真的很不錯，要是能早點遇到就好了。同時也覺得我寫這系列文章真不錯，讓我從自己之前只是會唱部分的歌曲中學到了很多，我覺得這已經不是從歌曲學日語了，這是從歌曲學人生了，發現自己之前聽的歌的另一面，這種感覺真的很奇妙，更喜歡了（其實這裡想到了亞絲娜對桐人的質疑，如果發現另一面會怎麼樣，真的會更喜歡啊）。\n同時，按照這個系列慣例，翻譯並不完全按照原文意思，部分語句玩梗，不適合用梗的部分後面已刪除。\n2025.05.26 唱了這首歌，詞彙有點難，不過喊出「透明なまま終わっていきなよ、私はもうきっと大丈夫」的時候真的很解放，釋放情緒的感覺超棒 (然後被不認識的詞語打敗了)\n歌曲影片 歌詞 なつかしい音 なつかしい匂い なつかしい景色\n懷念的聲音，懷念的氣味，懷念的景色\n蘇よみがえるトラウマ 見たくない顔 聞きたくない声\n再顯的 PTSD，不想看見的臉，不想聽到的聲音\n許せない人たち もう行けなくなっちゃった、あの駅\n無法原諒的人們，已經無法回去的，那個車站\n暗い「人目が怖いの」\n消極地「世人的眼光很恐怖」\nそんな記憶 あいして生きる\n那樣的記憶也要懷抱著愛活下去\n透明なまま終わっていきなよ\n別就這樣放棄啊\n私はもうきっと大丈夫\n我肯定可以的\n嫌い泣きたいも今振り返れば\n如今再看那些討厭、想哭的事情\n泡と消える刹那せつな\n也如同泡沫般轉瞬即逝\n私見て下を見た気でいなよ そのまま\n不要小看我啊\n消えてしまいたいと願ったような夜に\n就算是曾經想要消失的夜晚\n笑ってられてるよ 永遠に消えないんだよ\n也能夠笑著面對了，永遠不會消失\n狭い世界で くだらない談だんに怯おびえてる私\n狹小的世界內，對無意義的話語受傷的我（這個世界可能指涉社交圈小或者說見識少）\n霞かすんで歪ゆがんだ脳 明白めいはくな病\n頭腦模糊扭曲，多少有點病\n傷跡きずあとは消えないまま 責任の所在は？\n傷痕無法消失，責任在誰呢？\nあの日の子供が泣くのだ 今でも\n那天哭泣的孩子，現在也\u0026hellip;\n今日ものうのう生きている 永世えいせい罪人ざいにん共に問う\n我想問問那些毫無愧疚地活著的永世罪人\n替えの効かないもの 戻らないものに手を出した自じ覚かくはある？\n是否意識到自己伸手染指了那些無可替代，無法挽回的東西？\n許せぬ過去を睨にらんでも仕方ない、って\n說什麼就算盯著那些無法原諒的過去也無濟於事\n言葉は理解するが 時に解決を促うながさせる\n我懂得這些道理啊，可是\u0026hellip;有時卻被迫接受所謂的解決。\n卑ひ劣れつさに 愚ぐ劣れつさに\n那份卑鄙，那份愚蠢\n反吐へどが出る 反吐へどが出る\n好噁心啊，噁心地想吐🤮\n「忘れろ」も言葉のナイフだ\n「忘記吧」也是多麼傷人的話語\n私は今日も立っている 私は今日も歌っている\n今天，我依然站著，我依然歌唱\n透明なまま終わっていきなよ\n別就這樣放棄啊\n私はもう大丈夫\n我已經沒問題了\n嫌い泣きたいも今振り返れば\n如今再看那些討厭、想哭的事情\n私を生かすのは私なのだ\n真正掌控我的是我自己啊\n透明なまま終わっていきなよ\n別就這樣放棄啊\n私はもう、もう大丈夫\n我肯定，已經沒問題了\n嫌い泣きたいも今振り返れば\n如今再看那些討厭、想哭的事情\n決して消えぬ「愛」か\n一定不會消失的愛嗎？\n私見て下を見た気でいなよ そのまま\n不要小看我啊\n消えてしまいたいと願ったような夜に\n就算是曾經想要消失的夜晚\n笑っているんだよ 笑っているんだよ 笑っているんだよ\n笑著面對著，歡笑著面對著，已經不在意了\n","date":"2025-03-07T01:26:31+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/239/","title":"音有所感 - 《致選擇活下去的我》"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 同 電腦網路的筆記 的編寫時間，畢竟考試這兩部分在一起，都是同時學習的\n防火牆技術 防火牆 (Firewall) 是建立在內外網路邊界上的過濾阻擋機制，它認為內部網路是安全且可信賴的，而外部網路是不安全且不可信賴的\n防火牆的作用是防止不希望的、未經授權地進出受保護的內部網路，透過邊界控制強化內部網路的安全策略\n防火牆作為網路安全體系的基礎與核心控制措施，貫穿於受控網路通訊主幹線，對透過受控主幹線的任何通訊行為進行安全處理，如控制、稽核、警報與回應等，同時也承擔著繁重的通訊任務。由於其自身處於網路系統中的敏感位置，本身還要面對各種安全威脅，因此，選用一個安全、穩定且可靠的防火牆產品，其重要性不言而喻\n防火牆技術經歷了封包過濾、應用代理閘道及狀態偵測技術三個發展階段\n封包過濾防火牆 封包過濾防火牆通常有一個封包檢查區塊 (通常稱為封包過濾器)，資料封包過濾可以根據資料封包標頭中的各項資訊來控制站點與站點、站點與網路、網路與網路之間的相互存取，但無法控制傳輸資料的內容，因為內容是應用層資料，而封包過濾器處在網路層與資料鏈路層 (即 TCP 和 IP 層) 之間。透過檢查模組，防火牆能夠攔截與檢查所有出站及進站的資料，它首先開啟封包，取出封包標頭，根據封包標頭的資訊確定該封包是否符合封包過濾規則，並進行記錄。對於不符合規則的封包，應進行警報並丟棄該封包\n過濾型的防火牆通常直接轉發報文，它對使用者完全透明，速度較快。其優點是防火牆對每條傳入與傳出網路的封包實行低層級控制；每個 IP 封包的欄位都被檢查，例如來源位址、目的位址、協定與連接埠等；防火牆可以識別與丟棄帶有欺騙性來源 IP 位址的封包；封包過濾防火牆是兩個網路之間存取的唯一來源；封包過濾通常被包含在路由器資料封包中，因此不需要額外的系統來處理這個特性。缺點是不能防範駭客攻擊，因為網管不可能區分出可信賴網路與不可信賴網路的界線；不支援應用層協定，因為它不識別資料封包中的應用層協定，存取控制粒度太粗糙；不能處理新的安全威脅\n應用代理閘道防火牆 應用代理閘道防火牆徹底隔斷內網與外網的直接通訊，內網使用者對外網的存取變成防火牆對外網的存取，然後再由防火牆轉發給內網使用者。所有通訊都必須經過應用層代理軟體轉發，存取者任何時候都不能與伺服器建立直接的 TCP 連線，應用層的協定會話過程必須符合代理的安全策略要求\n應用代理閘道的優點是可以檢查應用層、傳輸層與網路層的協定特性，對資料封包的偵測能力比較強。缺點是難以配置；處理速度非常慢\n狀態偵測技術防火牆 狀態偵測防火牆結合了代理防火牆的安全性與封包過濾防火牆的高速度等優點，在不損失安全性的基礎上，提高了代理防火牆的效能\n病毒 電腦病毒的特性包括：傳播性、隱蔽性、感染性、潛伏性、觸發性、破壞性等\nWorm 表示蠕蟲病毒、Trojan 表示特洛伊木馬、Backdoor 表示後門病毒、Macro 表示巨集病毒\n巨集病毒感染的對象主要是純文字文件、電子試算表等\n木馬軟體：冰河\n蠕蟲病毒：歡樂時光、熊貓燒香、紅色程式碼、愛蟲病毒、震網\n網路攻擊 阻斷服務攻擊 (DOS 攻擊)：目的是使電腦或網路無法提供正常的服務 阻斷服務攻擊是不斷向電腦發起請求來實現的\n重送攻擊：攻擊者發送一個目的主機已經接收過的報文來達到攻擊目的 攻擊者利用網路監聽或其他方式盜取認證憑證，之後再重新發送給認證伺服器 主要用於身分認證過程，目的是破壞認證的正確性\n密碼入侵攻擊：使用某些合法使用者的帳號與密碼登入到目的主機，然後再實施攻擊活動\n特洛伊木馬：被偽裝成程式或遊戲，當使用者下載了帶有木馬的軟體或附件時，這個程式就會向駭客發起連線請求，建立連線後駭客就實施攻擊活動\n連接埠欺騙攻擊：採用連接埠掃描找到系統漏洞從而實施攻擊\n網路監聽：攻擊者可以接收某一網段在同一條實體通道上傳輸的所有資訊，使用網路監聽可以輕鬆截取包括帳號與密碼在內的資訊資料\nIP 欺騙攻擊：產生的 IP 資料封包為偽造的來源 IP 位址，以便冒充其他系統或發件人的身分\nSQL 注入攻擊：是駭客對資料庫進行攻擊的常用手段之一 沒有對使用者輸入資料的合法性進行判斷，使應用程式存在安全隱患 攻擊者可以提交一段資料庫查詢程式碼，根據程式返回的結果，獲得某些他想得知的資料，首先取得資料庫的權限，就可取得使用者帳號與密碼資訊，以及對某些資料修改等\n入侵偵測技術：專家系統、模型偵測、簡單比對\n網路安全 SSL (Secure Socket Layer, 安全通訊端層) 是 Netscape 於 1994 年開發的傳輸層安全協定，用於實現 Web 安全通訊，1996 年發布的 SSL 3.0 協定草案已經成為一個事實上的 Web 安全標準\nTLS (Transport Layer Security, 傳輸層安全協定) 是 IETF 制定的協定，它建立在 SSL 3.0 協定規範之上，是 SSL 3.0 的後續版本\n終端設備與遠端站點之間安全連線的協定是 SSH。SSH 為 Secure Shell 的縮寫，是由 IETF 制定的建立在應用層與傳輸層基礎上的安全協定。SSH 是專為遠端登入會話與其他網路服務提供安全性的協定。利用 SSH 協定可以有效防止遠端管理過程中的資訊洩漏問題，SSH 最初是 UNIX 上的程式，後來又迅速擴展到其他操作平台\nHTTPS (Hyper Text Transfer Protocol over Secure Socket Layer)，是以安全為目標的 HTTP 通道，即使用 SSL 加密演算法的 HTTP\nMIME (Multipurpose Internet Mail Extensions, 多用途網際網路郵件擴展類型) 是一個網際網路標準，擴展了電子郵件標準，使其能夠支援：非 ASCII 字元純文字，非文字格式附件 (二進位、聲音、圖像等)，由多部分 (multiple parts) 組成的訊息本體，包含非 ASCII 字元的標頭資訊 (Header information)\nPGP (Petty Good Privacy, 優良保密協定) 是一個基於 RSA 公鑰加密體系的郵件加密軟體。可以用它對郵件保密以防止未經授權者閱讀，還能對郵件加上數位簽章從而使收信人可以確認郵件的發送方\n","date":"2025-03-04T18:38:28+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/238/","title":"軟體設計師 - 資訊安全部分筆記"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 引言 最近下載 OneDrive 分享的檔案時，發現無法被 IDM 自動抓取，而瀏覽器下載又不穩定，經常下載失敗，於是我便在想是否有辦法獲取直接下載連結。\n擴充功能問題 剛開始看到不支援了，還以為需要重新安裝，結果刪除後去 Chrome 線上應用程式商店顯示無法安裝，呃，刪太早了。\n不過 IDM 作為付費軟體，居然沒有跟進更新。\n從 簡悅專案問題 得知，原來只是按鈕被加上了 disabled 屬性禁用，把屬性移除後就能正常安裝。\n獲取直接連結 但 IDM 還是無法偵測，那就只能尋找直接下載連結了。\n進入分享頁面，預覽某個檔案，點擊右上角 Share - Copy link 即可獲取檔案分享連結，類似於：\n1 https://xxx-my.sharepoint.com/:u:/r/personal/xxx/Documents/xxx/xxx.rar?csf=1\u0026amp;web=1\u0026amp;e=OTZZbx 將其中的 web 替換為 download，類似於：\n1 https://xxx-my.sharepoint.com/:u:/r/personal/xxx/Documents/xxx/xxx.rar?csf=1\u0026amp;download=1\u0026amp;e=OTZZbx 複製到 IDM 的 Add URL 下載即可。\n參考文章： https://techcommunity.microsoft.com/discussions/onedriveforbusiness/onedrive-direct-download-link/4226744 ","date":"2025-03-02T12:58:57+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/237/","title":"獲取 OneDrive 直接下載連結"},{"content":" 📢 本文由 gemini-3-pro 翻譯 從圖片連結就能知道這是 2023-04 的筆記了，一直沒發是因為幾乎就只是知識點而已，不是一種文章的樣式，不過畢竟也是筆記，偶爾想查閱的時候還是直接看部落格方便啊。\n1. 網路設備 層級 設備 隔離廣播域 隔離碰撞域 實體層 中繼器 / 集線器 × × 資料鏈結層 橋接器 / 交換器 × √ 網路層 路由器 √ √ 實體層的互連設備 實體層的互連設備有中繼器 (Repeater) 和集線器 (Hub)。\n中繼器\n它是實體層上實現區域網路網段互連的設備，用於擴展區域網路網段的長度。\n集線器\n集線器可以看成是一種特殊的多路中繼器 (多連接埠中繼器)，也具有訊號放大功能。\n資料鏈結層的互連設備 資料鏈結層的互連設備有橋接器 (Bridge) 和交換器 (Switch)。\n橋接器\n橋接器用於連接兩個區域網路網段。\n交換器\n交換器是多連接埠 (Multi-port) 的橋接器。\n網路層的互連設備 路由器 (Router) 是網路層互連設備，用於連接多個邏輯上分開的網路。\n應用層的互連設備 閘道器 (Gateway) 是應用層的互連設備。當連接不同類型且協定差別較大的網路時，則要選用閘道器設備。\n2. 協定組 電腦網路的 TCP/IP 協定組\n3. TCP 和 UDP 網際層協定 IP 網際層 (網路層) 是整個 TCP/IP 協定組的重點，在網際層定義的協定除了 IP 外，還有 ICMP、ARP 和 RARP 等幾個重要的協定。\nIP 所提供的服務通常被認為是無連線的 (Connectionless) 和不可靠的 (Unreliable)。事實上，在網路效能良好的情況下，IP 傳送的資料能夠完好無損地到達目的地。\n所謂無連線的傳輸，是指沒有確定目標系統在已做好接收資料準備之前就發送資料。與此相對應的就是連線導向的 (Connection Oriented) 傳輸 (如 TCP)，在該類傳輸中，來源系統與目的系統在應用層資料傳送之前需要進行三向交握 (Three-way Handshake)。\n至於不可靠的服務，是指目的系統不對成功接收的封包進行確認，IP 只是盡可能地使資料傳輸成功。但是只要需要，上層協定必須實現用於保證封包成功提供的附加服務。\n由於 IP 只提供無連線、不可靠的服務，所以把錯誤偵測和流量控制之類的服務授權給了其他的各層協定，這正是 TCP/IP 能夠高效工作的一個重要保證。\n傳輸層協定 TCP TCP (Transmission Control Protocol, 傳輸控制協定) 是整個 TCP/IP 協定組中最重要的協定之一。它在 IP 提供的不可靠資料服務的基礎上，為應用程式提供了一個可靠的、連線導向的、全雙工的資料傳輸服務。\n可靠傳輸、連線管理、錯誤檢驗和重傳、流量控制、壅塞控制、連接埠定址\n其中流量控制採用的是：可變大小的滑動視窗協定\n利用 TCP 在來源主機和目的主機之間建立和關閉連線操作時，均需要通過三向交握來確認建立和關閉是否成功。\n傳輸層協定 UDP 使用者資料報協定 (User Datagram Protocol, UDP) 是一種不可靠的、無連線的協定，可以保證應用程式行程間的通訊。與同樣處在傳輸層的連線導向 TCP 相比，UDP 是一種無連線的協定，它的錯誤偵測功能要弱得多。可以這樣說，TCP 有助於提供可靠性；而 UDP 有助於提高傳輸的高速率性。例如，必須支援互動式會話的應用程式 (如 FTP 等) 往往使用 TCP；而自己進行錯誤偵測或不需要錯誤偵測的應用程式 (如 DNS、SNMP 等) 往往使用 UDP。\nUDP 協定軟體的主要作用是將 UDP 訊息展示給應用層，它並不負責重新發送遺失的或出錯的資料訊息，不對接收到的無序 IP 資料報重新排序，不消除重複的 IP 資料報，不對已收到的資料報進行確認，也不負責建立或終止連線。這些問題是由使用 UDP 進行通訊的應用程式負責處理的。\nTCP 雖然提供了一個可靠的資料傳輸服務，但它是以犧牲通訊量來實現的。也就是說，為了完成同樣一個任務，TCP 需要更多的時間和通訊量。這在網路不可靠的時候透過犧牲一些時間換來達到網路的可靠性是可行的，但在網路十分可靠的情況下，則可以採用 UDP，通訊量的浪費就會很小。\n4. SMTP 和 POP3 電子郵件 (E-mail) 就是利用電腦進行資訊交換的電子媒體信件。它是隨著電腦網路而出現的，並依靠網路的通訊手段實現普通郵件訊息的傳輸。它是最廣泛的一種服務。\nE-mail 系統基於用戶端/伺服器模式。E-mail 伺服器主要採用 SMTP (簡單郵件傳輸協定)，本協定描述了電子郵件的訊息格式及其傳遞處理方法，保證被傳送的電子郵件能夠正確的定址和可靠的傳輸，它是物件導向文字的網路協定，其缺點是不能用來傳送非 ASCII 碼文字和非文字附件，在日益發展的多媒體環境中以及人們關注的郵件私密性方面更顯出它的侷限性。\n後來的一些協定，包括多用途 Internet 郵件擴充協定 (MIME) 及增強私密郵件保護協定 (PEM)，彌補了 SMTP 的缺點。SMTP 用在大型多使用者、多工的作業系統中，將它用在 PC 上收信是十分困難的，所以在 TCP/IP 網路上的大多數郵件管理程式使用 SMTP 來發信，且採用 POP (Post Office Protocol, 常用的是 POP3) 來保管使用者未能及時取走的郵件。\nPOP 協定有兩個版本：POP2 和 POP3。目前使用的 POP3 既能與 STMP 共同使用，也可以單獨使用，以傳送和接收電子郵件。POP 協定是一種簡單的純文字協定，每次傳輸以整個 E-mail 為單位，不能提供部分傳輸。\n簡單郵件傳送協定和用於接收郵件的 POP3 均是利用 TCP 連接埠。SMTP 所用的連接埠號是 25，POP3 所用的連接埠號是 110。\n5. ARP 和 RARP 和 DHCP ARP 和 RARP 位址解析協定 (Address Resolution Protocol, ARP) 及反向位址解析協定 (RARP) 是駐留在網際層 (網路層) 中的另一個重要協定。ARP 的作用是將 IP 位址轉換為實體位址 (Physical Address)，RARP 的作用是將實體位址轉換為 IP 位址。\n網路中的任何設備，主機、路由器和交換器等均有唯一的實體位址，該位址通過網卡給出，每個網卡出廠後都有不同的編號，這意味著使用者所購買的網卡有著唯一的實體位址。另一方面，為了遮蔽底層協定及實體位址上的差異，IP 協定又使用了 IP 位址，因此，在資料傳輸過程中，必須對 IP 位址與實體位址進行相互轉換。\n用 ARP 進行 IP 位址到實體位址轉換的過程為：當電腦需要與任何其他的電腦進行通訊時，首先需要查詢 ARP 快取 (Cache)，如果 ARP 快取中這個 IP 位址存在，便使用與它對應的實體位址直接將資料報發給所需的實體網卡；如果 ARP 快取中沒有該 IP 位址，那麼 ARP 便在區域網路上以廣播方式發送一個 ARP 請求封包。\n如果區域網路上 IP 位址與某台電腦中的 IP 位址相一致，那麼該電腦便生成一個 ARP 回應訊息，訊息中包含對應的實體位址。ARP 協定軟體將 IP 位址與實體位址的組合添加到它的快取中，這時即可開始資料通訊。\nDHCP DHCP (動態主機設定協定) 的功能是：集中的管理、分配 IP 位址、使網路環境中的主機動態的獲得 IP 位址、Gateway 位址、DNS 伺服器位址等資訊，並能提升位址的使用率。\nDHCP 用戶端可以從 DHCP 伺服器獲得本機 IP 位址、DNS 伺服器位址、DHCP 伺服器位址和預設閘道的位址等。\nWindows 無效位址：169.254.x.x\nLinux 無效位址：0.0.0.0\n168.254.x.x 是 Windows 系統在 DHCP 訊息租用失敗時自動給用戶端分配的 IP 位址。\n6. IP 位址和子網路遮罩 IP 位址 Internet 位址是按名字來描述的，這種位址表示方式易於理解和記憶。實際上，Internet 中的主機位址是用 IP 位址來唯一標識的。這是因為 Internet 中所使用的網路協定是 TCP/IP 協定，故每個主機必須用 IP 位址來標識。\n每個 IP 位址都由 4 個小於 256 的數字組成，數字之間用 . 分開。Internet 的 IP 位址共有 32 位元，4 個位元組。它有兩種表示格式；二進位格式和十進位格式。二進位格式是電腦所認識的格式，十進位格式是由二進位格式「翻譯」過去的，主要是為了便於使用和掌握。例如，十進位 IP 位址 129.102.4.11 與二進位的 10000001 01100110 00000100 00001011 相同，顯然表示成帶點的十進位格式方便得多。\n網域名稱和 IP 位址是一一對應的，網域名稱易於記憶、便於使用，因此得到比較普遍的使用。當使用者和 Internet 上的某台電腦交換資訊時，只需要使用網域名稱，網路會自動地將其轉換成 IP 位址找到該台電腦。\nInternet 中的位址可分為 5 類：A 類、B 類、C 類、D 類和 E 類。在 IP 位址中，全 0 代表的是網路，全 1 代表的是廣播。\nA 類網路位址佔有 1 個位元組 (8 位元)，定義最高位為 0 來標識此類位址，餘下 7 位元為真正的網路位址，支援 1~126 個網路。後面的 3 個位元組 (24 位元) 為主機位址，共提供 $2^{24}-2$ 個端點的定址。\nA 類網路位址第一個位元組的十進位值為 000~127\nB 類網路位址佔有兩個位元組，使用最高兩位為 10 來標識此類位址，其餘 14 位元為真正的網路位址，主機位址佔後面的兩個位元組 (16 位元)，所以 B 類全部的位址有 $(2^{14}-2)(2^{16}-2)$ = 16382×65534 個。\nB 類網路位址第一個位元組的十進位值為 128~191\nC 類網路位址佔有 3 個位元組，它是最通用的 Internet 位址。使用最高三位為 110 來標識此類位址，其餘 21 位元為真正的網路位址，因此 C 類位址支援 $2^{21}-2$ 個網路。主機位址佔最後 1 個位元組，每個網路可多達 $2^8-2$ 個主機。\nC 類網路位址第一個位元組的十進位值為 192~223\nD 類位址是相當新的。它的標識頭是 1110，用於多播 (Multicast)，例如用於路由器的修改。\nD 類網路位址第一個位元組的十進位值為 224~239\nE 類位址為實驗保留，其識別頭是 1111。\nE 類網路位址第一個位元組的十進位值為 240~255\n網路軟體和路由器使用子網路遮罩 (Subnet Mask) 來識別封包是僅存放在網路內部還是被路由轉發到其他地方。在一個欄位內，1 的出現表明一個欄位包含所有或部分網路位址，0 表明主機位址位置。例如，最常用的 C 類位址使用前 3 個位元組來識別網路，最後一個位元組 (8 位元) 識別主機。因此，子網路遮罩是 255.255.255.0。\nIPv6 簡介 IPv6 具有長達 128 位元的位址空間，可以徹底解決 IPv4 位址不足的問題。除此之外，IPv6 還採用分級位址模式、高效 IP 封包首部、服務品質 (QoS)、主機位址自動配置、認證和加密等許多技術。\n7. Windows 指令 ipconfig/release：DHCP 用戶端手工釋放 IP 位址 ipconfig/flushdns：清除本地 DNS 快取內容 ipconfig/displaydns：顯示本地 DNS 內容 ipconfig/registerdns：DNS 用戶端手工向伺服器進行註冊 ipconfig：顯示所有網路介面卡的 IP 位址、子網路遮罩和預設閘道值 ipconfig/all：顯示所有網路介面卡的完整 TCP/IP 設定資訊，包括 DHCP 服務是否已啟動 ipconfig/renew：DHCP 用戶端手工向伺服器重新整理請求 (重新申請 IP 位址) 8. 路由 Windows Server 2003 的路由類型有 5 種。當 Windows 伺服器收到一個 IP 封包時，先尋找主機路由，再尋找網路路由 (直連網路和遠端網路)，這些路由尋找失敗時，最後才尋找預設路由。\n各種路由來源的管理距離 (Administrative Distance) 如下：\n如果路由器收到了由多個路由協定轉發的、關於某個目標的多條路由，則比較各個路由的管理距離，並採用管理距離小的路由來源提供的路由資訊。\n","date":"2025-03-01T23:28:30+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/236/","title":"軟體設計師 - 電腦網路部分筆記"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 這篇文章檔案的建立到最後修改時間是 2022.10.31 - 2024.09.15，記錄了這段時期內我嚐過的茶葉以及個人感受。\n不過到了後期的時候，事實上我已經不是很喜歡這個愛好了，記錄就寫得很敷衍，但總歸是自己曾經的愛好，再加上文章編號到了 233，那就放一篇可能有點意思的文章吧 (老早就以為自己發過了，拖到了現在)\n紅茶 名稱 口味 妃子笑 初嚐時有種很悶膩的口感多次沖泡之後散發一股地瓜的味道大約可沖 12 泡 水蜜桃 初次沖泡比妃子笑稍苦，不膩夜裡呼吸不順，甚至出血，不確定是否茶的緣故 昔歸紅 初嚐甜而不膩，苦而不澀，非常好 祁門紅茶 初嚐時與 昔歸紅 差不多，不甜，但似乎更醇厚但茶葉較碎細 金駿眉 過於醇厚，甚至略帶苦澀，但第三杯喝後口中留有餘香與甘甜茶葉較細碎，且沖泡次數不多 醉紅 就是紅茶那個味可沖泡次數還行，但不能悶泡，碎渣較多 煙燻小種 確實帶有股煙燻味\n入口苦澀，但餘韻回甘 老欉紅茶 好喝 黑茶 名稱 口味 金獎六類 像是八寶粥的味道 參香六堡 帶有股藥草的苦味 天尖 初嚐時被其美味所震撼（或許是因為喝了前面兩種茶）\n味道苦澀，但有回甘\n多次沖泡後變得過於苦澀 金花茯磚 淡雅的「金獎六類」＋淡雅的「參香六堡」 老青磚 舊木頭味，茶渣太多 老熟普 喝起來不太好喝的樣子 老生普 很難泡開，苦澀 古樹熟普 相較於前兩種，還算可以 普洱生茶 初入口時略帶苦澀，而後口中帶有回甘\n放置兩天後，茶葉頂端出現發霉現象，沖泡後苦澀味更為明顯 普洱熟茶 八寶粥味 白茶 名稱 口味 荒野貢眉 入口帶有鮮嫩農作物的微苦澀感，甘甜綿軟 昔歸白 塊狀茶葉，散開後品嚐，入口蜜甜，口齒留香\n沖泡次數很多 \u0026gt;10 野小白 飲用時苦澀，飲後口中帶有餘甘 白毫銀針 茶色很淡，第一泡略帶茶草味，之後稍帶蜜甜，口中帶有餘甘 冰糖甜 第一、二泡帶有茶草味，之後是正常的白茶味 老白茶 經典白茶味，夠甜 高壽 第一口是茶草味，之後是正常的白茶味 烏龍茶 名稱 口味 大紅袍 量多，可以，微甜 鐵觀音 茶香但苦澀 蘭底水仙 苦澀 鴨屎香單叢 前兩泡帶有淡淡的烏龍茶香，後面味道轉淡 蜜蘭香單叢 入口無味，後有留香，後續很苦 梨山烏龍 淡淡的木頭味，泡開後是正常的烏龍味 流香肉桂 入口木頭味，後有回甘 白牡丹 初聞有油茶味，入口木頭味 清香鐵觀音 感覺味道差不多，淡雅清香 漳平水仙 感覺味道差不多，淡雅清香 古法鐵觀音 味道相較於上方幾款不錯 岩茶 名稱 口味 大紅袍 苦澀 杏桃香 奇特、苦澀 佛國岩肉桂 入口微苦，後口帶有留香 佛手雪梨 似乎只有苦味，過一段時間後有留香 留香肉桂 同上，有岩茶的感覺 蘭底水仙 名字超好聽，不過味道還是那種岩茶的感覺，甜度倒是比較高 奇丹 印刷名稱是「上立下可」的字，但不知道這個字是什麼，手寫也找不到\n味道相對較清淡，保留了岩茶的回甘，體驗相當不錯 其他 名稱 口味 小青柑 黑茶，不太好，略帶酸味\n體驗極差，第三天出現餿味 安吉白 外觀好看，很香，帶有板栗味，略顯膩口 蒙頂黃芽 與上一個類似，略好一些 茉莉雪芽 茶葉飄香，茶湯清香，飲後口中帶有餘香\n烏龍茶？ ","date":"2025-02-12T23:58:53+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/233/","title":"個人品茶史"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 音有所感系列 歌曲名稱 翻譯 連結 僕が死のうと思ったのは 曾經我也想過一了百了 https://blog.yexca.net/archives/214 あくあ色ぱれっと aqua 的調色盤 https://blog.yexca.net/archives/219 恋の押し売り 戀愛推銷 https://blog.yexca.net/archives/220 17さいのうた 17 歲的歌 https://blog.yexca.net/archives/224 drop 墜入愛河 本文 生きるを選んだ私へ 致選擇活下去的自己 https://blog.yexca.net/archives/239 rainy lady 雨意未晴 https://blog.yexca.net/archives/249 恋しくなったら手を叩こう 想談戀愛的話就拍拍手吧 https://blog.yexca.net/archives/250 pris-magic! 稜鏡魔法! https://blog.yexca.net/archives/260 引言 今天試著做了 2019 年 12 月的 N1 試卷，居然不小心就合格了，突然激發了我想寫一篇學日語的文章，就是這個系列啦！\n選歌的時候有點煩惱，因為最近我都在聽音樂 (我通常把有人聲的叫做歌曲，無人聲的叫做音樂)，這玩意也寫不了啊。\n試著找了 YouTube Music 每個季節最常聽的歌曲，但都不怎麼適合單曲循環 (單聽可以，但沒喜歡到可以一直循環的地步)，翻看紀錄發現了這首歌。\n說到這首歌，可能是我第一首沒看歌詞卻聽懂最多內容的歌了 (有點矛盾，但這不重要)，以前也多次循環播放過，可以說是直接讓我以此為契機去認識潤羽るしあ了 (雖然已經終止活動了)，怎麼會有這麼甜的歌呢，超愛啦！\n歌曲影片 歌詞 夢の中で君と過ごしても\n即使在夢中和你共度時光\nまた覚めるたび君が離れないの\n每次醒來你還是在我心裡\n退屈なベッドで1人きり\n獨自一人躺在無聊的床上\nあぁ 迎えに来てよ王子様\n啊~，快來接我吧，王子大人\n君を知りたい 気持ちもどかしい\n想要了解你，心情也焦急不安\nいっそシャボン玉になって弾けたい\n想化作泡泡，在一瞬間綻放\nあぁ 君が好き なんて言えない\n啊~，好喜歡你，但說不出口\nたまに冷たい 君がわかんない\n偶爾冷漠的你真的搞不懂\n君の場所びゅーんと飛んでって\n一下子飛到你的所在位置\nアニメみたいに2人恋に落ちて\n像動畫那樣兩個人墜入愛河\nくすぐったいくらいに君のこと\n想到你時，連心都癢癢的\n考える1人の夜がいいの\n獨自一人想你的夜晚也不錯\nふわふわと浮かぶ甘い心\n輕飄飄的甜甜的心\n頭離れない君は悪い男？\n無法移開視線的你其實是個壞男人嗎？\nわからないことにもやもやして\n不知道的事情也不用管啦\n夢でも君のことを考えて\n夢中也要想著你\nあぁ いじけちゃって嫌になっても 考えちゃう\n啊~，即使悶悶不樂，煩到不行，還是忍不住去想你\nねぇ 優しかったり冷たくなったり 迷路みたい\n欸，你時而溫柔時而冷漠，真是搞不懂\nあぁ 攻略サイトも見当たらないから やり直しばかり\n啊~，就連攻略網站也找不到，只能一遍遍嘗試了\nもー知らないもんって強がり\n只好逞強地說「我才不想理你」\nでも嫌いになんてなれるわけもない\n但也不是討厭你的意思啦\nそう思うほど胸も痛くなる愛\n越想越覺得心好痛\n私の恋のキュービットは\n我的戀愛邱比特\nいつになったら現れるの\n到底什麼時候才會出現啊\n夢の中で君と過ごしても\n即使在夢中和你共度時光\nまた覚めるたび君が離れないの\n每次醒來你還是在我心裡\n退屈なベッドで1人きり\n獨自一人躺在無聊的床上\nあぁ 迎えに来てよ王子様\n啊~，快來接我吧，王子大人\n君を知りたい 気持ちもどかしい\n想要了解你，心情也焦急不安\nいっそシャボン玉になって弾けたい\n想化作泡泡，在一瞬間綻放\nあぁ 君が好き なんて言えない\n啊~，好喜歡你，但說不出口\nたまに冷たい 君がわかんない\n偶爾冷漠的你真的搞不懂\nひいふうみいよ 数えて\n一、二、三、四，數著\n君につぎ 会える日を楽しみに眠るの\n期待著和你再次相見而入睡\nいつでも会えるよう\n為了能隨時和你相見\n昨日よりもかわいくなるために生きるよ\n我要努力活得比昨天更可愛\n気付いてくれるかな\n你有沒有注意到我啊\n君の好きなメイクにしてみたとか (どうかな？)\n試試看你喜歡的打扮怎麼樣 (好不好啊？)\n少し重すぎかな\n會不會有點太誇張了？\n優柔不断で何も決まんないや (もう)\n猶豫不決，什麼都決定不了 (吼)\n可愛くなれるかな\n可以變得更可愛嗎\n君の前だとチークはいらないか (ねえ ねえ)\n和你在一起就不用畫腮紅了 (欸，欸)\n私と同じかな\n和我一樣嗎\nこの気持ち君も同じだといいな\n如果這個心意你也一樣該有多好啊\n夢の中で君と過ごしても\n即使在夢中和你共度時光\nまた覚めるたび君が離れないの\n每次醒來你還是在我心裡\n退屈なベッドで1人きり\n獨自一人躺在無聊的床上\nあぁ 迎えに来てよ王子様\n啊~，快來接我吧，王子大人\n君を知りたい 気持ちもどかしい\n想要了解你，心情也焦急不安\nいっそシャボン玉になって弾けたい\n想化作泡泡，在一瞬間綻放\nあぁ 君が好き なんて言えない\n啊~，好喜歡你，但說不出口\nたまに冷たい 君がわかんない\n偶爾冷漠的你真的搞不懂\nふわふわな気持ちを隠しても\n就算想遮掩自己輕飄飄的心情\n君の眼を見るとまた零こぼれるちゃうよ\n看向你的眼睛時也會忍不住流露出來\n味のないケーキも君となら\n就算沒味道的蛋糕，只要是跟你在一起\n大好きな時間に変わってく\n也會變成我最喜歡的時光\n君を知りたい もっと知りたい\n想要了解你，更多地了解你\n好きの2文字が口から出せない\n「喜歡」這兩個字卻說不出來\nあぁ 君が好き を隠した日々\n啊~，好喜歡你，每天藏著這份心情\nたまに冷たい 君も愛いとおしい\n偶爾冷漠的你也很迷人\n","date":"2025-02-06T22:06:10+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/230/","title":"音有所感 - 《drop》"},{"content":" 此頁面有使用機器翻譯喲\n音之所感系列\n歌曲名稱 翻譯 連結 僕が死のうと思ったのは 曾經我也想過一了百了 https://blog.yexca.net/zh-tw/archives/214 あくあ色ぱれっと aqua 的調色板 https://blog.yexca.net/zh-tw/archives/219 恋の押し売り 戀愛推銷 https://blog.yexca.net/zh-tw/archives/220 17さいのうた 17 歲的歌曲 本文 引言 其實我一開始只是聽懂了有關「寫給自己的信」那部分，覺得跟我第一次聽到時的心情相當契合，所以就一直聽下去了。\n後來嘗試去翻譯這首歌，再加上最近的種種經歷，我感覺自己現在的狀態，好像跟ユイカ當時的情況很像。現在的我，就跟這首歌一樣，只有迷惘：究竟要成為什麼樣的人？未來會是什麼模樣？我又該往哪裡前進呢？\n正面一點，就像歌詞裡所說的，試著接受自己吧。離開那份迷惘，隨便找一件自己感覺喜歡的事情去做吧。\n最後，也想感謝一直鼓勵著我的人，以及那些雖然嘴上沒說鼓勵，但卻在行動上支持我的人。\n歌曲影片 歌詞 こんな私の未熟なうたを　聴いてくれてどうも有難うね 未熟: みじゅく\n感謝你來聽我還很青澀的歌\nもう少しで私は未熟な大人に　なるみたいです\n再過不久，我好像也要變成不成熟的大人了\nなんか笑っちゃうね\n總覺得有點好笑呢\n本当はね\n其實啊\nもっと前を向けるようなうたを　書くつもりだったけど\n本打算寫更加讓人積極的歌\n書けなくて\n卻怎麼也寫不出來\n私はまだ　他の誰かを支えられるほど\n我還沒有達到可以支撐別人的存在\n強くなかったみたい　ごめんね\n看起來並不怎麼要強，真是抱歉吶\n拝啓　未来の私へ　今そこで\n敬啟，未來的我啊，現在在那裡\nどんなことをして　生きていますか\n正做著什麼樣的事情，過著什麼樣的生活呢\n拝啓　今の私へ　今ここで\n敬啟，現在的我啊，現在在此刻\nどんなことをしたら　生きていけるんでしょうか\n我該做些什麼，才可以繼續活下去呢\n\u0026ldquo;好きだからかっこいい\u0026quot;とか　\u0026ldquo;そばにいる\u0026quot;とか\n曾經寫過「因為喜歡才覺得帥」、「想要待在身邊」\n\u0026ldquo;勝手に盗んだ\u0026quot;とか　書いてた\n還有「隨便就偷走你的心」之類的\nどうせだったらもうちょっと　貴方みたいに\n這樣的話，不如再向你\nやさしいうたを書けばよかったね\n寫首溫暖的歌就好了呢\n本当はね　好きなことだけして生きたいの\n其實啊，我只想做喜歡的事情吶\nでもそれは上手な生き方とは言えないから\n但那稱不上成熟的活法\n無駄になっても　意味がなくても\n即使顯得徒勞，毫無意義\n今はここから　離れなきゃいけないの　ごめんね\n現在還是不得不離開了，抱歉吶\n拝啓　未来の私へ　今そこで\n敬啟，未來的我啊，現在在那裡\nどんな大人になって　生きていますか\n變成了什麼樣的大人，過著什麼樣的生活呢\n拝啓　今の私へ　今ここで\n敬啟，現在的我啊，此刻在這裡\nどんな大人になりたいと　言えばいいんでしょうか\n說出「想要成為什麼樣的大人」可以嗎\n「さよなら」は悲しくなるからさ\n「再見」聽起來太悲傷了\n「またね」って言わせて\n請讓我說「下次見」吧\nいつか私が　今みたいな　うたを書けなくなっても\n就算未來哪天我寫不出來這樣的歌了\n怒らないでね\n也請不要怪我\n拝啓　過去の私へ　今の私は\n敬啟，過去的我啊，現在的我\nずっと夢見ていたこと叶えてるよ\n實現了一直以來的夢想喲\n拝啓　今の私へ\n敬啟，現在的我啊\nこんな情けない　うただって歌えばいいよ 情け: なさけ\n唱出這麼軟弱的歌也可以喲\nそれが私だから\n因為那就是我\n拝啓　未来の私へ　今そこは\n敬啟，未來的我啊，現在在那裡\nどんな綺麗な世界が　広がっていますか\n展開著怎樣絢麗多彩的世界呢\n拝啓　今の私へ　今ここが\n敬啟，現在的我啊，現在的時刻\nどんな世界よりも　幸せでした\n比任何世界都要幸福呀\nこんな私の未熟なうたを　聴いてくれてどうも有難うね\n感謝你來聽我還很青澀的歌\nこれから私は未熟な大人に　なる準備をします\n接下來我也要為成為不夠成熟的大人，而好好準備\n「じゃあ またね」\n「那麼，下次見」\n","date":"2025-01-25T16:57:49+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/224/","title":"音之所感 - 《17さいのうた》"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 設定 YAML、YML、Properties 檔案都可以進行設定，也可以透過 Java 系統屬性及命令列參數。\n優先順序：命令列參數 \u0026gt; Java 系統屬性 \u0026gt; Properties 檔案 \u0026gt; YML 檔案 \u0026gt; YAML 檔案\n命令列使用時，需要先執行 Maven 的包裝指令，然後在命令列執行。\n1 2 3 4 5 java -jar path_to_jar.jar # Java 系統屬性，以埠號為例 java -Dserver.port=9000 -jar path_to_jar.jar # 命令列參數，以埠號為例 java -jar path_to_jar.jar --server.port=9000 SpringBoot 專案進行包裝時需要引入 spring-boot-maven-plugin 外掛程式（如果基於官方樣板建立專案，會自動加入該外掛程式）。\nBean 管理 取得 Bean 對於預設的單例非延遲載入 Bean 而言，Spring 專案啟動時，會把 Bean 都建立好並放置在 IOC 容器中（例如加上 @Lazy 註解後，將會在第一次被使用時實例化）。\n如果想主動取得這些 Bean，可以透過以下方式。\n根據名稱取得 1 Object getBean(String name) 根據類型取得 1 \u0026lt;T\u0026gt; T getBean(Class\u0026lt;T\u0026gt; requiredType) 根據名稱及類型取得（類型轉換） 1 \u0026lt;T\u0026gt; T getBean(String name, Class\u0026lt;T\u0026gt; requiredType) 為了使用此方法，需要先取得 IOC 容器物件。\n1 2 3 4 5 6 7 8 9 10 11 12 13 @Autowired private ApplicationContext applicationContext; //IOC 容器物件 public void testGetBean(){ // 根據 Bean 的名稱取得 DeptController beanl = (DeptController) applicationContext.getBean(\u0026#34;deptController\u0026#34;); // 根據 Bean 的類型取得 DeptController bean2 = applicationContext.getBean(DeptController.class); // 根據 Bean 的名稱及類型取得 DeptController bean3 = applicationContext.getBean(\u0026#34;deptController\u0026#34;, DeptController.class); } Bean 作用域 Spring 支援五種作用域，其中後三種只在 Web 環境中生效。\n作用域 描述 singleton 容器內同名稱的 Bean 只有一個實例（單例） prototype 每次使用該 Bean 時會建立新的實例（非單例） request 每個請求範圍內會建立新的實例 session 每個會話範圍內會建立新的實例 application 每個應用程式範圍內會建立新的實例 使用註解 @Scope 設定作用域\n1 2 3 4 5 6 // 設定為非單例 @Scope(\u0026#34;prototype\u0026#34;) @RestController public class xxxController{ } 在實際開發中，絕大部分的 Bean 都是單例的，也就是說絕大部分的 Bean 不需要設定 scope 屬性。\n第三方 Bean 如果要管理的 Bean 物件來自於第三方（並非自訂），就無法使用 @Component 及衍生註解來宣告 Bean，這時就需要用到 @Bean 註解。例如解析 XML 檔案的 dom4j。\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.dom4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;dom4j\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.1.3\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 依賴如上所示。\n1 2 3 4 5 6 7 @SpringBootApplication public class xxxApplication{ @Bean // 將方法回傳值交給 IOC 容器管理，使其成為 IOC 容器的 Bean 物件 public SAXReader saxReader(){ return new SAXReader(); } } 不過，若要管理第三方 Bean 物件，建議對這些 Bean 進行集中分類設定，可以透過 @Configuration 註解宣告一個設定類。\n1 2 3 4 5 6 7 @Configuration public class CommonConfig { @Bean public SAXReader saxReader(){ return new SAXReader(); } } 透過 @Bean 註解的 name 或 value 屬性可以宣告 Bean 的名稱，如果不指定，預設 Bean 的名稱就是方法名。如果第三方 Bean 需要依賴其他 Bean 物件，直接在 Bean 定義方法中設定形參即可，容器會根據類型自動組裝。\n1 2 3 4 5 6 7 @Configuration public class CommonConfig { @Bean public SAXReader saxReader(XxService xxService){ return new SAXReader(); } } 起始依賴 在開發中，若直接使用 Spring 需要引入相關依賴，並且保證版本匹配；而使用 SpringBoot 則只需要引入起始依賴即可。其原理是 Maven 的傳遞依賴，其他的依賴都會自動透過 Maven 的依賴機制傳遞進來。\n自動配置 SpringBoot 的自動配置就是當 Spring 容器啟動後，一些設定類、Bean 物件會自動儲存到 IOC 容器中，不需要我們手動去宣告，從而簡化了開發，省去了繁瑣的設定操作。\n設定類 @Configuration 的底層是 @Component，也是容器中的一個 Bean 物件。\n在引入依賴之後，是如何將依賴 Jar 檔案中所定義的設定類以及 Bean 載入到 Spring IOC 容器中的呢？\n@ComponentScan 使用 @ComponentScan 可以指定要掃描的套件，例如依賴匯入了 com.example 套件。\n1 2 @SpringBootApplication @ComponentScan({\u0026#34;net.yexca\u0026#34;,\u0026#34;com.example\u0026#34;}) 不過，當需要引入大量的第三方依賴時，上方需要設定大量的套件，而大面積的掃描效能也比較低。\n@Import 可以匯入普通類別、設定類以及 ImportSelector 介面實作類。\n普通類別 1 2 @Import(TokenParser.class) //匯入普通類別 @SpringBootApplication 設定類 設定類內容\n1 2 3 4 5 6 7 8 9 10 11 12 @Configuration public class HeaderConfig { @Bean public HeaderParser headerParser(){ return new HeaderParser(); } @Bean public HeaderGenerator headerGenerator(){ return new HeaderGenerator(); } } 啟動類\n1 2 @Import(HeaderConfig.class) //匯入設定類 @SpringBootApplication ImportSelector 介面實作類 ImportSelector 介面實作類內容\n1 2 3 4 5 6 public class MyImportSelector implements ImportSelector { public String[] selectImports(AnnotationMetadata importingClassMetadata) { //回傳值為字串陣列（陣列中封裝了具完整限定名稱的類別） return new String[]{\u0026#34;com.example.HeaderConfig\u0026#34;}; } } 啟動類\n1 2 @Import(MyImportSelector.class) //匯入 `ImportSelector` 介面實作類 @SpringBootApplication @EnableXxxxx 上述 @Import 需要首先知道第三方依賴中有哪些設定類或 Bean 才行；而第三方依賴可以提供 @EnableXxxxx 註解，封裝 @Import 註解以提供一些常用 Bean，使用時只需要 @EnableXxxxx 註解即可。\n例如上述 @Import 的設定類，可以封裝一個 @EnableHeaderConfig 註解。\n1 2 3 4 5 @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.TYPE) @Import(MyImportSelector.class)//指定要匯入哪些 Bean 物件或設定類 public @interface EnableHeaderConfig { } 然後只需要在啟動類加上 @EnableHeaderConfig 註解即可匯入相應的 Bean。\n1 2 @EnableHeaderConfig //使用第三方依賴提供的以 Enable 開頭的註解 @SpringBootApplication 此方法也是 SpringBoot 所採用的方式。\nSpringBoot 的自動配置 在 @SpringBootApplication 註解裡有 @EnableAutoConfiguration，其中 @Import({AutoConfigurationImportSelector.class}) 匯入了 ImportSelector 介面的實作類 AutoConfigurationImportSelector.class。\n在該實作類中覆寫了 selectImports() 方法。\n1 2 3 4 5 6 7 8 9 public String[] selectImports(AnnotationMetadata annotationMetadata) { if (!this.isEnabled(annotationMetadata)) { return NO_IMPORTS; } else { // 取得自動配置的設定類資訊集合 AutoConfigurationEntry autoConfigurationEntry = this.getAutoConfigurationEntry(annotationMetadata); return StringUtils.toStringArray(autoConfigurationEntry.getConfigurations()); } } 呼叫 getAutoConfigurationEntry() 方法取得了自動配置的設定類資訊集合。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 protected AutoConfigurationEntry getAutoConfigurationEntry(AnnotationMetadata annotationMetadata) { if (!this.isEnabled(annotationMetadata)) { return EMPTY_ENTRY; } else { AnnotationAttributes attributes = this.getAttributes(annotationMetadata); // 取得在設定檔中設定的所有自動配置類別的集合 List\u0026lt;String\u0026gt; configurations = this.getCandidateConfigurations(annotationMetadata, attributes); configurations = this.removeDuplicates(configurations); Set\u0026lt;String\u0026gt; exclusions = this.getExclusions(annotationMetadata, attributes); this.checkExcludedClasses(configurations, exclusions); configurations.removeAll(exclusions); configurations = this.getConfigurationClassFilter().filter(configurations); this.fireAutoConfigurationImportEvents(configurations, exclusions); return new AutoConfigurationEntry(configurations, exclusions); } } 其中 getCandidateConfigurations(annotationMetadata, attributes) 方法會取得在設定檔中設定的所有自動配置類別的集合。\n1 2 3 4 5 6 protected List\u0026lt;String\u0026gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) { List\u0026lt;String\u0026gt; configurations = new ArrayList(SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader())); ImportCandidates.load(AutoConfiguration.class, this.getBeanClassLoader()).forEach(configurations::add); Assert.notEmpty(configurations, \u0026#34;No auto configuration classes found in META-INF/spring.factories nor in META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports. If you are using a custom packaging, make sure that file is correct.\u0026#34;); return configurations; } 可以看到，它是取得 META-INF/spring.factories 和 META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports 檔案中設定類別的集合。\n上述兩個檔案通常在引入的起始依賴中。\n也就是說，當 SpringBoot 程式啟動時，就會載入設定檔當中所定義的設定類，並將這些設定類資訊（類別的完整限定名稱）封裝到 String 類型的陣列中，最終透過 @Import 註解將這些設定類全部載入到 Spring 的 IOC 容器中，交由 IOC 容器管理。\n@Conditional 但是檔案中的設定類那麼多，每個 Bean 都會註冊到 IOC 容器中嗎？並非如此，使用 @Conditional 註解可以讓 Bean 物件依照條件進行組裝。\n@Conditional 是一個父註解，底下有許多子註解。\n@ConditionalOnClass 判斷環境中是否存在對應的位元碼檔案，才會將 Bean 註冊到 IOC 容器。\n1 2 3 4 5 6 7 8 9 10 11 @Configuration public class HeaderConfig { @Bean //環境中存在指定的這個類別時，才會將該 Bean 加入 IOC 容器 @ConditionalOnClass(name=\u0026#34;io.jsonwebtoken.Jwts\u0026#34;) public HeaderParser headerParser(){ return new HeaderParser(); } } 上述 Bean 需要引入 JWT 權杖的依賴才會注入到 IOC 容器中。\n1 2 3 4 5 6 \u0026lt;!--JWT 權杖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.jsonwebtoken\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jjwt\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.9.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 測試\n1 2 3 4 5 6 7 8 9 10 11 @SpringBootTest public class AutoConfigurationTests { @Autowired private ApplicationContext applicationContext; @Test public void testHeaderParser(){ System.out.println(applicationContext.getBean(HeaderParser.class)); } } @ConditionalOnMissingBean 判斷環境中沒有對應的 Bean（類型或名稱），才會將 Bean 註冊到 IOC 容器。\n1 2 3 4 5 6 7 8 9 10 11 @Configuration public class HeaderConfig { @Bean //不存在該類型的 Bean 時，才會將該 Bean 加入 IOC 容器 @ConditionalOnMissingBean public HeaderParser headerParser(){ return new HeaderParser(); } } 上述當 IOC 中沒有 HeaderConfig 類型的 Bean 時才會建立。\n也可以在註解中指定其他 Bean 名稱。\n1 2 3 4 5 6 7 8 9 10 11 @Configuration public class HeaderConfig { @Bean //不存在指定名稱的 Bean 時，才會將該 Bean 加入 IOC 容器 @ConditionalOnMissingBean(name=\u0026#34;deptController2\u0026#34;) public HeaderParser headerParser(){ return new HeaderParser(); } } 上例在不存在名稱為 deptController2 的 Bean 物件時，才會建立 HeaderConfig 物件並註冊到 IOC。\n還可以指定類型。\n1 2 3 4 5 6 7 8 9 10 11 @Configuration public class HeaderConfig { @Bean //不存在指定類型的 Bean 時，才會將 Bean 加入 IOC 容器 @ConditionalOnMissingBean(HeaderConfig.class) public HeaderParser headerParser(){ return new HeaderParser(); } } 上例執行時呼叫該 Bean 會引發 NoSuchBeanDefinitionException 異常，因為 @Configuration 中有 @Component，所以會自動建立 HeaderConfig 的 Bean，因此不會建立 HeaderParser 的 Bean。\n@ConditionalOnProperty 判斷設定檔中存在對應屬性與值時，才會將 Bean 註冊到 IOC 容器。\n設定檔\n1 name: header 設定類\n1 2 3 4 5 6 7 8 9 10 11 @Configuration public class HeaderConfig { @Bean //設定檔中存在指定屬性名與值時，才會將 Bean 加入 IOC 容器 @ConditionalOnProperty(name =\u0026#34;name\u0026#34;,havingValue = \u0026#34;header\u0026#34;) public HeaderParser headerParser(){ return new HeaderParser(); } } 自訂起始依賴 例如自訂一個阿里雲 OSS 的起始依賴。\n首先是命名，SpringBoot 官方 Starter 命名為 spring-boot-starter-xxx，而第三方組織提供的則為 xxx-spring-boot-starter。\n然後是模組，需要按照規範定義兩個模組：\nStarter 模組，進行依賴管理，將程式開發所需的依賴都定義在 Starter 起始依賴中。 Autoconfigure 模組，用於自動配置。 定義好這兩個模組後，其他專案只需要引入起始依賴即可，自動配置模組會透過依賴傳遞引入。\n模組 POM 檔案 aliyun-oss-spring-boot-starter 模組\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.7.5\u0026lt;/version\u0026gt; \u0026lt;relativePath/\u0026gt; \u0026lt;!-- lookup parent from repository --\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;groupId\u0026gt;com.aliyun.oss\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;aliyun-oss-spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;java.version\u0026gt;11\u0026lt;/java.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!--引入autoconfigure模組--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.aliyun.oss\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;aliyun-oss-spring-boot-autoconfigure\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/project\u0026gt; aliyun-oss-spring-boot-autoconfigure 模組\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.7.5\u0026lt;/version\u0026gt; \u0026lt;relativePath/\u0026gt; \u0026lt;!-- lookup parent from repository --\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;groupId\u0026gt;com.aliyun.oss\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;aliyun-oss-spring-boot-autoconfigure\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;java.version\u0026gt;11\u0026lt;/java.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--引入Web起始依賴--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--Lombok--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--阿里雲OSS--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.aliyun.oss\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;aliyun-sdk-oss\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.15.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.xml.bind\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jaxb-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.3.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.activation\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;activation\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.1.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- no more than 2.3.3--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.glassfish.jaxb\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jaxb-runtime\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.3.3\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/project\u0026gt; 自動配置 AliOSSAutoConfiguration 類別\n1 2 3 4 5 6 7 8 9 10 11 12 13 @Configuration //匯入 AliOSSProperties 類別，並交給 Spring IOC 管理 @EnableConfigurationProperties(AliOSSProperties.class) public class AliOSSAutoConfiguration { //建立 AliOSSUtils 物件，並交給 Spring IOC 容器 @Bean public AliOSSUtils aliOSSUtils(AliOSSProperties aliOSSProperties){ AliOSSUtils aliOSSUtils = new AliOSSUtils(); aliOSSUtils.setAliOSSProperties(aliOSSProperties); return aliOSSUtils; } } AliOSSProperties 類別\n1 2 3 4 5 6 7 8 9 10 11 12 13 /*阿里雲 OSS 相關設定*/ @Data @ConfigurationProperties(prefix = \u0026#34;aliyun.oss\u0026#34;) public class AliOSSProperties { //區域 private String endpoint; //身份 ID private String accessKeyId ; //身份密鑰 private String accessKeySecret ; //儲存空間 private String bucketName; } AliOSSUtils 類別\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 @Data public class AliOSSUtils { private AliOSSProperties aliOSSProperties; /** * 實作上傳圖片到 OSS */ public String upload(MultipartFile multipartFile) throws IOException { // 取得上傳檔案的輸入流 InputStream inputStream = multipartFile.getInputStream(); // 避免檔案覆蓋 String originalFilename = multipartFile.getOriginalFilename(); String fileName = UUID.randomUUID().toString() + originalFilename.substring(originalFilename.lastIndexOf(\u0026#34;.\u0026#34;)); //上傳檔案到 OSS OSS ossClient = new OSSClientBuilder().build(aliOSSProperties.getEndpoint(), aliOSSProperties.getAccessKeyId(), aliOSSProperties.getAccessKeySecret()); ossClient.putObject(aliOSSProperties.getBucketName(), fileName, inputStream); //檔案存取路徑 String url =aliOSSProperties.getEndpoint().split(\u0026#34;//\u0026#34;)[0] + \u0026#34;//\u0026#34; + aliOSSProperties.getBucketName() + \u0026#34;.\u0026#34; + aliOSSProperties.getEndpoint().split(\u0026#34;//\u0026#34;)[1] + \u0026#34;/\u0026#34; + fileName; // 關閉 ossClient ossClient.shutdown(); return url;// 回傳上傳到 OSS 的路徑 } } 新建自動設定檔 META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports\n1 com.aliyun.oss.AliOSSAutoConfiguration 使用 引入依賴\n1 2 3 4 5 6 \u0026lt;!--引入阿里雲 OSS 起始依賴--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.aliyun.oss\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;aliyun-oss-spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 上例阿里雲 OSS 相關設定需要從設定檔讀取。\n1 2 3 4 5 6 7 #設定阿里雲 OSS 參數 aliyun: oss: endpoint: your_oss_region accessKeyId: your_key_id accessKeySecret: your_key_secret bucketName: your_bucker_name 測試\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 @RestController public class UploadController { @Autowired private AliOSSUtils aliOSSUtils; @PostMapping(\u0026#34;/upload\u0026#34;) public String upload(MultipartFile image) throws Exception { //上傳檔案到阿里雲 OSS String url = aliOSSUtils.upload(image); return url; } } ","date":"2025-01-23T15:06:36+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/223/","title":"Spring 自動配置與起始依賴"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 事務 事務是一組操作的集合，它是一個不可分割的工作單位，這些操作要嘛同時成功，要嘛同時失敗。\n操作：\n開啟事務 (一組操作開始前，開啟事務)：start transaction / begin 提交事務 (這組操作全部成功後，提交事務)：commit 回滾事務 (中間任何一個操作出現例外，回滾事務)：rollback 假設刪除部門後要繼續刪除該部門員工。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @Service public class DeptServiceImpl implements DeptService{ @Autowired private DeptMapper deptMapper; @Autowired private EmpMapper empMapper; @Override public void delete(Integer id）{ //1．刪除部門 deptMapper.delete(id); // 假如這裡出現錯誤，只刪除了部門，沒刪除員工 //2.根據部門id，刪除部門下的員工資訊 empMapper.deleteByDetId(id); } } 如上所示，將會留下不存在部門的員工，造成了資料的不一致。\nSpring 事務管理 註解：@Transactional，位置：Service 層方法、類別、介面上\n作用：將當前方法交給 Spring 進行事務管理，方法執行前開啟事務；成功執行完畢提交事務；出現例外回滾事務。\n上述方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @Service public class DeptServiceImpl implements DeptService{ @Autowired private DeptMapper deptMapper; @Autowired private EmpMapper empMapper; @Transactional // 交給Spring進行事務管理 @Override public void delete(Integer id）{ //1．刪除部門 deptMapper.delete(id); //2.根據部門id，刪除部門下的員工資訊 empMapper.deleteByDetId(id); } } 同時可以開啟事務管理日誌。\n1 2 3 4 #Spring事務管理日誌 logging: level: org.springframework.jdbc.support.JdbcTransactionManager: debug 事務屬性 - 回滾 預設情況下，只有出現執行期例外 (RuntimeException) 才回滾事務，透過 rollbackFor 屬性可以控制出現何種例外類型時，回滾事務。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @Service public class DeptServiceImpl implements DeptService{ @Autowired private DeptMapper deptMapper; @Autowired private EmpMapper empMapper; // 所有例外都回滾 @Transactional(rollbackFor = Exception.class) @Override public void delete(Integer id）{ //1．刪除部門 deptMapper.delete(id); //2.根據部門id，刪除部門下的員工資訊 empMapper.deleteByDetId(id); } } 事務屬性 - 傳播行為 事務傳播行為是指當一個事務方法被另一個事務方法呼叫時，這個事務方法應該如何進行事務。\n1 2 3 4 5 6 7 8 9 10 11 @Transactional public void a(){ // code userServices.b(); // code } @Transactional public void b(){ // code } 上述 a 呼叫了 b，b 該如何進行事務，加入 a 的事務或者單獨開一個事務。\n可以透過屬性 propagation 進行控制。\n屬性值 描述 REQUIRED (預設值) 需要事務，有則加入，無則建立新事務 REQUIRES_NEW 需要事務，無論有無都建立新事務 SUPPORTS 支援事務，有則加入，無則在無事務狀態執行 NOT_SUPPORTS 不支援事務，有事務則暫停，在無事務下執行 MANDATORY 必須有事務，否則拋出例外 NEVER 必須無事務，否則拋出例外 使用範例\n1 2 3 4 5 6 7 8 9 10 11 @Transactional public void a(){ // code userServices.b(); // code } @Transactional(propagation = Propagation.REQUIRES_NEW) public void b(){ // code } ","date":"2025-01-22T13:30:38+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/222/","title":"Spring 事務管理"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 Aspect-Oriented Programming (面向切面程式設計、面向方面程式設計) 是針對特定方法進行程式設計。\n動態代理是面向切面程式設計最主流的實作。而 SpringAOP 是 Spring 框架的高階技術，旨在管理 bean 物件的過程中，主要透過底層的動態代理機制，對特定的方法進行程式設計。\n統計方法執行時間 匯入依賴\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-aop\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 撰寫 AOP 程式，針對特定方法根據業務需求進行程式設計\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Slf4j @Component @Aspect // AOP類 public class TimeAspect { // 切入點表達式 @Around(\u0026#34;execution(* net.yexca.service.*.*(..))\u0026#34;) public Object recordTime(ProceedingJoinPoint proceedingJoinPoint) throws Throwable { long begin = System.currentTimeMillis(); // 呼叫原始方法 Object object = proceedingJoinPoint.proceed(); long end = System.currentTimeMillis(); log.info(proceedingJoinPoint.getSignature() + \u0026#34;方法執行時間：{}ms\u0026#34;, end-begin); return object; } } AOP 的應用場景有記錄操作日誌、權限控制、交易管理等\n核心概念 連結點：JoinPoint，可以被 AOP 控制的方法 (隱含方法執行時的相關資訊)\n通知：Advice，指哪些重複的邏輯，也就是共性功能 (最終體現為一個方法)\n切入點：PointCut，匹配連結點的條件，通知僅會在切入點方法執行時被應用\n切面：Aspect，描述通知與切入點的對應關係 (通知 + 切入點)\n目標物件：Target，通知所應用的物件\n上例中，未寫出的 Service 所有方法都是連結點，被切入點表達式選中的方法都是切入點，而 AOP 類別的 recordTime 方法為通知，註解 @Around 與通知共同為切面，而 TimeAspect 類別稱為切面類別\n通知 通知類型 @Around：環繞通知，此註解標註的通知方法在目標方法前、後都被執行\n@Before：前置通知，此註解標註的通知方法在目標方法前被執行\n@After：後置通知，此註解標註的通知方法在目標方法後被執行，無論是否有例外都會執行\n@AfterReturning：返回後通知，此註解標註的通知方法在目標方法後被執行，有例外不會執行\n@AfterThrowing：例外後通知，此註解標註的通知方法發生例外後執行\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 @Component @Aspect public class MyAspect { @Before(\u0026#34;execution(* net.yexca.service.impl.*(..))\u0026#34;) public void before(){ System.out.println(\u0026#34;Before\u0026#34;); } @Around(\u0026#34;execution(* net.yexca.service.impl.*(..))\u0026#34;) public Object around(ProceedingJoinPoint proceedingJoinPoint) throws Throwable { System.out.println(\u0026#34;Around before\u0026#34;); Object result = proceedingJoinPoint.proceed(); System.out.println(\u0026#34;Around after\u0026#34;); return result; } @After(\u0026#34;execution(* net.yexca.service.impl.*(..))\u0026#34;) public void after(){ System.out.println(\u0026#34;After\u0026#34;); } @AfterReturning(\u0026#34;execution(* net.yexca.service.impl.*(..))\u0026#34;) public void afterRetruning(){ System.out.println(\u0026#34;AfterReturning\u0026#34;); } @AfterThrowing(\u0026#34;execution(* net.yexca.service.impl.*(..))\u0026#34;) public void afterThrowing(){ System.out.println(\u0026#34;AfterThrowing\u0026#34;); } } @Around 環繞通知需要自己呼叫 ProceedingJoinPoint.proceed() 來讓原始方法執行，其他通知不需要考量目標方法執行\n@Around 環繞通知方法的回傳值，必須指定為 Object，來接收原始方法的回傳值\n上述的 5 個註解的切入點表達式都相同，可以提取，如下所示\n1 2 3 4 5 6 7 8 9 10 public class MyAspect { @Pointcut(\u0026#34;execution(* net.yexca.service.impl.*(..))\u0026#34;) public void pt(){} @Before(\u0026#34;pt()\u0026#34;) public void before(){ System.out.println(\u0026#34;Before\u0026#34;); } } 方法 pt() 若是 public 權限符，則可以在其他的類別中引用\n通知順序 當有多個切面的切入點都匹配到目標方法，目標方法執行時，多個通知方法都會被執行\n1 2 3 4 5 6 net: yexca: aop: - MyAspect1 - MyAspect2 - MyAspect3 假設三個 AOP 類別都選中了同一個方法，不同切面類別中，預設是按照切面類別名稱字母排序\n目標方法前的通知方法：字母排名靠前的先執行 目標方法後的通知方法：字母排名靠後的先執行 假設三個 AOP 類別都有 @Before 和 @After，執行順序為\n1 2 3 4 5 6 MyAspect1 before MyAspect2 before MyAspect3 before MyAspect3 after MyAspect2 after MyAspect1 after 可以使用 @Order(num) 註解加在切面類別上來控制順序，num 越小越先執行，@Before 和 @After 執行同上\n切入點表達式 描述切入點方法的一種表達式，主要用來決定專案中的哪些方法需要加入通知\n常見形式有 execution(...) 根據方法的簽章匹配和 annotation 根據註解匹配\nexecution 主要根據方法的回傳值、套件名稱、類別名稱、方法名稱、方法參數等資訊來匹配，語法為\n1 execution(存取修飾符 回傳值 套件名稱.類別名稱.方法名稱(方法參數) throws 例外) 其中存取修飾符、套件名稱.類別名稱、throws 例外可以省略，不過不建議省略套件名稱.類別名稱\n也可以使用萬用字元描述切入點\n*：單個獨立的任意符號，可以萬用任意回傳值、套件名稱、類別名稱、方法名稱、任意類型的一個參數，也可以萬用套件、類別、方法名稱的一部分 1 execution(* com.*.service.*.update*(*)) ..：多個連續的任意符號，可以萬用任意層級的套件，或任意類型、任意個數的參數 1 execution(* com.yexca..service.*(..)) 還可以使用 \u0026amp;\u0026amp;、||、! 來組合比較複雜的切入點表達式\n撰寫建議\n所有業務方法名稱在命名時盡量規範，方便切入點表達式快速匹配 描述切入點方法通常基於介面描述，而非實作類別，增強擴充性 在滿足業務需求的前提下，盡量縮小切入點的匹配範圍 @annotation @annotation 切入點表達式，用於匹配標示有特定註解的方法，使用需先自訂義註解\n1 2 3 4 @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.METHOD) public @interface MyLog { } 然後在方法上加入該註解，在 AOP 類別方法上\n1 @Before(\u0026#34;@annotation(net.yexca.aop.MyLog)\u0026#34;) 連結點 在 Spring 中用 JoinPoint 抽象化了連結點，用它可以取得方法執行時的相關資訊\n對於 @Around 通知，取得連結點資訊只能使用 ProceedingJoinPoint 對於其他四種通知，取得連結點資訊只能使用 JoinPoint，它是 ProceedingJoinPoint 的父類別 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public Object recordTime(ProceedingJoinPoint proceedingJoinPoint) throws Throwable { // 取得目標物件的類別名稱 String className = proceedingJoinPoint.getTarget().getClass().getName(); // 取得目標方法的方法名稱 String methodNAme = proceedingJoinPoint.getSignature().getName(); // 取得目標方法執行時傳入的參數 Object[] args = proceedingJoinPoint.getArgs(); // 呼叫原始方法 Object object = proceedingJoinPoint.proceed(); return object; } ","date":"2025-01-21T16:05:57+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/221/","title":"Spring AOP (面向切面程式設計)"},{"content":" 此頁面有使用機器翻譯喲\n音之所感系列\n歌曲名稱 翻譯 連結 僕が死のうと思ったのは 曾經我也想過一了百了 https://blog.yexca.net/zh-tw/archives/214 あくあ色ぱれっと aqua 的調色板 https://blog.yexca.net/zh-tw/archives/219 恋の押し売り 戀愛推銷 本文 17さいのうた 17 歲的歌曲 https://blog.yexca.net/zh-tw/archives/224 引言 其實早就翻譯了捏~(￣▽￣)~*\n歌曲影片 歌詞 ハートマーク作って\n畫個愛心的記號\n届け届け届け\n快一點、傳達到、你心裡\nきっと恋の押し売り\n這大概是戀愛的推銷\n好きで好きでごめん\n好喜歡，太喜歡，抱歉呀\n出会っちゃった！\n和你相遇了！\nときめいちゃった？ ときめく\n心跳加速了嗎？\n私だけ？ドキドキしてるの\n還是只有我？在砰砰心跳呢\nちゃんと気にかけて\n多多在意我啦\n私だけ！甘やかして\n只對我！好好寵愛吧\n(Ah)　君と話す理由欲しくて探している\n（啊）不斷尋找和你聊天的理由\n(なんで？)　強がっていても恋に負けちゃうんだね\n（為什麼？）就算裝作堅強，還是敗給了戀愛呀\nハートマーク作って\n畫個愛心的記號\n届け届け届け\n快一點、傳達到、你心裡\nきっと恋の押し売り\n這大概是戀愛的推銷\n好きで好きでごめん\n好喜歡，太喜歡，抱歉呀\nハートのレスください\n請回覆我的心意\n早く早く早くー！\n快一點、再快點、馬上做~！\nこれは恋の押し売り\n這可是戀愛的強制推銷\n返品なんてダメよ\n退貨？不可以！\n取られたくないんだよ…\n不想被搶走啊\u0026hellip;\n誰よりも可愛くなりたい\n想要變得比誰都可愛\n完全勝利して\n想完全勝利\n私だけって言わせてやる！\n讓你說出「只有我」！\n(Ah)　君の胸を狙う私の恋の銃口\n（啊）我的戀愛槍，瞄準著你的胸口\n(なんで？)　震えちゃうんだろう\n（為什麼？）會不由自主地顫抖呢\nいつか撃ち抜けるまで 撃ち抜く: うちぬく\n直到貫穿為止\nせーっの！BANG\n一、二、砰！\n期待させてよ\n讓我更加期待吧\nもっともっともっと\n多點、再多、更多\n私浮ついちゃって 浮つく: うわつく\n我有點飄飄然了\nバカだバカだごめん\n傻乎乎，真的是，抱歉呀\nハートは忙しくて\n心裡稍微有點忙\nあっちこっちどっちー？\n那裡？這裡？哪裡？\n今はまだまだプロローグ\n現在還只是序幕呢\n押して押して押すの\n按下去、快一點、去推進\n私、君に出会えて変わったの！\n我，和你遇見之後改變了！\nそりゃあ悩んじゃう事もあるけど…\n雖然也有會煩惱的時候。。。\nもっともっと可愛くなりたいって思うし\n但想要變得更加更加可愛\n何より君に好きって言ってもらいたい！\n沒有什麼比得上你對我說喜歡！\n笑顔の私(可愛い)\n笑著的我（可愛捏）\n泣いちゃう私(可愛い)\n哭著的我（可愛捏）\n怒った私(可愛い)\n生氣的我（可愛捏）\n恋する私…\n戀愛中的我。。。\n甘えさせてよ\n讓我撒嬌嘛\nずっとずっとずっと\n始終、一直、永遠\nきっと後悔させない\n一定不會讓你後悔的\nお願い　好きになって\n拜託了，喜歡我吧\nハートマーク作って\n畫一個愛心記號\n届け届け届け\n快一點、傳達到、你心裡\nきっと恋の押し売り\n大概是戀愛的小強推\n好きで好きでごめん\n喜歡你，超喜歡，抱歉呀\nハートのレスください\n請回覆我的心意\n早く早く早くー！\n快一點、再快點、馬上要！\nこれは恋の押し売り\n這可是戀愛的強制推銷\n返品なんてダメよ\n不可以、退貨哦\n","date":"2025-01-20T16:24:43+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/220/","title":"音之所感 - 《恋の押し売り》"},{"content":" 此頁面有使用機器翻譯喲\n音之所感系列\n歌曲名稱 翻譯 連結 僕が死のうと思ったのは 曾經我也想過一了百了 https://blog.yexca.net/zh-tw/archives/214 あくあ色ぱれっと aqua 的調色板 本文 恋の押し売り 戀愛推銷 https://blog.yexca.net/zh-tw/archives/220 17さいのうた 17 歲的歌曲 https://blog.yexca.net/zh-tw/archives/224 引言 第二首本來想選我的 2024 年度歌曲，不過不經意間聽到了 Aqua 的歌，便想到了這首，之前聽的時候只是中間的有一段和我的人生經歷有點類似，所以一直在聽，全曲認真翻譯後才知道染上 Aqua 顏色的梗從這裡來的啊（在 C105 聽到「想染上 aqua 的顏色的話」，還以為是來自《君色に染まる》）\n雖然經歷類似讓我開始慢慢聽上 Aqua 且慢慢喜歡上，但事實上我的「キミがいるから私　いつでも頑張れるんだ」是 Warma 捏，寫到這突然就意識到了一直在影響著我的到底是什麼了，以及如今是為何這樣，不過正如因這首歌的改變，當前的困惑也一定有契機可以化解\n我很克制得沒寫下去，畢竟是一首歡樂的歌，可以說對於偶像路線簡直是太絕了這首歌，同時用詞倒也不是太難（相對於外國人），是我都可以聽懂的程度（doge）\n因為我是去年（2024）接觸到 Aqua 的嘛，因為經常聽到這首歌（3D 直播），還以為是經歷了一些沉澱，然後出了這麼厲害的歌（因為一直在收聽榜第一），沒想到是出道即巔峰啊（《For the Win》是 bilibili 企劃的，暫且不記上），同時之後的歌曲，怎麼說呢，偶像類的都很好，可以說是直接讓我開始喜歡一些偶像風了，以此為契機，倒是喜歡上了偶像演唱會（雖然隨著 Aqua 的畢業也不怎麼感興趣了）\n同時，對比其他翻譯可能有出入，我的翻譯多數是有自己的感情吧，所以部分並不是歌詞本身的意思（事實上 上一首 也是），這個在可能下一个 2024 年度歌曲的翻譯中表現更明顯。我覺得如果只是照抄一個標準的翻譯多少沒啥意義，因為是真正熱愛的事物，多少想留存自己的特色 (染上我的色彩)\n最後捏，我也想染上 Aqua 的色彩捏，畢竟是我最愛的三個人之一 （C105 沒買到立牌真可惜了，結城的也沒買到（悲\n歌曲影片 歌詞 何をしても不器用で　何かとミスしてばっか\n什麼也做不到，做什麼都出錯\nダメダメな私だって\n一無是處的我\nできる事があるの\n也有可以做到的事喔\n凹んで悲しくたって　笑顔にしてあげるんだ 凹む: へこむ\n就算陷入低落，我也會讓你笑起來喔\nここにいるから　早く　私を見つけてね\n因為就在這裡，快一點，找到我吧\nLove You Love You, I love you\n愛你愛你，我愛你\nLove You Love You, Ah,I love you so much\n愛你愛你，我非常愛你\nLove You Love You, I love you\n愛你愛你，我愛你\nLove You Love You\n愛你愛你\n（あぁ　愛してもっと）\n(啊~，更加愛我吧)\nいつでも隣にいるし、いつでも一緒に笑える\n一直都陪在身邊，一直都一起歡笑\n私をたくさん知って　たくさん好きって言って\n多多了解我，多多對我說“喜歡”\nワガママで朝も苦手　ドジだし　ダメダメだけど\n任性也賴床，笨手笨腳還一無是處\nそれでも私の事を　見ててね\n就算那樣也請專注於我\n描く夢の未来へ続く\n向著描繪未來的路\n道をキミと歩けますように\n希望能和你一起走下去\nねぇもっと！好きになってもらいたいの！\n呐，想讓你多多喜歡我！\n頭の中は君ばっか！\n我的腦海裡只有你\nってゆーかそっぽなんて向いてないで！\n話說，別把頭轉開呀！\nあぁもう！ヤキモキしちゃうわ　Ah\n啊啊，真是的！急死人了\nずっとずっと好きがいいの\n一直一直喜歡下去吧\n心の奥もトキメイちゃうくらい\n內心深處都怦然心動的程度\nこっち向いててよね　ダーリン？\n看看我嘛，親愛的？\nあぁもう離さないから、絶対に！\n啊~，再也不會放開你，絕對不會！\nLove You Love You, I love you\n愛你愛你，我愛你\nLove You Love You\n愛你愛你\n（あぁ　愛してもっと）\n(啊~，多多愛我吧)\nキミがいるから私　いつでも頑張れるんだ\n因為有你在身邊，我才能努力下去\n落ち込んで悲しくたって　キミがいるから\u0026hellip;\n就算低落悲傷，因為有你在身邊。。。\nキミがいるから　歩いてこれた\n正因為有你在，我才能走到今天\nキミがいなくちゃ　前も見れない\n如果沒有你，我連前方也看不清\n嫌な事とか辛い事とかあったって\n即使有討厭的，痛苦的事\nキミの力でここまで笑ってこれたんだ\n有你的力量就可以笑著走到現在\n今度はもっと私がぐっとひっぱって　連れて行くんだ\n這次我會更加努力拉著你，一起走下去\nキミがいるから私がいるの\n因為有你在，我才能到這\nこんな私を　愛してくれる？\n你願意愛上這樣的我嗎？\nねぇもっと　ねぇもっと\n呐，多一點，再多點\nまだもっと　受け止めてよね！ねぇいい？\n更多地接受我吧！可以嗎？\nさぁ声を上げて！\n那麼，大聲地說出來吧！\nねぇもっと　ねぇもっと\n呐，多一點，再多點\n好きになってもらいたいの\n想讓你喜歡上我\nいつでも　そう私ばっか みたいにそっぽなんて向かせないわ\n無論何時，我都不允許你把目光移開，只讓我在你心裡\nね、ほら夢中にしちゃうわ　Ah\n呐，看到了吧，已經沉迷了呢~\nずっとずっと好きがいいの！心も体も染まっちゃうくらいに\n一直一直喜歡下去吧，直到你的身心都染上我的色彩\nこっち向いててよねダーリン?\n看向這邊呀，親愛的？\nあぁもう離さないから、絶対に　絶体ね　絶体よ　約束だよ\n啊~，我不會放開你，一定不會、肯定不會、絕對不會，約好了喔\n（あぁ 愛してもっと）\n(啊~，更多地愛我吧)\n","date":"2025-01-20T00:16:48+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/219/","title":"音之所感 - 《あくあ色ぱれっと》"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 會話技術 會話：使用者開啟瀏覽器，造訪網頁伺服器的資源，會話建立，直到有一方中斷連線，會話結束。在一次會話中可以包含多次請求與回應。\n會話追蹤：一種維護瀏覽器狀態的方法，伺服器需要辨識多次請求是否來自同一個瀏覽器，以便在同一次會話的多個請求之間共享資料。\n會話追蹤方案：\n用戶端會話追蹤技術：Cookie 伺服器端會話追蹤技術：Session 權杖技術 Cookie Cookie 是 HTTP 協定支援的技術，在瀏覽器第一次造訪時，伺服器端請求標頭中設定 Cookie Set-Cookie: your_cookie，瀏覽器會自動將 Cookie 儲存在本機，並在下次造訪時自動在請求標頭中加入 Cookie Cookie: your_cookie。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 @RestController public class SessionController { // 設定 Cookie @GetMapping(\u0026#34;/c1\u0026#34;) public Result cookie1(HttpServletResponse response){ response.addCookie(new Cookie(\u0026#34;login_name\u0026#34;, \u0026#34;yexca\u0026#34;)); return Result.success(); } // 取得 Cookie @GetMapping(\u0026#34;/c2\u0026#34;) public Result cookie2(HttpServletRequest request){ Cookie[] cookies = request.getCookies(); for (Cookie c : cookies){ if(c.getName().equals(\u0026#34;login_name\u0026#34;)){ System.out.println(\u0026#34;login_name:\u0026#34;+c.getValue()); } } return Result.success(); } } 不過行動裝置不能使用 Cookie，並且 Cookie 無法跨網域。\n相同網域：相同協定、IP/網域名稱、連接埠\nSession 基於 Cookie 實作，在瀏覽器第一次請求時產生一個 Session，然後在回應標頭傳回 Session 的 ID Set-Cookie: JSESSIONID=session_id，然後瀏覽器在下次請求時自動帶上該 ID。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 @RestController public class SessionController { // 將值儲存到 HttpSession 中 @GetMapping(\u0026#34;/s1\u0026#34;) public Result session1(HttpSession session){ log.info(\u0026#34;HttpSession_set:{}\u0026#34;, session.hashCode()); session.setAttribute(\u0026#34;login_user\u0026#34;,\u0026#34;yexca\u0026#34;); return Result.success(); } // 從 HttpSession 中取得值 @GetMapping(\u0026#34;/s2\u0026#34;) public Result session2(HttpServletRequest request){ HttpSession session = request.getSession(); log.info(\u0026#34;HttpSession_get:{}\u0026#34;, session.hashCode()); Object loginUser = session.getAttribute(\u0026#34;login_user\u0026#34;); log.info(\u0026#34;loginUser:{}\u0026#34;, loginUser); return Result.success(); } } Session 的問題在於，如果伺服器端使用負載平衡，亦即有多台伺服器端，如果第一次回應的是伺服器一，而第二次回應的是伺服器二，由於伺服器二沒有 Session，所以無法使用。\nJWT 權杖 權杖技術支援 PC 端、行動裝置，可以解決叢集環境下的身分驗證問題，減輕伺服器端儲存壓力，但需要自行實作。\nJWT 全稱 JSON Web Token，官方網站： https://jwt.io/ ，定義了一種簡潔、自包含的格式，用於在通訊雙方以 JSON 資料格式安全地傳輸資訊。由於數位簽章的存在，這些資訊是可靠的。\n組成：\n第一部分：標頭（Header），記錄權杖類型、簽章演算法等 第二部分：酬載（Payload，有效載荷），記錄一些自訂資訊、預設資訊等 第三部分：簽章（Signature），防止權杖被篡改、確保安全性。將標頭（Header）、酬載（Payload）和指定金鑰，透過指定簽章演算法計算而來。 引入依賴項\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.jsonwebtoken\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jjwt\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.9.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 產生與解析\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class WebApplicationTests { // JWT 產生 @Test public void jwtGenTest(){ Map\u0026lt;String,Object\u0026gt; claims = new HashMap\u0026lt;\u0026gt;(); claims.put(\u0026#34;id\u0026#34;, \u0026#34;233\u0026#34;); claims.put(\u0026#34;user\u0026#34;, \u0026#34;yexca\u0026#34;); String jwt = Jwts.builder() .signWith(SignatureAlgorithm.HS256, \u0026#34;yexca\u0026#34;) // 簽章演算法 .setClaims(claims) //自訂內容(酬載) .setExpiration(new Date(System.currentTimeMillis() + 3600 * 1000)) // 有效期為 1 小時 .compact(); System.out.println(jwt); } // 輸出 // eyJhbGciOiJIUzI1NiJ9.eyJpZCI6IjIzMyIsImV4cCI6MTcwMjc5NzA4OCwidXNlciI6InlleGNhIn0.BqZDxEddGN4g4GyyfvkOtKYv7DVlIF6cWY9PGW2RbUU // JWT 解析 @Test public void jwtParseTest(){ Claims claims = Jwts.parser() .setSigningKey(\u0026#34;yexca\u0026#34;) // 金鑰 .parseClaimsJws(\u0026#34;eyJhbGciOiJIUzI1NiJ9.eyJpZCI6IjIzMyIsImV4cCI6MTcwMjc5NzA4OCwidXNlciI6InlleGNhIn0.BqZDxEddGN4g4GyyfvkOtKYv7DVlIF6cWY9PGW2RbUU\u0026#34;) .getBody(); // 取得第二部分 System.out.println(claims); } // 輸出 // {id=233, exp=1702797088, user=yexca} } 登入驗證 過濾器 (Filter) 過濾器是早期 JavaWeb 三大元件 (Servlet, Filter, Listener) 之一。過濾器可以將對資源的請求攔截下來，進而實現一些特殊的功能，例如登入驗證、統一編碼處理、敏感字元處理等。\n快速入門 建立過濾器類別\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 @WebFilter(urlPatterns = \u0026#34;/*\u0026#34;) // 攔截路徑 public class DemoFilter implements Filter { @Override public void init(FilterConfig filterConfig) throws ServletException { // Filter.super.init(filterConfig); System.out.println(\u0026#34;過濾器初始化\u0026#34;); } @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { System.out.println(\u0026#34;過濾器攔截\u0026#34;); // 放行 filterChain.doFilter(servletRequest, servletResponse); } @Override public void destroy() { // Filter.super.destroy(); System.out.println(\u0026#34;過濾器銷毀\u0026#34;); } } 在 Application 上加上註解\n1 2 @ServletComponentScan // 開啟了對 servlet 元件的支援 @SpringBootApplication 攔截路徑 可以根據需求調整，以下為範例\n攔截類型 urlPatterns 涵義 攔截特定路徑 /login 只有造訪 /login 才會被攔截 目錄攔截 /emps/* 造訪 /emps 下所有資源都會被攔截，/emps 也會被攔截 攔截所有 /* 造訪所有資源都會被攔截 單個過濾器執行邏輯 瀏覽器發送請求 -\u0026gt; 請求被攔截 -\u0026gt; 執行放行前邏輯 -\u0026gt; 放行 -\u0026gt; 執行放行後邏輯 -\u0026gt; 瀏覽器收到回應\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 @WebFilter(urlPatterns = \u0026#34;/*\u0026#34;) // 攔截路徑 public class DemoFilter implements Filter { @Override public void init(FilterConfig filterConfig) throws ServletException { // Filter.super.init(filterConfig); System.out.println(\u0026#34;過濾器初始化\u0026#34;); } @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { System.out.println(\u0026#34;過濾器攔截，放行前邏輯\u0026#34;); // 放行 filterChain.doFilter(servletRequest, servletResponse); System.out.println(\u0026#34;過濾器攔截，放行後邏輯\u0026#34;); } @Override public void destroy() { // Filter.super.destroy(); System.out.println(\u0026#34;過濾器銷毀\u0026#34;); } } 過濾器鏈 一個網頁應用程式中，可以設定多個過濾器，這些過濾器就形成了一個過濾器鏈。\n順序：註解設定的過濾器優先級是透過過濾器類別名稱的自然排序。\n邏輯：瀏覽器發送請求 -\u0026gt; 請求被 A 攔截 -\u0026gt; 執行 A 放行前邏輯 -\u0026gt; A 放行 -\u0026gt; 請求被 B 攔截 -\u0026gt; 執行 B 放行前邏輯 -\u0026gt; B 放行 -\u0026gt; 執行 B 放行後邏輯 -\u0026gt; 執行 A 放行後邏輯 -\u0026gt; 瀏覽器收到回應\n登入驗證 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 @Slf4j @WebFilter(urlPatterns = \u0026#34;/*\u0026#34;) public class LoginCheckFilter implements Filter { @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { HttpServletRequest request = (HttpServletRequest) servletRequest; HttpServletResponse response = (HttpServletResponse) servletResponse; // 取得請求 URL String requestURI = request.getRequestURI(); log.info(\u0026#34;請求 URL：{}\u0026#34;,requestURI); // 判斷是否有login if(requestURI.contains(\u0026#34;login\u0026#34;)){ log.info(\u0026#34;登入操作，放行\u0026#34;); filterChain.doFilter(servletRequest, servletResponse); return; // 因為登入操作不需要以下邏輯 } // 非登入操作，取得權杖 String jwt = request.getHeader(\u0026#34;token\u0026#34;); // 判斷權杖是否有效 if(!StringUtils.hasLength(jwt)){ log.info(\u0026#34;請求標頭 token 為空\u0026#34;); // 將物件轉換為 JSON Result error = Result.error(\u0026#34;NOT_LOGIN\u0026#34;); String notLogin = JSONObject.toJSONString(error); response.getWriter().write(notLogin); return; } // 驗證權杖 try { JwtUtils.parseJWT(jwt); }catch (Exception e){ e.printStackTrace(); log.info(\u0026#34;解析權杖失敗\u0026#34;); // 將物件轉換為 JSON Result error = Result.error(\u0026#34;NOT_LOGIN\u0026#34;); String notLogin = JSONObject.toJSONString(error); response.getWriter().write(notLogin); return; } // 放行 log.info(\u0026#34;權杖合法，放行\u0026#34;); filterChain.doFilter(servletRequest,servletResponse); } } 攔截器 (Interceptor) 快速入門 建立攔截器\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 @Component public class LoginCheckInterceptor implements HandlerInterceptor { @Override // 目標方法執行前執行，傳回 true 放行，false 不放行 public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { // return HandlerInterceptor.super.preHandle(request, response, handler); System.out.println(\u0026#34;preHandle\u0026#34;); return true; } @Override // 目標方法執行後執行 public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { // HandlerInterceptor.super.postHandle(request, response, handler, modelAndView); System.out.println(\u0026#34;postHandle\u0026#34;); } @Override // 檢視彩現完成後執行，最後執行 public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { // HandlerInterceptor.super.afterCompletion(request, response, handler, ex); System.out.println(\u0026#34;afterCompletion\u0026#34;); } } 建立設定\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 @Configuration // 設定類別 public class WebConfig implements WebMvcConfigurer { @Autowired private LoginCheckInterceptor loginCheckInterceptor; @Override public void addInterceptors(InterceptorRegistry registry) { // WebMvcConfigurer.super.addInterceptors(registry); registry.addInterceptor(loginCheckInterceptor).addPathPatterns(\u0026#34;/**\u0026#34;).excludePathPatterns(\u0026#34;/login\u0026#34;); } } 攔截路徑 路徑 涵義 例子 /* 一層路徑 /emps, /login 不能匹配 /emps/1 /** 任意層級路徑 /emps, /emps/1, /emps/1/2 /emps/* /emps 下的一層路徑 /emps/1 不能匹配 /emps, /emps/1/2 /emps/** /emps 下的任意層級路徑 /emps, /emps/1, /emps/1/2 攔截流程 如果同時存在過濾器和攔截器\n瀏覽器造訪 -\u0026gt; 過濾器放行前邏輯 -\u0026gt; 過濾器放行 -\u0026gt; DispatcherServlet -\u0026gt; Interceptor preHandle -\u0026gt; Controller -\u0026gt; postHandle -\u0026gt; afterCompletion -\u0026gt; DispatcherServlet -\u0026gt; 過濾器放行後邏輯 -\u0026gt; 回應瀏覽器\n過濾器會攔截所有的請求，而攔截器只會攔截 Spring 環境中的資源。\n登入驗證 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 @Slf4j @Component public class LoginCheckInterceptor implements HandlerInterceptor { @Override // 目標方法執行前執行，傳回 true 放行，false 不放行 public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { // return HandlerInterceptor.super.preHandle(request, response, handler); System.out.println(\u0026#34;preHandle\u0026#34;); // 取得請求 URL String requestURI = request.getRequestURI(); log.info(\u0026#34;請求 URL：{}\u0026#34;,requestURI); // 判斷是否有login if(requestURI.contains(\u0026#34;login\u0026#34;)){ log.info(\u0026#34;登入操作，放行\u0026#34;); return true; } // 非登入操作，取得權杖 String jwt = request.getHeader(\u0026#34;token\u0026#34;); // 判斷權杖是否有效 if(!StringUtils.hasLength(jwt)){ log.info(\u0026#34;請求標頭 token 為空\u0026#34;); // 將物件轉換為 JSON Result error = Result.error(\u0026#34;NOT_LOGIN\u0026#34;); String notLogin = JSONObject.toJSONString(error); response.getWriter().write(notLogin); return false; } // 驗證權杖 try { JwtUtils.parseJWT(jwt); }catch (Exception e){ e.printStackTrace(); log.info(\u0026#34;解析權杖失敗\u0026#34;); // 將物件轉換為 JSON Result error = Result.error(\u0026#34;NOT_LOGIN\u0026#34;); String notLogin = JSONObject.toJSONString(error); response.getWriter().write(notLogin); return false; } // 放行 log.info(\u0026#34;權杖合法，放行\u0026#34;); return true; } @Override // 目標方法執行後執行 public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { // HandlerInterceptor.super.postHandle(request, response, handler, modelAndView); System.out.println(\u0026#34;postHandle\u0026#34;); } @Override // 檢視彩現完成後執行，最後執行 public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { // HandlerInterceptor.super.afterCompletion(request, response, handler, ex); System.out.println(\u0026#34;afterCompletion\u0026#34;); } } ","date":"2025-01-16T23:06:20+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/218/","title":"JWT 登入驗證"},{"content":" 📢 本文由 gemini-3-pro 翻譯 初識 MQ 同步調用 微服務間基於 Feign 的呼叫屬於同步方式，存在一些問題。\n例如要開發一個支付服務，需要加入訂單服務和倉儲服務的程式碼，後期若要加入簡訊服務、積分服務等都需要修改支付程式碼，違反了 開放-封閉原則 ，並且在請求返回前無法做其他事情也會造成效能的浪費。\n問題： 耦合度高、效能下降、資源浪費、級聯失敗 (若提供者出現問題，所有呼叫方也會跟著出問題，如同骨牌效應，迅速導致整個微服務群故障)。\n非同步調用方案 非同步 (Asynchronous) 調用常見實現就是事件驅動模式。\n使用者支付請求 -\u0026gt; 支付服務 -\u0026gt; Broker，之後支付服務完成並回應，然後由 Broker 通知訂單服務、倉儲服務和簡訊服務。\n優點： 服務解耦、效能提升、吞吐量提高、服務沒有強依賴、故障隔離、流量削峰。 缺點： 依賴於 Broker 的可靠性、安全性、吞吐能力，架構變複雜了，業務沒有明顯的流程線，不好追蹤管理。 MQ MessageQueue，訊息佇列，字面意思為存放訊息的佇列，也就是事件驅動架構中的 Broker。\nRabbitMQ ActiveMQ RocketMQ Kafka 公司/社群 Rabbit Apache 阿里 (Alibaba) Apache 開發語言 Erlang Java Java Scala \u0026amp; Java 協定支援 AMQP，XMPP，SMTP，STOMP OpenWire, STOMP，REST, XMPP, AMQP 自定義協定 自定義協定 可用性 高 一般 高 高 單機吞吐量 一般 差 高 非常高 訊息延遲 微秒級 毫秒級 毫秒級 毫秒以內 訊息可靠性 高 一般 高 一般 追求可用性： Kafka、RocketMQ、RabbitMQ 追求可靠性： RabbitMQ、RocketMQ 追求吞吐能力： RocketMQ、Kafka 追求訊息低延遲： RabbitMQ、Kafka 安裝 RabbitMQ 可以從 官網 看到多種安裝方式，我使用 Docker 線上拉取。\n1 docker pull rabbitmq:3-management 執行指令：\n1 2 3 4 5 6 7 8 9 docker run \\ -e RABBITMQ_DEFAULT_USER=admin \\ -e RABBITMQ_DEFAULT_PASS=admin \\ --name mq \\ --hostname mq1 \\ -p 15672:15672 \\ -p 5672:5672 \\ -d \\ rabbitmq:3-management 訪問 \u0026lt;localhost:15672\u0026gt; 即可打開管理介面。RabbitMQ 中的一些概念：\nchannel： 操作 MQ 的工具 exchange： 交換機，路由訊息到佇列中 queue： 佇列，儲存訊息 virtualHost： 虛擬主機，是對 queue、exchange 等資源的邏輯分組 訊息模型 在 官網提供了多種 Demo ，對應了不同的訊息模型：\n基本訊息佇列 (BasicQueue)： \u0026ldquo;Hello World!\u0026rdquo; 工作訊息佇列 (WorkQueue)： Work Queues 發佈訂閱模型： Fanout Exchange：廣播 Publish/Subscribe Direct Exchange：路由 Routing Topic Exchange：主題 Topics Hello World Publisher -\u0026gt; Queue -\u0026gt; Consumer\npublisher： 訊息發佈者，將訊息發送到佇列 queue queue： 訊息佇列，負責接受並快取訊息 consumer： 訂閱佇列，處理佇列中的訊息 發佈者\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 public class PublisherTest { @Test public void testSendMessage() throws IOException, TimeoutException { // 1.建立連線 ConnectionFactory factory = new ConnectionFactory(); // 1.1.設定連線參數，分別是：主機名、連接埠號、vhost、使用者名稱、密碼 factory.setHost(\u0026#34;localhost\u0026#34;); factory.setPort(5672); factory.setVirtualHost(\u0026#34;/\u0026#34;); factory.setUsername(\u0026#34;admin\u0026#34;); factory.setPassword(\u0026#34;admin\u0026#34;); // 1.2.建立連線 Connection connection = factory.newConnection(); // 2.建立通道 Channel Channel channel = connection.createChannel(); // 3.建立佇列 String queueName = \u0026#34;hello.queue\u0026#34;; channel.queueDeclare(queueName, false, false, false, null); // 4.發送訊息 String message = \u0026#34;hello, rabbitmq!\u0026#34;; channel.basicPublish(\u0026#34;\u0026#34;, queueName, null, message.getBytes()); System.out.println(\u0026#34;發送訊息成功：【\u0026#34; + message + \u0026#34;】\u0026#34;); // 5.關閉通道和連線 channel.close(); connection.close(); } } 接收者\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 public class ConsumerTest { public static void main(String[] args) throws IOException, TimeoutException { // 1.建立連線 ConnectionFactory factory = new ConnectionFactory(); // 1.1.設定連線參數，分別是：主機名、連接埠號、vhost、使用者名稱、密碼 factory.setHost(\u0026#34;localhost\u0026#34;); factory.setPort(5672); factory.setVirtualHost(\u0026#34;/\u0026#34;); factory.setUsername(\u0026#34;admin\u0026#34;); factory.setPassword(\u0026#34;admin\u0026#34;); // 1.2.建立連線 Connection connection = factory.newConnection(); // 2.建立通道 Channel Channel channel = connection.createChannel(); // 3.建立佇列 String queueName = \u0026#34;hello.queue\u0026#34;; channel.queueDeclare(queueName, false, false, false, null); // 4.訂閱訊息 channel.basicConsume(queueName, true, new DefaultConsumer(channel){ @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException { // 5.處理訊息 String message = new String(body); System.out.println(\u0026#34;接收到訊息：【\u0026#34; + message + \u0026#34;】\u0026#34;); } }); System.out.println(\u0026#34;等待接收訊息。。。。\u0026#34;); } } 控制台輸出：\n1 2 等待接收訊息。。。。 接收到訊息：【hello, rabbitmq!】 顯然這種方式略顯繁瑣。\nSpringAMQP SpringAMQP 是基於 RabbitMQ 封裝的一套模板，並且還利用 SpringBoot 對其實現了自動配置 (Auto-configuration)，使用起來非常方便。\nAMQP\nAdvanced Message Queuing Protocol，是用於在應用程式之間傳遞業務訊息的開放標準。該協定與語言和平台無關，更符合微服務中獨立性的要求。\nSpring AMQP\nSpring AMQP 是基於 AMQP 協定定義的一套 API 規範，提供了模板來發送和接收訊息。包含兩部分，其中 spring-amqp 是基礎抽象，spring-rabbit 是底層的預設實現。\n它可以自動宣告佇列、交換機及其綁定關係，基於註解 (Annotation) 的監聽器模式，非同步接收訊息。\nBasic Queue 簡單佇列模型 首先在父專案 (Parent Project) 中引入依賴：\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-amqp\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; publisher 訊息發送 設定 application.yml：\n1 2 3 4 5 6 7 spring: rabbitmq: host: localhost # 主機名 port: 5672 # 連接埠 virtual-host: / # 虛擬主機 username: admin # 使用者名稱 password: admin # 密碼 利用 RabbitTemplate 實現訊息發送：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @RunWith(SpringRunner.class) @SpringBootTest public class SpringamqpTest { @Autowired private RabbitTemplate rabbitTemplate; @Test public void testSimpleQueue(){ // 佇列名 String queueName = \u0026#34;hello.queue\u0026#34;; // 訊息 String msg = \u0026#34;Hello Spring ampq\u0026#34;; // 發送 rabbitTemplate.convertAndSend(queueName,msg); } } consumer 訊息接收 設定 application.yml 同上：\n1 2 3 4 5 6 7 spring: rabbitmq: host: localhost # 主機名 port: 5672 # 連接埠 virtual-host: / # 虛擬主機 username: admin # 使用者名稱 password: admin # 密碼 建立一個新類別 SpringRabbitListener：\n1 2 3 4 5 6 7 @Component public class SpringRabbitListener { @RabbitListener(queues = \u0026#34;hello.queue\u0026#34;) public void listenSimpleQueue(String msg){ System.out.println(\u0026#34;接收的訊息為：\u0026#34; + msg); } } WorkQueue 工作訊息佇列 也稱 TaskQueue，任務模型，可以提高訊息處理速度，避免佇列訊息堆積。\nPublisher -\u0026gt; Queue -\u0026gt; Consumer1 and Consumer2 and \u0026hellip;\npublisher 訊息發送 定義一個方法，每秒發送 50 條訊息：\n1 2 3 4 5 6 7 8 9 10 11 12 public class SpringamqpTest { @Test public void testWorkQueue() throws InterruptedException { String queueName = \u0026#34;hello.queue\u0026#34;; String msg = \u0026#34;Hello Spring ampq...\u0026#34;; for (int i = 0; i \u0026lt; 50; i++) { rabbitTemplate.convertAndSend(queueName, msg + i); // 睡眠20毫秒，1秒發50條訊息 Thread.sleep(20); } } } consumer 訊息接收 建立兩個消費者綁定同一佇列：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @Component public class SpringRabbitListener { @RabbitListener(queues = \u0026#34;hello.queue\u0026#34;) public void listenSimpleQueue1(String msg) throws InterruptedException { System.out.println(\u0026#34;1接收的訊息為：\u0026#34; + msg); // 每秒處理40條訊息 Thread.sleep(25); } @RabbitListener(queues = \u0026#34;hello.queue\u0026#34;) public void listenSimpleQueue2(String msg) throws InterruptedException { // 使用err輸出紅色訊息 System.err.println(\u0026#34;2接收的訊息為：\u0026#34; + msg); // 每秒處理5條訊息 Thread.sleep(200); } } 測試 先運行接收者，而後運行發送者發送訊息。\n從輸出結果可以看到，兩個接收者各接收一半的訊息，也就是說訊息是平均分配給每個消費者，並沒有考慮到消費者的處理能力。這樣顯然是有問題的。\nprefetch 修改 application.yml 檔案，設定 prefetch 這個值，可以控制預取訊息的上限 (預設無限)。\n1 2 3 4 5 6 7 8 9 10 11 spring: rabbitmq: host: localhost # 主機名 port: 5672 # 連接埠 virtual-host: / # 虛擬主機 username: admin # 使用者名稱 password: admin # 密碼 listener: simple: # 每次只能獲取一條訊息，處理完成才能獲取下一個訊息 prefetch: 1 再次測試可以發現執行效率提高。\n發佈訂閱模型 發佈訂閱模式加入了交換機 (Exchange)，允許將同一個訊息發送給全部接收者。\nPublisher -\u0026gt; Exchange -\u0026gt; Queue1 and Queue2\nQueue1 -\u0026gt; Consumer1 and Consumer2\nQueue2 -\u0026gt; Consumer3\n常見的 exchange 有：\nFanout： 廣播 Direct： 路由 Topic： 主題 exchange 負責路由，並不儲存，一旦路由失敗則訊息遺失。\nFanout (扇出) 廣播 Fanout exchange 會將接收到的訊息廣播到每一個和其綁定的 queue。\n在接收者建立一個配置類別，宣告佇列與交換機：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 @Configuration public class FanoutConfig { /** * 宣告交換機 * @return */ @Bean public FanoutExchange fanoutExchange(){ return new FanoutExchange(\u0026#34;hello.fanout\u0026#34;); } /** * 第一個佇列 * @return */ @Bean public Queue fanoutQueue1(){ return new Queue(\u0026#34;fanout.queue1\u0026#34;); } /** * 綁定第一個佇列與交換機 * @param fanoutQueue1 * @param fanoutExchange * @return */ @Bean public Binding bindingQueue1(Queue fanoutQueue1, FanoutExchange fanoutExchange){ return BindingBuilder.bind(fanoutQueue1).to(fanoutExchange); } /** * 第二個佇列 * @return */ @Bean public Queue fanoutQueue2(){ return new Queue(\u0026#34;fanout.queue2\u0026#34;); } /** * 綁定第二個佇列與交換機 * @param fanoutQueue2 * @param fanoutExchange * @return */ @Bean public Binding bindingQueue2(Queue fanoutQueue2, FanoutExchange fanoutExchange){ return BindingBuilder.bind(fanoutQueue2).to(fanoutExchange); } } 訊息發送：\n1 2 3 4 5 6 7 8 9 10 public class SpringamqpTest { @Test public void testFanoutExchange(){ // 交換機 String exchangeName = \u0026#34;hello.fanout\u0026#34;; // 訊息 String msg = \u0026#34;hello, everyone\u0026#34;; rabbitTemplate.convertAndSend(exchangeName,\u0026#34;\u0026#34;,msg); } } 其中中間空著的 routingkey 在下兩個模型使用。\n訊息的接收：\n1 2 3 4 5 6 7 8 9 10 11 @Component public class SpringRabbitListener { @RabbitListener(queues = \u0026#34;fanout.queue1\u0026#34;) public void listenFanoutQueue1(String msg){ System.out.println(\u0026#34;Fanout1 接收訊息：\u0026#34; + msg); } @RabbitListener(queues = \u0026#34;fanout.queue2\u0026#34;) public void listenFanoutQueue2(String msg){ System.out.println(\u0026#34;Fanout2 接收訊息：\u0026#34; + msg); } } Direct 路由 Direct Exchange 會將接收到的訊息根據規則路由到指定的 Queue，因此稱為路由模式。\n佇列與交換機的綁定要指定一個 Routingkey，發送方發訊息時也必須指定訊息的 Routingkey，只有佇列的 Routingkey 和訊息的 Routingkey 完全一致，才會接收到訊息。\n在此使用基於註解宣告佇列和交換機，不需要配置類別：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 @Component public class SpringRabbitListener { @RabbitListener(bindings = @QueueBinding( value = @Queue(name = \u0026#34;direct.queue1\u0026#34;), // exchange = @Exchange(name = \u0026#34;hello.direct\u0026#34;, type = ExchangeTypes.DIRECT), // 因為預設為 Direct 類型，可以不用指定 exchange = @Exchange(name = \u0026#34;hello.direct\u0026#34;), key = {\u0026#34;red\u0026#34;,\u0026#34;warma\u0026#34;} )) public void listenDirectQueue1(String msg){ System.out.println(\u0026#34;1 接收訊息：\u0026#34; + msg); } @RabbitListener(bindings = @QueueBinding( value = @Queue(name = \u0026#34;direct.queue2\u0026#34;), exchange = @Exchange(name = \u0026#34;hello.direct\u0026#34;), key = {\u0026#34;red\u0026#34;,\u0026#34;aqua\u0026#34;} )) public void listenDirectQueue2(String msg){ System.out.println(\u0026#34;2 接收訊息：\u0026#34; + msg); } } 發送者：\n1 2 3 4 5 6 7 8 9 10 public class SpringamqpTest { @Test public void testDirectExchange(){ // 交換機 String exchangeName = \u0026#34;hello.direct\u0026#34;; // 訊息 String msg = \u0026#34;hello, aqua\u0026#34;; rabbitTemplate.convertAndSend(exchangeName,\u0026#34;aqua\u0026#34;,msg); } } 上例只有接收者 2 可以接收到訊息，若 routingkey 為 red 則兩個都能接收到訊息。\nTopic 主題 TopicExchange 與 DirectExchange 類似，區別在於 routingKey 必須是多個單字的列表，並且以 . 分割。\nQueue 與 Exchange 指定 BindingKey 時可以使用萬用字元：\n#：匹配一個或多個單字 *：只匹配一個單字 接收者：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @Component public class SpringRabbitListener { @RabbitListener(bindings = @QueueBinding( value = @Queue(\u0026#34;topic.queue1\u0026#34;), exchange = @Exchange(name = \u0026#34;hello.topic\u0026#34;, type = ExchangeTypes.TOPIC), key = \u0026#34;#.news\u0026#34; )) public void listenTopicQueue1(String msg){ System.out.println(\u0026#34;1 接受訊息：\u0026#34; + msg); } @RabbitListener(bindings = @QueueBinding( value = @Queue(\u0026#34;topic.queue2\u0026#34;), exchange = @Exchange(name = \u0026#34;hello.topic\u0026#34;, type = ExchangeTypes.TOPIC), key = \u0026#34;china.#\u0026#34; )) public void listenTopicQueue2(String msg){ System.out.println(\u0026#34;2 接受訊息：\u0026#34; + msg); } } 訊息發送：\n1 2 3 4 5 6 7 8 9 10 public class SpringamqpTest { @Test public void testTopicExchange(){ // 交換機 String exchangeName = \u0026#34;hello.topic\u0026#34;; // 訊息 String msg = \u0026#34;news for China\u0026#34;; rabbitTemplate.convertAndSend(exchangeName,\u0026#34;china.news\u0026#34;,msg); } } 上例 1 和 2 都可以接收。\n1 2 3 4 5 6 7 8 9 10 public class SpringamqpTest { @Test public void testTopicExchange(){ // 交換機 String exchangeName = \u0026#34;hello.topic\u0026#34;; // 訊息 String msg = \u0026#34;news for Japan\u0026#34;; rabbitTemplate.convertAndSend(exchangeName,\u0026#34;japan.news\u0026#34;,msg); } } 只有 1 可以接收。\n訊息轉換器 Spring 會把發送的訊息序列化為位元組 (Bytes) 發送給 MQ，接收訊息時，把位元組反序列化為 Java 物件，只不過預設情況下 Spring 採用的序列化方式是 JDK 序列化，其數據體積過大、有安全漏洞、可讀性差。\n可以使用 JSON 方式來做序列化和反序列化。\n首先在父專案引入依賴：\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.fasterxml.jackson.dataformat\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jackson-dataformat-xml\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.9.10\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 在消費者與接收者宣告一個 bean 即可：\n1 2 3 4 @Bean public MessageConverter jsonMessageConverter(){ return new Jackson2JsonMessageConverter(); } ","date":"2025-01-15T17:03:32+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/217/","title":"SpringAMQP"},{"content":" 此頁面有使用機器翻譯喲\n音之所感系列\n歌曲名稱 翻譯 連結 僕が死のうと思ったのは 曾經我也想過一了百了 本文 あくあ色ぱれっと aqua 的調色板 https://blog.yexca.net/zh-tw/archives/219 恋の押し売り 戀愛推銷 https://blog.yexca.net/zh-tw/archives/220 17さいのうた 17 歲的歌曲 https://blog.yexca.net/zh-tw/archives/224 引言 有沒有一種聽力材料，可以讓人不是處於學習的狀態，可以反覆聽，並可以嘗試影子跟讀的呢？這不就是歌曲嗎！\n考慮到我聽歌時只是部分能聽懂，如果深入分析了解歌詞的話，說不定真的可以當成對語言的練習了\n第一首就從一首雖然有點沉重，但可以說陪伴了我大部分時間，我可以百聽不厭的歌曲開始吧\n歌曲影片 歌詞 僕ぼくが死しのうと思おもったのは　ウミネコが桟さん橋ばしで鳴ないたから\n我之所以想過一了百了，是因為黑尾鷗在碼頭啼鳴\n波なみの随意ずいいに浮うかんで消きえる　過去かこも啄ついばんで飛とんでいけ\n隨波浮沉又消逝，連過去也一併啄起飛向遠方\n僕ぼくが死しのうと思おもったのは　誕生日たんじょうびに杏あんずの花はなが咲さいたから\n我之所以想過一了百了，是因為生日時杏花開了\nその木こ漏もれ日びでうたた寝ねしたら　虫むしの死し骸がいと土つちになれるかな\n在那灑落的日影下小憩，是否能化作蟲的遺骸與黃土呢\n薄荷はっか飴あめ　漁港ぎょこうの灯台とうだい　錆さびたアーチ橋ばし　捨すてた自転車じてんしゃ\n薄荷糖、漁港的燈塔、生鏽的拱橋、被拋棄的自行車\n木造もくぞうの駅えきのストーブの前まえで　どこにも旅たび立だてない心こころ\n木造車站爐火前，踏不出旅途的心\n今日きょうはまるで昨日きのうみたいだ　明日あすを変かえるなら今日きょうを変かえなきゃ\n今天就好像昨天一樣，想改變明天的話要從今天開始\n分かってる　分かってる　けれど\n我知道啊，我明白啊，可是。。。\n僕ぼくが死しのうと思おもったのは　心こころが空からっぽになったから\n我之所以想過一了百了，是因為內心已經空寂了\n満みたされないと泣ないているのは　きっと満みたされたいと願ねがうから\n因空虛而哭泣，無非是渴望被填滿\n僕ぼくが死しのうと思おもったのは　靴紐くつひもが解ほどけたから\n我之所以想過一了百了，是因為鞋帶鬆開了\n結むすびなおすのは苦手にがてなんだよ　人ひととの繋つながりもまた然しかり\n重新繫上很麻煩，人際關係也同樣如此\n僕ぼくが死しのうと思おもったのは　少年しょうねんが僕ぼくを見みつめていたから\n我之所以想過一了百了，是因為少年注視著我\nベッドの上うえで土下座どげざしてるよ　あの日ひの僕ぼくにごめんなさいと\n在床上向我土下座，對那天的自己說抱歉\nパソコンの薄うす明あかり　上階じょうかいの部屋へやの生活音せいかつおん\n電腦螢幕的微光，上層房間的生活聲\nインターフォンのチャイムの音おと　耳みみを塞ふせぐ鳥とりかごの少年しょうねん\n門鈴的聲音，捂住耳朵的籠中少年\n見みえない敵てきと戦たたかってる　六畳ろくじょう一間ひとまのドンキホーテ\n在六坪房間的堂吉訶德，與無形之敵在戰鬥著\nゴールはどうせ醜みにくいものさ\n終點反正是醜陋的\n僕ぼくが死しのうと思おもったのは　冷つめたい人ひとと言いわれたから\n我之所以想過一了百了，是因為被人說成冷漠無情\n愛あいされたいと泣ないているのは　人ひとの温ぬくもりを知しってしまったから\n因渴望被愛而哭泣著，是因為已經嘗過人間冷暖\n僕ぼくが死しのうと思おもったのは　あなたが奇麗きれいに笑わらうから\n我之所以想過一了百了，是因為你的笑容如此溫暖\n死しぬことばかり考かんがえてしまうのは　きっと生いきる事ことに真面目まじめすぎるから\n總想着死亡，一定是活得太認真了吧\n僕ぼくが死しのうと思おもったのは　まだあなたに出会であってなかったから\n我之所以想過一了百了，是因為未曾遇見你\nあなたのような人ひとが生うまれた　世界せかいを少すこし好すきになったよ\n正因為有你這樣的人會誕生，才會有點喜歡這個世界\nあなたのような人ひとが生いきてる　世界せかいに少すこし期待きたいするよ\n正因為有你這樣的人存在著，才會對世界有些許期待\n","date":"2025-01-11T01:10:51+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/214/","title":"音之所感 - 《僕が死のうと思ったのは》"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 Python 打包是依據目前的作業系統環境而定的，在 Windows 下會打包出 .exe 執行檔，在 Linux 下則會打包出 ELF 格式的二進位檔案，不支援跨平台打包。\n安裝 透過 pip 安裝\n1 pip install pyinstaller 打包成單一檔案 使用參數 --onefile\n1 pyinstaller --onefile main.py 常用參數 對於 Windows 程式的打包，常用參數有：\n--windowed: 不顯示終端機視窗 (如果是自行實作圖形使用者介面 (GUI) 的話) --icon=icon.ico: 為程式加入圖示 --hidden-import: 明確指定所需的相依套件 (避免自動分析遺漏) --add-data: 加入額外的資源檔到打包中 --debug: 啟用偵錯資訊 打包成多個檔案 打包成多個檔案時，使用 --onedir 參數\n1 pyinstaller --onedir main.dy 相依檔案會放在 _internal 資料夾下，非常不友善\n只有 pyinstaller 6.1.0 以上版本才能使用此參數\n1 pyinstaller --contents-directory . .\\main.py 這樣打包後的相依檔案和進入點就會在同一個目錄中。\n打包設定項目 假設目前專案的設定檔放在 project/conf/settings.json\n打包時想把這個檔案也包含進去，首先打包成多個檔案\n1 pyinstaller --name my_program --contents-directory . .\\main.py 會在目前目錄產生 my_program.spec 檔案，修改 a 的 data，以元組 (tuple) 的方式輸入想打包的檔案，例如：\n1 datas=[(\u0026#39;conf/settings.json\u0026#39;, \u0026#39;conf/\u0026#39;)], 然後刪除 dist/ 資料夾下所有檔案後執行指令 (不刪除也可以，後續問題同意即可)\n1 pyinstaller my_program.spec 專案 透過這種方式，已經把 https://blog.yexca.net/archives/211 的軟體打包成執行檔了 (雖然還是沒做錯誤處理)\n參考文章 https://www.cnblogs.com/yqbaowo/p/17863429.html ","date":"2025-01-07T17:26:09+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/213/","title":"Python pyinstaller 打包"},{"content":" 此頁面有使用機器翻譯喲\n引言 今天想對最近設計的半透明、毛玻璃和圓角進行總結，突然想到 2023-12-01 好像做過一個什麼東西，就順便重整一下好了\n頁面背景 現代的 (二次元) 網頁要有一個背景\n1 2 3 4 5 6 7 8 body{ background-image: url(\u0026#39;../img/77194247_p0.jpg\u0026#39;); background-size: cover; background-attachment: fixed; /* 固定 */ background-repeat: no-repeat; /* 不重複 */ padding: 0; margin: 0; } 半透明與毛玻璃 然後在背景上加一個蒙版，實現半透明與毛玻璃效果\n1 2 3 4 5 6 7 8 9 10 11 .layout { /* display: flex; */ margin: 0; padding: 0; display: flex; width: 100vw; height: 100vh; backdrop-filter: blur(2px); /* 背景模糊效果 */ -webkit-backdrop-filter: blur(2px); /* Safari 支援 */ background: rgba(0, 0, 0, 0.4); /* 半透明黑色背景 */ } 網頁的重構 說起來寫文章還是很傷腦筋，做的時候寫會被打斷，做完再寫又會很累不想動，所以我就折衷一下，隨便寫寫就好\n專案地址: https://github.com/yexca/MusicPlayer-Twinkle 順便更新了之前的文章 (簡體中文) https://blog.yexca.net/archives/116/ 用這個方法加了一個範例: https://twinkle.yexca.net 卡片效果 這也屬於現代的設計\n1 2 3 4 5 6 7 8 9 10 .card { width: 300px; padding: 20px; background-color: rgba(255, 255, 255, 0.5); /* 半透明白色背景 */ border-radius: 15px; /* 圓角 */ box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); /* 陰影 */ backdrop-filter: blur(10px); /* 背景模糊效果 */ border: 1px solid rgba(255, 255, 255, 0.3); /* 邊框 */ color: pink; /* 前景文字顏色 */ } 嗯，之後有時間再以卡片為設計來完善這個專案 (又開新坑了)\nTwinkle 另外，專案的內容是 Twinkle 的音樂，具體介紹請參閱\nhttps://twinkle130527.wixsite.com/twinkle https://www.dojin-music.info/circle/1255 SoundCloud\nhttps://soundcloud.com/twintwinkles ","date":"2025-01-05T16:19:36+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/212/","title":"毛玻璃效果"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 2025-05-18 更新\n我寫了一個 SQLite 版的，不用設定資料庫了，詳細資訊請訪問: https://blog.yexca.net/archives/248 耗時三天寫出了一個大概能用的版本，不過沒有做錯誤處理 遇到錯誤直接重啟吧\n專案網址: https://github.com/yexca/PixivDownloader-MySQL 引言 這要從 資料庫紀錄已下載繪師作品 開始說起了，當時我弄了一個資料庫紀錄我下載過的作品，時間久了之後，覺得這玩意是在做重複作業啊，說到重複作業那必然是交給電腦來做啊，正好最近不經意間產生了撰寫程式的想法，也正好對其不滿意: https://github.com/yexca/yasumiProject ，同時又是過年比較空閒，這就開寫。\n說明 雖說我是寫出來了，不過沒有錯誤處理之類的，只能說勉強能用吧。同時程式碼很亂 (第一次開發比較大的 GUI 軟體啦)，亂到我不想去整理和做國際化支援了。\n並且開發過程中突然想到都寫程式了為什麼不用 SQLite 呢，這還要開一個 MySQL 多麻煩，不過都做了，就做到最後吧。\n最後本來想打包的，因為使用設定檔，打包好麻煩 (剛開始不知道打包出來被 Windows 當成病毒了)，我實在懶得折騰了，就這樣吧。\n介面 背景圖: https://www.pixiv.net/artworks/83273073 首頁 設定 設定 因為基於我現有資料庫開發，所以幾乎沒有自定義程度，資料庫建立資料表語句為：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 CREATE TABLE pic ( ID varchar(99), # 唯一識別 name varchar(255), # 繪師暱稱 downloadedDate datetime, # 下載/更新時間 lastDownloadID varchar(255), # 最新作品ID platform varchar(50), # 平台 url varchar(255), # 連結 PRIMARY KEY(ID) )ENGINE=InnoDB DEFAULT CHARSET=utf8mb4; 然後因為 API 的使用需要登入並且不可以用帳號密碼登入，根據 https://gist.github.com/ZipFile/c9ebedb224406f4f11845ab700124362 取得 Auth Token 後使用。\n背景圖片我並沒有上傳到 git 倉庫，路徑為 app\\resources\\images\\background.png\n然後是需要安裝 Python，安裝相依套件：\n1 pip install -r requirements.txt 使用 執行程式\n1 python main.py 在 Pixiv 驗證介面和設定介面完成相關配置後返回首頁。\n填入繪師 ID 或者 某一作品的 ID 就會自動爬取該繪師全部作品了。\n結尾 我其實都覺得自己都不去使用它，這算是我開發經歷的一小步吧。\n","date":"2025-01-03T20:05:44+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/211/","title":"Pixiv 下載器"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 引言 這篇文章是寫給我自己的，說是 2024 總結，但也是記錄近年的生活感悟與心路歷程。文筆不是很好，想表達的東西還有很多，但不知道該如何整合在一起，就先這樣吧。\n從 2020 到 2024 的經歷 從 2020 年開始，慢慢地總是覺得時間過得好快，哪怕是經歷了很多事情，也不會找回 2020 以前那種可能是認真過每一天，或者是會覺得時間漫長的感覺。但是當我以客觀的角度來分析時，事實上每一年我都經歷了許多事情，也做了不少事，尤其是今年我經歷的也可謂是相當之多。\n2020 這年考完大學，之後我開始了第一次遠離家鄉的生活，大學生活時加入了社團，參加了不少活動。 2021 上半年參加了不少社團活動，下半年我更換了手機進入蘋果生態系、轉系、建立本部落格。 2022 我在 Switch OLED 剛出時溢價購入並玩得不亦樂乎，同年購入 Quest2 開啟 VR 之旅，並編寫了一些 VRChat 教學，同時還在年底去了南京遊玩。 2023 這一年換校區了，開始參加一些二次元活動，如原神和必勝客、喜茶的聯名，後期學校解封也是逛了逛周邊地區，參加了軟考和日檢，購買了 Google Pixel 6 以及開始迷上辦卡。 2024 這應該是我最精彩的一年，年初開始去深圳實習，在此期間逛了 Costco 在深圳的新店、第一次看海、認識到了許多很好的人、逛了華強北、去了香港、逛了澳門、第一次坐船等，我的思想也逐漸轉變，回學校、畢業回家後對於他人的態度也有轉變，開始和我的家人交流，和家人去了徐州遊玩，開始嘗試做飯，自己 DIY 物品，考取駕照等，這之後還去了日本，第一次坐飛機，第一次穿二次元衣服出門、第一次參加動漫展 (C105) 等等。 可以說我經歷的事情是逐年增多，但我的主觀感受還是「時間過得很快，我並沒有做過什麼事情」，這不免使我產生困惑。\n對於生活的理論解釋 注意：提及的理論純屬個人想像，並沒有經過驗證分析，請謹慎相信。\n事實上，在 2023 下半年原本應該準備研究所考試的我，眼睛卻非常痛，每天睜眼的時間幾乎不能超過 4 小時。因此那段時間我幾乎天天躺在床上，在半睡半醒中產生了一種解釋生活的理論，於是我就開始沉迷於解釋生活。\n狀態行為理論 我甚至為這些理論進行了命名。最開始產生的是狀態行為理論，我把可以影響人的行為的各種因素當成可以被量化的變數（如情緒的喜怒哀樂、資訊的掌握程度、經歷的事情、當下周圍的影響因子等），這些變數有不同的權重。掌握大部分變數可以較高準確率預測一個人的行為，之後對其進行推論：如果知道每一個人的變數值，那麼每個人的人生其實是確定的。\n當然該理論不是直接演變成這樣的，剛開始的三四天只是暢想。某一天突然意識到貌似我想的東西和 Unity 的 State Behaviors 重合，便以此命名。之後對一些事情進行分析後，演變成大概這個樣子。\n圈子理論 同時為了幫助確定一定的影響因素，我想出了圈子理論來表示一個人受到他人的影響。這本身也是我對於網際網路的思考，源於當我從對單一事物的深度探索，變成對各種事物的廣度探索時，我發現一個很奇怪的現象：網路的人群可以根據對什麼的喜好或關注，而劃分為一個又一個圈子。每個圈子裡貌似有一種自圓其說的理論，同時可能會有相較於普通大眾來說很震驚但圈內很平常，或相較於普通大眾很平常但圈內很震驚的事情。並且存在對立的圈子，也就是其自圓其說出這裡很好、其餘很不好，儘管在另一邊可能是相反的。當然並不可能所有的圈子都是孤立的，部分可以進行同類化到一個集合，一般可以直接以集合的行為代表其下方的行為。\n雖然不是同一個東西，但可以類比在資訊繭房下，人們更多地見到自己想見到的東西。又因為世界上的人很多，總可以找到觀點類似的人，然後在這個繭房裡不斷加深自己的理解，從而形成自圓其說的解釋。\n當然這可能只是基礎結論，要想解釋這個複雜的世界，不能每次都使用基礎結論，應該使用一定的推論或輔助結論。\n名句的解釋 比如為什麼會覺得名人名言很有道理。基於狀態行為理論，或者可能推廣到對萬物的解釋，也就是世界的事物有一個根父類別，其演變出許多子類別，以此類推到子抽象類別。可能他們經歷了一定的事情，實際上是某個抽象類別的實作，以此總結抽象出一句話。然後我們的某些經歷可能是這個抽象類別的另一種實作，就會覺得這句名言很有道理。\n稍微嚴謹來說，這基於因為人類歷史的記載太多了，幾乎任何選擇都有人做過（不一定是那件事，而是抽象成那件事）。於是無論對於任何事情都可以給出正面支持和反面教訓，因此我不認為世界上有絕對正確或絕對錯誤的事情，只是在某些狀態或場合下相對正確或錯誤。\n信任解釋理論 再比如最近喜歡的信任解釋理論。我覺得世界是基於信任運作的，比如在過馬路的時候信任司機不會突然開車撞向我、走在路上迎面而來的人不會掏出刀來刺傷我等等，這可能是比較平常或習慣的事情基於普遍的信任。\n當然，這將近一年半的時間裡還考慮過很多其他理論解釋，但不是太記得了。\n理論與實踐的割裂 偶爾我也會想，如果能像孩子一樣隨心所欲地做自己喜歡的事，會不會感到更多的自由？但轉念一想，這個孩子或許早已被我埋葬在規則的泥土之下。\n雖然很多生活問題都可以解釋了，但這還是沒有幫助我走出這種經歷，甚至慢慢開始產生了負面效果。\n隨著解釋的增多，我也不是突然意識到，應該是慢慢感受到我可能就是太沉浸於解釋了，而忘了生活往往是結果，我卻一直想著哪種選擇會產生哪種結果。雖然事前把所有可能性想好，經歷固然會更美好，但正因為把所有的可能都分析了，實際在經歷的時候就和玩遊戲跳過 NPC 對話似的，只等別人說出自己提前想到的某種可能的話，然後選擇一種可能性回覆，慢慢地對於生活就會厭倦。\n於是我開始去嘗試娛樂：散步、購物、跑步、旅行、玩遊戲等。明明擁有選擇的自由，卻總覺得自己被附加了某種無形的鎖鏈。哪怕是娛樂，也像完成任務一般，更多是為了達成心理上的「數值平衡」，而非真正的放鬆與快樂。我的生活彷彿變成了一場模擬遊戲，面對壓力時，我會按照既定規則尋找降低壓力的方式，比如「安排娛樂」。我對自己的生活可能也進行了量化，覺得某件事情產生了多少壓力，我需要做些什麼降低壓力，但這些娛樂活動卻不是真正為我帶來快樂的事，而是執行一種被普遍認為有效的「壓力緩解」方案。這讓我想起被安排娛樂的孩子，乍看之下他們在玩遊戲或參加活動，卻未必是發自內心的熱愛。我現在的狀態似乎和他們沒有區別，只不過安排的人和被安排的人都是我自己。\n我是自己生活的設計者，同時也是執行者，彷彿自己安排的劇本，只是為了完成任務，卻失去了內在的情感連結。\n我開始慢慢覺得自己身上有附加的鎖鏈，我做任何事情都要在一個特定的規則下，只要是做了除這件事以外的東西就是不好，或者不行。亦或者我在尋求一個認可，只要我這樣做了就會被認可，那樣做了一定不被認可。\n這是否也是陷入了一個圈子理論的圈子中呢？解釋出這些的我其實也是另一種解釋的一部分，就好比我認為世界的理論是一個一個數軸上的點，然後我把這些串起來解釋出了數軸，但我本身也被二維座標系所解釋著。\n由於 bilibili 的嵌入式體驗不好，改為 Youtube 的。鹿乃有官方帳號，本歌曲影片：BV1zr4y1n7sM\n我懷疑過自己應該是患了憂鬱症，甚至規劃過如何自殺。寫到這裡突然想到《僕が死のうと思ったのは (曾經我也想過一了百了)》這首歌的一句歌詞「死ぬことばかり考えてしまうのは (腦子裡只想著自殺這件事)　きっと生きる事に真面目すぎるから (一定是因為對待生活太過認真了吧)」。是啊，正如歌詞所寫，我是否是對生活過於認真了呢？\n同時這首歌的其他地方也讓我有所聯想，比如「今日はまるで昨日みたいだ (今天就好像昨天一樣)」。是啊，儘管每天都經歷不一樣的事情，但在思想上我覺得這就是理論產生的結果，理論並沒有改變，生活也沒有改變。\n「見えない敵と戦ってる (一直與看不見的敵人在戰鬥)」，我在和誰戰鬥呢？彷彿就是我創造出來的規則的負面，也是我內心的不確定感和對悲傷的固執。\n「明日を変えるなら今日を変えなきゃ (想要改變明天的語就得從今天開始改變)　分かってる (我知道啊)　分かってる (我明白啊)　けれど (可是\u0026hellip;)」，可是我可以改變什麼呢？基於理論的印象，就算向他人訴說，他人給出了見解，哪怕是說動了我，我也還是會一成不變地按照自己悲傷的觀點度日。\n「僕が死のうと思ったのは (我之所以想一了百了是因為)　冷たい人と言われたから (被說成是冷漠的人)」，但我明明是按照應該會很有趣的人的樣子做出的回應啊。\n「愛されたいと泣いているのは (因為想要被愛而哭泣)　人の温もりを知ってしまったから (是因為我開始懂得人情世故)」，他們的關心都是基於對他人的尊重或者禮儀，並不是真的關心我，我也只是禮貌機械地回覆，沒有任何情感。\n「僕が死のうと思ったのは (我之所以想一了百了是因為)　まだあなたに出会ってなかったから (還沒有與你相遇)　あなたのような人が生まれた (正因為有你這樣的人出生)　世界を少し好きになったよ (我才會變得喜歡這個世界啊)　あなたのような人が生きてる (正因為有你這樣的人活著)　世界に少し期待するよ (我才對世界有些許期待唷)」，但我把自己尋求幫助、他人的見解也運用理論去解釋，那是一種必然產生的結果，彷彿我去呼叫一個介面，輸入一定內容就會回傳給我什麼內容。只要我這樣做就會獲得什麼，太確定了。\n但生活往往是不確定的，我慢慢也會對不確定的事情感到恐懼。同樣地，為了消除恐懼，我開始完善之前對於生活的理論，慢慢地增加子理論去解釋，這也暫時緩解了我一定的恐懼。但是人是不可能絕對理性的，第一反應本能地還是會出於感性，我的理論也會有這一點存在。理性控制著我，這只是暫時的，從結果來看，時間會把傷口撫平。\n從解釋到行動的轉變 時間像流水，不斷流逝，而我卻彷彿在岸邊計算水量，卻忘了去觸摸水的溫度。\n我為自己打造了一套看似理性的框架，卻逐漸成為它的囚徒。即使有完全的自由選擇權，也總是帶著無形的束縛感。這個理論最大的問題在於，它過於強調邏輯與規則，忽略了情感和體驗的部分。我彷彿是一個演算法，為自己設定了行動規則，卻在執行過程中發現，我應該表達自己的感受。這是一個漫長的轉變過程，不過對於我來說，解釋可以立馬轉變，但思想或行動卻很難轉變。在理論的思維固化下，我很難去轉變從事物本源解釋的角度看待問題。\n我首先意識到自己對理論的依賴開始有負面效果，雖然當我產生這個想法的時候，也是可以被自己的理論所解釋，因為我會用它解釋一切，包括它自己。但同時人是可以轉變的，因為受到變數的影響，多個變數的累積，權重不斷加大，開始促使我轉變。\n首先應該是我接觸的人變多了。固步自封、自我封閉雖然不會受到人際關係的傷害，但也使得自己接觸面變得侷限。其實也正感謝我的理論，它讓我先擁有了邁出去的第一步，因為可能在內向的心裡和別人交流很麻煩，但理論的思維是不違法不違規，我可以有這種選擇，我只是做了一個和別人交流的選擇而已。從遇到的第一個性格很好的人開始，逐步認識更多的人，我慢慢地產生了性格的轉變。\n因為接觸面變廣，可以對世界進行更深層次的思考，從而完善了理論。這種完善的理論使得我可以產生更多選擇的可能性（雖然有負面的比如更多的恐懼），但正如高風險高收益一樣，事物伴隨著一定的代價。\n這之後就是慢慢嘗試變多後，我可以說是去驗證了理論吧。從空想到驗證的調整，使得我可以更清楚知道某項選擇後果的個人感受程度，正因為這種對感受的重視，把我從量化拉回。\n當然這遠遠不夠，因為感受也是可以量化的。上個月我練習聽力的時候聽到一段對話：\nA：這兩個哪個更好？ B：甲挺不錯。 A：乙不會更好嗎（並解釋了理由）。 B：明明已經有了結論還來問我幹什麼。\n儘管只是比較日常的對話，但它多次在我腦中回想。確實，多數時候我可能知道大概怎麼做，並且有一定的決定，但是我不去行動，只是反覆確認可能性，力圖找出所有分支，讓我活在確定中，甚至不是找最優解。這段對話事實上是對我一種確定的回覆產生一種不確定的可能（我知道這話很怪，只是我不會表達這種感受），亦或者是喚起了選擇的意義是獲得自己想要的結果。\n再或者說，可能只是我並沒有什麼目標，沒有根據自己的情感、需求確定的目標，只是根據一定的可能性創造出來的目標，創造出來的我並不喜歡的目標。\n我開始嘗試增加自己感受的變數，我要把自己喜歡的事物的權重拉高。理論是解釋生活、幫助人類理解世界的，它不是支配者，我不應該被支配。我應該是使用它以達到我喜歡的目標，我喜愛的生活！\n現狀 我可以自由表達，我可以自由行動（不違反法律規則的話）。這篇文章的出現也表達了我在慢慢衝破枷鎖，因為我之前覺得這是一件很丟臉的事情，不去記錄我的理論，所以事實上部分子理論也就忘了。\n我意識到活著是一個過程，這是一個無法改變的事實。正如我之前對朋友說過的一句話：「既然無法改變，只能去適應」。生活中會遇到各種各樣的人，美好的也有，不幸的也有。往往當我們陷入悲傷的時候，那是不幸的東西累積太多，或許衝昏了頭腦，而忘記了自己所擁有的美好事物。\n正如 關於頁面 寫道，「無論何時都要盛裝登場，每段經歷都是全心投入」。對於世界來說，我只是一個個體，一個數字，但對於我來說，我就是整個世界！\n「 萬物皆浮雲，只要好心情 」，激活自己的 Atopes ，做自己熱愛的事吧，買自己喜歡的東西吧，去自己想去的地方吧。不用考慮太多，大膽表達自己吧。\n我現在就想到了 https://github.com/RimoChan 的頭像，真正去熱愛自己的生活。快樂也是活一天，痛苦也是活一天，沒必要內耗啦。\n結尾 明年會怎麼樣呢？我覺得可以以我部落格的介紹結尾：\n把這個不美好的世界，編成我所期望的樣子吧！\n","date":"2024-12-31T17:40:09+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/210/","title":"2024 年度總結"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 引言 隨著對於資訊的瀏覽增多，往往會有書寫其他語言文章的需求（同時現代的作品幾乎都具備多語言支援），同時也因為自從畢業設計當時加入了多語言支援後，之後做的東西或設計的東西往往都會想要進行國際化支援。就連 最近寫的一個相當於練手的小專案 也弄了多語言支援呢（不過這並不是我想要的效果，太古老了，想做一個現代一點的，另外 正在製作中 ，希望可以堅持做完）。\n回過頭來看看我的部落格，這個陪伴我最久的作品，它還沒有國際化。雖然一部分原因通常都是寫簡體中文文章啦，但 之前的部落格 介面部分中文部分英文，實際上弄得多少有些混亂，雖然我個人可以看懂，但對於非相關人士可能會感到疑惑。\n但原本的 Jekyll 我折騰了半天硬是沒成功達成多語言，索性轉向原生支援國際化的 Hugo 啦。不過每個主題都有其特色，這個主題對於分類與標籤的處理和上個主題區別很大，之後得慢慢修改適應才行。\n這篇文章寫得很潦草吧，主要是它的配置貌似很依賴主題，我也幾乎都是根據主題的範例修改的，所以我覺得也沒什麼好寫的（因為官方文件也很豐富）。\n環境 使用 Docker 有 Hugo 的容器，所以環境問題沒怎麼折騰（使用的工具可以看 這裡 呢）。\n建立部落格 建立新部落格\n1 hugo new site blogName 進入目錄\n1 cd blogName 初始化儲存庫\n1 git init 安裝主題，這裡使用 hugo-theme-stack 主題，其他同理\n1 git submodule add https://github.com/CaiJimmy/hugo-theme-stack/ themes/hugo-theme-stack 配置 hugo.toml 選擇主題\n1 theme = \u0026#39;hugo-theme-stack\u0026#39; 預覽\n1 hugo server 包含草稿 (draft) 的預覽\n1 hugo server -D 部分修改可能需要清除快取才能生效（例如配置項、頁面的修改）\n1 hugo --cleanDestinationDir 建置網站，預設建置檔案在 public 目錄下\n1 hugo 多語言支援 在網站設定檔（我使用 yml 配置）中設定預設語言\n1 2 defaultContentLanguage: \u0026#39;zh-cn\u0026#39; # 預設語言代碼 defaultContentLanguageInSubdir: false # 預設語言路徑是否帶語言代碼 然後設定具體的語言項目\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 languages: zh-cn: contentDir: \u0026#39;content/zh-cn\u0026#39; # 文章存放目錄 disabled: false languageCode: \u0026#39;zh-cn\u0026#39; languageDirection: \u0026#39;ltr\u0026#39; # 文章從左到右 (ltr) 還是從右到左 (rtl) languageName: \u0026#39;简体中文\u0026#39; title: \u0026#34;yexca\u0026#39;Blog\u0026#34; weight: 1 zh-tw: contentDir: \u0026#39;content/zh-tw\u0026#39; disabled: false languageCode: \u0026#39;zh-tw\u0026#39; languageDirection: \u0026#39;ltr\u0026#39; languageName: \u0026#39;繁體中文\u0026#39; title: \u0026#34;yexca\u0026#39;Blog\u0026#34; weight: 2 字體國際化: https://blog.yexca.net/archives/240 文章撰寫 不同於 Jekyll，Hugo 的文章撰寫稍微有點複雜，加上國際化支援後，使得文章管理更加複雜（複雜的好處是自定義程度高），這點可能根據不同主題而有所不同。我說明一下我使用的做法，首先上方語言項目配置指定了文章的目錄，需要在 content 建立相應目錄，然後該語言的文章就在該目錄下寫作。\n同時，指定文章是在哪個目錄下，stack 主題設定檔中可以指定：\n1 2 3 params: mainSections: - posts 這就表示我簡體中文的文章應該放在 content/zh-cn/posts 裡，然後還有一些目錄是主題指定的，可以參考對應主題的範例。\n現在要建立一篇簡體中文的新文章可以使用：\n1 TZ=\u0026#34;Asia/Tokyo\u0026#34; hugo new content/zh-cn/posts/test.md 不指定時區的話預設使用 UTC 時間（雖然可以自己改，但習慣了 Jekyll 自動建立的我，覺得自己寫時間很麻煩）。\n文章預設建立模板在 blogName/archetypes 下，可以改為 yml 格式。\n參考文章 Hugo - Quick start https://stack.jimmycai.com/guide/ Hugo - Multilingual mode ","date":"2024-12-27T23:11:45+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/209/","title":"使用 Hugo 進行部落格國際化支援"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 簡易 (非技術框架) 實作的 Go 後端\n眾所周知，後端的開發通常是面向介面的開發，也可以說是 CRUD 工程師。本文將使用 Go 語言描述如何從資料庫讀取資料，並回傳 JSON 格式的資料。\n資料庫 本範例是從 MySQL 資料庫的分類表，讀取出分類的名稱與 ID，資料庫結構如下：\n1 2 3 4 5 6 DROP TABLE IF EXISTS categories ; CREATE TABLE categories ( id INT AUTO_INCREMENT PRIMARY KEY, name VARCHAR(255) NOT NULL, description VARCHAR(255) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4; 專案結構 本範例的專案結構如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 project/ ├── database/ // 資料庫套件 │ └── database.go // 資料庫連線 ├── handler/ // 處理器套件 │ └── category.go // 分類相關介面 ├── model/ // 資料模型套件 │ ├── category.go // 分類表模型 │ └── response.go // 回應資料模型 ├── router/ // 路由套件 │ └── router.go // 路由設定 ├── utils // 工具套件 │ └── response.go // 統一回應 ├── main.go // 程式進入點 接下來將分目錄說明。\ndatabase 此套件用於管理與資料庫的連線。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 // database.go package database import ( \u0026#34;database/sql\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; _ \u0026#34;github.com/go-sql-driver/mysql\u0026#34; ) var DB *sql.DB func InitDB() { var err error dsn := \u0026#34;username:password@tcp(address:3306)/name?charset=utf8\u0026#34; DB, err = sql.Open(\u0026#34;mysql\u0026#34;, dsn) if err != nil { log.Fatalf(\u0026#34;無法開啟資料庫: %v\u0026#34;, err) } // 測試連線 err = DB.Ping() if err != nil { log.Fatalf(\u0026#34;無法 Ping 資料庫: %v\u0026#34;, err) } fmt.Println(\u0026#34;成功連線到資料庫！\u0026#34;) } handler 此套件負責處理特定的業務邏輯 (類似於三層式架構中的 Service)。其中，資料庫處理部分還可以再分層 (類似於 Mapper)，不過這只是一個簡單的範例，就先這樣囉～\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 // category.go package handler import ( \u0026#34;net/http\u0026#34; \u0026#34;project/database\u0026#34; \u0026#34;project/model\u0026#34; \u0026#34;project/utils\u0026#34; ) func GetCategories(w http.ResponseWriter, r *http.Request) { // 查詢資料庫 rows, err := database.DB.Query(\u0026#34;select id,name from categories\u0026#34;) if err != nil { http.Error(w, \u0026#34;查詢分類失敗\u0026#34;, http.StatusInternalServerError) return } defer rows.Close() // 解析資料 var categories []model.Category for rows.Next() { var category model.Category err = rows.Scan(\u0026amp;category.Id, \u0026amp;category.Name) if err != nil { utils.JSONResponse(w, http.StatusInternalServerError, \u0026#34;無法解析分類資料\u0026#34;, nil) //http.Error(w, \u0026#34;Failed to analyze Categories\u0026#34;, http.StatusInternalServerError) return } categories = append(categories, category) } // 回傳 JSON //w.Header().Set(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;) //json.NewEncoder(w).Encode(categories) utils.JSONResponse(w, http.StatusOK, \u0026#34;\u0026#34;, categories) } 被註解掉的內容是未採用統一回應介面，直接回傳 JSON 的情況。\nmodel 這裡的資料模型通常可以分為三種：從前端接收到的、資料庫的，以及回傳給前端的。由於這只是一個簡單的範例，所以我並沒有細分。\n1 2 3 4 5 6 7 8 // category.go package model type Category struct { Id int `json:\u0026#34;id\u0026#34;` Name string `json:\u0026#34;name\u0026#34;` Description string `json:\u0026#34;description\u0026#34;` } 回應的資料模型為：\n1 2 3 4 5 6 7 package model type Response struct { Code int `json:\u0026#34;code\u0026#34;` Msg string `json:\u0026#34;msf\u0026#34;` Data interface{} `json:\u0026#34;data\u0026#34;` } router 此套件管理路由，也就是當存取到什麼路徑時，要指定相對應的處理邏輯 (類似於三層式架構中的 Controller)。\n1 2 3 4 5 6 7 8 9 10 11 12 13 // router.go package router import ( \u0026#34;github.com/gorilla/mux\u0026#34; \u0026#34;project/handler\u0026#34; ) func InitRouter() *mux.Router { router := mux.NewRouter() router.HandleFunc(\u0026#34;/categories\u0026#34;, handler.GetCategories).Methods(\u0026#34;GET\u0026#34;) return router } utils 此套件為工具類別，用於定義可通用的工具。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // response.go package utils import ( \u0026#34;encoding/json\u0026#34; \u0026#34;log\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;project/model\u0026#34; ) func JSONResponse(w http.ResponseWriter, code int, message string, data interface{}) { w.Header().Set(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json; charset=utf-8\u0026#34;) w.WriteHeader(http.StatusOK) err := json.NewEncoder(w).Encode(model.Response{Code: code, Msg: message, Data: data}) if err != nil { log.Fatal(err) return } } main 程式的進入點\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // main.go package main import ( \u0026#34;log\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;project/database\u0026#34; \u0026#34;project/router\u0026#34; ) func main() { // 初始化資料庫 database.InitDB() // 初始化路由 r := router.InitRouter() // 啟動 log.Println(\u0026#34;在連接埠 8848 啟動伺服器\u0026#34;) log.Fatal(http.ListenAndServe(\u0026#34;:8848\u0026#34;, r)) } 執行 go run main.go 後，程式將會監聽連接埠 8848。\n","date":"2024-12-22T22:07:15+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/208/","title":"GoLang 後端入門"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 Golang 系列\nHello GoLang: https://blog.yexca.net/archives/154 GoLang (var and const) 變數與常數: https://blog.yexca.net/archives/155 GoLang (func) 函式: https://blog.yexca.net/archives/156 GoLang (slice and map) 切片: https://blog.yexca.net/archives/160 GoLang (OOP) 物件導向: https://blog.yexca.net/archives/162 GoLang (reflect) 反射: https://blog.yexca.net/archives/204 GoLang (struct tag) 結構體標籤: https://blog.yexca.net/archives/205 GoLang (goroutine) Go 協程: https://blog.yexca.net/archives/206 GoLang (channel) 通道: 本文\nGo 協程 (goroutine) 可以透過通道 (channel) 傳遞資料，引用型別的通道可用於多個 Go 協程之間的通訊，其內部實作了同步機制，確保併發安全\n有點類似 RabbitMQ (僅個人為方便學習所類比，實則為不同東西)\n定義變數 通道為引用型別，複製或函式呼叫時將引用同一個通道物件，零值為 nil\n透過 make() 函式建立，例如\n1 2 3 c := make(chan int) // 新增容量為 3 c := make(chan int, 3) 當容量為 0 時，通道是無緩衝區、會阻塞讀寫的；大於 0 時有緩衝區、非阻塞，直到寫滿才會阻塞\n透過 \u0026lt;- 來接收和傳送資料\n1 2 3 4 5 6 7 8 // 傳送資料到通道 channel \u0026lt;- 3 // 接收並捨棄 \u0026lt;-channel // 注意無空格 // 接收並賦值給變數 x := \u0026lt;-channel // 接收並賦值給變數，並判斷是否接收成功(通道是否為空) data, flag := \u0026lt;-channel 無緩衝區 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package main import \u0026#34;fmt\u0026#34; func main() { c := make(chan int) go func() { defer fmt.Println(\u0026#34;A.defer\u0026#34;) c \u0026lt;- 6 fmt.Println(\u0026#34;A 正在執行\u0026#34;) }() num := \u0026lt;-c fmt.Println(\u0026#34;num =\u0026#34;, num) fmt.Println(\u0026#34;main 結束\u0026#34;) } 有緩衝區 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { c := make(chan int, 3) go func() { defer fmt.Println(\u0026#34;A 結束\u0026#34;) for i := 0; i \u0026lt; 3; i++ { c \u0026lt;- i fmt.Println(\u0026#34;A Go 協程, i =\u0026#34;, i, \u0026#34;len =\u0026#34;, len(c), \u0026#34;cap =\u0026#34;, cap(c)) } }() time.Sleep(2 * time.Second) for i := 0; i \u0026lt; 3; i++ { num := \u0026lt;-c fmt.Println(\u0026#34;main, num =\u0026#34;, num) } fmt.Println(\u0026#34;main 結束\u0026#34;) } 關閉通道 透過 close() 關閉\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package main import \u0026#34;fmt\u0026#34; func main() { c := make(chan int, 5) go func() { for i := 0; i \u0026lt; 5; i++ { c \u0026lt;- i } // 關閉 close(c) }() for { if data, ok := \u0026lt;-c; ok { fmt.Println(data) } else { break } } fmt.Println(\u0026#34;Main 完成\u0026#34;) } 使用 range 上述 main 的 for 迴圈可以簡寫使用 range\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package main import \u0026#34;fmt\u0026#34; func main() { c := make(chan int, 5) go func() { for i := 0; i \u0026lt; 5; i++ { c \u0026lt;- i } close(c) }() //for { // if data, ok := \u0026lt;-c; ok { // fmt.Println(data) // } else { // break // } //} for data := range c { fmt.Println(data) } fmt.Println(\u0026#34;Main 完成\u0026#34;) } 單向通道 預設情況下，通道是雙向的，即可讀可寫，也可以指定通道方向，只讀或只寫\n1 2 3 4 5 var c chan int // 宣告正常雙向通道 // c1 只可寫 var c1 chan\u0026lt;- int // c2 只可讀 var c2 \u0026lt;-chan int 可以把雙向通道轉為單向，反之則不行。也就是可以定義函式形參為單向，但傳遞雙向通道\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // chan\u0026lt;- // 只寫 func counter(out chan\u0026lt;- int) { defer close(out) for i := 0; i \u0026lt; 5; i++ { out \u0026lt;- i // 如果對方不讀，會阻塞 } } // \u0026lt;-chan // 只讀 func printer(in \u0026lt;-chan int) { for num := range in { fmt.Println(num) } } func main() { c := make(chan int) // 雙向 go counter(c) // 生產者 printer(c) // 消費者 fmt.Println(\u0026#34;完成\u0026#34;) } select select 可以監聽多個通道上的資料流動，語法與 switch 類似，但每個 case 敘述中必須是一個 I/O 操作\n一般放到 for{} 敘述區塊中\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 package main import \u0026#34;fmt\u0026#34; func main() { c := make(chan int) quit := make(chan int) go func() { for i := 0; i \u0026lt; 10; i++ { fmt.Println(\u0026lt;-c) } quit \u0026lt;- 0 }() // main x, y := 1, 1 for { select { case c \u0026lt;- x: tmp := x x = y y = tmp + y case \u0026lt;-quit: fmt.Println(\u0026#34;退出\u0026#34;) return // 可以有 default，此範例不需要 } } } ","date":"2024-12-21T14:52:55+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/207/","title":"GoLang 通道"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 Golang Series\nHello GoLang: https://blog.yexca.net/archives/154 GoLang (var and const) 變數與常數: https://blog.yexca.net/archives/155 GoLang (func) 函式: https://blog.yexca.net/archives/156 GoLang (slice and map) 切片: https://blog.yexca.net/archives/160 GoLang (OOP) 物件導向: https://blog.yexca.net/archives/162 GoLang (reflect) 反射: https://blog.yexca.net/archives/204 GoLang (struct tag) 結構體標籤: https://blog.yexca.net/archives/205 GoLang (goroutine) Go 程: 本文\nGoLang (channel) 通道: https://blog.yexca.net/archives/207 行程 (Process) -\u0026gt; 執行緒 (Thread) -\u0026gt; 協程 (Coroutine)\n協程 (coroutine) 也稱為輕量級執行緒，可以輕鬆建立上萬個而不會導致系統資源耗盡，多個協程共享該執行緒分配到的電腦資源。\nGo 語言原生支援協程，稱為 goroutine，Go 的並發透過 goroutine 和 channel 實作。\n建立 goroutine 透過 go 關鍵字開啟一個 goroutine\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func newTask() { i := 0 for { fmt.Println(\u0026#34;newTask goroutine i =\u0026#34;, i) i++ time.Sleep(1 * time.Second) } } func main() { go newTask() i := 0 for { fmt.Println(\u0026#34;main goroutine i =\u0026#34;, i) i++ time.Sleep(1 * time.Second) } } 使用匿名函式 當然也可以使用匿名函式\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { go func() { defer fmt.Println(\u0026#34;A.defer\u0026#34;) func() { defer fmt.Println(\u0026#34;B.defer\u0026#34;) fmt.Println(\u0026#34;B\u0026#34;) }() // 表示執行該匿名函式 fmt.Println(\u0026#34;A\u0026#34;) }() time.Sleep(2 * time.Second) } 匿名函式也可以有參數與回傳值，不過 goroutine 的回傳值需要透過 channel 傳輸，下例僅示範帶有參數的情況：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { go func(a, b int) { fmt.Println(\u0026#34;a =\u0026#34;, a, \u0026#34;b =\u0026#34;, b) }(10, 20) time.Sleep(2 * time.Second) } 結束 主 goroutine 結束後，其他的工作 goroutine 也會自動結束。\n不過也可以使用 runtime.Goexit() 立即終止當前 goroutine 的執行 (defer 仍會執行)。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;runtime\u0026#34; \u0026#34;time\u0026#34; ) func main() { go func() { defer fmt.Println(\u0026#34;A.defer\u0026#34;) func() { defer fmt.Println(\u0026#34;B.defer\u0026#34;) runtime.Goexit() // 結束 goroutine fmt.Println(\u0026#34;B\u0026#34;) }() // 表示執行該匿名函式 fmt.Println(\u0026#34;A\u0026#34;) }() time.Sleep(2 * time.Second) } /* * 輸出 * B.defer * A.defer */ ","date":"2024-12-17T21:16:31+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/206/","title":"GoLang Go 程"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 Golang Series\nHello GoLang: https://blog.yexca.net/archives/154 GoLang (var and const) 變數與常數: https://blog.yexca.net/archives/155 GoLang (func) 函式: https://blog.yexca.net/archives/156 GoLang (slice and map) 切片: https://blog.yexca.net/archives/160 GoLang (OOP) 物件導向: https://blog.yexca.net/archives/162 GoLang (reflect) 反射: https://blog.yexca.net/archives/204 GoLang (struct tag) 結構體標籤: 本文\nGoLang (goroutine) Goroutine: https://blog.yexca.net/archives/206 GoLang (channel) 通道: https://blog.yexca.net/archives/207 透過結構體標籤可以描述該類別在某套件的作用。\n獲取標籤值 透過 ` 符號來定義 tag (Markdown 程式碼區塊的按鍵)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) type User struct { // 多個 tag 用空格分隔 name string `doc:\u0026#34;name\u0026#34; info:\u0026#34;nameOfUser\u0026#34;` age int `info:\u0026#34;ageOfUser\u0026#34;` } func main() { user := User{\u0026#34;zhangSan\u0026#34;, 18} findTag(\u0026amp;user) } func findTag(input interface{}) { t := reflect.TypeOf(input).Elem() for i := 0; i \u0026lt; t.NumField(); i++ { tagInfo := t.Field(i).Tag.Get(\u0026#34;info\u0026#34;) tagDoc := t.Field(i).Tag.Get(\u0026#34;doc\u0026#34;) fmt.Println(\u0026#34;info:\u0026#34;, tagInfo, \u0026#34;doc:\u0026#34;, tagDoc) } } JSON 轉換 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 package main import ( \u0026#34;encoding/json\u0026#34; \u0026#34;fmt\u0026#34; ) type User struct { // 注意必須是公有屬性才可轉換 JSON Name string `json:\u0026#34;name\u0026#34;` Age int `json:\u0026#34;age\u0026#34;` } func main() { user := User{\u0026#34;zhangSan\u0026#34;, 18} // struct --\u0026gt; json jsonStr, err := json.Marshal(user) if err != nil { fmt.Println(\u0026#34;error\u0026#34;, err) } else { fmt.Printf(\u0026#34;jsonStr : %s\\n\u0026#34;, jsonStr) } // json --\u0026gt; struct var user2 User err = json.Unmarshal(jsonStr, \u0026amp;user2) if err != nil { fmt.Println(\u0026#34;error\u0026#34;, err) } else { fmt.Println(user2) } } ","date":"2024-12-11T18:31:18+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/205/","title":"GoLang 結構體標籤"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 Golang Series\nHello GoLang: https://blog.yexca.net/archives/154 GoLang (var and const) 變數與常數: https://blog.yexca.net/archives/155 GoLang (func) 函式: https://blog.yexca.net/archives/156 GoLang (slice and map) 切片: https://blog.yexca.net/archives/160 GoLang (OOP) 物件導向: https://blog.yexca.net/archives/162 GoLang (reflect) 反射：本文\nGoLang (struct tag) 結構體標籤: https://blog.yexca.net/archives/205 GoLang (goroutine) Goroutine: https://blog.yexca.net/archives/206 GoLang (channel) 通道: https://blog.yexca.net/archives/207 反射指一類應用，它們能夠自我描述與自我控制\npair Go 語言變數包括 type (型別) 和 value (值) 部分，組成 pair\nstatic type 是在編碼時開發者看見的型別，concrete type 是在 runtime 系統看見的型別\n型別斷言能否成功，取決於變數的 concrete type，而不是 static type。因此一個 read 變數如果 concrete type 也實作了 write 方法的話，也可以被型別斷言為 write\n反射建立於型別之上，靜態型別已經固定，因此反射主要與 interface 型別相關 (它是 concrete type)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 package main import \u0026#34;fmt\u0026#34; type ReadBook interface { Read() } type WriteBook interface { Write() } type Book struct { } func (this *Book) Read() { fmt.Println(\u0026#34;read Book\u0026#34;) } func (this *Book) Write() { fmt.Println(\u0026#34;write Book\u0026#34;) } func main() { // b: pair\u0026lt;type:Book, value:book{}位址\u0026gt; b := \u0026amp;Book{} // r: pair\u0026lt;type:, value:\u0026gt; var r ReadBook // r: pair\u0026lt;type:Book, value:book{}位址\u0026gt; r = b r.Read() var w WriteBook w = r.(WriteBook) // 因為 r 的 type 是 Book，所以可行 w.Write() } TypeOf 與 ValueOf reflect.TypeOf() 是獲取 pair 中的 type，reflect.ValueOf() 獲取 pair 中的 value\n1 2 3 4 5 6 7 8 9 10 11 12 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) func main() { a := 3.14 fmt.Println(\u0026#34;type of a:\u0026#34;, reflect.TypeOf(a)) // float64 fmt.Println(\u0026#34;value of a:\u0026#34;, reflect.ValueOf(a)) // 3.14 } 類型轉換 執行 reflect.ValueOf() 後得到型別為 reflect.Value 的變數\n已知原始資料型別 已知原始資料型別可以直接強制轉換\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) func main() { a := 3.14 fmt.Println(\u0026#34;type of a:\u0026#34;, reflect.TypeOf(a)) fmt.Println(\u0026#34;value of a:\u0026#34;, reflect.ValueOf(a)) value := reflect.ValueOf(a) fmt.Printf(\u0026#34;type of value:%T\\n\u0026#34;, value) // reflect.Value newA := value.Interface().(float64) fmt.Printf(\u0026#34;type of newA:%T\\n\u0026#34;, newA) // float64 } 需要注意型別轉換需要完全一致，否則將會 panic，例如指標\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) func main() { a := 3.14 fmt.Println(\u0026#34;type of a:\u0026#34;, reflect.TypeOf(a)) fmt.Println(\u0026#34;value of a:\u0026#34;, reflect.ValueOf(a)) // 傳遞位址 point := reflect.ValueOf(\u0026amp;a) fmt.Printf(\u0026#34;type of value:%T\\n\u0026#34;, point) // reflect.Value // 轉換型別為指標 newA := point.Interface().(*float64) fmt.Printf(\u0026#34;type of newA:%T\\n\u0026#34;, newA) // *float64 } 也就是說反射可以將 \u0026ldquo;反射型別物件\u0026rdquo; 再重新轉換為 \u0026ldquo;介面型別變數\u0026rdquo;\n未知原始資料型別 透過遍歷探尋 Field 獲得\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) type Person struct { // 一行為一個 field Name string Age int Rank float64 } // 注意方法為公有，若私有則無法存取 func (person Person) Sleep() { fmt.Println(\u0026#34;person sleep\u0026#34;) } func main() { p := Person{\u0026#34;zhangSan\u0026#34;, 18, 5.2} getFieldAndMethod(p) } func getFieldAndMethod(input interface{}) { getType := reflect.TypeOf(input) fmt.Println(\u0026#34;type:\u0026#34;, getType.Name()) getValue := reflect.ValueOf(input) fmt.Println(\u0026#34;value/AllField:\u0026#34;, getValue) // 獲取屬性 numField := getValue.NumField() for i := 0; i \u0026lt; numField; i++ { fieldType := getType.Field(i) fieldValue := getValue.Field(i).Interface() fmt.Printf(\u0026#34;%s: %v = %v\\n\u0026#34;, fieldType.Name, fieldType.Type, fieldValue) } // 獲取方法 numMethod := getType.NumMethod() for i := 0; i \u0026lt; numMethod; i++ { method := getType.Method(i) fmt.Printf(\u0026#34;%s: %v\\n\u0026#34;, method.Name, method.Type) } } 透過 reflect.Value 賦值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) func main() { a := 3.14 // 只有是指標時才可賦值 pointer := reflect.ValueOf(\u0026amp;a) // 設置指向該位址，獲取原始值 newValue := pointer.Elem() // 判斷是否可以設置值 fmt.Println(\u0026#34;value canSet:\u0026#34;, newValue.CanSet()) if newValue.CanSet() { // 如果可以設置 newValue.SetFloat(9.96) // 顯示變數值 fmt.Println(\u0026#34;value of a:\u0026#34;, a) // 9.96 } else { fmt.Println(\u0026#34;error\u0026#34;) } } 透過 reflect.Value 呼叫方法 透過函式名稱呼叫\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) type User struct { name string age int } func (user User) MethodHasArgs(a string, b int) { fmt.Println(\u0026#34;User MethodHasArgs\u0026#34;) } func (user User) MethonNotArgs() { fmt.Println(\u0026#34;User MethodNotArgs\u0026#34;) } func main() { user := User{\u0026#34;zhangSan\u0026#34;, 18} value := reflect.ValueOf(user) // 透過函式名稱呼叫 method1 := value.MethodByName(\u0026#34;MethodHasArgs\u0026#34;) // 構建參數 args1 := []reflect.Value{reflect.ValueOf(\u0026#34;string\u0026#34;), reflect.ValueOf(18)} // 呼叫函式 method1.Call(args1) // 無參呼叫 method2 := value.MethodByName(\u0026#34;MethonNotArgs\u0026#34;) args2 := make([]reflect.Value, 0) method2.Call(args2) } 反射的基本原理 ","date":"2024-12-03T14:07:18+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/204/","title":"GoLang 反射"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 問題一： https://blog.yexca.net/archives/198 問題二： https://blog.yexca.net/archives/201 問題三： https://blog.yexca.net/archives/200 問題四： https://blog.yexca.net/archives/202 問題五：此篇文章\n引言 應該快兩週了吧，終於把這份試卷看完了，效率不是普通的低啊。整體來說怎麼說呢，雖然整體難度是比中國 408 的難度低一點，但考試的風格與側重點並不相同，具體來說還是不太好比較。希望下次我的效率可以高一點啊。\n碎碎念 話說最近比較少寫碎碎念了，這其實是因為當我想著要發一篇文章的時候，通常都已經很累了，已經沒有精力寫了。說到這裡就想到以前對於一樣東西從來都只是考慮要不要去學，現在不得不把時間、精力等都算進去了，最近看到的一個梗：\n你就不能一手抓公職考試，一手抓選調，一手抓國考，一手抓省考，一手抓教師證，一手抓留學，一手抓實習，一手抓面試，一手抓轉正，一手抓秋季徵才，一手抓畢業專題，一手抓戀愛？但你還得留一手，因為中國人講究凡事留一手。\n讓我感觸很深，人的精力是有限的，獲得一定收穫的同時，必定會失去一些所得，包括時間、精力、熱情等，這些其實都是可以被量化的變數，只是以前這些變數的上限大於甚至遠大於我的活動，並沒有被發掘而已（當然也可能是透支之類的其他轉換，為了嚴謹加個說明）。隨著年齡的增長，也可以說是經歷或看的事情的增加，慢慢地，越來越多的變數必須被考慮，從而導致我每天都很疲憊且效率低下吧。\n有時候活著很累，可能是我太唯物了，多一點唯心，世界還是比較美好的（我已經不敢對任何事物進行肯定性的描述了，我害怕不確定性，但生活往往沒有確定的事物，雖然這歸因於對變數的不掌握，不多說了，不然又得一大段）。\n背景 考慮一個如圖5.1所示的邏輯電路X，以 $ck$ 為輸入，並輸出 $z_2,z_1,z_0$。這裡，$R_0,R_1,R_2$ 是正緣觸發型（前緣觸發型）D型正反器，初始化時的輸出為0。此外，F是一個邏輯電路，以 $x_2,x_1,x_0$ 為輸入，輸出 $y_2,y_1,y_0$，其構成如圖5.2所示。A和B是圖5.3所示的兩種2輸入閘之一。對電路X的輸入 $ck$ 施加一個以1單位時間為週期的時脈脈衝。以下 $n$ 為正整數，$t$ 為時刻。假設在時刻 $t=0$ 時 $R_0,R_1,R_2$ 已被初始化，且時刻0之後第 $n$ 個時脈脈衝的上升緣所產生的輸出，在時刻 $t=n$ 時穩定地得到 $z_2,z_1,z_0$。此過程如圖5.4所示。此後，電路組成元件（閘、正反器及導線）所造成的延遲，相較於時脈脈衝的週期，足夠小可以忽略不計。\n圖5.1：邏輯電路X 圖5.2：邏輯電路F 圖5.3：2輸入閘 圖5.4：電路X的運作 1 回答以下 a~f 問題。\na）電路F的輸出 $y_2,y_1,y_0$ 僅由輸入 $x_2,x_1,x_0$ 的值決定。執行此類操作的電路名稱，從以下選項中選擇最合適的一項。\n甲　非同步電路\n乙　組合邏輯電路\n丙　循序邏輯電路\n丁　非線性電路\nb）在時刻 $t=n$ 時，電路X的輸出 $z_2,z_1,z_0$ 分別等於時刻 $t=$ 甲 的 $y_2,y_1,y_0$ 值。將甲以 $n$ 的式子表示。\nc）為了使電路X如圖5.4所示般運作，請以圖5.5所示的表格形式完成表示電路F運作的真值表。\n圖5.5：電路F的運作 d）執行如圖5.4所示操作的電路名稱，從以下選項中選擇最合適的一項，並以符號①～④作答。\n① 解碼器 ② 多工器 ③ 計數器 ④ 移位暫存器\ne）為了讓電路X如圖5.4般運作，圖5.2中的A和B應分別填入什麼？從圖5.3中選擇並以符號①～⑥作答。可以使用相同的閘多次。\nf）邏輯變數 $x$ 和 $y$ 的邏輯AND運算以 $xy$ 表示，邏輯OR運算以 $x+y$ 表示，$x$ 的反相（NOT）以 $\\bar{x}$ 表示。電路F的輸出 $y_2$ 為：\n1-解答 1-a 非同步電路是指不使用時脈訊號，各部分獨立運作的電路。 組合邏輯電路是指輸出僅由輸入的當前值決定的電路。 循序邏輯電路是指輸出不僅依賴當前輸入，也依賴內部狀態（例如正反器的輸出）的電路。 非線性電路是指輸入與輸出關係不呈線性的電路。 這題顯然屬於「組合邏輯電路」。\n1-b 因為D型正反器會先接收一個輸入，僅在時脈上升緣觸發時將其放到輸出端。由於狀態更新的同步性，D型正反器會引入一個週期的延遲，所以 甲: $n-1$。\n1-c x_2 x_1 x_0 y_2 y_1 y_0 0 0 0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 1 0 1 1 1 0 0 1 0 0 1 0 1 1 0 1 1 1 0 1 1 0 1 1 1 1 1 1 0 0 0 1-d 解碼器（Decoder）：解碼器是一種將少量輸入訊號解碼為較多輸出訊號的組合邏輯電路。它根據輸入的二進位編碼，啟動對應的輸出線。 多工器（Multiplexer）：多工器是一種從多個輸入訊號中選擇一個訊號輸出的組合邏輯電路。它利用選擇訊號（Select Lines）來決定哪個輸入訊號通過到輸出端。 計數器（Counter）：計數器是一種循序邏輯電路，用於對脈衝訊號進行計數。根據脈衝訊號的個數，計數器的輸出值以特定的方式變化。 移位暫存器（Shift Register）：移位暫存器是一種儲存資料並能按照一定方向移動資料的循序邏輯電路。它由一系列正反器組成。 這題顯然屬於「移位暫存器（Shift Register）」。\n1-e A: ② (OR) B: ① (AND)\n透過真值表及其電路進行分析，因為有多個輸出，可以一個輸出一個輸出地看。由於 $y_0$ 的電路已經決定，首先看 $y_1$ 輸出為 1 時的輸入。\n$x_2$ $x_1$ $x_0$ 0 0 1 0 1 0 1 0 1 1 1 0 分析電路，可以暫時忽略輸入 $x_2$ (從電路或下一問可以知道，簡化後無 $x_2$)。\n然後代入為 1 的輸入進行實驗，得到 A 是 OR 閘，B 是 AND 閘。\n分析 $y_2$ 輸出為 1 時的輸入驗算，結果正確。\n1-f $$ \\begin{align} y_2\u0026=\\bar{x_2}\\bar{x_1}x_0+\\bar{x_2}x_1\\bar{x_0}+x_2\\bar{x_1}x_0+x_2x_1\\bar{x_0} \\\\ \u0026= \\bar{x_2}(\\bar{x_1}x_0+x_1\\bar{x_0})+x_2(\\bar{x_1}x_0+x_1\\bar{x_0}) \\\\ \u0026= \\bar{x_1}x_0+x_1\\bar{x_0} \\end{align} $$2 圖5.6所示的G是一個邏輯電路，以 $x_2,x_1,x_0$ 為輸入，輸出 $y_2,y_1,y_0$。使用G，構成如圖5.7所示的邏輯電路Y，以 $ck$ 為輸入，輸出 $z_2,z_1,z_0$。進一步地，使用Y構成如圖5.8所示的邏輯電路 $X'$。圖5.8中的C和D為圖5.3所示的2輸入閘之一。回答以下 a~e 問題。\n圖5.6：邏輯電路G\n圖5.7：邏輯電路Y\n圖5.8：邏輯電路 $X'$\n圖5.9：電路Y的運作\na）電路G為了得到輸出 $y_0$ 使用了5個閘。請描述一個可以使用圖5.3中列出的2個或更少的閘，來得到與G中 $y_0$ 相同輸出的電路。\nb）對電路Y的輸入 $ck$ 施加一個以1單位時間為週期的時脈脈衝。假設在時刻 $t=0$ 時 $R_0,R_1,R_2$ 已被初始化，且時刻0之後第n個時脈脈衝的上升緣所產生的輸出，在時刻 $t=n$ 時穩定地得到 $z_2,z_1,z_0$。請以圖5.9所示的表格形式完成時刻 $t=1,4,7,12$ 時電路Y的輸出 $z_2,z_1,z_0$。\nc）假設 $m$ 為非負整數。在上述b）所示的條件下，將時刻 $t=m$ 時電路Y的輸出組合 $(z_2,z_1,z_0)$ 視為向量，並表示為 $z(m)$。請回答 $z(m)$ 和 $z(m+1)$ 的漢明距離最大值。\nd）圖5.8的電路X’與圖5.1的電路X表現出同等的行為。此時，請從圖5.3中選擇填入圖5.8中C和D的閘，並以符號①～⑥作答。可以使用相同的閘多次。這裡所稱的「同等行為」是指以下情況：對X’和X各自的輸入 $ck$ 施加一個如圖5.10所示，來自同一脈衝產生源P的1單位時間週期的時脈脈衝。在時刻 $t=0$ 時，X’和X內部的D型正反器被初始化，且時刻0之後第n個時脈脈衝的上升緣所產生的輸出，在時刻 $t=n$ 時，若 $w_2,w_1,w_0$ 和 $z_2,z_1,z_0$ 分別穩定得到，則 $w_2=z_2$ 且 $w_1=z_1$ 且 $w_0=z_0$。\n圖5.10 e）考慮如圖5.11所示的邏輯電路。假設在時刻 $t=t_0$ 時，輸入x和y同時從0變為1。此時預期輸出z會保持0不變，但由於反相器（NOT Gate）的延遲，可能會產生如圖5.12所示的脈衝。此現象稱為毛刺（Glitch，或稱冒險），根據連接的電路，可能會導致誤動作。在圖5.8的電路X’中，如果閘C、D的延遲不能忽略，輸出 $w_0$ 是否可能發生毛刺？請說明，如果可能發生，請提供對策；如果不會發生，請在100字以內說明原因。但假設電路Y的組成元件（閘、正反器及導線）的延遲可以忽略，且 $R_0,R_1,R_2$ 各自的輸出會同時變化。\n圖5.11：可能產生毛刺的邏輯電路範例\n圖5.12：毛刺範例\n2-解答 2-a 分析電路可知 $y_0=x_1x_2+\\bar{x_1}\\bar{x_2}$，等價於 $x_1\\ \\text{XNOR}\\ x_2$，因此可以直接使用一個 XNOR 閘來簡化電路。\n只能使用⑥。\n2-b t $x_0$ $x_1$ $x_2$ $y_0$ $y_1$ $y_2$ 0 0 0 0 1 0 0 1 1 0 0 1 1 0 2 1 1 0 0 1 0 3 0 1 0 0 1 1 4 0 1 1 1 1 1 5 1 1 1 1 0 1 6 1 0 1 0 0 1 7 0 0 1 0 0 0 8 0 0 0 1 0 0 9 1 0 0 1 1 0 10 1 1 0 0 1 0 11 0 1 0 0 1 1 12 0 1 1 1 1 1 可以看到從 $t=7$ 開始循環。\n2-c 漢明距離表示兩個相同長度的二進位向量中，不同位元的數量。\n從上一題的真值表來看，最大為 1。\n2-d C: ③ (XOR) D: ③ (XOR)\n分析兩個電路的時刻表，可以得到真值表。\n$z_0$ $z_1$ $z_2$ $w_0$ $w_1$ $w_2$ 1 0 0 1 0 0 1 1 0 0 1 0 0 1 0 1 1 0 0 1 1 0 0 1 1 1 1 1 0 1 1 0 1 0 1 1 0 0 1 1 1 1 0 0 0 0 0 0 分析電路，可以先看 $w_1$，尋找使 $w_1$ 為 1 的輸入。\n$z_0$ $z_1$ $z_2$ 1 1 0 0 1 0 1 0 1 0 0 1 從電路可知可以忽略 $z_0$，剩下的 $z_1$ 和 $z_2$ 呈現出不同輸出為 1 的情況，也就是互斥或閘（XOR Gate）的形式，即 D 為互斥或閘。\n分析 $w_0$ 為 1 的輸入。\n$z_0$ $z_1$ $z_2$ $z_1 \\oplus z_2$ 1 0 0 0 0 1 0 1 1 1 1 0 0 0 1 1 從電路可知，可以直接觀察 $z_0$ 和 $z_1 \\oplus z_2$，呈現出不同輸出為 1 的情況，也就是互斥或閘（XOR Gate）的形式，即 C 為互斥或閘。\n2-e $w_0$ 有可能發生毛刺。對策包括在輸出端加入緩衝器，或加入同步正反器，抑或是重新檢視電路設計。\n參考文章 布林代數的簡化（公式法與卡諾圖法） ","date":"2024-12-01T18:15:28+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/203/","title":"東京科學大學研究所資訊理工學院 2020 問題五 / 科学大院理工学 2020 問題五"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 問題一： https://blog.yexca.net/archives/198 問題二： https://blog.yexca.net/archives/201 問題三：這篇文章\n問題四： https://blog.yexca.net/archives/202 問題五： https://blog.yexca.net/archives/203 前言 這份考題是演算法題目，初次看到時，有種要放棄治療的感覺，但在做過一遍之後，會覺得難度沒有想像中大，但需要對既有演算法有較高的理解力。之所以說難度沒有想像中大，可能與我心中的預期有關吧，因為我以為可能要設計什麼演算法吧 (我想表達的意思是我並不覺得這份題目簡單)\n本考題版權為東京科學大學所有，僅為方便觀看而引用，無任何營利行為\n1 以兩種不同的演算法，使用 C 語言實作了將包含 n 個元素的整數陣列 a 依遞增順序排列的處理。請從選項中選出最適合填入程式 3.1、3.2 標題 A、B 的演算法名稱，並回答其符號。\n「選項」\n甲、選擇排序\n乙、氣泡排序\n丙、快速排序\n丁、插入排序\n程式 3.1：A 1 2 3 4 5 6 7 8 9 10 11 12 13 void sort_a(int a[], int n) { int i, j, tmp; for(i=0; i\u0026lt;n-1; ++i){ for(j=n-1; i\u0026lt;j; --j){ if(a[j]\u0026lt;a[j-1]){ tmp=a[j]; a[j]=a[j-1]; a[j-1]=tmp; } } } } 程式 3.2：B 1 2 3 4 5 6 7 8 9 10 11 12 13 void sort_b(int a[], int n) { int i, j, tmp; for(j=1; j\u0026lt;n; ++j){ tmp=a[j]; i=j-1; while(0\u0026lt;=i \u0026amp;\u0026amp; tmp\u0026lt;a[i]){ a[i+1]=a[i]; --i; } a[i+1]=tmp; } } 答案\n這份題目是針對兩種排序演算法的程式碼，判斷其使用了哪種排序方法。A 是氣泡排序 (乙、氣泡排序)，B 是插入排序 (丁、插入排序)\n2 關於堆積排序 (Heap Sort)，請回答下列問題。不過，n 為正整數。\na）請說明在二元堆積中，除了根節點以外的任何節點值應滿足的條件 (最大堆積條件或最小堆積條件皆可)。\nb）當二元堆積儲存 n 個元素時，請以 n 的算式表示其樹高。樹高定義為根節點與葉節點之間路徑長度的最大值。\nc）使用堆積排序法排列 n 個元素時，請從以下選項中分別選出其平均時間複雜度和最差時間複雜度的漸近評估最適合的答案。\n甲、$O(1)$\n乙、$O(\\log n)$\n丙、$O(n)$\n丁、$O(n\\log n)$\n戊、$O(n^2)$\n這份題目考堆積排序，第一小題要求寫出除了根節點以外的任何節點值應滿足的條件 (二元樹大頂堆或小頂堆擇一即可)；第二小題是寫出所構成的堆積二元樹的高度；第三小題則是選擇平均時間複雜度和最差情況複雜度。\n答案\na\n最大堆積條件：除了根節點以外的任何節點值，都必須小於或等於其父節點的值。 最小堆積條件：除了根節點以外的任何節點值，都必須大於或等於其父節點的值。 b\n$$ \\left \\lfloor \\log_2n \\right \\rfloor $$c\n平均時間複雜度和最差時間複雜度：丁、$O(n\\log n)$\n3 設 $A=\\{ A[0], A[1], \\cdots, A[n-1] \\}$ 為包含 n 個相異整數的陣列。對於小於 n 的非負整數 $i,j$，若 $i\\lt j$ 且 $A[i]\\gt A[j]$，則稱 $(i,j)$ 為 A 的反轉對，A 的反轉對數量則稱為 A 的反轉數。例如，陣列 $\\{ 5,7,4,6 \\}$ 的反轉對為 $(0,2),(1,2),(1,3)$，反轉數為 3。請回答下列問題。\na）請找出陣列 $\\{ 1,0,4,3,2, \\}$ 的反轉數。\nb）在將集合 $\\{ 1,2,\\cdots,n \\}$ 的所有元素排列而成的陣列 (元素數量為 n 個) 中，請指出反轉數最大的排列方式。此外，請以 n 的算式表示其反轉數。\nc）使用氣泡排序法將集合 $\\{ 1,2,\\cdots,n \\}$ 的所有元素排列而成的任意陣列 B (元素數量為 n 個) 依遞增順序排列。此時，「氣泡排序法中的 X 與陣列 B 的反轉數相等」的關係成立。請回答填入 X 的適當詞語，並簡潔地說明該關係成立的理由。\n這份題目首先引入了「逆序」的概念 ( 宋浩老師的線性代數課程 有提到)，第一小題要求找出逆序數；第二小題要求找出最大逆序數；第三小題則是寫出氣泡排序法中的什麼與逆序數相等，並說明理由。\n答案\na 反轉數為 4，分別為 (1,0), (4,3), (4,2), (3,2)\nb 最大的反轉數是當排列方式為\n$$ \\{ n, n-1, n-2, \\cdots, 2, 1 \\} $$對於 n 有 n-1 個，對於 n-1 有 n-2 個，以此類推。反轉數為其總和。\n$$ (n-1)+(n-2)+\\cdots+2+1+0=\\frac{n(n-1)}{2} $$ c X：交換次數\n理由：因為每次交換操作都消除一個反轉對。\n氣泡排序法是將每兩個元素進行比較，將順序不對的進行交換，一次操作就是消除一個反轉對。\n4 程式 3.3 是以合併排序 (Merge Sort) 演算法為基礎，使用 C 語言實作將整數陣列依遞增順序排列的處理。請回答下列問題。\n程式 3.3：合併排序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 int mergesort(int a[], int begin, int end, int w[]){ int mid = (begin+end)/2; int i = begin, j = mid+1, k, c=0; printf(\u0026#34;(%d, %d)\\n\u0026#34;, begin, end); if(begin\u0026lt;end){ mergesort(a, begin, mid, w); mergesort(a, mid+1, end, w); for(k=begin; k\u0026lt;=end; ++k){ if(mid\u0026lt;i){ A }else if(end\u0026lt;j){ B }else{ /* ++c */ if(a[i]\u0026lt;a[j]){ C }else{ D } } } for(k=begin; k\u0026lt;=end; ++k){ E } } return 0; } a）請從選項中選出適當的程式碼，填入空格 A、B、C、D、E，以完成程式。不過，假設欲排序的陣列為 a，排序時用於工作區的陣列為 w，並且 mergesort 函式將以下兩行程式碼呼叫。\n1 2 int a[5] = {3, 5, 1, 4, 2}, w[5]; mergesort(a, 0, 4, w); 選項 $$ \\begin{matrix} 甲. a[k]=w[i] \u0026 乙. a[k]=w[i++] \u0026 丙. a[k]=w[++i] \\\\ 丁. a[k]=w[j] \u0026 戊. a[k]=w[j++] \u0026 己. a[k]=w[++j] \\\\ 庚. a[k]=w[k] \u0026 辛. a[k]=w[k++] \u0026 壬. a[k]=w[++k] \\\\ 癸. w[k]=a[i] \u0026 子. w[k]=a[i++] \u0026 丑. w[k]=a[++i] \\\\ 寅. w[k]=a[j] \u0026 卯. w[k]=a[j++] \u0026 辰. w[k]=a[++j] \\\\ 巳. w[k]=a[k] \u0026 午. w[k]=a[k++] \u0026 未. w[k]=a[++k] \\end{matrix} $$b）當使用 a）中所示的程式碼呼叫 mergesort 函式時，標準輸出的第 1 行會印出 $(0,4)$。請分別回答第 3 行、第 5 行、第 7 行會印出的內容。\nc）我們希望找出 mergesort 函式在將引數指定的範圍內陣列元素排序前，執行程式 3.3 第 18 行的總次數 (元素比較次數)。因此，我們將第 17 行 (取消註解) 改為 ++c;，但這還不夠。若要將比較次數儲存到變數 count 中，且使用以下兩行程式碼呼叫，程式 3.3 應如何修改？\n1 2 int a[5] = {3, 5, 1, 4, 2}, w[5]; int count = mergesort(a, 0, 4, w); 不過，不允許使用全域變數或靜態變數。此外，除了第 17 行的修改外，對程式進行的變更僅限於 3 次行替換。行替換指的是將某行的程式碼替換為 60 個字元以內 (不計算空白字元) 的其他程式碼。作答時，請按照下方「答案寫法 (範例)」所示，標註修改的行號和替換後的程式碼。假設第 17 行的註解已取消，請說明其他必要的修改。\n「答案寫法 (範例)」 6行目：printf(\u0026quot;hello\\n\u0026quot;);\n30行目：c= end - begin + 1;\n答案\na\nA: w[k] = a[j++]; 即 卯 B: w[k] = a[i++]; 即 子 C: w[k] = a[i++]; 即 子 D: w[k] = a[j++]; 即 卯 E: a[k] = w[k]; 即 庚 b\n第 3 行: (0,1)\n第 5 行: (1,1)\n第 7 行: (3,4)\nc\n第 8 行: c += mergesort(a, begin, mid, w);\n第 9 行: c += mergesort(a, mid + 1, end, w);\n第 31 行: return c;\n這份題目乍看之下挺嚇人的，但仔細閱讀後會發現考的內容其實還好，理解合併排序後應該就能比較容易解出來。順帶一提，因為我快把演算法忘光了，而且以前都是看動畫來理解 (比較直觀)，解題時很慶幸發現了 不錯的動畫演算法網站 ","date":"2024-11-23T20:35:28+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/200/","title":"東京科學大學 大學院資訊理工學院 2020 問題三 / 科學大院理工學 2020 問題三"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 以前寫的小文章，系統建立時間 2023.12.01\n現在看著之前寫的小文章都不太想發佈，但也捨不得刪，想來想去還是發佈吧，也是自己寫的\nngrok 一鍵設定 前往 官網 註冊帳號並驗證電子郵件後會取得 Authtoken\n下載程式： ngrok - download 新增 Token\n1 ngrok config add-authtoken YourToken 執行 1 ngrok http [Port] 將 [Port] 替換成要監聽的本機埠號\n自行架設 ngrok 參考： ngrok內網穿透 學海無涯-回頭是岸 學海無涯，回頭是岸 frp 參考： frp 內網穿透 ","date":"2024-11-22T22:05:34+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/199/","title":"內網穿透"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 前言 Sometimes it\u0026rsquo;s the people who no one imagines anything of who do the things that no one can imagine\n最近從 畢導影片 彈幕中得知關於圖靈的紀錄片 The Imitation Game（模仿遊戲），順便看了一下，對於片中出現的這句話感觸良多，以此作為形式語言與自動機文章的開篇引言。\n當您開始有點憂鬱的時候，也請看看 Amy 關於此句的感悟 吧。\n基本概念 字母表：符號（字元）的非空有限集合\n$$ {\\textstyle \\sum_1} = \\{0, 1\\} $$字串：由某字母表中符號組成的有限序列\n$$ 若 \\space {\\textstyle \\sum_1} = \\{0, 1\\}，那麼 \\space 0，1，00，101011 \\space 為 \\space {\\textstyle \\sum_1} \\space 上的字串 $$空字串：記為 $\\varepsilon$ ，有 0 個字元的字串。對任意字母表 $\\sum$ 都有 $\\varepsilon \\notin \\sum$\n符號的使用約定\n字母表：$\\sum, \\Gamma, \\cdots$\n字元：$a, b, c, \\cdots$\n字串：$\\cdots,w,x,y,z$\n集合：$A,B,C,\\cdots$\n字串的長度：字串中符號所佔位置的數量\n$$ 對於 \\space {\\textstyle \\sum_1} = \\{0, 1\\}，|0010|=4 $$字串 $x$ 和 $y$ 的串接：將首尾相接得到新字串的運算，記為 $x \\cdot y$ 或 $xy$\n$$ x=01, y=ab, 則 \\space xy=01ab $$字串 $x$ 的 $n$ 次冪 ($n \\ge 0$) ，遞迴定義為\n$$ x^n= \\left \\{ \\begin{matrix} \\varepsilon \u0026 n=0 \\\\ x^{n-1}x \u0026 n \\gt 0 \\end{matrix} \\right . $$$對於 \\space {\\textstyle \\sum_1} = \\{a, b\\} (ba)^2=baba, ba^2=baa$\n集合 $A$ 和 $B$ 的串接，記為 $A\\cdot B$ 或 $AB$ ，定義為\n$$ A \\cdot B = \\{ w |w=x \\cdot y, x \\in A \\space and \\space y \\in B \\} $$若 $\\space A = \\{0, 11\\} \\space B = \\{ab, ba\\} $\n$AB = \\{ 0ab, 0ba, 11ab, 11ba \\}, BA= \\{ ab0, ab11, ba0, ab11 \\}$\n集合 $A$ 的 $n$ 次冪 ($n \\ge 0$) ，遞迴定義為\n$$ A^n= \\left \\{ \\begin{matrix} \\{ \\varepsilon \\} \u0026 n=0\\\\ A^{n-1}A \u0026 n \\ge 1 \\end{matrix} \\right . $$$對於 \\space {\\textstyle \\sum_1} = \\{0, 1\\} $，有 ${\\textstyle \\sum^0}=\\{\\varepsilon\\}, {\\textstyle \\sum^1}=\\{0,1\\}, {\\textstyle \\sum^2}=\\{00,01,10,11\\}, \\cdots$\n克林閉包 (Kleene Closure) : 將某字母表的所有冪（包含零次）取聯集得到\n$$ {\\textstyle \\sum^*} = \\bigcup_{i=0}^{\\infty}{\\textstyle \\sum^i} $$正閉包 (Positive Closure) : 將某字母表的所有冪（不包含零次）取聯集得到\n$$ {\\textstyle \\sum^+} = \\bigcup_{i=1}^{\\infty}{\\textstyle \\sum^i} $$顯然\n$$ {\\textstyle \\sum^*} = {\\textstyle \\sum^+} \\cup \\{ \\varepsilon \\} $$語言 定義：若 $\\sum$ 為字母表且 $\\forall L \\subseteq \\sum^*$ ，則 $L$ 稱為字母表 $\\sum$ 上的語言\n自然語言、程式設計語言等 $ \\\\{ 0^n 1^n \\mid n \\ge 0 \\\\} $ The set of strings of 0\u0026rsquo;s and 1\u0026rsquo;s with an equal number of each $\\emptyset$ ，$\\{ \\varepsilon \\}$ 和 $\\sum^*$ 分別都是任意字母表 $\\sum$ 上的語言，但 $\\emptyset \\ne \\{ \\varepsilon \\}$ 語言唯一的限制就是所有字母表都是有限的\n","date":"2024-11-19T22:18:42+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/197/","title":"形式語言與自動機 - 基本概念"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 引言 2022 SA am2\n01-08: http://127.0.0.1:4000/archives/191 09-15: http://127.0.0.1:4000/archives/192 16-20: http://127.0.0.1:4000/archives/193 21-25: http://127.0.0.1:4000/archives/194 這五題的難度還可以，原本解完充滿自信的，不小心看了下下午論述題，我瞬間沒自信了 :cry:\n碎碎念 思考人生這種事情也確實是空閒的人會思考的，忙起來後也就沒時間去胡思亂想了 但忙過頭了說不定也會想呢\n我現在應該是意識到自己之前的兩點不足了。首先是總覺得隨時都能複習；其次是「學無止境」這個觀念的誤用。\n應該先從學無止境開始吧。「學無止境」本身是正確的，但我對這個概念的理解有些偏頗。我一直認為知識是無限的，總覺得自己不可能完全掌握任何東西，也因此產生了「什麼都不會」的心態。實際上，雖然知識的確無窮無盡，但並不代表每個領域都必須完全精通才能實際應用。有時，掌握其中一部分內容已經足以應對工作和任務了\n例如我常常在通過一門考試之後，依然會覺得自己一無所知，仍然無法勝任相關工作。然而，客觀來說，只要掌握了必要的部分內容，就已經具備了完成相關任務的能力。這種心態可能和我過去受到的教育有關，常常聽到類似「世界很大」、「所學遠遠不夠」、「真正的高手有多厲害」等話語。這種觀念在一定程度上鼓勵了學習，卻也讓我過於關注自身的不足，逐漸失去了原本的信心\n就像現在我聽到的多數學生也會說「我什麼都做不到」之類的話語，可能有一部分原因是這種觀念帶來的副作用\n然後就是隨時都能複習的想法。倒也不是複習，更像是一種「隨時可以查閱」的依賴心理。我之前備考日文 N2 時讀到一篇文章，講述了沒有文字的人如何學習之類的，因為沒有文字的記載，對於知識的獲取如上課可能是此生只有一次機會聽到該內容，所以必須全部努力記下來才行；文章還提到了我們因為網路很便利而不去記憶一些東西，並且認為網路能檢索到的東西都是自己的知識，但假如網路不能用的話事實上是不知道那些內容的，所以真正屬於自己的知識是那些已經內化到記憶中的東西。\n回到我的情況，我也是因為覺得可以隨時看，比如某條 Linux 指令啦或某段演算法程式碼之類的而不去記憶，造成一種我以為我會，但用的時候並不能寫出來，實際上應該屬於不會的範疇。這樣反覆的經歷也加深了前面提到的「什麼都不會」感覺。\n總結一下，首先應當意識到未被記憶的東西應該屬於不會，並且勝任某件作業或者可以成為某種角色所需掌握的知識是有邊界的，不用去嘗試完全精通\n感覺寫出來和想表達的意思還是有點偏差，文筆不好還使用了 ChatGPT，就這樣吧\n21 容量が a M バイトでアクセス時間がｘナノ秒の命令カッシュと、容量が b M バイトでアクセス時間がｙナノ秒の主記憶をもつシステムにおいて、CPUからみた、主記憶と命令キャッシュとを合わせた平均アクセス時間を表す式はどれか。ここで、読み込みたい命令コードが命令キャッシュに存在しない確率をｒし、キャッシュ管理に関するオーバヘッドは無視できるものとする。\n$$ \\begin{align} ア　\u0026\\frac{(1-r)\\cdot a}{a+b} \\cdot x +\\frac{r \\cdot b}{a+b} \\cdot y \\\\ イ　\u0026(1-r) \\cdot x + r \\cdot y \\\\ ウ　\u0026\\frac{r \\cdot a}{a+b} \\cdot x + \\frac{(1-r) \\cdot b}{a+b} \\cdot y \\\\ エ　\u0026r \\cdot x + (1-r) \\cdot y \\end{align} $$題目翻譯：容量為 a MB、存取時間為 x 奈秒的指令快取和容量為 b MB、存取時間為 y 奈秒的主記憶體構成的系統中，從 CPU 的角度來看，主記憶體和指令快取的平均存取時間的表達式是哪一個？其中，所需的指令代碼不存在於指令快取中的機率為 r，可以忽略與快取管理相關的開銷\n命中快取時間是 $(1-r) \\times x$ 未命中快取，讀取主記憶體時間為 $r \\times y$ 所以答案選 イ\n22 データベースサーバのクラスタリング技術の特徴のうち、シェアードエブリシングはどれか。\nア　クラスタリング構成にして可用性を高めることによって、故障発生時に担当していた範囲のデータを待機系のサーバに引き継ぐことができる。\nイ　サーバごとに管理する対象データが決まっているので、1台のサーバに故障が発生すると故障したサーバが管理する対象データを処理できなくなり、システム全体の可用性が低下する。\nウ　データを複数の磁気ディスクに分割配置し、更にサーバと磁気ディスクが1対1に対応しているので、複数サーバを用いた並列処理ができる。\nエ　負荷を分散し、全てのサーバのリソースを有効活用できることに加えて、データを共有することによって1台のサーバに故障が発生したときでも処理を継続することができる。\n題目翻譯：在資料庫伺服器的叢集技術 (clustering) 特性中，以下哪一項描述了 Shared Everything 的特點\nア　透過叢集配置提高可用性，故障發生時可以將負責的範圍內數據轉交給備用伺服器\nイ　每個伺服器負責管理特定數據，因此如果某個伺服器發生故障，則無法處理該伺服器負責的數據，系統的整體可用性會下降\nウ　數據被分割並放置在多個磁碟上，伺服器和磁碟之間是一對一的對應關係，因此可以利用多個伺服器進行平行處理\nエ　在負載分散的同時可以有效利用所有伺服器資源，並且透過共享數據，即使某一台伺服器發生故障，也能繼續處理\nShared Everything 是一種資料庫叢集架構，在該架構中，所有伺服器共享相同的數據儲存。這樣一來，任何一台伺服器的資源都可以存取和處理資料庫中的所有數據，從而提高系統的備援性和容錯能力。如果一台伺服器出現故障，其他伺服器可以接管該伺服器的任務，不會導致系統整體不可用。所以答案選 エ\n選項 ア 描述的是主備架構；選項 イ 描述的是 Shared Nothing 架構；選項 エ 描述的是 Shared Disk 架構 (最後兩個架構看看就好 doge)\n23 幾つかのサブシステムから成るシステムの信頼性に関する記述のうち、適切なものはどれか。\nア　あるサブシステムで発生したフォールトの影響が他のサブシステムに波及することを防ぐフォールトマスグは、システムのMTBFは変化させないが、MTTRの短縮につながる。\nイ　サブシステムにフォールトが検出されたとき、再試行すると正しい結果が得られる場合もあるので、再試行はシステムのMTBFの向上とMTTRの短縮につながる。\nウ　サブシステムの稼働中に行われるフォールトの検出は、システムを停止せず行われるので、システムのMTTRは変化させないが、MTBFの向上につながる。\nエ　フォールトが発生したあるサブシステムを切り離して、待機系のサブシステムに自動で切り替えるフェールオーバーは、システムのMTBFは変化させないが、MTTRの短縮につながる。\n題目翻譯：以下關於由多個子系統組成的系統的可靠性的描述中，哪一項是正確的\nア　故障隔離 (Fault Masking) 防止某個子系統中發生的故障影響到其他子系統，雖然不改變系統的平均無故障時間 (MTBF)，但可以縮短平均修復時間 (MTTR)\nイ　當檢測到子系統中有故障時，重試可能會得到正確的結果，因此重試會提升系統的 MTBF，並縮短 MTTR\nウ　在子系統運作過程中進行的故障檢測不會停止系統，因此不會改變系統的 MTTR，但可以提升 MTBF\nエ　發生故障的子系統會被隔離，並自動切換到備用子系統的故障轉移 (Failover) 機制不會改變系統的 MTBF，但可以縮短 MTTR\n對於多子系統組成的系統來說，可靠性通常取決於 MTBF 和 MTTR。MTBF 是 Mean Time Between Failures。MTTR 是 Mean Time To Repair (Recovery)。\nFault Masking (故障隔離) 確保故障不會蔓延至其他子系統。故障隔離的確減少了受故障影響的子系統數量，幫助快速修復，但不會直接影響系統的 MTBF，因為它只是隔離了故障，而不是防止故障的發生\n重試在系統中可以用於處理偶發的錯誤。但它屬於容錯機制，並不能提高系統整體的 MTBF。因為系統的根本故障沒有減少，這一機制只是避免了某些操作失敗\n故障檢測能在運作過程中提升系統的 MTBF，但與 MTTR 無關\nFailover (故障轉移) 將故障系統切換至備用系統，提升系統恢復能力。這種方式透過快速替換故障系統，確實有效地縮短了 MTTR，但不會影響 MTBF，因為它只是縮短了恢復時間\n總之 ア 和 エ 我是沒明白，答案選 エ。可能故障隔離不是直接恢復被故障影響的功能或組件，而故障切換在縮短恢復時間方面更加直接有效吧\n24 $t_{1} \\sim t_{10}$ の時刻でスケジュールされたトランザクション $T_1 \\sim T_4$ がある。時刻 $t_{10}$ で $T_1$ が commit を発行する直前の、トランザクションの待ちグラフを作成した。a に当てはまるトランザクションはどれか。ここで、select(X) は共有ロックを掛けて資源 X を参照することを表し、update(X) は専有ロックを掛けて資源 X を更新することを表す。これらのロックは、commit された時にアンロックされるものとする。また、トランザクションの待ちグラフの矢印は、$T_i \\rightarrow T_j$ としたとき、$T_j$ がロックしている資源のアンロックを、$T_i$ を待つことを表す。\n（トランザクションのスケジュール$t_1$）\n時刻 $T_1$ $T_2$ $T_3$ $T_4$ $t_1$ select(A) $t_2$ select(B) $t_3$ select(B) $t_4$ select(A) $t_5$ update(B) $t_6$ select(C) $t_7$ select(C) $t_8$ update(C) $t_9$ update(A) $t_{10}$ commit （トランザクションの待ちグラフ）\nア　$T_1$\nイ　$T_2$\nウ　$T_3$\nエ　$T_4$\n題目翻譯：在時刻 $t_{1} \\sim t_{10}$ 之間，排程了交易 $T_1 \\sim T_4$。在時刻 $t_{10}$ 時，交易 $T_1$ 在 commit 前，構建了交易的等待圖。請問在圖中位置 a 所指的交易是哪一個？這裡，select(X) 表示對資源加共享鎖並讀取，update(X) 表示對資源加排他鎖並修改。所有的鎖會在交易提交時解鎖。並且在等待圖中，箭頭 $T_i \\rightarrow T_j$ 表示交易 $T_i$ 正在等待交易 $T_j$ 解鎖其持有的資源\n關於資料庫的並行控制 (X 鎖和 S 鎖) 可以參見： https://blog.yexca.net/archives/92 這裡首先共享鎖 (S 鎖) 是可以被其他交易讀取的，所以並不會發生阻塞，也就是一直到 $t_5$ 時刻 $T_4$ 的 update(B) 想對資源 B 加排他鎖 (X 鎖)，但資源 B 此時被 $T_2$ 和 $T_3$ 加共享鎖而阻塞，圖中受到兩個阻塞的有 b 和 c。也就是 $T_4$ 可能是 b 或者 c\n然後 $t_8$ 時刻 $T_2$ 想對 C 加排他鎖，此時資源 C 被 $T_1$ 阻塞 (因為 $T_1$ 持有 S 鎖)，所以 $T_1$ 阻塞 $T_2$。圖中只有一個阻塞的是 a。基本可以斷定其就是 $T_2$\n最後 $t_9$ 想對 A 施加排他鎖，此時 A 被 $T_1$ 和 $T_4$ 施加共享鎖，所以被其阻塞，符合條件的有 b 和 c。\n之後就是提交釋放鎖了，未被阻塞的只有 $T_1$ 所以是 d，根據上述分析可以知道 a 是 $T_2$、b 是 $T_4$、c 是 $T_3$。所以答案選 イ\n25 図は、既存の電話機とPBXを使用した企業内の内線網を、IPネットワークに統合する場合の接続構成を示している。図中の $a \\sim c$ に該当する装置の適切な組合せはどれか。\n- a b c ア PBX VoIPゲートウェイ ルータ イ PBX ルータ VoIPゲートウェイ ウ VoIPゲートウェイ PBX ルータ エ VoIPゲートウェイ ルータ PBX 題目翻譯：圖中展示了一個企業內部的內線網路在整合到 IP 網路時的連接構成。請問圖中 $a \\sim c$ 所對應的設備正確組合是哪一項\n- a b c ア PBX VoIP 閘道器 路由器 イ PBX 路由器 VoIP 閘道器 ウ VoIP 閘道器 PBX 路由器 エ VoIP 閘道器 路由器 PBX 為了將傳統電話系統整合進 IP 網路結構，需要一些設備：\nPBX (Private Branch Exchange，專用分機交換機)：這是傳統電話系統的核心設備，負責管理和控制企業內部電話的交換與連接 VoIP 閘道器：充當傳統電話系統與 IP 網路之間的橋梁，將類比訊號轉換為 IP 封包，以便在 IP 網路上傳輸 路由器：負責在 IP 網路上管理和轉發封包，確保封包能夠到達目的地 所以答案選 ア\n","date":"2024-11-08T18:29:54+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/194/","title":"2022 SA am2 -21-25"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 引言 2022 SA am2\n01-08: http://127.0.0.1:4000/archives/191 09-15: http://127.0.0.1:4000/archives/192 16-20: http://127.0.0.1:4000/archives/193 21-25: http://127.0.0.1:4000/archives/194 漸漸不會起來了呢，不過還是可控的 (doge\n16 e シールの説明はどれか。\nア　インターネット上のゲーム内に限定されたキャラクターのイメージデータの作成者を証明する仕組みの一つである。\nイ　個人の意思表示をしている個人の本人確認が必要な電子文書データについて、その電子文書データの作成者の証明と改ざん防止のために、個人が行う電子署名である。\nウ　電子文書データの作成者の証明と改ざん防止のために、重要文書を扱う国や地方自治体などの公共機関だけに使用が許されている電子署名である。\nエ　法人が作成した電子文書データについて、その電子文書データの作成者が間違いなくその法人であり、かつその電子文書データは作成後に改ざんされていないことを証明するものである。\n題目翻譯：e シール（電子印章）的說明是哪一項\nア　這是在網際網路上證明遊戲角色形象資料的建立者的一種機制，限定於遊戲內使用。\nイ　這是個人對電子文件資料進行的電子簽章，用於證明該電子文件的建立者身分並防止竄改。\nウ　為了證明電子文件資料的建立者身分並防止竄改，僅限國家和地方政府等公共機構使用的電子簽章。\nエ　針對法人建立的電子文件資料，證明該文件的建立者確實是該法人，並確保該文件在建立後未被竄改。\ne シール 通常用於法人或機構對電子文件的認證，確保文件的建立者是法人並且沒有被竄改。因此正確答案為選項 エ\n17 マルチベクトル型 DDoS 攻撃に該当するものはどれか。\nア　攻撃対象のWebサーバ1台に対して、多数のPCから一斉にリクエストを送ってサーバのリソースを枯渇させる攻撃と、大量のDNS通信によってネットワークの帯域を消費する攻撃を同時に行う。\nイ　攻撃対象のWebサイトのログインパスワードを解読するために、ブルートフォースによるログイン試行を、多数のスマートフォン、IoT機器などから成るボットネットを踏み台にして一斉に行う。\nウ　攻撃対象のサーバに大量のレスポンスが同時に送り付けられるようにするために、多数のオープンリゾルバに対して、送信元IPアドレスを攻撃対象のサーバのIPアドレスに偽装した名前解決のリクエストを一斉に送信する。\nエ　攻撃対象の組織内の多数の端末をマルウェアに感染させ、当該マルウェアを遠隔操作することによってデータの改ざんやファイルの消去を一斉に行う。\n題目翻譯：以下哪項屬於多向量型 DDoS 攻擊\nア　對目標的 1 台 Web 伺服器，從大量 PC 同時發送請求使伺服器資源枯竭，同時進行大量的 DNS 通訊消耗網路頻寬。\nイ　為了破解目標網站的登入密碼，使用暴力破解嘗試登入，同時利用大量智慧型手機和 IoT 設備構成的殭屍網路進行一齊攻擊。\nウ　為了向目標伺服器發送大量回應資料，透過多個開放的 DNS 解析器，將請求的發送源偽裝成目標伺服器 IP 位址，批量發送網域名稱解析請求。\nエ　透過感染目標組織內部的大量終端設備，使這些設備感染惡意軟體，透過遠端操作進行資料竄改或檔案刪除的攻擊。\n多向量型 DDoS 攻擊通常會同時使用不同的攻擊手法。選項 ア 使用了消耗伺服器資源和消耗網路頻寬的兩種方式，因此是一個多向量攻擊；而選項 ウ 僅使用 DNS 放大攻擊 (Amplification Attack)，不屬於多向量攻擊。 イ 主要攻擊目標是登入密碼破解，而非多種資源的消耗或網路頻寬的多重佔用；エ 透過惡意軟體感染的入侵攻擊，不是 DDoS 類型的網路頻寬或資源消耗攻擊。所以答案為選項 ア\n18 暗号方式に関する記述のうち、適切なものはどれか。\nア　AESは公開鍵暗号方式、RSAは共通鍵暗号方式の一種である。\nイ　共通鍵暗号方式では、暗号化及び複合に同一の鍵を使用する。\nウ　公開鍵暗号方式を通信内容の秘匿に使用する場合は、暗号化に使用する鍵を秘密にして、複合に使用する鍵を公開する。\nエ　デジタル署名に公開鍵暗号方式が使用されることはなく、共通鍵暗号方式が使用される。\n題目翻譯：關於加密方式的描述，以下哪項是正確的\nア　AES 是一種公鑰加密方式，RSA 是一種對稱金鑰加密方式\nイ　在對稱金鑰加密方式中，加密和解密使用相同的金鑰\nウ　在公鑰加密方式用於通訊內容保密時，加密所用的金鑰應保密，解密所用的金鑰應公開\nエ　數位簽章不會使用公鑰加密方式，而是使用對稱金鑰加密方式\n這題屬於加密領域，答案是選擇 イ。AES 是對稱加密演算法，其他選項可以參考我不知道啥時收藏的一篇文章： 一文詳解 RSA 非對稱加密演算法 19 CRYPTREC の役割として、適切なものはどれか。\nア　外国為替及び外国貿易法で規制されている暗号装置の輸出許可申請を審査、承認する。\nイ　政府調達においてIT関連製品のセキュリティ機能の適切性を評価、認証する。\nウ　電子政府での利用を推奨する暗号技術の安全性を評価、監視する。\nエ　民間企業のサーバに対するセキュリティ攻撃を監視、検知する。\n題目翻譯：關於 CRYPTREC 的作用，以下哪項描述是正確的\nア　根據《外匯及外國貿易法》審查和批准受限制的加密設備的出口許可申請\nイ　在政府採購中，對 IT 相關產品的安全功能進行適當性評價和認證\nウ　對電子政府中推薦使用的加密技術的安全性進行評估和監控\nエ　監控並檢測針對私營企業伺服器的安全攻擊\nCRYPTREC (Cryptography Research and Evaluation Committees，密碼技術研究和評估委員會) 是日本一個專注於密碼技術的政府專案。其主要職責包括對密碼演算法的研究、評估、推薦和監視，以確保這些演算法的安全性和可靠性，特別是在政府和公共部門的應用中。其核心功能有推薦加密技術、監控和評估安全性以及支持政策制定。其主要目標是確保密碼技術在公共領域的安全應用，防止資訊洩漏和資料竄改等安全事件的發生。所以答案選 ウ\n20 インターネットとの接続において、ファイアウォールのNAPT機能によるセキュリティ上の効果はどれか。\nア　DMZ上にある公開Webサイトの脆弱性を悪用する攻撃を防御できる。\nイ　インターネットから内部ネットワークへの侵入を検知し、検知後の通信を遮断できる。\nウ　インターネット上の特定のWebサービスを利用するHTTP通信を検知し、遮断できる。\nエ　内部ネットワークからインターネットにアクセスする利用者PCについて、インターネットからの不正アクセスを困難にすることができる。\n題目翻譯：在連接到網際網路時，使用防火牆的 NAPT 功能的安全效果是什麼\nア　能夠防禦利用位於 DMZ 上的公開網站漏洞的攻擊\nイ　能夠檢測從網際網路到內部網路的入侵，並在檢測到後阻斷通訊\nウ　能夠檢測並阻止利用特定 Web 服務的 HTTP 通訊\nエ　可以使從內部網路存取網際網路的使用者 PC 更難受到來自網際網路的不正當存取\nNAPT (Network Address Port Translation，網路位址連接埠轉換) 是一種動態地將內部 IP 位址和連接埠映射到外部 IP 位址和連接埠的技術。其主要作用是在共享一個公網 IP 位址時隱藏內部網路的 IP 位址，防止外部設備直接存取內部網路設備，從而提升安全性。所以答案選 エ\n","date":"2024-11-06T22:05:18+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/193/","title":"2022 SA am2 -16-20"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 引言 2022 SA am2\n01-08: http://127.0.0.1:4000/archives/191 09-15: http://127.0.0.1:4000/archives/192 16-20: http://127.0.0.1:4000/archives/193 21-25: http://127.0.0.1:4000/archives/194 從中間的題目開始，難度開始上來了，幾乎都是沒有學過的了，可以收回之前說的我覺得可以過的言論了，不過要是真不學什麼東西直接過倒不如不去考呢，就算考不過，但學到的知識可以影響自己 (怎麼又有要開始的跡象了)\n碎碎念 因為寫得太多了，不用引言了，改成碎碎念得了 (本來是放前面的，但覺得還是文章相關放前面比較好，所以銜接可能有點怪)\n最近每個文章是不是都得來個感悟啊 doge (不知道人的腦洞是有極限的嗎)\n事實上這些感悟或者思考的出現是從去年，我的眼睛開始非常地疼痛，然後我經常就只是躺在床上聽音樂 (不僅是螢幕，就算是看自然的景色也會疼痛)，就是在躺著的時間裡我可能是夢也可能是胡思亂想 (我已經不知道躺著時候我是在夢境還是現實了，眼睛疼痛，同時有時候身體還會難受) 使我想到了可以說對我影響比較深的兩個理論，我將其命名為「狀態行為理論」與「圈理論」，從我將它們大體想出來後，我常常在夢或者對某件事情進行思考的時候想到這兩個理論，對其進行細節的修正，然後再度思考，當然還有一些其他的思考啦，就像最近文章出現的那樣。本來那時候想著把兩個理論寫出來的，但一拖再拖，那股勁沒了就會覺得有點害羞去發表，因為並沒有經過任何的查重驗證之類的發布一個自以為是的理論什麼的，還是有點不大好。當然還有著我平常覺得部落格只是討論技術吧，但現在倒是想開了，學技術第一想法是去尋找相關課程，我寫的東西也沒啥人看，想怎麼造就怎麼造。(莫名想到 warma 介紹爆炸電台的樣子)\n寫到這我去找了下 warma 影片，簡略看了下並沒有找到，可能在消失的第二期吧。但第九期開頭有提到「大家有沒有這種感覺，就是當你去完成一件事，然後你寫好了一個精妙的計劃，這個計劃非常完美，但是你實行起來之後，從第一步開始，就不想照著計劃走了，就感覺我憑什麼要照著計劃來」。這讓我想到了之前我的矛盾，在人生沒有計劃或者被安排時候覺得沒有目標，不知如何行動之類的；但是有計劃或者按照安排來又會覺得自己的人生不自由。然後就導致著自己在這種製作計劃、推翻計劃、再次製作、再次推翻的循環中，最終一事無成。事實上我倒是處於這個狀態，想要什麼但不會去接近它，害怕失去，一次小小的接近失敗都有可能放棄去接近，當然，這在我昨天晚上想到的信任想法中有所體現，太長了不贅述。但是聽到 warma 說出來我當時會瞬間有將此種狀態打破的感覺 (這也與之前想法有所關聯) ，特定的人說出的話總是會對人生有所影響，這使得我暫時性的擁有可能對部分事情的顧慮。\n不知不覺打了挺多字，雖然還有一些想說的，還是打住比較好吧。說到這突然就理解之前看到的部落格可能會出一些自己的個人總結之類的了 (最近看的也就是 翠翠 的了)\n預覽看了下怎麼快比本文長了\n9 ソフトウェアのテスト工程において、バグ管理図を用いて、テストの進捗状況とソフトウェアの品質を判断したい。このときの考え方のうち、最も適切なものはどれか。\nア　テスト工程の前半で予想以上にバグが摘出され、スケジュールが遅れたので、スケジュールの見直しを行い、五日遅れでテストが終了すると判断した。\nイ　テスト項目がスケジュールどおりに消化され、かつ、バグ摘出の累積件数が増加しなければ、ソフトウェアの品質は高いと判断できる。\nウ　テスト項目消化の累積件数、バグ摘出の累積件数及び未解決バグの件数の全てが変化しなくなった場合は、解決困難なバグに直面しているかどうかを確認する必要がある。\nエ　バグ摘出の累積件数の推移とテスト項目の未消化件数の推移から、テスト終了の時期をほぼ正確に予測できる。\n題目翻譯：在軟體的測試階段，想透過使用缺陷管理圖來判斷測試進度和軟體品質。下列關於這種方法的描述中，最合適的是哪一個\nア　由於測試階段的前半部分發現的缺陷超過預期，導致進度延遲，因此重新審視了進度計劃，判斷測試將延遲五天完成。\nイ　如果測試項目按計劃完成，且缺陷的累計發現數量沒有增加，可以認為軟體品質較高。\nウ　當測試項目的累計完成數量、缺陷累計發現數量和未解決缺陷數量都不再變化時，有必要確認是否遇到難以解決的缺陷。\nエ　透過缺陷累計發現數量的變化趨勢和測試項目未完成數量的變化趨勢，可以較準確地預測測試結束時間。\n在測試進度和品質管理中，缺陷管理圖用於視覺化缺陷的累積趨勢和測試的完成情況，透過分析這些趨勢，開發團隊可以更好地了解測試的進展和品質狀況。這題 ア 與缺陷管理圖無關，イ 本身錯誤。剩下的兩個選項描述都是正確的，參考答案是 ウ。可能題目是想判斷軟體的進展與品質，這個選項比較符合吧 (我也不是很理解)\n10 故障の予防を目的とした解析手法であるFMEAの説明はどれか。\nア　個々のシステム構成要素に起こり得る潜在的な故障モードを特定し、それらの影響度を評価する。\nイ　故障を、発生した工程や箇所などで分類して分析し、改善すべき工程や箇所を特定する。\nウ　発生した故障について、故障の原因に関係するデータ、事象などを収集し、”なぜ”を繰り返して原因を掘り下げ、根本的な原因を追究する。\nエ　発生した故障について、その引き金となる原因を列挙し、それらの関係を木構造で表現する。\n題目翻譯：以下哪項是為了預防故障而進行的 FMEA (失效模式與影響分析) 方法的說明\nア　識別系統各個組成要素中可能發生的潛在故障模式，並評估它們的影響程度。\nイ　對故障按照發生的程序或位置等進行分類分析，並確定需要改進的程序或位置。\nウ　針對發生的故障，收集與故障原因相關的資料和事件，並不斷追問「為什麼」，以深入探討根本原因。\nエ　針對發生的故障，列舉其誘發原因，並將這些關係以樹狀結構表示出來。\nFMEA (Failure Mode and Effects Analysis，失效模式與影響分析) 是一種系統化的方法，旨在識別系統或元件中的潛在故障模式、評估其影響，並採取措施預防潛在故障的發生。它主要應用於預防性維護和設計改進。因此答案是 ア\nイ 是故障分類分析方法；ウ 是 RCA (根本原因分析)；エ 是 FTA (故障樹分析)\n11 JIS X 0160:2021 (ソフトウェアライフサイクルプロセス) によれば、廃棄プロセスのタスクのうち、アクティビティ“廃棄を確実化する”において実施すべきタスクはどれか。\nア　選定されたソフトウェアシステム要素を再利用、再生利用、再調整、分解修理、保管又は破壊する。\nイ　ソフトウェアシステムの廃棄戦略を定義する。\nウ　ソフトウェアシステム又は要素を不活化して取り除くための準備する。\nエ　廃棄後の、人の健康、安全性、セキュリティ及び環境への有害な状況が識別されて対処されていることを確認する。\n題目翻譯：根據 JIS X 0160:2021 (軟體生命週期程序) ，在廢棄程序的任務中，應執行「確保廢棄」的活動中的哪項任務\nア　對選定的軟體系統元素進行再利用、回收、重新調整、拆解修復、保管或銷毀。\nイ　定義軟體系統的廢棄策略。\nウ　為停用並移除軟體系統或其組件做好準備。\nエ　確認廢棄後不會對人類健康、安全、資訊安全及環境造成有害影響。\nア 在描述的是具體的廢棄操作方式，屬於廢棄程序的具體任務；イ 是制定廢棄策略的程序，屬於廢棄活動的計劃和策略制定階段；ウ 是在廢棄前的工作；エ 確保了不會產生負面影響，符合題意。因此答案是 エ\n12 JIS X 0160:2021 (ソフトウェアライフサイクルプロセス) によれば、ライフサイクルモデルの目的及び成果を達成するために、ライフサイクルプロセスを修正するか、又は新しいライフサイクルプロセスを定義することを何というか。\nア　シミュレーション\nイ　修整（Tailoring）\nウ　統治（Governance）\nエ　ベンチマーキング\n題目翻譯：根據 JIS X 0160:2021 (軟體生命週期程序) ，為了實現生命週期模型的目的和成果，對生命週期程序進行修改或定義新的生命週期程序的行為稱為什麼\nア　Simulation (模擬)\nイ　Tailoring (修整/裁剪)\nウ　Governance (治理)\nエ　Benchmarking (基準測試/標竿管理)\nSimulation (模擬) 指透過模型來模擬系統的行為；Tailoring (修整) 指根據特定需求對現有的生命週期程序進行調整或定義新的程序，以適應專案的目標和成果；Governance (治理) 指對組織、專案的管理和監督；Benchmarking (基準測試) 指對比最佳實踐或行業標準，以改進效能。因此答案是 イ\n13 IT 投資に対する評価指標の設定に際し、バランススコアカードの手法を用いてKPIを設定する場合に、内部ビジネスプロセスの視点に立ったKPIの例はどれか。\nア　ITリテラシ向上のための研修会の受講率を100％とする。\nイ　売上高営業利益率を前年同期比5％アップとする。\nウ　顧客クレーム件数を1か月当たり20件以内とする。\nエ　注文受付から製品出荷までの日数を3日短縮とする。\n題目翻譯：在設定 IT 投資的評估指標時，如果使用平衡計分卡的方法設定 KPI，那麼從內部業務流程的視角來看，以下哪項是 KPI 的示例\nア　將 IT 素養提高的培訓出席率設為 100%\nイ　將營業利潤率比去年同期提高 5%\nウ　將客戶投訴數量控制在每月 20 件以內\nエ　將從訂單接受到產品出貨的天數縮短 3 天\n平衡計分卡 (Balanced Scorecard，簡稱 BSC) 是一種策略管理和績效衡量工具，用於幫助組織從多維度評估和提升其整體績效。它透過將傳統的財務指標與非財務指標相結合，提供了一種平衡的管理方式，使企業能夠從更全面的角度來設定和評估策略目標，確保長期策略與日常營運的有機結合。主要從四個方面設定：\n財務觀點：關注財務表現和目標，比如收入增長、成本控制、利潤率等。傳統財務指標如 ROI (投資報酬率) 也屬於這一觀點 客戶觀點：關注客戶的滿意度和市場佔有率，指標可能包括客戶滿意度、投訴數量、客戶保持率等，用以衡量客戶的體驗和忠誠度 內部業務流程觀點：關注組織內部的營運流程效率，指標可能包括生產週期、訂單處理時間、品質控制等，這個觀點旨在優化企業內部的關鍵流程和效率 學習與成長觀點：關注員工發展和組織創新，指標可能包括培訓參加率、員工技能提升、員工滿意度等，確保企業擁有持久發展的動力和創新能力 因此答案是 エ\n14 組込みシステム開発において、製品に搭載するLSIを新規に開発する。LSI設計を自社で行い、LSI製造を外部に委託する場合の委託先として、適切なものはどれか。\nア　IPプロバイダ\nイ　デザインハウス\nウ　ファウンドリ\nエ　ファブレスメータ\n題目翻譯：在嵌入式系統開發中，計劃新開發搭載在產品上的 LSI (大型積體電路) 。若 LSI 的設計由本公司負責，而 LSI 的製造委外，作為承接方適當的是哪個\nア　IP Provider\nイ　Design House\nウ　Foundry (晶圓代工)\nエ　Fabless Manufacturer (無廠半導體商)\nIP Provider 指提供 LSI 設計中所需的智慧財產權 (IP) 模組的公司，主要提供各種半導體設計所用的預製 IP 模組，但不負責實際的晶片生產製造；Design House 指幫助其他公司完成 LSI 設計的公司；Foundry 指專門負責生產 LSI 等半導體晶片的公司，為沒有生產能力的設計公司提供製造服務；Fabless Manufacturer 指無工廠的半導體公司，通常負責晶片設計，而把生產委外給 Foundry 公司進行。因此答案選 ウ\n15 ラボ契約の特徴はどれか。\nア　依頼元がベンダ企業側の作業担当者を指名して直接指揮命令を行う契約であり、ベンダ企業はこれを前提に要員を割り当てる。\nイ　依頼元は、契約に基づきスキルや人数などの準備を満たすように要員を確保することをベンダ企業に求めるかわりに一定以上の発注を約束する。\nウ　開発したシステムによって依頼元が将来獲得する売上や利益をベンダ企業にも分配することを条件に、開発時のベンダ企業への発注金額を抑える。\nエ　ベンダ企業が契約で定めた最低発注工数を下回って作業を完了した場合には、実稼働工数に基づいて請求することが求められる。\n題目翻譯：實驗室合約 (Lab Contract) 的特點是什麼\nア　委託方指名供應商企業的工作人員並直接指揮命令的合約，供應商企業根據此要求分配人員。\nイ　委託方根據合約要求供應商企業確保符合技能、人數等準備條件，委託方則承諾至少達到一定數量的訂單。\nウ　以將來由所開發的系統獲得的銷售額或利潤分配給供應商企業為條件，從而壓低開發時對供應商企業的發包金額。\nエ　如果供應商企業完成的實際工作工時低於合約中規定的最低發包工時，則要求根據實際工作工時進行結算。\nLab Contract 指的是一種常見於 IT 行業的長期人力資源委外形式。在該合約下，供應商根據委託方的需求 (例如技能或人數) ，分配專門的人員團隊並派駐在委託方處，委託方直接指揮這些人員。此類合約通常不針對具體專案，而是將供應商的人員資源作為長期委外資源。因此答案選 イ。另外 ウ 是收益共享型合約\n","date":"2024-11-04T23:29:15+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/192/","title":"2022 SA am2 -09-15"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 引言 2022 SA am2\n01-08: http://127.0.0.1:4000/archives/191 09-15: http://127.0.0.1:4000/archives/192 16-20: http://127.0.0.1:4000/archives/193 21-25: http://127.0.0.1:4000/archives/194 這份專門試卷難度倒是還好，不過還是有我學過的內容，想必經過一定的學習後我應該可以通過選擇題，希望能早點做完後看看下午題，這才是我合格的關鍵。\n說到這裡，我覺得共通一我的做法很有問題，完全看不懂的情況下做題完全沒有意義，還是慢慢一題一題做比較好。之前我做完後在寫文章解析時，倒是想著快點完成，導致那張試卷幾乎相當於白做，畢竟剛開始一題一題慢慢做也沒關係。\n碎碎念 最近突然覺得學習彷彿是一種連結，靈感來源於語言的學習就是一種將事物與語言的連結，而學習的東西是一種抽象的連結，針對於某種輸入，產生某種輸出，通過不斷地重複加深這種連結。比較直觀的就是知識點的關聯，從某一點推出另一點，彷彿就是兩個知識之間的連結，在看過或者自己推出這個連結後將這種連結加深，這就類似事物與語言詞彙的連結，從而讓人掌握了這個事物，或者說這種連結後，也就掌握了此知識。（當然只是隨便一想而已，無相應證明。事實上我聽到的多數觀點或論據也可能是基於不夠嚴謹的證明，從自己的一段經歷推導出來的。人基於自己的經歷來形成自己的觀點，沒有見過的事物是無法想像的。不過有一個例外，可能就是夢吧，夢確實可能是自己到了某個世界遊歷，當然並不嚴謹，這還是最近我看到一個小說是進入某世界隨機出現在那個世界的某處，然後經歷一番後若有完成特殊條件可以保留那個世界的部分記憶有所收穫，對於自己做的夢倒也是如此從而讓我有了這個推斷。但事後仔細回想後，倒是可能因為睡著後大腦可以專注於想像，此時想像力達到巔峰，從而完成自己醒著時候無法想像到的。比如 DNA 雙螺旋結構的發現人也是從夢中得到的靈感）\n1 アジャイル開発の初期段階において、プロジェクトの目的、スコープなどに対する共通認識を得るために、あらかじめ設定されている設問と課題について関係者が集まって確認し合い、その成果を共有する手法はどれか。\nア　アジャイルモデリング\nイ　インセプションデッキ\nウ　プランニングポーカ\nエ　ユーザストーリマッピング\n題目翻譯：在敏捷開發的初期階段，為了在專案的目的、範圍等方面達成共識，相關人員會聚集在一起確認預先設定的問題與課題，並共享成果。這種方法是哪一種？\nア agile modeling (敏捷建模)\nイ Inception Deck (創始手冊)\nウ planning poker (規劃撲克)\nエ user story mapping (使用者故事對照)\nInception Deck 是一種重要的方法，尤其在專案的初始階段使用，以確保團隊對專案的目的和範圍形成共識。團隊會事先確定並探討一些關鍵性的問題（如專案的目標、潛在風險、成功標準等），這能夠幫助所有團隊成員對專案的整體方向和邊界有清晰的理解並達成一致。因此，正確答案是 イ。\n2 ソフトウェアパターンのうち、GoFのデザインパターンの説明はどれか。\nア　Javaのパターンとして、引数オブジェクト、オブジェクトの可変性などで構成される。\nイ　オブジェクト指向開発のためのパターンであって、生成、構造、振る舞いの三つのカテゴリに分類される。\nウ　構造、分散システム、対話型システム及び適合型システムの四つのカテゴリに分類される。\nエ　抽象度が異なる要素を分割して階層化するためのLayers、コンポーネント分割のためのBrokerなどで構成される。\n題目翻譯：在軟體模式中，GoF (Gang of Four) 設計模式的描述是哪一個？\nア Java 模式，由參數物件和物件的可變性等構成。\nイ 物件導向開發的模式，分為生成 (Creational)、結構 (Structural) 和行為 (Behavioral) 三類。\nウ 分為結構、分散式系統、互動式系統及適應性系統四類。\nエ 為了將不同抽象層次的元素分離並階層化，包含 Layers、Broker 等。\nGoF 的設計模式是由四位軟體工程師提出的經典設計模式，專門用於物件導向程式設計。它將設計模式分為三大類：生成（創建）、結構、行為，用於解決常見的物件導向設計問題。因此，正確答案是 イ。\n我去搜了下 相關介紹 ，貌似就是 我之前寫的設計模式 的由來吧。\n3 Pattern-Oriented Software Architecture (POSA) のアーキテクチャパターンのうち、ソフトウェアをメタレベルとベースレベルの二つのレベルに分割し、ソフトウェアの構造と振る舞いとを動的に変更できる仕組みを提供しているものはどれか。\nア　Broker\nイ　Microkernel\nウ　Model-View-Controller\nエ　Reflection\n題目翻譯：在模式導向軟體架構 (POSA) 的架構模式中，將軟體分為元層 (meta level) 和基礎層 (base level) 兩個層級，並提供一種能夠動態改變軟體結構和行為的機制的是哪一種？\nア Broker (經紀人/代理)\nイ Microkernel (微核心)\nウ Model-View-Controller (模型-視圖-控制器)\nエ Reflection (反射)\nBroker 模式是一種分散式系統架構模式，旨在將系統的不同組件（如用戶端和伺服器）解耦合，透過 Broker 進行通訊。Broker 充當媒介的角色，負責傳遞訊息並管理遠端服務的呼叫。\nMicrokernel 模式通常用於作業系統設計，將核心功能（如記憶體管理、行程管理）保留在微核心中，而將其他選用功能作為獨立模組來實現，能夠動態載入或解除載入。\nModel-View-Controller (MVC) 模式是一種常見的互動式系統架構模式，用於分離應用程式的商業邏輯 (Model)、使用者介面 (View) 和使用者輸入控制 (Controller)。MVC 主要目的是解耦顯示邏輯和商業邏輯，並沒有提供動態改變軟體結構和行為的機制。\nReflection 模式是一種將軟體分為「元層」和「基礎層」兩層的架構模式，元層包含描述系統結構和行為的元資料，而基礎層負責執行實際的商業邏輯。透過反射模式，軟體可以動態修改其結構和行為，以適應不同的需求和場景。這種模式常用於需要高擴充性和靈活性的系統。因此，正確答案是 エ。\n4 組込みシステムでDBMSを用いるときには、通信のオーバヘッド、通信負荷の発生を防ぐこと、必要なメモリ容量をリソース制限内に抑えることなどを目的として、インプロセスデータベースを用いることがある。このインプロセスデータベースの説明として、適切なものはどれか。\nア　クライアントサーバ形式のクライアントとなるアプリケーションプログラムとソケットを介して通信し、SQLを用いて処理を記述する。\nイ　データベースエンジンはライブラリ形式で提供され、アプリケーションプログラムとリンクされて同一メモリ空間で動作する。\nウ　データベースの全体をメモリ上に配置して、データベース処理を高速化する。\nエ　一つのテーブルを一つのファイルで管理し、アプリケーションプログラムからはファイル入出力のAPIで操作する。\n題目翻譯：在嵌入式系統中使用 DBMS 時，常常為了防止通訊開銷 (Overhead)、通訊負荷的產生，並將必要的記憶體容量控制在資源限制範圍內，而使用程序內資料庫 (In-process database)。關於這種程序內資料庫的描述，正確的是哪一個？\nア 透過通訊端 (Socket) 與作為用戶端的應用程式進行通訊，並使用 SQL 進行處理。\nイ 資料庫引擎以函式庫 (Library) 的形式提供，與應用程式連結，在同一記憶體空間中執行。\nウ 將整個資料庫載入到記憶體中，以加快資料庫處理速度。\nエ 將一個資料表管理為一個檔案，並透過檔案 I/O API 從應用程式進行操作。\n程序內資料庫 (インプロセスデータベース) 是指資料庫引擎作為函式庫檔案與應用程式連結，共享同一記憶體空間。這種設計避免了用戶端-伺服器模式帶來的通訊開銷和負載，適合資源受限的嵌入式系統。\nア 選項描述了用戶端-伺服器架構的資料庫，通常透過網路通訊端通訊；ウ 選項描述了「記憶體資料庫」，即將資料庫全部載入至記憶體以提高效能；エ 選項描述了一種基於檔案的資料庫管理方法，通常用於檔案資料庫。因此，正確答案是 イ。\n5 デザインパターンのなかのストラテジパターンを用いて、帳票出力のクラス図のとおりに設計した。適切な説明はどれか。\nア　クライアントは、使用したいフォーマットに対応する、帳票出力ストラテジクラスのサブクラスを意識せずに利用できる。\nイ　新規フォーマット用のアルゴリズムの追加が容易である。\nウ　帳票出力ストラテジクラスの中で、どのフォーマットで帳票を出力するかの振り分けを行っている。\nエ　帳票出力のアルゴリズムは、コンテキストクラスの中に記述する。\n題目翻譯：使用策略模式 (Strategy Pattern) 設計了報表輸出的類別圖。下列哪項描述是正確的？\nア 用戶端可以在不關注具體策略子類別的情況下使用相應的報表輸出格式。\nイ 可以輕鬆添加用於新格式的演算法。\nウ 報表輸出策略類別負責選擇使用哪種格式輸出報表。\nエ 報表輸出的演算法應寫在 Context 類別（上下文類別）中。\n題目是使用策略模式實現了一個多格式報表的分發。策略模式的設計原則是將演算法的實現和使用分離，使得可以在不修改用戶端程式碼的情況下切換或增加不同的演算法。同時我也寫過策略模式的文章： https://blog.yexca.net/archives/137 策略模式的設計使得新演算法的增加非常方便，只需實作新的具體策略類別並與現有結構整合即可。因此，正確答案是 イ。\n6 モジュール間のデータの受渡し方法のうち、最も低いモジュール結合度となるものはどれか。\nア　単一のデータ項目を大域的データで受け渡す。\nイ　単一のデータ項目を引数で受け渡す。\nウ　データ構造を大域的データで受け渡す。\nエ　データ構造を引数で受け渡す。\n題目翻譯：以下關於模組之間的資料傳遞方法，哪一種方式的模組耦合度最低？\nア 使用全域資料傳遞單一資料項。\nイ 使用參數傳遞單一資料項。\nウ 使用全域資料傳遞資料結構。\nエ 使用參數傳遞資料結構。\n這題是考程式的耦合度的，我也寫過一篇文章： https://blog.yexca.net/archives/145#%E8%80%A6%E5%90%88 傳遞單一資料值為資料耦合 (Data Coupling)，傳遞資料結構為標記耦合 (Stamp Coupling)，全域參數應該屬於公共耦合 (Common Coupling)，其中資料耦合的耦合度最低。因此，正確答案是 イ。\n7 既存システムを基に、新システムのモデル化を行う場合のDFD作成の手順として、適切なものはどれか。\nア　現物理モデル -\u0026gt; 現論理モデル -\u0026gt; 新物理モデル -\u0026gt; 新論理モデル\nイ　現物理モデル -\u0026gt; 現論理モデル -\u0026gt; 新論理モデル -\u0026gt; 新物理モデル\nウ　現論理モデル -\u0026gt; 現物理モデル -\u0026gt; 新物理モデル -\u0026gt; 新論理モデル\nエ　現論理モデル -\u0026gt; 現物理モデル -\u0026gt; 新論理モデル -\u0026gt; 新物理モデル\n題目翻譯：基於現有系統進行新系統建模時，建立資料流圖 (DFD) 的步驟順序應為何？\nア 現實體模型 -\u0026gt; 現邏輯模型 -\u0026gt; 新實體模型 -\u0026gt; 新邏輯模型\nイ 現實體模型 -\u0026gt; 現邏輯模型 -\u0026gt; 新邏輯模型 -\u0026gt; 新實體模型\nウ 現邏輯模型 -\u0026gt; 現實體模型 -\u0026gt; 新實體模型 -\u0026gt; 新邏輯模型\nエ 現邏輯模型 -\u0026gt; 現實體模型 -\u0026gt; 新邏輯模型 -\u0026gt; 新實體模型\n這題盲猜選 イ。一般建立資料流圖需要從現有系統的具體實作抽象出業務需求（實體到邏輯），然後再基於現有業務需求改進出邏輯模型，最後實作新的邏輯需求（邏輯到實體）。\n8 ある購買システムの開発において、開発者が行った探索的テストの例として、適切なものはどれか。\nア　過去に購買システムを開発した経験に基づいて、入力項目間の関連チェックの不備を検出できそうなデータパターンを推測し、テストケースを事前に作成してテストした。\nイ　数量の範囲に応じて適用する商品価格が正しいかどうかを確認するために、各範囲の数量の中央の値を用いたテストケースを作成してテストした。\nウ　組織変更の前後で組織名が正しく印刷されるかどうかを確認するために、新組織の有効開始日とその前日とを発注日とするテストケースを事前に作成してテストした。\nエ　入力値の組合せが無効なときは伝票を作成しないことを確認するために、幾つかの代表的な入力値の組合せをテストし、その結果に基づいて次のテストケースを作成してテストしを繰り返した。\n題目翻譯：在一個採購系統的開發中，作為開發者進行的探索性測試的合適例子是哪一個？\nア 根據過去開發採購系統的經驗，推測出可能檢測到輸入項之間關係不完善的測試資料模式，預先建立測試案例並進行了測試。\nイ 為了確認根據數量範圍套用的商品價格是否正確，使用每個範圍中間值的測試案例並進行了測試。\nウ 為了確認組織變更前後的組織名稱是否正確列印，預先建立了使用新組織有效開始日和前一日作為下單日的測試案例並進行了測試。\nエ 為了確認當輸入值組合無效時不產生單據，測試了幾個具代表性的輸入值組合，並根據結果反覆建立新的測試案例進行測試。\n探索性測試是一種在測試過程中動態設計和執行測試的方式，不依賴事先確定的測試案例，而是基於對系統的理解和觀察結果即時調整測試方案。探索性測試的特點在於測試案例並非完全預設，而是根據測試結果不斷調整和補充。\nア、イ、ウ 選項中測試案例都是事先建立好的，符合傳統的事前設計測試，不符合探索性測試的特點。所以正確答案是 エ。\n","date":"2024-11-03T23:11:52+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/191/","title":"2022 SA am2 -01-08"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 引言 2022 SA am1\n01-02: https://blog.yexca.net/archives/184 03-05: https://blog.yexca.net/archives/185 06-10: https://blog.yexca.net/archives/186 11-15: https://blog.yexca.net/archives/189 16-30: https://blog.yexca.net/archives/190 整張試卷寫下來大部分是軟體設計師的感覺，估計有些共通的科目對軟體開發要求較低吧，專門的試卷估計會難一點。大部分題目專有名詞看不懂，但是翻譯過來後是可以會做的，專有名詞的記憶很重要呢。\n第 16 問 次の流れ図において、判定条件網羅（分岐網羅）を満たす最小のテストケースの組みはどれか。\nア　(1) A=0, B=0 (2) A=1, B=1\nイ　(1) A=1, B=0 (2) A=1, B=1\nウ　(1) A=0, B=0 (2) A=1, B=1 (3) A=1, B=0\nエ　(1) A=0, B=0 (2) A=0, B=1 (3) A=1, B=0\n這題是最少需要多少個測試案例才能將每個分支都測試到，就不解析了，答案是選項 イ。\n第 17 問 問題が発生していないが、プログラムの仕様書と現状のソースコードとの不整合を解消するために、リバースエンジニアリングの手法を使って仕様書を作成し直す。これはソフトウェア保守のどの分類に該当するか。\nア　完全化保守\nイ　是正保守\nウ　適応保守\nエ　予防保守\n題目翻譯：問題尚未發生，但為了消除程式的規格說明書與當前原始碼之間的不一致，使用逆向工程的方法重新編寫規格說明書。這屬於軟體維護的哪種分類？\nア　完善性維護\nイ　更正性維護\nウ　適應性維護\nエ　預防性維護\n死去的記憶開始攻擊我，學過但忘光了。完善性維護是指改進軟體功能、效能或其他品質屬性以符合新的標準或要求，即在原本功能的基礎上進行增強與完善；更正性維護是指修復軟體中的缺陷，糾正軟體異常或錯誤；適應性維護是指使軟體適應執行環境的變化，例如相容新的作業系統或硬體；預防性維護是指在未發生問題的情況下，進行維護以預防潛在問題的產生。所以答案為選項 エ。\n第 18 問 ある組織では、プロジェクトのスケジュールとコストの管理にアーンドバリューマネジメントを用いている。期間10日間のプロジェクトの、5日目の終了時点の状況は表のとおりである。この時点でのコスト効率が今後も続くとしたとき、完成時総コスト見積り（EAC）は何万円か。\n管理項目 金額（万円） 完成時総予算（BAC） 100 プランドバリュー（PV） 50 アーンドバリュー（EV） 40 実コスト（AC） 60 ア　110\nイ　120\nウ　135\nエ　150\n題目翻譯：某組織使用實獲值管理 (earned value management) 來管理專案的進度與成本。在一個為期 10 天的專案中，第 5 天結束時的情況如下表所示。如果此時的成本效率在今後繼續保持，那麼完成時的總成本估計 (EAC) 是多少萬日圓？\n管理項目 金額 (萬日圓) 完成時總預算 (BAC) 100 計畫價值 (PV) 50 實獲值 (EV) 40 實際成本 (AC) 60 這題是沒學過的東西呢。完成時的總成本估計 (EAC) 計算方法為：\n$$ EAC=\\frac{BAC}{CPI} $$其中 CPI (成本績效指數) 為：\n$$ CPI=\\frac{EV}{AC} $$帶入數值計算：\n$$ \\begin{align} CPI\u0026=\\frac{40}{60}=\\frac{2}{3} \\\\ EAC\u0026=\\frac{100}{\\frac{2}{3}}=150 \\end{align} $$所以答案為選項 エ。\n第 19 問 ソフトウェア開発プロジェクトにおいて、表の全ての作業を完了させるために必要な期間は最短で何日間か。\n作業 作業の開始条件 所要日数（日） 要件定義 なし 30 設計 要件定義の完了 20 製造 設計の完了 25 テスト 製造の完了 15 利用者マニュアル作成 設計の完了 20 利用者教育 テストの完了及び利用者マニュアル作成の完了 10 ア　80\nイ　95\nウ　100\nエ　120\n題目翻譯：在軟體開發專案中，完成表中所有工作所需的最短時間是多少天？\n工作 前提條件 所需天數 需求定義 無 30 設計 需求定義完成 20 製造 設計完成 25 測試 製造完成 15 使用者手冊編寫 設計完成 20 使用者教育訓練 測試與使用者手冊編寫完成 10 這題畫出那個圖就行了，挺簡單的一個圖。答案為選項 ウ。\n第 20 問 ITIL 2011 edition では、可用性管理における重要業績評価指標（KPI）の例として、”保守性を表す指標値”の短縮を挙げている。保守性を表す指標に該当するものはどれか。\nア　一定時間内での中断の数\nイ　平均故障間隔\nウ　平均サービス・インシデント間隔\nエ　平均サービス回復時間\n題目翻譯：在 ITIL 2011 版中，可用性管理的關鍵績效指標 (KPI) 中包括了「表示可維護性的指標值」的縮寫。下列選項中，屬於表示可維護性的指標是哪一個？\nア：一定時間內的中斷次數\nイ：平均故障間隔 (MTBF)\nウ：平均服務事件間隔 (MTBSI)\nエ：平均服務恢復時間 (MTTR)\n在 ITIL 可用性管理中，可維護性通常表示系統在發生故障後恢復或修復的能力，而非故障的頻率或間隔。而平均服務恢復時間 (MTTR, Mean Time to Restore Service) 用於描述故障後的恢復速度，表示一旦發生故障，系統平均需要花多少時間恢復。所以答案為選項 エ。\n第 21 問 基幹業務システムの構築及び運用において、データ管理者（DA）とデータベース管理者（DBA）を別々に任命した場合のDAの役割として、適切なものはどれか。\nア　業務データ量の増加傾向を把握し、ディスク装置の増設などの計画して実施する。\nイ　システム開発の設計工程では、主に論理データベース設計を行い、データ項目を管理して標準化する。\nウ　システム開発のテスト工程では、主にパフォーマンスチューニングを担当する。\nエ　システム障害が発生した場合には、データの復旧や整合性のチェックなどを行う。\n題目翻譯：在建置與營運核心業務系統時，如果分別指派了資料管理者 (DA) 與資料庫管理員 (DBA)，那麼 DA 的適當職責是什麼？\nア：掌握業務資料量的增長趨勢，計畫並實施增加磁碟設備等措施。\nイ：在系統開發的設計階段，主要進行邏輯資料庫設計，並管理與標準化資料項目。\nウ：在系統開發的測試階段，主要負責效能優化 (Tuning)。\nエ：在系統故障發生時，進行資料恢復與一致性檢查。\n資料管理者 (DA) 主要負責邏輯資料管理，包括制定資料標準、定義資料項目以及邏輯資料庫設計。DA 的職責是確保資料一致性與標準化，而資料庫管理員 (DBA) 則通常負責硬體資源管理、效能優化與資料復原等任務。所以答案為選項 イ。\n第 22 問 監査証拠の入手と評価に関する記述のうち、システム監査基準（平成30年）に照らして、適切でないものはどれか。\nア　アジャイル手法を用いたシステム開発プロジェクトにおいては、管理用ドキュメントとしての体裁が整っているものだけが監査証拠として利用できる。\nイ　外部委託業務実施拠点に対する監査において、システム監査人が委託先から入手した第三者の保証報告書に依拠できると判断すれば、現地調査を省略できる。\nウ　十分かつ適切な監査証拠を入手するための本調査の前に、監査対象の実態を把握するための予備調査を実施する。\nエ　一つの監査目的に対して、通常は、複数の監査手続きを組み合わせ監査を実施する。\n題目翻譯：在獲取與評估稽核證據的描述中，根據《系統稽核標準（平成 30 年）》的標準，以下哪一項是不適當的？\nア：在使用敏捷開發方法進行系統開發專案時，只有格式完善的管理文件才能用作稽核證據。\nイ：在對委外業務執行地點的稽核中，如果系統稽核員判斷可以依賴從受託方獲得的第三方保證報告，則可以省略現場調查。\nウ：為了獲取充分且適當的稽核證據，在正式調查之前，進行預備調查以瞭解稽核對象的實際情況。\nエ：針對一個稽核目的，通常結合多種稽核程序來進行稽核。\n這標準真的不知道了，系統稽核標準中並未規定敏捷專案的稽核證據必須為格式完善的管理文件。實際上，在敏捷專案中，非正式文件（如會議記錄、程式碼庫、看板等）也可以作為有效的稽核證據，以反映專案的實際情況。所以答案為選項 ア。\n第 23 問 BPOの説明はどれか。\nア　災害や事故で被害を受けても、重要事業を中断させない、又は可能な限り中断期間を短くする仕組みを構築すること\nイ　社内業務のうちコアビジネスでない事業に関わる業務の一部又は全部を、外部の専門的な企業に委託すること\nウ　製品の基準生産計画、部品表及び在庫情報を基に、資材の所要量と必要な時期を求め、これを基準に資材の手配、納入の管理を支援する生産管理手法のこと\nエ　プロジェクトを、戦略との適合性や費用対効果、リスクといった観点から評価を行い、情報化投資のバランスを管理し、最適化を図ること\n題目翻譯：以下哪項是對 BPO 的解釋？\nア：即使在災害或事故中受到損害，仍能確保重要業務不中斷，或盡可能縮短中斷時間的機制的建置。\nイ：將公司內部業務中非核心業務的一部分或全部委託給外部專業公司處理。\nウ：基於產品的基準生產計畫、零件表與庫存資訊，確定材料的需求量與所需時間，並以此為基準支援材料的採購與交付管理的生產管理方法。\nエ：從策略適配性、成本效益與風險等角度對專案進行評估，管理資訊化投資的平衡並進行優化。\nBPO (Business Process Outsourcing，業務流程委外) 是指將公司內部的非核心業務委託給外部專業公司處理，以集中資源在核心業務上。所以答案為選項 イ。\nア 選項為業務連續性計畫 (BCP, Business Continuity Plan)；ウ 選項中為物料需求計畫 (MRP, Material Requirements Planning)；エ 選項為專案組合管理 (PPM, Project Portfolio Management)。\n第 24 問 IT投資効果の評価方法において、キャッシュフローベースで初年度の投資によるキャッシュアウトを何年後に回収できるかという指標はどれか。\nア　IRR(Internal Rate of Return)\nイ　NPV(Net Present Value)\nウ　PBP(Pay Back Period)\nエ　ROI(Return On Investment)\n題目翻譯：在 IT 投資效益的評價方法中，基於現金流量來計算初始投資的現金流出在幾年後可以回收的指標是哪一個？\nア 是內部報酬率法，表示專案投資的收益率，使得淨現值為零的折現率，是衡量專案收益水準的常用指標；イ 是淨現值法，透過計算未來現金流的現值總和減去初始投資額，用以評估專案的整體價值；ウ 是回收期間法，題目答案；エ 是投資報酬率，透過投資收益與投資成本的比率，評估專案的獲利能力。所以選 ウ。\n第 25 問 UMLの図のうち、業務要件定義において、業務フローを記述する際に使用する、処理の分岐や並行処理、処理の同期などを表現できる図はどれか。\nア　アクティビティ図\nイ　クラス図\nウ　状態マシン図\nエ　ユースケース図\n題目翻譯：在 UML 的圖表中，用於業務需求定義並描述業務流程，可以表達處理的分支、並行處理以及處理同步的圖是哪一個？\nア：活動圖 (Activity Diagram)\nイ：類別圖 (Class Diagram)\nウ：狀態機圖 (State Machine Diagram)\nエ：使用案例圖 (Use Case Diagram)\n活動圖適用於描述業務流程，能夠表示處理過程中的分支、並行處理和同步處理，因此通常用於業務需求的定義階段；類別圖用於描述系統中的類別及其屬性、方法、類別之間的關係等，它主要用於顯示系統的靜態結構；狀態機圖用於描述物件在生命週期中的狀態變化與狀態間的轉移，它適合表示物件的行為，尤其是在狀態變化和事件響應方面；使用案例圖用於描述系統的功能需求，以及系統如何與外部使用者或其他系統進行互動，使用案例圖透過表示不同的使用案例來定義系統的功能。所以選 ア。\n第 26 問 PPMにおいて、投資用の資金源として位置付けられる事業はどれか。\nア　市場成長率が高く、相対的市場占有率が高い事業\nイ　市場成長率が高く、相対的市場占有率が低い事業\nウ　市場成長率が低く、相対的市場占有率が高い事業\nエ　市場成長率が低く、相対的市場占有率が低い事業\n題目翻譯：在 PPM (產品組合管理) 中，作為投資資金來源的業務是哪一種？\nア 市場成長率高、相對市場佔有率高的業務\nイ 市場成長率高、相對市場佔有率低的業務\nウ 市場成長率低、相對市場佔有率高的業務\nエ 市場成長率低、相對市場佔有率低的業務\nPPM 中，這類業務被稱為「金牛 (Cash Cow)」。由於其市場佔有率高，可以帶來穩定的現金流，同時其市場成長率較低，通常不需要額外投資，因此可以作為其他高成長業務的資金來源。正確答案是 ウ。\n第 27 問 半導体産業において、ファブレス企業と比較したファウンドリ企業のビジネスモデルの特徴として、適切なものはどれか。\nア　工場での生産をアウトソーシングして、生産設備への投資を抑える。\nイ　自社製品の設計、マーケティングに注力し、新市場を開拓する。\nウ　自社製品の販売に注力し、売上げを拡大する。\nエ　複数の企業から生産だけを専門に請け負い、多くの製品を低コストで生産する。\n題目翻譯：在半導體產業中，與無廠半導體 (Fabless) 企業相比，代工 (Foundry) 企業的商業模式特點是什麼？\nア 將工廠的生產委外，以減少在生產設備上的投資。\nイ 專注於自家產品的設計與行銷，開拓新市場。\nウ 專注於自家產品的銷售，擴大銷售額。\nエ 專門承接多家企業的生產業務，以低成本生產大量產品。\n在半導體產業中，代工企業主要負責製造，並不設計自己的產品，而是專門為其他企業提供生產服務。這種模式使其能夠以較低的成本批量生產多種產品。正確答案是 エ。\n第 28 問 XBRLで主要な取扱いの対象とされている情報はどれか。\nア　医療機関のカルテ情報\nイ　企業の顧客情報\nウ　企業の財務情報\nエ　自治体の住民情報\n題目翻譯：在 XBRL (eXtensible Business Reporting Language) 中，主要處理的對象資訊是哪一項？\nア 醫療機構的病歷資訊\nイ 企業的客戶資訊\nウ 企業的財務資訊\nエ 地方政府的住民資訊\nXBRL 是一種用於商業與財務報告的標準化語言，旨在處理與交換公司財務數據。正確答案是 ウ。\n第 29 問 リーダシップ論のうち、PM理論の特徴はどれか。\nア　優れたリーダシップを発揮する、リーダ個人がもつ性格、知性、外観などの個人的資質の分析に焦点を当てている。\nイ　リーダシップのスタイルについて、目標達成能力と集団維持能力の二つの次元に焦点を当てている。\nウ　リーダシップの有効性は、部下の成熟（自律性）の度合いという状況要因に依存するとしている。\nエ　リーダシップの有効性は、リーダがもつバーソナリティと、リーダがどれだけ統制力や影響力を行使できるかという状況要因に依存するとしている。\n題目翻譯：在領導理論中，PM 理論的特點是哪一個？\nア 聚焦於分析展現優秀領導力的領導者個人的特質，例如性格、智力、外表等個人資質。\nイ 關於領導風格，聚焦於目標達成能力 (P) 與團隊維持能力 (M) 兩個維度。\nウ 認為領導的有效性依賴於部下成熟度（自主性）的程度這一情境因素。\nエ 認為領導的有效性取決於領導者的個性，以及其行使控制力與影響力的程度這一情境因素。\nPM 理論 (Performance-Maintenance Theory) 認為，領導風格由「P (目標達成)」與「M (團隊維持)」兩個維度組成。因此，PM 理論的特點是關注領導者在任務達成與團隊維持方面的能力。正確答案是 イ。\n第 30 問 A社は、B社と著作物の権利に関する特段の取決めをせず、A社の要求仕様に基づいて、販売管理システムのプログラム作成をB社に委託した。この場合のプログラム著作権の原始的帰属に関する記述のうち、適切なものはどれか。\nア　A社とB社が話し合って帰属先を決定する。\nイ　A社とB社の共有帰属となる。\nウ　A社に帰属する。\nエ　B社に帰属する。\n題目翻譯：A 公司在沒有與 B 公司就著作權做出特別約定的情況下，基於 A 公司的需求規格將銷售管理系統的程式編寫委託給了 B 公司。在這種情況下，關於程式著作權原始歸屬的描述中，哪一項是正確的？\nア A 公司與 B 公司透過協商決定歸屬\nイ 歸屬於 A 公司與 B 公司共同擁有\nウ 歸屬於 A 公司\nエ 歸屬於 B 公司\n在沒有特別約定的情況下，按照著作權法，委託合約中產生的作品之著作權通常歸屬於實際創作者，即 B 公司。只有在合約中明確規定著作權歸委託方 (A 公司) 時，著作權才會歸屬給 A 公司。因此正確答案是 エ。\n","date":"2024-10-28T19:04:14+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/190/","title":"2022 SA am1 -16-30"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 引言 2022 SA am1\n01-02: https://blog.yexca.net/archives/184 03-05: https://blog.yexca.net/archives/185 06-10: https://blog.yexca.net/archives/186 11-15: https://blog.yexca.net/archives/189 16-30: https://blog.yexca.net/archives/190 碎碎念 最近眼睛越來越疼了，看螢幕可能一小時就開始了，而且看東西很模糊，感覺需要讓眼睛休息了，不然再近視看不見真的會很難受 (要是不疼的話我應該都能更新完這張試卷了)\n第 11 問 OpenFlow を使った SDN(Software-Defined Networking) に関する記述として、適切なものはどれか。\nア　インターネットのドメイン名を管理する世界規模の分散データベースを用いて、IPアドレスの代わりに名前を指定して通信できるようにする仕組む\nイ　携帯電話網において、回線交換方式ではなく、パケット交換方式で音声通話を実現する方式\nウ　ストレージ装置とサーバを接続し、WWN(World Wide Name) によってノードやポートを識別するストレージ用ネットワーク\nエ　データ転送機能とネットワーク制御機能を論理的に分離し、ネットワーク制御を集中的に行う可能にしたアーキテクチャ\n題目翻譯：以下關於使用 OpenFlow 的 SDN (軟體定義網路) 的描述，哪一項是正確的\nア：使用一個全球分散式的資料庫來管理網際網路的網域名稱，以便可以使用名稱而非 IP 位址進行通訊。\nイ：在行動通訊網路中，不透過電路交換方式，而是透過封包交換方式實現語音通話的方式。\nウ：連接儲存裝置和伺服器，並使用 WWN（全球唯一名稱）識別節點和埠號的儲存網路。\nエ：將資料轉發功能和網路控制功能在邏輯上分離，使集中化網路控制成為可能的架構。\n選項 ア 是 DNS 的描述；イ 是行動通訊中 VoIP (基於封包交換的語音傳輸方式) 的描述；ウ 是對 SAN (儲存區域網路) 的描述。所以答案為選項 エ\n第 12 問 メッセージの送受信における署名鍵の使用に関する記述のうち、適切なものはどれか。\nア　送信者が送信者の署名鍵を使ってメッセージに対する署名を作成し、メッセージに付加することによって、受信者が送信者による署名であることを確認できようになる。\nイ　送信者が送信者の署名鍵を使ってメッセージを暗号化することによって、受信者が受信者の署名鍵を使って、暗号文を元のメッセージに戻すことができるようになる。\nウ　送信者が送信者の署名鍵を使ってメッセージを暗号化することによって、メッセージの内容が関係者以外に分からないようになる。\nエ　送信者がメッセージに固定文字列を付加し、更に送信者の署名鍵を使って暗号化することによって、受信者がメッセージの改ざん部位を特定できるようになる。\n題目翻譯：關於訊息收發中的簽章金鑰使用，以下哪項描述是正確的\nア：傳送者使用傳送者的簽章金鑰對訊息進行簽章並附加到訊息上，這樣接收者可以確認該簽章是傳送者產生的。\nイ：傳送者使用傳送者的簽章金鑰加密訊息，這樣接收者可以使用接收者的簽章金鑰將密文還原為原始訊息。\nウ：傳送者使用傳送者的簽章金鑰加密訊息，使訊息內容對非相關方不可見。\nエ：傳送者在訊息上附加固定字串，再使用傳送者的簽章金鑰加密，這樣接收者可以確定訊息被竄改的部分。\n這裡討論簽章一般是 RSA 演算法。一般用其公鑰解密，私鑰是不會洩漏的，所以選項 イ 錯誤；簽章金鑰不用作加密訊息，因為公鑰公開，任何人都是可以看到的，只用於驗證屬於傳送者，所以選項 ウ 錯誤；金鑰無法確定被竄改的部分，所以選項 エ 錯誤。答案為選項 ア\n第 13 問 クライアント証明書で利用者を確認するリバースプロキシサーバを用いて、複数のWebサーバにシングルサインオンを行うシステムがある。このシステムに関する記述のうち、適切なものはどれか。\nア　クライアント証明書を利用者のPCに送信するのは、Webサーバではなく、リバースプロキシサーバである。\nイ　クライアント証明書を利用者のPCに送信するのは、リバースプロキシサーバではなく、Webサーバである。\nウ　利用者IDなどの情報をWebサーバに送信するのは、リバースプロキシサーバではなく、利用者のPCである。\nエ　利用者IDなどの情報をWebサーバに送信するのは、利用者のPCではなく、リバースプロキシサーバである。\n題目翻譯：使用反向代理伺服器，透過用戶端憑證驗證使用者並實現對多個 Web 伺服器的單一登入系統。關於該系統的描述，以下哪項是正確的\nア：將用戶端憑證傳送到使用者的 PC 的是反向代理伺服器，而不是 Web 伺服器。\nイ：將用戶端憑證傳送到使用者的 PC 的是 Web 伺服器，而不是反向代理伺服器。\nウ：將使用者 ID 等資訊傳送到 Web 伺服器的是使用者的 PC，而不是反向代理伺服器。\nエ：將使用者 ID 等資訊傳送到 Web 伺服器的是反向代理伺服器，而不是使用者的 PC。\n這題倒是挺貼近現實的，挺多大公司都會使用吧，就像微軟的那個每次登入會單獨到一個登入的請求。用戶端的憑證儲存在用戶端，反向代理伺服器負責處理用戶端憑證的驗證，前兩個選項錯誤；在反向代理伺服器驗證完成後，向伺服器傳送使用者資訊，所以答案為選項 エ\n第 14 問 内部ネットワークのPCからインターネット上のWebサイトを参照するときに、DMZに設置したVDI (Virtual Desktop Infrastructure) サーバ上のWebブラウザを利用すると、未知のマルウェアがPCにダウンロードされるのを防ぐというセキュリティ上の効果が期待できる。この効果を生み出すVDIサーバの動作の特徴はどれか。\nア　Webサイトからの受信データを受信処理した後、IPsecでカプセル化し、PCに送信する。\nイ　Webサイトからの受信データを受信処理した後、実行ファイルを削除し、その他のデータをPCに送信する。\nウ　Webサイトからの受信データを受信処理した後、生成したデスクトップ画面の画像データだけをPCに送信する。\nエ　Webサイトからの受信データを受信処理した後、不正なコード列が検知されない場合だけPCに送信する。\n題目翻譯：當內部網路的 PC 存取網際網路上的網站時，透過使用位於 DMZ（隔離區）中的 VDI（虛擬桌面基礎架構）伺服器上的瀏覽器，可以有效防止未知惡意軟體下載到 PC 上。這種安全效果是由 VDI 伺服器的哪個操作特性產生的？\nア：從網站接收資料後，將其用 IPsec 封裝，然後傳送到 PC。\nイ：從網站接收資料後，刪除執行檔，然後將其他資料傳送到 PC。\nウ：從網站接收資料後，僅將產生的桌面螢幕影像資料傳送到 PC。\nエ：從網站接收資料後，只有在未偵測到惡意程式碼時才傳送到 PC。\n答案為選項 ウ，看名字就知道虛擬桌面只傳輸畫面。\n第 15 問 ファジングに該当するものはどれか。\nア　サーバにFINバケットを送信し、サーバからの応答を観測して、稼働しているサービスを見つけ出す。\nイ　サーバのOSやアプリケーションソフトウェアが生成したログやコマンド履歴などの解析して、ファイルサーバに保存されているファイルの改ざんを検知する。\nウ　ソフトウェアに、問題を引き起こしそうな多様なデータを入力し、挙動を監視して、脆弱性を見つけ出す。\nエ　ネットワーク上を流れるバケットを収集し、そのプロトコルヘッダやペイロードを解析して、あらかじめ登録された攻撃パターンと一致するものを検出する。\n題目翻譯：以下哪個選項符合模糊測試（Fuzzing）的描述\nア：向伺服器傳送 FIN 封包，並觀察伺服器的回應，以發現正在運行的服務。\nイ：分析伺服器的作業系統或應用軟體產生的紀錄 (Log) 和指令歷史紀錄，以偵測儲存在檔案伺服器上的檔案是否被竄改。\nウ：向軟體輸入可能引發問題的多種資料，監視其行為，並查找漏洞。\nエ：收集網路中傳輸的封包，解析其協定標頭和負載 (Payload)，偵測與預先註冊的攻擊模式相匹配的內容。\n模糊測試是一種自動化的軟體測試技術，透過向程式輸入隨機或異常資料來觸發潛在漏洞，從而偵測軟體中的錯誤和安全漏洞。Fuzzing 特別適用於發現系統中可能被忽視或未考慮到的邊界條件和異常情況。它的目標在於測試軟體在意外輸入條件下的行為，並判斷程式是否具備足夠的強健性 (Robustness) 和安全性。所以答案為選項 ウ\n選項 ア 描述的是 FIN 掃描，用於偵測目標伺服器上有哪些服務在運行，有點像 nmap 指令。選項 イ 是入侵偵測系統 (IDS) 工作的一部分。選項 エ 屬於網路入侵偵測系統 (NIDS)，常用該技術來即時監控網路流量，發現並防禦已知攻擊，但封包擷取與偵測雖能識別常見攻擊模式，但難以偵測到未知或變種攻擊。\n","date":"2024-10-26T21:41:16+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/189/","title":"2022 SA am1 -11-15"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 引言 2022 SA am1\n01-02: https://blog.yexca.net/archives/184 03-05: https://blog.yexca.net/archives/185 06-10: https://blog.yexca.net/archives/186 11-15: https://blog.yexca.net/archives/189 16-30: https://blog.yexca.net/archives/190 可能因為是多場考試共用的試卷吧，問題還是挺基礎的，感覺像軟考中級軟體設計師的程度。不過一共有四場考試呢，也不知道什麼時候能把這第一個寫完呢\n第六問 一つの $I^2C$ バスに接続された二つのセンサがある。それぞれのセンサ値を読み込む二つのタスで排他的に制御したい。利用するリアルタイムOSの機能として、適切なものはどれか。\nア　キュー\nイ　セマフォ\nウ　マルチスレッド\nエ　ラウンドロビン\n題目翻譯：有兩個連接到同一個 I²C 匯流排的感測器。為了互斥地控制兩個任務讀取各自的感測器值，應使用哪種即時作業系統（RTOS）的功能？\nア：佇列 (queue)\nイ：信號量 (semaphore)\nウ：多執行緒 (Multithreading)\nエ：輪轉排程 (Round Robin)\n佇列是一種資料結構，遵循 FIFO 即先進先出原則，適用於多個任務之間的通訊或資料傳遞。\n信號量是一種同步機制，主要用於控制對共享資源的存取，確保多個任務在並行環境下不會同時存取同一個資源。信號量分為兩類：二元信號量 (用於互斥存取) 和計數信號量 (用於管理資源池)。\n多執行緒指在一個行程內同時執行多個執行緒的機制。其本身不用於互斥控制，但往往需要配合信號量、互斥鎖等機制來確保對共享資源的安全存取。\n輪轉排程是一種簡單的任務排程演算法，例如時間片輪轉。\n選項本身倒是還好，只是都是片假名，無疑增加了難度。綜上所述，本題選擇 イ。\n第七問 アクチュエータの説明として、適切なものはどれか。\nア　与えられた目標量と、センサから得られた制御量に比較し、制御量を目標量に一致させるように操作量を出力する。\nイ　位置、角度、速度、加速度、力、温度などを検出し、電気的な情報に変換する。\nウ　エネルギー源からのパワーを、回転、直進などの働きに変換する。\nエ　マイクロフォン、センサなどが出力する微小な電気信号を増幅する。\n題目翻譯：關於致動器（Actuator）的描述，哪項是正確的？\nア：將給定的目標值與從感測器獲得的控制值進行比較，並輸出一個操作量以使控制值與目標值一致。\nイ：偵測位置、角度、速度、加速度、力、溫度等，並將其轉換為電訊號。\nウ：將來自能源的動力轉換為旋轉、直線運動等工作形式。\nエ：放大由麥克風、感測器等設備輸出的微量電訊號。\nア 是控制器的功能，通常用於閉迴路控制系統中；イ 是感測器的功能，將物理量轉換為電訊號；ウ 是致動器的功能；エ 是放大器的功能。本題選 ウ。\n第八問 第1、第2、第3正規形とリレーションの特徴 a, b, c の組合のうち、適切なものはどれか。\na：どの非キー属性も、主キーの真部分集合に対して関数従属しない。\nb：どの非キー属性も、主キーに推移的に関数従属しない。\nc：繰り返し属性が存在しない。\n第1正規形 第2正規形 第3正規形 ア a b c イ a c b ウ c a b エ c b a 題目翻譯：以下關於 1NF、2NF 和 3NF 的定義，與特徵 a, b, c 的組合，哪一項是正確的？\na：任何非主鍵屬性不相依於主鍵的真子集（部分相依）。\nb：任何非主鍵屬性不透過其他非主鍵屬性相依於主鍵（遞移相依）。\nc：不存在重複的屬性。\n這個其實就是正規化啦，還 特意寫了一篇文章 （翻譯成正規形有點奇怪欸）。參考 總結部分 可以知道 1NF 對應 c；2NF 對應 a；3NF 對應 b。答案為選項 ウ。\n第九問 ビッグデータの利用におけるデータマイニングを説明したものはどれか。\nア　蓄積されたデータを分析し、単なる検索だけではわからない隠れた規則や相関関係を見つけ出すこと\nイ　データウェアハウスに格納されたデータの一部を、特定の用途や部門用に切り出して、データベースに格納すること\nウ　データ処理の対象となる情報を基に規定した、データの構造、意味及び操作の枠組みのこと\nエ　データを複数のサーバに複製し、性能と可用性を向上させること\n題目翻譯：以下哪項描述了大數據利用中的資料探勘（Data Mining）？\nア：分析累積的資料，發現透過簡單搜尋無法找到的隱藏規律和關聯。\nイ：從資料倉儲（Data Warehouse）中提取一部分資料，按特定用途或部門需求儲存到資料庫中。\nウ：根據要處理的資訊，定義資料的結構、意義和操作框架。\nエ：將資料複製到多台伺服器上，以提高效能和可用性。\nア 是資料探勘的正確描述；イ 是描述資料超市（Data Mart）的過程，即從資料倉儲中選取部分資料用於特定用途；ウ 是資料模型的定義；エ 則是資料備份。答案為選項 ア。\n第十問 UDPを使用しているものはどれか。\nア　FTP\nイ　NTP\nウ　POP３\nエ　TELNET\n題目翻譯：以下哪項使用了 UDP 協定？\nFTP 是檔案傳輸協定，使用 TCP 確保資料安全；NTP 是網路時間協定，使用 UDP 確保速度；POP3 是郵局協定第三版，使用 TCP 確保郵件傳輸可靠性；TELNET 是遠端終端協定，使用 TCP 建立可靠的遠端終端工作階段。所以答案為選項 イ。\n","date":"2024-10-22T15:37:34+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/186/","title":"2022 SA am1 -06-10"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 引言 2022 SA am1\n01-02: https://blog.yexca.net/archives/184 03-05: https://blog.yexca.net/archives/185 06-10: https://blog.yexca.net/archives/186 11-15: https://blog.yexca.net/archives/189 16-30: https://blog.yexca.net/archives/190 碎碎念 星期一總是很累，在經歷了週末的休息後總會在今天提不起精神。不過今天也不知道怎麼回事，我突然一改之前快要憂鬱的感覺，儘管什麼也沒有做，突然就變得極其樂觀。情感或者狀態確實很奇妙。\n所以呢，今天也摸了不少魚呢，差點就不寫了。不過這張試卷有 30 個試題，照目前的速度恐怕至少要半個月才能看完 :cry:\n第三題 プログラム言語のうち、ブロックの範囲を指定する方法として特定の記号や予約語を用いず、等しい文字数の字下げを用いるという特徴をもつものはどれか。\nア　C\nイ　Java\nウ　PHP\nエ　Python\n題目翻譯：在程式語言中，哪種語言的特點是不使用特定的符號或保留字來指定程式碼區塊的範圍，而是透過相同字元數的縮排來指定範圍？\n顯然是 Python，即選項 エ。\n第四題 キャッシュメモリのアクセス時間が主記憶のアクセス時間の1/30で、ヒット率が95％のとき、実効メモリアクセス時間は、主記憶のアクセス時間の約何倍になるか。\nア　0.03\nイ　0.08\nウ　0.37\nエ　0.95\n這題考的是有效記憶體存取時間 (EMAT)，可以透過以下公式計算：\n$$ EMAT = Cache Access Time \\times Hit Rate + Main Memory Access Time \\times Miss Rate $$設 Main Memory Access Time = T，則 Cache Access Time = $\\frac{T}{30}$。由題目知 Hit Rate = 95%，則 Miss Rate = 5%。\n所以 EMAT = $\\frac{T}{30} \\times 95\\% + T \\times 5\\% \\approx 0.08T$，因此答案為選項 イ。\n這題以前不太會做，計算機組織的話我也只聽了一半，說實話應該也算忘得差不多了。\n第五題 プロセッサ数と、計算処理におけるプロセスの並列化が可能な部分の割合とが、性能上へ及ぼす影響に関する記述のうち、アムダールの法則に基づいたものはどれか。\nア　全ての計算処理が並列化できる場合、速度向上比は、プロセッサ数を増やしてもある水準に漸近的に近づく。\nイ　並列化できない計算処理がある場合、速度向上比は、プロセッサ数に比例して増加する。\nウ　並列化できない計算処理がある場合、速度向上比は、プロセッサ数を増やしてもある水準に漸近的に近づく。\nエ　並列化できる計算処理の割合が増えると、速度向上比は、プロセッサ数に反比例して減少する。\n題目翻譯：關於處理器數量與計算處理過程中可平行化部分佔比對效能的影響，下列哪一項是基於阿姆達爾定律 (Amdahl\u0026rsquo;s Law) 的描述？\nア：如果所有的計算處理都可以平行化，則速度提升比即使增加處理器數量，也會逐漸趨近於某個水平。\nイ：如果存在無法平行化的計算處理，速度提升比會隨著處理器數量的增加而按比例增長。\nウ：如果存在無法平行化的計算處理，則速度提升比即使增加處理器數量，也會逐漸趨近於某個水平。\nエ：隨著可平行化的計算處理比例增加，速度提升比會隨著處理器數量的增加而呈反比減少。\n要解出這題需要先知道什麼是「アムダールの法則」。Amdahl\u0026rsquo;s Law 描述了計算處理過程中，程式的平行化程度對效能提升的影響。它指出即使增加處理器的數量，程式中不能平行化的部分仍然會限制效能的提升。其公式如下：\n$$ S(N)=\\frac{1}{(1-P)+\\frac{P}{N}} $$其中 S(N) 表示使用 N 個處理器時的速度提升比、P 是程式中能夠進行平行化的部分比例、N 是處理器的數量。\n綜上所述，本題選 ウ。\n","date":"2024-10-21T20:35:34+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/185/","title":"2022 SA am1 -03-05"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 引言 2022 SA am1\n01-02: https://blog.yexca.net/archives/184 03-05: https://blog.yexca.net/archives/185 06-10: https://blog.yexca.net/archives/186 11-15: https://blog.yexca.net/archives/189 16-30: https://blog.yexca.net/archives/190 這篇文章是我想要挑戰一下，也沒想過會成功，去參加系統架構師考試，也就是電腦專業技術與軟體專業技術資格的高級考試。這項考試取得的證照和學習到的知識，可能大多數在編寫程式時用不上（其實用得上只是想不到），但有總比沒有好。我會盡量把這張試卷做完，這應該也能慢慢將我從夢中拉回吧。\n碎碎念 自己最近兩年確實很渾渾噩噩了，以至於現在處理事情的方法也深受該狀態影響。一直這樣下去終究不是辦法，既然無法選擇，那就盡力做好吧。我想要至少嘗試一下，沒有嘗試的勇氣才是最可怕的，這已經讓我最近失去了一個機會。還是應該有些改變或變化，生活才能過得比較真實一點。我也確實有時候覺得我活在夢裡，倒不是活得好，而是不真實。文字的力量是有限的，實際的經歷更具有說服力，儘管可能是虛假被創造出的事實，我開始去相信一些看似很離譜的事情。\n嗯，感覺在寫日記似的，算了吧，就這樣吧。\n引言提到感覺在做夢，其實讓我想到一部有趣的修仙小說，那個魔宗的人覺得自己是仙人，所在的世界只是一個幻境，自己是過來歷練的。我有時候都覺得被這個設定影響了。所以不要再廢話了嘛\n第一問 ハミング符号とは、データに冗長ビットを付加して、1ビットの誤りを訂正できるようにしたものである。ここでは。$X_1, X_2, X_3, X_4$ の4ビットから成るデータに3ビットの冗長ビット $P_3, P_2, P_1$ を付加したハミング符号 $X_1X_2X_3P_3X_4P_2P_1$ を考える。付加したビット $P_1, P_2, P_3$ は、それぞれ\n$$ X_1 \\oplus X_3 \\oplus X_4 \\oplus P_1 = 0 \\\\ X_1 \\oplus X_2 \\oplus X_4 \\oplus P_2 = 0 \\\\ X_1 \\oplus X_2 \\oplus X_3 \\oplus P_3 = 0 $$となるように決める。ここで、$\\oplus$ は排他的論理和を表す。\nハミング符号1110011には1ビットの誤りが存在する。誤りビットを訂正したハミング符号はどれか。\nア　0110011\nイ　1010011\nウ　1100011\nエ　1110111\n海明碼（Hamming Code）題目，題目給出了公式，每個位置代入計算互斥或（XOR）得：\n$$ X_1 \\oplus X_3 \\oplus X_4 \\oplus P_1 = 1 \\\\ X_1 \\oplus X_2 \\oplus X_4 \\oplus P_2 = 1 \\\\ X_1 \\oplus X_2 \\oplus X_3 \\oplus P_3 = 1 $$可以得到出錯的位置為 $(111)_2$ 即第 7 位，所以正確的數據為 0110011，即選項 ア。\n看到海明碼時，我只覺得很熟悉，但具體是什麼我已經完全不記得了，唉，之前到底學了什麼呢。\n海明碼可用於校驗資料是否出錯，並且進行一位元的糾錯。以原始資料 1100 為例，轉換為海明碼的過程如下：\n首先計算校驗位（Parity bits）的個數，$2^k \\ge k + m + 1$，其中 m 為原始資料的個數，k 為校驗位的個數。本例的 k 應為 3，共有三個校驗位。校驗位只會出現在 $2^n$ 即 1、2、4、8 ···。所以本例校驗位在第 1、2、4 位。此處以及以後提到的位置一般為從右往左。\n因為有三位校驗位加上四位資料，共有七個數，列出其二進位（校驗位 3 位，列出二進位為 3 位）：\n7 6 5 4 3 2 1 111 110 101 100 011 010 001 校驗位的位置，即 1、2、4 的數字分別對應 001、010、100，即 1 的位置在第一位、第二位、第三位，接下來找出所有位置相同的：\n校驗碼位置 數字 1 位置 碼 1 第一位，**1 1、3、5、7 2 第二位，*1* 2、3、6、7 4 第三位，1** 4、5、6、7 然後根據每一組（上表一行同一個位置的碼為一組）計算確定校驗位的碼，需要藉助原資料，如下表：\n位置 7 6 5 4 3 2 1 數值 1 1 0 0 因為校驗位數值不確定，先空著。\n第一組資料，根據第 1、3、5、7 位的數字確定，共有 1 個 1，所以補 1 使 1 的個數為偶數。\n第二組資料，根據第 2、3、6、7 位的數字確定，共有 2 個 1，所以補 0。\n第三組資料，根據第 4、5、6、7 位的數字確定，共有 2 個 1，所以補 0。\n所以海明碼對應位置如下：\n位置 7 6 5 4 3 2 1 數值 1 1 0 0 0 0 1 即資料 1100 的海明碼為 1100001，校驗方式其實和題目一樣，畢竟題目範例也是七位數。\n校驗是怎麼確定的呢？把題目中三行公式對應的位置換成從右往左數，可以看到其實就是上面確定校驗碼時劃分的三個組。所以校驗方式也就是確定校驗碼個數後，再確定各組位置，然後進行互斥或操作。根據得到的結果（全是 0 說明資料未改變），從右往左排列，即：\n···第三組、第二組、第一組\n得到的二進位數即資料發生改變的位置，改變數值則得到原來的海明碼。\n參考文章\n海明码一篇文章彻底搞懂 海明码的编码和校验方法 排他的論理和（XOR） 第二問 リストには、配列で実現する場合とポインタで実現する場合とがある。リストを配列で実現した場合の特徴として、適切なものはどれか。ここで、配列を用いたリストは配列に要素を連続して格納することによってリストを構成し、ポインタを用いたリストは要素と次の要素へのポインタを用いることによってリストを構成するものとする。\nア　リストにある実際の要素数にかかわらず、リストに入れられる要素の最大個数に対応した領域を確保し、実際には使用されない領域が発生する可能性がある。\nイ　リストの中間要素を参照するには、リストの先頭から順番に要素をたどっていくことから、要素数に比例した時間が必要となる。\nウ　リストの要素を格納する領域の他に、次の要素を指し示すための領域が別途必要となる。\nエ　リストへの挿入位置が分かる場合には、リストにある実際の要素数にかかわらず、要素の挿入を一定時間で行うことができる。\n這道題目問陣列實現的串列（List）有什麼特徵，除了 ア 以外都是指標構成串列的特徵，答案為選項 ア。\n問題還是很明顯的，選錯了就是我看不懂 :cry:，題目翻譯如下（ChatGPT）：\n串列可以使用陣列或指標來實現。使用陣列實現串列的特點是什麼？在這裡，陣列實現的串列是透過將元素連續地儲存在陣列中來構成的，而使用指標的串列則是透過使用元素和指向下一個元素的指標來構成的。\nア：無論串列中實際的元素數是多少，都要為串列中可容納的最大元素個數分配記憶體空間，可能會出現未使用的空間。\nイ：要存取串列中的中間元素，需要從串列的開頭開始逐個元素進行走訪，因此需要的時間與元素數量成正比。\nウ：除了儲存串列元素的空間外，還需要單獨的空間來指向下一個元素。\nエ：如果知道插入位置，那麼無論串列中實際有多少元素，都可以在固定時間內插入元素。\n","date":"2024-10-20T20:19:11+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/184/","title":"2022 SA am1 -01-02"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 引言 最近因為更換硬碟而重新安裝了電腦系統，當我拿出那多年未動的隨身碟時，裡面的軟體多少有點過時，有些已經無法在新系統上執行，還有好多我已經使用了相同功能的替代品，以及使用了一些新的軟體，遂寫下此文章記錄裝機用到的軟體。\n回頭發現這是 24.09.16 的文章，中間因為有事耽擱，加上狀態不是特別好，直到 24.10.02 才把文章寫完。\n系統 因為用了較長時間的 Win11，所以還是打算繼續使用 Win11。隨身碟裡的系統太舊了，於是去 MSDN itellyou 下載了新版映像檔。\n但是在安裝的時候卻發現這玩意居然必須要連網才能安裝了，就是在設定新系統的時候必須連網登入微軟帳戶，要是沒有網路的話最好使用舊版本 (記得應該是可以跳過的) 或者裝 Win10 (然後再升級 Win11 (doge))。\n2024.10.03\n今天刷到了 兩個跳過網路驗證的方法 ，沒嘗試過，先記錄下來\n第一個是按 Ctrl+Shift+F3 可以直接跳過，同時避免建立在地使用者 (下次重新啟動將重新進行設定)\n第二個是在連網介面按 Shift+F10 然後輸入 oobe\\bypassnro.cmd 之後系統會重新啟動，重啟後在網路頁面會出現沒有網路連接的選項\n軟體相關 我的安裝隨身碟已經好久沒有使用了，裡面的軟體有些我已經不再使用，並且也開始使用一些新的軟體，部分替代了原本的功能，所以還是有必要寫一下的。說不定下次裝機看這篇文章的時候我又會換一批軟體了 (雖然現在我不是很喜歡麻煩的事情)。\n辦公軟體 基礎的 Office 必不可少，採用 Office Tool 進行安裝方便快速。\n以下內容僅安裝 Word、Excel 和 PowerPoint。\n下載 Office Tool: https://otp.landian.vip/zh-cn/download.html 啟動 Office Tool，執行程式碼安裝：\n1 deploy /add O365ProPlusRetail_zh-cn /O365ProPlusRetail.exclapps Access,Bing,Groove,Lync,OneDrive,OneNote,Outlook,Publisher,Teams /channel Current /dlfirst 利用 kms 啟動 Office，執行程式碼啟動：\n1 2 3 ospp /inslicid MondoVolume /sethst:kms.loli.beer /setprt:1688 /act # or use kms.03k.org ospp /inslicid MondoVolume /sethst:kms.03k.org /setprt:1688 /act 參考文章\nhttps://www.coolhub.top/archives/11 https://www.coolhub.top/archives/14 下載工具與雲端硬碟 迅雷: 使用的是忘了從哪找的精簡版。雖然會吸血，但有些東西確實還是得用迅雷下載。\nBitComet: BT 下載工具，同樣使用了精簡版。類似的工具有 qBittorrent, µTorrent 等。\nResilio Sync : 基於 BT 技術的同步軟體，方便各端檔案同步。\nInternet Download Manager: 即 IDM，比較好用的多執行緒下載工具。\n115 : 用於下載一些下不動的 BT。類似的工具有 pikpak。\n百度網盤 : 開了會員很好用，但沒會員就是折磨。時間，加錢可得。與之類似的如阿里網盤、夸克網盤可以在需要時再下載。\n社群軟體 暫時使用的社群軟體也就那樣吧。\nTencent\nQQ : 最近出的 NT 版本確實還行吧。 WeChat: https://www.wechat.com/ Telegram: https://desktop.telegram.org/ 解壓縮工具 之前的電腦上倒是裝了不少的解壓縮工具，但實際上使用的也就兩個，於是這次就只裝兩個了。\nBandizip : 應該是較為流行的吧，之前當我剛聽說時學校電腦教室都用上了。\nWinRAR: 比較古老的軟體，但有些 rar 只有使用此軟體才能解壓縮。\n其他的:\n7-zip : 最為流行的解壓縮軟體。 NanaZip : 7z 的美化版，並且可以在 Win11 第一層右鍵選單顯示。 其他工具 Utools : 非常便捷的工具，官網有動畫介紹，透過外掛擴充使其非常方便，比如本文就是使用其 MarkDown 擴充寫的，雖然有些地方不如 Typora 但勝在方便。\nQuickLook : 快速預覽檔案的工具，用起來不是太理想，希望未來可以找到替代品。非安裝版需要解鎖後使用: https://github.com/QL-Win/QuickLook/issues/1 1Password : 密碼管理工具，可以使用開源替代品 bitwarden 。我已經徹底離不開密碼管理器啦。\nPDF 閱讀器: 感覺大部分都差不多，隨緣用用。\nFoxit PDF Wondershare PDFelement PDF XChange sandboxie : 沙盒工具，對於不想直接在電腦上執行而污染環境的程式很好用，非安裝版每次執行需要管理員權限。\nTickTick : To Do List 軟體，全平台同步，不過最近感覺同步不是太順暢。\nQuiteRSS : RSS 訂閱管理工具，但介面較為古老，不過由於我使用習慣了也無所謂。畢竟轉移只需壓縮解壓縮，RSS 訂閱也不會遺失。\nDuplicate Cleaner Pro: 之前用的清理軟體找不到了，就用八醬的這個啦。雖然有些時候不是太好用，但使用久了後還行吧。\nPixPin : 螢幕截圖工具。\nCode Tools VS Code : 只能說裝機必備了。\nTypora : Markdown 視覺化書寫工具。\nGit: https://git-scm.com/downloads/win Git 安裝後需要設定名稱和電子郵件。同時可以更新一下 Github 的 SSH 公鑰了。\n1 2 git config --global user.name \u0026#34;Your Name\u0026#34; git config --global user.email \u0026#34;email@example.com\u0026#34; 參考文章: https://blog.yexca.net/archives/95 JetBrains\nIntelliJ IDEA : Java 程式設計。 GoLand : Go 程式設計。 Dataflare : 連接資料庫的工具。\nDocker 我已經完全離不開 Docker 了。\n下載地址: https://docs.docker.com/desktop/install/windows-install/ 單獨分一個章節是因為安裝時出錯 WSL Update Failed。\n其實就是需要去 下載最新版本的 WSL ，然後重啟電腦就好了。\n參考文章\nhttps://forums.docker.com/t/wsl-update-failed/140473/3 https://github.com/docker/for-win/issues/13845 https://github.com/docker/for-win/issues/13580#issuecomment-1619667316 MySQL Docker : 因為使用其儲存一些資料，所以還是挺有必要使用的，但使用頻率不是太高，我覺得可以直接裝在 Docker 裡，這樣換系統之類的也方便 (也想過裝在伺服器上，但覺得有時候可能會沒有網路連線)。\n安裝\n1 docker pull mysql:5.7 執行時需要設定連接埠和 ROOT 密碼的環境變數 MYSQL_ROOT_PASSWORD。\n部落格 因為我部落格使用 Jekyll 框架，還需要重新安裝一下，希望不要出問題。\n執行環境\nRuby: https://www.ruby-lang.org/en/downloads/ RubyGems: https://rubygems.org/pages/download Node.js: https://nodejs.org/zh-tw 安裝 Jekyll\n1 gem install jekyll 初始化部落格\n1 bundle 好吧，有幾個外掛我重啟也裝不上，同時參考了 Installation Issues on MacOSX - Gem::Ext::BuildError: ERROR: Failed to build gem native extension 等文章也無法安裝。\n經朋友的提醒，確實還是得用 Docker 比較好，天天搞環境會煩死，明明專案都用 Docker 我部落格居然還在用在地安裝。\n參考我 主題安裝文章 安裝 VS Code 外掛 Dev Containers extension 用於查看容器內部檔案。\n打開 VS Code 按下 F1 輸入 Dev Containers: Clone Repository in Container Volume... 選擇後輸入一個 Git 連結 (即我的 blog 的原始碼)。\n等待一會後 (右下角可以看日誌) 選擇要使用的系統、軟體等配置，我選擇 Debian 系統，軟體我沒選。\n首先更新軟體：\n1 sudo apt-get update 參考 官方教學 安裝 Jekyll：\n1 2 3 sudo apt-get install ruby-full build-essential # 上方是依賴項目 sudo gem install jekyll bundler 安裝 NodeJS：\n1 sudo apt install nodejs 安裝依賴項目：\n1 sudo bundle 會提示不要用 root 權限執行，但這只是容器，隨便弄，無視。\n嘗試部署專案：\n1 bundle exec jekyll s 專案成功執行，但因為是容器的連接埠，需要映射到本機才能看，打開直接能看，VS Code nb (doge)。\n感覺比 Win 編譯的要快，非常 Nice。\n參考文章:\nhttps://jekyllcn.com/docs/installation/ https://jekyllrb.com/docs/installation/windows/#installation-via-bash-on-windows-10 https://code.visualstudio.com/docs/devcontainers/containers#_quick-start-open-a-git-repository-or-github-pr-in-an-isolated-container-volume 結尾 暫時需要用的就這些吧，有一些貌似自己用不到了或者使用頻率低就想不起來了，就這樣，掰掰。\n","date":"2024-10-02T21:35:24+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/182/","title":"2024 裝機紀錄"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 文章撰寫於 2022.11.30，因為早已不再使用此面板與 CuteOne，文章並未有最新適配，可能無法重現。\n同時，當時文章並未完成，我並無相關需求，僅作記錄。\n建置過程 兩篇文章\n寶塔面板 Python 專案管理器安裝 CuteOne – OneDrive 多網路硬碟掛載程式 - 大鳥博客 (daniao.org) CuteOne 建置個人雲端硬碟最完整教學！_將暮的博客-CSDN博客 第一篇文章我在 Python 專案管理器部署後一直無法成功執行，於是找到第二篇文章，內容非常詳細。\n影片持續轉圈無法播放、圖片無法顯示 您可能遇到安裝之後，圖片無法顯示，播放影片也持續在轉圈圈；\n這個問題是因為 SSL 憑證所導致的，假設您沒有使用 SSL，那麼您應該不會有這個問題；\n如果您是使用 SSL 的話，那麼您需要修改：\napp\\templates\\themes\\default\\public\\layout.html\n\u0026lt;!-- \u0026lt;meta http-equiv=\u0026quot;Content-Security-Policy\u0026quot; content=\u0026quot;upgrade-insecure-requests\u0026quot; /\u0026gt;--\u0026gt;\n修改為\n\u0026lt;meta http-equiv=\u0026quot;Content-Security-Policy\u0026quot; content=\u0026quot;upgrade-insecure-requests\u0026quot; /\u0026gt;\n請記得修改之後，在後台的上方會有一個重新啟動按鈕，您需要重新啟動才會生效；\n如果已經生效，您就不需要重新啟動了；\n或者您手動重新啟動也可以；\n所有 SSL 相關的問題都可以依照此方案解決；\n如果後台也遇到同樣狀況。\n後台的檔案路徑是：\napp\\templates\\admin\\public\\layout.html\n也是相同的程式碼。\n","date":"2024-09-10T23:06:59+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/181/","title":"寶塔面板建置 CuteOne"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 文章寫於 2022.05.09，文章並無最新適配，可能無法復現。另推薦使用較新的專案\n透過 OneDrive 可以建立網路硬碟網站，例如我的 VRChat 網路硬碟已經沒了，還可以直接建立網頁，或者圖床\noneindex 簡介 GitHub: https://github.com/avedu/oneindex OneDrive Directory Index，不佔用伺服器空間，不走伺服器流量，直接列出 OneDrive 目錄，檔案直鏈下載。\n環境 需要 PHP5.6+，需啟用 curl 支援，新手（比如我）建議直接使用 寶塔 直接部署，方便快捷\n另因寶塔隱私洩漏風波，有一些其他版本如 寶塔純淨版 ，請自行識別安裝\n安裝 從 GitHub 將儲存庫下載並上傳至網站根目錄並解壓縮\n然後訪問網站，進入安裝程式\n檢測 首先是同意條款，如果點擊同意會返回，請將網址列中最後的 \u0026amp;mdui-dialog 刪除後按回車\n如果環境正常點擊下一步\n程式安裝 點擊獲取應用ID和機密(分兩個頁面顯示，請注意保存)，然後登入微軟帳號\n保留出現的應用機密，然後點擊知道了，返回快速啟動\n注意：此機密僅會顯示一次，請妥善保存\n然後選擇一門語言，比如 Python，點擊 Get a client ID，複製獲得的 Client ID\n返回安裝程式介面，輸入應用機密和 Client ID，然後點擊下一步\n點擊綁定帳號，選擇接受即可\n如果出現錯誤\n請返回輸入應用機密和 Client ID 的介面，打開 Azure 的應用程式註冊 ，這裡應該有兩個應用程式\n找到名為 oneindex 的應用程式，複製它的應用程式 (用戶端) ID 填入 Client ID\n還有一個沒什麼用，可以直接刪除\n管理 安裝完成後會有管理後台和訪問網站選項\n可以進入管理後台修改網站名稱，主題，後台密碼等 (初始密碼: oneindex)\n後台網址為您的網域/?/admin\n偽靜態 設定 Apache 或者 Nginx 的 rewrite (使用 WordPress 的設定即可)\n以上為原作者的原話(部分內容有修改)，因我使用 寶塔 ，遂說明寶塔如何設定\n在寶塔面板的網站進入設定裡的偽靜態，選擇 wordpress 保存即可\n在網站管理後台將偽靜態勾選保存即可\n這樣連結中的 ? 會去除，訪問後台可直接您的網域/admin\n特殊檔案實現功能 Markdown 語法可參考我寫的文章： Markdown 筆記 在資料夾底部添加說明:\n在 OneDrive 的資料夾中添加 README.md 檔案，使用 Markdown 語法。\n在資料夾頭部添加說明:\n在 OneDrive 的資料夾中添加 HEAD.md 檔案，使用 Markdown 語法。\n加密資料夾:\n在 OneDrive 的資料夾中添加 .password 檔案，填入密碼，密碼不能為空。\n直接輸出網頁:\n在 OneDrive 的資料夾中添加 index.html 檔案，程式會直接輸出網頁而不列目錄。 配合 檔案展示設置-直接輸出 效果更佳。\n因為直接輸出網頁，可以直接搭網站\n訪問其他檔案正常，但訪問圖片出現 404 這是由於伺服器軟體 (Nginx/Apache) 接管了圖片處理，刪除相關設定即可\n以下為使用寶塔\n在網站-設定檔案將下述程式碼註解掉即可\n1 2 3 4 5 location ~ .*\\.(gif|jpg|jpeg|png|bmp|swf)$ { expires 30d; access_log on; } 改為\n1 2 3 4 5 #location ~ .*\\.(gif|jpg|jpeg|png|bmp|swf)$ #{ # expires 30d; # access_log on; #} 此問題參考 部署 OneDrive for business (PHP)客戶端程序 OneIndex 详细教程 - VirCloud\u0026rsquo;s Blog - Learning\u0026amp;Sharing 命令列功能 僅能在 PHP CLI 模式下執行\n清除快取:\n1 php one.php cache:clear 重新整理快取:\n1 php one.php cache:refresh 重新整理權杖:\n1 php one.php token:refresh 上傳檔案:\n1 php one.php upload:file 本地檔案 [OneDrive檔案] 上傳資料夾:\n1 php one.php upload:folder 本地資料夾 [OneDrive資料夾] 例如：\n1 2 3 4 5 6 7 8 9 10 11 //上傳 demo.zip 到 OneDrive 根目錄 php one.php upload:file demo.zip //上傳 demo.zip 到 OneDrive /test/ 目錄 php one.php upload:file demo.zip /test/ //上傳 demo.zip 到 OneDrive /test/ 目錄並將其命名為 d.zip php one.php upload:file demo.zip /test/d.zip //上傳 up/ 到 OneDrive /test/ 目錄 php one.php upload:file up/ /test/ 排程任務 [可選]推薦配置，非必需。後台定時重新整理快取，可增加前台訪問的速度。\n1 2 3 4 5 # 每小時重新整理一次權杖 0 * * * * /具體路徑/php /程式具體路徑/one.php token:refresh # 每十分鐘後台重新整理一遍快取 */10 * * * * /具體路徑/php /程式具體路徑/one.php cache:refresh Docker 安裝執行 請參考 TimeBye/oneindex ","date":"2024-08-27T11:00:24+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/180/","title":"基於 OneDrive 建站 (oneindex)"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 文章撰寫於 2022.06.09，因早已不再使用該面板與 OLAINDEX，文章並無最新適配，可能無法復現\n不建議使用寶塔面板\n環境需求 PHP 擴充需求\nPHP \u0026gt;= 7.4 PHP OpenSSL 擴充 PHP PDO 擴充 PHP Mbstring 擴充 PHP Tokenizer 擴充 PHP XML 擴充 PHP Ctype 擴充 PHP JSON 擴充 PHP BCMath 擴充 PHP Fileinfo 擴充 最低安裝標準 nginx+php\n環境安裝 PHP 寶塔的軟體商店搜尋安裝PHP7.4\n然後打開PHP7.4的設定，到停用函式\n將這三個 proc_open，proc_get_status 和 putenv 函式從中刪除\ncomposer 寶塔官方預設 composer 來源為阿里雲無需修改，其他版本可能需要\n1 2 3 curl -sS https://getcomposer.org/installer | php mv composer.phar /usr/local/bin/composer composer config -g repo.packagist composer https://mirrors.aliyun.com/composer # 更換來源為中國大陸鏡像，國外伺服器可忽略此步驟 部署 建立一個網站，PHP 版本記得選擇 PHP-74\n進入網站根目錄，點擊終端機，依序輸入以下指令\n1 2 3 4 5 6 7 8 git clone https://github.com/WangNingkai/OLAINDEX.git tmp mv tmp/.git . rm -rf tmp git reset --hard composer install -vvv # 這裡確保已成功安裝 composer ，如果報權限問題，建議給予使用者完整權限。 chmod -R 777 storage chown -R www:www * # 此處 www 根據伺服器具體使用者群組而定 composer run install-app (此為自動安裝，預設 sqlite 儲存資料) 第五步忽略 fileinfo\n1 2 3 composer install -vvv 改為 composer install -vvv --ignore-platform-req=ext-fileinfo --ignore-platform-req=ext-fileinfo --ignore-platform-req=ext-fileinfo --ignore-platform-req=ext-fileinfo 安裝完成後會出現管理員名稱和密碼\n設定 在網站，點擊網域，找到網站目錄，將執行目錄改為 /public 並儲存\n點擊虛擬靜態 (Rewrite)，選擇 laravel5 並儲存\n點擊設定檔\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 將 location ~ .*\\.(gif|jpg|jpeg|png|bmp|swf)$ { expires 30d; error_log /dev/null; access_log /dev/null; } location ~ .*\\.(js|css)?$ { expires 12h; error_log /dev/null; access_log /dev/null; } 改為 #location ~ .*\\.(gif|jpg|jpeg|png|bmp|swf)$ #{ # expires 30d; # error_log /dev/null; # access_log /dev/null; #} #location ~ .*\\.(js|css)?$ #{ # expires 12h; # error_log /dev/null; # access_log /dev/null; #} 後台 登入網址為 xxx.com/admin，將 xxx.com 替換為您的網域\n預設帳號為 admin，密碼為 123456\n參考文章 寶塔面板安裝OLAINDEX 6.0教程 - 如默星空 OLAINDEX ","date":"2024-08-23T17:14:26+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/179/","title":"寶塔面板架設 OLAINDEX"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 文章寫於 2022.06.12，本不想發布，但見文章寫得較為完整，想著發出來留念吧。因早已不使用該面板與 ZFile，文章並無最新適配，可能無法復現。\n不建議使用寶塔面板\n安裝相依性套件 查看系統版本 1、cat /etc/issue，此指令也適用於所有的 Linux 發行版。\n1 2 3 [root@S-CentOS home]# cat /etc/issue CentOS release 6.5 (Final) Kernel \\r on an \\m 2、cat /etc/redhat-release，這種方法只適合 Redhat 系的 Linux：\n1 2 [root@S-CentOS home]# cat /etc/redhat-release CentOS release 6.5 (Final) 3、lsb_release -a，即可列出所有版本資訊：\n1 2 3 [root@S-CentOS ~]# lsb_release -a LSB Version: :base-4.0-amd64:base-4.0-noarch:core-4.0-amd64:core-4.0-noarch:graphics-4.0-amd64:graphics-4.0-noarch:printing-4.0-amd64:printing-4.0-noarch Distributor ID: CentOS 對應系統輸入相應指令 1 2 3 4 5 # CentOS系統 yum install -y java-1.8.0-openjdk unzip # Debian/Ubuntu系統 apt update apt install -y openjdk-8-jre-headless unzip 建立網站 建立站點\n進入網站目錄，開啟終端機，輸入以下指令：\n1 2 3 wget https://c.jun6.net/ZFILE/zfile-release.war unzip zfile-release.war \u0026amp;\u0026amp; rm -rf zfile-release.war chmod +x ./bin/*.sh 常用指令 在網站目錄下的終端機執行：\n1 2 3 ./bin/start.sh # 啟動專案 ./bin/stop.sh # 停止專案 ./bin/restart.sh # 重啟專案 開放連接埠 在「安全性」中開放 8080 連接埠\n輸入指令啟動專案後，造訪 IP:8080 即可看到網站。\n自定義網域 如需開啟 https，請先申請憑證後開啟反向代理。\n在寶塔面板網站設定中找到「反向代理」。\n目標 URL 為 http://IP:8080，發送網域為 $host。\n如果部署不成功 因使用其他版本的寶塔導致我部署不成功，經自己探索得知設定檔有問題，可嘗試在 反向代理 的 設定檔 處，將以下程式碼替換原先程式碼：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #PROXY-START/ location ^~ / { proxy_pass http://127.0.0.1:8080; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header REMOTE-HOST $remote_addr; add_header X-Cache $upstream_cache_status; #Set Nginx Cache set $static_fileJA2B5K30 0; if ( $uri ~* \u0026#34;\\.(gif|png|jpg|css|js|woff|woff2)$\u0026#34; ) { set $static_fileJA2B5K30 1; expires 12h; } if ( $static_fileJA2B5K30 = 0 ) { add_header Cache-Control no-cache; } } #PROXY-END/ 自定義設定 設定檔目錄為 ./WEB-INF/classes/application.yml\n具體設定項可參考： 官方文件-參數配置 特殊檔案變更（展示檔案） ZFile 的展示檔案預設為 readme.md，但多數架站程式的展示檔案為 README.md。\nZFile 的加密檔案預設為 password.txt，但 oneindex 的為 .password，如果逐一更改檔案名稱顯然太過麻煩。\n開啟 application.yml（在寶塔內雙擊即可編輯），按 CTRL+F，輸入 readme，找到以下程式碼：\n1 2 3 constant: readme: readme.md password: password.txt 改為：\n1 2 3 constant: readme: README.md password: .password 按下 CTRL+S 儲存，然後執行重啟指令即可。\n參考文章 寶塔面板部署 ZFile 網盤系統（原創改良版） - 柚子蜜 linux 查看系統資訊指令 - konglingbin - 博客園 ","date":"2024-08-16T14:43:25+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/178/","title":"寶塔面板架設 ZFile"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 最近伺服器快過期了，便想著把 VRC Blog 遷移到 GitHub 上，於是便想著看看有沒有什麼好的主題，剛開始是想著現在用的 Typecho 主題是從 Jekyll 移植的，但 半年前 去搜尋找不到了，然後最近又有點想了解 Hexo，找了半天主題又想到之前挺喜歡的 Argon 好像有 Hexo 版，然後便有了這篇文章。\n環境 需要安裝 Node.js 10.13 以上版本，推薦 12.0 以上。\n需要安裝 Git。\n安裝 執行指令：\n1 npm install -g hexo-cli 檢查安裝是否成功：\n1 hexo -h 建立新部落格 切換到要安裝的資料夾：\n1 hexo init \u0026lt;folder_name\u0026gt; 進入資料夾：\n1 cd \u0026lt;folder_name\u0026gt; 安裝相依套件：\n1 npm i 建立完成後可以修改 ./_config 進行設定。\n安裝主題 到 主題站 挑選一個主題，不同主題可能有不同的安裝方法，具體請參考主題文件。\n以下為 Argon 主題的安裝範例：\n複製主題 首先在 ./themes 資料夾複製主題儲存庫：\n1 git clone https://github.com/solstice23/hexo-theme-argon.git 將複製下來的資料夾重新命名為 argon。\n安裝 ejs 渲染器：\n1 npm install hexo-renderer-ejs 在 ./_config.yml 檔案中將 theme 改為 argon。\n設定檔 修改檔案 ./themes/argon/_config.yml 以更改設定。\n設定搜尋 在根目錄執行：\n1 npm install hexo-generator-search --save 然後在 ./_config.yml 中加入選項：\n1 2 3 4 search: path: search.xml field: post content: true 寫作 建立新文章：\n1 hexo new [layout] \u0026lt;title\u0026gt; 其中 [layout] 是一個可選屬性，具體如下：\nLayout 描述 路徑 post 文章，預設 source/_posts page 頁面 source draft 草稿 source/_drafts 建立完成後即可開始編寫文章。\n預覽：\n1 hexo s 存取 localhost:4000 查看效果。\n產生靜態檔案 執行指令：\n1 hexo generate 執行指令後只會針對有變動的部分進行產出，建議先將原有的刪除再重新產生會比較好。\n參考文章 https://hexo.io/docs/ https://github.com/solstice23/hexo-theme-argon ","date":"2024-08-09T08:49:53+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/177/","title":"Hexo 安裝與使用"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 問題描述 n-皇后問題是在 n 列 n 行的棋盤上放置 n 個皇后，使得皇后彼此之間不受攻擊，其規則是任意兩個皇后不在同一列、同一行和相同的對角線上 (也就是國際象棋的皇后移動範圍)。\n問題分析 擬採用以下思路解決 n-皇后問題：\n第 i 個皇后放在第 i 列\n從第一個皇后開始，對於每個皇后，從其對應列 (第 i 個皇后對應第 i 列) 的第一行開始嘗試 若可以放置，確定位置，考慮下一個皇后 若與之前的皇后衝突，則考慮下一行 若超出最後一行，則重新確定上一個皇後的位置\n重複該過程，直到找到所有的放置方案\nC 程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;math.h\u0026gt; #define N 4 // 皇后個數 // 判斷第 k 個皇后目前放置位置是否與前面的皇后衝突 int isplace(int pos[], int k){ int i; for(i=1; i\u0026lt;k; i++){ if(pos[i]==pos[k] || fabs(i-k) == fabs(pos[i]-pos[k])) return 0; } return 1; } int main(){ int i,j; int count = 1; int pos[N+1]; // 初始化位置 for(i=1;i\u0026lt;=N;i++) pos[i]=0; j = 1; while(j\u0026gt;=1){ pos[j]=pos[j]+1; // 嘗試擺放第 i 個皇后 while(pos[j]\u0026lt;=N \u0026amp;\u0026amp; !isplace(pos,j)){ pos[j]=pos[j]+1; // 得到一個擺放方案 } if(pos[j]\u0026lt;=N \u0026amp;\u0026amp; j==N){ printf(\u0026#34;方案 %d：\u0026#34;, count++); for(i=1;i\u0026lt;=N;i++) printf(\u0026#34;%d\u0026#34;, pos[i]); printf(\u0026#34;\\n\u0026#34;); } // 考慮下一個皇后 if(pos[j]\u0026lt;=N \u0026amp;\u0026amp; j\u0026lt;N){ j+=1; }else{ // 返回考慮上一個皇后 pos[j]=0; j-=1; } } return 1; } ","date":"2024-07-28T14:26:26+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/176/","title":"演算法 n-皇后問題 (回溯法)"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 前言 先前在將 Typecho 遷移至 Docker 容器後，開啟 HTTPS 時登入後台會報錯，而將 HTTPS 關閉後則可以正常存取。由於先前在非 Docker 部署時可以正常存取，我原以為是 Docker 網路的問題，且當時的修改是一次性的，不會再進行更新，因此我在關閉 HTTPS 完成修改後便不再處理。如今再次使用 Typecho 又遇到相同問題，考量到需要更新文章，於是尋找解決方法。\n解決方法 解決方法非常簡單，在 data/config.inc.php 檔案最後加入以下程式碼：\n1 define(\u0026#39;__TYPECHO_SECURE__\u0026#39;, true); 接著重新啟動即可。\n成因分析 參考資料中推測是因為使用者與瀏覽器之間是透過 HTTPS 互動，但實際上 PHP 接收到的是來自 Cloudflare 的 HTTP 請求，因此 PHP 使用 HTTP 進行回應，進而導致了這個問題。\n參考文章 Typecho HTTPS 無法登入後台 ","date":"2024-07-26T22:22:22+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/175/","title":"Typecho HTTPS 無法登入存取後台"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 引言 畢業論文真是折磨呢。這是什麼時候的文章呢，這個檔案建立時間 2023.11.30 而修改時間 2022.09.18，我看不懂，但我大受震撼\n程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 \u0026lt;script\u0026gt; function secondToDate(second) { if (!second) { return 0; } var time = new Array(0, 0, 0, 0, 0); if (second \u0026gt;= 365 * 24 * 3600) { time[0] = parseInt(second / (365 * 24 * 3600)); second %= 365 * 24 * 3600; } if (second \u0026gt;= 24 * 3600) { time[1] = parseInt(second / (24 * 3600)); second %= 24 * 3600; } if (second \u0026gt;= 3600) { time[2] = parseInt(second / 3600); second %= 3600; } if (second \u0026gt;= 60) { time[3] = parseInt(second / 60); second %= 60; } if (second \u0026gt; 0) { time[4] = second; } return time; }\u0026lt;/script\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; language=\u0026#34;javascript\u0026#34;\u0026gt; function setTime() { var create_time = Math.round(new Date(Date.UTC(2021, 11, 6, 14, 15, 19)).getTime() / 1000); var timestamp = Math.round((new Date().getTime() + 8 * 60 * 60 * 1000) / 1000); currentTime = secondToDate((timestamp - create_time)); currentTimeHtml = \u0026#39;This Blog has running: \u0026lt;br/\u0026gt;\u0026#39; + currentTime[0] + \u0026#39; y \u0026#39; + currentTime[1] + \u0026#39; d \u0026#39; + currentTime[2] + \u0026#39; h \u0026#39; + currentTime[3] + \u0026#39; m \u0026#39; + currentTime[4] + \u0026#39; s\u0026#39;; document.getElementById(\u0026#34;htmer_time\u0026#34;).innerHTML = currentTimeHtml; } setInterval(setTime, 1000); \u0026lt;/script\u0026gt; 引用 在想放入的地方加入\n1 \u0026lt;span id=\u0026#34;htmer_time\u0026#34; style=\u0026#34;color: pink;\u0026#34; /\u0026gt; 參考文章 個人部落格添加運作時間 - 騰訊雲開發者社群-騰訊雲 ","date":"2024-05-14T11:08:25+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/172/","title":"部落格運作時間"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 Gateway 是所有微服務的統一入口點，具有以下功能：\n身份驗證與權限檢查：閘道器作為微服務入口點，需要驗證使用者是否有請求資格，如果沒有則進行攔截。 請求路由、負載平衡：所有請求都必須先經過Gateway，但閘道器不處理商業邏輯，而是根據某種規則，將請求轉發到某個微服務，這個過程稱為路由。當然，當路由的目標服務有多個時，還需要進行負載平衡。 流量限制：當請求流量過高時，在閘道器中依照下游微服務能夠接受的速度來放行請求，避免服務壓力過大。 SpringCloud 的閘道器實作有兩種：\nZuul：基於 Servlet 實作，屬於阻塞式程式設計。 SpringCloudGateway：基於 Spring5 中提供的 WebFlux，屬於響應式程式設計的實作，具備更好的效能。 簡單入門 建立專案，引入依賴：\n1 2 3 4 5 6 7 8 9 10 \u0026lt;!--閘道器--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-gateway\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--nacos服務發現依賴--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-alibaba-nacos-discovery\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 編寫基本設定和路由規則：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 server: port: 10010 # 閘道器埠號 spring: application: name: gateway # 服務名稱 cloud: nacos: server-addr: localhost:8848 # nacos位址 gateway: routes: # 閘道器路由設定 - id: user-service # 路由ID，自訂，只要唯一即可 # uri: http://127.0.0.1:8081 # 路由的目標位址 http就是固定位址 uri: lb://userService # 路由的目標位址 lb就是負載平衡，後面接服務名稱 predicates: # 路由斷言，也就是判斷請求是否符合路由規則的條件 - Path=/user/** # 這個是依照路徑匹配，只要以/user/開頭就符合要求 然後存取 \u0026lt;localhost:10010/user/1\u0026gt; 進行測試。\n路由設定包含：\n路由ID：路由的唯一識別。 路由目標 (uri)：路由的目標位址，http 代表固定位址，lb 代表根據服務名稱負載平衡。 路由斷言 (predicates)：判斷路由的規則，符合則轉發到路由目的地。 路由過濾器 (filters)：對請求或回應進行處理。 斷言工廠 在設定檔中編寫的斷言規則僅是字串，這些字串會被 Predicate Factory 讀取並處理，轉換為路由判斷的條件。\n例如上述範例 Path=/user/** 是依照路徑匹配，這個規則是由 org.springframework.cloud.gateway.handler.predicate.PathRoutePredicateFactory 類別來處理的，類似的斷言工廠有：\n名稱 說明 範例 After 某個時間點之後的請求 - After=2037-01-20T17:42:47.789-07:00[America/Denver] Before 某個時間點之前的請求 - Before=2031-04-13T15:14:47.433+08:00[Asia/Shanghai] Between 某兩個時間點之間的請求 - Between=2037-01-20T17:42:47.789-07:00[America/Denver], 2037-01-21T17:42:47.789-07:00[America/Denver] Cookie 請求必須包含某些Cookie - Cookie=chocolate, ch.p Header 請求必須包含某些標頭 - Header=X-Request-Id, \\d+ Host 請求必須是存取某個主機 (網域) - Host=.somehost.org,.anotherhost.org Method 請求方式必須是指定方式 - Method=GET,POST Path 請求路徑必須符合指定規則 - Path=/red/{segment},/blue/** Query 請求參數必須包含指定參數 - Query=name, Jack或者- Query=name RemoteAddr 請求者的IP必須是指定範圍 - RemoteAddr=192.168.1.1/24 Weight 權重處理 過濾器工廠 GatewayFilter 是閘道器中提供的一種過濾器，可以對進入閘道器的請求和微服務回傳的回應進行處理。\nSpring 提供了 31 種不同的路由過濾器工廠，例如：\n名稱 說明 AddRequestHeader 給當前請求添加一個請求標頭 RemoveRequestHeader 移除請求中的一個請求標頭 AddResponseHeader 給回應結果中添加一個回應標頭 RemoveResponseHeader 從回應結果中移除一個回應標頭 RequestRateLimiter 限制請求的流量 更多參考： https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway/gatewayfilter-factories.html 請求標頭過濾器 以請求標頭過濾器為例，給所有進入 userService 的請求添加一個請求標頭：Hello=World。\n在 gateway 中修改 application.yml，添加路由過濾：\n1 2 3 4 5 6 7 8 9 10 spring: cloud: gateway: routes: - id: user-service uri: lb://userservice predicates: - Path=/user/** filters: # 過濾器 - AddRequestHeader=Hello, World # 添加請求標頭 然後可以修改 Controller 進行測試：\n1 2 3 4 5 @GetMapping(\u0026#34;/{id}\u0026#34;) public User queryById(@PathVariable(\u0026#34;id\u0026#34;) Long id, @RequestHeader(\u0026#34;Hello\u0026#34;) String hello) { System.out.println(hello); return userService.queryById(id); } 預設過濾器 如果想對所有的路由都生效，則可以將過濾器工廠寫在 default 下：\n1 2 3 4 5 6 7 8 9 10 spring: cloud: gateway: routes: - id: user-service uri: lb://userservice predicates: - Path=/user/** default-filters: # 預設過濾項 - AddRequestHeader=Hello, World 全域過濾器 閘道器提供了 31 種過濾器，但每一種過濾器的作用都是固定的。如果我們希望攔截請求，執行自己的商業邏輯，則無法實作。\n而全域過濾器的作用也是處理所有進入閘道器的請求和微服務回應，與 GatewayFilter 的作用一樣。區別在於 GatewayFilter 透過設定定義，處理邏輯是固定的；而 GlobalFilter 的邏輯需要自己編寫程式碼實作，定義方式是實作 GlobalFilter 介面：\n1 2 3 4 5 6 7 8 9 10 public interface GlobalFilter { /** * 處理當前請求，如有必要，透過{@link GatewayFilterChain}將請求交給下一個過濾器處理 * * @param exchange 請求上下文，其中可以取得Request、Response等資訊 * @param chain 用來將請求委託給下一個過濾器 * @return {@code Mono\u0026lt;Void\u0026gt;} 回傳表示當前過濾器業務結束 */ Mono\u0026lt;Void\u0026gt; filter(ServerWebExchange exchange, GatewayFilterChain chain); } 在 filter 中編寫自訂邏輯，可以實作下列功能：\n登入狀態判斷 權限驗證 請求流量限制等 簡單使用 目標：定義全域過濾器，攔截請求，判斷請求的參數是否符合以下條件：\n參數中是否有 authorization， authorization 參數值是否為 admin。 若同時符合則放行，否則攔截。\n首先在 gateway 中定義一個過濾器：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 @Order(-1) // 優先處理 @Component public class AuthorizeFilter implements GlobalFilter { @Override public Mono\u0026lt;Void\u0026gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) { // 取得請求參數 MultiValueMap\u0026lt;String, String\u0026gt; params = exchange.getRequest().getQueryParams(); // 取得AuthorizeFilter參數，此處約定第一個為認證參數 String authorize = params.getFirst(\u0026#34;AuthorizeFilter\u0026#34;); // 檢查 if(\u0026#34;admin\u0026#34;.equals(authorize)){ // 放行 return chain.filter(exchange); } // 攔截，禁止存取 exchange.getResponse().setStatusCode(HttpStatus.FORBIDDEN); // 結束處理 return exchange.getResponse().setComplete(); } } 過濾器執行順序 請求進入閘道器會遇到三種過濾器：當前路由的過濾器、DefaultFilter、GlobalFilter。\n請求路由後，會將當前路由過濾器和 DefaultFilter、GlobalFilter，合併到一個過濾器鏈（集合）中，排序後依序執行每個過濾器。\n每個過濾器都有 int 類型的 order 值，order 值越小，優先序越高，執行順序越靠前。\n路由過濾器和 defaultFilter 的 order 值由 Spring 指定，預設從 1 開始遞增。\nGlobalFilter 透過實作 Ordered 介面，或是添加 @Order 註解來指定 order 值，由我們自己指定。\n當過濾器的 order 值相同時，會依照 defaultFilter \u0026gt; 路由過濾器 \u0026gt; GlobalFilter 的順序執行。\n其中透過實作介面指定 order 值：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 //@Order(-1) // 優先處理 @Component public class AuthorizeFilter implements GlobalFilter, Ordered { @Override public Mono\u0026lt;Void\u0026gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) { // 取得請求參數 MultiValueMap\u0026lt;String, String\u0026gt; params = exchange.getRequest().getQueryParams(); // 取得AuthorizeFilter參數，此處約定第一個為認證參數 String authorize = params.getFirst(\u0026#34;AuthorizeFilter\u0026#34;); // 檢查 if(\u0026#34;admin\u0026#34;.equals(authorize)){ // 放行 return chain.filter(exchange); } // 攔截，禁止存取 exchange.getResponse().setStatusCode(HttpStatus.FORBIDDEN); // 結束處理 return exchange.getResponse().setComplete(); } @Override public int getOrder() { return -1; } } 跨網域問題 同網域表示協定相同、IP 或網域名稱相同、埠號相同。\n跨網域問題：瀏覽器禁止請求發起者與伺服端發生跨網域 AJAX 請求，請求被瀏覽器攔截的問題，解決方案便是 CORS。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 spring: cloud: gateway: globalcors: # 全域的跨網域處理 add-to-simple-url-handler-mapping: true # 解決options請求被攔截問題 corsConfigurations: \u0026#39;[/**]\u0026#39;: allowedOrigins: # 允許哪些網站的跨網域請求 - \u0026#34;http://localhost:8090\u0026#34; allowedMethods: # 允許的跨網域AJAX請求方式 - \u0026#34;GET\u0026#34; - \u0026#34;POST\u0026#34; - \u0026#34;DELETE\u0026#34; - \u0026#34;PUT\u0026#34; - \u0026#34;OPTIONS\u0026#34; allowedHeaders: \u0026#34;*\u0026#34; # 允許在請求中攜帶的標頭資訊 allowCredentials: true # 是否允許攜帶Cookie maxAge: 360000 # 這次跨網域偵測的有效期限 ","date":"2024-05-05T00:54:52+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/171/","title":"Gateway 服務閘道器"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 Feign 是一個宣告式的 HTTP 用戶端，Github： https://github.com/OpenFeign/feign 簡單用法 引用相依性\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-openfeign\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 在啟動類別加入註解以開啟 Feign 的功能\n1 2 @EnableFeignClients @SpringBootApplication 撰寫 Feign 用戶端\n1 2 3 4 5 @FeignClient(\u0026#34;userService\u0026#34;) public interface UserClient { @GetMapping(\u0026#34;/user/{id}\u0026#34;) User findById(@PathVariable(\u0026#34;id\u0026#34;) Long id); } 取代 RestTemplate\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 @Service public class OrderService { @Autowired private OrderMapper orderMapper; // @Autowired // private RestTemplate restTemplate; @Autowired private UserClient userClient; public Order queryOrderById(Long orderId) { // 1.查詢訂單 Order order = orderMapper.findById(orderId); // 2.查詢使用者 // String url = \u0026#34;http://localhost:8081/user/\u0026#34; + order.getUserId(); // String url = \u0026#34;http://userService/user/\u0026#34; + order.getUserId(); // User user = restTemplate.getForObject(url, User.class); // Feign User user = userClient.findById(order.getUserId()); // 3.封裝使用者資訊 order.setUser(user); // 4.回傳 return order; } } 自訂設定 Feign 支援自訂設定來覆寫預設設定，可修改的設定如下：\n類型 作用 說明 feign.Logger.Level 修改日誌等級 包含四種不同的等級：NONE、BASIC、HEADERS、FULL feign.codec.Decoder 回應結果的解析器 HTTP 遠端呼叫的結果解析，例如將 JSON 字串解析為 Java 物件 feign.codec.Encoder 請求參數編碼 將請求參數編碼，以便透過 HTTP 請求傳送 feign. Contract 支援的註解格式 預設是 SpringMVC 的註解 feign. Retryer 失敗重試機制 請求失敗的重試機制，預設沒有，但會使用 Ribbon 的重試 通常只需設定日誌等級，日誌等級有：\nNONE：不記錄任何日誌資訊，這是預設值 BASIC：僅記錄請求的方法、URL、回應狀態碼以及執行時間 HEADERS：在 BASIC 的基礎上，額外記錄了請求和回應的標頭資訊 FULL：記錄所有請求和回應的明細，包括標頭資訊、請求本體、中繼資料 設定方式有兩種，一種是設定檔，另一種是建立 Bean\n設定檔 設定檔針對單一服務\n1 2 3 4 5 feign: client: config: userservice: # 針對某個微服務的設定 loggerLevel: FULL # 日誌等級 針對所有服務\n1 2 3 4 5 feign: client: config: default: # 這裡使用 default 代表全域設定，如果寫服務名稱，則是針對某個微服務的設定 loggerLevel: FULL # 日誌等級 bean 先宣告一個類別，然後宣告一個 Logger.Level 的物件\n1 2 3 4 5 6 public class DefaultFeignConfiguration { @Bean public Logger.Level feignLogLevel(){ return Logger.Level.BASIC; // 日誌等級為 BASIC } } 如果要在全域生效，請放在啟動類別的 @EnableFeignClients 註解中\n1 @EnableFeignClients(defaultConfiguration = DefaultFeignConfiguration .class) 如果是區域生效，請放在 @FeignClient 註解中\n1 @FeignClient(value = \u0026#34;userService\u0026#34;, configuration = DefaultFeignConfiguration .class) Feign 使用優化 Feign 底層用戶端實作：\nURLConnection：預設實作，不支援連線池\nApache HttpClient ：支援連線池\nOKHttp：支援連線池\n使用連線池可以提升 Feign 的效能\n以下範例為取代為 HttpClient\n引用相依性 1 2 3 4 5 \u0026lt;!-- httpClient 的相依性 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.github.openfeign\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;feign-httpclient\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 設定連線池 1 2 3 4 5 6 7 8 9 feign: client: config: default: # default 全域設定 loggerLevel: BASIC # 日誌等級，BASIC 代表基本的請求和回應資訊 httpclient: enabled: true # 開啟 Feign 對 HttpClient 的支援 max-connections: 200 # 最大連線數 max-connections-per-route: 50 # 每個路徑的最大連線數 最佳實踐 所謂最佳實踐，就是在使用過程中歸納的經驗，是一種最佳的使用方式\nFeign 的用戶端與服務提供者的 Controller 程式碼非常相似\n1 2 3 4 5 6 7 8 9 10 11 12 // Feign 用戶端 @FeignClient(\u0026#34;userService\u0026#34;) public interface UserClient { @GetMapping(\u0026#34;/user/{id}\u0026#34;) User findById(@PathVariable(\u0026#34;id\u0026#34;) Long id); } // Controller @GetMapping(\u0026#34;/user/{id}\u0026#34;) public User queryById(@PathVariable(\u0026#34;id\u0026#34;) Long id) { return userService.queryById(id); } 對於重複的程式碼，有兩種簡化方法\n方式一：繼承 為消費者的 FeignClient 和提供者的 Controller 定義統一的父介面作為標準\n定義一個介面\n1 2 3 4 public interface UserAPI{ @GetMapping(\u0026#34;/user/{id}\u0026#34;) User findById(@PathVariable(\u0026#34;id\u0026#34;) Long id); } Feign 用戶端實作\n1 2 @FeignClient(value=\u0026#34;userService\u0026#34;) public interface UserClient extends UserAPI{} Controller 類別\n1 2 3 4 5 6 @RestController public class UserController implements UserAPI{ public User findById(@PathVariable(\u0026#34;id\u0026#34;) Long id){ // 程式碼 } } 優點：簡單，實作了程式碼共享\n缺點：\n服務提供者、消費者強耦合 參數列表中的註解映射並不會繼承，因此 Controller 中必須再次宣告方法、參數列表、註解 方式二：抽離方式 將 FeignClient 抽離為獨立模組，並且把介面相關的 POJO、預設的 Feign 設定都放到這個模組中，提供給所有消費者使用\n建立一個新專案，引用 Feign 起始相依性\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-openfeign\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 在消費者端引用 feign-api 的相依性\n當定義的 FeignClient 不在 SpringBootApplication 的掃描套件範圍時，這些 FeignClient 無法使用，有兩種方式解決\n指定 Feign 應該掃描的套件 1 @EnableFeignClients(basePackages = \u0026#34;net.yexca.feign.clients\u0026#34;) 指定要載入的 Client 介面 1 @EnableFeignClients(clients = {UserClient.class}) ","date":"2024-05-03T23:11:52+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/170/","title":"Feign 遠端呼叫"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 需先安裝軟體，官網： https://nacos.io/zh-cn/ 在 conf/application.properties 檔案中可以更改連接埠，預設為 8848\n註冊服務 父專案中新增管理相依性\n1 2 3 4 5 6 7 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-alibaba-dependencies\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.6.RELEASE\u0026lt;/version\u0026gt; \u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt; \u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; 註解掉 Eureka 的相依性，並新增 Nacos 用戶端的相依性\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-alibaba-nacos-discovery\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 修改 application.yml，新增 Nacos 位址，註解掉 Eureka 位址\n1 2 3 4 spring: cloud: nacos: server-addr: localhost:8848 啟動 Nacos\n1 2 startup.cmd -m standalone # 參數為單機啟動 存取 http://localhost:8848/nacos/ 登入帳號密碼皆為 nacos\n分級儲存模型 服務分為多個叢集，每個叢集有多個實例，叢集可以按地區分配，以提高存取速度\n相對的，Eureka 只有 服務-實例，沒有叢集\n服務呼叫應盡可能選擇本地叢集的服務，跨叢集呼叫延遲較高。當本地叢集不可存取時，再去存取其他叢集\n可以透過 application.yml 設定叢集\n1 2 3 4 5 6 spring: cloud: nacos: server-addr: localhost:8848 discovery: cluster-name: Shanghai # 叢集名稱 然後將 Ribbon 的策略設定為 Nacos 的策略\n1 2 3 4 5 # 為某個微服務設定負載平衡規則，這裡是以 userService 服務為例 userService: ribbon: NFLoadBalancerRuleClassName: com.alibaba.cloud.nacos.ribbon.NacosRule # NFLoadBalancerRuleClassName: com.netflix.loadbalancer.Nac # 負載平衡規則 接著可以在 Nacos 設定實例的權重 (0-1)，權重越大，存取頻率越高\n環境隔離 Nacos 中服務儲存和資料儲存的最外層都是一個名為 namespace 的東西，用來做最外層隔離\n可以在 Nacos 中新建一個命名空間，例如 dev，然後修改 application.yml\n1 2 3 4 5 6 7 spring: cloud: nacos: server-addr: localhost:8848 discovery: cluster-name: Shanghai # 叢集名稱 namespace: UUID # 此處為命名空間的 UUID 不同 namespace 下的服務互相不可見，無法存取\n臨時實例與非臨時實例 對於臨時實例，Nacos 的處理方式與 Eukera 一致\n對於非臨時實例，Nacos 會主動詢問是否存活，服務不可用時不會刪除，在服務不可用時，Nacos 會主動通知消費者\n設定非臨時實例：\n1 2 3 4 5 spring: cloud: nacos: discovery: ephemeral: false # 設定為非臨時實例 Nacos 設定管理 當微服務部署的實例變多時，逐個更改設定非常麻煩，可以使用 Nacos 將設定集中管理，並且支援熱更新\n簡單使用 在 Nacos 控制台的設定管理中新增設定，其中 Data ID 為設定檔的 ID，格式為 [服務名稱]-[profile].[副檔名]，例如 userService-dev.yaml\n然後在設定內容中撰寫設定即可，例如：\n1 2 pattern: dateformat: yyyy-MM-dd HH:mm:ss 引入 Nacos 的設定管理用戶端相依性\n1 2 3 4 5 \u0026lt;!--nacos 設定管理相依性--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-alibaba-nacos-config\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 取得設定的步驟\n專案啟動 -\u0026gt; bootstrap.yml -\u0026gt; Nacos 設定檔 -\u0026gt; 本地 application.yml -\u0026gt; 建立 Spring 容器 -\u0026gt; 載入 bean\n新增 bootstrap.yml\n1 2 3 4 5 6 7 8 9 10 spring: application: name: userService # 服務名稱 profiles: active: dev # 開發環境，這裡設定為 dev cloud: nacos: server-addr: localhost:8848 # Nacos 位址 config: file-extension: yaml # 檔案副檔名 測試\n1 2 3 4 5 6 7 8 9 10 11 12 @RestController @RequestMapping(\u0026#34;/user\u0026#34;) public class UserController{ @Value(\u0026#34;${pattern.dateformat}\u0026#34;) private String dateformat; @GetMapping(\u0026#34;/now\u0026#34;) public String now(){ return LocalDateTime.now().format(DateTimeFormatter.ofPattern(dateformat)) } } 存取頁面查看效果\n熱更新 可以透過兩種方式實現\n方式一：在 @Value 注入的變數所在類別上加上註解 @RefreshScope\n1 2 3 4 5 6 7 8 9 10 11 12 13 @RefreshScope // 設定自動刷新 @RestController @RequestMapping(\u0026#34;/user\u0026#34;) public class UserController{ @Value(\u0026#34;${pattern.dateformat}\u0026#34;) private String dateformat; @GetMapping(\u0026#34;/now\u0026#34;) public String now(){ return LocalDateTime.now().format(DateTimeFormatter.ofPattern(dateformat)) } } 方式二：使用 @ConfigurationProperties\n新建設定類別\n1 2 3 4 5 6 @Component @Data @ConfigurationProperties(prefix = \u0026#34;pattern\u0026#34;) public class PatternProperties { private String dateformat; } Controller 類別\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // @RefreshScope // 設定自動刷新 @RestController @RequestMapping(\u0026#34;/user\u0026#34;) public class UserController{ // @Value(\u0026#34;${pattern.dateformat}\u0026#34;) // private String dateformat; @Autowired private PatternProperties properties; @GetMapping(\u0026#34;/now\u0026#34;) public String now(){ return LocalDateTime.now().format(DateTimeFormatter.ofPattern(properties.getDateformat())) } } 設定共享 微服務啟動時，會從 Nacos 讀取多個設定檔\n[spring.application.name]-[spring.profiles.active].yaml，例如：userService-dev.yaml\n[spring.application.name].yaml，例如：userService.yaml\n而第二個 [spring.application.name].yaml 不包含環境資訊，可以被多個環境共享\n設定優先順序：[spring.application.name]-[spring.profiles.active].yaml \u0026gt; [spring.application.name].yaml \u0026gt; 本地設定\n","date":"2024-05-02T22:36:17+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/169/","title":"Nacos 註冊中心"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 消費者發送請求會被 Ribbon 攔截，Ribbon 從 Eureka 取得提供者列表，Eureka 回傳提供者列表，Ribbon 根據 IRule 選擇伺服器發送請求。\n詳細攔截：請求 -\u0026gt; DynamicServerListLoadBalancer (獲取 URL 中的服務 ID, userService) -\u0026gt; DynamicServerListLoadBalancer -\u0026gt; Eureka -\u0026gt; DynamicServerListLoadBalancer -\u0026gt; IRule -\u0026gt; DynamicServerListLoadBalancer -\u0026gt; 發送請求\n負載平衡策略 內建負載平衡規則類別 規則描述 ZoneAvoidanceRule (Eureka 預設) 以區域可用的伺服器為基礎進行伺服器的選擇。使用 Zone 對伺服器進行分類，這個 Zone 可以理解為一個機房、一個機架等。而後再對 Zone 內的多個服務做輪詢 RoundRobinRule 簡單輪詢服務列表來選擇伺服器。它是 Ribbon 預設的負載平衡規則 AvailabilityFilteringRule 對以下兩種伺服器進行忽略： （1）在預設情況下，這台伺服器如果 3 次連線失敗，這台伺服器就會被設置為「短路」狀態。短路狀態將持續 30 秒，如果再次連線失敗，短路的持續時間就會呈幾何級數增加（2）併發數過高的伺服器。如果一個伺服器的併發連線數過高，配置了 AvailabilityFilteringRule 規則的用戶端也會將其忽略。併發連線數的上限，可以由用戶端的 \u0026lt;clientName\u0026gt;.\u0026lt;clientConfigNameSpace\u0026gt;.ActiveConnectionsLimit 屬性進行配置 WeightedResponseTimeRule 為每一個伺服器賦予一個權重值。伺服器回應時間越長，這個伺服器的權重就越小。這個規則會隨機選擇伺服器，這個權重值會影響伺服器的選擇 BestAvailableRule 忽略那些短路的伺服器，並選擇併發數較低的伺服器 RandomRule 隨機選擇一個可用的伺服器 RetryRule 重試機制的選擇邏輯 使用隨機策略 透過定義 IRule 實作可以修改負載平衡規則，有兩種方式：\n程式碼方式：在配置類別中，定義一個新的 IRule (全域設定) 1 2 3 4 @Bean public IRule randomRule(){ return new RandomRule(); } 設定檔方式：在 orderServer application.yml 檔案中，新增設定以修改規則 1 2 3 userService: # 為某個微服務配置負載平衡規則，這裡是 userservice 服務 ribbon: NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule # 負載平衡規則 懶載入 Ribbon 預設是採用懶載入 (Lazy Load)，即第一次存取時才會去建立 LoadBalanceClient，請求時間會很長；而預先載入 (Eager Load) 則會在專案啟動時建立，降低第一次存取的耗時。配置開啟預先載入：\n1 2 3 4 ribbon: eager-load: enabled: true clients: userService # 指定對 userService 這個服務進行預先載入 ","date":"2024-04-28T15:50:15+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/168/","title":"Ribbon 負載平衡"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 Golang 系列\nHello GoLang: https://blog.yexca.net/archives/154 GoLang (var and const) 變數與常數: https://blog.yexca.net/archives/155 GoLang (func) 函式: https://blog.yexca.net/archives/156 GoLang (slice and map) 切片: https://blog.yexca.net/archives/160 GoLang (OOP) 物件導向: 本文\nGoLang (reflect) 反射: https://blog.yexca.net/archives/204 GoLang (struct tag) 結構體標籤: https://blog.yexca.net/archives/205 GoLang (goroutine) Go 協程: https://blog.yexca.net/archives/206 GoLang (channel) 通道: https://blog.yexca.net/archives/207 透過使用結構體構建類別與物件的概念\n了解物件導向： 物件導向基礎 struct 首先是自訂型別，使用 type 關鍵字，類似於 C\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package main import \u0026#34;fmt\u0026#34; type myType int func main() { var a myType fmt.Println(\u0026#34;a =\u0026#34;, a) fmt.Printf(\u0026#34;type of a is %T\u0026#34;, a) } /* * 輸出 * a = 0 * type of a is main.myTye */ 定義型別使用 struct\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package main import \u0026#34;fmt\u0026#34; type Person struct { name string age int } fun main() { var zhang Person zhang.name = \u0026#34;zhangSan\u0026#34; zhang.age = 20 fmt.Print(zhang) } 函式傳遞相關，不使用指標是傳值 (Value Passing)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 package main import \u0026#34;fmt\u0026#34; type Person struct { name string age int } // 傳值，不會修改原始資料 func changeName(person Person) { person.name = \u0026#34;liSi\u0026#34; } // 傳址，會修改原始資料 func changeAge(person *Person) { person.age = 18 } func main() { var zhang Person zhang.name = \u0026#34;zhangSan\u0026#34; zhang.age = 20 fmt.Println(zhang) changeName(zhang) fmt.Println(zhang) changeAge(\u0026amp;zhang) fmt.Println(zhang) } 封裝 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 package main import \u0026#34;fmt\u0026#34; // 類別 type Person struct { // 屬性 name string age int } // 類別的方法 func (this *Person) SetName(name string) { this.name = name } func (this *Person) SetAge(age int) { this.age = age } func (this *Person) GetName() string { return this.name } func (this *Person) GetAge() int { return this.age } func main() { person := Person{name: \u0026#34;zhangSan\u0026#34;, age: 18} fmt.Println(person) } 注意到上述類別名稱、方法名稱首字母為大寫，代表該類別、方法可以被其他套件存取 (java public)，若首字母小寫則只能由此套件存取 (java private)，屬性名稱也是同理\n繼承 以下程式碼處於同一檔案，父類別\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 父類別 type Person struct { name string age int } // 父類別的方法 func (this *Person) Eat() { fmt.Println(\u0026#34;Person Eat...\u0026#34;) } func (this *Person) Walk() { fmt.Println(\u0026#34;Person Walk...\u0026#34;) } 子類別\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 子類別 type SuperMan struct { Person // 繼承父類別 level int // 子類別屬性 } // 子類別覆寫父類別方法 func (this *SuperMan) Walk() { fmt.Println(\u0026#34;SuperMan Walk\u0026#34;) } // 子類別特有方法 func (this *SuperMan) Fly() {} main 函式\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func main() { // 定義子類別屬性，方式一 superMan1 := SuperMan{Person{\u0026#34;zhangSan\u0026#34;, 18}, 4} // 定義子類別屬性，方式二 var superMan2 SuperMan superMan2.name = \u0026#34;liSi\u0026#34; // 因為同一個套件，可以存取父類別屬性 superMan2.age = 20 superMan2.level = 5 // 子類別呼叫父類別方法 superMan1.Eat() // 子類別覆寫方法 superMan1.Walk() // 子類別方法 superMan2.Fly() } 多型 以下程式碼處於同一檔案，定義介面\n1 2 3 4 5 6 // 介面，本質是一個指標 type Animal interface { Sleep() GetName() string GetType() string } 實作類別一\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 實作類別一 type Cat struct { name string kind string } // 實作介面所有方法 func (this *Cat) Sleep() { fmt.Println(\u0026#34;Cat Sleep()\u0026#34;) } func (this *Cat) GetName() string { return this.name } func (this *Cat) GetType() string { return this.kind } 實作類別二\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // 實作類別二 type Dog struct { name string kind string } // 實作介面所有方法 func (this *Dog) Sleep() { fmt.Println(\u0026#34;Cat Sleep()\u0026#34;) } func (this *Dog) GetName() string { return this.name } func (this *Dog) GetType() string { return this.kind } func ShowAnimal(animal Animal) { fmt.Println(animal) } main\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 func ShowAnimal(animal Animal) { fmt.Println(animal) } func main() { var animal Animal animal = \u0026amp;Cat{\u0026#34;cat1\u0026#34;, \u0026#34;cat\u0026#34;} animal.Sleep() animal = \u0026amp;Dog{\u0026#34;dog1\u0026#34;, \u0026#34;dog\u0026#34;} animal.Sleep() cat := Cat{\u0026#34;cat2\u0026#34;, \u0026#34;cat\u0026#34;} dog := Dog{\u0026#34;dog2\u0026#34;, \u0026#34;dog\u0026#34;} ShowAnimal(\u0026amp;cat) ShowAnimal(\u0026amp;dog) } 萬用型別與斷言 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package main import \u0026#34;fmt\u0026#34; // 使用空介面表示萬用資料型別 func f(arg interface{}) { // 型別斷言機制（即型別轉換） value, flag := arg.(string) if !flag { fmt.Println(\u0026#34;arg is not string type\u0026#34;) } else { fmt.Println(\u0026#34;arg is string type, arg =\u0026#34;, value) } } func main() { // 可以傳入任意資料型別，包括自訂 f(\u0026#34;abc\u0026#34;) f(123) f(3.14) } /* * 輸出 * arg is string type, arg = abc * arg is not string type * arg is not string type */ ","date":"2024-03-01T15:35:38+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/162/","title":"GoLang 物件導向"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 引入註冊中心之前先引入提供者與消費者概念\n提供者與消費者 服務提供者：一次業務中，被其他微服務呼叫的服務。（提供介面給其他微服務）\n服務消費者：一次業務中，呼叫其他微服務的服務。（呼叫其他微服務提供的介面）\n提供者與消費者是相對的，一個服務既可以是提供者也可以是消費者\nEureka 若提供者有多個，消費者如何獲取提供者資訊，如何得知提供者的健康狀態\n在啟動時，微服務向 Eureka 註冊服務資訊，消費者可透過 Eureka 抓取提供者資訊，然後進行遠端呼叫。微服務會每 30 秒向 Eureka 說明自己還活著，Eureka 會更新紀錄服務列表資訊，剔除不健康的伺服器\n如果有多個服務提供者，消費者利用負載平衡演算法，從服務列表中挑選一個\n建置 新建一個 Maven 模組，引入相依性\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-eureka-server\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 撰寫啟動類別\n1 2 3 4 5 6 7 @EnableEurekaServer @SpringBootApplication public class EurekaApplication { public static void main(String[] args) { SpringApplication.run(EurekaApplication.class,args); } } 設定檔\n1 2 3 4 5 6 7 8 9 server: port: 7995 spring: application: name: eureka-server eureka: client: service-url: defaultZone: http://127.0.0.1:7995/eureka 註冊服務 引入相依性\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-eureka-client\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 撰寫設定\n1 2 3 4 5 6 7 spring: application: name: userService eureka: client: service-url: defaultZone: http://127.0.0.1:7995/eureka 服務使用 承上例註冊\n1 2 3 4 5 @Bean @LoadBalanced public RestTemplate restTemplate(){ return new RestTemplate(); } 修改呼叫的網域名稱為服務名稱\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 @Service public class OrderService { @Autowired private OrderMapper orderMapper; @Autowired private RestTemplate restTemplate; public Order queryOrderById(Long orderId) { // 1. 查詢訂單 Order order = orderMapper.findById(orderId); // 2. 查詢使用者 // String url = \u0026#34;http://localhost:8081/user/\u0026#34; + order.getUserId(); String url = \u0026#34;http://userService/user/\u0026#34; + order.getUserId(); User user = restTemplate.getForObject(url, User.class); // 3. 封裝使用者資訊 order.setUser(user); // 4. 回傳 return order; } } ","date":"2024-02-29T16:53:15+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/161/","title":"註冊中心 - Eureka"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 Golang 系列\nHello GoLang: https://blog.yexca.net/archives/154 GoLang (var and const) 變數與常數: https://blog.yexca.net/archives/155 GoLang (func) 函式: https://blog.yexca.net/archives/156 GoLang (slice and map) 切片: 本文\nGoLang (OOP) 物件導向: https://blog.yexca.net/archives/162 GoLang (reflect) 反射: https://blog.yexca.net/archives/204 GoLang (struct tag) 結構體標籤: https://blog.yexca.net/archives/205 GoLang (goroutine) Go 協程: https://blog.yexca.net/archives/206 GoLang (channel) 通道: https://blog.yexca.net/archives/207 Go 的切片 (Slice) 是對陣列 (Array) 的抽象\n陣列 陣列的長度不可改變\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package main import \u0026#34;fmt\u0026#34; func main() { // 定義方式一 var arr1 [10]int // 遍歷 for i := 0; i \u0026lt; len(arr1); i++ { fmt.Println(\u0026#34;arr1[\u0026#34;, i, \u0026#34;]:\u0026#34;, arr1[i]) } // 定義方式二，賦值 arr2 := [10]int{0, 1, 2, 3} // range 遍歷 for index, value := range arr2 { fmt.Println(\u0026#34;index =\u0026#34;, index, \u0026#34;value =\u0026#34;, value) } // 定義不同長度 var arr3 [4]int fmt.Printf(\u0026#34;type of arr1 is %T\\n\u0026#34;, arr1) // [10]int fmt.Printf(\u0026#34;type of arr1 is %T\\n\u0026#34;, arr2) // [10]int fmt.Printf(\u0026#34;type of arr1 is %T\u0026#34;, arr3) // [4]int } 編譯執行後可以發現 arr3 與 arr1, arr2 型別不同，那麼在定義函式形式參數時也需要指定相應型別\n1 2 3 4 5 func test(arr [4]int) { for i := 0; i \u0026lt; len(arr); i++ { fmt.Println(\u0026#34;fmt_arr[\u0026#34;, i, \u0026#34;]:\u0026#34;, arr[i]) } } 上述函式只能傳遞 arr3，且為值傳遞 (Pass by Value)，修改值不會影響原始資料\n定義切片 與陣列相比，切片長度不固定，可以追加元素 (動態陣列)，在追加時可能會使切片的容量增大\n定義切片可以透過宣告一個未指定大小的陣列\n1 2 3 var name []type // 例如 var s []int 或者使用 make() 函式來建立切片\n1 2 3 var slice []type = make([]type, len) // len 為切片初始長度 // 也可以簡寫為 slice := make([]type, len) 可以使用選用參數 capacity 指定容量，省略時與 length 相同\n1 var slice []type = make([]type, length, capacity) 切片初始化 直接初始化\n1 s := []int {1, 2, 3} 將陣列區間初始化為切片，從 startIndex 到 endIndex-1，這兩個值都可以省略\n1 s := arr[startIndex:endIndex] 省略 startIndex 或 endIndex 表示從第一個元素開始索引或索引到最後一個元素\nlen() 和 cap() 切片是可以透過索引存取的，透過 len() 函式獲取長度\n而 cap() 為計算容量的方法，可以測量切片最長可以達到多少\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package main import \u0026#34;fmt\u0026#34; // 切片傳遞為參考傳遞 (引用傳遞)，函式內修改會影響原始資料 func printSlice(slice []int) { fmt.Printf(\u0026#34;len=%d, cap=%d, slice=%v\u0026#34;, len(slice), cap(slice), slice) } func main() { s := make([]int, 3, 5) printSlice(s) } /* * 輸出 * len=3, cap=5, slice=[0 0 0] */ 空切片 一個切片在未初始化之前預設為 nil (空切片)，長度為 0\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package main import \u0026#34;fmt\u0026#34; func printSlice(slice []int) { fmt.Printf(\u0026#34;len=%d, cap=%d, slice=%v\\n\u0026#34;, len(slice), cap(slice), slice) } func main() { var s []int printSlice(s) // 判斷是否為空 if s == nil { fmt.Println(\u0026#34;slice is empty\u0026#34;) } } 切片截取 透過設定上下限截取切片\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package main import \u0026#34;fmt\u0026#34; func printSlice(slice []int) { fmt.Printf(\u0026#34;len=%d, cap=%d, slice=%v\\n\u0026#34;, len(slice), cap(slice), slice) } func main() { s := []int{0, 1, 2, 3, 4, 5, 6, 7} // 打印原始切片 fmt.Println(s) // 從 2 (包含) 到 5 (不包含) printSlice(s[2:5]) // 從第一個到 5 (不包含) printSlice(s[:5]) // 從第二個到最後一個 printSlice(s[2:]) // 這樣賦值修改 subS 將會影響到 s subS := s[1:6] printSlice(subS) } append() 和 copy() 增加切片的容量與複製切片\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package main import \u0026#34;fmt\u0026#34; func printSlice(slice []int) { fmt.Printf(\u0026#34;len=%d, cap=%d, slice=%v\\n\u0026#34;, len(slice), cap(slice), slice) } func main() { var s []int printSlice(s) // 增加一個元素 s = append(s, 0) printSlice(s) // 增加多個元素 s = append(s, 1, 2, 3, 4) printSlice(s) // 建立一個容量為 s 兩倍的 s2 s2 := make([]int, len(s), cap(s)*2) // 複製 s 到 s2，此時修改 s2 不影響 s copy(s2, s) printSlice(s2) } 切片的擴充：如果追加的值超過容量，則容量通常會增加為原來的兩倍\nmap map 有兩種宣告方式\n1 2 3 4 5 6 7 8 9 10 11 package main import \u0026#34;fmt\u0026#34; func main() { var map1 = make(map[string]string) // 插入資料 map1[\u0026#34;one\u0026#34;] = \u0026#34;1\u0026#34; map1[\u0026#34;two\u0026#34;] = \u0026#34;2\u0026#34; fmt.Println(map1) // map[one:1 two:2] } 第二種\n1 2 3 4 5 6 7 8 9 10 11 package main import \u0026#34;fmt\u0026#34; func main() { map1 := map[string]string{ \u0026#34;one\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;two\u0026#34;: \u0026#34;2\u0026#34;, } fmt.Println(map1) } map 巢狀 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package main import \u0026#34;fmt\u0026#34; func main() { map1 := make(map[string]map[string]string) map1[\u0026#34;first\u0026#34;] = make(map[string]string, 2) map1[\u0026#34;first\u0026#34;][\u0026#34;one\u0026#34;] = \u0026#34;1\u0026#34; map1[\u0026#34;first\u0026#34;][\u0026#34;two\u0026#34;] = \u0026#34;2\u0026#34; fmt.Println(map1) } /* * 輸出 * map[first:map[one:1 two:2]] */ 修改、遍歷與刪除 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package main import \u0026#34;fmt\u0026#34; func main() { map1 := make(map[string]map[string]string) map1[\u0026#34;first\u0026#34;] = make(map[string]string, 2) map1[\u0026#34;first\u0026#34;][\u0026#34;one\u0026#34;] = \u0026#34;1\u0026#34; map1[\u0026#34;first\u0026#34;][\u0026#34;two\u0026#34;] = \u0026#34;2\u0026#34; // 修改 map1[\u0026#34;first\u0026#34;][\u0026#34;one\u0026#34;] = \u0026#34;one\u0026#34; fmt.Println(map1) // 遍歷 for key, value := range map1{ fmt.Println(\u0026#34;key =\u0026#34;, key, \u0026#34;value =\u0026#34;, value) } // 刪除 delete(map1, \u0026#34;first\u0026#34;) fmt.Println(map1) } 判斷是否有某值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 package main import \u0026#34;fmt\u0026#34; func main() { map1 := make(map[string]string) map1[\u0026#34;one\u0026#34;] = \u0026#34;1\u0026#34; val, ok := map1[\u0026#34;one\u0026#34;] if ok { fmt.Println(val) } else { fmt.Println(\u0026#34;empty\u0026#34;) } } ","date":"2024-02-27T20:00:00+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/160/","title":"GoLang 切片"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 這篇文章還是有點久遠的，書寫習慣和現在不同，甚至看著有點不習慣\n透過 crontab 指令，我們可以在固定的間隔時間執行指定的系統指令或 shell script 腳本。時間間隔的單位可以是分鐘、小時、日、月、週及以上的任意組合。\n指令格式 1 crontab [-u user] file crontab [-u user] [ -e | -l | -r ] 指令參數 -u user：用來設定某個使用者的 crontab 服務。 file：file 是指令檔案的名稱，表示將 file 作為 crontab 的任務列表檔案並載入 crontab。如果在命令列中沒有指定這個檔案，crontab 指令將接受標準輸入（鍵盤）上鍵入的指令，並將它們載入 crontab。 -e：編輯某個使用者的 crontab 檔案內容。如果不指定使用者，則表示編輯目前使用者的 crontab 檔案。 -l：顯示某個使用者的 crontab 檔案內容，如果不指定使用者，則表示顯示目前使用者的 crontab 檔案內容。 -r：從 /var/spool/cron 目錄中刪除某個使用者的 crontab 檔案，如果不指定使用者，則預設刪除目前使用者的 crontab 檔案。 -i：在刪除使用者的 crontab 檔案時給予確認提示。 檔案格式 執行 crontab -e 指令後，會開啟目前使用者的 crontab 檔案，在這個檔案中，以 # 開頭的語句是註解語句。\n在 crontab 檔案中，透過 m h dom mon dow command 這六個欄位來設定排程任務，每一行對應一個排程任務。這六個欄位的含義說明如下：\nm：對應分鐘 (minute) 指定要在一小時之中的第幾分鐘執行該任務。取值範圍是 0-59。\nh：對應小時 (hour) 指定要在一天之中的第幾個小時執行該任務。取值範圍是 0-23。\ndom：對應日期 (day of month) 指定要在一月之中的第幾天執行該任務。取值範圍是 0-31。\nmon：對應月份 (month) 指定要在一年之中的第幾月執行該任務。取值範圍是 1-12。 也可以透過月份英文名稱的前三個字母來指定，不區分大小寫。例如，一月的英文單字是 january，那麼這裡可以用 jan 來指定一月。\ndow：對應星期幾 (day of week) 指定要在一週之中的星期幾執行該任務。取值範圍是 0-7，0 和 7 都對應星期天。 也可以透過星期英文名稱的前三個字母來指定，不區分大小寫。例如，星期一的英文單字是 monday，那麼這裡可以用 mon 來指定星期一。\ncommand：對應具體的操作\n提供具體的指令來指定進行什麼操作，可以提供腳本檔案的路徑來執行該腳本檔案。\n這六個欄位要求用空格隔開。且每個欄位都必須提供值，不能省略某個欄位的值。從第五個欄位之後的所有內容都屬於第六個欄位，也就是要執行的操作。\n前五個欄位可以使用下面的特殊字元來指定一些特殊的時間：\n星號（*）：代表所有可能的值，例如 month 欄位如果是星號，則表示在滿足其它欄位的制約條件後每月都執行該指令操作。 逗號（,）：可以用逗號隔開的值指定一個列表範圍，例如，\u0026ldquo;1,2,5,7,8,9\u0026rdquo;。 減號（-）：可以用整數之間的減號表示一個整數範圍，例如 \u0026ldquo;2-6\u0026rdquo; 表示 \u0026ldquo;2,3,4,5,6\u0026rdquo;。 正斜線（/）：可以用正斜線指定時間的間隔頻率，例如 \u0026ldquo;0-23/2\u0026rdquo; 表示每兩小時執行一次。同時正斜線可以和星號一起使用，例如 */10，如果用在 minute 欄位，表示每十分鐘執行一次。 在 command 欄位中，可以使用換行符號、或者 % 字元來分隔指令內容。\n在第一個 % 之前的內容會傳遞給 shell 來執行，這個 % 自身會被替換成換行符號，在 % 之後、直到行末的內容都作為標準輸入傳遞。\n如果需要提供 % 字元自身，需要用 \\% 進行跳脫。\n常用方法 向 cron 程序提交一個 crontab 檔案之前，首先要設定環境變數 EDITOR。cron 程序根據它來確定使用哪個編輯器編輯 crontab 檔案。\n由於預設使用 nano 編輯器不是特別好用，可以改為 vi，透過編輯 $HOME 目錄下的 .profile 檔案，在其中加入這樣一行：\n1 EDITOR=vi; export EDITOR 然後儲存並退出。不妨建立一個名為 \u0026lt;user\u0026gt;cron 的檔案，其中 \u0026lt;user\u0026gt; 是使用者名稱，例如 yexcacron。在該檔案中加入要定時執行的內容，例如：\n1 2 3 # (put your own initials here)echo the date to the console every # 15minutes between 6pm and 6am 0,15,30,45 18-06 * * * /bin/echo \u0026#39;date\u0026#39; \u0026gt; /dev/console 在上面的例子中，系統將每隔 15 分鐘向主控台輸出一次目前時間。如果系統當機或停止回應，從最後所顯示的時間就可以一眼看出系統是什麼時間停止運作的。在有些系統中，用 tty1 來表示主控台，可以根據實際情況對上面的例子進行相應的修改。為了提交你剛剛建立的 crontab 檔案，可以把這個新建立的檔案作為 cron 指令的參數：\n1 crontab yexcacron 現在該檔案已經提交給 cron 程序，它將每隔 15 分鐘執行一次。同時，新建立檔案的一個複本已經被放在 /var/spool/cron 目錄中，檔名就是使用者名稱 (即 yexca)。\n執行腳本 如果執行腳本需要使用變數：\n1 30 6 * * * . /etc/profile;/bin/sh /root/zfile/bin/restart.sh 以上為每日 6:30 執行 zfile 的 restart.sh。\n參考文章 crontab 定時任務 — Linux Tools Quick Tutorial Linux技巧：介紹設置定時週期執行任務的方法 - SegmentFault 思否 Linux命令之Crontab——定時任務 - SegmentFault 思否 nano編輯器使用教程 - VPS偵探 Linux vi/vim - 菜鳥教程 ","date":"2024-02-26T21:34:15+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/159/","title":"Linux 排程任務 crontab"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 服務架構 單體架構 將業務的所有功能集中在一個專案中開發，並打包成一個檔案進行部署。\n優點：架構簡單、部署成本低，適合小型專案。\n缺點：耦合度高、擴充性差。\n分散式架構 根據業務功能對系統進行拆分，每個業務模組作為獨立專案開發，稱為一個服務。\n優點：降低服務耦合、有利於服務升級拓展。\n缺點：架構複雜、難度大，適合大型網際網路專案。\n微服務 微服務是一種經過良好架構設計的分散式架構方案，微服務架構特徵：\n單一職責 ：微服務拆分粒度更小，每一個服務都對應唯一的業務能力，做到單一職責，避免重複業務開發。 面向服務：微服務對外暴露業務介面。 自治：團隊獨立、技術獨立、數據獨立、部署獨立。 隔離性強：服務呼叫做好隔離、容錯、降級，避免出現連鎖問題。 微服務技術 微服務方案需要技術框架實作，常見的如下：\nDubbo SpringCloud SpringCloudAlibaba 註冊中心 zookeeper、 Redis Eureka、 Consul Nacos、 Eureka 服務遠端呼叫 Dubbo 協定 Feign (http 協定) Dubbo、Feign 配置中心 無 SpringCloudConfig SpringCloudConfig、 Nacos 服務網關 無 SpringCloudGateway、 Zuul SpringCloudGateway、 Zuul 服務監控與保護 dubbo-admin，功能弱 Hystix Sentinel 微服務需要根據業務模組拆分：\n單一職責：不同微服務，不要重複開發相同業務。 數據獨立：不要存取其他微服務的資料庫。 面向服務：將自己的業務暴露為介面，供其他微服務呼叫。 SpringCloud SpringCloud 是目前使用最廣泛的微服務框架。它整合了各種微服務功能組件，並基於 SpringBoot 實作了這些組件的自動裝配。\n官網： https://spring.io/projects/spring-cloud/ 服務註冊發現：Eureka、Nacos、Consul 統一配置管理：SpringCloudConfig、Nacos 服務遠端呼叫：OpenFeign、Dubbo 統一網關路由：SpringCloudGateway、Zuul 服務鏈路監控：Zipkin、Sleuth 流控、降級、保護：Hystix、Sentinel 微服務呼叫 需求：根據訂單 id 查詢訂單的同時，把訂單所屬的使用者資訊一起回傳。\n註冊 RestTemplate 1 2 3 4 @Bean public RestTemplate restTemplate(){ return new RestTemplate(); } 服務遠端呼叫 RestTemplate 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 @Service public class OrderService { @Autowired private OrderMapper orderMapper; @Autowired private RestTemplate restTemplate; public Order queryOrderById(Long orderId) { // 1. 查詢訂單 Order order = orderMapper.findById(orderId); // 2. 查詢使用者 String url = \u0026#34;http://localhost:8081/user/\u0026#34; + order.getUserId(); // RestTemplate 的 GET 方法 User user = restTemplate.getForObject(url, User.class); // 3. 封裝使用者資訊 order.setUser(user); // 4. 回傳 return order; } } ","date":"2024-02-25T17:56:54+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/158/","title":"Hi SpringCloud"},{"content":" 該文章使用 Google 翻譯處理。\nRedis 是一個基於記憶體的鍵值結構資料庫，是互聯網技術領域使用廣泛的儲存中間件\n官網： https://redis.io 簡體中文網： https://www.redis.net.cn/ Redis 基於記憶體存儲，讀寫效能高，適合儲存熱點資料 (商品、資訊、新聞) 。是用 C 語言開發的一個開源的高效能鍵值對資料庫，儲存 value 類型比較豐富，也被稱為結構化的 NoSql (Not Only SQL) 資料庫\nNoSql 泛指非關係型資料庫，不是要取代關係型資料庫，而是關係型資料庫的補充\n關係型資料庫 (RDBMS)：\nMySQL Oracle DB2 SQLServer 非關係型資料庫 (NoSQL)：\nRedis Mongo DB MemCached Redis 下載安裝與執行 下載地址：\nWindows: https://github.com/microsoftarchive/redis/releases Linux: https://download.redis.io/releases/ cn: http://www.redis.cn/download.html Windows 版直接解壓縮即可使用，Linux 版：\n解壓縮 tar -zxvf redis-4.0.0.tar.gz -C /usr/local 安裝依賴環境 yum install gcc-c++ 進入安裝目錄，編譯 make 進入 redis 的 src 目錄安裝 make install 相關文件說明：\n/usr/local/redis-4.0.0/src/redis-server：Redis 服務啟動腳本 /usr/local/redis-4.0.0/src/redis-cli：Redis 客戶端腳本 /usr/local/redis-4.0.0/redis.conf：Redis 設定檔 服務端啟動，以 Windows 版為例，啟動命令：\n1 redis-server.exe redis.windows.conf 默認端口號為 6379，默認無密碼，啟動完成後可以用客戶端連接\n命令行連接 通過 redis-cli.exe 進行連接\n1 redis-cli.exe -h ip -p port -a password 如果省略，則使用 127.0.0.1:6379\n可以通過修改配置文件 (redis.windows.conf) 設置密碼\n1 requirepass 123456 修改完成後重啟生效\n圖形化連接 Github： https://github.com/qishibo/AnotherRedisDesktopManager 下載安裝後新建連接，輸入相關信息後連接即可\nDocker 部署 拉取鏡像\n1 docker pull redis 獲取配置文件，下載對應版本，抽取配置文件即可，Linux 為 redis.conf\n創建 Redis 數據映射文件夾，例如\n1 2 mkdir /home/redis mkdir /home/redis/data 修改配置文件，傳送至部署機子，例如使用 scp 從 Win 傳至 Linux\n1 scp pathOfFile root@IP:/PathOfFile 啟動\n1 docker run -p 6379:6379 --name redis -v /home/redis/redis.conf:/etc/redis/redis.conf -v /home/redis/data:/data -d redis redis-server /etc/redis/redis.conf 參考資料： https://cloud.tencent.com/developer/article/1670205 Redis 數據類型 Redis 的 key 是字符串類型，value 有 5 種常用的數據類型\n字串 (string)：普通字串 哈希 (hash)：也叫散列 清單 (list)：依插入順序排序，可以有重複元素 集合 (set)：無序集合，不允許重複元素 有序集合 (sorted set/zset)：集合中每個元素關聯一個分數 (score)，根據分數升序排序 Redis 常用命令 Redis 大小寫不敏感\n字符串操作常用命令：\n1 2 3 4 5 6 7 8 # 設置指定 key 值 SET key value # 獲取指定 key 值 GET key # 設置指定 key 值，並將 key 的過期時間設為 seconds 秒 SETEX key seconds value # 只在 key 不存在時才設置 key 的值 SETNX key value hash 是一個 string 類型的 field 和 value 映射表，特別適合存儲對象，常用命令：\n1 2 3 4 5 6 7 8 9 10 # 將哈希表 key 中的 field 值設為 value HSET key field value # 取得儲存在哈希表中指定欄位的值 HGET key field # 刪除儲存在哈希表中的指定字段 HDEL key field # 獲取哈希表中所有字段 HKEYS key # 獲取哈希表中所有值 HVALS key 列表是簡單的字符串列表，按照插入順序排列，常用命令：\n1 2 3 4 5 6 7 8 9 10 11 # 將一個或多個值插入到清單頭部 LPUSH key value1 [value2] # 取得清單指定範圍內的元素 LRANGE key start stop # 移除並取得清單最後一個元素 RPOP key # 取得清單長度 LLEN key # 移出並取得清單的最後一個元素 # 如果清單沒有元素會阻塞清單直到等待逾時或發現可彈出元素為止 BRPOP key1 [key2] timeout 類似隊列，先進先出\n集合是字串型別的無序集合，集合成員唯一，常用指令：\n1 2 3 4 5 6 7 8 9 10 11 12 # 在集合中新增一個或多個成員 SADD key member1 [member2] # 傳回集合中的所有成員 SMEMBERS key # 取得集合的成員數 SCARD key # 傳回給定所有集合的交集 SINTER key2 [key2] # 傳回所有給定集合的並集 SUNION key1 [key2] # 移除集合中一個或多個成員 SREM key member1 [member2] 有序集合是字符串類型元素的集合，每個成員關聯一個 double 類型的分數，常用命令：\n1 2 3 4 5 6 7 8 # 在有序集合中新增一個或多個成員 ZADD key score1 member1 [score2 member2] # 透過索引區間傳回有序集合中指定區間內的成員 ZRANGE key start stop [WITHSCORES] # 有序集合中對指定成員的分數加上增量increment ZINCRBY key increment member # 移除有序集合中的一個或多個成員 ZREM key member1 [member2] 除了各數據類型專有，還有通用命令，即所有類型都可以使用的命令：\n1 2 3 4 5 6 7 8 # 尋找所有符合給定模式(pattern)的key KEYS pattern # pattern可以為* # 檢查指定key是否存在 EXISTS key # 傳回key所儲存的值的類型 TYPE key # 在key存在時刪除key DEL key 在 Java 中操作 Redis 如同使用 JDBC 操作 MySQL 資料庫一樣，需要使用 Redis 的 Java 用戶端進行操作 Redis\nRedis 的 Java 客戶端很多，常用的幾種：\nJedis Lettuce Spring Data Redis Jedis 封裝最好，與Redis 命令相同，是官方推薦；Lettuce 對線程呼叫更好，性能更好；Spring 對Redis 客戶端進行了整合，提供了Spring Data Redis，在Spring Boot 專案中還提供了對應的Starter，即spring-boot-starter-data-redis\nspring data Redis Spring Data Redis 是 Spring 的一部分，提供了在 Spring 應用中透過簡單的配置就可以存取 Redis 服務，對 Redis 底層開發包進行了高度封裝。在 Spring 專案中，可以使用Spring Data Redis來簡化 Redis 操作。網址： https://spring.io/projects/spring-data-redis Maven 座標：\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-data-redis\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; Spring Data Redis 中提供了一個高度封裝類 RedisTemplate 對相關 api 進行了歸類封裝，將同一類型的操作封裝為 operation 接口：\nValueOperations：string 資料操作 SetOperations：set 類型資料操作 ZSetOperations：zset 類型資料操作 HashOperations：hash 類型的資料操作 ListOperations：list 類型的資料操作 配置 Redis 資料來源，設定文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # application spring: profiles: active: dev redis: host: ${sky.redis.host} port: ${sky.redis.port} password: ${sky.redis.password} database: ${sky.redis.database} # -dev sky: redis: host: localhost port: 6379 password: 123456 # 使用哪個資料庫，不填預設為 0 database: 10 Redis 預設有 16 個資料庫 (0-15)，可以透過修改設定檔來指定資料庫的數量\n編寫配置類，建立 RedisTemplate 對象\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 @Configuration @Slf4j public class RedisConfiguration { @Bean public RedisTemplate redisTemplate(RedisConnectionFactory redisConnectionFactory){ log.info(\u0026#34;開始創建 Redis 對象\u0026#34;); RedisTemplate redisTemplate = new RedisTemplate(); // 設定 redis 的連接工廠對象 redisTemplate.setConnectionFactory(redisConnectionFactory); // 設定 redis key 的序列化器 redisTemplate.setKeySerializer(new StringRedisSerializer()); return redisTemplate; } } 此配置類別不是必須的，SpringBoot 框架會自動組裝 RedisTemplate 對象，不過預設的序列化器為 JdkSerializationRedisSerializer，儲存到 Redis 中的資料與原始資料有差別\n字串類型數據 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @SpringBootTest public class RedisTest { @Autowired private RedisTemplate redisTemplate; @Test public void testString(){ // set redisTemplate.opsForValue().set(\u0026#34;name\u0026#34;, \u0026#34;Tom\u0026#34;); // get String name =(String) redisTemplate.opsForValue().get(\u0026#34;name\u0026#34;); System.out.println(name); // setex redisTemplate.opsForValue().set(\u0026#34;code\u0026#34;, \u0026#34;1234\u0026#34;, 2, TimeUnit.MINUTES); // setnx redisTemplate.opsForValue().setIfAbsent(\u0026#34;lock\u0026#34;,\u0026#34;1\u0026#34;); redisTemplate.opsForValue().setIfAbsent(\u0026#34;lock\u0026#34;,\u0026#34;2\u0026#34;); } } 哈希類型數據 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @Test public void testHash(){ HashOperations hashOperations = redisTemplate.opsForHash(); // hset hashOperations.put(\u0026#34;100\u0026#34;, \u0026#34;name\u0026#34;, \u0026#34;Jerry\u0026#34;); hashOperations.put(\u0026#34;100\u0026#34;, \u0026#34;age\u0026#34;, \u0026#34;20\u0026#34;); // hget String name =(String) hashOperations.get(\u0026#34;100\u0026#34;, \u0026#34;name\u0026#34;); System.out.println(name); // hkeys Set keys = hashOperations.keys(\u0026#34;100\u0026#34;); System.out.println(keys); // hvals List values = hashOperations.values(\u0026#34;100\u0026#34;); System.out.println(values); // hdel hashOperations.delete(\u0026#34;100\u0026#34;, \u0026#34;name\u0026#34;); } 列表類型數據 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Test public void testList(){ ListOperations listOperations = redisTemplate.opsForList(); // lpush listOperations.leftPushAll(\u0026#34;mylist\u0026#34;, \u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;); listOperations.leftPush(\u0026#34;mylist\u0026#34;, \u0026#34;d\u0026#34;); // lrange List mylist = listOperations.range(\u0026#34;mylist\u0026#34;, 0, -1); System.out.println(mylist); // rpop listOperations.rightPop(\u0026#34;mylist\u0026#34;); // llen Long size = listOperations.size(\u0026#34;mylist\u0026#34;); System.out.println(size); } 集合類型數據 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 @Test public void testSet(){ SetOperations setOperations = redisTemplate.opsForSet(); // sadd setOperations.add(\u0026#34;set1\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;,\u0026#34;c\u0026#34;,\u0026#34;d\u0026#34;); setOperations.add(\u0026#34;set2\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;,\u0026#34;x\u0026#34;,\u0026#34;y\u0026#34;); // smembers Set members = setOperations.members(\u0026#34;set1\u0026#34;); System.out.println(members); // scard Long size = setOperations.size(\u0026#34;set1\u0026#34;); System.out.println(size); // sinter Set intersect = setOperations.intersect(\u0026#34;set1\u0026#34;, \u0026#34;set2\u0026#34;); System.out.println(intersect); // sunion Set union = setOperations.union(\u0026#34;set1\u0026#34;, \u0026#34;set2\u0026#34;); System.out.println(union); // srem setOperations.remove(\u0026#34;set1\u0026#34;, \u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;); } 有序集合類型數據 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Test public void testZset(){ ZSetOperations zSetOperations = redisTemplate.opsForZSet(); // zadd zSetOperations.add(\u0026#34;zset1\u0026#34;, \u0026#34;a\u0026#34;, 10); zSetOperations.add(\u0026#34;zset1\u0026#34;, \u0026#34;b\u0026#34;, 12); zSetOperations.add(\u0026#34;zset1\u0026#34;, \u0026#34;c\u0026#34;, 9); // zrange Set zset = zSetOperations.range(\u0026#34;zset1\u0026#34;, 0, -1); System.out.println(zset); // zincrby zSetOperations.incrementScore(\u0026#34;zset1\u0026#34;, \u0026#34;c\u0026#34;, 10); // zrem zSetOperations.remove(\u0026#34;zset1\u0026#34;, \u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;); } 通用命令操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @Test public void testCommon(){ // keys Set keys = redisTemplate.keys(\u0026#34;*\u0026#34;); System.out.println(keys); // exists Boolean name = redisTemplate.hasKey(\u0026#34;name\u0026#34;); System.out.println(name); // type for (Object key : keys) { DataType type = redisTemplate.type(key); System.out.println(type.name()); } // del redisTemplate.delete(\u0026#34;set2\u0026#34;); } ","date":"2024-02-23T16:40:34+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/157/","title":"Redis"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 Golang 系列\nHello GoLang: https://blog.yexca.net/archives/154 GoLang (var and const) 變數與常數: https://blog.yexca.net/archives/155 GoLang (func) 函式: 本文\nGoLang (slice and map) 切片: https://blog.yexca.net/archives/160 GoLang (OOP) 物件導向: https://blog.yexca.net/archives/162 GoLang (reflect) 反射: https://blog.yexca.net/archives/204 GoLang (struct tag) 結構體標籤: https://blog.yexca.net/archives/205 GoLang (goroutine) Goroutine: https://blog.yexca.net/archives/206 GoLang (channel) 通道: https://blog.yexca.net/archives/207 多個回傳值 Go 函式可以回傳多個值\n匿名回傳 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package main import \u0026#34;fmt\u0026#34; func swap(a, b int) (int, int) { return b, a } func main() { var x, y = swap(10, 20) fmt.Println(x, y) } /* 輸出 * 20 10 */ 具名回傳 1 2 3 4 5 6 7 8 9 10 11 12 13 14 package main import \u0026#34;fmt\u0026#34; func swap(a, b int) (x int, y int) { x = b y = a return } func main() { var x, y = swap(10, 20) fmt.Println(x, y) } 上述回傳值型別相同，可以合併\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package main import \u0026#34;fmt\u0026#34; func swap(a, b int) (x, y int) { x = b y = a // 如果不給 x,y 賦值，預設為 0 return } func main() { var x, y = swap(10, 20) fmt.Println(x, y) } init 與 main init 可以在任何套件中，也可以在同一個套件中出現多次，但建議只寫一個。\nmain 只能在 package main 中，且該套件必須有該函式。\n這兩個函式為保留函式，定義時不能有參數和回傳值。\nGo 程式會自動呼叫 init() 和 main()。\n程式執行 程式的初始化和執行都起始於 main 套件，同一個套件就算被多個套件 import 匯入也只會匯入一次，下圖為執行順序：\n例子\n假設結構如下：\n1 2 3 4 5 6 hello -- InitLib1 -- lib1.go -- InitLib2 -- lib2.go main.go 內容如下：\nlib1.go\n1 2 3 4 5 6 7 package InitLib1 import \u0026#34;fmt\u0026#34; func init() { fmt.Println(\u0026#34;lib1 init\u0026#34;) } lib2.go\n1 2 3 4 5 6 7 package InitLib2 import \u0026#34;fmt\u0026#34; func init() { fmt.Println(\u0026#34;lib2 init\u0026#34;) } main.go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package main import ( \u0026#34;fmt\u0026#34; // 此處底線為套件起別名，不給別名且匯入後不呼叫，編譯不會通過 _ \u0026#34;hello/InitLib1\u0026#34; _ \u0026#34;hello/InitLib2\u0026#34; ) func init() { fmt.Println(\u0026#34;main init\u0026#34;) } func main() { fmt.Println(\u0026#34;main\u0026#34;) } 執行結果：\n1 2 3 4 lib1 init lib2 init main init main 現在將 Lib1 套件匯入 Lib2，main 程式碼不變。\nlib1.go\n1 2 3 4 5 6 7 8 9 10 package InitLib1 import ( \u0026#34;fmt\u0026#34; _ \u0026#34;hello/InitLib2\u0026#34; ) func init() { fmt.Println(\u0026#34;lib1 init\u0026#34;) } 執行 main 結果：\n1 2 3 4 lib2 init lib1 init main init main lib2 只出現一次。\n呼叫其他套件函式 上例使用 _ 作為別名是匿名的，無法呼叫相應套件的方法。\n在 lib1 中增加函式：\nlib1.go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package InitLib1 import ( \u0026#34;fmt\u0026#34; //_ \u0026#34;hello/InitLib2\u0026#34; ) // 首字母大寫才可在其他套件呼叫 func Lib1Test() { fmt.Println(\u0026#34;lib1 test\u0026#34;) } func init() { fmt.Println(\u0026#34;lib1 init\u0026#34;) } main.go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package main import ( \u0026#34;fmt\u0026#34; // 給套件起別名 mylib1 \u0026#34;hello/InitLib1\u0026#34; _ \u0026#34;hello/InitLib2\u0026#34; ) func main() { // 透過 別名.方法 呼叫 mylib1.Lib1Test() fmt.Println(\u0026#34;main\u0026#34;) } /* * 輸出 * lib1 init * lib2 init * lib1 test * main */ 或者可以直接使用 .，檔案 main.go：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 package main import ( \u0026#34;fmt\u0026#34; // 別名改為 . . \u0026#34;hello/InitLib1\u0026#34; _ \u0026#34;hello/InitLib2\u0026#34; ) func main() { // 直接使用 Lib1Test() fmt.Println(\u0026#34;main\u0026#34;) } 不推薦使用，假設兩個套件有同名函式，將會產生歧義。\n指標 與 C 指標類似。\n呼叫函式可以使用兩種方式傳遞參數：值傳遞與指標（引用傳遞/傳址）。預設情況使用值傳遞，如本文第一段程式碼即為值傳遞。\n使用 \u0026amp; 可以獲取變數對應的記憶體位址。\n1 2 3 4 5 6 7 8 9 10 package main import ( \u0026#34;fmt\u0026#34; ) func main() { var a int fmt.Printf(\u0026#34;%x\u0026#34;, \u0026amp;a) } 傳址將記憶體位址傳遞給函式，函式修改將影響實際參數。同樣是交換函式，這次使用指標：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package main import \u0026#34;fmt\u0026#34; func swap(a, b *int) { var tmp = *a *a = *b *b = tmp } func main() { x, y := 10, 20 swap(\u0026amp;x, \u0026amp;y) fmt.Println(\u0026#34;x =\u0026#34;, x, \u0026#34;y =\u0026#34;, y) } defer defer 語句用於預定對一個函式的呼叫，可以稱為延遲函式，作用：\n釋放佔用的資源 捕捉處理異常 輸出日誌 類似於 try\u0026hellip;catch\u0026hellip;finally 的 finally。\n常用於處理成對的操作，如打開/關閉檔案、獲取/釋放鎖、連接/斷開連接等，確保資源被適當釋放，即使在發生錯誤或提前返回的情況下也能保證執行。\n如果一個函式中有多個 defer 語句，類似於堆疊（Stack），以 LIFO（後進先出）順序執行。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package main import \u0026#34;fmt\u0026#34; func deferDemo() { defer fmt.Println(\u0026#34;1\u0026#34;) defer fmt.Println(\u0026#34;2\u0026#34;) defer fmt.Println(\u0026#34;3\u0026#34;) defer fmt.Println(\u0026#34;4\u0026#34;) } func main() { deferDemo() } /* * 輸出 * 4 * 3 * 2 * 1 */ recover 執行時 panic 異常一旦被引發就會導致程式崩潰，recover 為用於「攔截」執行時 panic 的內建函式，類似 Java 的 try\u0026hellip;catch 的抓取異常。\nrecover 只有在 defer 呼叫的函式中有效。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 package main import \u0026#34;fmt\u0026#34; func deferDemo(i int) { var arr [10]int // 錯誤攔截在錯誤發生前設置 defer func() { // 設置 recover 攔截錯誤資訊 err := recover() if err != nil { fmt.Println(err) } }() arr[i] = 10 } func main() { deferDemo(10) fmt.Println(\u0026#34;main code\u0026#34;) } /* * 輸出 * runtime error: index out of range [10] with length 10 * main code */ ","date":"2024-02-22T04:47:28+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/156/","title":"GoLang 函式"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 Golang 系列\nHello GoLang: https://blog.yexca.net/archives/154 GoLang (var and const) 變數與常數: 本文\nGoLang (func) 函式: https://blog.yexca.net/archives/156 GoLang (slice and map) 切片: https://blog.yexca.net/archives/160 GoLang (OOP) 物件導向: https://blog.yexca.net/archives/162 GoLang (reflect) 反射: https://blog.yexca.net/archives/204 GoLang (struct tag) 結構體標籤: https://blog.yexca.net/archives/205 GoLang (goroutine) Goroutine: https://blog.yexca.net/archives/206 GoLang (channel) 通道: https://blog.yexca.net/archives/207 變數 宣告變數一般使用 var 關鍵字\n單一變數 定義型別 不指定初始值的宣告，預設為 0\n1 2 3 4 5 6 7 8 package main import \u0026#34;fmt\u0026#34; func main() { var a int fmt.Println(\u0026#34;a =\u0026#34;, a) } 指定初始值，a 為 100\n1 2 3 4 5 6 7 8 package main import \u0026#34;fmt\u0026#34; func main() { var a int = 100 fmt.Println(\u0026#34;a =\u0026#34;, a) } 省略型別 在宣告時不指定型別的話，Go 會自動推導變數型別\n1 2 3 4 5 6 7 8 9 10 11 12 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) func main() { var a = 100 fmt.Println(\u0026#34;a =\u0026#34;, a) fmt.Printf(\u0026#34;Type of a = %s\u0026#34;, reflect.TypeOf(a)) } := 基於省略型別會自動推導，可以使用 := 直接宣告變數\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) func main() { p := 3.14 fmt.Println(\u0026#34;p =\u0026#34;, p) fmt.Printf(\u0026#34;Type of p is %s\u0026#34;, reflect.TypeOf(p)) } /* * 輸出 * p = 3.14 * Type of p is float64 */ 多重變數 相同型別 1 2 3 4 5 6 7 8 9 package main import \u0026#34;fmt\u0026#34; func main() { var a, b int fmt.Println(\u0026#34;a =\u0026#34;, a) fmt.Println(\u0026#34;b =\u0026#34;, b) } 相同型別賦值 1 2 3 4 5 6 7 8 9 package main import \u0026#34;fmt\u0026#34; func main() { var a, b int = 100, 200 fmt.Println(\u0026#34;a =\u0026#34;, a) fmt.Println(\u0026#34;b =\u0026#34;, b) } 不同型別 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) func main() { var a, b = 100, 3.14 fmt.Println(\u0026#34;a =\u0026#34;, a) fmt.Printf(\u0026#34;Type of a is %s\\n\u0026#34;, reflect.TypeOf(a)) fmt.Println(\u0026#34;b =\u0026#34;, b) fmt.Printf(\u0026#34;Type of b is %s\u0026#34;, reflect.TypeOf(b)) } /* * 輸出 * a = 100 * Type of a is int * b = 3.14 * Type of b is float64 */ 不同型別 2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) func main() { a, b := 100, \u0026#34;Hello\u0026#34; fmt.Println(\u0026#34;a =\u0026#34;, a) fmt.Printf(\u0026#34;Type of a is %s\\n\u0026#34;, reflect.TypeOf(a)) fmt.Println(\u0026#34;b =\u0026#34;, b) fmt.Printf(\u0026#34;Type of b is %s\u0026#34;, reflect.TypeOf(b)) } 字串型別在 Go 裡面是一個結構，包含指向底層陣列的指標和長度，這兩部分各佔 8 個位元組，所以字串型別大小為 16 個位元組\n可以使用 unsafe.Sizeof() 函式查看型別佔用空間\n全局變數 全局變數的宣告不能使用 :=\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) var a, b int func main() { fmt.Println(\u0026#34;a =\u0026#34;, a) fmt.Printf(\u0026#34;Type of a is %s\\n\u0026#34;, reflect.TypeOf(a)) fmt.Println(\u0026#34;b =\u0026#34;, b) fmt.Printf(\u0026#34;Type of b is %s\u0026#34;, reflect.TypeOf(b)) } 或者使用分解的寫法，這種寫法一般用於全局變數\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) var ( a int = 1 b string = \u0026#34;Go\u0026#34; ) func main() { fmt.Println(\u0026#34;a =\u0026#34;, a) fmt.Printf(\u0026#34;Type of a is %s\\n\u0026#34;, reflect.TypeOf(a)) fmt.Println(\u0026#34;b =\u0026#34;, b) fmt.Printf(\u0026#34;Type of b is %s\u0026#34;, reflect.TypeOf(b)) } 常數 常數一般用 const 關鍵字定義\n定義 1 2 3 4 5 6 7 8 package main import \u0026#34;fmt\u0026#34; func main() { const c int = 9 fmt.Println(\u0026#34;c = \u0026#34;, c) } 也可以省略型別\n1 2 3 4 5 6 7 8 package main import \u0026#34;fmt\u0026#34; func main() { const c = 9 fmt.Println(\u0026#34;c = \u0026#34;, c) } 列舉 常數定義可用於列舉\n1 2 3 4 5 6 7 8 9 package main func main() { const ( BEIJING = 0 SHANGHAI = 1 SHENZHEN = 2 ) } iota 自增 上述列舉以 0 開始遞增，可以使用 iota 代替\n1 2 3 4 5 6 7 8 9 10 11 12 13 package main import \u0026#34;fmt\u0026#34; func main() { const ( BEIJING = iota // 0 SHANGHAI // 1 SHENZHEN // 2 ) fmt.Println(BEIJING, SHANGHAI, SHENZHEN) } iota 可以用於運算式，但一般用於自增\n","date":"2024-02-20T06:41:18+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/155/","title":"GoLang 變數與常數"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 Golang 系列\nHello GoLang: 本文\nGoLang (var and const) 變數與常數: https://blog.yexca.net/archives/155 GoLang (func) 函式: https://blog.yexca.net/archives/156 GoLang (slice and map) 切片: https://blog.yexca.net/archives/160 GoLang (OOP) 物件導向: https://blog.yexca.net/archives/162 GoLang (reflect) 反射: https://blog.yexca.net/archives/204 GoLang (struct tag) 結構體標籤: https://blog.yexca.net/archives/205 GoLang (goroutine) Go 協程: https://blog.yexca.net/archives/206 GoLang (channel) 通道: https://blog.yexca.net/archives/207 Go 下載： https://go.dev/dl/ JetBrains GoLand： https://www.jetbrains.com/go/ Go 簡介 Go 可以直接編譯，直接執行即可部署，靜態型別語言\n1 2 3 4 5 6 7 # 直接執行 go run hello.go # 編譯 go build hello.go # 編譯後執行 ./hello Go 的一些應用\n(1)、雲端運算基礎建設領域\n代表專案：docker、kubernetes、etcd、consul、cloudflare CDN、七牛雲儲存等\n(2)、基礎後端軟體\n代表專案：tidb、influxdb、cockroachdb 等\n(3)、微服務\n代表專案：go-kit、micro、monzo bank的typhon、bilibili 等\n(4)、網際網路基礎建設\n代表專案：以太坊、hyperledger 等\nHello Go 1 2 3 4 5 6 7 8 9 10 11 package main // 定義套件名稱 /* * 必須在原始碼檔案非註解的第一行指明檔案屬於哪個套件 * main 表示一個可獨立執行的程式，每個 Go 應用程式都包含一個名為 main 的套件 */ import \u0026#34;fmt\u0026#34; // 匯入 fmt 套件，實作了格式化 IO 的函式 func main(){ // 函式 fmt.println(\u0026#34;Hello Go\u0026#34;) } 一般 main 函式是啟動後第一個執行的函式，如果有 init 函式會先執行 init 函式\n定義函式時，{ 必須與函式名稱在同一行\n","date":"2024-02-19T07:58:37+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/154/","title":"Hello GoLang"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 新年快樂！\n流程： https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/login.html 前端取得授權碼，向 https://api.weixin.qq.com/sns/jscode2session 發起請求，取得 session_key 與 openid\n微信請求介面： https://developers.weixin.qq.com/miniprogram/dev/OpenApiDoc/user-login/code2Session.html 分析設計 介面設計 請求路徑：/user/user/login\n請求方式：POST\n請求參數：code String (微信使用者授權碼)\n回傳資料：\nid integer (使用者 ID) openid (微信 openid) token (jwt 令牌) 資料庫表格設計 使用者第一次使用小程序會自動註冊，將相關資訊儲存到 user 表格\n欄位名稱 資料類型 說明 id bigint 主鍵，自動遞增 openid varchar(45) 微信使用者唯一識別碼 name varchar(32) 使用者姓名 phone varchar(11) 手機號碼 gender varchar(2) 性別 id_number varchar(18) 身分證字號 avatar varchar(500) 微信使用者頭像路徑 create_time datetime 註冊時間 以個人身分註冊的小程式沒有權限取得微信使用者的手機號碼\n程式配置 首先配置微信登入所需參數\napplication-dev.yml\n1 2 3 4 sky: wechat: appid: your_appid secret: your_secret application.yml\n1 2 3 4 sky: wechat: appid: ${sky.wechat.appid} secret: ${sky.wechat.secret} 配置為微信使用者產生 jwt 令牌時使用的配置項目\n1 2 3 4 5 6 sky: jwt: # 使用者相關 user-secret-key: key user-ttl: 7200000 user-token-name: authentication Java 業務程式碼 controller\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 @RestController @RequestMapping(\u0026#34;/user/user\u0026#34;) @Api(tags = \u0026#34;使用者相關介面\u0026#34;) @Slf4j public class UserController { @Autowired private UserService userService; @Autowired private JwtProperties jwtProperties; @PostMapping(\u0026#34;/login\u0026#34;) @ApiOperation(\u0026#34;微信登入\u0026#34;) public Result\u0026lt;UserLoginVO\u0026gt; login(@RequestBody UserLoginDTO userLoginDTO){ log.info(\u0026#34;微信使用者登入：{}\u0026#34;, userLoginDTO.getCode()); // 微信登入 User user = userService.wxlogin(userLoginDTO); // 為微信使用者產生jwt令牌 HashMap\u0026lt;String, Object\u0026gt; claims = new HashMap\u0026lt;\u0026gt;(); claims.put(JwtClaimsConstant.USER_ID, user.getId()); String token = JwtUtil.createJWT(jwtProperties.getUserSecretKey(), jwtProperties.getUserTtl(), claims); UserLoginVO userLoginVO = UserLoginVO.builder() .id(user.getId()) .openid(user.getOpenid()) .token(token) .build(); return Result.success(userLoginVO); } } service\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 @Service @Slf4j public class UserServiceImpl implements UserService { // 微信介面 public static final String WX_LOGIN = \u0026#34;https://api.weixin.qq.com/sns/jscode2session\u0026#34;; @Autowired private WeChatProperties weChatProperties; @Autowired private UserMapper userMapper; @Override public User wxlogin(UserLoginDTO userLoginDTO) { String openid = getOpenid(userLoginDTO.getCode()); // 判斷openid是否合法 if (openid == null){ throw new LoginFailedException(MessageConstant.LOGIN_FAILED); } // 判斷是否為新使用者 User user = userMapper.getByOpenid(openid); // 若為新使用者，自動註冊 if (user == null){ user = User.builder() .openid(openid) .createTime(LocalDateTime.now()) .build(); userMapper.insert(user); } return user; } // 呼叫微信介面，取得使用者openid private String getOpenid(String code){ Map\u0026lt;String,String\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(\u0026#34;appid\u0026#34;, weChatProperties.getAppid()); map.put(\u0026#34;secret\u0026#34;, weChatProperties.getSecret()); map.put(\u0026#34;js_code\u0026#34;, code); map.put(\u0026#34;grant_type\u0026#34;, \u0026#34;authorization_code\u0026#34;); String json = HttpClientUtil.doGet(WX_LOGIN, map); JSONObject jsonObject = JSON.parseObject(json); String openid = jsonObject.getString(\u0026#34;openid\u0026#34;); return openid; } } Mapper\n1 2 3 4 5 6 7 @Mapper public interface UserMapper { @Select(\u0026#34;select * from user where openid = #{openid}\u0026#34;) User getByOpenid(String openid); void insert(User user); } Mapper XML\n1 2 3 4 5 6 7 8 9 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34; \u0026gt; \u0026lt;mapper namespace=\u0026#34;com.sky.mapper.UserMapper\u0026#34;\u0026gt; \u0026lt;insert id=\u0026#34;insert\u0026#34;\u0026gt; insert into user(openid, name, phone, sex, id_number, avatar, create_time) VALUES (#{openid}, #{name}, #{phone}, #{sex}, #{idNumber}, #{avatar}, #{createTime}) \u0026lt;/insert\u0026gt; \u0026lt;/mapper\u0026gt; 攔截器 統一攔截使用者端發送的請求進行 JWT 驗證\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 @Component @Slf4j public class JwtTokenUserInterceptor implements HandlerInterceptor { @Autowired private JwtProperties jwtProperties; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { // 判斷攔截類型，是控制器 (Controller) 還是其他資源 if(!(handler instanceof HandlerMethod)){ // 目前攔截的不是動態方法，直接放行 return true; } // 從請求中取得令牌 String token = request.getHeader(jwtProperties.getUserTokenName()); // 驗證令牌 try { log.info(\u0026#34;jwt驗證：{}\u0026#34;, token); Claims claims = JwtUtil.parseJWT(jwtProperties.getUserSecretKey(), token); Long userId = Long.valueOf(claims.get(JwtClaimsConstant.USER_ID).toString()); log.info(\u0026#34;目前使用者ID：{}\u0026#34;, userId); BaseContext.setCurrentId(userId); // 驗證通過 return true; }catch (Exception ex){ // 驗證未通過 return false; } } } 在 WebMvcConfiguration 註冊攔截器\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Autowired private JwtTokenUserInterceptor jwtTokenUserInterceptor; /** * 註冊自訂攔截器 * @param registry */ protected void addInterceptors(InterceptorRegistry registry) { log.info(\u0026#34;開始註冊自訂攔截器...\u0026#34;); //......... registry.addInterceptor(jwtTokenUserInterceptor) .addPathPatterns(\u0026#34;/user/**\u0026#34;) .excludePathPatterns(\u0026#34;/user/user/login\u0026#34;) .excludePathPatterns(\u0026#34;/user/shop/status\u0026#34;); } ","date":"2024-02-10T18:09:17+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/152/","title":"微信登入後端"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 前言 千萬不要把無窮迴圈放進去啊！！！請使用 systemd 方式\n建立腳本 請在此檔案中寫入您的腳本\n1 vi /etc/rc.d/rc.local 賦予執行權限\n1 chmod +x /etc/rc.d/rc.local 編輯啟動狀態 編輯檔案\n1 vi /usr/lib/systemd/system/rc-local.service 請在最後一行加入 [Install]\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # This file is part of systemd. # # systemd is free software; you can redistribute it and/or modify it # under the terms of the GNU Lesser General Public License as published by # the Free Software Foundation; either version 2.1 of the License, or # (at your option) any later version. # This unit gets pulled automatically into multi-user.target by # systemd-rc-local-generator if /etc/rc.d/rc.local is executable. [Unit] Description=/etc/rc.d/rc.local Compatibility ConditionFileIsExecutable=/etc/rc.d/rc.local After=network.target [Service] Type=forking ExecStart=/etc/rc.d/rc.local start TimeoutSec=0 RemainAfterExit=yes SysVStartPriority=99 [Install] WantedBy=multi-user.target 然後使用 systemd 開機自動啟動\n1 systemctl enable rc-local.service 檢視啟動狀態 請使用以下指令\n1 systemctl status rc-local.service 參考文章 Fedora 22(15以上版本)開機自動啟動腳本 - 可酷可樂 - 博客園 ","date":"2024-01-28T14:25:58+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/149/","title":"Fedora 開機啟動執行腳本"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 範例引入 取得員工資料，回傳統一回應結果，並在頁面呈現顯示\n首先需要匯入 dom4j 依賴，用於解析 XML 檔案\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.dom4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;dom4j\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.1.3\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 匯入解析 XML 的工具類別 XMLParserUtils、對應的實體類別 Emp、XML 檔案 emp.xml\n匯入靜態網頁檔案，放在 resources/static\nSpringBoot 專案的靜態資源 (H5 + CSS + JS 等前端資源) 預設存放目錄為 clsspath:/static, classpath:/public, clsspath:/resources\n對應 Maven 來說 classpath 為 src/main/resources\n編寫 Controller 程式，處理請求，回應資料 (此範例程式碼省略，使用下列三層架構)\n三層架構 上例 Emp 程式將資料存取、處理邏輯和接收回應請求放在一個 Controller 裡，使得復用性差、難以維護，為此需要將其分開以滿足單一職責原則，三層架構使得程式碼復用性強、便於維護、有利於擴展\n三層架構分為 Controller、Service 與 Dao\nController：控制層，接收前端送出的請求，對請求進行處理，並回應資料 Service：業務邏輯層，處理具體的業務邏輯 Dao：資料存取層 (Data Access Object) 或持久層，負責資料存取操作，CRUD 瀏覽器發出請求 -\u0026gt; Controller 接收請求、回應資料 -\u0026gt; Service 邏輯處理 -\u0026gt; Dao 資料存取\n上例 Emp 程式碼可以優化成\nController 1 2 3 4 5 6 7 8 9 @RestController public class EmpController { @RequestMapping(\u0026#34;/listEmp\u0026#34;) public Result listEmp(){ EmpService empServiceA = new EmpServiceA(); List\u0026lt;Emp\u0026gt; empList = empServiceA.listEmp(); return Result.success(empList); } } Service 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // interface public interface EmpService { public List\u0026lt;Emp\u0026gt; listEmp(); } public class EmpServiceA implements EmpService { private EmpDao empDao = new EmpDaoA(); public List\u0026lt;Emp\u0026gt; listEmp(){ List\u0026lt;Emp\u0026gt; empList = empDao.listEmp(); empList.forEach(emp -\u0026gt; { String gender = emp.getGender(); if(\u0026#34;1\u0026#34;.equals(gender)){ emp.setGender(\u0026#34;男\u0026#34;); } else if (\u0026#34;2\u0026#34;.equals(gender)) { emp.setGender(\u0026#34;女\u0026#34;); } String job = emp.getJob(); if(\u0026#34;1\u0026#34;.equals(job)){ emp.setJob(\u0026#34;講師\u0026#34;); } else if (\u0026#34;2\u0026#34;.equals(job)) { emp.setJob(\u0026#34;班主任\u0026#34;); } else if (\u0026#34;3\u0026#34;.equals(job)) { emp.setJob(\u0026#34;就業指導\u0026#34;); } }); return empList; } } Dao 1 2 3 4 5 6 7 8 9 10 11 12 // interface public interface EmpDao { public List\u0026lt;Emp\u0026gt; listEmp(); } public class EmpDaoA implements EmpDao { public List\u0026lt;Emp\u0026gt; listEmp(){ String file = this.getClass().getClassLoader().getResource(\u0026#34;emp.xml\u0026#34;).getFile(); List\u0026lt;Emp\u0026gt; empList = XmlParserUtils.parse(file, Emp.class); return empList; } } 分層解耦 內聚：軟體中各個功能模組內部的功能聯繫\n耦合：衡量軟體中各個層/模組之間的依賴、關聯的程度\n軟體設計原則：高內聚低耦合\n具體請見 https://blog.yexca.net/archives/145 例如上例三層架構，Controller 與 Service 耦合，Service 與 Dao 耦合\n在 Controller 中直接建立 Service 物件 EmpService empServiceA = new EmpServiceA(); 使用 A，若變更為 B 則需要修改 Controller，為了更換 Service 而不修改 Controller，可以建立一個容器，使得 Controller 從容器取得物件 (依賴注入) ，Service 把服務注入容器 (控制反轉)\n控制反轉：Inverse Of Control，簡稱 IOC。物件的建立控制權由程式自身轉移到外部 (容器) 依賴注入：Dependency Injection，簡稱 DI。容器為應用程式提供執行時所需的資源 Bean 物件：IOC 容器中建立、管理的物件 IOC 要把某個物件交給 IOC 容器管理，需要在對應類別上加上下列其中一個註解\n註解 說明 位置 @Component 宣告 Bean 的基礎註解 不屬於下列三種類別時使用此註解 (工具類別) @Controller @Component 的衍生註解 標註在控制器類別上 @Service @Component 的衍生註解 標註在業務類別上 @Repository @Component 的衍生註解 標註在資料存取類別上 (MyBatis 整合時，較少用) 宣告 Bean 時，可以透過 value 屬性指定名稱，若無，預設類別名稱首字母小寫 在 SpringBoot 整合網頁開發中，宣告控制器 Bean 只能用 @Controller Bean 元件掃描 上面宣告 Bean 的四個註解，若要生效，還需被元件掃描註解 @ComponentScan 掃描\n此註解實際上已包含在啟動類別宣告註解 @SpringBootApplication 中，預設的掃描範圍是啟動類別所在的套件及其子套件\n透過 value 或 basePackage 屬性指定掃描範圍\n1 @ComponentScan({\u0026#34;dao\u0026#34;,\u0026#34;net.yexca\u0026#34;}) 範例 上例中\nController 由於 @RestController 註解已包含 @Controller，無須修改\nService 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 // interface public interface EmpService { public List\u0026lt;Emp\u0026gt; listEmp(); } // 在實作類別新增 @Service // 將當前類別交給IOC容器管理，成為IOC容器中的Bean public class EmpServiceA implements EmpService { private EmpDao empDao = new EmpDaoA(); public List\u0026lt;Emp\u0026gt; listEmp(){ List\u0026lt;Emp\u0026gt; empList = empDao.listEmp(); empList.forEach(emp -\u0026gt; { String gender = emp.getGender(); if(\u0026#34;1\u0026#34;.equals(gender)){ emp.setGender(\u0026#34;男\u0026#34;); } else if (\u0026#34;2\u0026#34;.equals(gender)) { emp.setGender(\u0026#34;女\u0026#34;); } String job = emp.getJob(); if(\u0026#34;1\u0026#34;.equals(job)){ emp.setJob(\u0026#34;講師\u0026#34;); } else if (\u0026#34;2\u0026#34;.equals(job)) { emp.setJob(\u0026#34;班主任\u0026#34;); } else if (\u0026#34;3\u0026#34;.equals(job)) { emp.setJob(\u0026#34;就業指導\u0026#34;); } }); return empList; } } Dao 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // interface public interface EmpDao { public List\u0026lt;Emp\u0026gt; listEmp(); } // 在實作類別新增 @Repository // 將當前類別交給IOC容器管理，成為IOC容器中的Bean public class EmpDaoA implements EmpDao { public List\u0026lt;Emp\u0026gt; listEmp(){ String file = this.getClass().getClassLoader().getResource(\u0026#34;emp.xml\u0026#34;).getFile(); List\u0026lt;Emp\u0026gt; empList = XmlParserUtils.parse(file, Emp.class); return empList; } } DI 使用 @Autowired 註解可以注入依賴，不過預設是按照型別進行，如果存在多個相同型別的 Bean 會報錯\n將以上範例加上 DI (修改的程式碼將被註解)\nController 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @RestController public class EmpController { @Autowired // 執行時，IOC容器會提供該型別的Bean物件，並指派給該變數 -- 依賴注入 private EmpService empService; @RequestMapping(\u0026#34;/listEmp\u0026#34;) public Result listEmp(){ //EmpService empServiceA = new EmpServiceA(); //List\u0026lt;Emp\u0026gt; empList = empServiceA.listEmp(); List\u0026lt;Emp\u0026gt; empList = empService.listEmp(); return Result.success(empList); } } Service 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 // interface public interface EmpService { public List\u0026lt;Emp\u0026gt; listEmp(); } // 在實作類別新增 @Service // 將當前類別交給IOC容器管理，成為IOC容器中的Bean public class EmpServiceA implements EmpService { @Autowired // 執行時，IOC容器會提供該型別的Bean物件，並指派給該變數 -- 依賴注入 private EmpDao empDao; // private EmpDao empDao = new EmpDaoA(); public List\u0026lt;Emp\u0026gt; listEmp(){ List\u0026lt;Emp\u0026gt; empList = empDao.listEmp(); empList.forEach(emp -\u0026gt; { String gender = emp.getGender(); if(\u0026#34;1\u0026#34;.equals(gender)){ emp.setGender(\u0026#34;男\u0026#34;); } else if (\u0026#34;2\u0026#34;.equals(gender)) { emp.setGender(\u0026#34;女\u0026#34;); } String job = emp.getJob(); if(\u0026#34;1\u0026#34;.equals(job)){ emp.setJob(\u0026#34;講師\u0026#34;); } else if (\u0026#34;2\u0026#34;.equals(job)) { emp.setJob(\u0026#34;班主任\u0026#34;); } else if (\u0026#34;3\u0026#34;.equals(job)) { emp.setJob(\u0026#34;就業指導\u0026#34;); } }); return empList; } } Dao 沒有資料注入，無須修改\n@Primary 若將 Service 新增一個實作類別 EmpServiceB 且也使用了 @Autowired，程式會報錯，可以透過 @Primary 註解指定使用哪一個\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 // interface public interface EmpService { public List\u0026lt;Emp\u0026gt; listEmp(); } // 在實作類別新增 @Service // 將當前類別交給IOC容器管理，成為IOC容器中的Bean public class EmpServiceA implements EmpService { @Autowired // 執行時，IOC容器會提供該型別的Bean物件，並指派給該變數 -- 依賴注入 private EmpDao empDao; // private EmpDao empDao = new EmpDaoA(); public List\u0026lt;Emp\u0026gt; listEmp(){ List\u0026lt;Emp\u0026gt; empList = empDao.listEmp(); empList.forEach(emp -\u0026gt; { String gender = emp.getGender(); if(\u0026#34;1\u0026#34;.equals(gender)){ emp.setGender(\u0026#34;男\u0026#34;); } else if (\u0026#34;2\u0026#34;.equals(gender)) { emp.setGender(\u0026#34;女\u0026#34;); } String job = emp.getJob(); if(\u0026#34;1\u0026#34;.equals(job)){ emp.setJob(\u0026#34;講師\u0026#34;); } else if (\u0026#34;2\u0026#34;.equals(job)) { emp.setJob(\u0026#34;班主任\u0026#34;); } else if (\u0026#34;3\u0026#34;.equals(job)) { emp.setJob(\u0026#34;就業指導\u0026#34;); } }); return empList; } } @Primary // 使用此 Bean @Service // 將當前類別交給IOC容器管理，成為IOC容器中的Bean public class EmpServiceB implements EmpService { @Autowired // 執行時，IOC容器會提供該型別的Bean物件，並指派給該變數 -- 依賴注入 private EmpDao empDao; // private EmpDao empDao = new EmpDaoA(); public List\u0026lt;Emp\u0026gt; listEmp(){ List\u0026lt;Emp\u0026gt; empList = empDao.listEmp(); empList.forEach(emp -\u0026gt; { String gender = emp.getGender(); if(\u0026#34;1\u0026#34;.equals(gender)){ emp.setGender(\u0026#34;男\u0026#34;); } else if (\u0026#34;2\u0026#34;.equals(gender)) { emp.setGender(\u0026#34;女\u0026#34;); } String job = emp.getJob(); if(\u0026#34;1\u0026#34;.equals(job)){ emp.setJob(\u0026#34;講師\u0026#34;); } else if (\u0026#34;2\u0026#34;.equals(job)) { emp.setJob(\u0026#34;班主任\u0026#34;); } else if (\u0026#34;3\u0026#34;.equals(job)) { emp.setJob(\u0026#34;就業指導\u0026#34;); } }); return empList; } } @Qualifier 指定使用哪個 Bean，在 Controller 使用，將上方 @Primary 註解取消\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @RestController public class EmpController { @Qualifier(\u0026#34;empServiceA\u0026#34;) // 使用 Bean empServiceA @Autowired // 執行時，IOC容器會提供該型別的Bean物件，並指派給該變數 -- 依賴注入 private EmpService empService; @RequestMapping(\u0026#34;/listEmp\u0026#34;) public Result listEmp(){ //EmpService empServiceA = new EmpServiceA(); //List\u0026lt;Emp\u0026gt; empList = empServiceA.listEmp(); List\u0026lt;Emp\u0026gt; empList = empService.listEmp(); return Result.success(empList); } } @Resource 與 @Qualifier 類似，不過不使用 @Autowired\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @RestController public class EmpController { // @Qualifier(\u0026#34;empServiceA\u0026#34;) // 使用 Bean empServiceA // @Autowired @Resource(name = \u0026#34;empServiceB\u0026#34;) // 使用 Bean empServiceB private EmpService empService; @RequestMapping(\u0026#34;/listEmp\u0026#34;) public Result listEmp(){ //EmpService empServiceA = new EmpServiceA(); //List\u0026lt;Emp\u0026gt; empList = empServiceA.listEmp(); List\u0026lt;Emp\u0026gt; empList = empService.listEmp(); return Result.success(empList); } } @Autowired 與 @Resource 差異\n@Autowired 是 Spring 框架提供的註解，而 @Resource 是 JDK 提供的註解\n@Autowired 預設是按照型別注入，而 @Resource 預設是按照名稱注入\n","date":"2024-01-19T10:37:15+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/147/","title":"三層架構與分層解耦"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 瀏覽器發送請求會先經過 DispatcherServlet 轉交給各 *Controller 程式處理，處理完成後將結果返回給 DispatcherServlet，然後再回傳給瀏覽器。\nDispatcherServlet 被稱為核心控制器或前端控制器。\n對於瀏覽器請求的資料，會被封裝到 HttpServletRequest 物件中；回應資料則會被封裝到 HttpServletResponse 物件中。\n*Controller 接收請求，設定回應\n請求 簡單參數 首先是原始方式，透過 HttpServletRequest 物件手動取得請求參數。\n1 2 3 4 5 6 7 8 9 @RequestMapping(\u0026#34;/simpleParam\u0026#34;) public String simpleParam(HttpServletRequest request){ String name = request.getParameter(\u0026#34;name\u0026#34;); String ageStr = request.getParameter(\u0026#34;age\u0026#34;); int age = Integer.parseInt(ageStr); System.out.println(name + \u0026#34;;\u0026#34; + age); return \u0026#34;OK\u0026#34;; } 當瀏覽器存取 http://localhost:8080/simpleParam?name=tom\u0026age=18 網頁時會回傳字串 “OK”，程式則會回傳 “Tom;18”。\n顯然這種方式過於麻煩，在 SpringBoot 中可以透過參數名稱與方法參數名稱相同的方式，直接定義方法參數即可接收。\n1 2 3 4 5 @RequestMapping(\u0026#34;/simpleParam\u0026#34;) public String simpleParam(String name, Integer age){ System.out.println(name + \u0026#34;;\u0026#34; + age); return \u0026#34;OK\u0026#34;; } 效果相同。\n不過上述方法即使請求的參數名稱不同也會繼續執行，未提供的參數會是 null。\n可以使用 @RequestParam 完成映射，實現請求名稱與方法參數名稱不同時的對應。\n1 2 3 4 5 6 7 @RequestMapping(\u0026#34;/simpleParam\u0026#34;) public String simpleParam(@RequestParam(name = \u0026#34;name\u0026#34;) String username, Integer age){ // 當宣告 @RequestParam 後，代表該參數必須被傳遞，否則會報錯。 // 若更改為 @RequestParam(name = \u0026#34;name\u0026#34;, required = false) 代表該參數並非必要。 System.out.println(username + \u0026#34;;\u0026#34; + age); return \u0026#34;OK\u0026#34;; } 實體參數 如果只是少量參數，使用上述方法可行；但若是較多的資料，可以透過簡單實體物件來處理，只要請求參數名稱與方法參數物件的屬性名稱相同，定義 POJO 即可接收。\n1 2 3 4 5 6 7 8 9 10 11 12 @RequestMapping(\u0026#34;/simplePojo\u0026#34;) public String simplePojo(User user){ System.out.println(user); return \u0026#34;OK\u0026#34;; } // User類 public class User{ private String name; private Integer age; // set get toString 方法 } 存取 http://localhost:8080/simplePojo?name=tom\u0026age=18 網頁時會回傳字串 “OK”，程式則會回傳 “User{name=\u0026lsquo;tom\u0026rsquo;, age=18}”。\n複雜實體物件：請求參數名稱與方法參數屬性名稱相同，依照物件的階層結構關係即可接收巢狀 POJO 屬性參數。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 @RequestMapping(\u0026#34;/complexPojo\u0026#34;) public String complexPojo(UserComplex user){ System.out.println(user); return \u0026#34;OK\u0026#34;; } // User類 public class UserComplex{ private String name; private Integer age; private Address address; // set get toString } // Address類 public class Address{ private String province; private String city; // set get toString } 存取 http://localhost:8080/complexPojo?name=tom\u0026age=18\u0026address.province=beijing\u0026address.city=beijing 網頁時會回傳字串 “OK”，程式則會回傳 “UserComplex{name=\u0026lsquo;tom\u0026rsquo;, age=1000, address=Address{province=\u0026lsquo;ads,beijing\u0026rsquo;, city=\u0026lsquo;asda,beijing\u0026rsquo;}}”。\n陣列參數 請求參數名稱與方法參數陣列名稱相同且請求參數有多個時，定義陣列型別的方法參數即可接收。例如多選框。\n1 2 3 4 5 @RequestMapping(\u0026#34;/arrayParam\u0026#34;) public String arrayParam(String[] hobby){ System.out.println(Arrays.toString(hobby)); return \u0026#34;OK\u0026#34;; } 存取 http://localhost:8080/arrayParam?hobby=ads\u0026hobby=58s 網頁時會回傳字串 “OK”，程式則會回傳 “[ads, 58s]”。\n集合參數 請求參數名稱與方法參數陣列名稱相同且請求參數有多個時，使用 @RequestParam 繫結參數關係。\n1 2 3 4 5 @RequestMapping(\u0026#34;/listParam\u0026#34;) public String listParam(@RequestParam List\u0026lt;String\u0026gt; hobby){ System.out.println(hobby); return \u0026#34;OK\u0026#34;; } 存取 http://localhost:8080/listParam?hobby=ads\u0026hobby=58s 網頁時會回傳字串 “OK”，程式則會回傳 “[ads, 58s]”。\n日期參數 使用 @DateTimeFormat 註解來完成日期參數的格式轉換。\n需要注意的是傳遞參數有三種形式：\nyyyy-MM-dd HH:mm:ss yyyy/MM/dd HH:mm:ss yyyy年MM月dd日 HH時mm分ss秒 需要前後端統一格式才行。\n1 2 3 4 5 @RequestMapping(\u0026#34;/dateParam\u0026#34;) public String dateParam(@DateTimeFormat(pattern = \u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;) LocalDateTime localDateTime){ System.out.println(localDateTime); return \u0026#34;OK\u0026#34;; } 存取 http://localhost:8080/dateParam?localDateTime=2024-01-01%2001:01:01 網頁時會回傳字串 “OK”，程式則會回傳 \u0026ldquo;2024-01-01T01:01:01\u0026rdquo;。\nJSON 參數 JSON 資料的鍵名與方法參數物件的屬性名稱相同，定義 POJO 型別的方法參數即可接收參數，需要使用 @RequestBody 標示。\n若要傳輸 JSON 資料，必須使用 POST 請求。\n1 2 3 4 5 @RequestMapping(\u0026#34;/jsonParam\u0026#34;) public String jsonParam(@RequestBody UserComplex userComplex){ System.out.println(userComplex); return \u0026#34;OK\u0026#34;; } 請求資料\n1 2 3 4 5 6 7 8 { \u0026#34;name\u0026#34;: \u0026#34;jane\u0026#34;, \u0026#34;age\u0026#34;: \u0026#34;18\u0026#34;, \u0026#34;address\u0026#34;: { \u0026#34;province\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34; } } 使用 POST 方法請求 http://localhost:8080/jsonParam ，資料如上，網頁會回傳字串 “OK”，程式則會回傳 \u0026ldquo;UserComplex{name=\u0026lsquo;jane\u0026rsquo;, age=18, address=Address{province=\u0026lsquo;上海\u0026rsquo;, city=\u0026lsquo;上海\u0026rsquo;}}\u0026quot;。\n路徑參數 透過請求 URL 直接傳遞參數，使用 {...} 來標示該路徑參數，需要使用 @PathVariable 取得路徑參數。\n1 2 3 4 5 @RequestMapping(\u0026#34;/path/{id}\u0026#34;) public String pathParam(@PathVariable Integer id){ System.out.println(id); return \u0026#34;OK\u0026#34;; } 存取 http://localhost:8080/path/52 網頁時會回傳字串 “OK”，程式則會回傳 \u0026ldquo;52\u0026rdquo;。\n存取 http://localhost:8080/path/255 網頁時會回傳字串 “OK”，程式則會回傳 \u0026ldquo;255\u0026rdquo;。\n對於多個路徑參數：\n1 2 3 4 5 @RequestMapping(\u0026#34;/path/{id}/{name}\u0026#34;) public String pathParam(@PathVariable Integer id, @PathVariable String name){ System.out.println(id + \u0026#34;;\u0026#34; + name); return \u0026#34;OK\u0026#34;; } 存取 http://localhost:8080/path/255/Tom 網頁時會回傳字串 “OK”，程式則會回傳 \u0026ldquo;255;Tom\u0026rdquo;。\n總結 簡單參數 定義方法參數，請求參數名稱與方法參數變數名稱一致。 如果名稱不一致，透過 @RequestParam 手動映射。 實體參數 請求參數名稱與實體物件的屬性名稱一致，會自動接收並封裝。 陣列集合參數 陣列：請求參數名稱與陣列名稱一致，直接封裝。 集合：請求參數名稱與陣列名稱一致，使用 @RequestParam 繫結關係。 日期參數 @DateTimeFormat JSON 參數 @RequestBody 路徑參數 @PathVariable 回應 使用 @RequestBody 處理回應\n上述請求之所以能夠回應，是因為註解 @RestController 包含 @Controller 和 @ResponseBody。\n@RequestBody 型別：方法註解、類別註解\n位置：Controller 方法上或類別上\n作用：將方法的返回值直接回應，若返回值型別為 實體物件或集合，將會轉換為 JSON 格式回應。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 @RestController public class ResponseController { @RequestMapping(\u0026#34;/hello\u0026#34;) public String hello(){ System.out.println(\u0026#34;Hello SpringBoot\u0026#34;); return \u0026#34;Hello SpringBoot\u0026#34;; } @RequestMapping(\u0026#34;/getAddr\u0026#34;) public Address getAddr(){ Address address = new Address(); address.setProvince(\u0026#34;上海\u0026#34;); address.setCity(\u0026#34;上海\u0026#34;); return address; } @RequestMapping(\u0026#34;/listAddr\u0026#34;) public List\u0026lt;Address\u0026gt; listAddr(){ List\u0026lt;Address\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); Address address1 = new Address(); address1.setProvince(\u0026#34;北京\u0026#34;); address1.setCity(\u0026#34;北京\u0026#34;); Address address2 = new Address(); address2.setProvince(\u0026#34;上海\u0026#34;); address2.setCity(\u0026#34;上海\u0026#34;); list.add(address1); list.add(address2); return list; } } 存取相關網址進行測試。\n統一回應結果 以上三個方法的回傳型別都不一樣，使得前端開發較為困難，因此可以統一回應結果為一個類別。\n1 2 3 4 5 6 7 8 9 public class Result{ // 回應碼，1 代表成功，0 代表失敗 private Integer code; // 提示訊息 private String msg; // 回傳的資料 private Object data; // ... } 讓所有的回應方法都回傳一個 Result 物件，使專案管理與維護更為容易。\n例如以下類別：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 public class Result { private Integer code ;//1 成功 , 0 失敗 private String msg; //提示訊息 private Object data; //資料 data public Result() { } public Result(Integer code, String msg, Object data) { this.code = code; this.msg = msg; this.data = data; } public Integer getCode() { return code; } public void setCode(Integer code) { this.code = code; } public String getMsg() { return msg; } public void setMsg(String msg) { this.msg = msg; } public Object getData() { return data; } public void setData(Object data) { this.data = data; } public static Result success(Object data){ return new Result(1, \u0026#34;success\u0026#34;, data); } public static Result success(){ return new Result(1, \u0026#34;success\u0026#34;, null); } public static Result error(String msg){ return new Result(0, msg, null); } @Override public String toString() { return \u0026#34;Result{\u0026#34; + \u0026#34;code=\u0026#34; + code + \u0026#34;, msg=\u0026#39;\u0026#34; + msg + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, data=\u0026#34; + data + \u0026#39;}\u0026#39;; } } 那麼上面程式碼可以改為：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 @RequestMapping(\u0026#34;/hello\u0026#34;) public Result hello(){ System.out.println(\u0026#34;Hello SpringBoot\u0026#34;); return Result.success(\u0026#34;Hello SpringBoot\u0026#34;); } @RequestMapping(\u0026#34;/getAddr\u0026#34;) public Result getAddr(){ Address address = new Address(); address.setProvince(\u0026#34;上海\u0026#34;); address.setCity(\u0026#34;上海\u0026#34;); return Result.success(address); } @RequestMapping(\u0026#34;/listAddr\u0026#34;) public Result listAddr(){ List\u0026lt;Address\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); Address address1 = new Address(); address1.setProvince(\u0026#34;北京\u0026#34;); address1.setCity(\u0026#34;北京\u0026#34;); Address address2 = new Address(); address2.setProvince(\u0026#34;上海\u0026#34;); address2.setCity(\u0026#34;上海\u0026#34;); list.add(address1); list.add(address2); return Result.success(list); } 存取相關網址進行測試。\n","date":"2024-01-14T16:47:28+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/144/","title":"Spring 請求與回應"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 Maven 是一款用於管理和建置 Java 專案的工具\nMaven 可以方便快捷地管理專案相依的資源 (Jar 檔)，避免版本衝突問題；提供標準、統一的專案結構；標準跨平台的自動化專案建置方式\n安裝 在 官網 下載後解壓，然後設定本地存放庫，修改 conf/setting.xml 中的 \u0026lt;localRepository\u0026gt; 為一個指定目錄\n1 2 \u0026lt;!-- 例如本地庫在 D:\\develop\\maven_repo --\u0026gt; \u0026lt;localRepository\u0026gt;D:\\develop\\maven_repo\u0026lt;/localRepository\u0026gt; 設定阿里雲私服鏡像，修改 conf/setting.xml 中的 \u0026lt;mirror\u0026gt; 標籤，新增子標籤\n1 2 3 4 5 6 \u0026lt;mirror\u0026gt; \u0026lt;id\u0026gt;alimaven\u0026lt;/id\u0026gt; \u0026lt;name\u0026gt;aliyun maven\u0026lt;/name\u0026gt; \u0026lt;url\u0026gt;http://maven.aliyun.com/nexus/content/groups/public/\u0026lt;/url\u0026gt; \u0026lt;mirrorOf\u0026gt;central\u0026lt;/mirrorOf\u0026gt; \u0026lt;/mirror\u0026gt; 設定環境變數：MAVEN_HOME 為 Maven 解壓目錄，並將其 bin 目錄加入 PATH 環境變數\n測試安裝完成：在命令列輸入 mvn -v 查看輸出\n相依性配置 相依性 (Dependency)：指當前專案執行所需要的 Jar 檔，一個專案中可以引入多個相依性\n設定步驟：\n在 pom.xml 中編寫 \u0026lt;dependencies\u0026gt; 標籤 在 \u0026lt;dependencies\u0026gt; 標籤中使用 \u0026lt;dependency\u0026gt; 引入座標 定義座標的 groupId, artifactId, version 重新整理配置，引入新加入的座標 1 2 3 4 5 6 7 8 \u0026lt;!-- 例如引入 logback --\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;ch.qos.logback\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;logback-classic\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.3\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 可以到 https://mvnrepository.com/ 查找相依性座標資訊\n相依性傳遞 相依性具有傳遞性\n直接相依：在當前專案中透過相依性配置建立的相依關係 間接相依：被相依的資源如果相依於其他資源，則當前專案間接相依於其他資源 當新增相依性時，若此套件相依於其他套件，將自動新增相關套件\n當然，若某個套件的子套件並不需要，可以排除相依 (指主動斷開相依的資源，被排除的資源無需指定版本)\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;!-- 例如排除某專案的 junit --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.yexca\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-project\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;exclusions\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;groupId\u0026gt;junit\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit\u0026lt;/artifactId\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;/exclusions\u0026gt; \u0026lt;/dependency\u0026gt; 相依性範圍 相依的 Jar 檔，預設可以在任何地方使用，可以透過 \u0026lt;scope\u0026gt;...\u0026lt;/scope\u0026gt; 設定其作用範圍：\n主程式範圍有效 (main 資料夾範圍內) 測試程式範圍有效 (test 資料夾範圍內) 是否參與打包執行 (package 指令範圍內) scope 值 主程式 測試程式 打包 (執行) 範例 compile (預設) Y Y Y log4j test - Y - junit provided Y Y - servlet-api runtime - Y Y JDBC 驅動 1 2 3 4 5 6 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;junit\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.10\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; 生命周期 Maven 的生命週期是為了對所有的 Maven 專案建置過程進行抽象和統一\nMaven 中有 3 套相互獨立的生命週期：\nclean：清理工作 default：核心工作，如：編譯、測試、打包、安裝、部署等 site：生成報告、發布站台等 其中每套生命週期包含一些階段 (phase)，階段是有順序的，後面的階段相依於前面的階段\nclean pre-clean clean：移除上一次建置產生的檔案 (target 資料夾) post-clean default validate initialize generate-sources process-sources generate-resources process-resources compile：編譯專案原始碼 process-classes generate-test-sources process-test-sources generate-test-resources process-test-resources test-compile process-test-classes test：使用合適的單元測試框架執行測試 (JUnit) prepare-package package：將編譯後的檔案打包，如 Jar、War 等 verify install：安裝專案到本地存放庫 deploy site pre-site site post-site site-deploy 在同一套生命週期中，當執行後面的階段時，前面的階段都會執行\n分模組設計 分模組設計是在進行專案設計階段時，就可以將一個大型專案拆分成若干個模組，每一個模組都是獨立的，如果我們需要用到另外一個模組的功能，直接引用該模組的相依性即可\n可以把一些通用的實體類別或工具類別單獨作為一個模組，若某一模組需要使用，直接引入對應的相依性即可\n方便專案的管理維護、擴充，也方便模組間的相互呼叫與資源共享\n繼承 像 Lombok 相依性，可能專案中的每個模組都會使用，每個模組都宣告一次相當繁瑣，可以透過繼承解決這個問題\n繼承關係 建立一個父工程，將模組共有的相依性都提取到父工程進行配置，只要子類別繼承了父工程，相依性也會繼承下來，這樣就無需在各個子工程中進行配置了\n繼承描述的是兩個工程間的關係，與 Java 中的繼承相似，子工程可以繼承父工程中的配置資訊，常見於相依關係的繼承，可以簡化相依性配置、統一管理相依性\n1 2 3 4 5 6 7 \u0026lt;!--指定父工程--\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;...\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;...\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;...\u0026lt;/version\u0026gt; \u0026lt;relativePath\u0026gt;....\u0026lt;/relativePath\u0026gt; \u0026lt;/parent\u0026gt; 如果是 JavaWeb 開發，可以讓父工程繼承 spring-boot-starter-parent，其他模組繼承該父工程\n一般情況下，在檔案結構中，子工程為父工程的子目錄\n以下為例子\n父工程的打包方式為 pom 1 2 3 4 5 6 7 8 9 10 11 \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.7.5\u0026lt;/version\u0026gt; \u0026lt;relativePath/\u0026gt; \u0026lt;!-- lookup parent from repository --\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;groupId\u0026gt;net.yexca\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;tlias-parent\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;packaging\u0026gt;pom\u0026lt;/packaging\u0026gt; Maven 打包方式：\njar：普通模組打包，SpringBoot 專案基本都是 Jar 檔 (內建 Tomcat 執行) war：普通 Web 程式打包，需要部署在外部的 Tomcat 伺服器中執行 pom：父工程或聚合工程，該模組不寫程式碼，僅進行相依性管理 子工程指定父工程 1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;net.yexca\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;tlias-parent\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;!-- 指定父工程的 pom 檔案的相對位置 (如果不指定，將從本地存放庫/遠端存放庫查找該工程) --\u0026gt; \u0026lt;relativePath\u0026gt;../tlias-parent/pom.xml\u0026lt;/relativePath\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;!-- \u0026lt;groupId\u0026gt;net.yexca\u0026lt;/groupId\u0026gt; -\t因為自動繼承父工程，可以省略 --\u0026gt; \u0026lt;artifactId\u0026gt;tlias-utils\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; 父工程中配置共有相依性 1 2 3 4 5 6 7 \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.18.24\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 版本鎖定 某些相依性部分模組需要，部分模組不需要，可以在父級中管理相依性的 version，方便管理與修改\n可以透過 \u0026lt;dependencyManagement\u0026gt; 標籤管理相依性版本\n父工程\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;!--統一管理相依性版本--\u0026gt; \u0026lt;dependencyManagement\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!--JWT權杖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.jsonwebtoken\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jjwt\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.9.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/dependencyManagement\u0026gt; 子工程\n1 2 3 4 5 6 7 8 9 10 \u0026lt;dependencies\u0026gt; \u0026lt;!--JWT權杖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.jsonwebtoken\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jjwt\u0026lt;/artifactId\u0026gt; \u0026lt;!-- \u0026lt;version\u0026gt;0.9.1\u0026lt;/version\u0026gt; - 因為父工程指定了版本，不需要填寫 --\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 父工程的 \u0026lt;dependencyManagement\u0026gt; 配置只管理版本，不會將相依性引入子工程。只有在子工程引入後才會生效，只是引入時無需指定版本號\n而 \u0026lt;dependencies\u0026gt; 會把相依性直接引入所有子工程\n屬性設定 也可以透過自定義屬性及屬性引用的形式，在父工程中將相依性的版本號進行集中管理維護\n自定義屬性：\n1 2 3 \u0026lt;properties\u0026gt; \u0026lt;lombok.version\u0026gt;1.18.24\u0026lt;/lombok.version\u0026gt; \u0026lt;/properties\u0026gt; 引用屬性：\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${lombok.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 於是可以在父工程中將所有的版本號，集中管理維護\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 \u0026lt;properties\u0026gt; \u0026lt;maven.compiler.source\u0026gt;11\u0026lt;/maven.compiler.source\u0026gt; \u0026lt;maven.compiler.target\u0026gt;11\u0026lt;/maven.compiler.target\u0026gt; \u0026lt;lombok.version\u0026gt;1.18.24\u0026lt;/lombok.version\u0026gt; \u0026lt;jjwt.version\u0026gt;0.9.1\u0026lt;/jjwt.version\u0026gt; \u0026lt;aliyun.oss.version\u0026gt;3.15.1\u0026lt;/aliyun.oss.version\u0026gt; \u0026lt;jaxb.version\u0026gt;2.3.1\u0026lt;/jaxb.version\u0026gt; \u0026lt;activation.version\u0026gt;1.1.1\u0026lt;/activation.version\u0026gt; \u0026lt;jaxb.runtime.version\u0026gt;2.3.3\u0026lt;/jaxb.runtime.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${lombok.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;!--統一管理相依性版本--\u0026gt; \u0026lt;dependencyManagement\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!--JWT權杖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.jsonwebtoken\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jjwt\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${jjwt.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--阿里雲OSS--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.aliyun.oss\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;aliyun-sdk-oss\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${aliyun.oss.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.xml.bind\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jaxb-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${jaxb.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.activation\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;activation\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${activation.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- no more than 2.3.3--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.glassfish.jaxb\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jaxb-runtime\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${jaxb.runtime.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/dependencyManagement\u0026gt; 若想要修改相依性的版本，只需要在父工程的自定義屬性中，修改相應屬性值即可\n聚合 若一個模組相依於另一個模組，打包該模組前需要先將其他模組 install 到本地存放庫，然後再打包。如果相依的模組很多，那麼需要執行的操作會過於繁瑣\n透過 Maven 的聚合就可以輕鬆實現專案的一鍵建置 (清理、編譯、測試、打包、安裝等)\n**聚合：**將多個模組組織成一個整體，同時進行專案的建置 **聚合工程：**一個不具有業務功能的「空」工程 (有且僅有一個 pom 檔案。一般來說，繼承關係中的父工程與聚合關係中的聚合工程是同一個) **作用：**快速建置專案 (無需根據相依關係手動建置，直接在聚合工程上建置即可) 可以在聚合工程中透過 \u0026lt;modules\u0026gt; 設定當前聚合工程所包含的子模組名稱\n1 2 3 4 5 6 7 \u0026lt;!--聚合其他模組--\u0026gt; \u0026lt;modules\u0026gt; \u0026lt;!-- 工程路徑 --\u0026gt; \u0026lt;module\u0026gt;../tlias-pojo\u0026lt;/module\u0026gt; \u0026lt;module\u0026gt;../tlias-utils\u0026lt;/module\u0026gt; \u0026lt;module\u0026gt;../tlias-web-management\u0026lt;/module\u0026gt; \u0026lt;/modules\u0026gt; 之後進行編譯、打包、安裝操作只需在聚合工程上進行即可，其他工程會自動同步操作\n繼承 聚合 作用 繼承用於簡化相依性配置、統一管理相依性 聚合用於快速建置專案 相同點 打包方式均為 pom，通常製作在同一個 pom 均屬於設計型模組，無實際內容 不同點 繼承是在子模組中配置關係\n父模組無法感知哪些子模組繼承了自己 聚合是在聚合工程中配置關係\n聚合可以感知到參與聚合的模組有哪些 私服 私服是一種特殊的遠端存放庫，它是架設在區域網路內的存放庫服務，用來代理位於外部的中央存放庫，用於解決團隊內部的資源共享與資源同步問題\n如果在專案中需要使用其他第三方提供的相依性，如果本地存放庫沒有，會自動連接私服下載，如果私服也沒有，私服此時會自動連接中央存放庫，去中央存放庫中下載相依性，然後將下載的相依性儲存在私服存放庫及本地存放庫中\n私服一般一個公司一台，不用自己配置\n私服存放庫與專案版本 私服存放庫說明：\nRELEASE：儲存自己開發的 RELEASE 發布版本的資源 SNAPSHOT：儲存自己開發的 SNAPSHOT 發布版本的資源 Central：儲存的是從中央存放庫下載下來的相依性 專案版本說明：\nRELEASE (發布版本)：功能趨於穩定、當前更新停止，可以用於發行的版本，儲存在私服中的 RELEASE 存放庫中 SNAPSHOT (快照版本)：功能不穩定、尚處於開發中的版本，即快照版本，儲存在私服的 SNAPSHOT 存放庫中 設定 設定私服的存取使用者名稱與密碼，在 Maven 安裝目錄的 conf/settings.xml 的 servers 配置中設定\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;servers\u0026gt; \u0026lt;server\u0026gt; \u0026lt;id\u0026gt;maven-releases\u0026lt;/id\u0026gt; \u0026lt;username\u0026gt;admin\u0026lt;/username\u0026gt; \u0026lt;password\u0026gt;admin\u0026lt;/password\u0026gt; \u0026lt;/server\u0026gt; \u0026lt;server\u0026gt; \u0026lt;id\u0026gt;maven-snapshots\u0026lt;/id\u0026gt; \u0026lt;username\u0026gt;admin\u0026lt;/username\u0026gt; \u0026lt;password\u0026gt;admin\u0026lt;/password\u0026gt; \u0026lt;/server\u0026gt; \u0026lt;/servers\u0026gt; 設定私服相依性下載的存放庫群組地址，檔案同上，修改 mirrors 與 profiles 標籤\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 \u0026lt;mirrors\u0026gt; \u0026lt;mirror\u0026gt; \u0026lt;id\u0026gt;maven-public\u0026lt;/id\u0026gt; \u0026lt;mirrorOf\u0026gt;*\u0026lt;/mirrorOf\u0026gt; \u0026lt;url\u0026gt;http://127.0.0.1:8081/repository/maven-public/\u0026lt;/url\u0026gt; \u0026lt;/mirror\u0026gt; \u0026lt;/mirrors\u0026gt; \u0026lt;profiles\u0026gt; \u0026lt;profile\u0026gt; \u0026lt;id\u0026gt;allow-snapshots\u0026lt;/id\u0026gt; \u0026lt;activation\u0026gt; \u0026lt;activeByDefault\u0026gt;true\u0026lt;/activeByDefault\u0026gt; \u0026lt;/activation\u0026gt; \u0026lt;repositories\u0026gt; \u0026lt;repository\u0026gt; \u0026lt;id\u0026gt;maven-public\u0026lt;/id\u0026gt; \u0026lt;url\u0026gt;http://127.0.0.1:8081/repository/maven-public/\u0026lt;/url\u0026gt; \u0026lt;releases\u0026gt; \u0026lt;enabled\u0026gt;true\u0026lt;/enabled\u0026gt; \u0026lt;/releases\u0026gt; \u0026lt;snapshots\u0026gt; \u0026lt;enabled\u0026gt;true\u0026lt;/enabled\u0026gt; \u0026lt;/snapshots\u0026gt; \u0026lt;/repository\u0026gt; \u0026lt;/repositories\u0026gt; \u0026lt;/profile\u0026gt; \u0026lt;/profiles\u0026gt; pom 檔案設定上傳地址，在父工程中設定即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;distributionManagement\u0026gt; \u0026lt;!-- release 版本的發布地址 --\u0026gt; \u0026lt;repository\u0026gt; \u0026lt;id\u0026gt;maven-releases\u0026lt;/id\u0026gt; \u0026lt;url\u0026gt;http://127.0.0.1:8081/repository/maven-releases/\u0026lt;/url\u0026gt; \u0026lt;/repository\u0026gt; \u0026lt;!-- snapshot 版本的發布地址 --\u0026gt; \u0026lt;snapshotRepository\u0026gt; \u0026lt;id\u0026gt;maven-snapshots\u0026lt;/id\u0026gt; \u0026lt;url\u0026gt;http://127.0.0.1:8081/repository/maven-snapshots/\u0026lt;/url\u0026gt; \u0026lt;/snapshotRepository\u0026gt; \u0026lt;/distributionManagement\u0026gt; 設定完成後，執行父工程的 deploy 生命周期即可將專案發布到私服存放庫\n","date":"2024-01-13T23:58:42+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/143/","title":"Maven 學習"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 SpringBoot 入門範例 需求：使用 SpringBoot 開發一個 Web 應用程式，瀏覽器發起 /hello 後，回傳字串 “Hello Spring”\n首先需要建立 SpringBoot 專案，並勾選 Web 開發相關相依性\n接著建立控制器類別，在 *Application.java 同級目錄下建立檔案 Controller/HelloController.java\n1 2 3 4 5 6 7 8 9 @RestController public class HelloController{ @RequestMapping(\u0026#34;/hello\u0026#34;) public String hello(){ String s = \u0026#34;Hello Spring\u0026#34;; System.out.println(s); return s; } } 執行 *Application.java 類別，在瀏覽器存取 http://localhost:8080/hello HTTP 超文字傳輸協定基於 TCP 協定 (導向連接，安全)，基於請求-回應模型 (一次請求對應一次回應)\nHTTP 協定是無狀態的協定，對於交易處理沒有記憶能力。每次請求-回應都是獨立的，這使得它速度快，相對地多次請求間不能共享資料\n其他詳見： https://blog.yexca.net/archives/64 ","date":"2024-01-10T17:53:18+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/142/","title":"JavaWeb 入門"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 建立新目錄，將網頁檔案放入 ./dict\n根目錄建立檔案 dockerfile，內容如下：\n1 2 3 4 5 6 # 基於 nginx:1.20 映像檔 FROM nginx:1.20 # 將 dist 檔案中的內容複製到 /usr/share/nginx/html/ 這個目錄下方 COPY dist/ /usr/share/nginx/html/dist/ # 用本地的 nginx.conf 配置來取代 nginx 映像檔中的預設配置 COPY nginx.conf /etc/nginx/nginx.conf 建立新檔案 nginx.conf，內容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #user nobody; worker_processes 1; events { worker_connections 1024; } http { include mime.types; default_type application/octet-stream; sendfile on; #tcp_nopush on; keepalive_timeout 65; # HTTP server server { listen 80; server_name localhost; location / { root /usr/share/nginx/html/dist; index index.html index.htm; } error_page 500 502 503 504 /50x.html; location = /50x.html { root html; } } } 執行打包指令\n1 docker build -t username/imagename:v1.0 . tag 修改映像檔名稱 推送映像檔的命名規範\n1 docker push 註冊使用者名稱/映像檔名 修改 tag\n1 docker tag name username/imagename:v1.0 如果沒有加上 tag，推送時預設為 latest，推送\n1 docker push username/imagename:v1.0 參考文章 docker: 打包 H5 專案的映像檔 Docker 映像檔推送（push）到 Docker Hub ","date":"2024-01-09T21:50:25+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/141/","title":"Docker 建立與推送 H5 映像檔"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 問題描述 某公司購買長鋼條，將其切割後進行出售。切割鋼條的成本可以忽略不計，鋼條的長度為英吋。已知價格表 $p$ ，其中 $p_{i}(i=1,2,\\cdots,m)$ 表示長度為 $i$ 英吋的鋼條的價格。現要求解使銷售收益最大的切割方案。\n問題分析 假設長鋼條的長度為 $n$ 英吋，最佳切割方案的最左邊切割段長度為 $i$ 英吋，則繼續求解剩餘長度為 $m-1$ 英吋鋼條的最佳切割方案。考慮所有可能的 $i$ ，得到的最大收益 $r_{n}$ 對應的切割方案即為最佳切割方案。$r_{n}$ 的遞迴定義如下：\n$$ r_{n}=max_{1\\le i \\le n}(p_{i}+r_{n-i}) $$C 程式碼 對此問題有兩種方案：\n(1) 分治法 (自頂向下) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int Top_Down_Cut_Rod(int p[], int n){ int r=0; // 最大價值 int i; if(n==0){ retrun 0; } for(i=1; i\u0026lt;=n; i++){ int tmp = p[i]+Top_Down_Cut_Rod(p, n-i); r = (r\u0026gt;=tmp) ? r : tmp; } return r; } 時間複雜度 $O(2^{n})$\n(2) 動態規劃 (自底向上) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int Bottom_Up_Cut_Rod(int p[], int n, int *s){ // *s:子問題最佳切割方法 int r[n+1]; // 子問題最佳價值 r[0]=0; for(int j=1; j\u0026lt;=n; j++){ int tmp=0; for(int i=1; i\u0026lt;=j; i++){ if(p[i]+r[j-1] \u0026gt; tmp){ tmp = p[i]+r[j-i]; s[j]=i; } } r[i]=tmp; } return r[n]; } 時間複雜度 $O(n^{2})$\n其他 在搜尋過程中發現已有的文章： 【基礎算法】动态规划详解——钢条切割 ","date":"2023-05-27T19:37:08+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/110/","title":"演算法 鋼條切割問題 (動態規劃 分治法)"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 問題描述 有 $n$ 枚硬幣，其中有一枚是偽幣，已知偽幣的重量較輕。現只有一個天平，要求用儘量少的比較次數找出這枚偽幣\n問題分析 將 $n$ 枚硬幣分成相等的兩部分：\n當 $n$ 為偶數時，將前後兩部分，即 $1\\cdots\\frac{n}{2}$ 和 $\\frac{n}{2}+1\\cdots n$ 放在天平的兩端，較輕的一端裡有偽幣，繼續在較輕的這部分硬幣中用同樣的方法找出偽幣 當 $n$ 為奇數時，將前後兩部分，即 $1\\cdots\\frac{n-1}{2}$ 和 $\\frac{n+1}{2}+1\\cdots n$ 放在天平的兩端，較輕的一端裡有偽幣，繼續在較輕的這部分硬幣中用同樣的方法找出偽幣；若兩端重量相等，則中間的硬幣，即第 $\\frac{n+1}{2}$ 枚硬幣是偽幣 C 程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 #include \u0026lt;stdio.h\u0026gt; // coins:重量陣列 first,last:陣列第一個與最後一個下標 int getCounterfeitCoin(int *coins, int first, int last); int main(void){ int coins[10] = {2,2,1,2,2,2,2,2,2,2}; int tmp = getCounterfeitCoin(coins, 0, 9); printf(\u0026#34;第 %d 個是偽幣\\n\u0026#34;,tmp+1); return 0; } int getCounterfeitCoin(int *coins, int first, int last){ int firstSum=0; int lastSum=0; int i; // 只剩兩枚硬幣 if(first == last -1){ if(coins[first] \u0026lt; coins[last]) return first; return last; } // 偶數枚硬幣 if ((last-first+1)%2 == 0){ for(i=first; i\u0026lt;first+(last-first)/2+1; i++){ firstSum += coins[i]; } for(i=first+(last-first)/2+1; i\u0026lt;last+1; i++){ lastSum += coins[i]; } if(firstSum \u0026lt; lastSum){ return getCounterfeitCoin(coins, first, first+(last-first)/2); }else{ return getCounterfeitCoin(coins, first+(last-first)/2+1, last); } }else{ // 奇數枚硬幣 for(i=first; i\u0026lt;first+(last-first)/2; i++){ firstSum += coins[i]; } for(i=first+(last-first)/2+1; i\u0026lt;last+1; i++){ lastSum += coins[i]; } if(firstSum \u0026lt; lastSum){ return getCounterfeitCoin(coins, first, first+(last-first)/2-1); }else if(firstSum \u0026gt; lastSum){ return getCounterfeitCoin(coins, first+(last-first)/2+1, last); }else{ return first+(last-first)/2; } } } ","date":"2023-05-18T20:17:35+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/109/","title":"演算法 偽幣問題 (分治法)"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 問題描述 在一塊電路板的上下兩端分別有 n 個接線柱。根據電路設計，用 $(i, \\pi(i))$ 表示將上端接線柱 i 與下端接線柱 $\\pi(i)$ 相連，稱其為該電路板上的第 i 條連線\n下圖所示的 $\\pi(i)$ 排列為 $\\{8, 7, 4, 2, 5, 1, 9, 3, 10, 6\\}$。對於任何 $1 \\le i \u003c j \\le n $ ，第 i 條連線和第 j 條連線相交的充要條件是 $\\pi(i)\u003e\\pi(j)$\n在製作電路板時，要求將這 n 條連線分佈到若干絕緣層上，在同一層上的連線不相交，現在要確定將哪些連線安排在一層上，使得該層上有盡可能多的連線，即確定連線集 $Nets=\\{ (i,\\pi(i)),1\\le i\\le n \\}$ 的最大不相交子集\n問題分析 記 $N(i,j)=\\{ t\\|(t,\\pi(t))\\in Nets, t\\le i, \\pi(t) \\le j \\}$ 。$N(i,j)$ 的最大不相交子集為 $MNS(i,j)$ ，$size(i,j)=\\|MNS(i,j)\\|$\n經分析，該問題具有最佳子結構性質。對於規模為 n 的電路佈線問題，可以建構如下遞迴式\n$$ \\begin{align*} \u0026(1) \\ 當 \\ i=1\\ 時， size(1,j)= \\begin{cases} 0, \u0026 \\text{j\u003c$\\pi$(1)} \\\\ 1, \u0026 \\text{其他情況} \\end{cases} \\\\ \u0026(2) \\ 當 \\ i\u003e1\\ 時， size(i,j)= \\begin{cases} size(i-1,j), \u0026 \\text{j\u003c$\\pi$(i)} \\\\ max{size(i-1,j),size(i-1,\\pi(i)-1)+1}, \u0026 \\text{其他情況} \\end{cases} \\end{align*} $$C 程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #define N 10 // 問題規模 // 求最大不相交連接數 void maxNum(int pi[], int **size); // 建構最大不相交連接集合，net[i]表示最大不相交子集中第i條連線的上端接線柱的序號 int constructSet(int pi[], int **size, int *net); int main(void){ // 索引從1開始 int pi[N+1] = {0, 8, 7, 4, 2, 5, 1, 9, 3, 10, 6}; int net[N]; int **size; size = (int**)malloc(sizeof(int*)*(N+1)); for(int i=0;i\u0026lt;N+1;i++) size[i]=(int*)malloc(sizeof(int)*(N+1)); maxNum(pi, size); int m = constructSet(pi, size, net); printf(\u0026#34;最大不相交連接數為：%d\\n\u0026#34;,m); printf(\u0026#34;包含的連線為：\\n\u0026#34;); for(int i=0; i\u0026lt;m; i++){ printf(\u0026#34;(%d,%d)\\n\u0026#34;, net[i], pi[net[i]]); } } void maxNum(int pi[], int **size){ // size[i][j]: 上下端分別有i個和j個接線柱的電路板的第一層最大不相交連接數 int i,j; // when j\u0026lt;pi(1) for(j=0; j\u0026lt;pi[1]; j++) size[1][j]; // when j\u0026gt;=pi(1) for(j=pi[1]; j\u0026lt;=N; j++) size[1][j]; for(i=2; i\u0026lt;N; i++){ // when j\u0026lt;pi(i) for(j=0; j\u0026lt;pi[i]; j++) size[i][j] = size[i-1][j]; // when j\u0026gt;=c[i] for(j=pi[i]; j\u0026lt;=N; j++) size[i][j]=size[i-1][j]\u0026gt;=size[i-1][pi[i]-1]+1 ? size[i-1][j] : size[i-1][pi[i]-1]+1; } // 最大連接數 size[N][N] = size[N-1][N]\u0026gt;=size[N-1][pi[N]-1]+1 ? size[N-1][N] : size[N-1][pi[N]-1]+1; } // 建構最大不相交連接集合，net[i]表示最大不相交子集中第i條連線的上端接線柱的序號 int constructSet(int pi[], int **size, int *net){ int i; int j=N; int m=0; // 記錄最大連接集合中的接線柱 for(i=N; i\u0026gt;1; i--){ // 遞減 // (i,pi[i])是最大不相交子集的一條連線 if(size[i][j] != size[i-1][j]){ net[m++]=i; // 將i記錄到陣列net中，連線數自增1 j=pi[i]-1; // 更新擴充連線柱區間 } } // when i=1 if(j\u0026gt;=pi[1]) net[m++] = 1; return m; } 其他 在搜尋過程中發現已有的文章： 算法设计与分析——电路布线（动态规划） 參考文章 LaTeX公式手册 Typora中使用LaTeX：多行公式左对齐 用malloc动态申请一个二维数组的三种方法 ","date":"2023-05-16T17:53:31+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/106/","title":"演算法 電路佈線問題 (動態規劃)"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 第十二章 管理磁碟和檔案系統 12.1 了解磁碟儲存體 在大多數現代作業系統中，資料儲存體的基本運作原理都是相同的。磁碟用作永久儲存體，而 RAM (Random Access Memory，隨機存取記憶體) 和交換空間則用作臨時儲存體。例如，當執行一條指令時，該指令將從硬碟複製到 RAM，以便電腦處理器 (CPU) 可以更快地存取該指令。\n相對於從硬碟存取資料，CPU 可以更快地從 RAM 存取資料。但因為 RAM 造價過高，且斷電即清除資料，硬碟容量遠大於 RAM。\n當執行太多程序或執行了一個帶有記憶體洩漏的程序而將 RAM 填滿時，如果系統沒有提供一種擴展系統記憶體的方法，則會導致新程序失敗，於是便有了交換空間。採用一些演算法將一些資料從 RAM 中換到磁碟中，在需要時再換回去。\n當需要在不同類型的作業系統之間交換檔案時，通常採用 VFAT 檔案系統。\n12.2 對硬碟進行分割 變更分割區可能導致系統無法啟動，建議先拿空硬碟熟練掌握後再實際應用。\n12.2.1 理解分割區表 從傳統上來說，PC 架構的電腦使用 MBR (Master Boot Record，主引導紀錄) 分割區表來儲存關於硬碟分割區大小和佈局資訊。然而，近年來，一種被稱為 GUID (Global Unique Identifier) 分割區表的新標準在部分 UEFI 電腦架構的電腦上得到了應用，從而取代了較老的 BIOS 系統啟動方法。\nMBR 規範所固有的限制帶來了對 GUID 分割的需求。MBR 分割區的大小被限制在 2TB，而 GUID 分割區可以建立最大 9.4ZB 的分割區。\nfdisk 指令不支援 GPT 分割，可以使用 parted 指令。\n12.2.2 查看磁碟分割區 fdisk -l /dev/sda 或 parted -l /dev/sdb\n由 sd? 裝置 (如 sda、sdb 等) 所表示的 SCSI 或 USB 儲存裝置最多可以有 16 個次要裝置 (比如主 /dev/sdc 裝置以及 /dev/sdc1 到 /dev/sdc15)，所以共有 15 個分割區。\n由 nvme 裝置 (如 nvme0、nvme1 等) 所表示的 NVMe SSD 儲存裝置可以劃分一個或多個命名空間 (大多數裝置只使用第一個) 和分割區，例如 /dev/nvme0n1p1 表示第一個 NVMe 裝置上第一個命名空間的第一個分割區。\n對於 x86 電腦，磁碟最多可以有 4 個主要分割區。所以如果想要 4 個以上的分割區，至少有一個分割區是延伸分割區。四個主要分割區外的任何分割區都是邏輯分割區，使用了來自延伸分割區的空間。\n12.2.3 建立單一分割區硬碟 一般添加一個儲存媒介的過程：\n安裝新的硬碟或插入新的 USB 隨身碟。 對新硬碟進行分割。 在新硬碟上建立檔案系統。 掛載檔案系統。 如果使用 parted 指令進行修改，請謹慎執行每一步，因為 parted 指令的變更會立即生效。 而 fdisk 指令是可撤銷的，只有在確定應用變更時才會實際變更。\n資料無價，謹慎操作。\n確認新增加的裝置名稱。\n方法有許多，例如查看系統日誌：\njournalctl -f\n例如分配的名稱為 /dev/sdb。\n如果裝置自動掛載需要先卸載。\n查看是否掛載 /dev/sdb：mount | grep sdb\n卸載分割區：umount /dev/sdb1\n使用 parted 指令建立分割區。\nparted /dev/sdb\n執行後將處於 parted 指令模式，可以使用 parted 單一字母指令設定來使用分割區。\n4.刪除分割區。\n單一指令 `p` 列出所有分割區。 使用 `rm` 指令，按下 Enter 後輸入相對應 `Number` 即可刪除某個分割區。 建立 GPT 分割區表。\n使用指令 mklabel gpt。\n建立新分割區。\n輸入 mkpart 指令，系統會提示輸入分割區名稱、檔案系統類型，然後是分割區的開始和結束。\n例如命名 yexca-UDisk，檔案類型為 xfs，分割區從 1MB 開始，到 123GB 結束：\n1 2 3 4 5 (parted) mkpart Partition name? []? yexca-UDisk File system type? [ext2]? xfs Start? 1 End? 123GB 檢查分割區是否正確建立。\n單一指令 p 列出所有分割區。\n分割區建立完成後需要在分割區上建立檔案系統。\n例如建立 XFS 檔案系統：mkfs -t xfs /dev/sdb1\n若沒有 -t 選項，預設建立 EXT2 檔案系統。\n掛載檔案系統。\n1 2 3 4 # 建立掛載資料夾 mkdir /mnt/tmp # 掛載 /dev/sdb1 到 /mnt/tmp mount /dev/sdb1 /mnt/tmp 卸載檔案系統。\n使用指令 umount /dev/sdb1\n一般來說，插入 USB 裝置會自動掛載。\n如果需要手動掛載，可在 /etc/fstab 添加一行：\n1 /dev/sdb1 /mnt/tmp xfs defaults 0 1 共六段：\n分割區 掛載的資料夾 檔案系統 分割區啟動時掛載 是否使用 dump 指令備份分割區檔案 (0 為不備份) 在一定的掛載數量之後對分割區進行錯誤檢查 12.2.4 建立多重分割區磁碟 使用 fdisk 指令介紹。\n進入 fdisk 指令模式。\nfdisk /dev/sdb\n建立分割區。\n單一指令 n，然後選擇主要分割區 p 或延伸分割區 e，選擇分割區位置 (預設即可)。\n然後是分配的空間，起始空間可以預設，按下 Enter 後輸入結束空間：例如分配 5 GB 空間則輸入 +5G，若直接輸數字則會被認為是磁區。\n第四個分割區，即延伸分割區，分配空間可以兩次都是預設。\n檢查分割區。\n單一指令 p。\n預設的分割區類型是 Linux，如果想要轉換分割區類型。\n使用指令 t，選擇分割區數，然後輸入 L 查看分割區類型列表，找到十六進位碼，然後輸入以變更。\n檢查變更並儲存變更。\n單一指令 p 以檢查，單一指令 w 以儲存變更。\n變更完畢後，檢查核心是否知道對分割區表的變更。\n1 2 3 4 5 grep sdb /proc/partitions # 如果沒有輸出預期的結果，執行以下指令 partprobe /dev/sdb # 再次檢查 grep sdb /proc/partitions 建立檔案系統。 1 2 3 4 5 6 7 8 9 10 # 建立 EXT4 檔案系統 mkfs -t ext4 /dev/sdb1 # 建立交換空間 mkswap /dev/sdb2 # 建立 EXT2 檔案系統 (預設值) mkfs /dev/sdb3 # 建立 VFAT 檔案系統 mkfs -t vfat /dev/sdb4 # 使該分割區成為 LVM 實體卷宗 pvcreate /dev/sdb5 12.3 使用邏輯卷宗管理分割區 如果磁碟空間不足，恐怕只能將資料複製到另一個更大的磁碟中，但該過程需要停機且效率低下。\nLVM (Logical Volume Management，邏輯卷宗管理) 可採用靈活且高效的方式處理變更儲存體的需求。透過使用 LVM，可將實體磁碟分割區添加到被稱為 卷宗群組 的空間池。邏輯卷宗根據需要從卷宗群組分配空間。\n12.3.1 檢查現有的 LVM 使用指令 fdisk -l /dev/sda 查看是否存在 Linux LVM 分割區，假設 /dev/sda2 為 LVM 分割區。\n查看該 LVM 分割區是否在 LVM 群組中使用。\npvdisplay /dev/sda2\n假設卷宗群組 (VG Name) 是 vg_abc，查看卷宗群組的資訊。\nvgdisplay vg_abc\n可以從實體卷宗使用的最小儲存單位是 PE (Physical Extent) 大小。\n查看卷宗群組的 PE 分配位置。\nlvdisplay vg_abc\n輸出將展示多個邏輯卷宗名稱，這些邏輯卷宗可以和實體卷宗一樣直接使用名稱進行掛載。\n12.3.2 建立 LVM 邏輯卷宗 LVM 邏輯卷宗的使用是由上而下進行的，而建立 LVM 邏輯卷宗的過程則是由下而上進行。首先建立一個或多個實體卷宗 (PV)，然後使用實體卷宗建立卷宗群組 (VG)，最後從卷宗群組建立邏輯卷宗 (LV)。\n準備一個有 LVM 分割區的儲存裝置。\n建立過程 12.2.4 有提及。\n將該實體卷宗加入卷宗群組。\nvgcreate myvg0 /dev/sdb5\n查看卷宗群組。\nvgdisplay myvg0\n若分割區為 400M，可以使用 396M 空間 (以 4M 為單位)。\n1 2 3 4 5 6 # 從卷宗群組部分空間建立一個邏輯卷宗，例如建立 1G 邏輯卷宗 lvcreate -n name -L 1G myvg0 # 查看該邏輯卷宗是否存在 ls /dev/mapper/myvg0* # 若輸出以下內容則建立成功 /dev/mapper/myvg0-name 放入檔案系統並掛載。 1 2 3 4 5 6 7 8 # 建立 EXT4 檔案系統 mkfs -t ext4 /dev/mapper/myvg0-name # 建立掛載資料夾 mkdir /mnt/tmp # 掛載 mount /dev/mapper/myvg0-name /mnt/tmp # 檢查是否掛載成功 df -h /mnt/tmp 或者也可以寫入 /etc/fstab 以自動掛載。 12.3.3 擴展 LVM 邏輯卷宗 如果用完邏輯卷宗的空間，可添加空間而不必卸載該邏輯卷宗。為此，卷宗群組中必須有可用的空間，然後擴展邏輯卷宗。\n檢查剩餘空間。 1 2 3 4 # 檢查卷宗群組可用空間 vgdisplay myvg0 # 檢查邏輯卷宗可用空間 df -h /mnt/tmp 擴展邏輯卷宗。\nlvextend -L +1G /dev/mapper/myvg0-name\n調整檔案系統大小。\nresize2fs -p /dev/mapper/myvg0-name\n檢查是否調整成功。\ndf -h /mnt/tmp\n12.4 掛載檔案系統 事實上在上兩節中已經涉及了掛載檔案系統指令 mount 以及自動掛載設定 (檔案 /etc/fstab)。\n12.4.1 支援的檔案系統 輸入指令 cat /proc/filesystems 以查看支援的檔案系統類型，以下僅部分。\n檔案系統 描述 ext4 流行 EXT3 檔案系統的繼承者。支援最大 1EB 的卷宗以及最大 16 TB 的檔案 iso9660 從 High Sierra 檔案系統 (CD-ROM 的原始標準) 演變而來。資料 CD-ROM 通常使用該檔案系統 Minix 最初用於 UNIX 的 Minix 版本。支援最多只有 30 個字元的檔案名稱 msdos MS-DOS 檔案系統類型，可用於掛載來自 Windows 作業系統的軟碟 vfat Microsoft 擴展的 FAT 檔案類型 exfat 為 SD 卡、USB 隨身碟和其他快閃記憶體優化的擴展 FAT 檔案系統 proc 並非真正的檔案系統。是 Linux 核心的檔案系統介面。/proc 的掛載點應該是一個 proc 檔案系統。許多公用程式依賴 /proc 才能存取 Linux 核心資訊 ReiserFS 日誌檔案系統。曾經多個 Linux 發行版本的預設檔案系統類型，但如今是 EXT 和 XFS swap 用於交換空間 squashfs 壓縮且唯讀的檔案系統類型 NFS Network Filesystem，用於在其他 Linux 或 UNIX 電腦上掛載檔案系統 ntfs Windows NT 檔案系統 xfs 最早由 Silicon Graphics 開發的高效能檔案系統，可很好地使用大型檔案 gfs2 一種共享磁碟檔案系統，允許多台電腦使用相互溝通的共享磁碟，而不必透過網路檔案系統層，如 CIFS、NFS 等 輸入 man fs 了解更多 Linux 檔案系統相關資訊。\n12.4.2 啟動交換空間 1 2 3 4 5 6 # 查看交換空間數量 free -m # 建立交換空間 mkswap /var/opt/myswap # 啟用交換空間 swapon /var/opt/myswap 如果在 /etc/fstab 添加了交換空間相關條目，如：\n/var/opt/myswap swap swap defaults 0 0\n可以使用 swapon -a 啟用。\n12.4.3 停用交換空間 swapoff /var/opt/myswap\n12.4.4 使用 fstab 檔案定義可掛載的檔案系統 12.2.3 已介紹，不過欄位二可以使用 UUID 而非裝置名稱，因為裝置名稱是可變的。\n查看 UUID：blkid\n12.4.5 使用 mount 指令掛載檔案系統 同樣在 12.2.3 已介紹。\n12.4.6 以迴送方式掛載磁碟映像檔 也就是將 ISO 映像檔掛載。\n1 2 3 4 # 建立掛載資料夾 mkdir /mnt/tmp # 掛載 mount -o loop name.iso /mnt/tmp 12.4.7 使用 umount 指令 可以輸入裝置分割區名稱或目錄名稱。\n裝置分割區名稱：umount /dev/sdb1\n目錄名稱：umount /mnt/tmp\n通常，最好使用目錄名稱。\n如果一個目錄正忙碌而無法被卸載，可以：\n延遲卸載：umount -l\n強制卸載：umount -f\n12.5 使用 Cockpit 管理儲存體 圖形使用者介面，啟用請參考第八章。\n","date":"2023-01-03T13:37:48+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/85/","title":"Linux 學習 第十二章 管理磁碟和檔案系統"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 前言 最近？拜讀了《漫畫數位電路》一書，在此簡要記錄。\n書中許多內容並未收錄於此。\n前情提要 數位電路分為 組合電路 與 時序電路。\n組合電路：由目前輸入資訊的組合決定輸出的電路。\n時序電路：帶有「記憶」的電路。\nMIL 符號 邏輯電路的 及閘 與 或閘 符號引申為多個輸入一個輸出。\n符號含義 及閘 (ALL)：多個輸入全為 1，輸出為 1。\n或閘 (EXIST)：若有一個輸入為 1，輸出為 1。\n電路線 有 圓圈 的為 低電位 (0、L)。\n無 圓圈 的為 高電位 (1、H)。\n組合電路的製作 多數決投票電路 多位投票人從兩個結果中選出一個。\n列出真值表，即所有可能發生的情況。\n在真值表 H 輸出處加上底線。\n「輸入線」與「將輸入取反的線」架設框架。\n兩條向下的電路線，第二條為反相線，即從第一條連接 反閘 到第二條。\n連接到 AND (及閘)\n輸入為 L 時，從將輸入取反處開始 (第二列)。\n輸入為 H 時，從最開始的地方畫線 (第一列)。\n然後，接入 AND。\n重複此過程，完成第二步所畫的所有線。\n將 AND 的所有輸出連接到 OR。\n電路的化簡 數位電路設計流程：釐清問題 - 真值表 - 化簡 - 繪製電路。\n透過 卡諾圖 進行化簡。\n真值表轉換為卡諾圖。\n製作真值表時，欄位從最高位元開始，例如 [C、B、A]，結果為 Z。\n卡諾圖是二維的真值表，通常用 0 與 1 表示電位。\n如果三個輸入，可以將行設為 B、A，列設為 C，然後將結果填入二維表。\n化簡前須知\n卡諾圖的 左右 與 上下 都是相連的，因為卡諾圖的橫向與縱向都是按 位元 (1 位) 變化的。\n化簡\n將相鄰的 1 劃分為一個集合。\n尋找行與列的共同點。\n若共同點為某值為 0，則使用 負運算 (或反運算)，即字母上方加一橫槓。\n範例\nC\\BA 00 01 11 10 0 1 1 1 上表中 共同點為 C 為 0，A 為 1，則運算式為 !C * A。 化簡的規則 集合的形狀只能是長、寬為 1、2、4 的矩形 (或正方形)。\n集合可以相互重疊。\n集合的個數越少，面積越大越好。\n註：左右和上下可以構成一個集合；如果無法進一步「形成集合」，則表示電路已無法再化簡。\n化簡後繪製電路圖，只需將所有運算式依照上一步驟的繪圖步驟 (從第三步開始) 進行即可。\n電路的忽略 在剛開始確定輸入時，因為二進位數的特性，可能會有一些不需考慮的輸入。\n例如輸入為月份，需要使用四位二進位數，總共有 16 個輸入，其中 0、13、14、15 均為不需考慮的輸入。\n這類輸入在卡諾圖中可以使用 - 代替，可以納入集合進行化簡。\n時序電路的製作 時序電路需要 組合電路 與 觸發器。\n關於 時序電路 的「記憶」，例如自動販賣機在投幣時會記錄目前投幣總數，若無記憶，則僅有最後一個硬幣的面額。\n引入一個觸發器，例如 時脈 (CLK)，僅在 CLK 觸發時，輸入才會對輸出有影響，否則輸出保持不變。\n以繪製電子骰子為例。\n繪製狀態轉移圖\n隨著時間的變化，電子骰子如何變化？\n若停止為低電位，從 1 開始到 6 再到 1。\n如果為高電位，則在某點一直保持停止。\n用二進位數來表示狀態\n將每種情況或者說狀態使用二進位表示，然後繪製出 狀態轉移表。\n透過狀態轉移表繪製電路，可以使用 D 觸發器儲存狀態。\n設計組合電路\n從 目前的狀態 決定 下一個狀態，實際上就是 組合電路。\n","date":"2022-12-04T16:54:29+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/80/","title":"歐姆社漫畫數位電路讀後"},{"content":" 📢 本文由 gemini-2.5-flash-lite 翻譯 使用 Windows11 部署，其他系統 (如 Linux ) 請參考： AUTOMATIC1111/stable-diffusion-webui: Stable Diffusion web UI 空間佔用 程式：5.3GiB (不含模型)\n運行：5.5GiB 以上\n請確保 C 碟空間至少 6GiB 再運行，否則電腦可能黑屏卡死\n環境 首先是網路環境，請確保連接上網際網路\nGit\n官網： https://git-scm.com/ Python 3.10.6 以上 (最新版本可能不穩定)\n建議 3.10.8： https://www.python.org/downloads/release/python-3108/ 勾選 Add python.exe to PATH\n模型下載\n官方模型 (偏寫實)\n透過磁力下載（請使用正規種子客戶端）\n1 magnet:?xt=urn:btih:3a4a612d75ed088ea542acac52f9f45987488d1c\u0026amp;dn=sd-v1-4.ckpt\u0026amp;tr=udp%3a%2f%2ftracker.openbittorrent.com%3a6969%2fannounce\u0026amp;tr=udp%3a%2f%2ftracker.opentrackr.org%3a1337 其他下載方式\n訪問 AUTOMATIC1111/stable-diffusion-webui Wiki Waifu 模型(二次元啦)\n訪問 hakurei/waifu-diffusion-v1-3 at main 選擇下載\n其他\nStable Diffusion Models (cyberes.github.io) 克隆倉庫 選擇一個合適的位置，右鍵選擇 在終端機中開啟 ，然後輸入以下指令\n1 git clone https://github.com/AUTOMATIC1111/stable-diffusion-webui.git 更新時可以進入該目錄 (stable-diffusion-webui) 後使用 git pull 指令\n設定 將下載的模型放入 /models/Stable-diffusion 目錄\n設定 /webui-user.bat 檔案 在set VENV_DIR= 後任意輸入字串，然後儲存退出\n運行 /webui-user.bat 檔案\n下載檔案過大 (6GiB 左右) ，可能會運行較長時間，期間無進度條提示（若感覺程式終止之類的，可透過網路頻寬使用情況以判斷是否正在下載）\n如果您的顯示卡是 GTX1660 或者算出來的圖是黑色的\n編輯 webui.bat ，在開頭加入以下文字\n1 set COMMANDLINE_ARGS=--precision full --no-half 其他 詳細了解： hua1995116/awesome-ai-painting: AI绘画资料合集（包含国内外可使用平台、使用教程、参数教程、部署教程、业界新闻等等） stable diffusion tutorial、disco diffusion tutorial、 AI Platform 訓練模型： NovelAI hypernetwork 自訓練教程 - 知乎 NovelAI軟體獲取 - novelai 資源站 咩小咩壁紙|NovelAI資源站 關鍵字例子\n1 2 NSFW, Prhololive, uruha_rushia, 1girl, bangs, bare shoulders, red eyes, blue dress, blue green hair, blue sleeves, blush, bow, breasts, chick, collarbone, detached collar, detached sleeves, double bun, eyebrows visible through hair, frills, hair orhament, medium hair, off-shoulder dress 參考文章 最火的AI绘画教程！免费开源，包教会 - 零度解说 【心得】(NSFW) AI 色圖製作體驗 + 關鍵字 @場外休憩區 哈啦板 - 巴哈姆特 ","date":"2022-10-30T16:23:07+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/77/","title":"NovelAI 繪圖 (WebUI)"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 引言 使用虛擬機安裝，軟體為 Fedora 的 盒子\n安裝前準備 下載映像檔 從 官方下載頁面 下載，推薦使用 BT 下載 (請使用正規 torrent 客戶端，例如 qBittorrent )\n然後放到虛擬機裡\n驗證開機模式 列出 efivars 目錄\n1 ls /sys/firmware/efi/efivars 如果正確顯示目錄並且沒有回報錯誤，則系統以 UEFI 模式開機，如果目錄不存在，則可能以 BIOS 模式開機 (或 CSM 模式)\n這個虛擬機中使用 BIOS 模式\n連接到網際網路 預設開啟網路介面與 DHCP 服務，無需設定\n更新系統時間 開啟與網路時間伺服器 (NTP) 同步\n1 timedatectl set-ntp true 可使用 timedatectl status 檢查服務狀態\n建立硬碟分割 使用了傳統的 fdisk 指令分割 (MBR 分割)，因為開機模式是 BIOS，採用官方的分割範例，只做了兩個分割區 (swap 交換分割區與其他)\n使用 fdisk -l 列出所有磁碟 (以 rom、loop 或 airoot 結尾的裝置可以忽略)\n使用 fdisk /dev/裝置名 開始分割\n指令 描述 n 建立分割區 p 檢查分割區 t 變更分割區類型 w 儲存變更 指定分割區大小使用 ++num+K/M/G/T/P ，若無後綴 (K/M/G/T/P) 則分配磁區\n格式化分割區 建立交換分割區 1 mkswap /dev/交換空間分割區 建立檔案系統 根據檔案系統不同指令不同，例如 ext4 檔案系統\n1 mkfs -t ext4 /dev/分割區 掛載分割區 將根分割區掛載到 /mnt，若有多個分割區，請務必先掛載根分割區\n1 mount /dev/分割區 /mnt 啟用交換空間\n1 swapon /dev/交換空間分割區 安裝 選擇映像檔 檔案 /etc/pacman.d/mirrorlist 定義了套件從何處下載，在連接到網際網路後會自動更新，也可手動更改，我就不更改了\n安裝套件 使用 pacstrap 腳本，安裝 base 套件和 Linux 核心以及 vim，如果安裝其他套件，在下方指令後加上名稱即可，當然也可以之後使用 pacman 安裝\n1 pacstrap /mnt base linux vim 設定系統 Fstab /etc/fstab 檔案描述系統啟動時如何自動掛載分割區，可以使用以下指令自動產生 (使用 -U 或 -L 選項設定 UUID 或磁碟區標籤，使用 UUID 以確保系統開機不會出錯)\n1 genfstab -U /mnt \u0026gt;\u0026gt; /mnt/etc/fstab 檢查自動設定是否正確\n1 cat /mnt/etc/fstab Chroot Chroot 至新安裝的系統\n1 arch-chroot /mnt 時區 以上海時間為例\n1 ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime 產生 /etc/adjtime\n1 hwclock --systohc 此時可使用指令 date 查看時間是否正確\n本土化 編輯 /etc/locale.gen ，取消 en_GB.UTF-8 的註解\n然後產生 locale 資訊\n1 locale-gen 建立 /etc/locale.conf 檔案，編輯 LANG 變數，例如 LANG=en_GB.UTF-8\n網路設定 建立 /etc/hostname 檔案並輸入主機名稱\n因為虛擬機使用 DHCP，就不 設定網路 了\nRoot 密碼 1 passwd 安裝開機載入程式 一般安裝 GRUB，我使用的虛擬機是 BIOS+MBR，安裝 grub 套件\n1 pacman -S grub 安裝 grub (下方指令 /dev/裝置，請注意不是分割區)\n1 grub-install --target=i386-pc /dev/裝置 產生設定檔\n1 grub-mkconfig -o /boot/grub/grub.cfg 重新啟動 使用 exit 或 Ctrl+D 離開 chroot 環境\n使用 umount -R /mnt 卸載被掛載的分割區\n重新啟動 reboot\n參考資料 Installation guide (繁體中文) - ArchWiki ","date":"2022-10-02T13:39:26+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/76/","title":"虛擬機中 Arch Linux 安裝紀錄"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 第四章 在檔案系統中移動 Linux 檔案系統儲存了電腦上所有的資訊\n目錄 描述 /bin 包含常見的 Linux 使用者指令，例如 ls、sort、date 和 chmod /boot 包含可開機的 Linux 核心、初始 RAM 磁碟和開機載入程式的設定檔 (GRUB) /dev 包含用來表示系統中裝置存取點的檔案。這些裝置包括終端裝置 (tty*) 、硬碟驅動器 (hd* 或 sd*) 、RAM (ram*) 以及 CD-ROM (cd*) 。使用者可以直接透過這些裝置檔案存取相應的裝置；然而，應用程式通常會對終端使用者隱藏實際的裝置名稱 /etc 包含管理設定檔。其中大多數檔案都是純文字檔案，只要使用者擁有適當權限，就可以使用任何文字編輯器編輯這些設定檔 /home 包含分配給每個帶有登入帳號的一般使用者的目錄 (root 使用者是一個例外，使用 /root 作為家目錄) /media 為自動掛載裝置 (特別是行動媒體) 提供了一個標準位置。如果媒體有一個磁碟標籤，那麼通常會使用該標籤名稱作為掛載點 /lib 包含 /bin 和 /sbin 目錄中的應用程式啟動系統所需的共享函式庫 /mnt 在該目錄被標準的 /media 目錄取代之前，/mnt 目錄是許多裝置常見的掛載點。一些可開機的 Linux 系統仍使用該目錄來掛載硬碟分割區和遠端檔案系統。此外很多人也在使用該目錄臨時掛載那些不需要永久掛載的本機或遠端檔案系統 /misc 該目錄有時用來根據請求自動掛載檔案系統 /opt 用來儲存附加應用程式軟體的目錄結構 /proc 包含關於系統資源的資訊 /root 表示 root 使用者的家目錄。因安全原因，沒有位於 /home /sbin 包含管理指令和守護行程 (daemons) /sys 包含用於調校區塊儲存和管理 cgroups 的參數 /tmp 包含應用程式使用的暫存檔案 /usr 包含使用者文件、遊戲、圖形檔案 (X11) 、函式庫 (lib) 以及其他不需要在啟動過程中使用的指令和檔案。/usr 目錄中的檔案在安裝完畢後不可更改。理論上來說，/usr 可以採用唯讀方式掛載 /var 包含不同應用程式所使用的資料目錄。特別可以在該目錄中放置作為 FTP 伺服器 (/var/ftp) 或 Web 伺服器 (/var/www) 共享的檔案。還包含所有的系統日誌檔案 (/var/log) 以及緩衝檔案 (/var/spool，如 mail、cups 和 news) 。/var 目錄所包含的目錄和檔案經常被修改。在伺服器電腦上，通常會建立一個 /var 目錄作為一個單獨的檔案系統，使用一個易於擴充的檔案系統 4.1 使用基本的檔案系統指令 cd 、pwd 、mkdir 、rmdir 、ls 、touch\n4.2 使用元字元和運算子 某些特殊字元被稱為元字元 (metacharacters) 或運算子 (operators)\n4.2.1 使用檔案比對元字元 元字元 描述 * 比對任何數量的字元 ? 比對任何一個字元 [\u0026hellip;] 比對括號之間的任一字元，可以包括一個連字號分隔的字母或數字範圍 例如 ls [a-g]* 列出以字母 a 到字母 g 開頭的檔案或目錄\n4.2.2 使用檔案重新導向元字元 元字元 描述 \u0026lt; 將檔案的內容導向到指令。指令的預設行為，可省略，例如使用 less bigfile 等同於 less \u0026lt; bigfile \u0026gt; 將指令的標準輸出導向到一個檔案。如果檔案存在將被覆寫 (覆蓋) 2\u0026gt; 將標準錯誤 (錯誤訊息) 導向到檔案 \u0026amp;\u0026gt; 將標準輸出和標準錯誤都導向到檔案 \u0026raquo; 將指令的輸出導向到一個檔案，並將該輸出添加到現有檔案的末尾 例如以下指令\n1 man chmod | col -b \u0026gt; /tmp/chmod 設定了手冊頁的格式 (使用 man 指令)，刪除了額外的退格鍵 (col -b) 並將輸出傳送到檔案 /tmp/chmod (如果檔案存在，則刪除之前的 /tmp/chmod 檔案)\n1 echo \u0026#34;Hello World!\u0026#34; \u0026gt;\u0026gt; ~/hello 將文字 Hello World! 添加到 ~/hello\n重新導向的另一種類型被稱為 here text (或者 here document) ，例如\n1 2 3 4 5 6 7 ed /etc/resolv.conf \u0026lt;\u0026lt; resendit a nameserver 100.100.100.100 . w q resendit 透過 ed 文字編輯器向 /etc/resolv.conf 檔案 (以 root 使用者執行的指令碼) 執行兩個 resendit 之間的內容 (範例為新增 DNS 伺服器的 IP 地址)\n4.2.3 使用括號擴充字元 透過使用大括號 {} 可以跨檔案名稱、目錄名稱或者指令中的其他參數擴充一組字元，例如\n1 touch memo{1,2,3,4,5} 將建立 memo1~memo5 共 5 個檔案\n1 touch {John,Bill,Sally}-{Breakfast,Lunch,Dinner} 將建立 9 個檔案\n1 touch {a..f}{1..5} 將建立 a1~f5 共 30 個檔案\n4.3 列出檔案和目錄 一般 ls 指令被設定別名為 ls --color=auto ，可透過下面指令查看別名\n1 alias ls 使用 ls -la 指令可以查看詳細資訊 (-l) 和所有檔案 (-a)\n欄位 檔案 目錄 1 權限 權限 2 連結到該項目的數量 連結到該項目的數量 3 檔案擁有者 目錄擁有者 4 檔案所屬群組 目錄所屬群組 5 檔案的位元組大小 包含該目錄資訊的檔案大小，非目錄包含檔案大小 6 最近一次修改的日期和時間 最近一次修改的日期和時間 7 檔案名稱 目錄名稱 註：\n時間和日期欄位的格式可以更改，根據 LANG 變數而定\n有時可執行檔權限為 s (-rwsr-sr-x) ，表示應用程式可被任何使用者存取，但執行行程的所有權為應用程式的使用者/群組，而不是啟動該指令的使用者\n如果目錄權限末尾是 t (drwxrwxr-t) ，則表示為該目錄設定了一個黏滯位 (sticky bit)。表明目錄的擁有者允許其他使用者添加檔案，但阻止刪除其他人添加的檔案\n透過為某一目錄分配一個 Set GID，該目錄中所建立的任何檔案都會被分配到與目錄群組相同的群組。如果在一個目錄上看到的是一個大寫 S 或 T 而不是執行位元，則意味著分別設定了 Set GID 或黏滯位，而由於某些原因執行位元沒有開啟\n如果權限末尾是加號 (-rw-rw-r-+) ，則說明在檔案上設定了擴充屬性，如 ACL 或 SELinux。末尾的點表示在檔案中設定了 SELinux\n透過 cd ~yexca 可存取 yexca 的家目錄，cd - 以返回之前的工作目錄 ($OLDPWD 指向的目錄) ，而 `cd .` 指向目前工作目錄 ($PWD)\nls 指令：-t 以最新修改時間順序顯示檔案；-F 在目錄後添加 / ，可執行檔後添加 * ，符號連結旁顯示 @；--hide=yexca 隱藏顯示 yexca 這個檔案或目錄；-S 按檔案大小列出檔案；-d 顯示該目錄的資訊而非目錄所包含的檔案和目錄\n4.4 了解檔案權限和所有權 對於 ls -l 指令第一欄\n第一位為檔案類型\n字母 類型 - 檔案 d 目錄 l 符號連結 b 區塊裝置 c 字元裝置 s Socket 套接字 p 具名管道 (Named pipe) 後九位為權限，前三位為使用者 (u) 的，中三位為所在群組 (g) 的，後三位為其他人 (o) 的\n對於檔案和目錄，權限位元含義略有不同\n權限 檔案 目錄 Read 檢視檔案內容 檢視目錄所包含的檔案和子目錄 Write 更改檔案內容，重新命名或刪除檔案 向目錄添加檔案或子目錄。刪除目錄中的檔案或子目錄 Execute 將檔案作為一個程式執行 將目錄更改為目前目錄，搜尋目錄或執行該目錄中一個程式，存取目錄中檔案的檔案中繼資料 (檔案大小、時間戳記等) 可透過 ls -ld 指令查看任何檔案或目錄的權限\n在 Fedora 和 Red Hat Enterprise Linux 中，當添加了一個新使用者時，預設情況下該使用者被分配到一個同名的群組中，這種分配群組的方法被稱為使用者專用群組方案\n4.4.1 使用指令 chmod (數字) 更改權限 r = 4；w = 2；x = 1\n1 chmod -R 755 ~/myfile 更改 ~/myfile 下所有檔案和目錄 (-R) 和該目錄的權限為 755 (rwxr-xr-x)\n4.4.2 使用 chmod (字母) 更改權限 1 chmod ug+rx files 1 chmod -R o-x ~/myfile 4.4.3 使用 umask 設定預設的檔案權限 一般使用者建立檔案預設權限為 rw-rw-r\u0026ndash;，目錄為 rwxrwxr-x。對於 root 使用者分別為 rw-r\u0026ndash;r\u0026ndash; 和 rwxr-xr-x。這些預設值由 umask 值確定，輸入該指令即可查看值，例如 0002\n若暫時忽略第一個 0 (前導零) ，那麼 umask 值被視為對檔案完全開放權限 (666) 或者對目錄完全開放權限 (777) 。umask 值 002 生成對目錄權限 775，檔案為 644。預設情況下一般檔案的執行權限被關閉\n如果臨時更改 umask 值，直接 umask [權限] ，將權限值替換 [權限] ，例如 umask 000 然後建立的檔案和目錄權限分別為 -rw-rw-rw- 和 drwxrwxrwx\n如果永久更改需要向家目錄 .bashrc 檔案結尾處添加一條 umask 指令\n4.4.4 更改檔案所有權 僅 root 使用者可更改檔案所有權\n1 chown user:group /etc/file 將 /etc/file 改為 user 所有和 group 群組，可使用 -R 遞迴更改\n或者只更改所屬使用者 chown yexca /etc/file\n4.5 移動、複製和刪除檔案 mv、cp、rm、rmdir\nmv 指令透過添加 -i 或設定別名防止移動時覆寫已有檔案，或使用 -b 則若有同名檔案會先備份舊檔案後移動新檔案\ncp 指令使用 -a 將保持原本的日期/時間戳記\n使用 -f 以強制套用更改 (例如 rm -rf /*)\n","date":"2022-09-25T20:35:02+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/75/","title":"Linux 學習 第四章 在檔案系統中移動"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 引言 人嘛，有了比較好的就會追求更好的，慾望無窮無盡。本想弄台 NAS，奈何經濟實力不夠，於是透過四個專案在自己電腦弄了入口、動畫、漫畫以及音聲庫，那麼\n承接 上回 ，繼續折騰\n成品展示 全部使用 Docker 部署，理論上應該只要 Docker 支援的平台就能復現\n調整了網域為 link.start.icu，本來沒有 .icu，但瀏覽器無法解析，只能加上 (不過莫名變更好了吧)\n手機訪問圖片顯示中間的 (有一點不太理想)\n有時間把這東西部署到伺服器上搞個導航吧 (不過標題不能直接改有點麻煩，不想弄 JS)\n註：使用 Docker Desktop 部署，所以就沒有寫部署過程了，可看 上回 的部署，過程差不多\n登入 Docker Hub 貌似安裝 Docker 後使用 docker pull 要先登入\n首先到官網註冊帳號： Docker Hub 然後需要先進行初始化，執行命令\n1 gpg --generate-key 輸入相關資訊後注意輸出的 pub 下一行的一串字串，複製並替換為下述命令的 [pub]\n1 pass init [pub] 然後在 Docker Desktop 登入\n動畫 - Jellyfin Docker Hub： jellyfin/jellyfin 官網： Jellyfin: The Free Software Media System 1 docker pull jellyfin/jellyfin 不過封面圖片方面不太理想，個人不是用 NAS，懶得弄了\n可參考： 利用 Jellyfin + Bangumi 打造更舒適的動畫媒體庫 - 初之音 漫畫 - Komga Docker Hub： gotson/komga 官網： Komga 1 docker pull gotson/komga 註：漫畫過多掃描時可能會導致電腦很卡\n音聲 - kikoeru-express Docker Hub： muveex/kikoeru-express Github： kikoeru-project/kikoeru-express 我下載的是 0.6.2 版本 (話說這東西和某網站很像嘛)\n1 docker pull muveex/kikoeru-express:v0.6.2 本來看到文章想用 PLEX 的，但必須登入使用搞得有點不想用了，但介面看起來很好看，忍了。裝完後發現要加自己的媒體庫居然還要安裝它的閉源軟體，這東西可以存取檔案系統幾乎所有檔案 (但存取不了我掛載的) ，解除安裝了，可能我弄 NAS 才會再次使用吧\n引導 - Heimdall Docker Hub： linuxserver/heimdall/ 官網： Heimdall Application Dashboard 1 docker pull linuxserver/heimdall 另在 參考文章第二篇 有提到統一認證，不過我個人不太需要就沒弄了 (主要是看著就很複雜)\n後話 從這次折騰來看，可能並不需要為 NAS 的系統買單，硬體買電腦配件組個主機，軟體裝個 Linux 系統，透過各種開源專案想必應該也可以有不錯的體驗\n指令列操作不來可以裝一些輕量的 GUI，例如 Xface、JWM 之類的\n參考文章 談談如何使用 docker，搭建一台「群暉」_NAS 儲存_什麼值得買 NAS也能用上【統一認證】_NAS 儲存_什麼值得買 使用 Plex \u0026amp; Docker 搭建自己的媒體伺服器 - RIN\u0026rsquo;S HOME 利用 Jellyfin + Bangumi 打造更舒適的動畫媒體庫 - 初之音 ","date":"2022-09-16T15:00:01+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/73/","title":"個人內網折騰"},{"content":" 📢 本文由 gemini-2.5-flash-lite 翻譯 前言 啟用某外掛後台出現 502 錯誤。\n進入資料庫 選擇進入 wp_options 資料表。\n找到 active_plugins 項目，一般在第二頁。\n編輯此項目的 option_value 行。\n刪除不需要的外掛 注意：刪除前請務必備份！！！\n找到不需要的外掛名稱。\n刪除從 i: 開始到 ; 為止的字串，例如 i:1;s:23:\u0026quot;elementor/elementor.php\u0026quot;;\n更改序號，也就是 i: 後面的數字。\n更改總數，也就是最開頭 a: 後面的數字。\n參考文章 從資料庫停用單一 WordPress 外掛 - WordPress - GoDaddy 說明 SG ","date":"2022-09-15T22:17:02+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/72/","title":"WordPress 停用資料庫外掛"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 前言 為了在區域網路內更方便地看漫畫。\nIP 設定 路由器為 OpenWRT 系統。\n路由器設定 在 網路 - IP/MAC 綁定 將電腦綁定一個固定的 IP。\nFedora 設定 因為我設定的 IP 與自動分配的不一致（有線連接），故需要手動修改。\n在 網路 - 設定 的 身分 加上 MAC 位址，IPv4 改為 手動，位址依序為 IP、255.255.255.255、路由器 IP，DNS 加上 路由器 IP，未取消勾選自動。\n網域劫持 儘管可以透過 IP 直接存取，但是有一個網域名稱會更加好記吧。\n在路由器 網路 - 主機名稱 的 主機名稱 處填入網域名稱，IP 位址 處填入電腦的 IP。\n安裝 Docker 安裝了有 GUI 的 Docker Desktop。\n設定儲存庫 1 dnf -y install dnf-plugins-core 1 2 3 sudo dnf config-manager \\ --add-repo \\ https://download.docker.com/linux/fedora/docker-ce.repo 下載 RPM 套件 在 官網 Download 處 下載。\n下載完成後直接雙擊安裝。\n安裝 Komga Docker 設定 檔案共享設定 在 Docker Desktop 的 設定 - Resources - File sharing 加入漫畫路徑。\n註：如果共享的目錄在下次啟動時不存在 (未掛載)，Docker 將無法正常啟動。\n網路設定 不清楚是否非必須，在 設定 - Resources - Network 設定為自己的網段。\n命令列安裝 直接在 Shell 執行：\n1 2 3 4 5 6 7 8 docker run \\ --name=komga \\ --user 1000:1000 \\ -p 2333:8080 \\ -v /home/yexca/komga/config:/config \\ -v /home/yexca/komga/data:/data \\ --restart unless-stopped \\ gotson/komga:latest -p 前一個為本機映射埠號，後一個為容器埠號。\n-v 檔案映射，將本機的目錄 (/home/yexca/komga/config) 映射到容器的 (/config)。\n註：無法映射本機的隱藏檔案（以 . 開頭的檔案）。\nGUI 安裝 在上一步完成後，Docker Desktop 的 Images 會多出一個 gotson/komga，點擊 run，然後進行配置：\n第一行：名稱\nPorts：映射到本機的埠號，比如 80，這樣就可以直接以網域名稱存取了。\nVolumes：路徑映射。\nEnvironment variables：環境變數，此處用不到。\n檢查是否執行 使用指令查看：\n1 docker ps -a 防火牆配置 開啟埠號：\n1 firewall-cmd --zone=public --add-port=80/tcp 載入設定：\n1 firewall-cmd --reload 查看埠號開啟狀態：\n1 firewall-cmd --zone=public --query-port=80/tcp 可能需要新增服務：\n1 firewall-cmd --add-service=http 如果真的無法開啟就用 GUI 吧 (一開始就用會更快吧)：\n1 sudo yum install firewall-config 參考文章 Install Docker Desktop on Fedora - Docker Documentation 【Docker】Error response from daemon: invalid mount config for type \u0026ldquo;bind\u0026rdquo;: bind source path does not exist - Qiita Run with Docker - Komga 簡約但絕不簡單的 Komga - 老蘇的 blog fedora 28 , firewalld 防火牆控制，firewall-cmd 管理防火牆規則 - xuyaowen - 博客園 Fedora 防火牆配置 - 上官飛鴻 - 博客園 原神自動簽到 (Linux 伺服器 Docker) - yexca\u0026rsquo;Blog Fedora 打開 8080 端口_chunqi zhi 的博客 - CSDN 博客 ","date":"2022-09-14T18:47:16+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/71/","title":"Fedora 安裝 Komga 折騰紀錄"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 第三章 使用 shell 本章介紹的 Linux shell 稱為 Bash shell，其全稱為 Bourne Again shell。還有其他的 shell，例如在 BSD UNIX 使用者中流行的 C shell (csh)，以及在 UNIX System V 使用者中非常流行的 Korn shell (ksh)，Ubuntu 預設啟動 Dash shell (速度比 Bash 快)，還有 Tcsh shell (一種改進的 C shell) 和 Ash shell (與 Bourne shell 非常相似)。\n3.1 shell 和 終端機視窗 使用 終端機視窗 (Terminal 窗口) 透過執行的 GUI，可以打開一個終端機模擬程式 (有時也稱為 終端機視窗)，從而啟動一個 shell。\n大部分系統透過 Ctrl+Shift+T 快速鍵打開，Fedora 可在程式中尋找，或者按 alt+F2 後輸入 gnome-terminal。\n使用虛擬主控台 大多數有 GUI 的 Linux 系統在啟動時通常會執行多個虛擬主控台，虛擬主控台除了可以打開 GUI 之外，還可以打開多個 shell 工作階段。\n透過 Ctrl+Shift+F1~F6 可切換虛擬主控台。以 Fedora 為例，tty1 為 gdm (登入螢幕)，tty2 為第一個桌面，tty3 為第二個桌面 (純文字)，以此類推。\n命令提示字元 對於一般使用者來說，預設的提示字元是一個簡單的錢字號。\n$\n對於 root 使用者來說，預設的提示字元是一個井字號 (有時也稱為 number sign 或 hash tag)。\n#\n生動形象地說明了美國本源在英國\n3.2 選擇 shell 使用 who 命令即可顯示當前登入的使用者名稱，登入的虛擬主控台以及登入的時間。\n使用 grep username /etc/passwd 命令，在輸出的最後可看到預設使用的 shell。\n可以透過輸入命令以切換 shell，例如 ksh、tcsh、csh、sh、dash 或其他 shell (假設已經安裝了這些 shell)。\n學習 Bash shell 不僅是因為它是大多數安裝中預設的 shell，也是因為它是大多數 Linux 認證考試中所使用的 shell。\n3.3 執行命令 雖然只需要透過輸入命令名稱就可以執行許多命令，但更常見的做法是在命令之後輸入更多內容，從而改變其行為。在命令之後輸入的字元和單字稱為選項和參數。\n3.3.1 了解命令語法 大多數命令都有一個或多個用來改變命令行為的選項。 一般選項由單個字母構成，並在前面添加一個連字號 -，然而為了每次使用多個選項，也可以將多個單字母選項組合在一起，或者在每個選項前面都使用一個連字號。\n一些命令的選項由一個完整的單字組成，一般需要在單字前使用雙連字號 --。例如，為了使用 help 這個選項，需要輸入 --help，如果是 -help 將被解釋為 -h、-e、-l、-p 這四個選項。儘管有些命令不遵守雙連字號約定，但大多數命令還是要在單字選項前使用雙連字號。\n此外，大多數命令還可在輸入某些選項後或者整個命令列結尾處接受參數。 參數是一個額外的資訊區塊，比如檔名、目錄、使用者名稱、裝置或其他用來告訴命令如何執行的資訊。通常，在命令列中可以使用任意數量的參數，只要數量不超過單個命令列所允許的總字母數即可。\n有時，一個參數與一個選項相關聯，此時參數必須跟在選項之後。如果使用的是單字母選項，那麼參數通常在一個空白之後。而對於全單字選項，參數跟在一個等號 = 之後。\n例如：\n1 tar -cvf backup.tar /home/yexca 選項的含義是建立 (c) 一個名為 backup.tar 的檔案 (f)，其中包含 /home/yexca 目錄的全部檔案，並且在備份檔案建立完畢 (v) 後顯示詳細資訊。因為 backup.tar 是 f 選項的一個參數，所以 backup.tar 必須跟在選項之後。\n1 ls --hide=Desktop \u0026ndash;hide 選項告訴 ls 命令不要顯示名為 Desktop 的檔案或目錄，注意選項與參數之間沒有空白。\n還可以嘗試其他的命令： uname 命令顯示正在執行的系統類型，添加了 -a 選項後還可以查看主機名稱及核心版本。\n當登入到一個 Linux 系統時，Linux 會認定您具有特定的身份，其中包括使用者名稱、群組名稱、使用者 ID 和群組 ID。此外，Linux 還會追蹤登入工作階段，從而了解登入的時間、閒置的時間以及登入的地點等。可透過 id 命令查看身份相關資訊。\n啟用了 SELinux (Security Enhanced Linux) 的 Linux 發行版本都在 id 輸出的末尾顯示了額外資訊，例如：\ncontext=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023\nSELinux 提供了一種可以緊緊鎖定 Linux 系統安全性的方法。\n透過 who -uH 可添加關於閒置時間和程序 ID 資訊 (u)，以及要求列印標頭 (H)。\n閒置 (IDLE) 表示在沒有任何命令輸入的情況下 shell 保持打開狀態的時間長度。程序號碼 (PID) 表示使用者登入 shell 的程序 ID。而備註 (COMMENT) 則表示使用者用來進行登入操作的遠端電腦名稱 (前提是使用者使用了網路上的另一台電腦進行登入)，或者本地 X Display 的名稱 (前提是使用者正在使用一個終端機視窗)，比如 :0.0。\n3.3.2 查找命令 為了找到所輸入的命令，shell 在所謂的路徑中進行查找，對於不在路徑中的命令，可透過輸入命令位置的完整識別進行執行。\n透過 echo $PATH 以查看 shell 的環境變數 PATH。\n參考： Linux 下 bin 目錄 - yexca‘Blog 與其他一些作業系統不同的是，預設情況下，在搜尋路徑之前，Linux 並不會為了查找執行檔而檢查目前目錄，而是馬上開始搜尋路徑，只有在執行檔位於 PATH 環境變數或者給定了執行檔的絕對路徑或相對路徑時，才會執行目前目錄的執行檔。\n並不是所有的命令都位於 PATH 變數的目錄中，一些命令內建於 shell，透過建立用來定義任何命令的別名以及選項，可以改寫另外一些命令。下面是 shell 檢查輸入命令的順序：\n別名 (Alias)。由 alias 命令設置的名稱，可輸入此命令以查看建立的別名。\nshell 保留字。shell 保留了一些單字用作特殊用途。\n函式。一組能夠在目前 shell 中共同執行的命令。\n內建命令。內建於 shell 中的命令，在檔案系統中沒有命令的表現形式，例如 cd、echo、exit、pwd、history (查看以前執行的命令列表)、fg (將一個背景執行的命令帶入前景)、set (設置 shell 選項) 和 type (顯示命令的位置)。\n檔案系統命令。儲存在電腦檔案系統中的命令 (這些命令由 PATH 變數值表示)。\n為了知道命令的出處，可以使用 type 或者 which 命令，透過使用 type -a 可顯示命令的所有已知位置。\n如果一些命令不在 PATH 變數中，可使用 locate 命令嘗試查找該命令，透過使用 locate 命令可以訪問系統中任何可訪問的部分。\nlocate 命令會對整個檔案系統進行查找，而不僅僅是在包含了命令的目錄中查找，如果沒有找到最近添加的檔案，可以 root 使用者身份執行 updatedb 以更新 locate 資料庫。\n3.4 使用命令歷史記錄重複執行命令 重複執行那些冗長、複雜且易於輸錯的命令將可以避免很多問題的出現。\n3.4.1 命令列編輯 預設情況下，Bash shell 使用基於 Emacs 文字編輯器的命令列編輯。如果更喜歡使用 vi，可以將 set -o vi 添加到家目錄的 .bashrc 檔案中。\n用來導覽命令列的按鍵： 按鍵 全稱 含義 Ctrl+F 向前一個字元 前進一個字元 Ctrl+B 向後一個字元 後退一個字元 Alt+F 向前一個單字 前進一個單字 Alt+B 向後一個單字 後退一個單字 Ctrl+A 命令列開頭 轉到目前命令列的開頭 Ctrl+E 命令列結尾 轉到目前命令列的結尾 Ctrl+L 清除螢幕 清除螢幕，並使游標停留在螢幕頂部 用來編輯命令列的按鍵： 按鍵 全稱 含義 Ctrl+D 刪除目前字元 刪除目前字元 Backspace 刪除前一個字元 刪除前一個字元 Ctrl+T 調換字元 交換目前字元和前一個字元的位置 Alt+T 調換單字 交換目前單字和前一個單字的位置 Alt+U 大寫單字 將目前單字改為大寫 Alt+L 小寫單字 將目前單字改為小寫 Alt+C 首字母大寫單字 把游標目前位置單字的頭一個字母變為大寫 Ctrl+V 插入特殊字元 添加一個特殊字元，例如添加 Tab 用來剪下和貼上命令列中文字的按鍵： 按鍵 全稱 含義 Ctrl+K 剪下到行末 剪下游標後面的所有字元 Ctrl+U 剪下到行首 剪下游標前面的所有字元 Ctrl+W 剪下前一個單字 剪下位於目前游標之前的一個單字 Alt+D 剪下後一個單字 剪下位於目前游標之後的一個單字 Ctrl+Y 貼上目前文字 貼上最近剪下的文字 Alt+Y 貼上早期文字 轉回到早期剪下的文字並貼上 Ctrl+C 刪除整行 刪除整個命令列 3.4.2 命令列補全 為了減少按鍵，Bash shell 提供了多種不同的方法來補全部分輸入值。為了嘗試補全一個值，需要輸入前幾個字元並按 Tab 鍵。下面是可以透過 Bash shell 部分輸入的值：\n命令、別名或函式。如果所輸入的文字以常規字元開頭，shell 將嘗試使用命令、別名或者函式名稱來補全該文字。\n變數。如果所輸入的文字以錢字號 $ 開頭，那麼 shell 將使用來自目前 shell 的一個變數來補全文字。\n使用者名稱。如果所輸入的文字以波浪號 ~ 開頭，shell 將使用一個使用者名稱補全文字。因此，~username 表示指定使用者的家目錄。\n主機名稱。如果所輸入的文字以 at 符號 @ 開頭，shell 將使用來自 /etc/hosts 檔案中的一個主機名稱補全文字。\n如果想要添加來自其他檔案的主機名稱，只需要將 HOSTFILE 變數設置為該檔名，但該檔案必須與 /etc/hosts 相同的格式。\n如果所輸入的字串可以產生多種補全結果，此時可以透過雙擊 TAB 鍵列出所有可能的結果。\n3.4.3 命令列重複執行 在輸入完一行命令後，該命令列會儲存到 shell 的歷史命令列表中。\n透過 history 命令查看歷史命令列表，或者添加數字參數以顯示指定數量的最新命令。\n透過使用驚嘆號 ! 以重複執行這些命令，此種方法將直接執行，沒有再次確認的機會。\n!n \u0026mdash; 執行命令編號。例如 !255 將執行第 255 個命令。\n!! \u0026mdash; 執行前一個命令。\n!?string? \u0026mdash; 執行包含字串的命令。\n除了直接執行 history 外，還可重複執行特定命令並進行編輯：\n按鍵 功能 描述 方向鍵或Ctrl+P 與 Ctrl+N 步驟 遍歷歷史命令列表的每一個命令列，直到找到所需的命令列 Ctrl+R 反向增量搜尋 按下後可輸入一個搜尋字串，完成反向搜尋。當輸入字串時，會出現可以執行或編輯的相匹配的命令列 Ctrl+S 向前增量搜尋 與上一個類似，不過是向前搜尋。並不是所有情況都可用 Alt+P 反向搜尋 按下後可輸入一個搜尋字串，完成反向搜尋。輸入字串並按 Enter 鍵後可看到該字串的最新命令列 Alt+N 向前搜尋 與上一個類似，不過是向前搜尋。並不是所有情況都可用 還可使用 fc 命令以使用歷史命令列表。輸入 fc 後跟著一個歷史命令列編號或一個範圍 (例如 fc 233 255)，將在文字編輯器中打開這些命令 (預設為 vi)，關閉編輯器後命令將 (逐個) 執行。\n關閉 shell 後，歷史命令列表將儲存到家目錄的 .bash_history 檔案中，預設最多儲存 1000 條。\n如果不想儲存歷史命令列表，就不要正常退出 shell，可透過 kill -9 PID 關閉 shell 工作階段以不儲存歷史命令。\n將變數 HISTFILE 設置為 /dev/null 或保持 HISTSIZE 為空都是沒用的，只要 shell 正常退出，就會永久儲存 shell 歷史。\n3.5 連接和擴充命令 shell 真正強大的功能在於能將命令的輸入和輸出重導向到其他命令或檔案中，反之亦然。\n為了將命令串在一起，shell 使用了中繼字元 (metacharacter)。中繼字元是對 shell 有特殊含義的輸入字元，用於連接請求或擴充請求。\n中繼字元包括管線字元 |、與號 \u0026amp;、分號 ;、右括號 )、左括號 (、小於號 \u0026lt; 和大於號 \u0026gt;。\n3.5.1 命令之間的管線 管線字元 | 將一個命令的輸出連接到另一個命令的輸入，例如：\n1 cat /etc/passwd | sort | less 該命令列出 /etc/passwd 檔案內容。輸出到 sort 命令以對內容排序，最後發送到 less 以顯示輸出。\n3.5.2 連續命令 使用分號 ; 將多個命令隔開可在同一命令列輸入多條命令以執行連續的命令，例如：\n1 date ; troff -me VertLargeDocument | lpr ; date 對一個很大的文件格式化，並顯示格式化所需的時間。\n3.5.3 背景命令 一些命令可能需要花費很長時間才能完成，可使用與號 \u0026amp; 讓命令在背景執行，例如：\n1 troff -me VertLargeDocument | lpr \u0026amp; 在程序結束之前不要關閉 shell 或刪除 (kill) 該程序，否則程序將終止。\n3.5.4 擴充命令 透過命令替換，可以使一條命令的標準輸出變為另一條命令的一個參數。\n命令替換的兩種形式是 $(command) 和 command (注意是反引號)。\n兩種形式中的命令可以包括選項、中繼字元和參數，例如：\n1 vi $(find /home | grep xyzzy) 在 vi 命令執行之前完成了命令替換。首先 find 命令從 /home 目錄尋找所有檔案與目錄，然後將輸出連接到 grep 命令，將檔名中不包含 xyzzy 的過濾掉，最後使用 vi 打開所有檔案進行編輯 (每次打開一個檔案)。\n注意：不要從根檔案系統開始使用 grep，否則將匹配並嘗試編輯幾千個檔案。\n3.5.5 擴充算術運算式 有時可能需要將算術結果傳遞給一條命令。透過 $[expression] 或者 $((expression))，例如：\n1 echo \u0026#34;I am $[2022-1957] years old\u0026#34; 輸出為 I am 65 years old。\n1 echo \u0026#34;There are $(ls | wc -w) files in this directory\u0026#34; 該命令列出目前目錄內容 (ls) 並執行了單字計數命令，計算出找到的檔案數量 (wc -w)，然後輸出。\n3.5.6 擴充變數 使用錢字號 $ 對 shell 中用來儲存資訊的變數進行擴充。當在命令列中擴充一個環境變數時，所列印的是變數的值，而不是變數名稱，例如：\n1 ls -l $BASH 列印 bash 命令的詳細列表 -rwxr-xr-x. 1 root root 1390064 1月 20 2022 /usr/bin/bash\n3.6 使用 shell 變數 shell 本身使用變數儲存了對使用者的 shell 工作階段非常有用的資訊。如果想要查看目前 shell 設置的所有變數，可以使用 set 命令。\n其中，本地變數的一個子集被稱為環境變數，對任何透過目前 shell 打開的新 shell 都是可用的。可以使用 env 命令查看環境變數。\n除了所設置的變數之外，系統檔案也會設置一些用來儲存相關資訊的變數，比如設定檔、信箱以及路徑目錄的位置。此外，這些變數還可以儲存關於 shell 提示字元、歷史命令列表的大小以及作業系統類型的相關值。如果想引用這些變數的值，需要在變數之前添加一個錢字號 $。\n當啟動一個 shell 時，許多環境變數已經被設置了，下表為一些既可以在使用 Bash shell 時設置，又可以為了使用不同功能而設置的變數：\n變數 描述 BASH 包含了 Bash 命令的完整路徑。其值通常為 /bin/bash BASH_VERSION 表示目前 Bash 命令版本的一個數字 EUID 表示目前使用者有效的使用者 ID 號碼。當啟動 shell 時，根據 /etc/passwd 檔案中的使用者項進行賦值 FCEDIT fc 命令用來編輯 history 命令的文字編輯器，預設為 vi HISTFILE 歷史命令檔案的位置，通常位於 $HOME/.bash_history HISTFILESIZE 可以儲存的歷史命令條目的數量。當達到該數量時，最早的命令將被丟棄，預設為 1000 HISTCMD 返回歷史命令列表中目前命令的數量 HOME 家目錄 HOSTTYPE 描述了 Linux 系統正在執行的電腦系統結構。對於 Intel 相容的個人電腦，其值為 i386、i486 或 i386-Linux 類似的值。而對於 AMD 64 位元電腦，其值為 x86_64 MAIL 信箱檔案的位置，通常為 /var/spool/mail/$USER OLDPWD 修改目前工作目錄之前的工作目錄 OSTYPE 用來識別目前作業系統。對於 Fedora，值為 Linux 或 Linux-gnu PATH 值為冒號 : 分隔的目錄列表，主要用來查找需要輸入的命令 PPID 目前 shell 的命令的程序 ID PROMPT_COMMAND 可以將該變數設置為一個命令名稱，以便在每次 shell 提示字元顯示之前執行該命令 PS1 設置 shell 提示字元的值。有時命令需要額外的提示字元，可以使用變數 PS2、PS3 等進行設置 PWD 表示目前目錄 RANDOM 生成一個 0~32767 的隨機數 SECONDS 自 shell 啟動後的秒數 SHLVL 與目前 shell 工作階段相關聯的 shell 層級數。當登入到 shell 時，值為 1，每執行一次 Bash 命令後該層級數將遞增 (例如使用 su 命令或輸入 bash) TMOUT 可以為該變數設置一個數字，表示 shell 可以閒置的秒數。在秒數到達後，shell 將會退出 (登出使用者) 3.6.1 建立和使用別名 (Alias) 使用 alias 命令可以列出所有別名以及建立別名。\n1 alias p=\u0026#39;pwd ; ls -CF\u0026#39; 執行 p 命令，將執行 pwd 命令後執行 ls -CF 以列表的形式列出該目錄的內容。\n如果想刪除，可使用 unalias 命令。\n3.6.2 退出 shell 輸入 exit 或者按 Ctrl+D。\n3.7 建立自己的 shell 環境 可以透過調整 shell 以幫助更有效地工作。\n3.7.1 設定 shell shell 的行為方式由多個設定檔所支援：\n檔案 描述 /etc/profile 為每個使用者設置了使用者環境資訊，當首次登入時執行該檔案。該檔案還從 /etc/profile.d 目錄的設定檔中收集相關的 shell 設置。除了為諸如使用者信箱位置以及歷史檔案大小的資訊設置環境變數，還提供了路徑值 /etc/bashrc 每次打開一個 Bash shell 時都會執行該檔案，可透過每個使用者的 ~/.bashrc 檔案中的資訊改寫該檔案。設置了預設的提示字元，同時還可添加一個或多個別名 ~/.bash_profile 用來被每個使用者輸入 shell 具體用法資訊的檔案，只有當使用者登入才會執行該檔案。預設情況下，它設置一些環境變數並執行使用者的 .bashrc 檔案。該檔案是添加環境變數的絕佳位置 ~/.bashrc 包含了特定於 Bash shell 的資訊，當進行登入以及每次打開一個新 Bash shell 都會讀取該檔案。該檔案是添加別名的好地方 ~/.bash_logout 每次登出時執行該檔案，預設會清除螢幕 如果想更改 /etc/profile 或 /etc/bashrc 檔案，則必須是 root 使用者。一般建立 /etc/profile.d/custom.sh 檔案來添加系統全域的設置，而不是直接編輯這些檔案。\nnano 編輯器 較為簡單的文字編輯器，Ctrl+O 儲存檔案，Ctrl+X 退出檔案。\n3.7.2 設置提示字元 提示字元由一組字元組成，每當 shell 準備接收命令時都會顯示這組字元。PS1 環境變數設置了提示字元所包含的內容，如果需要額外的輸入，可以使用 PS2、PS3 以及 PS4 的值。\n特殊字元 描述 \\! 顯示目前命令歷史記錄編號，包括為使用者名稱儲存的所有以前的命令 \\# 顯示目前命令的命令編號，僅包括用於獲取 shell 的命令 \\$ 根據使用者類型的不同，顯示使用者提示字元 $ 或 root 提示字元 # \\W 僅顯示目前工作的基底名稱 (basename) \\[ 出現在非列印字元序列之前。可用來向提示字元添加終端機控制序列，比如改變顏色、添加閃爍效果或使字元變粗 (所使用的終端機決定了最終可用的序列) \\] 緊跟在非列印字元序列之後 \\\\ 顯示一個反斜線 \\d 顯示目前日期的星期幾、月份以及日期 \\h 顯示正在執行 shell 的電腦的主機名稱 \\n 換行符號 \\nnn 顯示替換 nnn 的八進位數所表示的字元 \\s 顯示目前 shell 的名稱 \\t 以小時、分鐘、秒的格式列印目前時間 \\u 列印目前使用者名稱 \\w 顯示目前工作目錄的完整路徑 如果僅臨時修改，例如 export PS1=\u0026quot;[\\t\\w]\\$\u0026quot;。\n如果永久修改，需要向 ~/.bashrc 添加 PS1 值。\n閱讀更多： Bash Prompt HOWTO 3.7.3 添加環境變數 有時可能需要向 .bashrc 檔案添加一些環境變數：\nTMOUT \u0026mdash; 設置在 Bash 自動退出之前 shell 可以處於非活動狀態多長時間。\nPATH \u0026mdash; 設置了對所使用命令進行搜尋的目錄。例如為了添加目錄 /home/yexca/bin，可添加以下程式碼：\nPATH=$PATH:/home/yexca/bin ; export PATH\n該範例首先將所有目前的路徑目錄 ($PATH) 讀取到新 PATH 變數中，然後添加 ~/bin 目錄，最後匯出新的 PATH 變數。\n切勿將 . 添加到 PATH 變數，可能存在安全風險。\nWHATEVER \u0026mdash; 可以建立自己的環境變數，為工作提供捷徑。為這些變數選擇一個未被使用的任何名稱，並賦予一個有用的值。例如：\nMYWORKDIR=/home/yexca/work ; export MYWORKDIR\n可透過輸入 cd $MYWORKDIR 使設置的目錄成為目前目錄。\n3.8 獲取關於命令的資訊 一些命令內建於 shell 中，例如 help | less 以瀏覽幫助資訊，或者 help command 以查看某命令的幫助資訊。\n在命令中使用 --help 選項或 -h 選項以查看命令提供的幫助資訊。\n還有 info 和 man command 命令學習某一特定命令。\n說明頁 (man page) 是獲取命令以及 Linux 系統中其他基本組件相關資訊的最常用方法。\n說明頁有 8 個章節：\n節數 節名稱 描述 1 使用者命令 可以由一般使用者透過 shell 執行的命令 2 系統呼叫 某一應用程式中用來呼叫系統核心的程式設計函式 3 C 函式庫函式 為特定程式設計函式庫提供介面的程式設計函式 4 裝置和特殊檔案 表示硬體裝置或軟體裝置的檔案系統節點 5 檔案格式和約定 檔案類型或特定的設定檔 6 遊戲 系統中可玩的遊戲 7 雜項 對相關主題 (如協定、檔案系統) 的概述 8 系統管理工具和守護行程 需要 root 或其他管理特權的命令 透過 man -k 可搜尋說明頁資料庫。若無搜尋結果可能是未初始化，使用 root 身份執行 mandb 以初始化資料庫。\n透過例如 man 5 passwd 以顯示第 5 節內容。\n瀏覽時透過 Page Down 和 Page Up 以翻頁，或使用 Enter 與方向鍵以移動一行。如果想要搜尋，使用正斜線 / 然後輸入要搜尋的內容，透過 n 重複向前搜尋，N 以重複向後搜尋。輸入 q 以退出。\n","date":"2022-09-12T15:04:10+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/69/","title":"Linux 學習 第三章 使用 shell"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 前言 既然都有 Win 命令列了，那怎麼能沒有 Linux 呢？\nWindows 的文章： 命令列下載 YouTube 影片 下載 yt-dlp 建議配置好 Python 環境，然後到 Releases · yt-dlp/yt-dlp · GitHub 下載 yt-dlp，如果不想配置 Python 就下載 yt-dlp_linux。\n下載完成後賦予執行權限並放在 /usr/local/bin/ 下。\n下載 FFmpeg 參考官網 Download FFmpeg Fedora 下使用以下命令：\n1 sudo dnf install ffmpeg 設定檔 切換設定目錄：\n1 cd ~/.config 建立資料夾並進入：\n1 2 mkdir yt-dlp cd yt-dlp 建立設定檔：\n1 vi config 我的設定檔如下：\n1 -f bv+ba/b -o ~/Videos/%(uploader)s/%(upload_date)s%(title)s%(id)s.%(ext)s --continue --merge-output-format mp4 說明一下：\n1 2 3 4 5 6 7 8 9 10 11 12 -f bv+ba/b # 最高畫質與音訊 -o # 輸出資料夾設定 /%(uploader)s/ # 依頻道名稱建立資料夾 %(upload_date)s # 上傳時間 %(title)s # 影片標題 %(id)s # 影片 ID .%(ext)s # 影片副檔名 --continue # 斷點續傳 --merge-output-format mp4 # 合併為 mp4 影片 參考文章 FFmpeg 批次轉換影片格式 話說自己的文章有必要放連結嗎\n","date":"2022-09-10T19:29:58+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/68/","title":"Linux 下載 YouTube 影片"},{"content":" 📢 本文由 Gemini-3-flash 翻譯 引言 這個黑幕很好玩啊，非常好玩啊，可惜首頁無法渲染出來，而且 Markdown 編寫渲染也難\n使用方式 撰寫文章時選擇作為 HTML 編輯，插入以下語句\n1 \u0026lt;span class=\u0026#34;heimu\u0026#34; title=\u0026#34;黑幕彈框裡的字\u0026#34;\u0026gt;需要隱藏的文字\u0026lt;/span\u0026gt; 插入 CSS 本來是想著實作首頁也有黑幕，但實際測試發現首頁不會渲染 (為什麼不渲染啊啊啊啊啊啊啊！！！！！！！試著想像 Warma 的聲音)\n進入後台設定，找到頁尾設定，輸入以下程式碼，或者在 WP 的自訂 CSS 處插入，不過需要去掉標籤\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 \u0026lt;style\u0026gt; .heimu, .heimu a, a .heimu, .heimu a.new { background-color: #252525; color: #252525; text-shadow: none; } .heimu:hover, .heimu:active, .heimu:hover .heimu, .heimu:active .heimu { color: white !important; } .heimu:hover a, a:hover .heimu, .heimu:active a, a:active .heimu { color: lightblue !important; } .heimu:hover .new, .heimu .new:hover, .new:hover .heimu, .heimu:active .new, .heimu .new:active, .new:active .heimu { color: #BA0000 !important; } \u0026lt;/style\u0026gt; 註：因 Argon 不會渲染註釋，所以我並不把以下內容放入程式碼中：\n/*閱讀更多：https://zh.moegirl.org/MediaWiki:Mobile.css 本文引自萌娘百科(https://zh.moegirl.org)，文字內容預設使用《創用 CC 姓名標示-非商業性-相同方式分享 3.0》協議。*/\n參考文章 Re：萌娘百科上的黑幕實現 – Vanilla_chan – 博客園 萌百黑幕CSS代码-Hiyoung’blog ","date":"2022-09-05T21:51:23+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/67/","title":"萌娘百科黑幕在 Argon 主題 WordPress 實作"},{"content":" 📢 本文由 gemini-2.5-flash-lite 翻譯 引言 記錄我使用 OpenWRT 路由器連接學校網路的折騰過程，雖然最後的結果挺 emm？但在这个過程中還是了解到不少東西\n起始 通過在瀏覽器搜尋 openwrt通過深瀾認證 得到 恩山無線論壇 帖子回覆下的一個開源專案： coffeehat/BIT-srun-login-script ，通過專案知道了有支援多平台 (包括 openwrt) 的 golang 版本，於是開始折騰\n這是專案作者的文章： 深瀾校園網登錄的分析與 python 實現-北京理工大學版 折騰前 對於 OpenWRT 版本未提供編譯後的版本，即 IPK 文件，又因為我水平不行看不懂 README 便請教同學得知為 Linux 的指令，但在實際操作後得知此命令為編譯 Linux 核心，便放棄在實體機做開始使用虛擬機搞\n參考： Building a custom kernel/zh-cn - Fedora Project Wiki 開始折騰 另朋友發了 configuration - How to fix make error \u0026ldquo;No rule to make target \u0026lsquo;menuconfig\u0026rsquo;\u0026rdquo; when building a kernel for Beagleboard? - Unix \u0026amp; Linux Stack Exchange ，於是我便照著此帖子回答嘗試\n創建虛擬機 因為我使用的 Fedora 自帶虛擬機軟體 盒子，首先嘗試裝 CentOS8，因為我的鏡像文件放到了移動硬碟中，便直接掛載，選擇。結果提示創建失敗，然後我嘗試了 CentOS7，失敗，然後 Ubuntun，失敗\n接連失敗，要不是我之前用這軟體創建過Win10我都快懷疑是不是軟體不行了，打開錯誤日誌，果然看不懂，不過我注意到路徑有中文，於是把路徑改為英文，再次嘗試，失敗\n然後第二天我在想既然是編輯核心，要不使用 kali 吧，於是把 U 盤中 kali 鏡像複製到電腦，雖然最後安裝失敗但成功運行了，難道要把系統放本地才行嗎\n於是我把 CentOS7 的鏡像拷貝到 ~/Documents/ 下，安裝成功。因想著只是編譯 IPK 便只有 root 用戶\n連接網路 本以為在 Linux 下創建 Linux 虛擬機可以直接共享網路的，於是我就直接輸入命令 wget https://cdn.kernel.org/pub/linux/kernel/v5.x/linux-5.19.6.tar.xz，結果就是無法找到 IP 地址，使用命令 ifconfig 發現無 IP\n參考文章 在虛擬機中設置靜態 IP (centos 為例) 使虛擬機連上網路，不過在最後文件修改只需要將 ONBOOT 後的值改為 yes 然後加倆 DNS 就可以了\n安裝git 連上網路後我先裝了個 git，使用 yum install git 即可，然後配置姓名與郵箱\n1 git config --global user.name \u0026#34;Name\u0026#34; 1 git config --global user.email \u0026#34;email@example.com\u0026#34; 傳輸文件 繼續使用 wget 下載 Linux 核心，嘗試了三四次，幾乎都是在 50% 左右下載失敗而且速度很慢\n注：使用 wget -c URL 可實現斷點續傳\n然後就是 盒子 這個軟體貌似支援直接拖拽傳輸，於是我在我的電腦下載好後直接拖過去，失敗，文件沒有被傳輸過去，考慮到傳輸後的文件在 ~/Downloads/ 下，我使用的是 root 帳戶，於是我參考 Linux 添加用戶和管理員用戶 創建了一個用戶 (差點把最後一步刪除用戶也執行了)\n使用命令 su username 切換用戶，創建文件夾 ~/Downloads/，再次拖入還是失敗\n嘗試使用 盒子 的共享功能將電腦的 ~/Public 共享，但我怎麼操作也不能在虛擬機裡看到 (想必這軟體只適配了 RHEL 和 Fedora 吧)\nSSH 傳輸 然後我想到了通過 SSH 傳輸 (因為我輸入 ftp 發現沒這個命令，懶得裝了)\n本地開啟 SSH 連接，然後通過 scp 命令以使用 SSH 傳輸文件\n1 scp username@servername:/path/filename ~/Downloads/ 首先是確定 IP，在虛擬機中輸入命令 ip route 得到 IP 為 10.0.2.2\n然後使用 scp 命令傳輸\n解壓文件 使用 tar 命令解壓文件\n1 tar -xzvf filename.tar.xz emm，非 gzip 壓縮文件，那我不知道怎麼解壓啊\nSSH 傳輸 還是使用 SSH 傳輸吧，在 scp 命令加上 -r 即可傳輸文件夾\n開始嘗試 按照步驟將解壓後的文件放到 /usr/src/ 下，把 /boot 下的 config 放到 /usr/src/linux-5.19.6/.config，結果無論是把配置文件放到 .config/ 下還是放到 .config 都無法運行 make menuconfig 命令\n總結 折騰失敗，下次再來\n不過在我編寫此文章時注意到原帖嘗試直接在 OpenWRT 運行 Python，有時間嘗試一下\n再次嘗試 然後我諮詢了一位過了認證校園網的朋友 (雖然他是普通路由器)，他將路由器的 MAC 地址改為自己電腦的，結果插上網線認證頁面會自動轉發到電腦，然後認證後就有網了，不過是銳捷網頁認證\n然後考慮到深瀾使用的是 Portal 認證也就是 Web 頁面認證，既然是 Web 那想必就是使用 HTTP 了，我是否可以通過編輯 HTTP 報文的方式通過認證呢？那麼 Linux 有命令可以發送 HTTP 報文嗎，我搜了一下，發現 curl 與 wget 命令可以模擬 get 和 post 請求 (於是我打開 Fiddler 開始抓包，企圖還原驗證過程)\n才怪，我用路由器連接上學校網，電腦插上網線連上路由器，輸入認證頁面 IP，認證完成，路由器有網了\nLinux 命令模擬 Http 的 get 或 post 請求 雖然沒用到，不過既然看到了那就記錄一下吧\nGET 請求 curl 1 2 3 4 5 6 7 8 ## 如果這裡的 URL 指向的是一個文件可以直接下載到本地 curl URL ## 顯示全部信息 curl -i URL ## 只顯示頭部信息 curl -I URL ## 顯示 get 請求全過程解析 curl -v URL wget 1 wget URL POST 請求 curl 1 2 3 4 5 6 ## 通過 -d 參數，把訪問的參數放在裡面 curl -d \u0026#34;param1=value1\u0026amp;param2=value2\u0026#34; \u0026#34;URL\u0026#34; curl -d\u0026#39;param1=value1\u0026amp;param2=value2\u0026#39; -X POST URL curl -d \u0026#39;param1=value1\u0026#39; -d \u0026#39;param2=value2\u0026#39; -X POST URL wget 1 2 ## 通過 --post-data 參數實現 wget --post-data \u0026#39;user=name\u0026amp;passwd=passwd\u0026#39; URL 再次總結 有時候不能把某件事想的太複雜，往往很簡單的事只思考而沒實踐就否認這種可能性是錯誤的，這次就是我一開始就把最後再次嘗試部分否決才鬧了這麼一大圈 (要不是流量卡的不行我才不會去試)\n寫到這時我想到了兩句名言\n學而不思則罔，思而不學則殆\n實踐得真知\n所以有些時候還是應該大膽去嘗試，不要因為過多的思考而限制了自己！\n參考文章 求助深瀾校園網 Portal 認證應該怎麼刷固件？-小米無線路由器以及小米無線相關的設備-恩山無線論壇 configuration - How to fix make error \u0026ldquo;No rule to make target \u0026lsquo;menuconfig\u0026rsquo;\u0026rdquo; when building a kernel for Beagleboard? - Unix \u0026amp; Linux Stack Exchange 在虛擬機中設置靜態 IP (centos 為例) - yexca\u0026rsquo;Blog 安裝 Git - 廖雪峰的官方網站 Linux 添加用戶和管理員用戶 - yexca\u0026rsquo;Blog linux 系統下如何進行用戶之間的切換_M李麗的博客-CSDN博客_linux切換系統 使用 ssh 傳輸文件 - 思否 Linux tar 命令-菜鳥教程 Portal 認證原理-曹世宏的博客 Linux 命令發送 Http 的 get 或 post 請求 (curl 和 wget 兩種方法)_cyl937的博客-CSDN博客 ","date":"2022-09-05T21:24:23+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/66/","title":"記錄 OpenWRT 通過深瀾網路認證的折騰過程"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 前言 因為接觸了 YouTube-dl ，下載頻道的所有內容非常好用，但是下載下來是 webm 格式，相容性不是很好，於是查詢了使用 ffmpeg 轉換格式的指令。\n設定檔 後來發現改一下設定檔就行了，在檔案後面加上\n1 --merge-output-format mp4 這是我的設定檔\n1 -o \u0026#39;C:/Users/yexca/Downloads/Video/%(uploader)s/%(upload_date)s%(title)s%(id)s.%(ext)s\u0026#39; --merge-output-format mp4 單一指令 使用以下指令即可快速轉碼\n1 ffmpeg -i before.webm after.mp4 但一個一個轉碼實在是太慢了，於是就想到使用批次處理。\n批次處理 新增記事本，輸入以下程式碼\n1 for %%a in (*.webm) do ffmpeg -i \u0026#34;%%~a\u0026#34; -vcodec copy -f mp4 \u0026#34;%%~na.mp4\u0026#34; 其中 (*.webm) 為原始檔案類型，「%%~na.mp4」為想要產生的檔案類型。\n然後儲存並命名為run.bat 後，放到對應的資料夾執行即可。\n但這樣每次想轉換不同的檔案，還得修改一下，這樣不大實用啊（\ndos 然後我就看了一些 bat 檔案的資料，簡單寫了下面的程式 (需要使用 GB2312 編碼才能在命令列正常輸出中文)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 echo off :0 echo 請輸入數字選擇操作 echo 1.轉碼 echo 2.刪除 echo 3.退出 set /p choice=請選擇 goto %choice% :1 set /p before=請輸入轉碼前檔案格式 set /p after=請輸入轉碼後檔案格式 echo 開始轉碼%before%到%after% for %%a in (*.%before%) do ffmpeg -i \u0026#34;%%~a\u0026#34; -vcodec copy -f %after% \u0026#34;%%~na.%after%\u0026#34; echo 轉碼完成 goto 0 :2 set /p delet=請輸入需要刪除的檔案格式 echo 開始刪除%delet% del *.%delet% del %delet% echo 刪除完成 goto 0 :3 exit 放到對應的資料夾下使用就好了。\n參考文章 youtube-dl 的一些實用技巧 · eisen 部落格 給新手的 20 多個 FFmpeg 指令範例 - 知乎 FDM 當掉了，youtube-dl 慢得要死，烤肉man 的末日到了！ 中 AnnMilne 的評論\n用bat指令執行ffmpeg進行批次轉碼-五仁的紀錄 Bat指令學習 - 陽光雨露\u0026amp; - 部落格園 bat set指令詳解_python資深小白的部落格-CSDN部落格 ","date":"2022-09-05T16:41:38+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/65/","title":"ffmpeg 批次轉換影片格式"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 引言 這是在我閱讀了肖佳老師的書《HTTP 封包擷取實戰》後對 HTTP 相關內容的總結，主要還是訊息相關 (記錄：閱讀此書與寫出此文章耗時 5 天)\nHTTP 協定訊息的結構 HTTP 訊息分為 2 個：一個是 HTTP 請求訊息 (Request)，一個是 HTTP 回應訊息 (Response)\nHTTP 請求訊息 (Request) HTTP 請求訊息分為 3 個部分，第一部分叫起始行 (Request line)，第二部分叫標頭 (Request Header)，第三部分叫主體 (Body)\n第一行中有 Method (請求方法)、URI 和協定版本。例如 GET https://blog.yexca.net/ HTTP/2\n第二部分是 Header (標頭)\n第三部分是 Body (主體)\n注意：Header 標頭和 Body 主體之間有一個空行\nHTTP 回應訊息 (Response) HTTP 回應訊息與請求訊息的結構基本一樣，也分為 3 個部分，第一部分叫回應行 (Response line)，第二部分叫回應標頭 (Response Header)，第三部分是主體 (Body)\n第一行有協定版本、狀態碼和狀態碼訊息。例如 HTTP/2 200\n第二部分是 Header (標頭)\n第三部分是 Body (主體)\n注意：Header 標頭和 Body 主體之間有一個空行\nHTTP 協定請求方法和狀態碼 URL 格式 URL 的全稱為 Uniform Resource Locator，中文譯名為統一資源定位符，用於完整地描述 Internet 上某一處資源的位址\nURL 的基本格式如下：\nschema://host[:port#]/path/.../[?query-string][#anchor]\n屬性 描述 schema (協定) 指定底層使用的協定 (例如：http，https，ftp) host (網域) HTTP 伺服器的 IP 位址或者網域名稱 port# (連接埠) HTTP 伺服器的預設連接埠是 80，這種情況下連接埠號可以省略。如果使用了別的連接埠，則必須指明 path (資源的路徑) 存取資源的路徑 query-string (參數) 發送給 HTTP 伺服器的資料 anchor (錨點) 錨點，頁面內部超連結 HTTP 請求方法 編號 方法 描述 1 GET 請求指定的頁面資訊並傳回實體主體 2 HEAD 類似於 GET 請求，只不過傳回的回應中沒有具體的內容，用於獲取標頭 3 POST 向指定資源提交資料進行處理請求 (例如提交表單或者上傳檔案)，資料被包含在請求體中。POST 請求可能會導致新的資源建立和/或對現有資源的修改 4 PUT 從用戶端向伺服器傳送的資料取代指定文件的內容 5 DELETE 請求伺服器刪除指定的頁面 GET 與 POST 的區別 GET 提交的資料會放在 URL 之後，以 ? 分隔 URL 和傳輸資料 (即 query-string，鍵值對方式)，參數之間以 \u0026amp; 相連\n而 POST 方法是把提交的資料放在 HTTP 封包的 Body 中\nGET 提交的資料大小有限制 (因為瀏覽器對 URL 的長度有限制)\n而 POST 方法提交的資料大小沒有限制\nGET 方式需要使用 Request.QueryString 來取得變數的值\n而 POST 方法透過 Request.Form 來獲取變數的值\nHTTP 狀態碼 HTTP 狀態碼存在於 HTTP 的回應訊息中，其作用是 Web 伺服器用來告訴用戶端發生了什麼事\nHTTP 狀態碼被分為 5 大類，隨著協定的發展，HTTP 規範中會定義更多的狀態碼吧\n狀態碼 已定義範圍 分類 1XX 100～101 資訊提示，表示請求已被成功接收，繼續處理 2XX 200～206 成功，表示請求已被成功接收、理解、接受 3XX 300～305 重新導向，要完成請求，必須進行進一步處理 4XX 400～415 用戶端錯誤，請求有語法錯誤或請求無法實現 5XX 500～505 伺服器錯誤，伺服器未能實現合法的請求 常見狀態碼 名稱 釋義 200 OK：伺服器成功處理了請求 301/302 Moved Permanently (重新導向)：請求的 URL 已移走。Response 中應該包含一個 Location URL，說明資源現在所處的位置 304 Not Modified (未修改)：用戶端的快取資源是最新的，需要用戶端使用快取 404 Not Found：未找到資源 401 禁止存取 501 Internal Server Error：伺服器遇到一個錯誤，使其無法對請求提供服務 206 (Partial Content，部分內容) 206 狀態碼代表伺服器已經成功處理了部分 GET 請求 (只有發送 GET 方法的 HTTP 請求，Web 伺服器才可能傳回 206)\n應用比如說使用下載工具實現斷點續傳或者線上影片播放都是使用 206 狀態碼來實現\n例如現在打開影片網站的一個影片，對於影片所在的 URL\n瀏覽器會發送一個 GET 請求，Header 中包含 Range: bytes=5303296-5336063，意思就是請求得到 5303296-5336063 之間的資料\nWeb 伺服器傳回一個 206 的 HTTP 回應。Header 中包含 Content-Range: bytes 5303296-5336063/12129376，表明這次傳回的內容範圍\n301 與 302 (Moved Permanently，重新導向) 在得到 301 或 302 回應後，瀏覽器會再次請求位於 Location 中傳回的新 URL\n狀態碼 301 和 302 在語法上是一模一樣的，都是在 HTTP 回應的 Location 中傳回新的 URL\n區別在於：\n301 表示舊位址已經被永久移除了，這個資源不可存取了，搜尋引擎會把權重算到新位址\n例如：防止使用者輸錯網域或更換網域\n302 表示舊位址的資源還在，仍然可以存取，這個重新導向只是臨時地從舊位址跳轉到新位址，搜尋引擎會把權重算到新位址\n例如：未登入狀態下存取需要登入才能存取的頁面\n304 (Not Modified，未修改) 狀態碼 304 表示上次的文件已經被快取了，還可以繼續使用\n400 (Bad Request) 狀態碼 400 表示用戶端請求有語法錯誤，發送的 HTTP 請求中的資料有錯誤，例如表單有錯誤或者 Cookie 有錯誤，不能被伺服器所理解\n401 (Unauthorized) 狀態碼 401 是指未授權錯誤。有些網頁採用的是 HTTP 基本認證 (Basic Authentication) ，需要在 HTTP 請求 Header 中帶上 Authentication，否則伺服器會傳回狀態碼 401\n404 (Not Found) 該狀態碼表明伺服器上無法找到請求的資源。除此之外，也可以在伺服器端拒絕請求但不想說明理由時使用\n例如 BV1AB4y1D7Ft 這個影片僅在登入並且收藏的情況下才可見，否則將傳回 404\n403 (Forbidden) 狀態碼 403 表示 Web 用戶端發送的請求被 Web 伺服器拒絕了。如果伺服器想說明為什麼拒絕請求，可以在 Body 中描述原因。但這個狀態碼通常表示伺服器不想說明拒絕原因\n500 (Internal Server Error) 狀態碼 500 代表伺服器內部錯誤。出現錯誤的原因有很多，比如程式碼的錯誤、資料庫連接語句出錯、程式內部拋出異常、空指標錯誤等\n503 (Server Unavailable) 狀態碼 503 表示伺服器暫時不可用。由於伺服器維護或者過載，伺服器目前無法處理請求\n這個狀況是臨時的，並且將在一段時間以後恢復\n了解全部狀態碼 存取： HTTP 狀態碼 - 菜鳥教程 HTTP 協定 Header Header 的語法格式是「key: value」，一行一個。每一個 Header 都有特殊的作用\n快取相關的 Header HTTP 請求與 HTTP 回應都有很多用於快取的 Header。HTTP 快取是指當 Web 請求抵達快取時，如果本地有「已快取的」複本，就可以從本地儲存設備而不是原始伺服器中獲取該檔案\nCookie Cookie 是一種 HTTP 快取，是 HTTP 中非常重要的內容。它由 key=value 的形式組成，比如 ip_country=CN\n瀏覽器把 Cookie 透過 HTTP 請求中的「Cookie: header」發送給 Web 伺服器，Web 伺服器透過 HTTP 回應中的「Set-Cookie: header」把 Cookie 發送給瀏覽器\nAccept Accept 表示瀏覽器用戶端可以接受的媒體類型。例如 Accept: text/html 代表可以接受伺服器傳回 html\n萬用字元 * 代表任意類型，例如 Accept: text/html,*/*;q=0.8 代表瀏覽器可以處理所有的類型。一般瀏覽器用戶端給 Web 伺服器發送的都是類似這個\nAccept-Encoding Accept-Encoding 跟壓縮有關，瀏覽器發送 HTTP 請求告訴 Web 伺服器瀏覽器支援的壓縮形式，例如 Accept-Encoding: gzip, deflate\nAccept-Language Accept-Language 作用是聲明自己接受的語言。注意語言與字元集的區別，中文是語言，中文有多種字元集，例如 GB2312、GBK 等。例如 Accept-Language: en-US,en;q=0.8,zh-CN;q=0.6,zh;q=0.4,zh-TW;q=0.2\nUser-Agent User-Agent 的作用是瀏覽器用來告訴伺服器，用戶端使用的作業系統及版本、CPU 類型、瀏覽器及版本、瀏覽器轉譯引擎、瀏覽器語言、瀏覽器外掛程式等\n例如 User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:103.0) Gecko/20100101 Firefox/103.0 代表 64 位元 Linux 系統，Firefox 是 103.0 版本\n如果想要模擬各種不同的用戶端，只要修改 User-Agent，就可以偽裝成各種用戶端\nReferer Referer 主要用來讓伺服器判斷來源頁面，即使用者是從哪個頁面來的，網站通常用其統計使用者來源，也可以用作防盜連等\nConnection 從 HTTP/1.1 起，系統預設都開啟了 Connection: Keep-Alive，保持連線特性。Keep-Alive 不會永久保持連線，它有一個保持時間，可以在不同的伺服器軟體 (如 Apache) 中設定這個時間\nHost Host 的作用是指定被請求的主機和連接埠號，如果是 80 連接埠號會被自動隱藏\nHTTP 協定中的快取 快取無處不在，有瀏覽器端的快取、伺服器端的快取、代理伺服器的快取，還有 ASP.NET 頁面的快取、物件快取、資料庫快取等等\nHTTP 中具有快取功能的是瀏覽器快取和代理伺服器快取\nHTTP 快取是指當 Web 請求抵達快取時，如果本地有「已快取的」複本，就可以從本地儲存設備而不是從原始伺服器中提取這個文件\n快取的優點：減少了冗餘的資料傳輸，節省了傳輸時間；減少了伺服器的負擔，大大提高了網站的效能；加快了用戶端載入網頁的速度等\n如何判斷快取新鮮度 Web 伺服器透過以下兩種方式來判斷瀏覽器快取是否最新\n瀏覽器把快取檔案的最後修改時間透過 Header 的 If-Modified-Since 告訴 Web 伺服器。瀏覽器收到 HTTP 請求後，在 Header 中將檔案最後修改時間 Last-Modified 與請求訊息的 If-Modified-Since 相比較。若相同則說明檔案是最新的，則發送狀態碼 304 (Not Modified) 給瀏覽器用戶端；若不同則發送狀態碼 200 把最新檔案發送給瀏覽器用戶端\n瀏覽器把快取檔案的 ETag 透過 Header 的 If-None-Match 告訴 Web 伺服器\n與快取有關的 Header HTTP 請求訊息 Header 名稱 釋義 Cache-Control: max-age=0 以秒為單位 If-Modified-Since: Tue, 28 Jun 2022 00:50:56 GMT 快取檔案的最後修改時間 If-None-Match: \u0026ldquo;1771e0c387823da5329c20a76bece83c\u0026rdquo; 快取檔案的 ETag 值 Cache-Control: no-cache 不使用快取 Pragma: no-cache 不使用快取 HTTP 回應訊息 Header 名稱 釋義 Cache-Control: public 回應被快取，並且可以被多用戶存取使用 Cache-Control: private 回應只能作為私有快取，特定使用者使用 Cache-Control: no-cache 提醒瀏覽器要從伺服器提取文件進行驗證 Cache-Control: no-store 絕對禁止快取 (用於機密、敏感檔案) Cache-Control: max-age=60 60s 後快取過期 (相對時間) Date: Thu, 01 Sep 2022 21:56:36 GMT 目前回應發送的時間 Expires: Thu, 01 Sep 2022 21:57:37 GMT 快取過期的時間 (絕對時間) Last-Modified: Tue, 28 Jun 2022 00:50:56 GMT 伺服端檔案的最後修改時間 Etag: \u0026ldquo;1771e0c387823da5329c20a76bece83c\u0026rdquo; 伺服器檔案的 ETag 值 註：瀏覽器總是優先使用 cache-control，如果沒有時才考慮 Expires\nETag ETag 是 Entity Tag (實體標籤) 的縮寫，是根據實體內容生成的一段雜湊 (hash) 字串 (類似於 MD5 或者 SHA1 之後的結果)，可以表示檔案的狀態。當資源發生改變時，ETag 也隨之發生改變\n使用 ETag 主要是為了解決一些 Last-Modified 無法解決的問題，比如說某些伺服器不能精確得到檔案的最後修改時間、一些檔案最後修改時間改變了但是內容不變、某些檔案修改特別頻繁甚至達到了以秒為單位以下等\n註：Last-Modified 只能精確到秒\n瀏覽器不使用快取 使用 Ctrl+Shift+R 快捷鍵強制重新整理瀏覽器，可以讓瀏覽器不使用快取，即瀏覽器的 HTTP 請求訊息的 Header 中帶有 Cache-Control: no-cache，明確告訴 Web 伺服器不使用快取\n註：Pragma: no-cache 與 Cache-Control: no-cache 作用相同，只是 Pragma: no-cache 是 HTTP/1.0 定義的，保留為了相容性\n直接使用快取，不經過伺服器驗證 使用 Ctrl+R 快捷鍵重新整理瀏覽器，瀏覽器會去 Web 伺服器驗證快取\n如果在網址列直接輸入位址並存取，瀏覽器會「直接使用有效的快取」，不會發送 HTTP 請求去伺服器驗證快取，這種情況稱為快取命中 (cache hit)\n公有快取與私有快取 公有快取 Cache-Control: public 可以由多個使用者共享存取，而私有快取 Cache-Control: private 只能單個使用者存取使用\nHTTP 協定壓縮和 URL Encode HTTP 壓縮是指 Web 伺服器和瀏覽器之間壓縮傳輸文字內容的方法。HTTP 採用通用的壓縮演算法，比如用 gzip 來壓縮 HTML、JavaScript、CSS 檔案\nHTTP 內容編碼與壓縮的區別 在 HTTP 協定中，可以對 Body 部分進行編碼，如可以採用 gzip 這樣的編碼，從而達到壓縮的目的；也可以使用其他編碼方式把內容攪亂或加密，以此來防止未被授權的第三方看到文件的內容。所以 HTTP 壓縮其實就是 HTTP 內容編碼的一種\nHTTP 壓縮的過程 瀏覽器發送 HTTP 請求 Header 中帶 Accept-Encoding: gzip,deflate 告訴伺服器瀏覽器支援 gzip 壓縮\nWeb 伺服器接到 HTTP 請求後，先生成原始的 HTTP 回應，包含原始的 Content-Type 與 Content-Length；然後透過 gzip 對 HTTP 回應的 Body 進行編碼，並在編碼後 Header 中的 Content-Type 與 Content-Length 替換為壓縮後的大小，以及加上編碼方式 Content-Encoding: gzip；再把 HTTP 回應發送給瀏覽器\n瀏覽器接到 HTTP 回應後，根據 Content-Encoding: gzip 來對 HTTP 回應進行解碼，獲取到原始 HTTP 回應後顯示出網頁\n註：HTTP 請求也是可以編碼的，但是瀏覽器一般不會對 HTTP 請求編碼\n內容編碼類型 HTTP 定義了一些標準的內容編碼類型，並允許用擴展的形式添加更多的編碼\n在 Header 中的 Content-Encoding 就是使用這些標準化的代號來說明編碼時使用的演算法\n編碼 描述 gzip 表明實體採用 GNU zip 編碼 compress 表明實體採用 UNIX 的檔案壓縮程式 deflate 表明實體是用 zlib 的格式壓縮的 identity 表明沒有對實體進行編碼。當 Header 中沒有 Content-Encoding 時，預設為此情況 gzip、compress 以及 deflate 編碼都是無損壓縮演算法，用於減少傳輸訊息的大小，不會導致資訊缺失。其中 gzip 通常效率最高，使用最為廣泛\n深入理解 Cookie 機制 HTTP 協定是無狀態的，對於瀏覽器的每一次請求，伺服器都會獨立處理，不與之前或之後的請求發生關聯。即使是同一個瀏覽器發送了 3 個請求，伺服器也會獨立處理這 3 個請求，伺服器並不知道這 3 個請求是來自同一個瀏覽器\n工作階段機制與 Cookie 機制 伺服器需要識別瀏覽器請求，就必須弄清楚瀏覽器的請求狀態。既然 HTTP 協定是無狀態的，那就讓伺服器和瀏覽器共同維護一個狀態，這就是工作階段 (Session) 機制\n瀏覽器第一次請求伺服器時，伺服器建立一個工作階段，並將工作階段 ID (Session ID) 作為回應的一部分發送給瀏覽器\n瀏覽器儲存工作階段 ID，並在後續請求中帶上工作階段 ID\n伺服器取得請求中的工作階段 ID 就知道是不是同一個使用者了\n這樣後續請求與第一次請求就產生了關聯，而 Cookie 機制就是一種工作階段機制\n伺服器在記憶體中保存工作階段物件，瀏覽器可以使用 Cookie 機制保存工作階段 ID\nCookie 是什麼 Cookie 是瀏覽器用來儲存少量資料的一種機制，資料以 key=value 形式儲存，多個 Cookie 之間以分號 ; 分隔，瀏覽器發送 HTTP 請求時自動附帶 Cookie 資訊\nCookie 最主要的作用是用來做使用者認證，還可以用於保存使用者的一些其他資訊。也可以用於網際網路精準廣告定向技術，例如使用者瀏覽了某些商品，就可以用 Cookie 記錄下來，然後進行大數據深度分析，實現廣告精準投放\n鑒於此項，目前歐洲的一些國家已經對 Cookie 立法，並規定必須經過使用者的允許才可以保存使用者的 Cookie\nCookie 的屬性 根據網站不同， Cookie 有所不同\nExpires 表示 Cookie 失效的時間，如果不指定則在關閉瀏覽器或頁面時被瀏覽器刪除\nPath 表示 Cookie 所屬的路徑，asp.net 預設為 / 也就是根目錄\n假設在同一個伺服器上的目錄如下：/test/、/test/cd/、/test/dd，Cookie1 的 Path 在 /test/，Cookie2 的在 /test/cd/，那麼 /test/ 下的所有頁面都可以存取到 Cookie1，而 /test/dd/ 的子頁面不能存取 Cookie2。因為 Cookie 只能讓其 Path 路徑下的頁面存取\nHttpOnly 這是個關乎安全方面的屬性，將一個 Cookie 設定為 HttpOnly 後，透過 JavaScript 腳本將無法讀取到 Cookie 資訊，這能有效防止用 XSS 發起攻擊\n一般來說，跟登入相關的 Cookie 必須設定為 HttpOnly\nCookie 的分類與位置 類別 描述 工作階段 Cookie 臨時的 Cookie，記錄了使用者存取站點時的設定與偏好 (例如存取本站時的 Cookie)，關閉瀏覽器後將被刪除 持久 Cookie 儲存在硬碟上，有過期時間。不管退出瀏覽器還是重啟電腦都存在 網站的自動登入就是儲存持久 Cookie，在使用者再次存取相同網站時會先在硬碟中查找相關 Cookie 然後放到 HTTP 請求訊息中發送給伺服器\n那麼持久 Cookie 存在電腦哪裡呢？不同瀏覽器會在各自的獨立空間存放 Cookie，互不干擾\n例如 Linux 下 Firefox 的 Cookie 位置：~/.mozilla/firefox/xxxxxxxx.default-release/cookies.sqlite\nHTTP 基本認證 HTTP 協定是無狀態的，瀏覽器和 Web 伺服器之間可以透過 Cookie 來識別身分。那麼一些桌面應用程式是如何跟 Web 伺服器之間識別身分呢？\n一些網站和 Web 服務使用的是 HTTP 基本認證。有些桌面應用程式也透過 HTTP 協定跟 Web 伺服器互動，桌面應用程式一般不使用 Cookie，而是把使用者名稱+冒號+密碼用 Base64 編碼放在 HTTP 請求 Header 中的 Authorization 發送給服務端，這種方式叫 HTTP 基本認證 (Basic Authentication)\n在基本認證中，Web 伺服器可以拒絕一個事務，要求用戶端提供有效的使用者名稱和密碼，伺服器會傳回 401 狀態碼來初始化認證質詢，並用 WWW-Authenticate 回應首部指定要存取的安全域。瀏覽器收到質詢時，會打開一個對話框請求使用者輸入使用者名稱和密碼，然後將使用者名稱和密碼用 Base64 編碼，再用 Authorization 請求首部發送給伺服器\n一般家用路由器就是使用基本認證， RESTful API 就經常使用基本認證，使用命令 curl -u username:password URI 即可完成基本認證\nHTTP 基本認證的缺點 HTTP 協定是無狀態的，同一個用戶端對伺服器的每個請求都需要認證\nBase64 編碼是可逆的，非常容易破解，所以基本認證相當於以明文的方式傳輸使用者名稱和密碼。所以基本認證一定要用 HTTPS 加密傳輸，稍微安全一點\n使用基本認證登入後，除非關閉瀏覽器或清除歷史記錄，否則無法登出。而 Cookie 機制的話，網站可以提供登出方式以使 Cookie 失效\n無法防止 重送攻擊 摘要認證 摘要認證是針對基本認證存在的諸多問題而進行改良的方案。摘要認證是另一種 HTTP 認證協定，它試圖修復基本認證的嚴重缺陷，進行如下改進\n透過傳遞使用者名稱、密碼等計算出來的摘要來解決以明文方式在網路上發送密碼的問題\n透過伺服器產生隨機數 nonce 的方式防止惡意使用者捕獲並重送認證的握手過程\n透過用戶端產生隨機數 nonce 的方式支援用戶端對伺服器的認證\n透過對內容也加入摘要計算的方式，可以有選擇地防止對訊息內容的篡改\n參考文章 《圖解 HTTP》讀後總結及淺談 - yexca\u0026rsquo;Blog HTTP 狀態碼 - 菜鳥教程 IE/Firefox/Chrome 等瀏覽器保存 Cookie 的位置 - 腳本小娃子 - 博客園 「登錄」還是「登錄」？ - 知乎 重送攻擊 - 維基百科，自由的百科全書 通俗易懂：到底什麼是 REST API？ 表現層狀態轉換 - 維基百科，自由的百科全書 ","date":"2022-09-05T16:03:36+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/64/","title":"HTTP 學習"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 前言 儘管 Fedora 系統本身就內建 Java 環境，不過是 OpenJDK。有時候還是會需要用到 Oracle 的 Java 環境。\n下載 前往官網下載： Java Downloads | Oracle (下載需要登入)\n找到 java8-Linux，下載 x64 Compressed Archive (64位元的壓縮檔版本)\n撰寫本文時，檔案名稱為 jdk-8u341-linux-x64.tar.gz\n移至指定目錄 首先建立一個 Java 的目錄，在 /usr/local 中 1 sudo mkdir -p /usr/local/java 將檔案複製到此目錄 假設下載的檔案在 ~/Downloads，請進入下載目錄\n1 cd Downloads 然後複製到上述目錄\n1 sudo cp -r jdk-8u341-linux-x64.tar.gz /usr/local/java 解壓縮安裝檔 切換到 Java 目錄 1 cd /usr/local/java 解壓縮安裝檔 1 sudo tar xvzf jdk-8u341-linux-x64.tar.gz 設定 $PATH 環境變數 在 /etc/profile 檔案的結尾處加入以下內容 1 2 3 4 JAVA_HOME=/usr/local/java/jdk1.8.0_341 PATH=$PATH:$HOME/bin:$JAVA_HOME/bin export JAVA_HOME export PATH 更新可用的 Java 版本清單 直接執行以下指令 1 sudo update-alternatives --install \u0026#34;/usr/bin/java\u0026#34; \u0026#34;java\u0026#34; \u0026#34;/usr/local/java/jdk1.8.0_341/bin/java\u0026#34; 1 1 sudo update-alternatives --install \u0026#34;/usr/bin/javac\u0026#34; \u0026#34;javac\u0026#34; \u0026#34;/usr/local/java/jdk1.8.0_341/bin/javac\u0026#34; 1 1 sudo update-alternatives --install \u0026#34;/usr/bin/javaws.itweb\u0026#34; \u0026#34;javaws.itweb\u0026#34; \u0026#34;/usr/local/java/jdk1.8.0_341/bin/javaws.itweb\u0026#34; 1 使設定檔生效 首先重新載入系統全域的 PATH 檔案 1 source /etc/profile 重新啟動系統 1 reboot 切換 Java 版本 您可以執行指令來查看 Java 版本\n1 java -version 使用以下指令切換 1 sudo alternatives --config java 目前使用的 Java 版本前方會有「+」符號，找到對應的版本，輸入數字選擇即可。\n參考文章 如何在 Fedora {OpenJDK 和 Oracle JDK} 上安裝 Java？ ","date":"2022-09-02T17:37:51+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/63/","title":"Fedora 安裝 java8(Oracle JDK)"},{"content":" 📢 本文由 Gemini-3-flash 翻譯 該文章由 Hiyoung 編寫\n其文章: https://blog.hiyoung.icu/2022/09/01/906d191f9a59/ Aria2 是 Linux 下的一個下載工具，這裡介紹 Windows 下的安裝與設定，官方 Aria2 沒有 GUI 介面，所以配合 AriaNG 直接在 Web 介面進行操作。\nAriaNg 是一個讓 aria2 更容易使用的現代 Web 前端。AriaNg 使用純 html \u0026amp; javascript 開發，所以它不需要任何編譯器或執行環境。\n下載 Aria2+AriaNG 最新安裝包 首先先在官網下載安裝包\nAria2 的 Github 地址 – Aria2 官方文件 AriaNG 的 Github 地址 – AriaNG 官方文件 Aria2 選擇對應的作業系統下載壓縮檔即可，AriaNG 解壓縮後放在 Aria2 資料夾即可。\nAriaNg 現在提供三種版本：標準版、單檔案版和 AriaNg Native。\n標準版適合在 Web 伺服器中部署，提供資源快取和按需載入的功能。\n單檔案版適合本地使用，您下載後只要在瀏覽器中打開唯一的 html 檔案即可。\nAriaNg Native 同樣適合本地使用，並且不需要使用瀏覽器。\n新增設定檔 將檔案解壓縮至該目錄下後，你需要再新建立 4 個空檔案 (可以先建一個空 txt 檔案然後修改副檔名)：\nAria2.log （日誌檔案） aria2.session （用於記錄下載歷史，以便斷點續傳） aria2.conf （設定檔） HideRun.vbs （隱藏 cmd 視窗執行時用到的） 修改設定檔 打開剛才建立的 aria2.conf 空檔案，將以下內容填入（用記事本打開即可） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 ## \u0026#39;#\u0026#39;開頭為註解內容, 選項都有相應的註解說明, 根據需要修改 ## ## 被註解的選項填寫的是預設值, 建議在需要修改時再取消註解 ## ## 檔案儲存相關 ## # 檔案的儲存路徑(可使用絕對路徑或相對路徑), 預設: 當前啟動位置 dir=E:\\Aria2Download # 日誌檔案的儲存路徑 log=D:\\aria2-1.36.0-win-64bit-build1\\Aria2.log # 啟用磁碟快取, 0為停用快取, 需1.16以上版本, 預設:16M #disk-cache=32M # 檔案預先分配方式, 能有效降低磁碟碎片, 預設:prealloc # 預先分配所需時間: none \u0026lt; falloc ? trunc \u0026lt; prealloc # falloc和trunc則需要檔案系統和核心支援 # NTFS建議使用falloc, EXT3/4建議trunc, MAC 下需要註解此項 #file-allocation=none # 斷點續傳 continue=true ## 下載連線相關 ## # 最大同時下載任務數, 執行時可修改, 預設:5 #max-concurrent-downloads=5 # 同一伺服器連線數, 新增時可指定, 預設:1 max-connection-per-server=5 # 最小檔案分片大小, 新增時可指定, 取值範圍1M -1024M, 預設:20M # 假定size=10M, 檔案為20MiB 則使用兩個來源下載; 檔案為15MiB 則使用一個來源下載 min-split-size=10M # 單個任務最大執行緒數, 新增時可指定, 預設:5 #split=5 # 整體下載速度限制, 執行時可修改, 預設:0 #max-overall-download-limit=0 # 單個任務下載速度限制, 預設:0 #max-download-limit=0 # 整體上傳速度限制, 執行時可修改, 預設:0 #max-overall-upload-limit=0 # 單個任務上傳速度限制, 預設:0 #max-upload-limit=0 # 停用IPv6, 預設:false #disable-ipv6=true # 連線逾時時間, 預設:60 #timeout=60 # 最大重試次數, 設定為0表示不限制重試次數, 預設:5 #max-tries=5 # 設定重試等待的秒數, 預設:0 #retry-wait=0 ## 進度儲存相關 ## # 從工作階段檔案中讀取下載任務 input-file=D:\\aria2-1.36.0-win-64bit-build1\\aria2.session # 在Aria2退出時儲存`錯誤/未完成`的下載任務到工作階段檔案 save-session=D:\\aria2-1.36.0-win-64bit-build1\\aria2.session # 定時儲存工作階段, 0為退出時才儲存, 需1.16.1以上版本, 預設:0 #save-session-interval=60 ## RPC相關設定 ## # 啟用RPC, 預設:false enable-rpc=true # 允許所有來源, 預設:false rpc-allow-origin-all=true # 允許非外部存取, 預設:false rpc-listen-all=true # 事件輪詢方式, 取值:[epoll, kqueue, port, poll, select], 不同系統預設值不同 #event-poll=select # RPC監聽通訊埠, 通訊埠被佔用時可以修改, 預設:6800 #rpc-listen-port=6800 # 設定的RPC授權權杖, v1.18.4新增功能, 取代 --rpc-user 和 --rpc-passwd 選項 #rpc-secret=\u0026lt;TOKEN\u0026gt; # 設定的RPC存取用戶名, 此選項新版已廢棄, 建議改用 --rpc-secret 選項 #rpc-user=\u0026lt;USER\u0026gt; # 設定的RPC存取密碼, 此選項新版已廢棄, 建議改用 --rpc-secret 選項 #rpc-passwd=\u0026lt;PASSWD\u0026gt; # 是否啟用 RPC 服務的 SSL/TLS 加密, # 啟用加密後 RPC 服務需要使用 https 或者 wss 協定連線 #rpc-secure=true # 在 RPC 服務中啟用 SSL/TLS 加密時的憑證檔案, # 使用 PEM 格式時，您必須通過 --rpc-private-key 指定私鑰 #rpc-certificate=/path/to/certificate.pem # 在 RPC 服務中啟用 SSL/TLS 加密時的私鑰檔案 #rpc-private-key=/path/to/certificate.key ## BT/PT下載相關 ## # 當下載的是一個種子(以.torrent結尾)時, 自動開始BT任務, 預設:true #follow-torrent=true # BT監聽通訊埠, 當通訊埠被封鎖時使用, 預設:6881-6999 listen-port=51413 # 單個種子最大連線數, 預設:55 #bt-max-peers=55 # 打開DHT功能, PT需要停用, 預設:true enable-dht=false # 打開IPv6 DHT功能, PT需要停用 #enable-dht6=false # DHT網路監聽通訊埠, 預設:6881-6999 #dht-listen-port=6881-6999 # 本地節點查找, PT需要停用, 預設:false #bt-enable-lpd=false # 種子交換, PT需要停用, 預設:true enable-peer-exchange=false # 每個種子限速, 對少種的PT很有用, 預設:50K #bt-request-peer-speed-limit=50K # 用戶端偽裝, PT需要 peer-id-prefix=-TR2770- user-agent=Transmission/2.77 # 當種子的分享率達到這個數時, 自動停止做種, 0為一直做種, 預設:1.0 seed-ratio=0.7 # 強制儲存工作階段, 即使任務已經完成, 預設:false # 較新的版本開啟後會在任務完成後依然保留.aria2檔案 #force-save=false # BT校驗相關, 預設:true #bt-hash-check-seed=true # 繼續之前的BT任務時, 無需再次校驗, 預設:false bt-seed-unverified=true # 儲存磁力連結元數據為種子檔案(.torrent檔案), 預設:false bt-save-metadata=true 注意：你需要將下面四行的內容修改為你自己對應的檔案位置：\n1 2 3 4 5 6 7 8 # 檔案的儲存路徑(可使用絕對路徑或相對路徑), 預設: 當前啟動位置 dir=E:\\Aria2Download # 日志檔案的儲存路徑 log=D:\\aria2-1.36.0-win-64bit-build1\\Aria2.log # 從工作階段檔案中讀取下載任務 input-file=D:\\aria2-1.36.0-win-64bit-build1\\aria2.session # 在Aria2退出時儲存`錯誤/未完成`的下載任務到工作階段檔案 save-session=D:\\aria2-1.36.0-win-64bit-build1\\aria2.session 最後兩行的內容是儲存下載歷史的，如果有時 Aria2 不能啟動的話，清空裡面的內容就可以了。\n修改 HideRun.vbs 檔案 打開 HideRun.vbs 檔案，向其中新增\n1 CreateObject(\u0026#34;WScript.Shell\u0026#34;).Run \u0026#34;aria2c.exe --conf-path=aria2.conf\u0026#34;,0 接下來點擊執行 HideRun.vbs 檔案，（注意一定是 HideRun.vbs 檔案而不是那個執行檔！！），如果沒有報錯的話可以直接跳過下面這段：\n注意一下，這裡也可以在檔案前新增具體的檔案目錄前綴，但是前綴的檔案目錄中一定不要有空格。\n例如：\n1 CreateObject(\u0026#34;WScript.Shell\u0026#34;).Run \u0026#34;C:\\Users\\he ne\\Downloads\\aria2c.exe --conf-path=aria2.conf\u0026#34;,0 但是由於 he ne 這一資料夾裡面包含空格，就導致了系統不辨識，類似的常見錯誤位置還多見於：D:\\Program Files (x86)，這裡也是存在空格的，解決方式就是將這一前綴去除即可（但需要該 vbs 檔案位於該 aria2 資料夾下）。\n打開 index.html 打開裡面的 index.html 檔案，如果顯示 「已連線」，則表明搭建成功。\n新增開機自啟動 建立 HideRun.vbs 檔案的捷徑，放入 Windows 的開機自啟動目錄即可：\n在執行視窗中輸入：shell:startup\n這裡便會打開自啟動目錄資料夾，然後將該捷徑拖入即可。\n參考文章：\nAria2+AriaNG 配置指南（Win10 篇） AriaNG 文檔 ","date":"2022-09-01T23:06:38+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/62/","title":"Aria2+AriaNG 配置使用"},{"content":"notify: 📢 本文由 gemini-2.5-flash-lite 翻譯 引言 預設情況下 Fiddler 僅能攔截 HTTP 封包，需要進行設定後才能捕獲 HTTPS 流量。目前大部分網站都使用 HTTPS 或 HSTS，因此開啟 HTTPS 封包攔截功能是很有必要的。\nFiddler 設定 在「設定」-「HTTPS」頁面中，勾選「Capture HTTPS traffic」即可。下方的「Ignore server certificate errors(unsafe)」也可以勾選，但可能存在安全風險，之後請儲存設定。\n瀏覽器設定 啟用 HTTPS 攔截後，使用瀏覽器可能會出現憑證錯誤，提示「連線不安全」或「連線不是私密連線」等訊息。此時需要匯入相關憑證。以 Firefox 為例：\n首先下載 Fiddler 憑證。在上一部的設定頁面中，點擊「Export root cerificate to Desktop」即可將憑證匯出至桌面 (~/Desktop/)。\n然後進入 Firefox 的設定，在「隱私與安全性」-「憑證」頁面中匯入剛剛下載的憑證，並在彈出的視窗中全選信任相關選項。\n匯入完成後，即可正常瀏覽網頁，Fiddler 也能正常攔截 HTTPS 的請求與回應。\n","date":"2022-09-01T08:17:32+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/61/","title":"Fiddler 攔截 HTTPS 封包"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 前言 個人在安裝 Fedora 後會安裝的一些應用程式和套件。\n修改終端機快速鍵 開啟「設定」-「鍵盤」，在最下方「檢視及自訂快速鍵」。\n自訂快速鍵\n名稱：Shell 終端機\n命令：gnome-terminal\n快速鍵：自訂\n更新系統 1 sudo dnf update 修改截圖快速鍵 還是習慣 Windows 的快速鍵\n上述「截圖」處「互動式截圖」改為「Win+Shift+S」。\n將使用者目錄改為英文 中文目錄在使用終端機操作時非常不便。\n首先將語系改為英文：\n1 export LANG=en_US 然後更新使用者目錄：\n1 xdg-user-dirs-gtk-update 這時，系統會提示您是否要將使用者目錄下的資料夾改為英文，請選擇「是」。\n然後再將系統語系切換回中文：\n1 export LANG=zh_CN.UTF-8 再次執行更新使用者目錄的指令：\n1 xdg-user-dirs-gtk-update 再次輸入上述指令時，系統會提示您是否要改回中文，請選擇「否」，並勾選「不再提醒」即可。\nVsCode 設定環境\n1 sudo rpm --import https://packages.microsoft.com/keys/microsoft.asc 1 sudo sh -c \u0026#39;echo -e \u0026#34;[code]\\nname=Visual Studio Code\\nbaseurl=https://packages.microsoft.com/yumrepos/vscode\\nenabled=1\\ngpgcheck=1\\ngpgkey=https://packages.microsoft.com/keys/microsoft.asc\u0026#34; \u0026gt; /etc/yum.repos.d/vscode.repo\u0026#39; 重新整理快取\n1 dnf check-update 使用dnf安裝\n1 sudo dnf install code 或者使用yum\n1 2 yum check-update sudo yum install code Edge 瀏覽器 從 Windows 轉移過來還不是特別習慣 Firefox，再加上多裝置同步功能很方便。（不過最安全的還是 IE 瀏覽器）\n下載 Microsoft Edge 網路瀏覽器 | Microsoft 下載.rpm檔案。\nMarkText 支援全平台的 Markdown 編輯器\nGitHub - marktext/marktext: 📝 一款簡潔優雅的 Markdown 編輯器，支援 Linux、macOS 和 Windows。 7-Zip 安裝\n1 yum install -y p7zip p7zip-plugins 壓縮\n1 7z a after.7z before 解壓縮\n1 7z x after.7z FeedReader RSS 閱讀器，我是從 Fedora 內建的「軟體」應用程式搜尋並下載的。\nTelegram 請記得將其放到/opt/Telegram目錄下再執行。\nTelegram Messenger 網易雲音樂 安裝與設定 Flatpak\n1 sudo dnf install flatpak 1 flatpak remote-add --if-not-exists flathub https://flathub.org/repo/flathub.flatpakrepo 安裝 netease.CloudMusic\n1 flatpak install flathub com.netease.CloudMusic 執行／點擊圖示執行\n1 flatpak run com.netease.CloudMusic 解除安裝\n1 flatpak uninstall com.netease.CloudMusic NVIDIA 驅動程式安裝 安裝\n1 sudo dnf install akmod-nvidia 選用\n1 sudo dnf install xorg-x11-drv-nvidia-cuda 安裝完成後重新啟動\n1 reboot note: 如果重新啟動後顯示「Nvidia kernel module missing falling back to Nouveau」\n首先請確保在 BIOS 中停用 Secure Boot\nCheck the version of akmods package installed by running rpm -qa akmods\nRun sudo akmods --force \u0026amp;\u0026amp; sudo dracut --force to build the kernel modules\n此處參考： Fedora 34 NVIDIA kernel module missing. Falling back to nouveau - #4，來自 vk2bea - Ask Fedora 如果上述方法無效，請嘗試使用以下方法：\n解除安裝所有與 NVIDIA 相關的套件：sudo dnf remove \\*nvidia\\*\n安裝驅動程式：sudo dnf install akmod-nvidia\n此處參考： Nvidia kernel module missing falling back to Nouveau (Fedora 36 PR) : Fedora 桌面最佳化 對我的筆記型電腦來說，預設字體有點太小了。\n1 sudo dnf install gnome-tweak-tool 安裝完成後，在應用程式中會有「最佳化」這個軟體。\nQQ/Icalingua++ 這個 Linux 版的 QQ 應該沒人會用吧，應該不會吧\n登入時和其他第三方應用程式一樣會報異常，也太離譜了。\nIcalingua++ 第三方版本： GitHub - Icalingua-plus-plus/Icalingua-plus-plus: A client for QQ and more. GNOME 擴充功能 不知道做什麼用，但感覺好像會派上用場。\n安裝主機連接器\n1 sudo dnf install chrome-gnome-shell gnome-extensions-app 前往 Latest extensions in GNOME Shell Extensions 安裝\nSpeedtest 依序輸入以下指令：\n1 curl -s https://packagecloud.io/install/repositories/ookla/speedtest-cli/script.rpm.sh | sudo bash 1 sudo yum install speedtest Fedora 已安裝 git，gcc，gdb，python，OpenSDK java\nLibreOffice\n參考文章 將 Fedora 下的使用者目錄改為英文 – 騰訊雲開發者社群-騰訊雲 CentOS Fedora 利用 p7zip 壓縮、解壓縮檔案_hkNaruto 的部落格-CSDN 部落格 Running Visual Studio Code on Linux fedora-netease-fedora 網易雲音樂安裝腳本。該腳本用於在 Fedora 上一鍵安裝網易雲音樂，測試於 Fedora KDE 30。 Howto/NVIDIA - RPM Fusion 安裝 Fedora 36 後# 需要做的 8 件事 桌面應用程式 - 如何使用 GNOME Shell 擴充功能 Howto/Secure Boot - RPM Fusion SPEEDTEST CLI: Internet connection measurement for developers ","date":"2022-08-24T12:13:30+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/59/","title":"Fedora 安裝後"},{"content":" 📢 本文由 Gemini-3-flash 翻譯 引言 今天使用 Git 推送時出現提示 fatal: unable to access 'https://github.com/yexca-VRChat/yexca-VRChat.github.io.git/': Failed to connect to 127.0.0.1 port 1081 after 2074 ms: Connection refused，重新啟動電腦也沒用，於是尋找解決方法 (為什麼不讓我存取自己的儲存庫)\n解決過程 經查閱相關資料後得知與代理伺服器（Proxy）有關，但我代理伺服器是設在路由器上啊\n於是我連線到另一個普通路由器再次推送，還是出現同樣的問題\n接著嘗試設定 Git 的代理伺服器也無果\n1 2 git config --global --unset http.proxy git config --global --unset https.proxy 最後想到我 WinXray 貌似、好像、大概開過吧，然後打開一看，果然開啟了 PAC，關閉後再次推送成功\n參考文章 fatal: unable to access \u0026lsquo;https://github.com/fmoraless/e-commerce.git/\u0026rsquo;: Failed to connect to 127.0.0.1 port 56832: Connection refuse · Issue #11981 · desktop/desktop 解決 git 下載出現：Failed to connect to 127.0.0.1 port 1080: Connection refused 拒絕連線錯誤_點亮～黑夜的博客-CSDN博客 git 報錯:解決拒絕存取問題_Huang_milk的博客-CSDN博客 ","date":"2022-08-15T02:44:47+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/58/","title":"GitHub 拒絕存取 Connection refused"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 引言 使用 Git 可以更好地和朋友一起管理程式碼，也方便同步程式碼。由於我比較喜歡靜態網站，因此使用 Git 同步網頁檔案非常實用。\n安裝 Git 登入 ROOT 帳號，依序輸入以下指令\n1 2 yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel perl-devel yum install git 建立使用者 建立一個 Git 使用者群組和使用者，用於執行 Git 服務\n1 2 groupadd git useradd git -g git 公開金鑰獲取 此部分為自己電腦的公開金鑰，以 Windows 為例\n在 %UserProfile%/.ssh/ 目錄下 id_rsa.pub 檔案儲存\n如果沒有此檔案，開啟 cmd 執行 ssh-keygen 指令會自動產生\n匯入公開金鑰 將待匯入的公開金鑰匯入 /home/git/.ssh/authorized_keys 檔案中，一行一個。如果沒有該檔案，則建立一個\n1 2 3 4 5 cd /home/git/ mkdir .ssh chmod 755 .ssh touch .ssh/authorized_keys chmod 644 .ssh/authorized_keys 然後使用 vi 或 vim 指令將公開金鑰匯入，使用參考： vim 文字編輯 初始化 Git 儲存庫 選定一個目錄作為 Git 儲存庫，假設為 /home/gitrepo/repo.git\n1 2 3 4 5 cd /home mkdir gitrepo chown git:git gitrepo cd gitrepo git init --bare repo.git 以上指令 Git 會建立一個空儲存庫，伺服器上的 Git 儲存庫通常都以 .git 結尾。然後，將儲存庫所屬使用者改為 git：\n1 chown -R git:git runoob.git 克隆儲存庫 1 2 3 git clone git@您的IP:倉庫目錄 // 例如 git clone git@127.0.0.1:/home/gitrepo/repo.git 同步目錄 自動同步功能用到的是 Git 的掛鉤 (hook) 功能\n進入儲存庫目錄 /home/gitrepo/repo.git\n1 2 cd /home/gitrepo/repo.git cd hooks 建立並編輯檔案 post-receive\n1 vi post-receive 在該檔案寫入以下內容\n1 2 #!/bin/sh git --work-tree=同步到的目錄 --git-dir=倉庫位置 checkout -f 例如\n1 2 #!/bin/sh git --work-tree=/home/www/hexo --git-dir=/home/gitrepo/repo.git checkout -f 然後設定該檔案讀寫權限\n1 chmod +x post-receive 改變 repo.git 目錄的擁有者為 git 使用者\n1 chown -R git:git /home/gitrepo/repo.git 更新程式碼 如果你能確定什麼都沒有改動過只是更新本地程式碼，直接使用\n1 git pull 正規流程\n1 2 3 4 5 6 7 8 9 // 查看本地分支檔案資訊，確保更新時不產生衝突 git status // 如果檔案有修改，可以還原到最初狀態; 如果檔案需要更新到伺服器上，應該先合併 (merge) 到伺服器，再更新到本地 git checkout – [file name] // 查看目前分支情況 git branch // 如果分支為本地分支，則需切換到伺服器的遠端分支 git checkout remote branch git pull 其他指令 1 2 3 4 git branch // 看看分支 git checkout aaa // 切換分支aaa git branck aaa // 建立aaa分支 git chechout -b aaa // 本地建立 aaa分支，同時切換到aaa分支。只有提交的時候才會在伺服器上建立一個分支 禁用 git 使用者的 shell 登入權限 出於安全考量，我們要讓 git 使用者不能透過 shell 登入。可以編輯 /etc/passwd 來實現\n1 vi /etc/passwd 將\n1 git:x:1004:1004::/home/git:/bin/bash 改為\n1 git:x:1004:1004::/home/git:/usr/bin/git-shell 這樣 git 使用者可以透過 ssh 正常使用 git，但是無法登入 sehll\n參考文章 Linux chown 指令-菜鳥教學 Git 伺服器建置-菜鳥教學 Git - 產生 SSH 公開金鑰 SSH key 的介紹與在 Git 中的使用 - 簡書 Git - 在伺服器上建置 Git git 更新程式碼到本地_ftToday 的部落格-CSDN 部落格 如何在伺服器上建置 hexo 部落格-阿里云開發者社群 Linux 權限詳解（chmod、600、644、700、711、755、777、4755、6755、7755）_林20 的部落格-CSDN 部落格 詳細解析 Linux /etc/passwd 檔案 - Jtianlin - 部落格園 ","date":"2022-08-13T10:28:50+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/57/","title":"建立 Git 伺服器並同步到指定目錄"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 這篇文章由 Hiyoung 撰寫\n其文章: https://blog.hiyoung.icu/2022/08/11/607cac6fe835/ 現在主流串流媒體網站都支援外連嵌入程式碼，但是 B 站 (什麼時候倒閉?) 現在 (2022/8/11) 內建的外連引用預設為 360P，且不能調節解析度，非常地討厭，與 Youtube 相比高下立判，下面重點介紹一下 B 站引用外連的參數和方法。\nBilibili 外連引用 原版引用連結：\n1 \u0026lt;pre class=\u0026#34;language-html\u0026#34; data-info=\u0026#34;HTML\u0026#34; data-role=\u0026#34;codeBlock\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token tag\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token tag\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026lt;\u0026lt;/span\u0026gt;iframe\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token attr-name\u0026#34;\u0026gt;src\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token attr-value\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation attr-equals\u0026#34;\u0026gt;=\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;//player.bilibili.com/player.html?aid=80433022\u0026amp;bvid=BV1GJ411x7h7\u0026amp;cid=137649199\u0026amp;page=1\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token attr-name\u0026#34;\u0026gt;scrolling\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token attr-value\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation attr-equals\u0026#34;\u0026gt;=\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;no\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token attr-name\u0026#34;\u0026gt;border\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token attr-value\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation attr-equals\u0026#34;\u0026gt;=\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;0\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token attr-name\u0026#34;\u0026gt;frameborder\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token attr-value\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation attr-equals\u0026#34;\u0026gt;=\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;no\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token attr-name\u0026#34;\u0026gt;framespacing\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token attr-value\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation attr-equals\u0026#34;\u0026gt;=\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;0\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token attr-name\u0026#34;\u0026gt;allowfullscreen\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token attr-value\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation attr-equals\u0026#34;\u0026gt;=\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;true\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token tag\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token tag\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026lt;/\u0026lt;/span\u0026gt;iframe\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; 修改後引用連結：\n1 \u0026lt;pre class=\u0026#34;language-html\u0026#34; data-info=\u0026#34;HTML\u0026#34; data-role=\u0026#34;codeBlock\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token tag\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token tag\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026lt;\u0026lt;/span\u0026gt;iframe\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token attr-name\u0026#34;\u0026gt;src\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token attr-value\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation attr-equals\u0026#34;\u0026gt;=\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;//player.bilibili.com/player.html?aid=80433022\u0026amp;bvid=BV1GJ411x7h7\u0026amp;cid=137649199\u0026amp;page=1\u0026amp;as_wide=1\u0026amp;high_quality=1\u0026amp;danmaku=1\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token attr-name\u0026#34;\u0026gt;scrolling\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token attr-value\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation attr-equals\u0026#34;\u0026gt;=\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;no\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token attr-name\u0026#34;\u0026gt;border\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token attr-value\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation attr-equals\u0026#34;\u0026gt;=\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;0\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token attr-name\u0026#34;\u0026gt;frameborder\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token attr-value\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation attr-equals\u0026#34;\u0026gt;=\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;no\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token attr-name\u0026#34;\u0026gt;framespacing\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token attr-value\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation attr-equals\u0026#34;\u0026gt;=\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;0\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token attr-name\u0026#34;\u0026gt;allowfullscreen\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token attr-value\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation attr-equals\u0026#34;\u0026gt;=\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;true\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token tag\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token tag\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026lt;/\u0026lt;/span\u0026gt;iframe\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; 嗶哩嗶哩外連 key 說明 key 說明 aid 之前 B 站使用的 AV 號 bvid 目前的 BV 號 page 第幾個影片, 起始下標為 1 (預設值也是 1) 就是 B 站影片選集裡的第幾個影片 as_wide 是否寬螢幕 【1: 寬螢幕, 0: 小螢幕】 high_quality 是否高畫質 【1: 高畫質 (最高 1080p) / 0: 最低影片畫質 (預設)】 danmaku 是否開啟彈幕 【1: 開啟 (預設), 0: 關閉】 vd_source=XXX\u0026amp;t=XXX 可加上精準空降位址 YouTube 外連引用 使用預設的 YouTube 外連即可，更進階功能可自行去 官方教學 學習。\n1 \u0026lt;pre class=\u0026#34;language-html\u0026#34; data-info=\u0026#34;HTML\u0026#34; data-role=\u0026#34;codeBlock\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token tag\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token tag\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026lt;\u0026lt;/span\u0026gt;iframe\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token attr-name\u0026#34;\u0026gt;width\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token attr-value\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation attr-equals\u0026#34;\u0026gt;=\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;560\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token attr-name\u0026#34;\u0026gt;height\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token attr-value\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation attr-equals\u0026#34;\u0026gt;=\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;315\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token attr-name\u0026#34;\u0026gt;src\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token attr-value\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation attr-equals\u0026#34;\u0026gt;=\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;https://www.youtube.com/embed/OgcCOwj7wNY\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token attr-name\u0026#34;\u0026gt;title\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token attr-value\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation attr-equals\u0026#34;\u0026gt;=\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;YouTube video player\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token attr-name\u0026#34;\u0026gt;frameborder\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token attr-value\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation attr-equals\u0026#34;\u0026gt;=\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;0\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token attr-name\u0026#34;\u0026gt;allow\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token attr-value\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation attr-equals\u0026#34;\u0026gt;=\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token attr-name\u0026#34;\u0026gt;allowfullscreen\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token tag\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token tag\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026lt;/\u0026lt;/span\u0026gt;iframe\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; 影片演示 請前往 https://blog.hiyoung.icu/2022/08/11/607cac6fe835/ 觀看效果\nYoutube 1 2 3 4 5 6 7 8 9 \u0026lt;iframe allow=\u0026#34;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\u0026#34; allowfullscreen=\u0026#34;\u0026#34; frameborder=\u0026#34;0\u0026#34; height=\u0026#34;315\u0026#34; loading=\u0026#34;lazy\u0026#34; src=\u0026#34;https://www.youtube.com/embed/ucbx9we6EHk\u0026#34; title=\u0026#34;YouTube video player\u0026#34; width=\u0026#34;560\u0026#34;\u0026gt;\u0026lt;/iframe\u0026gt; ### Bilibili (修改前) \u0026lt;iframe allowfullscreen=\u0026#34;true\u0026#34; border=\u0026#34;0\u0026#34; frameborder=\u0026#34;no\u0026#34; framespacing=\u0026#34;0\u0026#34; scrolling=\u0026#34;no\u0026#34; src=\u0026#34;//player.bilibili.com/player.html?aid=499408391\u0026amp;bvid=BV16K411N7qj\u0026amp;cid=230404689\u0026amp;page=1\u0026amp;as_wide=1\u0026#34;\u0026gt; \u0026lt;/iframe\u0026gt; ### Bilibili (修改後) \u0026lt;iframe allowfullscreen=\u0026#34;true\u0026#34; border=\u0026#34;0\u0026#34; frameborder=\u0026#34;no\u0026#34; framespacing=\u0026#34;0\u0026#34; scrolling=\u0026#34;no\u0026#34; src=\u0026#34;//player.bilibili.com/player.html?aid=499408391\u0026amp;bvid=BV16K411N7qj\u0026amp;cid=230404689\u0026amp;page=1\u0026amp;high_quality=1\u0026amp;danmaku=1\u0026#34;\u0026gt; \u0026lt;/iframe\u0026gt; 參考資料： Sanarous 部落格 和 Google 外連 API 教學 ","date":"2022-08-12T00:11:17+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/56/","title":"部落格影片外連引用"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 前言 最早接觸 RSS 還是逛神社的時候，但當我知道有這麼個東西的時候 RSS 就幾乎凋零，不過還有類似於 RSSHub 之類的還在繼續為之奮鬥，不過 RSSHub 時常因網路問題無法連線，慢慢地就放棄了。隨著發現的部落格越來越多，為了能夠即時獲取更新以及記錄自己閱讀過以及未閱讀的文章，我再次使用 RSS\nRSS 簡介 RSS 的全稱是 Really Simple Syndication（簡易資訊聚合），它是一種訊息來源的格式規範，網站可以按照這種格式規範提供文章的標題、摘要、全文等資訊給訂閱使用者，使用者可以透過訂閱不同網站 RSS 連結的方式將不同的資訊來源進行聚合，在一個工具裡閱讀這些內容\n換句話說，與當前主流媒體推薦內容使我們被動獲取資訊不同，RSS 是主動尋找知識的過程，需要我們主動發掘資訊來源，而且只會顯示自己訂閱資訊來源的內容\n為什麼使用 RSS 拿起手機，打開資訊類 App，首頁就是推薦，再加上永遠刷不到底部的設計和基於大數據的喜好推薦，很容易就將一天的時間陷入這些觀點單一、毫無營養的內容。我不喜歡這種時間消逝的感覺，雖然學習之餘需要放鬆刷一下，但我始終堅持放鬆應該要由自己掌控，不應被這種被動式接受，所以使用 RSS 也是我對資訊繭房的一種抵抗吧\n往小了說，可能是為了標記自己未閱讀的文章，獲取自己關注的部落格的文章，也為了不錯過大神的文章吧\n往大了說，在現如今推薦演算法不斷升級、不斷精確的情況下，資訊繭房愈加嚴重，慢慢地失去了主動獲取資訊的能力，從而導致自己視野受限，甚至於失去學習能力\n如何使用 首先需要 RSS 閱讀器，我選擇 QuiteRSS ，是一款開源軟體\n然後需要 RSS 訂閱來源，這個需要自行尋找啦，如果網站不提供可以到 RSSHub 尋找是否有發布相關訂閱來源 (請保持網路環境正常)\n如何尋找 RSS 訂閱來源： 如何尋找要與 Feedzy RSS Feeds 一起使用的 RSS Feed URL 比如說本站的簡體中文 RSS 訂閱來源： https://blog.yexca.net/feed.xml 檢測是否為訂閱來源： Feed Validator for Atom and RSS 複製訂閱來源，打開軟體，建立新訊息來源即可\n後記 唉，本來想著描述得挺好的，但真正寫的時候我發現我無法使用語言來表達自己所要抒發的情感，不是無法使用語言表達，只是可能我深受各種網路資訊毒害，可能……已經不會寫文章了吧……\n寫之前想了很多，但真到寫的時候卻完全不知道怎麼表達，就這樣吧！\n參考文章/推薦閱讀 求問神社的 rss 是啥啊 高效獲取資訊，你需要這份 RSS 入門指南 - 騰訊雲開發者社區 RSS - 維基百科 RSS 凋零——主動獲取資訊到推送時代 什麼是 RSS？ ","date":"2022-08-09T16:08:14+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/55/","title":"RSS"},{"content":"notify: 📢 本文由 gemini-2.5-flash 翻譯 前言 昨日玩遊戲時接取第一個任務的記錄，由於是複述，部分細節可能與實際情況不同。\n接取任務 在通過某神秘人的考驗後取得 HackShop 的網站，接到第一個任務。\n任務內容為：「The client wants the login credentials of the user Daronane. The remote ip of the victim is 54.44.37.52. It\u0026rsquo;s important that you access the correct machine behind the public ip. The victim\u0026rsquo;s ip LAN is 172.16.6.7。」\n任務分析 任務要求為 Daronane 的登入憑證，受害者的公開 IP 位址為 54.44.37.52，區域網路 IP 位址為 172.16.6.7。\n初步試探 依照 Grey Hack 單人模式遊戲攻略（1）-MapleGe 文章所述的方法嘗試。\n首先使用 whois 指令取得管理員電子郵件地址為 Eggett@sabmi.net，向該電子郵件寄送 Login issue 郵件以取得 Daronane 的密碼 pierra。\n嘗試使用 SSH 連線 54.44.37.52，輸入指令 ssh Daronane@pierra 54.44.37.52 後發現連線失敗，錯誤訊息為 incorrect user/password。\n我懷疑是我輸入錯誤 (畢竟是手動輸入的帳號密碼)，然後嘗試了幾次，甚至複製貼上也是帳號或密碼錯誤，便停止嘗試。\n我使用瀏覽器存取該 IP 位址，自然是沒什麼線索，只有一行文字 Metlifegroup. Everything you need for your tech company 與一張圖片 (貌似是樹莓派)，猜測該網站可能是一個討論區，而受害者 Daronane 為該討論區的使用者？\n遊戲中文化 想到在存取 HackShop 時彈出的 Exploits 教學有部分我沒看懂，於是尋找該遊戲的中文化，開啟創意工坊，果然找到了該遊戲的繁體中文化 [简体中文](simplified Chinese)，訂閱後重新啟動遊戲，卻發現介面沒有中文化。\n找到創意工坊的下載位址：steam資料夾\\steamapps\\workshop\\content\\605230\\2825584160。透過閱讀 README.md 檔案得知，需要將該資料夾下的內容放至 C:\\Users\\%UserName%\\AppData\\LocalLow\\Loading Home\\Grey Hack\\ 資料夾下。\n事實上，只需要將 custom_lang.json 放入上述資料夾即可。\n重新進入遊戲後，在左側的 language 選擇 Chinese 即可中文化。\n閱讀手冊 閱讀中文化後手冊的 Exploits 部分 (發現跟沒中文化差不多)，還是不大理解這個東西是做什麼的。\n繼續探尋 繼續搜尋相關攻略，卻一無所獲，直到看到文章 Grey Hack: 一個比較簡單的任務 - 嗶哩嗶哩 。\n文章中腳本小子一詞使我了解到這個 Exploits 相當於現實中的攻擊腳本。\n錯誤探索 到 HackShop 下載工具 scanlib 與 scanrouter。\n嘗試執行指令 scanlib 54.44.37.52，提示 Missing metaxploit，看不懂。\n使用指令 nmap 54.44.37.52，得知該伺服器開放兩個連接埠，分別為 22 和 80，各自提供 SSH 與 HTTP 服務。\n使用指令 scanrouter 得知該伺服器有 Kernel_router.so:V1.0.0，然後尋找相關腳本，找到一個腳本描述為 Get access to a shell，沒有要求。\n我將該腳本下載到 /home/yexca/hacktool，然後在終端機進入該資料夾並輸入指令 KernelRouterAccess 54.44.37.52，錯誤提示為 Can't find metaxploit library in the /lib path or the current folder。\n註：一開始沒有重新命名，後來重新命名為 KernelRouterAccess，本文以此名稱為例撰寫，本文其他腳本均為後續重新命名，與商店中原名稱不同\n從錯誤來看是缺少檔案，看到 /lib 難道是對方伺服器沒有相應檔案無法辨識，因此無法進入嗎？\n再次思索 考慮到透過 nmap 指令得知這個伺服器開放 22 和 80 埠，又上述猜測受害者為該討論區使用者，於是到 HackShop 尋找 http 腳本，找到一個腳本描述為 Grant access to the file /etc/passwd and decipher its contents，要求為 Minimum number of 1 users registered in the computer，也就是至少一名使用者，該網站為討論區，估計應該不會直接使用 root 帳號進行開發吧，而且估計是多使用者開發。\n下載腳本後輸入指令 HttpPasswd 54.44.37.52 80，和使用上一個腳本一樣提示 Can't find metaxploit library in the /lib path or the current folder。\n我並沒有感到驚訝，因為透過 scanrouter 指令掃描只發現 Kernel_router.so:V1.0.0，沒有 libhttp.so 之類的函式庫。\n事實上我選擇 HTTP 腳本，也是由於上述文章提到其實只要完成任務就行，不需要遠端連線，你在本機執行腳本也不會留下痕跡。\n然後我想著那就繼續嘗試 SSH 吧，便進入 HackShop 尋找相應腳本，找到一個腳本描述為 Take advantage of a vulnerability in the ssh service to inject a new password to a registered user，要求為 Any user logged in the computer，也就是有使用者登入過，考慮到開發該網站一定需要登入，所以該要求應該可以達到。\n下載腳本後輸入指令 SSHPasswd 54.44.37.52 22，還是提示 Can't find metaxploit library in the /lib path or the current folder。\n這**怎麼玩？？？貴伺服器的 /lib 是什麼都沒有嗎？難道我要每種腳本都試一遍來確定 /lib 有什麼嗎？？？？那我豈不是會破產啊。\n進入正軌 於是我借助搜尋引擎尋找攻略，卻發現沒有。\n再次回想之前看到的錯誤條件 Can't find metaxploit library in the /lib path or the current folder，我只看到了前面的 /lib 以及看不懂的 metaxploit，仔細查看後面有一個 or the current folder，這個 目前資料夾 是指什麼呢？難道是我電腦上該腳本所在的資料夾，那我為了進攻豈不是要把相應的函式庫像 libssh.so 之類的都下載一遍？\n開啟黑市，並沒有像 libssh.so 之類的函式庫，聯想到該遊戲有指令 apt-get，在現實 Linux 中可以下載相關程式，於是在遊戲中輸入指令 apt-get search ssh，果不其然有一個 libssh.so，使用指令 apt-get install libssh.so 安裝 SSH。\n安裝完成後輸入指令 SSHPasswd 54.44.37.52 22，結果還是提示 Can't find metaxploit library in the /lib path or the current folder。\n我真是服了！！！\n再次開啟 HackShop，我把 Tools 下的每個商品都看了一遍，其中 metaxploit.so 引起我的注意，這不就是錯誤訊息中的那個 metaxploit 嘛！再結合錯誤訊息中的 current folder，是不是因為缺少這個東西才報錯啊。\n下載至腳本所在的資料夾 (/home/yexca/hacktool)，考慮到 scanrouter 指令只掃描到 Kernel_router.so，嘗試執行 KernelRouterAccess 54.44.37.52，果然，取得了進入權限！\n取得權限 取得進入權限後，想著先去刪除紀錄檔，輸入指令 FileExplorer.exe，存取 /var/system.log，提示 Permission denied，權限不足。然後發現這個腳本取得的是訪客權限，那我找密碼檔案吧，存取 /etc/passwd，還是提示 Permission denied (事實上我幾乎把該電腦的檔案都看了一遍)。\n啊這，那我買這個腳本有什麼用啊！\n因為 SSH 腳本是更改密碼，風險較高，所以我使用 HTTP 腳本來取得密碼。輸入指令 HttpPasswd 54.44.37.52 80，結果提示 can't read /etc/passwd. Permission denied，看到取得的權限是 guest，我**\n最後還是使用 SSH 腳本，輸入指令 SSHPasswd 54.44.37.52 22，輸入新密碼 114514，成功修改了 Farraze 的密碼。\n輸入指令 ssh Farraze@114514 54.44.37.52，成功進入受害者的機器，輸入指令 cat /etc/passwd，成功取得 root 的密碼加密資訊。\n在本機新建一個檔案 (touch mima.txt)，將 root 密碼資訊複製到裡面，然後解密 decipher mima.txt，成功取得 root 的密碼為 44444 (這密碼也太隨便了吧)。\n輸入指令 exit 中斷連線，接著輸入 ssh root@44444 54.44.37.52，成功以 root 權限登入。\n進入機器 進入後第一件事就是刪除紀錄檔，然後該機器的使用者有 Ralancl 和 Farraze，沒有受害者 Daronane，果然是討論區使用者嗎？但我將這台機器翻了一遍也沒找到相關東西 (順便把這兩個帳戶的錢轉到我的帳戶上啦~)\n回想任務內容，提到了 IP 172.16.6.7。\n輸入指令 ping 172.16.6.7，顯示 Ping successful，使用自己的電腦無法 Ping 通 (這根本是廢話，內部網路的機器怎麼可能 Ping 通)。\n輸入指令 nmap 172.16.6.7 查看開放埠，提示 command not found，指令未找到。\n啊這，那我只好將我電腦的指令檔案放到該電腦的 /bin 目錄下了。\n複製過去後再次輸入指令 nmap 172.16.6.7，可以看到開放了 3306 埠，服務為 employees，這是什麼東西？\n透過搜尋引擎得知 3306 埠一般為資料庫埠，也就是說需要使用 SQL 的腳本。\n取得密碼 進入 HackShop，搜尋相關腳本，找到一個腳本描述為 Take advantage of a vulnerability in the sql service to inject a new password to a registered user，要求為 Any user logged in the computer，也就是有使用者登入過，資料庫的建立必然要有使用者登入過啊。\n下載後輸入指令 SqlChangePasswd 172.16.6.7 3306，提示 Connection refused. Address unreachable，存取被拒。確實，資料庫肯定是白名單的啦。\n將腳本與 metaxploit.so 放到受害者機器 /root 資料夾下，再次輸入指令，修改密碼為 114514，修改使用者為 Osquel。\n那麼現在問題來了，我修改密碼然後呢？這伺服器只開放了 3306 埠，我也進不去啊 XD\n好吧，再次進入 HackShop，搜尋相關腳本，找到一個腳本描述為 Prints the contents of the file /etc/passwd，要求為 Any user logged in the computer，也就是有使用者登入過，和剛剛腳本的要求一樣。\n將腳本放到受害者機器 /root 資料夾下，輸入指令 SqlPrintPasswd 172.16.6.7 3306，得到該機器所有使用者的密碼，其中有受害者 Daronane 的。\n複製到自己的電腦並解密後得到密碼為：pierra。\n？？？我將此密碼傳送給客戶，得到了肯定的答覆？？？\n我**\n精彩！ (來自於 YouTuber 黑鏢客 的梗)\n後記 一開始就透過電子郵件取得了密碼，然後我一番折騰後再次取得了密碼 (這真的讓我超無言的)。\n收入為 200，但我購買腳本花費遠大於 200 (整體來說還是蠻虧的)，不過腳本可以重複使用，而且探索的過程也是很有趣的喔！\n這款遊戲的攻略可以說幾乎沒有啊，如果您正在尋找相關攻略，希望這篇文章能有所幫助。\n","date":"2022-08-03T22:41:06+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/54/","title":"記錄 Grey Hack 第一個任務 (取得密碼)"},{"content":" 📢 本文由 Gemini-3-flash 翻譯 這篇文章由 Hiyoung 撰寫\n其文章: https://blog.hiyoung.icu/2022/08/03/0b5e2db181ab/ 最近經常要使用 GitHub 儲存我學習過程中的程式碼，發現無法直接上傳資料夾，於是在網路上查了一下如何使用 Git 上傳，所以寫篇部落格文章記錄一下。\nGitHub 端操作 1. 複製儲存庫網址 本地端操作 1. 在本地端新建一個空資料夾 我這裡已經 clone 完成\n2. 在資料夾內開啟 Git Bash 視窗 3. Clone 遠端儲存庫 1 2 \u0026lt;pre class=\u0026#34;language-bash\u0026#34; data-info=\u0026#34;bash\u0026#34; data-role=\u0026#34;codeBlock\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token function\u0026#34;\u0026gt;git\u0026lt;/span\u0026gt; clone + 你的儲存庫網址 \u0026lt;span class=\u0026#34;token function\u0026#34;\u0026gt;git\u0026lt;/span\u0026gt; clone https://github.com/hiyoung3937/study_code.git //範例 4. 直接將需要上傳的檔案拖入即可 5. 上傳 1 2 3 4 5 \u0026lt;pre class=\u0026#34;language-bash\u0026#34; data-info=\u0026#34;bash\u0026#34; data-role=\u0026#34;codeBlock\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token builtin class-name\u0026#34;\u0026gt;cd\u0026lt;/span\u0026gt; study_code.git //根據自己的遠端儲存庫名稱輸入 \u0026lt;span class=\u0026#34;token function\u0026#34;\u0026gt;git\u0026lt;/span\u0026gt; init \u0026lt;span class=\u0026#34;token function\u0026#34;\u0026gt;git\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token function\u0026#34;\u0026gt;add\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token builtin class-name\u0026#34;\u0026gt;.\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token function\u0026#34;\u0026gt;git\u0026lt;/span\u0026gt; commit -m “你的提交訊息” \u0026lt;span class=\u0026#34;token function\u0026#34;\u0026gt;git\u0026lt;/span\u0026gt; push 指令說明 clone + 儲存庫網址 複製你的儲存庫至本地端 cd + 你的遠端儲存庫名 進入到遠端儲存庫內 (根據自己的儲存庫名稱輸入) git init 初始化 Git git add . 將工作區的檔案新增至暫存區（「.」是目前目錄下的所有檔案，也可只輸入資料夾名稱） git commit -m “你的提交訊息” 將暫存區的檔案新增至本地端儲存庫 git push 推送至遠端儲存庫（可能需要輸入帳號與密碼） ","date":"2022-08-03T12:49:27+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/53/","title":"使用 Git 上傳檔案至 GitHub"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 前言 哪個男孩不想用命令列執行一些東西來耍帥呢？之前我稍微了解過 youtube-dl，但看起來太複雜就沒去用，今天嘗試用過之後發現超級好用啊！\n環境 安裝 Python3.7+ 直接到 Python 官網 下載並安裝即可，安裝時記得勾選Add Python x.x to PATH\n安裝 yt-dlp yt-dlp 是基於 youtube-dl 修改的，實際測試下載速度比較快。\n下載 進入 releases 下載 yt-dlp.exe\n設定 把下載的檔案放到一個固定位置，開啟 我的電腦 的 內容，進入 進階系統設定 -\u0026gt; 環境變數 -\u0026gt; 系統變數，選取 Path，點選編輯，在新視窗點選新增，輸入 yt-dlp.exe 檔案所在的資料夾路徑。\n接著連續點三個 確定 來關閉所有視窗。\n測試 按下 Win+R 輸入 cmd，然後按 Enter 鍵。\n在 cmd 中輸入 yt-dlp，如果出現 Usage: yt-dlp [OPTIONS] URL [URL...] 就代表設定成功。\n更新 在 cmd 中輸入 yt-dlp -U 即可。\n下載影片 直接在 cmd 中輸入 yt-dlp+空白鍵+YouTube 影片連結 即可開始下載。\n預設會下載 720P 的畫質，儲存位置在 C:/Users/%UserName%/\n修改下載儲存位置 在 C:\\Users\\%UserName%\\AppData\\Roaming 建立一個資料夾並命名為 yt-dlp，接著進入剛建立的資料夾內，再建立一個檔案 config.txt。\n在檔案內輸入以下程式碼\n1 -o \u0026#39;C:/Users/%UserName%/Downloads/Video/%(title)s.%(ext)s\u0026#39; 其中 C:/Users/%UserName%/Downloads/Video/ 為下載目錄。\n%(title)s.%(ext)s 為儲存檔案名稱的格式，此處為影片標題.影片副檔名。\n下載 1080P 因為 1080P (含) 以上的影片是音訊和視訊分離的，所以需要先下載 ffmpeg。\nffmpeg 進入 官網 ，左下角選擇系統類型，接著選擇下載。\n我選擇的是 Releases · BtbN/FFmpeg-Builds ，下載 ffmpeg-n5.0-latest-win64-gpl-5.0.zip。\n接著放到一個固定資料夾，並把 bin 檔案目錄放到系統變數裡。\n測試 開啟 cmd，輸入 ffmpeg -version，如果出現版本號就代表設定成功。\n查詢命令 輸入 yt-dlp -D [URL] 即可查看目前影片的所有格式 (僅查詢，不下載)。\n下載命令 輸入 yt-dlp -f [ID] [URL] 來下載指定格式的影片，也可以使用 [ID]+[ID] 組合來下載影片和音訊，也就是 yt-dlp -f [ID]+[ID] [URL]，下載完成後會自動合併。\n註：下載最高畫質與音訊：-f \u0026quot;bv+ba/b\u0026quot;\n呼叫 aria2 在下載命令後加入 --external-downloader aria2c --external-downloader-args \u0026quot;-x 16 -k 1M\u0026quot; 即可。\n下載字幕 1 2 3 4 5 6 7 outube-dl --write-sub [url] // 這樣會下載一個 vtt 格式的英文字幕和 mkv 格式的 1080p 影片下來 youtube-dl --write-sub --skip-download [url] // 下載單獨的 vtt 字幕檔，而不會下載影片 youtube-dl --write-sub --all-subs [url] // 下載所有語言的字幕 (如果有的話) youtube-dl --write-auto-sub [url] // 下載自動產生的字幕 (YouTube only) 下載影片清單 1 2 3 4 5 6 7 youtube-dl -f [format code] [palylist_url] // 這種方式可以下載指定清晰度的 mp4 影片 youtube-dl [playlist_url] // 下載影片清單，這種方式下載的影片可能是 mkv 格式或 webm 格式 youtube-dl -cit [playlist_url] // 下載影片清單，這種方式下載的影片可能是 mkv 格式或 webm 格式 youtube-dl --yes-playlist [url] // 當連結為影片清單時，則下載該清單的影片，跟上面的一樣，可能是 mkv 或 webm 格式 視覺化介面 Releases · jely2002/youtube-dl-gui 參考文章 yt-dlp 的 Github 頁面 【備份】youtube-dl 使用介紹 - 簡書 一篇搞懂 Windows 系統【目錄變數】的相關知識_黑就黑到底的部落格-CSDN部落格_username變數 ","date":"2022-07-25T12:52:27+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/52/","title":"用命令列下載 YouTube 影片"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 前言 近日上網時發現一款覺得還不錯的字型，便找尋更換字型的方法。但實際使用下來並沒有那麼驚艷\n方法一 左下方「管理」-「設定」(或者快速鍵CTRL+,)進入設定介面，找到「Editor:Font Family」\n將預設的 Consolas, 'Courier New', monospace 改為要更換的字型即可\n方法二 Ctrl + Shift + P -\u0026gt; 輸入 settings.json -\u0026gt; 選擇 「Preferences:Open Settings(JSON)」 開啟 settings.json 檔案，然後將 \u0026quot;editor.fontFamily\u0026quot;: \u0026quot;要更改的字型\u0026quot;加入到 {} 中並儲存即可\n中英文字型分開設定 我們可以觀察到 VS Code 的預設字型有三種，以 , 區隔：Consolas, 'Courier New', monospace，若要為中英文設定不同的字型，只需要將第一個和第二個分別設定一個英文字型和一個中文字型（英文字型, 中文字型）即可，例如SF NS Mono, '楷體'\n","date":"2022-07-13T17:47:57+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/51/","title":"VS Code 更換字型"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 似乎沒有解決方法，不過可以將快速存取中自己加入的全部刪除 (恢復預設)\n前往 C:\\\\Users\\\\使用者名稱\\\\AppData\\\\Roaming\\\\Microsoft\\\\Windows\\\\Recent\\\\AutomaticDestinations，將此資料夾目錄下的檔案備份後全部刪除\n參考文章 FTP 位址無法從快速存取中移除，但其他資料夾可以 – Microsoft Community ","date":"2022-06-27T13:31:58+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/50/","title":"Windows 網路位址 (FTP 位址) 取消快速存取"},{"content":" 📢 本文由 Gemini-3-flash 翻譯 引言 今天嘗試了一下之前試過的無線中繼，發現已經忘記怎麼做了，果然實作過的東西還是要寫篇文章記錄一下比較好。\n在本文中，將 OpenWRT 路由器連接的 Wi-Fi 稱為上層路由，OpenWRT 路由器稱為路由器。\n前提 確保路由器與上層路由的 LAN 埠位址（即進入路由器後台的位址）不可與上層路由一致，若一致將無法上網。\n修改路由器 LAN 埠位址 進入路由器後台的「網路」-「介面」，點擊「LAN」的「修改」，更改其「IPv4 位址」即可。\n例如上層路由後台位址為 192.168.1.1，路由器可改為 192.168.5.1。\n修改完成並「儲存並套用」後，在瀏覽器輸入修改後的位址即可訪問路由器後台。\n路由器連接 Wi-Fi 進入「網路」-「無線」，點擊「掃描」，找到要連接的 Wi-Fi，點擊「加入網路」，輸入網路名稱與密碼，點擊「提交」，然後點擊「儲存並套用」即可。\n路由器開啟 Wi-Fi 如果路由器支援 2.4G 與 5G 雙頻段，可以選擇與上一步不同的頻段建立 Wi-Fi，這樣相容性最好。（如果另一個頻段已經有一個 Wi-Fi，可能已經可以使用了）\n如果只有單頻段，則在相同頻段新建一個。必須要新建，且不一定會成功，畢竟有些路由器不支援單網卡同時接收與發送。\n設定 Wi-Fi 與一般流程相同，在「網路」-「無線」處新增，輸入 SSID（即 Wi-Fi 名稱）和密碼，然後「儲存並套用」即可。\n參考文章 OpenWrt 进阶教程之无线中继配置指南 - 爱一枝梅 ","date":"2022-06-23T14:50:21+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/49/","title":"OpenWRT 無線中繼"},{"content":" 此文章由 Hiyoung 編寫\n其文章: https://blog.hiyoung.icu/2022/08/18/5be9517606f2/ notify: 📢 本文由 gemini-2.5-flash 翻譯 使用 PS 自動化腳本批次處理圖片 點擊功能表的「視窗」-\u0026gt;「動作」(快捷鍵 alt+F9) 在分頁底部點擊「新增資料夾」（新增群組），命名為「修改圖片大小」（可自行重新命名） 再點擊旁邊的「建立新動作」，我們可以看到底部圓點變為紅色 點擊「檔案」、「開啟舊檔」，開啟我們要處理的其中一張圖片，修改圖片大小，再點擊「確定」，然後「另存新檔」，取個名稱，儲存。（不要使用匯出，否則無法錄製動作導致陷入無限迴圈） 點擊「檔案」、「自動」、「批次處理」 設定 播放區選擇「群組」和「動作」 來源 選擇需要修改的圖片檔案位址 目標 選擇修改後的圖片儲存位址 勾選 「覆寫動作中的『開啟舊檔』指令」 和 「覆寫動作中的『儲存為』指令」 內容部分參考自網際網路\n","date":"2022-06-10T00:54:44+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/48/","title":"使用 PS 自動化腳本批次處理圖片"},{"content":" 📢 本文由 Gemini-3-flash 翻譯 引言 由於騰訊雲函數從六月開始收費，於是便棄用改在自己的伺服器上架設\n既然六月收費為什麼現在才寫文章呢？因為可能還有三個月的免費試用我米遊社的 Cookie 過期更換，故紀錄一下\n工具 \u0026amp; 原教學 原神簽到小助手 每日福利不用愁 - 銀彈博客 由於原文介紹了多種使用方法，自己的閱讀體驗不是太好，故寫此文\n騰訊雲函數處理 請將騰訊雲函數凍結以確保不會產生費用\n當然，如果沒什麼其他需求可直接註銷帳號，但註銷帳號需要手持身分證照片，請注意\n前提 伺服器可以連接上米哈遊的伺服器 https://mihoyo.com 可在 SSH 命令列視窗輸入 ping mihoyo.com 測試是否可以連線\n我的一個伺服器就連不上，只好換一個，唉\nDocker 安裝 可以直接使用一鍵腳本進行安裝，實測 Debian 10 和 CentOS 7 正常安裝 (請使用 root 帳戶)\n安裝指令如下：\n1 curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun 也可以使用中國大陸 daocloud 一鍵安裝指令：\n1 curl -sSL https://get.daocloud.io/docker | sh 腳本安裝 使用以下指令即可\n1 docker pull yindan/genshinhelper CentOS 錯誤 我使用 CentOS 安裝時出現錯誤 Can't Connect to Docker Daemon\n請確保使用 root 帳戶，然後輸入以下指令\n1 systemctl start docker 簡易使用 Cookie 獲取 獲取米遊社 Cookie 請參考： 原神樹脂查看/推播 – yexca\u0026rsquo;Blog 注意：Cookie 應包含 account_id 和 cookie_token 兩個欄位\n多帳號在不同 Cookie 中間加 # 即可，例如 Cookie1#Cookie2#Cookie3\n簡易配置 1 2 3 4 docker run -d --name=genshinhelper \\ -e COOKIE_MIHOYOBBS=\u0026#34;\u0026lt;COOKIE_MIHOYOBBS\u0026gt;\u0026#34; \\ --restart always \\ yindan/genshinhelper:latest 將自己的 Cookie 替換上述指令的 \u0026lt;COOKIE_MIHOYOBBS\u0026gt; 即可\n重新配置/更新 Cookie 重新配置好像需要解除安裝再重裝，然後再進行配置\n或者使用設定檔只需替換 Cookie 就可以了吧 (沒用過，Cookie 有效期很長的)\n常用指令 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 查看 Docker 所有的容器 docker ps -a # 查看日誌 docker logs -f genshinhelper --tail 100 # 重啟 docker restart genshinhelper # 更新 docker pull yindan/genshinhelper docker rm -f genshinhelper # 之後依據基本使用或進階使用重新部署 # 卸載 docker rm -f genshinhelper docker image rm genshinhelper 進階使用 可下載範例檔案修改\nGithub: config.json Telegram: https://t.me/genshinhelperupdates/5 安裝 假設設定檔位於伺服器的 /etc/genshin/config.json，使用以下指令映射配置\n1 2 3 4 docker run -d --name=genshinhelper \\ -v /etc/genshin:/app/genshincheckinhelper/config \\ --restart always \\ yindan/genshinhelper:latest 配置 設定檔可以只留下需要的參數，把非必須的參數刪除，例如只需要 Cookie\n則設定檔除了保持完整也可以寫成：\n1 2 3 { \u0026#34;COOKIE_MIHOYOBBS\u0026#34;: \u0026#34;\u0026lt;COOKIE_MIHOYOBBS\u0026gt;\u0026#34;, } 設定檔新增 RANDOM_SLEEP_SECS_RANGE：隨機延遲休眠秒數範圍，單位：秒。設置成 \u0026ldquo;0-0\u0026rdquo; 為取消延遲。 CHECK_IN_TIME：每日簽到時間。該時間和執行環境的時間有關，和時區無關。如果是 docker，可以用 TZ=Asia/Shanghai 設置時區。 CHECK_RESIN_SECS：原神原粹樹脂檢測間隔時間，單位：秒。 COOKIE_RESIN_TIMER：需要開啟原粹樹脂檢測帳號的 cookie。 SHOPTOKEN：微信積分商城的 token，透過封包擷取獲取。 ONEPUSH：推播配置。notifier 為推播名稱，params 為所需參數。詳見後文。\nOnePush 推播參數一覽 推播名稱 / notifier: bark\n參數大全 / params:\n{\u0026lsquo;required\u0026rsquo;: [\u0026lsquo;key\u0026rsquo;], \u0026lsquo;optional\u0026rsquo;: [\u0026rsquo;title\u0026rsquo;, \u0026lsquo;content\u0026rsquo;, \u0026lsquo;sound\u0026rsquo;, \u0026lsquo;isarchive\u0026rsquo;, \u0026lsquo;icon\u0026rsquo;, \u0026lsquo;group\u0026rsquo;, \u0026lsquo;url\u0026rsquo;, \u0026lsquo;copy\u0026rsquo;, \u0026lsquo;autocopy\u0026rsquo;]}\n推播名稱 / notifier: custom\n參數大全 / params:\n{\u0026lsquo;required\u0026rsquo;: [\u0026lsquo;url\u0026rsquo;], \u0026lsquo;optional\u0026rsquo;: [\u0026lsquo;method\u0026rsquo;, \u0026lsquo;datatype\u0026rsquo;, \u0026lsquo;data\u0026rsquo;]}\n推播名稱 / notifier: dingtalk\n參數大全 / params:\n{\u0026lsquo;required\u0026rsquo;: [\u0026rsquo;token\u0026rsquo;], \u0026lsquo;optional\u0026rsquo;: [\u0026rsquo;title\u0026rsquo;, \u0026lsquo;content\u0026rsquo;, \u0026lsquo;secret\u0026rsquo;, \u0026lsquo;markdown\u0026rsquo;]}\n推播名稱 / notifier: discord\n參數大全 / params:\n{\u0026lsquo;required\u0026rsquo;: [\u0026lsquo;webhook\u0026rsquo;], \u0026lsquo;optional\u0026rsquo;: [\u0026rsquo;title\u0026rsquo;, \u0026lsquo;content\u0026rsquo;, \u0026lsquo;username\u0026rsquo;, \u0026lsquo;avatar_url\u0026rsquo;, \u0026lsquo;color\u0026rsquo;]}\n推播名稱 / notifier: pushplus\n參數大全 / params:\n{\u0026lsquo;required\u0026rsquo;: [\u0026rsquo;token\u0026rsquo;, \u0026lsquo;content\u0026rsquo;], \u0026lsquo;optional\u0026rsquo;: [\u0026rsquo;title\u0026rsquo;, \u0026rsquo;topic\u0026rsquo;, \u0026lsquo;markdown\u0026rsquo;]}\n推播名稱 / notifier: qmsg\n參數大全 / params:\n{\u0026lsquo;required\u0026rsquo;: [\u0026lsquo;key\u0026rsquo;], \u0026lsquo;optional\u0026rsquo;: [\u0026rsquo;title\u0026rsquo;, \u0026lsquo;content\u0026rsquo;, \u0026lsquo;mode\u0026rsquo;, \u0026lsquo;qq\u0026rsquo;]}\n推播名稱 / notifier: serverchan\n參數大全 / params:\n{\u0026lsquo;required\u0026rsquo;: [\u0026lsquo;sckey\u0026rsquo;, \u0026rsquo;title\u0026rsquo;], \u0026lsquo;optional\u0026rsquo;: [\u0026lsquo;content\u0026rsquo;]}\n推播名稱 / notifier: serverchanturbo\n參數大全 / params:\n{\u0026lsquo;required\u0026rsquo;: [\u0026lsquo;sctkey\u0026rsquo;, \u0026rsquo;title\u0026rsquo;], \u0026lsquo;optional\u0026rsquo;: [\u0026lsquo;content\u0026rsquo;, \u0026lsquo;channel\u0026rsquo;, \u0026lsquo;openid\u0026rsquo;]}\n推播名稱 / notifier: telegram\n參數大全 / params:\n{\u0026lsquo;required\u0026rsquo;: [\u0026rsquo;token\u0026rsquo;, \u0026lsquo;userid\u0026rsquo;], \u0026lsquo;optional\u0026rsquo;: [\u0026rsquo;title\u0026rsquo;, \u0026lsquo;content\u0026rsquo;, \u0026lsquo;api_url\u0026rsquo;]}\n推播名稱 / notifier: wechatworkapp\n參數大全 / params:\n{\u0026lsquo;required\u0026rsquo;: [\u0026lsquo;corpid\u0026rsquo;, \u0026lsquo;corpsecret\u0026rsquo;, \u0026lsquo;agentid\u0026rsquo;], \u0026lsquo;optional\u0026rsquo;: [\u0026rsquo;title\u0026rsquo;, \u0026lsquo;content\u0026rsquo;, \u0026rsquo;touser\u0026rsquo;, \u0026lsquo;markdown\u0026rsquo;]}\n推播名稱 / notifier: wechatworkbot\n參數大全 / params:\n{\u0026lsquo;required\u0026rsquo;: [\u0026lsquo;key\u0026rsquo;], \u0026lsquo;optional\u0026rsquo;: [\u0026rsquo;title\u0026rsquo;, \u0026lsquo;content\u0026rsquo;, \u0026lsquo;markdown\u0026rsquo;]}\n推播例子 1 2 3 4 5 telegram ONEPUSH={\u0026#34;notifier\u0026#34;:\u0026#34;telegram\u0026#34;,\u0026#34;params\u0026#34;:{\u0026#34;markdown\u0026#34;:false,\u0026#34;token\u0026#34;:\u0026#34;xxxx\u0026#34;,\u0026#34;userid\u0026#34;:\u0026#34;xxx\u0026#34;}} discord ONEPUSH={\u0026#34;notifier\u0026#34;:\u0026#34;discord\u0026#34;,\u0026#34;params\u0026#34;:{\u0026#34;markdown\u0026#34;:true,\u0026#34;webhook\u0026#34;:\u0026#34;https://discord.com/api/webhooks/xxxxxx\u0026#34;}} docker 設定檔對應目錄為：/etc/genshin:/app/genshincheckinhelper/config\n","date":"2022-06-09T13:33:42+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/47/","title":"原神自動簽到 (Linux 伺服器 Docker)"},{"content":" 📢 本文由 Gemini-3-flash 翻譯 引言 在學習 Markdown 用法 後，感覺非常好用 (最近的文章都是使用 Markdown 寫的)，又因為程式設計或 GitHub 架站 會與 Markdown 接觸，而我寫程式使用 VS Code (看嘉然)，因此尋找是否可以即時預覽。\n快速鍵 在 Markdown 檔案介面 (.md 檔案)，點擊一下檔案介面 (滑鼠文字游標在檔案內)，然後按下 CTRL+K 後按下 V 即可，注意使用英文輸入法。\n以上是即時預覽，可以按 CTRL+Shift+V 開啟新視窗預覽。\n按鈕 在 Markdown 檔案右上角有個 開啟側邊預覽 按鈕，點擊即可。\n指令面板 按 CTRL+Shift+P 開啟指令面板，然後輸入 markdown 就能看到一些指令。\n參考文章 Visual Studio Code 撰寫並即時預覽 Markdown ","date":"2022-06-09T00:03:34+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/46/","title":"VS Code 即時預覽 Markdown"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 前言 首先我不是嘉心糖，我只是覺得很可愛 (我剛開始甚至都不知道是嘉然)，然後這個 Bug 蠻多，自動啟動不是每次都能觸發，但她太可愛啦\n然後這個擴充套件還可以改背景，但我個人不是太喜歡就沒改\n效果預覽如下 安裝 開啟 VS Code 然後在 擴充套件 搜尋 A-SOUL-live2d 安裝\n擴充套件網址： A-SOUL-live2d - Visual Studio Marketplace 其實可以直接去擴充套件那邊看，有安裝過程，不用看我寫的垃圾文章\n簡易使用 安裝完畢重新啟動 VS Code，然後在資源檢視最下方會有 LIVE2D-A-SOUL，展開 (不能展開就重新啟動 VS Code)\n然後在 補充設定 處 產生 擴充套件依賴檔案，重新啟動 VS Code，點擊 啟動 live2d\n右下角就會出現嘉然囉，可以把滑鼠移上去，拖曳右上角第三個圖示以移動位置，第一個點擊改變大小\n調整完位置，大小後可以在 設定資訊 處開啟 自動啟動，然後點擊 儲存目前設定 就可以開啟 VS Code 就能看見嘉然囉~\n其他 以下複製自擴充套件介紹\n基本操作\n啟動、關閉 live2d： 字面意思，會啟動看板人物，初始預設位置右下角 儲存目前設定： 在調整 live2d 大小縮放和拖曳位置後，可儲存資訊，下次啟動時自動帶入 重設預設位置： 目前位置異常，無法拖曳移動時可重設使用【縮放大小也會重設】 背景圖片 點擊切換： 點擊按鈕為人物右側圖示第二個 儲存背景圖片： 需要目前背景圖片存在才會生效。只能儲存一份，再次點擊會覆蓋舊的 載入背景圖片： 載入儲存的背景圖片 定時切換： 字面意思，可查看 切換按鈕 是否旋轉判斷是否開啟定時功能 背景圖片樣式設定 下載背景圖片 設定資訊\n自動啟動： 字面意思，開啟後。VS Code 啟動，live2d 自動啟動 定位依賴： 人物定位的依賴角 補充設定\n擴充套件依賴檔案： 擴充套件依賴檔案會在初次安裝擴充套件並啟動時自動產生 產生： live2d 無法正常啟動時，可嘗試點擊該按鈕，強制重新產生覆蓋設定資訊 移除： 解除安裝該擴充套件前，請盡可能先執行該操作。可移除擴充套件對 VS Code 檔案的所有修改 人物功能\n目光跟隨滑鼠 【缺點，暫時無法實現整個頁面的跟隨】 點擊互動 A-SOUL 粉絲導航網站入口 切換背景圖片 切換模型 溜冰場 音訊測試 一個魂二創網站入口 模型來源 關於警告 使用時會跳出 Code 損壞警告，原作者指出\n本擴充套件是透過修改 VS Code 的 js 檔案的方式執行 所以會在初次安裝，或者 VS Code 升級的時候，出現以下提示，請選擇 【不再提示】\n音訊支援 目前擴充套件僅一個簡易的語音測試，暫且可以不用考慮該功能\nVS Code 使用的 Electron 版本不包含 ffmpeg ，需替換內建的 ffmpeg 動態連結庫才能正常播放 (每次更新 VS Code 都需重新替換)\nVS Code for Windows 1.31.0 - 1.35.1 不需替換，1.36.0 後無此待遇\nVS Code for macOS 1.43+ 替換後閃退 解決方案 解除安裝 首先將 補充設定 移除，然後在 擴充套件 介面解除安裝擴充套件即可\n","date":"2022-06-01T06:01:00+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/45/","title":"VS Code 右下角嘉然"},{"content":" 📢 本文由 Gemini-3-flash 翻譯 引言 最近基於 GitHub Pages 弄了一個個人頁面 (已經沒了)，記錄一下如何使用 GitHub Pages 建站以及自訂網域。\n本文沒有建站系統等，因為我也就寫了一個 Markdown 檔案。\n建立 GitHub 存放庫 首先需要註冊一個 GitHub 帳號，登入後 建立一個新存放庫 。\n其中 Repository name 為 username.github.io，例如我的 GitHub 使用者名稱為 yexca，則輸入 yexca.github.io。\nGit 環境安裝 Windows 環境直接從 Git 官網直接 下載安裝程式 即可。\n安裝完成後，開啟 Git Bash，在命令列輸入以下程式碼：\n1 2 git config --global user.name \u0026#34;Your Name\u0026#34; git config --global user.email \u0026#34;email@example.com\u0026#34; 其中 Your Name 替換為您的姓名，email@example.com 替換為您的電子郵件。\n例如我的：\n1 2 git config --global user.name \u0026#34;yexca\u0026#34; git config --global user.email \u0026#34;yexca@duck.com\u0026#34; GitHub Desktop 安裝 如果您熟悉 Git 的操作 熟悉 Git 操作怎麼會來看我的文章，這一步可以跳過。\n直接進入 GitHub Desktop 官網 下載安裝即可。\n複製存放庫 開啟 GitHub Desktop 後登入 GitHub 帳號，選擇一個空資料夾將上一步建立的存放庫複製 (Clone) 到本機。\n然後軟體會出現一個存放庫變動介面，右方會有一些快捷操作。\n這裡我使用 VS Code，點擊 Open in Visual Studio Code 在 VS Code 開啟。\n建立網站 這裡直接建立一個 README.md 檔案使用 Markdown 編輯 (這裡順便放一個我寫的 Markdown 筆記)。\n編輯完成並儲存後，在 GitHub Desktop 點擊 Commit to main，然後點擊右方 Push origin 即可。\n至此訪問 username.github.io 即可看到網站內容，如果沒看到請等一段時間。\n自訂網域 GitHub Pages 進入剛剛建立的存放庫頁面，點擊 Settings，左側找到 Pages，在 Custom domain 處輸入自訂網域然後點擊 Save。\n註：在這裡可以進行 Jekyll 建站主題的選擇。\nDNS 在網域的 DNS 解析處新增一個 CNAME 類型解析，將網域指向 username.github.io，其中 username 為您的 GitHub 使用者名稱。\nHTTPS 這裡我用 GitHub 的不知為何沒成功，於是使用 Cloudflare 。\n在 DNS 解析處啟用代理，然後在 SSL/TLS 的 邊緣憑證 處將 一律使用 HTTPS 打開即可。\n其他建站 因無部落格需求，我只是寫一個簡單的檔案，如果是建立部落格之類的可以使用一些建站工具：\nJekyll GitHub 官方支援的建站 VuePress 中文網 Markdown 推薦 Gitbook 適合建立說明文件類網站 LOFFER Gridea 一個靜態部落格寫作客戶端 Hexo 快速、簡潔且高效的部落格框架 Hugo 參考文章 GitHub Pages 快速入門 - GitHub Docs GitHub Pages 部落格：自訂網域，HTTPS，CAA — 浮雲的部落格 GitHub Pages 搭建教程 安裝 Git - 廖雪峰的官方網站 ","date":"2022-05-28T15:30:43+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/44/","title":"GitHub Pages 建站及自訂網域"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 前言 最近因建立 雲端硬碟網站 而了解了一下 Markdown，發現這東西非常好用，於是寫了一份學習筆記。\n可以透過 線上編輯器 邊看邊學，也可以下載一些 編輯器 。\n個人編寫 Markdown 的工具為 Typora 。\n複習可以去看官方的速查表 Markdown 語法速查表 。\n標題 建立標題，只需#+空白+標題文字，總共有六個層級，對應 HTML 的 h1~h6。\n1 2 3 4 5 6 # 這是一級標題 ## 這是二級標題 ### 這是三級標題 #### 這是四級標題 ##### 這是五級標題 ###### 這是六級標題 一般的網頁編寫，第一層標題是網頁標題，第二層開始為內文，用到第四層就差不多了。\n換行 只需在上一行末尾加上兩個以上的空白後 Enter (或換行) 即可，有些編輯器可以直接換行。\n例如以下程式碼：\n1 2 這是第一行 //這裡有兩個空白，後面也有→ 這是第二行 效果如下：\n這是第一行 //這裡有兩個空白，後面也有→\n這是第二行\n斜體 \u0026amp; 粗體 斜體是在文字前後加上一個 *，粗體是在文字前後加上兩個 **。\n例如以下程式碼：\n1 2 3 *這是斜體* **這是粗體** ***這是斜體加粗體*** 效果如下：\n這是斜體\n這是粗體\n這是斜體加粗體\n引用區塊 建立引言區塊只需在段落開頭添加 \u0026gt;+空白+內容。\n例如以下程式碼：\n1 2 3 \u0026gt; 這是一級引言 \u0026gt;\u0026gt; 這是二級引言 \u0026gt;\u0026gt;\u0026gt; 這是三級引言 效果如下：\n這是一級引言\n這是二級引言\n這是三級引言\n清單 可以建立有序清單和無序清單。\n有序清單 在清單項目前添加 數字+.+空白+內容 即可。\n例如以下程式碼：\n1 2 3 1. 第一項 2. 第二項 3. 第三項 效果如下：\n第一項 第二項 第三項 無序清單 使用 +，- 或 *+空白+ 內容 即可，但請不要混用 (為了相容性)。\n子項目可以使用 四個空白 或一個 TAB 然後用父項目格式即可。\n不過為了符合 (markdownlint) 規範，一篇文章中的所有無序清單應盡量使用相同的符號，例如都使用 -。\n例如以下程式碼：\n1 2 3 4 5 6 - 第一項 - 第一項子項目一 - 第一項子項目二 - 第一項子項目二的子項目一 - 第二項 - 第三項 效果如下：\n第一項 第一項子項目一 第一項子項目二 第一項子項目二的子項目一 第二項 第三項 程式碼 單行 將要變成程式碼的內容放在 \u0026ldquo;`\u0026rdquo; 中即可，如果程式碼中有 \u0026ldquo;`\u0026rdquo; ，請使用 \u0026ldquo;``\u0026quot;。\n例如以下程式碼：\n1 2 `將此內容變成程式碼區塊` ``此內容中含有\u0026#39;`\u0026#39;喔~`` 效果如下：\n將此內容變成程式碼區塊\n此內容中含有'`'喔~\n程式碼區塊 可以透過將每一行縮排四個空白或一個 TAB。\n或者上下行 \u0026ldquo;```\u0026rdquo; 包住，若要使用語法高亮，請在上方 \u0026ldquo;```\u0026rdquo; 後寫上語言類型。\n為了符合規範，請盡量使用第二種方式。\n例如以下程式碼：\n1 2 3 4 5 6 7 \\`\\`\\` C include\u0026lt;stdio.h\u0026gt; int main(void) { printf(\u0026#34;Hello World\u0026#34;); } \\`\\`\\` 效果如下：\n1 2 3 4 5 include\u0026lt;stdio.h\u0026gt; int main(void) { printf(\u0026#34;Hello World\u0026#34;); } 分隔線 在單獨一行使用三個及以上的 *，- 或 _ 即可。\n為了規範，請盡量使用三個星號。\n例如以下程式碼：\n1 *** 效果如下：\n連結 簡易連結 直接將連結或電子郵件地址使用 \u0026lt;\u0026gt; 括起來即可。\n例如以下程式碼：\n1 2 \u0026lt;https://yexca.net\u0026gt; \u0026lt;yexca@duck.com\u0026gt; 效果如下：\nhttps://yexca.net yexca@duck.com 自訂文字的連結 [超連結顯示名](超連結地址 \u0026quot;超連結 title\u0026quot;)，其中 \u0026quot;超連結 title\u0026quot; 可以不用填寫。\n例如以下程式碼：\n1 2 [yexca 的部落格](https://blog.yexca.net) [yexca 的部落格](https://blog.yexca.net \u0026#34;其實是yexca和Hiyoung的部落格\u0026#34;) 效果如下：\nyexca 的部落格 yexca 的部落格 參考型連結 例如以下程式碼：\n1 2 3 4 [blog]: https://blog.yexca.net [contact]: \u0026lt;mailto:yexca@duck.com\u0026gt; 這是我的[個人部落格][blog]，有問題可以[聯絡我][contact]。 效果如下：\n這是我的 個人部落格 ，有問題可以 聯絡我 。\n圖片 插入圖片 ![圖片 alt](圖片連結 \u0026quot;圖片 title\u0026quot;)，其中 圖片 alt 為當圖片載入失敗時顯示的內容，圖片 title 為滑鼠移到圖片上顯示的內容。\n請注意：部分 Markdown 編輯器不支援 圖片 title (例如本站這個主題)，為了規範，請至少確保填寫 圖片 alt。\n例如以下程式碼：\n1 ![圖片](https://cdn.statically.io/gh/yexca/picx-images-hosting@master/2023/04-網站背景/blog-background.2p10z489pjc0.webp \u0026#34;這是本站的背景圖片\u0026#34;) 效果如下：\n圖片包含連結 使用連結的語法，將圖片放在 [] 裡面即可。\n例如以下程式碼：\n1 [![圖片](https://cdn.statically.io/gh/yexca/picx-images-hosting@master/2023/04-網站背景/blog-background.2p10z489pjc0.webp)](https://www.pixiv.net/artworks/82542737) 效果如下：\n跳脫字元 如果有不想被 Markdown 格式化的字元，只需要在前方加上 \\ 即可。\n例如以下程式碼：\n1 2 我想打出*但這會變成斜體* 加上跳脫字元\\*後面就不會變成斜體，而且可以顯示 效果如下：\n我想打出但這會變成斜體\n加上跳脫字元*後面就不會變成斜體，而且可以顯示\n內嵌 HTML 直接使用即可，以摺疊標籤為例：\n例如以下程式碼：\n1 2 3 4 5 6 7 \u0026lt;details\u0026gt; \u0026lt;summary\u0026gt; 點我試試看 \u0026lt;/summary\u0026gt; 被發現啦 \u0026lt;/details\u0026gt; 我可以用Markdown**變粗**，也可以同時用HTML\u0026lt;i\u0026gt;變斜\u0026lt;/i\u0026gt; 因為本站主題無法直接解析 H5，所以不提供範例。\n表格 使用三個或多個 - 建立每欄的標題，使用 | 分隔每欄，使用 : 向左、向右或置中對齊 (非必要)。\n例如以下程式碼：\n1 2 3 |標題|內容|備註| |:---|:---:|---:| |靠左對齊|置中|靠右對齊| 效果如下：\n標題 內容 備註 靠左對齊 置中 靠右對齊 請注意：不可以在表格中加入標題、引言、清單、圖片或 HTML 標籤等等。\n刪除線 在要刪除的內容前後加上 ~~。\n例如以下程式碼：\n1 我永遠喜歡 ~~戰爭文學博士~~ Warma 效果如下：\n我永遠喜歡 戰爭文學博士 Warma\n待辦事項清單 使用 -+空白+[ ] 或 [x]+空白+內容。\n例如以下程式碼：\n1 2 - [ ] 這個還沒完成呢 - [x] 這個完成啦 效果如下：\n這個還沒完成呢 這個完成啦 使用 Emoji 表情符號 複製貼上 大部分情況可以直接複製 Emojipedia 上的表情符號直接貼上，請確保網頁編碼為 UTF-8。\n使用表情符號簡碼 這需要 Markdown 應用程式支援，以冒號 : 開頭和結尾。\n可以透過 表情符號簡碼列表 查詢。\n例如以下程式碼：\n1 :blush:,:smiley: 效果如下：\n😊,😃\n註腳 類似於論文參考文獻的註標。\n例如以下程式碼：\n1 2 3 4 5 6 這裡引用了維基百科[^1]，這裡引用了 Github[^2]。 也可以使用英文，但不能使用空白或 TAB[^yexca]。 [^1]: 這裡可以使用文字，然後會顯示在上方相應的位置 [^2]: 或者使用連結 [Github](https://github.com/yexca) [^yexca]: [個人首頁](https://lit.link/yexca) 效果如下，參考的內容在文章最尾端，點擊註標即可查看。\n這裡引用了維基百科1，這裡引用了 Github2。 也可以使用英文，但不能使用空白或 TAB3。\n請注意：部分編輯器不支援。\n參考文章 Markdown 官方教學 Markdown 學習 這裡可以使用文字，然後會顯示在上方相應的位置\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n或者使用連結 Github \u0026#160;\u0026#x21a9;\u0026#xfe0e;\n個人首頁 \u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2022-05-28T00:59:23+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/43/","title":"Markdown 簡述 (學習筆記)"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 引言 本人可以直接連線進入遊戲，但加速器等方式無法進入遊戲，加上每次進入遊戲都要關閉虛擬私人網路較為麻煩，尋找相關資料卻無果，故撰寫此文。（遊戲為 iOS 日服）\n正文 透過查看日誌檔案，確定了進入遊戲時連線的網域名稱。\n將以下網域名稱加入 DIRECT 即可：\n1 sekai.colorfulpalette.org 後記 本想詳細說明的，卻發現遊戲出了國際服和台服，如果要詳細寫估計要花費很長時間並進行校對，懶～\n","date":"2022-05-19T15:01:25+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/42/","title":"プロセカ的 IP 規則"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 這篇文章由 Hiyoung 撰寫\nLinux 不會自動建立不存在的資料夾，使用「mv」指令時需要注意資料夾是否存在，否則會將檔案重新命名。 為檔案建立實體連結（Hard Link）實際上是為檔案建立了額外的名稱部分（資料部分未改動），類似於 C 語言中建立了一個指標指向該檔案。 為檔案建立符號連結（Symbolic Link）類似於 Windows 中的捷徑，在使用「ls -li」指令中可以比較直觀地看出區別。實體連結的位元組數和來源檔案一樣，而符號連結的位元組數不同。 使用別名「alias」建立指令：在同一行同時執行多個指令用「;」分開；可以使用「type」查詢指令是否已經在系統中；值得注意的是使用「alias」建立指令在結束 Shell 工作階段時會消失（因為沒有新增到檔案中）；使用「unalias」刪除別名。 使用「\u0026gt;」重新導向會覆寫來源檔案，「\u0026raquo;」重新導向會在來源檔案後方附加。 將錯誤訊息寫入檔案（而不是顯示在螢幕上）可以用「2\u0026gt;」。 重新導向標準輸出和錯誤到同一個檔案有兩種方法：一是，在重新導向的檔案名稱後加上「2\u0026gt;\u0026amp;1」；二是，在重新導向符號前加「\u0026amp;」。 方法一（在舊版本的 Shell 也可使用）\n方法二\n","date":"2022-04-30T04:24:07+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/40/","title":"Linux 隨手筆記"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 該文章由 Hiyoung 撰寫\n其文章: https://blog.hiyoung.xyz/2022/09/03/3256bd2afccc/ 一、虛擬機器設定 在功能表列選擇編輯 → 虛擬網路編輯器，開啟虛擬網路編輯器對話框，選擇 NAT 網路連線方式，隨意設定子網路 IP，點擊 NAT 設定頁面，查看子網路遮罩與預設閘道，後面修改靜態 IP 時會用到。\n在 VMnet8 模式下選擇 NAT 連線，並且取消 DHCP 服務。\n點擊 NAT 設定，記錄下此時的預設閘道。\n在系統的網路設定處，檢查 VMnet8 的網路配置。\n二、Linux 主機設定 在 root 權限下輸入指令 cd /etc/sysconfig/network-scripts 進入該資料夾，輸入指令 ls 瀏覽該資料夾下的檔案，找到 ifcfg-en*** 檔案，如下圖所示：\n使用 vim ifcfg-en*** 開啟檔案。\n將 BOOTPROTO=\u0026ldquo;dhcp\u0026rdquo; 改為 BOOTPROTO=\u0026ldquo;static\u0026rdquo;、ONBOOT=\u0026ldquo;no\u0026rdquo; 改為 ONBOOT=\u0026ldquo;yes\u0026rdquo;。\n並在下方新增：\nIPADDR=your ip（靜態 IP 位址）\nNETMASK=your netmask（子網路遮罩，一般為 255.255.255.0）\nGATEWAY=your gateway（預設閘道位址）\nDNS1=8.8.8.8（國內外公共 DNS 即可）\nDNS2=8.8.4.4\n最後輸入 :wq 儲存並離開即可。\n","date":"2022-04-22T18:13:42+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/39/","title":"在虛擬機器中設定靜態 IP（以 CentOS 為例）"},{"content":" 📢 本文由 Gemini-3-flash 翻譯 前言 2022 年 03 月 22 日，OBS 在 Steam 上架了，雖然方便更新，但每次使用都要開啟 Steam 實在有點麻煩。\n正文 在 Steam 收藏庫介面右鍵點擊 OBS Studio，依序選擇「管理 \u0026gt; 瀏覽本機檔案」。\n在檔案總管中進入路徑 bin/64bit 或 bin/32bit，找到 obs64 或 obs32。\n直接點擊這個檔案就可以啟動 OBS，因此可以將其固定到「開始」畫面或建立捷徑。\n按右鍵選擇「建立捷徑」，將捷徑放到桌面即可。\n","date":"2022-04-11T22:19:48+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/37/","title":"免啟動 Steam 開啟 OBS"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 一、查詢時間戳 開啟網頁 https://member.bilibili.com/x2/creative/h5/calendar/event?ts=0 按下 CTRL+F，輸入 jointime，找到 jointime 後面的數字就是時間戳\n將時間戳複製\n二、轉換時間戳 開啟網站 時間戳 (Unix timestamp) 轉換工具 – 線上工具 在對應位置輸入時間戳，點擊轉換即可\n參考資料 UP主教學如何查看自己的B站註冊時間，精確到秒！bilibili ","date":"2022-04-09T13:47:52+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/36/","title":"查詢B站註冊時間(精確到秒)"},{"content":" 📢 本文由 Gemini-3-flash 翻譯 前言 今日我在撰寫文章時，發現 PicX 圖床無法使用並提示 Bad credentials，於是便尋找解決方法。\n結論 其實就是 GitHub 的 Token 到期了，然後在電子信箱裡會收到一封郵件，標題為 [GitHub] Your personal access token has expired\n郵件有三行，第二行 If this token is still needed 後面有個連結，點擊打開並重新建立即可。\n注意設定 Expiration 即 Token 期限。\n重新建立後需要在 PicX 將圖床設定重置一下。\n具體參考： 使用PicX自建免費圖床 – yexca’Blog ","date":"2022-03-22T16:30:12+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/35/","title":"使用 PicX 圖床上傳圖片提示 \"Bad credentials\""},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 另外我寫了模型修改教學，可以前往： https://vrchat.yexca.net/ 查看\n前言 近日經由好友告知 VRchat 中的鋼琴可以自行彈奏，於是便學習了此功能，並撰寫此篇文章作為記錄。 註：似乎只能在 PC 模式下自動彈奏，當然，您也可以在 VR 環境下投影桌面試試看（doge\n如果未使用 MIDI 檔案 一、準備 為實現鋼琴自動彈奏，需要安裝兩款軟體及一個外掛程式。\n1）loopMIDI 此軟體可直接至官網取得，官網連結： loopMIDI-Tobias Erichsen (tobias-erichsen.de) 檔案直接連結： loopMIDISetup_1_0_16_27.zip （可能因版本更新而失效）\n2）Jazz-Plugin 安裝時請保持預設安裝路徑，否則可能無法正常使用。\nWindows: 點此下載（外掛程式官網連結） （如果官網連結無法下載，亦可 點此下載 ）\nMac OS X: 點擊下載 Linux version: 點擊下載 3）瀏覽器外掛程式 Jazz-MIDI Chrome、Opera 或其他雙核心瀏覽器（例如 360 安全瀏覽器等）： 點擊前往 Chrome 線上應用程式商店安裝 如果無法存取 Chrome 線上應用程式商店 Chrome 73 版之前請下載 Jazz-MIDI-crx2.crx 使用，Chrome 73 版之後請下載 Jazz-MIDI-crx3.crx 使用。\nChrome 進入擴充功能 透過在網址列輸入（或此處直接點擊） chrome://extensions 並按下 Enter 進入擴充功能\n如圖所示\nEdge 進入擴充功能 透過在網址列輸入（或此處直接點擊） edge://extensions/ 並按下 Enter 進入擴充功能\n如圖所示\n如果出現彈跳視窗，點擊 「管理擴充功能」\n開啟擴充功能介面後 首先開啟「開發人員模式」，Chrome 在右上角，Edge 在左中。\n接著直接將下載好的 .crx 檔案拖曳至擴充功能介面即可。\n二、步驟 1）開啟 loopMIDI，建立新專案 建立新專案時，請先在右下角 New port-name 輸入名稱，再點擊左下角 + (加號) 即可。\n完成後，專案將會顯示在上方，這裡以 Hello World 作為專案名稱。\n2）開始播放 \u0026lt;1\u0026gt; 尋找欲播放的歌曲 首先，開啟網站 MidiShow – 領先的 MIDI 音樂交流與下載網站 註冊登入後搜尋想播放的歌曲。\n\u0026lt;2\u0026gt; 進行播放設定 如圖所示，以 Hand in Hand 為例，點擊「播放設定」按鈕。\n設定如圖，MIDI 輸出裝置 請選擇剛才使用 loopMIDI 建立的專案，此處為 Hello World。\n\u0026lt;3\u0026gt; 開始播放 此時進入中文酒吧鋼琴旁，選中板凳坐上去，接著在網頁中點擊播放即可。\n如果使用 MIDI 檔案 首先，請確保 MIDI 檔案為鋼琴譜，多軌檔案可能會發生混亂，請自行編輯。\n一、準備 1）loopMIDI 此軟體可直接至官網取得，官網連結： loopMIDI-Tobias Erichsen (tobias-erichsen.de) 檔案直接連結： loopMIDISetup_1_0_16_27.zip （可能因版本更新而失效）\n2）MidiPiano 此軟體我在某下載軟體網站取得（Google 搜尋結果第一個）。\n網站連結： MidiPiano – Download (softonic.com) 二、步驟 1）在 loopMIDI 中建立新專案 建立新專案時，請先在右下角「New port-name」輸入名稱，再點擊左下角「+」 (加號) 即可。\n完成後，專案將會顯示在上方，這裡以「Hello World」作為專案名稱。\n2）開啟 MidiPiano，進行設定 點擊播放清單，可直接將檔案拖曳進入，點擊選項，將輸出裝置設定為剛才 loopMIDI 建立的專案，此處為 Hello World。\n如果出現彈跳視窗「MIDI 輸入輸出不能為同一個，會當機的！」 請點擊選項中的 MIDI 輸入裝置，將剛才 loopMIDI 建立的專案取消勾選，然後再切換至 MIDI 輸出裝置 並將其開啟。\n3）開始播放 此時進入中文酒吧鋼琴旁，選中板凳坐上去，接著選擇 播放清單 中想播放的歌曲，再點擊 播放 即可。\n參考資料 【VRChat】教你如何在中文酒吧自動彈鋼琴 嗶哩嗶哩 播放器選擇及外掛程式安裝說明 ","date":"2022-03-22T16:11:47+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/34/","title":"VRchat 在中文酒吧自動彈鋼琴"},{"content":" 📢 本文由 Gemini-3-flash 翻譯 引言 這篇文章是我自行蒐集的一些免費圖床，部分圖床曾經使用過。當然，如果您想要使用圖床，我推薦您閱讀 使用 PicX 自建免費圖床 – yexca’Blog 一、路過圖床 官網連結： 路過圖床 – 免費圖片上傳, 專業圖片外鏈, 免費公共圖床 高速穩定，單圖最大 10MB\n二、ImgURL 官網連結： ImgURL 免費圖床 訪客每日限 10 次上傳，單圖最大 5MB\n三、SM.MS 官網連結： Image Upload – SM.MS – Simple Free Image Hosting 老牌圖床，現在訪客禁止上傳，普通使用者單圖最大 5MB， 5GB 儲存空間\n（另外該圖床的圖片直連連結網域是 loli.net）\n四、KinhPicture 官網連結： KinhPicture – 聚合圖床 島主的聚合圖床，支援阿里、百度、AWS S3 等 15 個介面，單圖限制 2~32MB\n五、極兔圖床 官網連結： 極兔圖床 – 免費圖床, 匿名圖床, 免費 CDN 圖床, 圖床 API, 專業的圖片代管商 最大可上傳 10MB 的圖片\n六、Gimhoy 圖床 官網連結： Gimhoy 圖床 - 無限制永久免費圖 七、bayimg 官網連結： bayimg – free uncensored image hosting ","date":"2022-03-20T16:54:36+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/33/","title":"圖床網站總結"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 前言 本文所寫方法僅供一般用途，如有特殊需求請自行查詢。\n一、使用 Win10/Win11 內建功能 1）系統內建截圖軟體 Win10/Win11 內建一個截圖軟體，名稱為「擷取工具」，有兩種使用方式。\n\u0026lt;1\u0026gt; 開啟軟體使用 透過按下 Win 按鍵，開啟所有應用程式，找到「擷取工具」開啟。\n如上圖所示為開啟軟體後的介面，點擊「新增」即可進行截圖。\n\u0026lt;2\u0026gt; 使用快捷鍵 其實上圖中軟體介面已經顯示快捷鍵，為 Win+Shift+S，三個按鍵一起按即可開始截圖。\n完成截圖後儲存 完成截圖後，右下角的通知中心會跳出一個視窗。\n如果想透過聊天軟體傳送，可直接在聊天介面的輸入框中按下 Ctrl+V 即可顯示圖片。\n如果想儲存到本機，可點擊通知中心對應的通知，跳出截圖後按下 Ctrl+S 選擇路徑儲存。 其他功能請自行探索。\n2）使用系統內建的 Xbox Bar 透過按下 Win+G 即可開啟 Xbox Bar，點擊空白處或再次按下 Win+G 即可關閉。\n\u0026lt;1\u0026gt; 透過 Xbox Bar 截圖與錄影 如圖所示，紅框中第一個按鈕為截圖，第三個按鈕為錄影，再次按下即可結束錄影（或按下螢幕上出現的一個懸浮視窗上的結束按鈕）。 如果未出現「擷取」方塊，請按下上圖藍框中按鈕。\n\u0026lt;2\u0026gt; 截圖與錄影檔案位置 如上圖所示，紅框中有「顯示所有擷取」，點擊即可出現使用 Xbox Bar 截圖或錄影的所有檔案，每個檔案下都會出現「開啟檔案位置」，點擊即可開啟檔案所在位置。\n當然，Xbox Bar 所儲存的檔案路徑在 此電腦/視訊/擷取 (即 C:\\Users\\%username%\\Videos\\Captures)，截圖與錄影都在這裡。\n二、使用第三方應用程式 如果是第三方應用程式，會有許多選擇，這裡僅說明兩個，一般情況下系統內建功能就已足夠。\n1）使用 QQ/TIM/WeChat (微信) 進行截圖或錄影 QQ/TIM 的截圖快捷鍵為 Ctrl+Alt+A，錄影快捷鍵為 Ctrl+Alt+S。\nWeChat (微信) 的截圖快捷鍵為 Alt+A，未發現錄影功能。\n兩者皆可在聊天介面輸入框上方的小剪刀圖示右側的小箭頭處進行修改「截圖隱藏目前視窗」。\n2）使用 OBS 進行錄影 OBS 簡介 由於並非本文重點，此處複製官方簡介，進入官方網站下載安裝即可。\nOBS Studio – 免費開放原始碼軟體，用於直播和螢幕錄影。\n官方網站： Open Broadcaster Software-OBS Github： obsproject/obs-studio: OBS Studio 錄製螢幕教學 \u0026lt;1\u0026gt; 使用 OBS 進行錄製 開啟 OBS 介面如上圖所示，左下第二個有「來源視窗」，點擊下方加號。\n如上圖所示，選擇顯示器擷取，然後點兩次確定即可出現顯示器螢幕。\n右方點擊「開始錄製」即可開始錄製目前桌面。\n\u0026lt;2\u0026gt; 檔案儲存位置 點擊左上角「檔案-顯示錄影」即可跳出錄製檔案儲存位置。\n問題：如果未出現螢幕 此問題的解決方法為在「NVIDIA 控制面板」中，將「管理 3D 設定」裡的 OBS「選擇此程式的首選圖形處理器」改為「整合式」。\n如下圖所示，因為我的電腦預設為「整合式」，我便未更改。\n如無法解決，請自行搜尋其他方法。\n","date":"2022-03-19T13:57:39+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/32/","title":"Windows 電腦截圖與錄影"},{"content":" 📢 本文由 gemini-2.5-flash-lite 翻譯 引言 近期購入了 Beat Saber (雖然是透過阿根廷區)，於是便想著新增自訂歌曲。透過 Steam 的評論區得知 WGzeyu 大佬做了相關教學，但由於我的目的比較單純，而教學內容又相當完整，因此特地撰寫這篇文章來總結。\n一、準備工作 註：2022.03.25：今日修改相關內容時發現 1.20.0 版本已有 Mod，請直接參閱第二部分。同時，恢復資料的部分已更新。\n1）降級 由於目前最新版本 1.20.0 並沒有相關 Mod，因此需要先進行降級。待 Mod 更新後，可以再升級回最新版本。\n\u0026lt;1\u0026gt; 下載 1.19.0 或更早的版本 可至 WGzeyu 大佬提供的網盤 下載。選擇想下載的版本後進行下載。\n檔案直連： 1.19.0 Steam 版 \u0026lt;2\u0026gt; 替換 1.20.0 版本 解壓縮下載的檔案，然後透過 Steam 開啟遊戲目錄。返回上一層後，將「Beat Saber」資料夾重新命名為「Beat Saber 1.20.0」，接著將剛剛下載的檔案重新命名為「Beat Saber」並移動到此資料夾。\n\u0026lt;3\u0026gt; 如何恢復資料 \u0026lt;1\u0026gt; 使用 Steam 開啟遊戲目錄，刪除 UserData 資料夾內的 Beat Saber IPA。 \u0026lt;2\u0026gt; 複製以下資料夾 (依需求複製)： * UserData (Mod 設定) * CustomSabers (光劍模型) * CustomPlatforms (場景模型) * CustomAvatars (人物模型) * CustomNotes (方塊模型) \u0026lt;3\u0026gt; 然後進入「Beat Saber 1.20.0」資料夾，貼上複製的這些資料夾。在彈出的提示中，選擇【替換】。 \u0026lt;4\u0026gt; 開啟「Beat Saber」資料夾，進入 Beat Saber_Data 資料夾，剪下 CustomLevels 資料夾。 \u0026lt;5\u0026gt; 進入「Beat Saber 1.20.0」資料夾，進入 Beat Saber_Data 資料夾，貼上剪下的那個資料夾。在彈出的提示中，選擇【替換】。\n最後將「Beat Saber」資料夾刪除，將「Beat Saber 1.20.0」資料夾重新命名為「Beat Saber」。\n2）相關軟體 \u0026lt;1\u0026gt; Mod 管理器 \u0026ldquo;ModAssistant\u0026rdquo; 此軟體有英文版和中文版，請依需求下載。網盤下載： 網盤連結 檔案直連： ModAssistant 中文增強版 Mod 安裝器，支援 PC 不支援 Quest \u0026lt;2\u0026gt; BeatSaber 歌曲路徑管理器 可透過上述網盤連結下載，檔案直連： BeatSaber 歌曲路徑管理器 (5.3 版本，可能因更新而失效)\n\u0026lt;3\u0026gt; Resilio Sync 可透過上述網盤連結下載，官網連結： Resilio Sync 檔案直連： Resilio Sync 64 位元 3）資料夾 上述軟體中，除了 Resilio Sync 外，皆為單一檔案應用程式，可放置於常用軟體資料夾。\n另外，需在您想存放歌曲的位置建立一個資料夾，例如「E:\\games\\Beat Saber Song\\」，位置可自行決定。\n二、步驟 1）開啟 Beat Saber 一次 2）開啟 \u0026ldquo;ModAssistant\u0026rdquo; 點擊同意後即可進入左方的 \u0026ldquo;Mod\u0026rdquo; 介面。左下方可選擇遊戲版本。選擇好後即可安裝 Mod，或直接開始安裝。\n若速度過慢，可在「選項」中將軟體來源改為國內。\n3）開啟 Beat Saber 一次 4）開啟 Resilio Sync 此部分步驟請參考： Beat Saber 曲包資源同步 – Resilio Sync (wgzeyu.com) 反正最後都是需要開啟這個網頁的，既然已有步驟，我就不在此處撰寫了（懶惰）。\n下載資料夾目錄即選擇上一步建立的資料夾。\n5）開啟 BeatSaber 歌曲路徑管理器 初次開啟時，請依照提示進行選擇。然後點擊「新增目錄」，選擇放置歌曲的目錄 (即上一步下載的資料夾目錄)。\n接著點擊「儲存列表」即可。\n三、後續 當然，如果您有其他需求，請參考 WGzeyu 的 教學 。\n","date":"2022-03-18T17:46:00+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/31/","title":"Beat Saber 新增自訂歌曲清單"},{"content":" 📢 此頁面有使用機器翻譯喲 引言 在玩了 Beat Saber 和 VRchat 等 VR 遊戲後突然想到 i 社有部分遊戲支援 VR，本人最喜歡玩戀活，於是試著進行遊玩，但卻遇到相關問題，本文僅作記錄。另 VR 版則無劇情，本人使用原版所以遇到問題較少。\n前提/條件 以下圖片和部分文字來自 Oculus 官網 Support ，部分英文自己進行了翻譯，鑑於本人英文不是太好，請以官方原內容為準，以下列出主要內容，詳情請參考 Oculus Link 的相容性要求 資料線要求 Oculus Link 需使用能夠支援資料和電源連接的優質 USB 資料線。為獲得最佳舒適體驗，您還應確保資料線長度至少為 3 米 (10 英尺)\n電腦要求 配件 推薦配置 CPU Intel i5-4590 / AMD Ryzen 5 1500X 或更高版本 顯卡 請參閱下面的 GPU 表 記憶體 8 GB+ 記憶體 作業系統 Win10 USB 介面 1 個 USB 介面 Oculus Link 支援的 GPU NVIDIA GPU 支援 暫時不支援 NVIDIA Titan Z X NVIDIA Titan X X NVIDIA GeForce GTX 970 X NVIDIA GeForce GTX 1060 Desktop, 3GB X NVIDIA GeForce GTX 1060 Desktop, 6GB X NVIDIA GeForce GTX 1060M X NVIDIA GeForce GTX 1070(all) X NVIDIA GeForce GTX 1080(all) X NVIDIA GeForce GTX 1650 X NVIDIA GeForce GTX 1650 Super X NVIDIA GeForce GTX 1660 X NVIDIA GeForce GTX 1660 TI X NVIDIA GeForce RTX 20-series (all) X NVIDIA GeForce RTX 30-series (all) X AMD GPU 支援 暫時不支援 AMD 200 Series X AMD 300 Series X AMD 400 Series X AMD 500 Series X AMD 5000 Series X AMD 6000 Series X AMD Vega Series X 一、進入遊戲 進入遊戲 VR 版本直接打開 KoikatuVR.exe 即可，由於使用 steam 串流，故可提前進入 steamVR\n進入遊戲前請確保戴上耳機，房門鎖緊等以預防突發情況，如不能做到請注意行為 XD\n問題一：無法進入 steamVR 一、確保安裝相關軟體 1）steamVR 安裝 首先打開 steam，然後按 Win+R，輸入 steam://run/250820，按下回車便會自動安裝 steamVR\n2）Oculus 安裝 訪問 官網下載 ，注意：安裝完成後會下載相關檔案，完成後會要求登錄帳號，請確保網絡環境正常 (台灣應該沒事 XD)\n如要求提供支付方式，可尋找 跳過 按鈕\n如果登入一直在加載，無法成功登入 可通過修改 Hosts 解決，推薦使用火絨打開 hosts 檔案進行修改\n如果不使用火絨，打開 C:\\Windows\\System32\\drivers\\etc，找到 hosts 這個檔案，用記事本打開\n在檔案末尾添加如下內容\n1 2 3 4 157.240.11.49 graph.oculus.com 157.240.11.49 www2.oculus.com 157.240.8.49 scontent.oculuscdn.com 157.240.8.49 securecdn.oculus.com 然後保存即可，如果不是使用火絨，請保存到一個地方然後移回原目錄並將副檔名 .txt 去除\n二、確保 Link 線正常 事實上，連接 Quest2 的時候 Oculus 軟體會有一步選擇是否檢測 Link 線，可通過此進行檢測，如果當時未進行檢測，可選擇 設備 - Quest2 和 Touch-USB 檢測 進行檢測\n三、確保設置正常 1）Quest2 設備設置 使用 USB 連接 PC 和 Quest2 時 Quest 會彈出 允許訪問資料，請選擇拒絕，如果選擇了 允許，請拔下再重新連接選擇 拒絕\n2）Oculus 軟體設置 其實直接打開 steamVR 會有彈窗 是否允許未知來源 此時選擇允許即可\n當然，可以在軟體的 設置 - 通用 - 未知來源 進行打開\n四、還是無法打開？換個姿勢試試 如果以上都沒問題但還是無法打開 steamVR，則可使用下述方式\n1）Quest2 設備 當連接 PC 後一般會有彈窗 啟用 Oculus Link，此時選擇 啟用 即可\n如果上述未選擇 啟用 或沒有彈窗，可在下方任務欄的最左方即 快速設置 中找到 Oculus Link，點擊即可打開\n2）啟動 steamVR 不會有人不知道 steamVR 怎麼啟動吧 (doge)\n如果先連接 VR 設備再打開 steam，那麼 steam 的介面右上方應該有 “VR” 標識，點擊即可打開\n如果無此標識，可在任務欄 (或者說右下托盤) 裡找到 steam 圖標，鼠標右擊，倒數第二個即為 steamVR\n當然，可以在 steam 庫中將 工具 也顯示，這樣可以在 steam 庫中看見 steamVR\n二、開始遊戲 我不知道這裡應該寫什麼，分這個標題是因為問題二與遊戲有關，那就寫其他的吧 (doge)\n點擊 KoikatuVR.exe 會自動打開 steamVR，所以可以在 Quest2 設備打開 Oculus Link 後直接打開 KoikatuVR 即可\n注意：遊戲會在桌面有一個視窗，可透過 Win+D 最小化所有視窗，但當摘下頭顯再次戴上時好像會再次出現，請注意\n問題二：無法開始遊戲/不知如何開始 如果您閱讀其他文章或觀看相關影片可能會得到僅支援部分設備 (支持啥我忘了)，如果和我一樣去測試了 VR kanojo 能否正常運行，也可能會以為是靠注視，其實不然 (我就是想多寫點)\n只需要按下 “搖桿” 即可出現選擇線，按下前 “扳機鍵” 即可選擇 (更多操作請看 三、操作說明)\n問題三：開始遊戲後一直白屏，電腦上 \u0026ldquo;LOADING\u0026rdquo; 一直在一半 可進 コイカツ！ DL 版 ，點擊下方 體験版・無料ダウンロード 中的 コイカツ VR パッチ 進行下載\n檔案直鏈： コイカツ VR パッチ 下載解壓後會有一個可執行檔，運行後會出現 コイカツ！VR_0531 更新版 資料夾，將裡面 setup 資料夾內容移到遊戲根目錄並覆蓋即可\n注意：此方法來源作者指出姿勢會變成只有三個，由於我並未遊玩，所以我沒有姿勢 (本來想著 VR 玩劇情的，但 VR 不能玩劇情)，以下為作者給出解決 (部分內容有修改)\n姿勢是在故事模式裡用過什麼姿勢，在 vr 裡才能用，所以在故事模式裡戰鬥的時候把所有姿勢都點一遍，點完就換就行，然後到晚上存檔，在退出換 vr，然後姿勢就齊了\n原文地址： 兄弟們有沒有玩了 vr 的 三、操作說明 此部分為自行遊玩得出，僅作部分說明，其他操作請自行參考其他文章\n1）開始遊戲 進入遊戲後會有俩選項，分別為\nスタート，即 start，即開始\nエンド，即 End，即結束\n按下 \u0026ldquo;搖桿\u0026rdquo;，會出現一條線，可進行選擇 (前 \u0026ldquo;扳機鍵\u0026rdquo;)\n2）進入本番 左右手手腕部分會出現文字，可通過左右控制器上方按鍵即 Y 和 B 進行切換\n一共有倆個，進入戰鬥後有三個 (多了一個 移動)，分別為\n日文 英文 中文 作用 アクション Action 行動 前 \u0026ldquo;扳機鍵\u0026rdquo; 可進行各種操作 側 \u0026ldquo;扳機鍵\u0026rdquo; 可打開菜單 按下 \u0026ldquo;搖桿\u0026rdquo; 可進行選擇 システム system 系統 前 \u0026ldquo;扳機鍵\u0026rdquo; 可重置位置 移動 Move 移動 前 \u0026ldquo;扳機鍵\u0026rdquo; 按住可改變視角 3）注意 僅可在 \u0026ldquo;アクション\u0026rdquo; 時按下 \u0026ldquo;搖桿\u0026rdquo; 可以進行選擇\n參考文章 Oculus Link 兄弟們有沒有玩了 vr 的 Oculus 用戶端在 Win10 上面無法安裝或登陸的解決方法_國韻的部落格 - CSDN 部落格_oculus 無法連接伺服器 中國移動的日文 (別問我為什麼會參考這個，問就是不會日文)\n","date":"2022-03-18T16:54:23+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/30/","title":"使用 Quest2 VR 玩戀愛活動 (戀活 / koikatu) 遇到的問題及解決"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 本文章由 Hiyoung 編寫\n第一章：了解 Web 及網路基礎 1.1 簡介 為了理解 HTTP，應事先了解一下 TCP/IP 協定家族。我們通常使用的網路（包括網際網路）是在 TCP/IP 協定家族的基礎上運作，而 HTTP 屬於其內部的一個子集。在網際網路上的設備若要相互通訊，雙方就必須遵從相同的規則，我們將這些規則稱為協定。（TCP/IP 是對網際網路相關的各類協定家族的一個總稱，包括但不限於：PPPoE、HTTP、TCP、IP、UDP、IEEE 802.3…）\n在 TCP/IP 協定家族中，按照層次從上到下分為：應用層、傳輸層、網路層、資料鏈結層。\n網際網路協定套件-維基百科 在使用 TCP/IP 協定家族進行通訊時，用戶端會從應用層往下走，伺服端會從資料鏈結層往上走。用戶端在層與層之間傳輸資料時，每經過一層時會為其加上該層的段首資訊。相反地，伺服端會一層一層地消去首部。這種將資料資訊包裝起來的方法叫做封裝。\n1.2 IP、TCP 與 DNS 1.2.1 IP 協定 IP 協定位於網路層，TCP/IP 中的 IP 指的是 IP 協定，與 IP 位址並非同一回事。IP 協定的作用是將各種資料封包傳送給對方。各種 IP 位址可以和 MAC 位址進行配對。IP 位址可變換，但 MAC 位址基本上不會更改。IP 位址指明了節點被分配到的位址，MAC 位址是指網路卡所屬的固定位址。\n1.2.2 MAC 位址 IP 之間的通訊依賴 MAC 位址。通常會使用 ARP 協定 來根據通訊方的 IP 位址反查出對應的 MAC 位址。\n1.2.3 TCP 協定 按層次分，TCP 位於傳輸層，提供位元組流服務（Byte Stream Service）——為了方便傳輸，將大塊資料分割成以報文段（segment）為單位的資料封包進行管理。簡而言之，TCP 協定為了更容易傳送大數據才將資料分割，而且 TCP 協定能夠確認資料最終是否送達對方。\n為了確認資料是否送達對方，TCP 採用了三次握手策略。握手過程中使用了 TCP 的旗標（flag）——SYN（synchronize）和 ACK（acknowledgement）。\n1.2.4 負責網域名稱解析的 DNS 服務 電腦既可以被賦予 IP 位址，也可以被賦予主機名和網域名稱。DNS 協定提供透過網域名稱查找 IP 位址，或逆向從 IP 位址反查網域名稱的服務。\n1.3 URL 與 URI 1.3.1 區別與關係 與 URI（統一資源識別碼）相比，我們更熟悉 URL（Uniform Resource Locator，統一資源定位符）。URL 正是使用網頁瀏覽器等存取網頁時需要輸入的網頁位址。例如 https://www.bilibili.com/ 就是 URL。URI 用字串識別某個網際網路資源，而 URL 表示資源的地點（網際網路上所處的位置）。可見 URL 是 URI 的子集。URI 可被視為定位符（URL）、名稱（URN）或兩者兼具。 統一資源名稱 （URN）如同一個人的名稱，而 統一資源定位符 （URL）代表一個人的住址。換言之，URN 定義某事物的身份，而 URL 提供查找該事物的方法。\n1.3.2 URI 格式 表示指定的 URI，要使用涵蓋所有必要資訊的絕對 URI、絕對 URL 以及相對 URL。\n相對 URL，是指從瀏覽器中基本 URI 處指定的 URL，形如 /image/logo.gif。\n絕對 URI 的格式：\n登入資訊（認證）：指定使用者名稱和密碼作為從伺服端獲取資源時必要的登入資訊（身份認證）。此項是可選項。\n伺服器位址：使用絕對 URI 必須指定待存取的伺服器位址。位址可以是類似 hackr.jp 這種 DNS 可解析的名稱，或是 192.168.1.1 這類 IPv4 位址名稱，還可以是 [0:0:0:0:0:0:0:1] 這樣用方括號括起來的 IPv6 位址名稱。\n伺服器連接埠號：指定伺服器連接的網路連接埠號。此項也是可選項，若使用者省略則自動使用預設連接埠號。\n帶層次的文件路徑：指定伺服器上的檔案路徑來定位特指的資源。這與 UNIX 系統的檔案目錄結構相似。\n查詢字串：針對已指定的檔案路徑內的資源，可以使用查詢字串傳入任意參數。此項為可選項。\n片段識別符：使用片段識別符通常可標記出已獲取資源中的子資源（文件內的某個位置）。但在 RFC 中並沒有明確規定其使用方法。該項也為可選項。\n第二章：簡單的 HTTP 協定 2.1 HTTP 簡介 HTTP 是一種不保存狀態的協定，所謂不保存狀態是指 HTTP 協定本身並不會對每次的請求和回應之間的通訊狀態進行保存。所以引入了 Cookie 技術來保存通訊狀態。（註：這本 HTTP 書籍出版較早，現在使用保存狀態的技術是由 cookie、session 和 token 共同實現的）\n2.2 常用的 HTTP 方法 GET：獲取資源\nGET 方法是用來請求 URL 指定的資源。指定資源經伺服端解析後返回回應內容。\nPOST：傳輸實體主體\nPOST 用於向伺服器傳輸資料，當獲取的資料過大時也會使用 POST 方法。\nGET 與 POST 的區別：\n先下結論，GET 與 POST 方法沒有實質區別，只是報文格式不同。\n請求參數長度限制：GET 請求長度最多 1024kb，POST 對請求資料沒有限制。\n請求參數：GET 請求參數是透過 URL 傳遞的，多個參數以 \u0026amp; 連接，POST 請求放在 request body 中。 請求快取：GET 請求會被快取，而 POST 請求不會，除非手動設定。 安全性：POST 比 GET 安全，GET 請求在瀏覽器回溯時是無害的，而 POST 會再次請求。 歷史紀錄：GET 請求參數會被完整保留在歷史紀錄裡，而 POST 中的參數不會被保留。 編碼方式：GET 請求只能進行 URL 編碼，而 POST 支援多種編碼方式。 對參數的資料類型：GET 只接受 ASCII 字元，而 POST 沒有限制。\n此外， HTTP 還有 PUT、HEAD、DELETE 等方法 在此不細細展開。\n2.3 HTTP 的持久連線（三次握手四次揮手） 持久連線的特點是，只要任意一端沒有明確提出斷開連線，則保持 TCP 連線狀態。\n三次握手：建立 TCP 連線 四次揮手：斷開 TCP 連線\n在持久連線中使用管線化技術，可以不用等待回應即可直接傳送下一個請求。\n2.4 使用 Cookie 的狀態管理 Cookie 會根據從伺服端傳送的回應報文內一個叫做 Set-Cookie 的首部欄位資訊，通知用戶端保存 Cookie。當下次用戶端再往該伺服器傳送請求時，用戶端會自動在請求報文中加入 Cookie 值後傳送出去。\nCookie 資訊是在伺服端產生並傳送給用戶端進行保存的。\n第三章 HTTP 報文資訊 3.1 HTTP 的請求與回應報文結構 用於 HTTP 協定交互的資訊被稱為 HTTP 報文。請求端（用戶端）的 HTTP 報文叫做請求報文，回應端（伺服端）的叫做回應報文。由 8 位元組流組成，透過 HTTP 通訊傳輸。\n請求行：包含用於請求的方法、請求 URI 和 HTTP 版本。\n狀態行：包含表明回應結果的狀態碼、原因短語和 HTTP 版本。\n首部欄位：包含表示請求與回應的各種條件和屬性的各類首部。一般有 4 種首部，分別是：通用首部、請求首部、回應首部和實體首部。\n其他：可能包含 HTTP 的 RFC 裡未定義的首部（Cookie 等）。\n3.2 編碼傳輸與分塊傳輸 HTTP 在傳輸資料過程中，透過編碼提升傳輸速率。\n3.2.1 報文主體與實體主體的差異 實體：作為請求或回應的有效負載資料（補充項）被傳輸，其內容由實體首部和實體主體組成。\nHTTP 報文的主體用於傳輸請求或回應的實體主體。**通常，報文主體等於實體主體。**只有當傳輸中進行編碼操作時，實體主體的內容發生變化，才導致它與報文主體產生差異。\n3.2.2 分割傳送實體主體 在 HTTP 通訊過程中傳輸大容量資料時，透過將資料分割成多塊，能讓瀏覽器逐步顯示頁面。將實體主體分塊的功能稱為分塊傳輸編碼。分塊傳輸編碼會將實體主體分成多個塊。每一塊都會用十六進制來標記塊的大小，而實體主體的最後一塊會使用「0(CR+LF)」來標記。\n所謂的塊也就是常稱的封包。\n第四章 返回結果的 HTTP 狀態碼 4.1 狀態碼的類別 藉助狀態碼，使用者可以知道伺服器是否正常處理了請求，狀態碼種類繁多但常用的大概只有 14 種。\n4.2 2XX 成功 4.2.1 200 OK 表示從用戶端傳來的請求在伺服端被正常處理了。在回應報文內，隨狀態碼一起返回的資訊會因方法的不同而發生改變。\n4.2.2 204 No Content 該狀態碼代表伺服器接收的請求已成功處理，但在返回的回應報文中不含實體的主體部分。\n4.3 3XX 重導向 重點介紹一下 301 重導向與 302 重導向，還有其他狀態碼可自行查看。\n4.3.1 301 Moved Permanently 301 重導向是永久性的重導向。該狀態碼表示請求的資源已被分配了新的 URI，以後應使用資源現在所指的 URI。例如像下方給出的請求 URI，當指定資源路徑的最後忘記添加斜線「/」時，就會產生 301 狀態碼。\nhttp://excample.com/sample\n4.3.2 302 Found 302 重導向是臨時性的重導向。該狀態碼表示請求的資源已被分配了新的 URI，希望使用者（本次）能使用新的 URI 存取。與 301 Moved Permanently 狀態碼相似，但 302 狀態碼代表的資源不是被永久移動，只是臨時性質的。\n4.4 4XX 用戶端錯誤 有 400 Bad Request、401 Unauthorized、403 Forbidden、404 Not Found。重點介紹一下 404 Not Found。\n4.4.1 404 Not Found 該狀態碼表明伺服器上無法找到請求的資源。除此之外，也可以在伺服端拒絕請求且不想說明理由時使用。\n4.5 5XX 伺服端錯誤 5XX 的回應結果表明伺服器本身發生錯誤。\n第五章 Web 伺服器 5.1 通訊資料轉發程式：代理、閘道器、隧道 5.1.1 代理 代理伺服器的基本行為就是接收用戶端傳送的請求後轉發給其他伺服器。代理不改變請求 URI，會直接傳送給前方持有資源的目標伺服器。值得一提的是，代理是指對用戶端的代理（也稱為前向代理），而反向代理是指對伺服器的代理。\n使用代理伺服器可以利用快取技術減少網路頻寬的流量，有時也會為了資訊安全而使用代理。\n快取代理 代理轉發回應時，快取代理（Caching Proxy）會預先將資源的副本（快取）保存在代理伺服器上。當代理再次接收到對相同資源的請求時，就可以不從來源伺服器那裡獲取資源，而是將之前快取的資源作為回應返回。\n反向代理 反向代理的優點有很多：\n對用戶端隱藏伺服器（叢集）的 IP 位址\n安全：作為 應用層防火牆 ，為網站提供對基於 Web 的攻擊行為（例如 DoS / DDoS ）的防護，更容易排除 惡意軟體 等\n為後端伺服器（叢集）統一提供加密和 SSL 加速（如 SSL 終端代理）\n負載平衡 ，若伺服器叢集中有負載較高者，反向代理透過 URL 重寫 ，根據連線請求從負載較低者獲取與所需相同的資源或備援\n對於靜態內容及短時間內有大量存取請求的動態內容提供 快取服務 對一些內容進行 壓縮 ，以節約 頻寬 或為網路頻寬不佳的網路提供服務\n5.1.2 閘道器 閘道器的工作機制與代理十分相似。而閘道器能使通訊線路上的伺服器提供非 HTTP 協定服務。\n","date":"2022-03-16T23:56:48+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/29/","title":"《圖解HTTP》讀後總結與淺談"},{"content":" 📢 本文由 Gemini-3-flash 翻譯 注意 此文章複製自 《unity學習筆記》——將MMD模型匯入unity ，僅用於個人記錄使用，部分內容有修改\n方法 1：利用 Unity 外掛程式直接讀取 FBX 模型 第一步：安裝外掛程式 MMD4Mecanim (Beta) 外掛程式網址： Stereoarts Homepage （應外掛程式作者要求，請勿上傳至 GitHub）\n檔案直連： MMD4Mecanim_Beta_20200105.zip 第二步：開啟 Unity，連按兩次下載好的外掛程式中的 MMD4Mecanim.unitypackage 檔案 第三步：將 MMD 模型（全部）檔案匯入 Unity 選擇自動產生的 .MMD4Mecanim，點擊同意（此時可加入動畫、音樂等）\n此方法的好處是可以最大限度地還原 MMD 原本的渲染效果，而且不需要自行重新設定著色器 (Shader)，並且不需藉助 Unity 以外的其他軟體。\n方法 2：利用 Blender 外掛程式將 MMD 模型轉為 FBX 匯入 第一步：安裝 Blender 外掛程式 GitHub: cats-blender-plugin 此外掛程式可以讓 Blender 辨識 MMD 的 PMX 檔案，然後可以根據需要使用 Blender 匯出成 FBX、STL 等格式（FBX 為 Unity 可辨識的格式）。\n第二步：將匯出的 FBX 模型與原模型的所有材質一起匯入 Unity 在匯入 Unity 時，效果或渲染風格可能與原本的不一致，需要自行設定著色器 (Shader)。\n自行設定著色器的好處是可以在 Unity 中統一不同模型的美術風格，或者如果是為了方便起見，可以在 Unity Asset Store 下載相應風格的模型，將下載模型的著色器套用至匯入的 MMD 模型即可（模型動作也可以套用，顏色可以自行修改）。\n","date":"2022-03-10T13:15:26+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/28/","title":"將 MMD 模型匯入 Unity"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 前言 在日常撰寫文章時，經常會需要插入圖片（雖然我最近的文章都沒有圖片），但是如果使用自己的伺服器，會比較耗費流量，而且載入速度也不是特別快。這時候就需要使用圖床了，然而多數免費圖床會不時地出現圖片遺失、速度緩慢等問題，因此我開始探索如何自建圖床。\n然而，如果特意花錢租用雲端伺服器來託管圖片，又太貴不划算；使用付費圖床則多數有流量或空間限制。於是我無意間發現了一個專案，這是一款基於 GitHub API \u0026amp; jsDelivr 開發，並具備 CDN 加速功能的圖床管理工具。\nPicX 圖床簡介 官方網站： PicX 圖床 專案位址： XPoet/picx: 基於 GitHub API \u0026amp; jsDelivr 開發的具有 CDN 加速功能的圖床管理工具 官方文件： 快速開始-PicX 圖床 特色：只需選擇一個 GitHub 儲存庫作為圖床，然後在 PicX 官網 完成 Token 綁定和相應設定即可使用，免下載與安裝，就這麼簡單。\n快速開始 首先，建立一個 GitHub 儲存庫 點擊連結 Create a New Repository Repository name 輸入一個名稱（例如 image-hosting）\n儲存庫屬性必須選擇 Public\n接著，建立一個具有 repo 權限的 GitHub Token 點擊連結 New personal access token 輸入 Note（即名稱，例如 picx-image-hosting）\n注意：「Expiration」為此 Token 的有效期限，請務必選擇。 如果您過早讀到這篇文章而未進行設定，請參考： 使用 PicX 圖床上傳圖片提示「Bad credentials」– yexca’Blog Select scopes 勾選 repo，然後建立 Token\n注意：新產生的 Token 只會顯示一次，請妥善保管，如有遺失，重新產生即可。\n最後，到官網輸入 Token 設定 開啟 PicX官網 ，進入圖床設定，填入 Token\n然後選擇儲存庫和目錄方式\n建立目錄：需手動輸入一個新目錄。（使用 / 可建立多層目錄，例如：A01/A02 表示建立了二級目錄，最多支援建立三層目錄。） 根目錄：圖片將直接儲存在儲存庫根目錄下。 自動目錄：自動產生日期格式 YYYYMMDD 的目錄。例如：20200909。 好的，圖床已經設定完成，開始使用吧！\n其他設定 設定預設開啟圖片壓縮，可在「我的設定」中進行修改\n","date":"2022-02-17T23:02:13+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/27/","title":"使用 PicX 自建免費圖床"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 前言 由於學校的教務系統查看課表不夠便利，而且第三方課表存在一定的資安疑慮並且廣告很多，於是我便想著把課表匯入日曆，我選擇匯入 Outlook 日曆，這樣可以實現在 iOS、Windows 和 Android 多個裝置上同步。\n準備工作 一台電腦 一支 Android 手機 電腦安裝 Chrome 瀏覽器： 官方網站連結 手機安裝 WakeUp 課表： 官方網站連結 第一步，匯出課表 一、使用 Chrome 開啟教務系統網址，進入課表介面\n二、匯出 HTML 檔案\n首先複製以下程式碼\n1 javascript:void(function(u,s){s=document.body.appendChild(document.createElement(\u0026#39;script\u0026#39;));s.src=u+\u0026#39;?ts=\u0026#39;+Date.now();s.charset=\u0026#39;UTF-8\u0026#39;}(\u0026#39;https://the-red-hat-was-uncovered.gitee.io/supwisdom-course-table/dist.js\u0026#39;)) 接著是加入我的最愛，Windows 下的快速鍵是 Ctrl + D\n按下快速鍵後，可以直接點選「更多」按鈕，來編輯剛才加入的我的最愛，這時候可以修改名稱和 URL（網址），名稱取個好記的（例如「WakeUp 匯出課表」），URL（網址）那邊貼上剛剛複製的程式碼！然後再儲存。\n最後點擊剛剛加入的我的最愛網址（如上所述），此時瀏覽器會自動下載「教務.html」檔案（也就是下一步要用的檔案）\n第二步，匯入 WakeUp 課表 一、將上一步匯出的檔案傳送到手機上\n二、匯入課表至 WakeUp 課表\n手機開啟 WakeUp 課表，匯入新課表（右上方第二個），點選「從 HTML 檔案匯入」\n「選擇學校/教務類型」選擇「樹維教務（簡易匯入）」 ，不用選擇學校，然後選擇檔案後點選右下角\n匯入完成後請注意選擇正確的開學日期或是當前週數\n第三步，匯入日曆 在 WakeUp 課表點選右上方第三個匯出，選擇「匯出為 ICS（日曆用）格式」\n如果是 Android 手機可找到檔案目錄，點擊檔案，用日曆開啟即可\n如果是 iOS 手機可透過寄送電子郵件（帶附件）的方式傳送到手機登入的電子郵件信箱，然後點擊附件匯入\n參考文章 樹維教務簡易匯入 ","date":"2022-02-16T17:53:16+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/26/","title":"將課表匯入日曆（樹維教務）"},{"content":" 📢 本文由 gemini-2.5-flash-lite 翻譯 國內工具 使用站長工具的連接埠掃描，輸入IP位址或網域名稱和連接埠後點擊開始掃描\n如果顯示關閉，則連接埠未開啟或無法連線\n工具連結： 連接埠掃描 – 站長工具 國外工具 使用 you get signal 的 Port Forwarding Tester 進行掃描\n進入後會自動填寫您的IP和 80 連接埠，可修改為想要掃描的IP和連接埠後點擊 Check\n如果出現紅旗並顯示 port ** is closed on ***.***.***.*** 則連接埠未開啟或無法連線\n工具連結： Open Port Check Tool – Test Port Forwarding on Your Router ","date":"2022-02-13T19:46:38+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/25/","title":"查看伺服器連接埠是否開啟"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 引言 由於 QQ 軟體過於臃腫且權限過大，並且經常性卡住無法載入，因此便尋找其他方法。首先是透過 Telegram 收發 QQ 訊息，但設定較為複雜且並不穩定，於是棄用並改用 VS Code。\n插件簡介 名稱: QQ\nID: takayama.vscode-qq\n說明: lite qq for chat in working\n版本: 1.4.2\n發布者: takayama\nVS Marketplace 連結: VS Code QQ Extension GitHub 專案位址： vscode-qq 註：本程式不在本地儲存任何訊息紀錄和圖片。暫不支援臨時對話。\n安裝 首先安裝 VS Code，造訪 官網 點擊 Download 即可下載安裝。\n然後造訪上述 VS Code QQ Extension 連結點擊 Install 即可自動開啟 VS Code 安裝。\n或者打開 VS Code 在左側「延伸模組」(或按 CTRL+SHIFT+X)，然後搜尋 QQ (注意大寫)，點擊第一個安裝。\n功能 按快速鍵「CTRL+SHIFT+P」打開命令面板。\n輸入「QQ Explorer: Login」（或只輸入「login」會顯示對應選項）後按 Enter。\n然後根據提示輸入帳號密碼即可登入成功，此時會顯示相關功能。\n輸入「QQ Explorer: 搜尋好友」即可搜尋好友。\n輸入「QQ Explorer: 搜尋群組」即可搜尋群組。\n設定 在登入成功後控制面板便會有設定，進入設定為 JSON 檔案編輯，內容如下：\n1 2 3 4 5 6 7 8 9 { \u0026#34;account\u0026#34;: ***********, // QQ 號碼 \u0026#34;password\u0026#34;: \u0026#34;********************************\u0026#34;, // QQ 密碼 \u0026#34;platform\u0026#34;: 5, // 登入平台，可更改「1: 手機, 3: 手錶(功能不完整), 4: PC, 5: pad(預設)」 \u0026#34;show_me_add_group_request\u0026#34;: false, \u0026#34;theme\u0026#34;: \u0026#34;default\u0026#34;, // UI 主題，可更改「default(預設) 和 console(控制台風格)」 \u0026#34;theme_css\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;theme_js\u0026#34;: \u0026#34;\u0026#34; } 可自訂主題，詳情參考： 修改/自定義 UI 主題 ","date":"2022-02-11T21:47:56+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/24/","title":"使用 VS Code 收發 QQ 訊息"},{"content":" 📢 本文由 gemini-2.5-flash-lite 翻譯 引言 Potplayer 是非常優秀的影片播放軟體，但最近的版本右下角開始有彈出廣告，非常令人困擾。本文將介紹兩種方法來解決右下角彈窗問題。\n使用無彈窗的舊版本（推薦） 最後一個沒有廣告彈窗的版本是 1.7.18958。\n舊版本的所有 PotPlayer 都可以從以下網址下載：\nPotPlayer 舊版本下載 1.7.18958 版本直接下載連結： 64 位元 | 32 位元 安裝完成後，開啟「設定」（按 F5），在「基本設定」-\u0026gt;「自動更新」中選擇「不使用自動更新」。\n使用綠色版 註：此版本的個人使用體驗感覺不是太好，例如無法靠近吸附視窗、以原始檔案比例開啟等。\n藍奏雲連結 by zdBryan\n一般執行 = 安裝版（包含開始選單捷徑及程式解除安裝捷徑）\n右鍵解壓縮 = 綠色版（本身不提供便攜式軟體，需手動執行綠化處理）\n版本特色\n1、移除驗證，移除右下角空白廣告彈窗！解除安裝時可選擇備份設定。 2、禁止背景網路請求：境外廣告、傳送日誌、檢查升級。 3、整合額外的音訊解碼器及影片解碼器元件。 4、預設配置：一般設定 + 預設啟用自訂解碼器 H.265/HEVC 及硬體加速。 5、刪除 TV 直播列表、登入程式、日誌管理、訊息通知、多語言等不必要的檔案。 參考文章 關於 Potplayer 右下角彈窗解決方案 PotPlayer v1.7.21589 綠色版 ","date":"2022-02-06T21:37:45+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/23/","title":"移除 Potplayer 右下角彈窗"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 前言 (閒聊) 閒暇之餘，於是便想鑽研一下路由器當作網路閘道器（但事後才發現這台路由器的儲存空間太小，無法安裝太多外掛程式，簡直是白忙了一整個下午）\n2022.02.17 更新：無意間發現了一個內建網路閘道器的 FIR300M 韌體，但由於支援的方法過於老舊，若要刷入，請注意辨別。\n原文連結： 更新編譯方法 - FIR300M/FIR302M 的 Openwrt 韌體 免拆機刷 百度網盤： 提取碼: vouv OpenWRT 簡介 OpenWRT 是基於 Linux 的路由器作業系統，擁有許多強大的外掛程式和較佳的擴充性，並且可以透過 SSH 進行連線\n官方網站： OpenWrt Wiki - Welcome to the OpenWrt Project OpenWRT 通用教學： 從零開始學習 OpenWrt: 刷機 + 使用 + 編譯教學 準備工作 一、軟體 HFS 二、適用於 FIR300M 的 OpenWRT 韌體: 百度網盤 三、電腦開啟 Telnet 服務，請參考 win10 如何開啟 telnet 服務 （Win11 也適用，控制台可以在設定中搜尋進入） 簡要步驟 一、登入路由器管理介面 (192.168.1.1) 並登入 二、造訪 http://192.168.1.1/goform/Diagnosis?pingAddr=192.168.1.100|echo\u0026quot;\u0026quot;|telnetd 三、開啟命令提示字元 (cmd)，輸入: telnet 192.168.1.1 四、將韌體傳輸到路由器，等待完成 五、此時進入路由器管理介面即為 OpenWRT (初始無密碼，直接登入即可) 六、點擊 System-Language and Style 可將語系改為中文 詳細步驟 (第四步) 開啟 HFS，將「準備工作」第二步中的韌體重新命名為「1.bin」並拖曳到視窗中\n在命令提示字元 (cmd) 輸入指令「telnet 192.168.1.1」並成功連線後，依序輸入以下指令\n1 2 3 cd /tmp wget http://192.168.1.100/1.bin // 請將「192.168.1.100」替換為您的機器 IP mtd_write -r write 1.bin Kernel // (注意，這裡的 K 是大寫) 執行成功後路由器會自動重新啟動，所以會顯示「連線中斷」\n外掛程式安裝 在 OpenWRT 管理介面點擊「系統-軟體包」即可安裝相應外掛程式\n建議到 Github 尋找相應的外掛程式，當然也可以自行編寫\n因為安裝外掛程式需要網路位址，可以直接複製 Github 相應專案 Release 中的 ipk 檔案連結\n自己編寫要如何安裝？您都已經會自己編寫了，還會不懂這個嗎？ (doge)\n注意事項 外掛程式安裝需要與路由器相容，部分外掛程式可能需要環境依賴，也就是需要先安裝其他外掛程式。\n具體可以透過錯誤訊息進行判斷\n參考文章 FIR300M 免拆機刷 Openwrt 教學 路由器刷韌體——斐訊路由器 FIR300M 刷 OpenWrt 韌體教學 HFS – 超好用的本機檔案分享工具，快速從電腦傳輸檔案到手機等裝置 許迎果 第 215 期 OpenWrt 外掛程式的安裝與移除 ","date":"2022-02-06T20:44:10+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/22/","title":"FIR300M 路由器刷韌體 OpenWRT"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 引言 (廢話) 有時候會有在 Word 文件中插入程式碼的需求，但是直接把程式碼複製過去會不怎麼美觀，而且沒有高亮顯示看著也相當難受。\n工具一 CodeInWord 在 Word 中優雅展現的程式碼/程式碼高亮/Word 中插入程式碼/程式碼格式化 工具二 Syntax Highlight Code In Microsoft Word 使用說明 沒什麼要說明的，把程式碼複製過去，選擇相對應的語言，點擊生成再複製到 Word 中即可。\n附錄 如果以上網站無法使用，可在搜尋引擎搜尋「syntax highlight code in word」。\n參考文章 如何優雅地在 Microsoft Word 中插入程式碼 ","date":"2022-01-20T14:28:52+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/21/","title":"在 Microsoft Word 中插入程式碼（高亮）"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 前言 在玩其他區域的一些小遊戲時，常常會因為亂碼而無法遊玩，或者發生錯誤而不能執行，這時候就需要轉區以匹配正確的文字。\n雖然可以透過修改 Windows 的地區設定來執行，但很多時候這個方法稍微繁瑣，並且需要重新開機。玩完後如果不改回來，則可能導致正常的軟體無法使用，此時便需要相關的轉區軟體。\n軟體取得 軟體官網： Locale Emulator GitHub 專案位址 (releases)： Locale Emulator – GitHub 設定說明 下載並解壓縮後，點擊「LEInstaller」依照需求為目前使用者或所有使用者安裝。\n安裝完成後，點擊「LEGUI」設定轉區環境 (如果玩日本遊戲則不需要，預設會自動設定)。\n使用說明 找到要開啟的遊戲，右鍵點擊執行檔 (.exe)。\n接著選擇 Locale Emulator，然後選擇對應環境執行 (如果是 Win11，請點擊「顯示更多選項」)。\n廢話 僅作為個人記錄，以供自用，官網上就有使用說明。\n","date":"2022-01-14T15:53:40+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/20/","title":"轉區軟體 Locale Emulator"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 這篇文章由 Hiyoung 編寫\n背景知識：\nLinux 時鐘概述 Linux 系統有兩個時鐘：一個是硬體時鐘，即 BIOS 時間；另一個是系統時鐘，是 Linux 系統 Kernel（核心）時間。 在 Linux 系統上程式執行時讀取的時間都是系統 Kernel（核心）時間。 每次 Linux 開機時，系統 Kernel（核心）會先去讀取硬體時鐘的設定（但是此時的硬體時間不一定準確），然後系統時鐘就會獨立於硬體繼續運作。 綜上所述，所以想要永久修改 Linux 時間並讓時間準確，就需要永久修改硬體時間，不然每次重新開機 Linux 時，系統時間又變回之前的硬體時間。 Linux 時鐘相關指令 系統 Kernel（核心）時鐘的相關指令是 timedatectl 或者 date； 硬體 BIOS 時鐘相關指令是 hwclock 或者 clock。\n1. 在 Linux CLI 介面輸入 date 查看目前 Linux 系統時間 1 date 輸入 hwclock --show 查看硬體時間\n1 hwclock --show 2. 校準 Linux 系統時間（使用 NTP 服務時需要系統連網） CentOS 下安裝配置 NTP 服務的步驟如下： 1 2 # 安裝 NTP 服務的套件 sudo yum install ntp 1 2 # 將 NTP 服務設定為預設啟動 sudo chkconfig ntp on 1 2 # 修改啟動參數，增加 -g -x 參數，允許 NTP 服務在系統時間誤差較大時也能正常運作 sudo vi /etc/sysconfig/ntpd 1 2 # 啟動 NTP 服務 sudo service ntpd restart Ubuntu/Debian 下安裝配置 NTP 服務的步驟如下： 1 2 # 安裝 NTP 服務的套件 sudo apt-get install ntp 1 2 # 修改啟動參數，增加 -g -x 參數，允許 NTP 服務在系統時間誤差較大時也能正常運作 sudo vi /etc/default/ntp 1 2 # 啟動 NTP 服務 sudo service ntp restart 將硬體時鐘調整為與系統時鐘一致 1 hwclock --systohc --localtime (這個好像更有效) 或者\n1 timedatectl set-local-rtc 1 最後將日期寫入 CMOS 永久生效 1 clock -w 或者\n1 hwclock -w 3. 開啟 Google BBR 加速 本文的系統要求為 Debian 9 或更高版本的 Debian Linux，其他作業系統所知不詳，不知是否適合本文的方法。\n注意，本文的配置參數不只啟用 Google BBR，還包括一系列網路參數的優化，直接複製執行使用即可。\nGoogle BBR 一鍵加速 VPS 伺服器很簡單，SSH 登入 VPS 後，分別執行以下 2 個指令即可（滑鼠選取反白後，點滑鼠右鍵複製貼上到 root 帳號的 # 後面，然後按 Enter 鍵）。\n指令 1 1 wget https://raw.githubusercontent.com/bannedbook/fanqiang/master/v2ss/server-cfg/sysctl.conf -O -\u0026gt; /etc/sysctl.con 如果提示 wget: command not found 的錯誤，這是因為你的系統沒有安裝 wget，所以需要先安裝 wget: \u0026lt;strong\u0026gt;apt-get install -y wget\u0026lt;/strong\u0026gt;\n指令 2 1 sysctl -p 執行成功後大致會輸出：（視個人情況而定） fs.file-max = 51200 net.ipv4.conf.lo.accept_redirects = 0 net.ipv4.conf.all.accept_redirects = 0 net.ipv4.conf.default.accept_redirects = 0 net.ipv4.ip_local_port_range = 10000 65000 net.ipv4.tcp_fin_timeout = 15 net.ipv4.tcp_fastopen = 3 net.ipv4.tcp_keepalive_time = 1200 net.ipv4.tcp_rmem = 32768 436600 873200 net.ipv4.tcp_syncookies = 1 net.ipv4.tcp_synack_retries = 2 net.ipv4.tcp_syn_retries = 2 net.ipv4.tcp_timestamps = 0 net.ipv4.tcp_max_tw_buckets = 9000 net.ipv4.tcp_max_syn_backlog = 65536 net.ipv4.tcp_mem = 94500000 91500000 92700000 net.ipv4.tcp_max_orphans = 3276800 net.ipv4.tcp_mtu_probing = 1 net.ipv4.tcp_wmem = 8192 436600 873200 net.core.netdev_max_backlog = 250000 net.core.somaxconn = 32768 net.core.wmem_default = 8388608 net.core.rmem_default = 8388608 net.core.rmem_max = 67108864 net.core.wmem_max = 67108864 net.ipv4.tcp_congestion_control = bbr\n","date":"2022-01-14T01:30:54+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/19/","title":"Linux 伺服器（網路相關）"},{"content":" 該文章使用 Google 翻譯處理。\n順序棧 (數組實作) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #include \u0026lt;stdio.h\u0026gt; // 元素 elem 進棧，a 為數組，top 值為目前堆疊的棧頂位置 int push(int* a,int top,int elem) { a[++top]=elem; return top; } // 資料元素出棧 int pop(int * a,int top) { if (top==-1) { printf(\u0026#34;空堆疊\u0026#34;); return -1; } printf(\u0026#34;彈棧元素：%d\\n\u0026#34;,a[top]); top--; return top; } int main(void) { int a[100]; int top=-1; top = push(a, top, 1); top = push(a, top, 2); top = push(a, top, 3); top = push(a, top, 4); top = pop(a, top); top = pop(a, top); top = pop(a, top); top = pop(a, top); top = pop(a, top); return 0; } 輸出結果：\n彈棧元素：4 彈棧元素：3\n彈棧元素：2 彈棧元素：1 空堆疊\n鏈堆疊 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; typedef struct lineStack{ int data; struct lineStack * next; }lineStack; // stack 為目前的鏈棧，a 表示入棧元素 lineStack* push(lineStack * stack,int a) { // 建立儲存新元素的節點 lineStack * line=(lineStack*)malloc(sizeof(lineStack)); line-\u0026gt;data=a; // 新節點與頭節點建立邏輯關係 line-\u0026gt;next=stack; // 更新頭指標的指向 stack=line; return stack; } // 棧頂元素出鏈棧的實作函數 lineStack * pop(lineStack * stack) { if (stack) { // 宣告一個新指標指向棧頂節點 lineStack * p=stack; // 更新頭指針 stack=stack-\u0026gt;next; printf(\u0026#34;出棧元素：%d \u0026#34;,p-\u0026gt;data); if (stack) { printf(\u0026#34;新棧頂元素：%d\\n\u0026#34;,stack-\u0026gt;data); } else { printf(\u0026#34;堆疊已空\\n\u0026#34;); } free(p); } else { printf(\u0026#34;棧內沒有元素\u0026#34;); return stack; } return stack; } int main(void) { lineStack * stack=NULL; stack=push(stack, 1); stack=push(stack, 2); stack=push(stack, 3); stack=push(stack, 4); stack=pop(stack); stack=pop(stack); stack=pop(stack); stack=pop(stack); stack=pop(stack); return 0; } 輸出結果：\n出棧元素：4 新棧頂元素：3 出棧元素：3 新棧頂元素：2\n出棧元素：2 新棧頂元素：1\n出棧元素：1 堆疊已空 棧內沒有元素\n","date":"2021-11-21T22:19:04+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/17/","title":"資料結構 堆疊程式碼"},{"content":" 該文章使用 Google 翻譯處理。\n程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; // malloc()、exit() #define Size 5 // 對 Size 進行巨集定義，表示順序表申請空間的大小 typedef struct Table { int * head; // 宣告了一個名為head的長度不確定的數組，也叫“動態數組” int length; // 記錄當前順序表的長度 int size; // 記錄順序表分配的儲存容量 }table; // 初始化函數 table initTable() { table t; t.head = (int*)malloc(Size * sizeof(int)); // 建構一個空的順序表，動態申請儲存空間 if (!t.head) // 若申請失敗，作出提示並直接退出程序 { printf(\u0026#34;初始化失敗\u0026#34;); exit(0); } t.length = 0; // 空表的長度初始化為 0 t.size = Size; // 空表的初始儲存空間為 Size return t; } // 插入函數，其中，elem 為插入的元素，add 為插入到順序表的位置 table addTable(table t, int elem, int add) { int i; // 判斷插入本身是否有問題（如果插入元素位置比整張表的長度 +1 還大 (如果相等，是尾隨的情況)，或者插入的位置本身不存在，程序作為提示並自動退出) if (add \u0026gt; t.length + 1 || add \u0026lt; 1) { printf(\u0026#34;插入位置有問題\u0026#34;); return t; } // 做插入操作時，首先需要看順序表是否有多餘的儲存空間提供給插入的元素，如果沒有，則需要申請 if (t.length == t.size) { t.head = (int *)realloc(t.head, (t.size + 1) * sizeof(int)); if (!t.head) { printf(\u0026#34;儲存分配失敗\u0026#34;); return t; } t.size += 1; } // 插入操作，需要將從插入位置開始的後續元素，逐個後移 for (i = t.length - 1; i \u0026gt;= add - 1; i--) { t.head[i + 1] = t.head[i]; } // 後移完成後，直接將所需插入元素，新增至順序表的相應位置 t.head[add - 1] = elem; // 由於添加了元素，所以長度 +1 t.length++; return t; } // 刪除函數 table delTable(table t, int add) { int i; if (add \u0026gt; t.length || add \u0026lt; 1) { printf(\u0026#34;被刪除元素的位置有誤\u0026#34;); exit(0); } for (i = add; i \u0026lt; t.length; i++) { t.head[i - 1] = t.head[i]; } t.length--; return t; } // 尋找函數，其中，elem 表示要尋找的資料元素的值 int selectTable(table t, int elem) { int i; for (i = 0; i \u0026lt; t.length; i++) { if (t.head[i] == elem) { return i + 1; } } return -1; } // 更改函數，其中，elem 為要更改的元素，newElem 為新的資料元素 table amendTable(table t, int elem, int newElem) { int add = selectTable(t, elem); t.head[add - 1] = newElem; return t; } // 輸出順序表中元素的函數 void displayTable(table t) { int i; for (i = 0; i \u0026lt; t.length; i++) { printf(\u0026#34;%d \u0026#34;, t.head[i]); } printf(\u0026#34;\\n\u0026#34;); } int main() { int i, add; table t1 = initTable(); // 在順序表中新增元素 for (i = 1; i \u0026lt;= Size; i++) { t1.head[i - 1] = i; t1.length++; } printf(\u0026#34;原順序表：\\n\u0026#34;); displayTable(t1); printf(\u0026#34;刪除元素 1:\\n\u0026#34;); t1 = delTable(t1, 1); displayTable(t1); printf(\u0026#34;在第 2 的位置插入元素 5:\\n\u0026#34;); t1 = addTable(t1, 5, 2); displayTable(t1); printf(\u0026#34;尋找元素 3 的位置:\\n\u0026#34;); add = selectTable(t1, 3); printf(\u0026#34;%d\\n\u0026#34;, add); printf(\u0026#34;將元素 3 改為 6:\\n\u0026#34;); t1 = amendTable(t1, 3, 6); displayTable(t1); return 0; } 結果 程式運行結果為：\n原順序表： 1 2 3 4 5\n刪除元素 1:\n2 3 4 5\n在第 2 的位置插入元素 5:\n2 5 3 4 5\n尋找元素 3 的位置:\n3\n將元素 3 改為 6:\n2 5 6 4 5\n","date":"2021-11-20T23:01:47+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/16/","title":"資料結構 順序表程式碼"},{"content":" 該文章使用 Google 翻譯處理。\n簡單鍊錶 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include \u0026lt;stdio.h\u0026gt; struct student { long num; float score; struct student *next; }; void main() { struct student a, b, c, *head, *p; a.num = 99101; a.score = 89.5; b.num = 99103; b.score = 90; c.num = 99107; c.score = 85; // 對結點的 num 和 score 成員賦值 head = \u0026amp;a; // 將結點 a 的起始位址賦給頭指標 head a.next = \u0026amp;b; // 將結點 b 的起始位址賦給 a 結點的 next 成員 b.next = \u0026amp;c; c.next = NULL; // c 結點的 next 成員不存放其他結點位址 p = head; // 使 p 指標指向 a 結點 do { printf(\u0026#34;%ld %5.1f\\n\u0026#34;, p-\u0026gt;num, p-\u0026gt;score); // 輸出 p 指向的結點的數據 p = p-\u0026gt;next; // 使 p 指向下一個結點 }while(p != NULL); // 輸出完 c 結點後 p 的值為 NULL system(\u0026#34;pause\u0026#34;); } 記憶體分配函數 malloc 函數 1 void *malloc(unsigned int size); 作用是在記憶體的動態儲存區中分配一個長度為 size 的連接空間。有些函數的值（即傳回值）是一個指向分配空間起始位址的指標（基底型別為 void）。如果些函數未能成功地執行（例如記憶體空間不足）則傳回空指標 NULL。\ncalloc 函數 1 void *calloc(unsigned n, unsigned size); 其作用是在記憶體的動態區儲存中分配 n 個長度為 size 的連續空間。函數傳回一個指向分配空間起始位址的指針，如果分配不成功，則傳回 NULL。 用 calloc 函數可以為一維數組開啟動態儲存空間， n 為數組元素個數，每個元素長度為 size。\nfree 函數 1 void free(void *p); 其作用是釋放由 p 指向的記憶體區，使這部分記憶體區能被其它變數使用， p 是最後一次呼叫 calloc 或 malloc 函數時傳回的值。 free 函數無回傳值​​。請注意：以前的C版本提供的 malloc 和 calloc 函數得到的是指向字元型資料的指標。 ANSI C 提供的 malloc 和 calloc 函數規定為 void * 類型。\n動態鍊錶的實現 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #define NULL 0 #define LEN sizeof(struct student) struct student { long num; float score; struct student *next; }; struct student *create() { struct student *p1, *p2, *head; int num; float score; int n = 0; head = NULL; p1 = p2 = (struct student *)malloc(LEN); printf(\u0026#34;please input num and score.\\n\u0026#34;); scanf(\u0026#34;%d,%f\u0026#34;, \u0026amp;p1-\u0026gt;num, \u0026amp;p1-\u0026gt;score); while(p1-\u0026gt;num != 0) { n ++; if(n == 1) head = p1; else p2-\u0026gt;next = p1; p2 = p1; p1 = (struct student *)malloc(sizeof(struct student)); printf(\u0026#34;please input num and score.\\n\u0026#34;); scanf(\u0026#34;%d,%f\u0026#34;, \u0026amp;p1-\u0026gt;num, \u0026amp;p1-\u0026gt;score); } p2-\u0026gt;next = NULL; return head; } void printlist(struct student *head) { struct student *p; p = head; if(head != NULL) { do { printf(\u0026#34;num=%d score=%f\\n\u0026#34;, p-\u0026gt;num, p-\u0026gt;score); p = p-\u0026gt;next; }while(p != NULL); } } void main() { struct student *head; head = create(); printlist(head); system(\u0026#34;pause\u0026#34;); } // 列印鍊錶 void printlist(struct student *head) { struct student *p; p = head; if(head != NULL) { do { printf(\u0026#34;num=%d score=%5.2f\\n\u0026#34;, p-\u0026gt;num, p-\u0026gt;score); p = p-\u0026gt;next; } while (p != NULL); } /* while(p -\u0026gt; next != NULL) { printf(\u0026#34;num=%d score=%f\\n\u0026#34;, p-\u0026gt;num, p-\u0026gt;score); p = p-\u0026gt;next; }*/ } // 刪除節點 struct student *delNode(struct student *head, int num) { printf(\u0026#34;delNode.\\n\u0026#34;); struct student *p1, *p2; if(head == NULL) { printf(\u0026#34;The List is NULL.\\n\u0026#34;); } else { p1 = head; while(p1-\u0026gt;next != NULL \u0026amp;\u0026amp; p1-\u0026gt;num != num) { p2 = p1; p1 = p1-\u0026gt;next; } if(p1-\u0026gt;num == num) { if(p1 == head) head = p1-\u0026gt;next; else p2-\u0026gt;next = p1-\u0026gt;next; } else printf(\u0026#34;Can not find list num.\\n\u0026#34;); } return head; } // 更新節點 struct student *update(struct student *head, int index, int num, float score) { printf(\u0026#34;update.\\n\u0026#34;); struct student *p; if(head == NULL) { printf(\u0026#34;The List is NULL.\\n\u0026#34;); } else { p = head; while(p-\u0026gt;next != NULL \u0026amp;\u0026amp; p-\u0026gt;num != index) { p = p-\u0026gt;next; } if(p-\u0026gt;num == index) { p-\u0026gt;num = num; p-\u0026gt;score = score; } else printf(\u0026#34;Can not find list index.\\n\u0026#34;); } return head; } // 增加節點 struct student *add(struct student *head, int index, int num, float score) { printf(\u0026#34;add.\\n\u0026#34;); struct student *p1, *p2, *p3; if(head == NULL) { printf(\u0026#34;The List is NULL.\\n\u0026#34;); } else { p1 = p2 = head; while(p1-\u0026gt;next != NULL \u0026amp;\u0026amp; p1-\u0026gt;num != index) { p1 = p1-\u0026gt;next; p2 = p1; } if(p1-\u0026gt;num == index) { p3 = (struct student *)malloc(LEN); p3-\u0026gt;num = num; p3-\u0026gt;score = score; if(p2-\u0026gt;next == NULL) { p2-\u0026gt;next = p3; p3-\u0026gt;next = NULL; } else { p3-\u0026gt;next = p2-\u0026gt;next; p2-\u0026gt;next = p3; } } else printf(\u0026#34;Can not find list index.\\n\u0026#34;); } return head; } ","date":"2021-11-17T12:00:49+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/15/","title":"資料結構 鍊錶程式碼"},{"content":" 該文章使用 Google 翻譯處理。\n該文章由 Hiyoung 編寫，翻譯自 yexca\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 //數組堆疊的實現 #include\u0026lt;stdio.h\u0026gt; #define MaxSize 50 typedef struct Stack_Array{ int data[MaxSize]; int top; }Sqstack,*pSqstack; void Initstack(); //初始化 int Isempty(); //判斷棧空 int Push(); //入堆疊 int Pop(); //出堆疊 int Gettop(); //get 堆疊頂元素 int main(void) //測試 { int val; Sqstack s1; pSqstack ps1=\u0026amp;s1; Initstack(\u0026amp;s1); //初始化 if(Isempty(\u0026amp;s1)) //判斷棧空 printf(\u0026#34;棧為空！\\n\u0026#34;); else printf(\u0026#34;棧不為空！\\n\u0026#34;); printf(\u0026#34;輸入壓棧元素的值\u0026#34;); //壓棧 1 scanf(\u0026#34;%d\u0026#34;,\u0026amp;val); Push (ps1,\u0026amp;val); printf(\u0026#34;輸入壓棧元素的值\u0026#34;); //壓棧 2 scanf(\u0026#34;%d\u0026#34;,\u0026amp;val); Push (ps1,\u0026amp;val); if(Isempty(ps1)) //判斷棧空 printf(\u0026#34;棧為空！\\n\u0026#34;); else printf(\u0026#34;棧不為空！\\n\u0026#34;); if(Gettop(ps1,\u0026amp;val)) //get 堆疊頂元素 printf(\u0026#34;棧頂值為%d\\n\u0026#34;,val); else printf(\u0026#34;棧頂元素查找失敗！\\n\u0026#34;); if(Pop(ps1,\u0026amp;val)) //出棧 printf(\u0026#34;出棧成功，出棧元素為%d\\n\u0026#34;,val); else printf(\u0026#34;出棧失敗！\\n\u0026#34;); return 0; } //初始化 void Initstack (pSqstack ps1) { ps1-\u0026gt;top=-1; return; } //判斷棧空 int Isempty(pSqstack ps1) { if(ps1-\u0026gt;top==-1) return 1; else return 0; } //若棧不滿，則進行壓棧 int Push(pSqstack ps1,int *val)//*val:接受一個地址(int *(\u0026amp;val)) { if(ps1-\u0026gt;top==MaxSize) return 0; else { ps1-\u0026gt;top++; ps1-\u0026gt;data[ps1-\u0026gt;top]=*val;//這裡傳遞的是值，這裡的*val是*(\u0026amp;val),\u0026amp;val是由主調函數輸入 //也可写作ps1-\u0026gt;data[++ps1-\u0026gt;top]=*val; 一定是++ps1-\u0026gt;top return 1; } } //若棧不空，則進行出棧，用val返回棧頂元素 int\tPop(pSqstack ps1,int *val) { if(Isempty(ps1)) return 0; else { *val=ps1-\u0026gt;data[ps1-\u0026gt;top--]; return 1; } } //get棧頂元素，用val返回棧頂元素 int Gettop(pSqstack ps1,int *val) { if(Isempty(ps1)) return 0; else { *val=ps1-\u0026gt;data[ps1-\u0026gt;top]; return 1; } } 圖解簡化\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 //棧的鍊式存儲實現 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #define Stack_Init_Size 10 // 初始化堆疊的最大長度 #define StackIncrement 10 // 若堆疊最大空間不夠時，需要增加的長度 typedef int ElemType; typedef int Status; typedef struct { ElemType *base; // 堆疊底部指針 ElemType *top; // 堆疊頂指針 int stack_size; // 堆疊的最大長度 } SqStack; // 初始化堆疊 Status InitStack(SqStack *S) { // 分配初始空間 S-\u0026gt;base = (ElemType *) malloc(Stack_Init_Size * sizeof(ElemType)); if (!S-\u0026gt;base) { exit(0); } S-\u0026gt;top = S-\u0026gt;base; /// 棧頂與棧底相同 S-\u0026gt;stack_size = Stack_Init_Size; // 堆疊的最大長度等於初始長度 return 1; } // 判斷棧是否為空，只需要判斷棧頂指標與棧底指標是否相同即可 Status EmptyStack(SqStack *S) { return S-\u0026gt;base == S-\u0026gt;top; } // 取得棧的實際長度，棧頂減去棧底指標即為棧的長度 Status LengthStack(SqStack *S) { if (S-\u0026gt;top == S-\u0026gt;base) { return 0; } return (Status) (S-\u0026gt;top - S-\u0026gt;base); } // 取得棧頂的元素，參數e用來存放棧頂的元素 Status GetTopStack(SqStack *S, ElemType *e) { if (S-\u0026gt;top == S-\u0026gt;base) { return 0; } *e = *(S-\u0026gt;top - 1); return 1; } // 進棧，參數e是要進棧的元素 Status PushStack(SqStack *S, ElemType e) { // 若棧的最大長度不會夠用時，重新開闢，增大長度 if (S-\u0026gt;top - S-\u0026gt;base \u0026gt;= S-\u0026gt;stack_size) { S-\u0026gt;base = (ElemType *)realloc(S-\u0026gt;base, (S-\u0026gt;stack_size + StackIncrement) * sizeof(ElemType)); if (!S-\u0026gt;base) { return 0; } // 棧頂指標為棧底指標加上堆疊之前的最大長度 S-\u0026gt;top = S-\u0026gt;base + S-\u0026gt;stack_size; // 堆疊目前的最大長度等於堆疊之前的最大長度與增加的長度總和 S-\u0026gt;stack_size += StackIncrement; } *S-\u0026gt;top++ = e; // 先賦值，後棧頂指標上移 return 1; } // 出棧，參數e用來存放出棧的元素 Status PopStack(SqStack *S, ElemType *e) { if (S-\u0026gt;base == S-\u0026gt;top) { return 0; } *e = *--S-\u0026gt;top; // 棧頂指標先下移，後賦值 return 1; } // 銷毀棧，釋放棧空間，棧頂棧底指標置為NULL，長度置為0 Status DestroyStack(SqStack *S) { free(S-\u0026gt;base); S-\u0026gt;base = S-\u0026gt;top = NULL; S-\u0026gt;stack_size = 0; return 1; } // 遍歷棧，依序列印每個元素 Status StackTraverse(SqStack *S) { ElemType *p; if (S-\u0026gt;top == S-\u0026gt;base) { printf(\u0026#34;Stack is NULL.\\n\u0026#34;); return 0; } p = S-\u0026gt;top; // 由棧頂依序向下遍歷 while (p \u0026gt; S-\u0026gt;base) { p--; printf(\u0026#34;%d \u0026#34;, *p); } printf(\u0026#34;\\n\u0026#34;); return 1; } int main() { SqStack q, *S; S = \u0026amp;q; int i, n, e; printf(\u0026#34;Creat a NULL Stack :\\n\u0026#34;); InitStack(S); printf(\u0026#34;input the length of the Stack :\\n\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (i = 1; i \u0026lt;= n; i++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;e); PushStack(S, e); } printf(\u0026#34;Is the stack NULL?\\n\u0026#34;); if (EmptyStack(S)) { printf(\u0026#34;Yes!\\n\u0026#34;); } else { printf(\u0026#34;No!\\n\u0026#34;); } printf(\u0026#34;The length of stack is %d.\\n\u0026#34;, LengthStack(S)); printf(\u0026#34;The stack is :\\n\u0026#34;); StackTraverse(S); e = GetTopStack(S, \u0026amp;e); printf(\u0026#34;The top data is %d.\\n\u0026#34;, e); printf(\u0026#34;input the data to the stack :\\n\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;e); PushStack(S, e); printf(\u0026#34;The new stack is :\\n\u0026#34;); StackTraverse(S); printf(\u0026#34;Delete the top data : \u0026#34;); e = PopStack(S, \u0026amp;e); printf(\u0026#34;%d\\n\u0026#34;, e); printf(\u0026#34;The new stack is :\\n\u0026#34;); StackTraverse(S); printf(\u0026#34;Destroy the stack :\\n\u0026#34;); DestroyStack(S); StackTraverse(S); return 0; } ","date":"2021-11-11T23:03:27+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/14/","title":"C 資料結構程式碼"},{"content":" 該文章由 ctxbb 編寫，因為是圖片，沒翻譯\n","date":"2021-11-11T18:01:33+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/13/","title":"揚州杏雨後"},{"content":" 該文章使用 Google 翻譯處理。\n雖然米忽悠的米遊社提供了原神樹脂的查看，但是使用電腦時每次查看還要打開手機然後打開米遊社著實有億點不方便\n原作者文章： 自己做了一個樹脂記錄軟件 原文軟件鏈接： 提取碼：1w5b 下載完成後打開，會提示輸入 uid 和 cookie，下面是如何抓取米遊社的 cookie\n首先打開 米遊社 並登錄\n然後按 F12 打開開發者工具，這時刷新網頁\n然後點擊“網絡-ys/”，找到請求標頭，然後在 cookie 右擊複製\n注意：需要的 cookie 字段為 account_id=xxx; cookie_token=xxx，請自行修改\n**2022-6-6 修改 ( hiyoung )**\n由於米哈遊修改了 bbs 可以獲取的 Cookie，導致一次獲取的 Cookie 缺失，所以需要增加步驟\n按下鍵盤上的 F12 或右鍵檢查,開啟開發者工具,點選 Console\n輸入\n1 var cookie=document.cookie;var ask=confirm(\u0026#39;Cookie:\u0026#39;+cookie+\u0026#39;\\n\\nDo you want to copy the cookie to the clipboard?\u0026#39;);if(ask==true){copy(cookie);msg=cookie}else{msg=\u0026#39;Cancel\u0026#39;} 回車執行，並在確認無誤後點擊確定。此時 Cookie 已經復製到你的粘貼板上了\n注意：請使用 Chrome，Edge 獲取也是不完整的 ( yexca )\n","date":"2021-11-10T15:21:30+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/12/","title":"原神樹脂查看與推送"},{"content":" 該文章使用 Google 翻譯處理。\n首先我們找到要下載的視頻 (廢話)，複製圖中框選部分的鏈接\n然後打開 視頻下載解析網站 ，輸入複製的鏈接然後點擊解析視頻圖片 (如需驗證根據網站提示進行即可)\n然後點擊下載視頻即可\n// 這篇好水\n","date":"2021-11-10T11:29:51+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/11/","title":"微博影片下載"},{"content":" 該文章使用 Google 翻譯處理。\n多數情況下，我們瀏覽網頁一般使用瀏覽器或系統自帶的返回，但有些系統的交互邏輯及其不好用，這時在網頁添加一個返回上一頁按鈕可以極大改善瀏覽體驗\n首先，在 WordPress 的後台點擊“外觀-自定義”來到可視化編輯頁面\n在左方找到“額外CSS”選項（一般在最後）\n然後在裡面輸入下方代碼\n1 2 3 4 5 6 7 8 .float-button { position: fixed; height: 90px; width: 40px; bottom: 90px; right: 50px; /* 可以自行修改相關描述 */ } 輸入完成後儲存，然後編輯主題相關介面\n如果您不能訪問服務器文件，可以在 WordPress 後台的“外觀-主題編輯器”中找到要添加的界面修改\n如果您可以存取伺服器文件，可以開啟路徑 網站根目錄/wp-content/themes/\u0026lt;您的主題名稱\u0026gt;/ 然後開啟相應頁面修改\n只需在相關頁面文件插入下面代碼並保存即可\n1 2 3 4 \u0026lt;div class=\u0026#34;float-button\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; name=\u0026#34;Submit\u0026#34; value=\u0026#34;返回\u0026#34; onclick=\u0026#34;javascript:history.back(-1);\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- 可以自行修改相關描述 --\u0026gt; 參考文章 網頁上的「返回上一頁」的幾種實作程式碼 div 套路之懸浮的 button ","date":"2021-11-10T11:06:27+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/10/","title":"WordPress 新增返回上一頁按鈕"},{"content":" 該文章使用 Google 翻譯處理。\n該文章由 Hiyoung 編寫，翻譯自 yexca\n準備條件：win11 專業版及以上，將系統地區調至美國\n在設置-\u0026gt;應用 -\u0026gt; 可選功能 -\u0026gt; 更多Windows功能中勾選虛擬機平台，然後重啟系統即可\n然後下載安裝包，鏈接: https://pan.baidu.com/s/1215GlKeDCHcbE0I2SgtWLg 提取碼: frkx\n下載完成後我們可以看到下面兩個文件：倒數第二個是安卓子系統安裝包，倒數第一個是WSA工具箱用於安裝 apk 文件\n最下面兩份文件\n現在我們以管理員身份打開 Windows power shell\n執行指令：add-appxpackage 空格 + 安卓子系統的文件路徑 (切記指令與路徑之間加一個空格)\n!Win11android_4 出現上面這個即說明安裝成功\n然後在開始選單即可看到安裝完成的安卓子系統，點擊運行，勾選上開發者模式\n解壓縮另一個 zip 檔案運行，即可安裝 apk 文件\n至此即安裝完成\n**********以下內容由 yexca 添加**********\n如果工具箱無法安裝或出現下圖情況，請打開子系統設置，打開第一個選項“文件”，再打開工具箱即可 獲取文件路徑 在文件上鼠標右擊選擇“屬性-安全”，第一行對象名稱即為文件路徑\nWSA 工具箱 原發布地址 ","date":"2021-11-09T23:45:42+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/9/","title":"Win11 官方安卓子系統安裝"},{"content":" 該文章使用 Google 翻譯處理。\n該文章由 Hiyoung 編寫，翻譯自 yexca\n1.SQL ORDER BY 關鍵字 ORDER BY 關鍵字用於對結果集按照一個列或者多個列進行排序。\nORDER BY 關鍵字默認按照升序對記錄進行排序。如果需要按照降序對記錄進行排序，您可以使用 DESC 關鍵字\nSQL ORDER BY 語法 1 2 3 SELECT *column\\_name*,*column\\_name* FROM *table\\_name* ORDER BY *column\\_name*1,*column\\_name*2 ASC|DESC; –ASC 表示升序，DESC 表示降序\n–使用 order by 語句時應放在所有語句的最後使用，並且排序多個列時先排 column\\_name1 再 column\\_name2…\n2.刪除所有數據（delete 和 drop table） 您可以在不刪除表的情況下，刪除表中所有的行。這表示表格結構、屬性、索引將保持不變：DELETE FROM table\\_name;\n或\nDELETE * FROM table\\_name;\n**註釋：**在刪除記錄時要格外小心！因為您不能重來！\nDROP TABLE 語句 DROP TABLE 語句用於刪除表。DROP TABLE table\\_name\n**註釋：**與 elete 不同的是 drop table 會刪除表數據和結果，也是不可逆的！\nDROP DATABASE 語句 DROP DATABASE 語句用於刪除數據庫。DROP DATABASE database\\_name\nTRUNCATE TABLE 語句 如果我們僅僅需要刪除表內的數據，但並不刪除表本身，那麼我們該如何做呢？\n請使用 TRUNCATE TABLE 語句：TRUNCATE TABLE table\\_name\n3.SQL join SQL join 用於把來自兩個或多個表的行結合起來。\n下圖展示了 LEFT JOIN、RIGHT JOIN、INNER JOIN、OUTER JOIN 相關的 7 種用法。\nINNER JOIN：如果表中有至少一個匹配，則返回行(INNER JOIN 與 JOIN 是相同的) LEFT JOIN：即使右表中沒有匹配，也從左表返回所有的行 RIGHT JOIN：即使左表中沒有匹配，也從右表返回所有的行 FULL JOIN：只要其中一個表中存在匹配，則返回行 註釋：SQL 中的 join 語句其實對應數據庫理論中的連接概念，left join、right join 和 inner join 對應自然連接，full join 對應笛卡爾積\n4.SQL 約束 (Constraints) 1 2 3 4 5 6 7 CREATE TABLE table_name ( column_name1 data_type(size) constraint_name, column_name2 data_type(size) constraint_name, column_name3 data_type(size) constraint_name, .... ); NOT NULL – 指示某列不能存儲 NULL 值。 UNIQUE – 保證某列的每行必須有唯一的值。（一個表可以有多個 UNIQUE 約束但只能有一個 primary key，primary key 自動包含 unique 約束） PRIMARY KEY – NOT NULL 和 UNIQUE 的結合。確保某列（或兩個列多個列的結合）有唯一標識，有助於更容易更快速地找到表中的一個特定的記錄。（主鍵） FOREIGN KEY – 保證一個表中的數據匹配另一個表中的值的參照完整性。（外鍵） CHECK – 保證列中的值符合指定的條件。 DEFAULT – 規定沒有給列賦值時的默認值。 5.AUTO INCREMENT 字段 我們通常希望在每次插入新記錄時，自動地創建主鍵字段的值。\n我們可以在表中創建一個 auto-increment 字段。\n下面的 SQL 語句把 “Persons” 表中的 “ID” 列定義為 auto-increment 主鍵字段：CREATE TABLE Persons\n1 2 3 4 5 6 7 ( ID int IDENTITY(1,1) PRIMARY KEY, LastName varchar(255) NOT NULL, FirstName varchar(255), Address varchar(255), City varchar(255) ) 在上面的實例中，IDENTITY 的開始值是 1，每條新記錄遞增 1。\n**提示：**要規定 “ID” 列以 10 起始且遞增 5，請把 identity 改為 IDENTITY(10,5)。\n要在 “Persons” 表中插入新記錄，我們不必為 “ID” 列規定值（會自動添加一個唯一的值）：\n1 2 INSERT INTO Persons (FirstName,LastName) VALUES (\u0026#39;Lars\u0026#39;,\u0026#39;Monsen\u0026#39;) 上面的 SQL 語句會在 “Persons” 表中插入一條新記錄。”ID” 列會被賦予一個唯一的值。”FirstName” 列會被設置為 “Lars”，”LastName” 列會被設置為 “Monsen”。\n6.觸發器 參見： SqlServer 基礎之(觸發器) – wangchuang2017 – 博客園 ","date":"2021-11-08T11:51:18+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/8/","title":"SQL 語句的一些語法細節 (SQL SERVER 語句)"},{"content":" 該文章使用 Google 翻譯處理。\n該文章由 Hiyoung 編寫，翻譯自 yexca\n在安裝完 SQL server 和 navicat 後在 navicat 中添加數據庫：\n1.連接名無要求，按照自己需要命名\n2.打開安裝好的 SQL server 配置管理器\n注意 SQL Server（SQLEXPRESS）要保證在運行中，否則 navicat 無法連接\n雙擊開啟後點選服務，可以看到自己的主機名\n3.此時打開 navicat 在主機的地方填上：主機名 \\SQLEXPRESS (格式)\n4.用戶名填 sa (為安裝 SQL server 時的預設用戶名，具體 SQL server 網路教學很多可以自己參考) ，密碼是自己設定的 (同樣在 SQL server 安裝時設定的密碼)\n5.測試連接成功即可使用\n注：僅個人在安裝過程中遇到的問題，具體安裝教程請參考網絡\n附上 navicat 15 及註冊機： https://pan.baidu.com/s/1cJ1EZ9Gyz6Jp6J03VqcDHA 提取碼：3n7g\n","date":"2021-11-07T23:41:46+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/7/","title":"關於在使用 navicat 連接 SQL server 的一些問題"},{"content":" 該文章使用 Google 翻譯處理。\n該文章由 Hiyoung 編寫，翻譯自 yexca\n其文章 (簡體中文): https://blog.hiyoung.icu/2022/12/15/997871bc263d/ 正文 VSC只是一個純文本編輯器，不是 IDE (集成開發環境)，不含編譯器和許多其它功能，所以編譯器要自己裝好\n第一步：在 vscode 官網下載軟件，鏈接： Visual Studio Code – Code Editing. Redefined 第二步：我們需要下載一個編譯器，C 語言使用 gcc，鏈接： MinGW-w64 – for 32 and 64 bit Windows download | SourceForge.net ，選最新版本中的 x86\\_64-posix-seh 即可，網站下載可能較慢，下面給出百度網盤鏈接\n（以下附上百度網盤秒傳鏈接：b48357234368d9ba439fc0db6e86531d#84cbf1dc60abe4fff77d035540ea3132#140697937#mingw64.zip）\n（正常百度網盤鏈接：鏈接: https://pan.baidu.com/s/17FYT\\_Y-s-I2yajFc2MICqw 提取碼: ewis ）\n第三步：將 E:\\mingw64\\bin 添加到系統變量中（盤符根據自己編譯器安裝的位置）\n以 Win11 為例：打開設置-\u0026gt;系統-\u0026gt;關於-\u0026gt;高級系統設置-\u0026gt;環境變量-\u0026gt;系統變量-\u0026gt;點擊Path-\u0026gt;編輯-\u0026gt; 瀏覽-\u0026gt; 把對應文件加入即可\n第四步：\n按 Win+R，運行 cmd（不要跳這一步），輸入 gcc，應該會提示 no input files 而不是“不是內部命令或外部命令”或者“無法將“gcc” 項識別為cmdlet、函數、腳本文件或可運行程序的名稱”。如果是“不是內部命令或外部命令”，說明 gcc 在的文件夾沒有在環境變量的Path中，要加進去才行。如果加了還是這樣，重啟（不要忘記重啟）。如果重啟了還不行，那就是你自己進行的操作有問題。\n輸 gcc -v 可以顯示出 gcc 的版本。如果顯示出來的版本與你剛下的不同/更老，說明 Path 裡原本有老版本的編譯器，可能是安裝其它 IDE 時裝上的。則需要去掉 Path 裡原來的那一個 gcc 的路徑。\n這兩項驗證一定要符合，否則必須修改環境變量。小心別錯刪了。\n第五步：現在打開 vscode，下載相關插件\n第六步：我們需要寫兩個 json 文件，下面依次是 launch.json 和tasks.json（兩個文件名也必須是launch.json 和tasks.json ） 注意看代碼註釋，兩個文件都有幾處地方需要將路徑改為自己編譯器的路徑\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 { // 使用 IntelliSense 了解相關屬性。 // 懸停以查看現有屬性的描述。 // 欲了解更多信息，請訪問: https://go.microsoft.com/fwlink/?linkid=830387 \u0026#34;version\u0026#34;: \u0026#34;0.2.0\u0026#34;, \u0026#34;configurations\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;gcc.exe - 生成和調試活動文件\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;cppdbg\u0026#34;, \u0026#34;request\u0026#34;: \u0026#34;launch\u0026#34;, \u0026#34;program\u0026#34;: \u0026#34;${fileDirname}\\\\bin\\\\$ {fileBasenameNoExtension}.exe\u0026#34;,//這裡意思生成的二進制代碼會放入當前文件的bin文件夾中，我們需要自己新建一個bin文件夾 \u0026#34;args\u0026#34;: [], \u0026#34;stopAtEntry\u0026#34;: false, \u0026#34;cwd\u0026#34;: \u0026#34;${fileDirname}\u0026#34;, \u0026#34;environment\u0026#34;: [], \u0026#34;externalConsole\u0026#34;: false, \u0026#34;MIMode\u0026#34;: \u0026#34;gdb\u0026#34;, \u0026#34;miDebuggerPath\u0026#34;: \u0026#34;E:\\\\mingw64\\\\bin\\\\gdb.exe\u0026#34;, \u0026#34;setupCommands\u0026#34;: [ { \u0026#34;description\u0026#34;: \u0026#34;為 gdb 啟用整齊打印\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;-enable-pretty-printing\u0026#34;, \u0026#34;ignoreFailures\u0026#34;: true } ], \u0026#34;preLaunchTask\u0026#34;: \u0026#34;C/C++: gcc.exe 生成活動文件\u0026#34; } ] } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 { \u0026#34;tasks\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;cppbuild\u0026#34;, \u0026#34;label\u0026#34;: \u0026#34;C/C++: gcc.exe 生成活動文件\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;E:\\\\mingw64\\\\bin\\\\gcc.exe\u0026#34;,//改成自己的檔案路徑 \u0026#34;args\u0026#34;: [ /*\u0026#34;${fileDirname}\\\\*.c\u0026#34;, \u0026#34;-o\u0026#34;, \u0026#34;${fileDirname}\\\\bin\\\\${fileBasenameNoExtension}.exe\u0026#34;, \u0026#34;-g\u0026#34;//多檔編譯*/ \u0026#34;-g\u0026#34;, \u0026#34;${file}\u0026#34;, \u0026#34;-o\u0026#34;, \u0026#34;${fileDirname}\\\\bin\\\\${fileBasenameNoExtension}.exe\u0026#34;//這裡意思產生的二進位程式碼會放入目前檔案的 bin 資料夾中，我們需要自己新建一個 bin 資料夾 ], \u0026#34;options\u0026#34;: { \u0026#34;cwd\u0026#34;: \u0026#34;${fileDirname}\u0026#34; }, \u0026#34;problemMatcher\u0026#34;: [ \u0026#34;$gcc\u0026#34; ], \u0026#34;group\u0026#34;: { \u0026#34;kind\u0026#34;: \u0026#34;build\u0026#34;, \u0026#34;isDefault\u0026#34;: true }, \u0026#34;presentation\u0026#34;: { \u0026#34;echo\u0026#34;: true, \u0026#34;reveal\u0026#34;: \u0026#34;always\u0026#34;, // 執行任務時是否跳到終端面板，可以為 always，silent，never。具體參見 VSC 的文檔 \u0026#34;focus\u0026#34;: true, // 設為 true 後可以使執行 task 時焦點聚集在終端，但對編譯 C/C++ 來說，設為 true 沒有意義 \u0026#34;panel\u0026#34;: \u0026#34;shared\u0026#34; // 不同的檔案的編譯資訊共享一個終端面板 }, \u0026#34;detail\u0026#34;: \u0026#34;調試器生成的任務。\u0026#34; }, { \u0026#34;type\u0026#34;: \u0026#34;cppbuild\u0026#34;, \u0026#34;label\u0026#34;: \u0026#34;(多文件)gcc.exe - 生成和調試活動文件\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;E:\\\\mingw64\\\\bin\\\\gcc.exe\u0026#34;,//改成自己的檔案路徑 \u0026#34;args\u0026#34;: [ \u0026#34;${fileDirname}\\\\*.c\u0026#34;, \u0026#34;-o\u0026#34;, \u0026#34;${fileDirname}\\\\bin\\\\${fileBasenameNoExtension}.exe\u0026#34;,//這裡意思產生的二進位程式碼會放入目前檔案的 bin 資料夾中，我們需要自己新建一個 bin 資料夾 \u0026#34;-g\u0026#34; ], \u0026#34;options\u0026#34;: { \u0026#34;cwd\u0026#34;: \u0026#34;${fileDirname}\u0026#34; }, \u0026#34;problemMatcher\u0026#34;: [ \u0026#34;$gcc\u0026#34; ], \u0026#34;group\u0026#34;: { \u0026#34;kind\u0026#34;: \u0026#34;build\u0026#34;, \u0026#34;isDefault\u0026#34;: true }, \u0026#34;presentation\u0026#34;: { \u0026#34;echo\u0026#34;: true, \u0026#34;reveal\u0026#34;: \u0026#34;always\u0026#34;, // 執行任務時是否跳到終端面板，可以為 always，silent，never。具體參見 VSC 的文檔 \u0026#34;focus\u0026#34;: true, // 設為 true 後可以使執行 task 時焦點聚集在終端，但對編譯 C/C++ 來說，設為 true 沒有意義 \u0026#34;panel\u0026#34;: \u0026#34;shared\u0026#34; // 不同的檔案的編譯資訊共享一個終端面板 }, \u0026#34;detail\u0026#34;: \u0026#34;調試器生成的任務。\u0026#34; } ], \u0026#34;version\u0026#34;: \u0026#34;2.0.0\u0026#34; } 至此設置工作基本結束，vscode 有許多好用的插件可以自己探索，未來也會在寫一篇文章推荐一些好用的插件\n","date":"2021-11-07T23:32:26+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/6/","title":"VsCode 配置 C 語言環境"},{"content":" 該文章使用 Google 翻譯處理。\n正文 安裝完成 VS Code 和 Python 並配置環境變量後\n開啟 VS Code，進入拓展搜尋並下載 Python\n在資源管理器新建一個 Python 原始檔 (.py) 後，資源管理器會在.vscode 資料夾下產生 setting.json 檔案（若沒有自動產生可自行建立）\n開啟 setting.json 文件，並替換為以下程式碼\n1 2 3 4 5 6 { \u0026#34;python.linting.flake8Enabled\u0026#34;: true, \u0026#34;python.linting.flake8Args\u0026#34;: [\u0026#34;--max-line-length=248\u0026#34;], \u0026#34;python.linting.pylintEnabled\u0026#34;: false } 此時回到 python 文件，VS Code 右下會彈出警告，點擊下載\n按 CTRL+SHIFT+P 鍵，輸入 Python: Select Interpreter (即 Python：選擇編譯器)\n然後選擇您下載的編譯器即可\n如果 .vscode 資料夾下有 launch.json 文件，需要在該文件的 configurations 中加入以下程式碼\n1 2 3 4 5 6 7 { \u0026#34;name\u0026#34;: \u0026#34;Python: 目前文件\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;python\u0026#34;, \u0026#34;request\u0026#34;: \u0026#34;launch\u0026#34;, \u0026#34;program\u0026#34;: \u0026#34;${file}\u0026#34;, \u0026#34;console\u0026#34;: \u0026#34;integratedTerminal\u0026#34; } 參考文章 VsCode 配置 Python 環境小白教程 VSCode 配置 Python 教程 ","date":"2021-11-07T11:28:58+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/5/","title":"VsCode 配置 Python 環境"},{"content":" 該文章使用 Google 翻譯處理。\n該文章由 Hiyoung 編寫\nmailto：可以自動調用當前系統默認的郵件客戶端，並自動填充收件人、抄送人、密送人、主題、內容。\n參數說明:\nmailto： 收件人，多個以;分隔\ncc： 抄送人，多個以;分隔\nbcc： 密送人，多以;分隔\nsubject： 主題\nbody： 內容\n各參數間用\u0026amp;連接即可\n例如：\u0026lt;a mailto:***@***.com?subject=this is subject\u0026amp;body=this is body\u0026gt;…\u0026lt;a\u0026gt;\n注：在 elementor 中應在文本編輯器的超鏈接選項中直接填寫 mailto:***@***.com?subject=this is subject\u0026amp;body=this is body 即可\n","date":"2021-11-06T17:05:36+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/4/","title":"如何自動呼叫目前系統預設的郵件用戶端"},{"content":" 該文章使用 Google 翻譯處理。\n正文 首先到待嵌入的視頻將鼠標移到分享按鈕上（不用點擊）\n然後移到嵌入代碼並複制\n（本例代碼如下）\n1 \u0026lt;iframe src=\u0026#34;//player.bilibili.com/player.html?aid=583631611\u0026amp;bvid=BV1Tz4y1X7Bg\u0026amp;cid=206708397\u0026amp;page=1\u0026#34; scrolling=\u0026#34;no\u0026#34; border=\u0026#34;0\u0026#34; frameborder=\u0026#34;no\u0026#34; framespacing=\u0026#34;0\u0026#34; allowfullscreen=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;/iframe\u0026gt; 我們需要這串程式碼中的「aid」和「cid」部分（即 aid=583631611 和 cid=206708397 ）\n然後將 aid 和 cid 填入下方代碼的對應位置\n1 2 3 \u0026lt;div style=\u0026#34;position: relative; padding: 30% 45%;\u0026#34;\u0026gt; \u0026lt;iframe style=\u0026#34;position: absolute; width: 100%; height: 100%; left: 0; top: 0;\u0026#34; src=\u0026#34;https://player.bilibili.com/player.html?cid=206708397\u0026amp;aid=583631611\u0026amp;page=1\u0026amp;as_wide=1\u0026amp;high_quality=1\u0026amp;danmaku=0\u0026#34; frameborder=\u0026#34;no\u0026#34; scrolling=\u0026#34;no\u0026#34;\u0026gt;\u0026lt;/iframe\u0026gt; \u0026lt;/div\u0026gt; （以上代碼中 aid 和 cid 已替換）\n在寫文章的過程若插入影片只需將區塊設為「自訂 HTML」然後把替換好aid和cid的程式碼拷貝過去即可\n如下為示例視頻\n參考文章 關於博客園內嵌入 bilibili 視頻 ","date":"2021-11-06T16:43:20+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/3/","title":"WordPress 嵌入 BiLiBiLi 影片說明"},{"content":" 該文章使用 Google 翻譯處理。\n預設情況下，WordPress 允許作者查看您網站媒體庫中的所有圖像。允許作者查看媒體庫中的所有檔案。 他們還可以查看由管理員 ， 編輯或其他作者上傳的圖像。\n對於許多網站而言，這可能並不重要。 但是，如果您運行一個多作者網站 ，則可能需要更改它。\n首先，進入 網站根目錄/wp-content/themes/您目前使用的主題名稱/\n找到 functions.php 檔案並編輯，在末尾插入如下程式碼即可\n1 2 3 4 5 6 7 8 9 10 11 12 // Limit media library access add_filter( \u0026#39;ajax_query_attachments_args\u0026#39;, \u0026#39;wpb_show_current_user_attachments\u0026#39; ); function wpb_show_current_user_attachments( $query ) { $user_id = get_current_user_id(); if ( $user_id \u0026amp;\u0026amp; !current_user_can(\u0026#39;activate_plugins\u0026#39;) \u0026amp;\u0026amp; !current_user_can(\u0026#39;edit_others_posts \u0026#39;) ) { $query[\u0026#39;author\u0026#39;] = $user_id; } return $query; } 參考文章 如何限制媒體庫對 WordPress 中使用者自己上傳的內容的訪問 ","date":"2021-11-06T14:31:04+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/2/","title":"WordPress 限制使用者存取媒體庫"},{"content":" 該文章使用 Google 翻譯處理。\n歡迎使用 WordPress。這是您的第一篇文章。編輯或刪除它，然後開始寫作吧！\n","date":"2021-11-06T14:15:19+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/1/","title":"Hello World！"}]