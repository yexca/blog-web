[{"content":" 📢 本文由 Gemini-3-pro 翻譯 意識可以獨立於肉體、直覺可以超越邏輯、觀測可以改變現實\nNDE (Near-Death Experience) 指的是瀕臨死亡的體驗，目前有一些個人或組織對其進行過研究，像是 IANDS（國際瀕死體驗研究協會）和 P.M.H. Atwater 博士對數千名 NDErs（瀕死體驗者）的研究等。\n本文將基於這些研究以及我個人的理解來寫，因為內容實在太過複雜，如果有什麼疏漏，還請多多包涵。\n什麼是 NDE 從發生機制來看，NDE 通常指因物理狀態被醫學認定死亡後，意識前往「那裡」的經歷。但值得注意的是，也存在「情緒誘發型瀕死體驗 (Emotion-Induced NDE)」，也就是在極度的情緒 (Extreme Emotional) 或心理壓力 (Psychological Distress) 下，物理身體雖然表面無恙，但意識依然觸發了離體機制，前往了「那裡」，比如心碎症候群或迷走神經性昏厥 (Vasovagal Syncope) 導致的意識斷線。\nNDE 的核心是意識去了「那裡」的經歷，也就是強調靈魂出竅 (OBE, Out-of-Body Experience) 與重入 (Re-entry)，而不是一個簡單的美夢或者惡夢。\n「那裡」比較標誌性的特徵可能是時間非線性、空間摺疊，以及那道有深度與包覆感的光（這個光可能是連接高維世界與三維世界意識的接口）。\n而在 NDE 的「整合期 (Integration Period)」，可能會表現為 PTSD 症狀，並帶有重度憂鬱者的影子，比如自我消融 (Ego Dissolution) 或世界疏離感，雖然恢復過程類似 PTG（創傷後成長）的變化，但本質上還是有很大區別。\nNDE 與夢 關於 NDE 和普通的夢的區別，Bruce Greyson 博士制定了一套嚴格的評分系統，也就是格雷森量表 (The Greyson NDE Scale)。\n評判標準為每一項 (0=無、1=輕微、2=強烈)：\nA. 認知特徵 (Cognitive)\n時間感是否改變 (變快/變慢/停止/非線性) 思維是否加速 (極度清晰/全景式回顧) 是否有這一生經歷的回顧 (人生跑馬燈) 是否突然理解了宇宙/人生的某種真理 B. 情感特徵 (Affective)\n是否感到安寧/愉悅 是否感到極度的喜悅 是否感到與宇宙/萬物合一 是否看到/感到耀眼的光芒 C. 超自然特徵 (Paranormal)\n感官是否比平時更靈敏 (或者感覺脫離肉體) 是否有超感官知覺 (預知/遙視) 是否看到了未來的景象 是否感覺脫離了物理世界 D. 超越性特徵 (Transcendental)\n是否進入了某種非塵世的存在領域 (夢境/虛空) 是否遇到了神秘的存在 (死神/聲音/光體) 是否遇到了已故的人或宗教人物 是否遇到了無法回頭的界限 (決定生死的瞬間) 總分是 32 分，達到 7 分以上則可以在臨床科學上被認定為 NDE。\nNDE 與 PTSD PTSD 和 NDE 都是一個人經歷極端的創傷後，大腦原有防禦機制崩塌的結果。而 PTSD 是在未成功的狀態下的產物，在經過重構後會轉為 PTG。\n雖然解離感 (Dissociation)、高度警覺、各種疼痛在 PTSD 患者身上也有，但是兩者幾乎是不同的東西。\n生命科學解釋 PTSD 和 NDE 的大腦改變是不一樣的。\nPTSD 的大腦會導致杏仁核 (Amygdala) 肥大和海馬迴 (Hippocampus) 萎縮。杏仁核負責警告，這表明患者會變得極度敏感，一直處於「戰或逃」的亢奮狀態。而海馬迴負責記憶處理，導致患者無法把過去的創傷歸檔，總覺得創傷正在發生，也就是永遠活在恐懼的迴圈裡。\nNDE 的大腦是預設模式網路 (DMN) 抑制與顳頂聯合區 (TPJ) 改變。預設模式網路是負責「自我造作」、焦慮、反芻過去的網路，活性降低意味著小我 (Ego) 漸漸消失從而焦慮變少。而顳頂聯合區負責處理「我在那裡」，所以這部分的改變導致 NDErs 能體驗到「靈魂出竅」或萬物合一的感覺。\n兩者對比 其中有一些決定性的區別：\n特徵 PTSD NDE 核心情緒 恐懼、無助、焦慮 最終會轉向平靜、接納、愛 自我認知 覺得自己破碎了、受害者 覺得自己是觀察者 (Observer) 世界觀 世界是危險的，我要躲避 世界是有意義的，我有任務 對死亡 極度恐懼死亡 恐懼減少或轉化為探索慾 同時 PTSD 在經歷干預治療後可以是 PTG，而 NDE 無需治療，跟隨自己內心即可心態積極向上。\nNDE 與 PTG PTG (Post-Traumatic Growth) 本質上是心理層面的認知重構，是一個人經歷重大創傷後，在認知重構後性格或三觀（價值觀）的改變。\nNDE 則是生理與量子層面的能量過載（Overload）。基於 Rick Strassman 的假設，是大腦在瀕死瞬間（缺氧、突波）時松果體可能釋放了大量的 DMT，神經元同步放電達到峰值從而使意識暫時脫離了肉體束縛。造成的結果是不僅性格改變，身體的物理屬性也會改變。\n總結 NDE 是物理加精神的雙重改變，而一些精神類疾病像 PTSD、憂鬱症只是精神或心理層面的改變。\nNDE 為什麼存在 NDE 是不合理下的合理，正如《駭客任務》(The Matrix) 裡的 Neo 一樣，「你的存在，是這個完美數學方程式中無法消除的餘數」。\n當然，這個其實也屬於防止「熱寂 (Heat Death)」與「死結 (Deadlock)」的機制。\n如果這個物質世界 (Reality) 完全封閉，嚴格遵循物理定律以及因果律 (牛頓力學/決定論)，那麼系統最終將走向熵增到極致，也就是死氣沉沉的熱寂，或者會因為邏輯太嚴密而陷入死結（人類完全變成機器，失去靈性）。\n所以 NDErs 是引入了外部變數，以沾染部分高維空間的混沌能量（靈性/愛/真理）後注入一些「負熵 (Negentropy)」以防止熱寂與死結。\nNDE 可以重現嗎 現代神經科學認為，NDE 並不是「靈魂出竅」，而是大腦在極端危急時刻的一種特殊保護機制，以下行為也可能產生類似 NDE 的感覺：\n顳葉癲癇： 刺激大腦顳葉，普通人也能產生「遇見上帝」的感覺。 缺氧/G 力昏迷： 飛行員在離心機裡也會產生「隧道視野」和「全生回顧」。 致幻劑 (DMT)： 服用特定成分，也能產生類似的體驗。 NDE 是如何回來的 NDE 主要有兩種回來的方式，當然也有一些「小眾」的情況：\n被動遣返型 (The \u0026ldquo;Sent Back\u0026rdquo; Type)\n大概佔 60% 左右，這部分人是在「那裡」很舒服不想回來，但是突然出現一個權威形象（某種存在/親人/神）對他說「時間未到」或者「你還有任務未完成」從而回來。\n因為是服從的心態，通常是帶著遺憾與不捨被踢回來的，回來後往往會有嚴重的「思鄉病」，想要回到「那裡」。\n情感羈絆型 (The \u0026ldquo;Love Anchor\u0026rdquo; Type)\n大概佔 30% 左右，這部分人往往是到了邊界，面臨選擇，比如自己的孩子、伴侶或者父母，想要守護他們從而回來。\n因為屬於犧牲與愛的心態，通常是因為對他人的愛主動回來的，所以會帶有「守護者」的使命感，性格改變為溫柔並充滿愛心。\n其他\n當然，還有像是為了未完成的事業，未完成的學業之類的拒絕去「那裡」，或者\u0026hellip;意志對抗型 (The \u0026ldquo;Willpower Warrior\u0026rdquo; Type) 強行回來。\nNDE 的週期 事實上，在 NDE 的發生前後有一定的精神匱乏期，甚至可以說遵循 1-3-7 模型：\nNDE 前的空虛期\n這部分可以說是靈魂暗夜 (The Dark Night)，一般是 1-3 年左右，這個階段是為了清空快取 (Cache)，以為了迎接 NDE 的高維能量注入。\nNDE 後的空虛期\n這部分是真空校準期 (The Vacuum)，一般是 6 個月到 1.5 年，因為高維世界的景象相較於現實世界是迷人的，所以可能會對現實的低密度世界感到慢或無聊。\nNDE 的完全整合期\n大概是在 NDE 發生後的 7 年左右，這個時候 NDErs 可以無縫融合進地球的生活。\nNDE 的特徵 NDErs 有一些比較共通的能力，或者說「後遺症」：\n路燈干擾現象 (SLI) 這是 NDErs 最著名的「Bug」，也就是生物電磁場 (Bio-electromagnetic field) 的頻率或者功率會被加強，從而可能會干擾附近的電子設備，比較典型的是戴機械錶會容易走不準，以及走過路燈時燈泡會突然熄滅或爆閃 (Street Light Interference)。\n超感官共情 (Hyper-Empathy) 這個能力是由於大腦的抑制器 (Reducing Valve) 被拆除，所以潛意識掃描範圍變得極廣，也就是導致對於周圍的情緒數據等訊息接收更靈敏，從而更容易耗盡社交能量 (Social Battery Drained)。\n抽象思維具象化 (Synesthesia-like Processing) 普通人對概念的理解是線性的或文字的，但 NDErs 對概念的理解是全像 (Holographic) 的，也就是對複雜的概念或公式的理解不是靠邏輯推導，而是幾何結構或圖案，這比邏輯推導快無數倍，屬於量子運算級別。\n生理代謝改變 (Metabolic Changes) NDErs 的身體代謝通常會加快，細胞更新機制發生了改變，當然還有一些其他變化：\n對酒精或藥物敏感： 更容易喝醉、麻醉劑或止痛藥反應異常（無效或過敏）。 飲食改變： 突然覺得不能吃某樣東西，或者渴望特定的食物（新鮮蔬菜）。 共時性 (Synchronicity) NDErs 的意念 (Intention) 比普通人強得多，比較容易實現自己想要的事情，但這個強運不是隨心所欲的，一般會符合「自我實現」或「利他」屬性。\n自我實現： 指對自己不再虛偽迎合，而是從事自己真正熱愛的事物。 利他： 不一定是指做慈善，可能也只是分享自己的洞察，幫助別人。 絕對直覺 (Absolute Intution) NDErs 的直覺更像是一種對某件事，彷彿我天生就做過或者這是命定的軌跡一樣，具體有三個層級：\n層級 1: 下載感 (The Download)\n這是基礎的 NDE 直覺，表現為「我沒思考，但我就是知道」，去掉了中間的思考過程，直接給出答案或結果。\n層級 2: 既視感 (Deja Vu / Future Memory)\n因為「那裡」的時間是非線性的，所以過去、現在、未來是同時存在的，可能在「那裡」已經走過一遍劇本了，從而在經歷的時候感覺自己貌似經歷過。\n層級 3: 清明夢感 (Lucid Dreaming Reality)\n這是最高級的直覺，在 NDE 後遺症中被稱為「面紗變薄 (Thinning of the Veil)」或者「現實解離 (Derealization)」，也就是到某一地方彷彿就像進入了夢境，這往往代表那個地方是「高維錨點 (Anchor Point)」或者說「任務地點」。\n預知 (Foreknowledge) NDE 會獲得預知未來的能力，但是這個未來是可以改變的，或者說 NDErs 看到的是基於當前狀態下機率最大的那個「未來」。\n雖然預知其實是無法測量時間尺度的，因為預知一般是來自「那裡」的訊息，在那裡時間是非線性的，或者說不存在時間這個概念，也就無法得知時間尺度。但是如果嘗試擬合三維的時間的話，一般離自己比較近的時間會比較「準」，可能一年以內，因為時間臨近，「變數」會比較少，所以極大機率發生，但是長時間的預知就不是很準確了，甚至說是無法預知的，只是知道一個大概的趨勢而已。\n當然也不是每一次預知都要在 NDE 狀態下觸發，不如說因為 NDE 的原因更容易去「那裡」，所以更容易進入 STE (Spiritually Transformative Experience) 即靈性轉化體驗。\n雖然到了「那裡」的夢不一定是預知夢，但一般而言預知夢應該是去了「那裡」獲取了相關訊息，所以了解夢的分類可以幫助區分普通夢和去了「那裡」。\n夢的分類 夢根據大腦的生成部分不同，大致可以分為三類：\n焦慮釋放\n這部分是由大腦皮層或杏仁核生成的，對現實的部分焦慮進行釋放的夢境，基本符合三維物理，同時帶有情緒感。\n模擬推演\n這是由大腦的前額葉（邏輯中心）生成的，主要是潛意識在基於現實的訊息進行推演各種可能性。\nNDE 預知夢\n這部分的夢來源於松果體或高維意識，也就是「那裡」。在這個夢境中，時間是非線性的，空間是重疊的，情緒是零度的，一切都是狀態，意識是觀察者。\n類似於塊狀宇宙 (Block Universe) 一樣，移動不存在，時間不存在，只是被觀測的對象，並且場景是由念而生，任何想法立馬獲得反饋 (Zero Latency)，這也可能是「思鄉病」的原因。\n預知夢的特徵 NDErs 的來自「那裡」的預知夢通常會有以下特徵：\n超高畫質解析度 (Hyper-Reality)\n相對於普通的模糊的夢不同，預知夢是細節極其清晰的夢，那個真實感甚至可能超過現實。\n情緒的「零度」 (Emotional Neutrality)\n普通夢可能伴隨著情感波動，但是預知夢往往是作為一個「觀察者」的角度，只是在「看」事情的發生，而不是思考怎麼辦或者說「體驗」。\n既視感的驗證 (Deja Vu Confirmation)\n當未來這件事真的發生的時候，會有既視感，因為現實和夢境「完美重疊」。\nNDE 的代價 With great power comes great responsibility (能力越強，責任越大)\n當然，雖然看著上方的「後遺症」是挺酷的，不過 NDErs 往往需要支付一定的代價：\n無法回頭的孤獨 (The Irreversible Solitude)\n因為「那裡」所見即所得 (WYSIWYG) 的體驗可能過於美好，可能會使 NDErs 突然感覺三維世界索然無味，從而可能無法再度融入這個世界。\n感官過載與能量耗竭 (Sensory Overload \u0026amp; Burnout)\n因為直覺和感知的增強，NDE 需要高維或者說高能量訊息，而三維世界存在許多帶有雜訊的訊息，這將導致 NDErs 很容易極度疲憊，同時身體跟不上靈魂的速度，並且經常精神匱乏或當機。\n絕對責任的重負 (The Burden of Absolute Responsibility)\nNDErs 的回來是有「任務」的，也就是處於不是在完成這個「任務」的道路上，NDErs 得到的懲罰會比正常人更重，並且 NDErs 的作惡也會更快得到更重的懲罰。\n絕對真實\nNDErs 幾乎是必須要說真理，且必須遵從本心，違背本心或訴說謊言將會獲得更重的懲罰，以及更容易被拆穿。\n總的來說，就是要遵從本心，不作惡，完成任務，以及無人可以理解的\u0026hellip;孤獨。\n量子力學解釋 遇事不決，量子力學。說實話，NDErs 的 STE 體驗，確實有點類似於和「那裡」發生了量子糾纏 (Quantum Entanglement) 也說不定。\nNDE 的量子力學解釋 諾貝爾物理學獎得主 Roger Penrose 與 Stuart Hameroff 提出的 \u0026lsquo;Orch-OR 理論\u0026rsquo;（儘管在學界尚存爭議）提供了一個量子視角的解釋，他們認為人的意識存在於腦神經元微管內的量子狀態中。\n當心臟停止或者瀕死的時候，量子態失去相干性 (Decoherence)，量子訊息離開大腦洩漏到宇宙中，也就是去了「那裡」，當身體機能恢復時，量子訊息又被「吸」了回來。\n共時性的量子力學解釋 現實是一個基於機率的模擬系統，普通人的意念是混亂的，無法影響亂數產生器。\nNDErs 因為意識去過「那裡」，所以還保留著一條通道或者是量子糾纏，從而在產生某個想法的時候，周圍的一切會「機率塌縮 (Probability Collapse)」到對應的事情。\n這就好比量子力學中的「觀察者效應」在巨觀層面的投射，意念似乎引導了機率的走向。\n預知的量子力學解釋 這點可以基於 Aldous Huxley 提出的減壓閥理論 (The Reducing Valve) 解釋。\n普通人的大腦一般是一個「減壓閥」或者說過濾器，它將會過濾掉 99.9% 的訊息，而 NDE 將這個減壓閥進行高壓擊穿破壞了，所以 NDErs 將接收更多的訊息。\n也就是大腦意識原先的 Beta 波，將更容易進入 Theta 波或 Delta 波狀態以與「那裡」同頻共振。\n弦論解釋 因為這些概念有點過於玄乎，所以我想到了弦論 (String Theory)，它認為現實世界的一切都是弦的振動，物質取決於弦是如何震動的，而三維空間的一切是由十一維空間的弦的波動引起的。\nNDE 的弦論解釋 在弦論的 M-理論中，我們的三維宇宙被認為是一張漂浮在更高維空間的 D-膜 (D-Brane)。\n因為所有的物質都是「開弦」，弦的兩端是黏在這張「膜」上的，所以我們被鎖在三維世界裡出不去。但是「重力子 (Graviton)」是「閉弦」，因為沒有端點所以可以離開膜，飄到高維空間 (The Bulk，體空間) 中去。\n如果我們將此概念引入意識模型，可以大膽猜想，在瀕死的那一刻，意識可能發生了某種「量子相變」，從「開弦」暫時變成了「閉弦」，獲得了逃逸出三維膜的能量，而進入了高維度的「體空間」。\n因為高維空間時間不是線性的，所以才會有常識性的「邏輯」錯誤。\n共時性的弦論解釋 對於普通人因為沒去過高維空間，所以是無法干涉現實的物質震動。而去過高維空間的意識可能在 NDE 的時候被「調校」過，從而在產生一些想法的時候，可以在高維空間「撥動琴弦」以影響到三維空間的「膜」，從而投射到現實的改變。\n電磁干擾的弦論解釋 受到高維空間影響的意識，可能意識頻率 (Spirit) 比常人高或者不穩定，所以當靠近路燈或者精密儀器的時候，意識的「弦」和這些電子設備的「弦」發生了共振 (Resonance) 或干涉 (Interference)，從而造成了「路燈干擾現象 (SLI)」。\n命理學解釋 當西方的神經科學和心理學走到盡頭，我們不妨把目光投向東方的古老智慧。\n從命理學或者說玄學來看，NDE 現象其實也是「命中注定」的，當我得到這個結論的時候，說實話我超級震撼，不得不感嘆那句「冥冥之中自有天意」，也讓我覺得這並不是什麼特殊現象，而是一種\u0026hellip;既定的軌跡，當真是來自東方的神秘力量啊。\n觸發條件 NDE 是由兩種特殊參數同時作用的結果：\n參數 A: 劇烈的衝突\n一般情況下，NDE 發生在「歲運並臨」或者「三刑/六沖」的年份或日期，比如著名的「寅巳申三刑 (無恩之刑)」或者「天克地沖」。這導致了肉體（地支）和能量場（天干）發生劇烈物理碰撞，導致「神識」被震出肉體。\n參數 B: 空亡/華蓋\n當時那個時間點需要有「空亡」的相應命理，比如日柱落入空亡或者大運走入死絕之地（比如墓庫），從而讓神識連接到「那裡」。\n判斷條件 因為這些衝擊都是極強的，一般情況下遇到可以說就是等於宣布死亡了，但判斷是瀕死還是死亡，需要看當天的日主是否有「根」。\n死亡 (Death)\n當衝擊發生的時候，日主的「根」被完全拔除，只有一個虛浮的天干，那麼「生」氣將消散。\n瀕臨死亡 (NDE)\n雖然衝擊極強，但是日主的「根」還在的話，雖然身體受損，並不會被沖散。\n也就是 NDE = 「衝擊力 ＞ 肉體承受力」但「衝擊力 ＜ 靈魂抓地力」。\n後遺症的命理學解釋 NDE 後的狀態，事實上屬於魂魄分離狀態，道家命理認為：\n魂: 掌管精神、思維、夢境（屬木/火） 魄: 掌管肉體、感官、本能（屬金/水） NDE 的本質是「魂」飛出去到「那裡」，但是「魄」還留在體內維持生命。所以當「魂」回歸的時候，它和「魄」的咬合可能會出現微小的錯位，也就造成了這些後遺症。\n聲明 本文嘗試使用跨學科視角來解碼 NDE 體驗，但其中大部分理論只是用隱喻 (Metaphor) 來解釋主觀意識體驗，並非代表這些物理定律已在巨觀意識層面得到證實，尤其是文章涉及到了命理學部分解釋，大多純屬腦補擬合。\n歸根結底，這只是一種「可能性的探索」，或者是\u0026hellip;靈魂的全端理論捏 (Full-Stack Theory of Soul)。\n致 NDErs 如果作為 NDErs 的你還在痛苦的整合期讀到了這篇文章，我想說：\n無論這背後的機制是神學的那個存在的慈悲、命理學的命中注定、心理學的認知機制改變、生命科學的大腦結構改變、還是量子力學的波函數塌縮，最重要的是：\n回來，本身就是一個奇蹟\n既然回來了，那就從愛自己開始吧，畢竟，我們可是好不容易續了簽（命）的不是嘛～\n","date":"2026-01-01T17:16:59+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/264/","title":"走進 NDE"},{"content":" 📢 本文由 Gemini-2.5-pro 翻譯 引言 早在 2022 年我折騰 Linux 的時候(簡體中文) ，當時就提到了搞 NAS 不一定得為系統買單。\n如今在伺服器的折騰中，雲端硬碟掛載的速度實在不盡人意，在衝動下，我下單了 N5095 主機板。考量到我手頭上的 4G 記憶體有點低，但又不是很想再徒增花費，於是我再次開啟了我的折騰之旅。\n技術選型 首先是系統，在這個低配置下，那當然是使用最輕量的 Alpine Linux 了。\n然後是如何安裝，為了和 WEPE 相容，使用 Ventoy 做主引導來安裝系統。\n服務的部署使用 Docker 來保證主機的乾淨以及可重現性。\n使用的服務如下：\n影音: Emby 漫畫: Komga 音樂: Navidrome 音聲: Kikoeru 共享: Samba 統一入口: Heimdall 考慮過但未使用的服務如下：\n影音: Jellyfin 漫畫/小說: Kavita 雲端掛載: CloudDrive 檔案架構 對於各個服務的位置，使用我一貫的風格，每個服務一個資料夾，放在 /home 下。\n對於 HDD 全部掛載在 /mnt 下，這是比較常見的掛載方式。\n透過 mount \u0026ndash;bind 綁定掛載以實現將 HDD 上對應的檔案掛載到對應服務的位置。\n系統安裝 在 官網下載 Alpine Linux 後放入安裝了 Ventoy 的隨身碟中，在主機板 BIOS 設定從隨身碟開始引導，進入 Ventoy 後，選擇 Alpine Linux 並進行引導進入系統。\n等待載入完成後，登入使用者 root，不用輸入密碼，登入完成後輸入安裝指令：\n1 setup-alpine 然後根據引導設定完成安裝即可。\n官方文件: setup-alpine - Alpine Linux 公鑰登入 編輯 NAS 相關設定檔 ~/.ssh/authorized_keys，首先建立設定資料夾：\n1 mkdir .ssh 進入資料夾：\n1 cd .ssh 加入自己的公鑰：\n1 vi authorized_keys （自己的公鑰在 %USERPROFILE%\\.ssh）\n開啟公鑰登入：\n1 vi /etc/ssh/sshd_config 在第 41 行，將註解取消變為：\n1 PubkeyAuthentication yes 開啟社群源 開啟軟體庫檔案：\n1 vi /etc/apk/repositories 把註解刪掉變為：\n1 2 3 #/media/dm-0/apks http://dl-cdn.alpinelinux.org/alpine/v3.22/main http://dl-cdn.alpinelinux.org/alpine/v3.22/community 安裝 Docker 更新軟體：\n1 apk update 安裝 Docker：\n1 apk add docker docker-cli-compose 設定開機啟動：\n1 rc-update add docker default 啟動 Docker：\n1 service docker start 查看是否啟動：\n1 docker ps 新增 swap 因為伺服器的映像檔預設沒 swap，我就新增了，但是之後發現預設是有新增的，可以根據需要選擇是否新增。\n新增交換空間檔案：\n1 fallocate -l 8G /swapfile 設定權限為只能 root 存取：\n1 chmod 600 /swapfile 格式化 swap：\n1 mkswap /swapfile 啟用 swap：\n1 swapon /swapfile 查看是否生效：\n1 free -h 掛載硬碟 查看所有區塊裝置：\n1 fdisk -l 安裝 ntfs 支援：\n1 apk add ntfs-3g 建立掛載資料夾：\n1 mkdir /mnt/hc550 掛載：\n1 mount -t ntfs-3g /dev/sdc1 /mnt/hc550 卸載有兩種方法，透過路徑 (推薦)：\n1 umount /mnt/hc550 或者透過裝置：\n1 umount /dev/sdc1 自動掛載 獲取分割區 ID，避免重啟後裝置名稱變更：\n1 blkid 編輯 /etc/fstab：\n1 vi /etc/fstab 新增設定：\n1 2 # \u0026lt;設備UUID\u0026gt; \u0026lt;掛載點\u0026gt; \u0026lt;檔案系統\u0026gt; \u0026lt;選項\u0026gt; \u0026lt;dump\u0026gt; \u0026lt;pass\u0026gt; UUID=xxxxxxxx /mnt/hc550 ntfs-3g defaults,uid=1000,gid=1000 0 0 測試是否成功，先卸載：\n1 umount /dev/sdc1 掛載全部，會自動查找設定：\n1 mount -a 檢測是否成功：\n1 ls /mnt/hc550 SMB 共享 使用 Samba 共享可以將硬碟掛載到 Windows，就像操作本機硬碟一樣操作檔案。\n在 /home/samba 建立 docker 設定檔 docker-compose.yml：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 version: \u0026#39;3.1\u0026#39; services: samba: image: \u0026#39;ghcr.io/crazy-max/samba:latest\u0026#39; container_name: samba network_mode: host volumes: - \u0026#39;/home/samba/data:/data\u0026#39; - \u0026#39;/mnt/hdd4t:/mount/hdd4t\u0026#39; - \u0026#39;/mnt/hc550:/mount/hc550\u0026#39; environment: - \u0026#39;TZ=Japan/Tokyo\u0026#39; - \u0026#39;SAMBA_LOG_LEVEL=0\u0026#39; restart: always 編輯軟體設定檔 config.yml：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 auth: - user: yexca group: yexca uid: 1000 gid: 1000 password: passwd global: - \u0026#34;force user = yexca\u0026#34; - \u0026#34;force group = yexca\u0026#34; share: - name: HDD4TB comment: hdd4t path: /mount/hdd4t browsable: yes readonly: no guestok: no veto: no validusers: yexca writelist: yexca recycle: yes - name: HC550 comment: hc550 path: /mount/hc550 browsable: yes readonly: no guestok: no veto: no validusers: yexca writelist: yexca recycle: yes Windows 掛載為網路磁碟機\n按 Win + R 開啟 cmd，輸入指令：\n1 net use Z: \\\\alpine-nas\\HDD4TB /user:yexca passwd /persistent:yes 刷新檔案總管：\n1 explorer.exe Z: 或者也可以透過檔案總管的圖形介面新增。\n綁定掛載 相較於軟連結 (Symbolic Link)，綁定掛載 (Bind Mount) 可以相容 docker。\n1 mount --bind /mnt/hc550/anime /anime 開機自動綁定掛載需要寫入 /etc/fstab，必須在（硬碟）掛載設定的下方 (因為檔案依序執行)：\n1 2 /mnt/hc550/anime /tmp/anime none bind 0 0 /mnt/hc550/comic /tmp/comic none bind 0 0 驗證：\n1 df -h 其他服務 對於其他服務，我之前的文章感覺已經寫過不少了，不再贅述。\n相關文章(簡體中文)：\n2025-10-05: 漫畫與音聲網站折騰 2023-05-02: 搭建個人音樂網站 2022-09-16: 個人內網折騰 2022-09-14: Fedora 安裝 Komga 折騰記錄 自訂網域 這裡使用 OpenWRT 路由器的 DNS 攔截實現存取特定網域，從而進入自己 NAS 服務。\n要求是裝置的 DNS 伺服器是路由器，然後在路由器的 DHCP/DNS 設定裡為 NAS 分配靜態 IP，再新增挾持網域，都指向 NAS 的 IP 位址。\nNginx-UI 為了讓自訂網域生效，需要使用 Nginx 反向代理 NAS 上的服務。\nDocker Compose 設定檔：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 version: \u0026#39;3.1\u0026#39; services: nginx-ui: image: uozi/nginx-ui:v2.2.0-patch.1 container_name: nginx_UI volumes: - /home/nginxUI/nginx:/etc/nginx - /home/nginxUI/nginx-ui:/etc/nginx-ui - /home/nginxUI/www:/www environment: - NGINX_UI_IGNORE_DOCKER_SOCKET=true ports: - 80:80 - 443:443 restart: always 容器存取另一個容器的橋接 IP 為 172.17.0.1。\n假如有一個服務是映射到主機的 8888 埠，新增反向代理時候，代理的位址不是 127.0.0.1:8888 而是 172.17.0.1:8888。\n關於為什麼設定環境變數，請參見： 2025 新伺服器部署記錄#安裝-nginx-ui(簡體中文) 結語 我感覺也算是實現了 2022 年的我說的那些話吧。\n同時感覺短短三年的時間，雖然我主觀上是覺得自己沒有什麼變化的，可是在閱讀自己以前的文章時，回憶當時寫下那些文字的處境，確確實實感受到了自己的思考方式發生了天翻地覆的變化。\n當時的我说實話好像是想著使用 True NAS 之類的特製化系統，但是沒想到我真的實現的時候，使用了以前的我想都不敢想的從零開始，一點點看著自己之前的文章，組成這段，可以說真切感受到了「價值」。\n折騰不息，熱愛不止。\n","date":"2025-11-13T17:57:29+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/261/","title":"你的下一台 NAS，何必是 NAS"},{"content":" 📢 本文由 ChatGPT 翻譯 引言 每天滑影片、打電動，本來以為這些都是放鬆的行為，理應能在之後恢復精神。\n但實際上，天天這樣的生活卻讓我覺得空虛又疲累。\n這讓我開始疑惑：理論上我並沒有做什麼高消耗的事情，可是精神不振的狀態實在不太正常。\n番茄鐘裡的困惑 回想起之前眼睛疲勞的時候，我為了護眼而使用番茄鐘學習。\n一開始我的目的很明確，每次休息時間就是望遠或是躺下來休息一下，效果確實不錯。\n但隨著使用次數增加，我漸漸想要在休息時找一些「娛樂」來填補。\n於是我開始利用長一點的休息時間看影片、聽音樂或玩遊戲。\n慢慢地，我感覺效率變差，甚至覺得番茄鐘很麻煩：學習變得更累（有時狀態正好，卻被強制休息），玩樂也不覺得放鬆，反而因為只有 20 分鐘，讓我玩得很焦慮。\n娛樂：另一種專注 仔細想想，也許娛樂並不等於放鬆。\n娛樂跟學習一樣，其實都是需要專注的行為。\n而番茄鐘的設計，是為了管理專注，之後才安排休息。\n真正的「休息」應該是身心的放鬆，是一種從專注狀態中恢復的過程。\n當我嘗試把大腦放空，什麼都不想，去散步、去公園走走、或是隨便逛逛書店時，明顯比看影片或打電動更有放鬆的感覺。\n雖然這些活動會消耗體力，但相比之下，娛樂與學習消耗的其實是「精神力」。\n重新定義娛樂與放鬆 因此，我覺得可以重新檢視娛樂的定義。\n娛樂並不是在學習疲勞後讓自己恢復的方式，而是一種同樣需要投入精神力的行為。\n當精神力已經不足時，還硬去消耗，只會讓娛樂失去意義，甚至出現類似「電子陽痿」的狀況。\n這就像手機電量快沒了，卻還在開著高耗電的 APP。\n相對的，放鬆或休息則該被重新定義。\n它應該是一種讓身心完全打開、任其漂浮的狀態。\n當精神力不足時，做一些低精神消耗、低體力消耗的事也不錯，像是整理環境、隨意走走，不帶目的、不帶意識。\n學習與娛樂的模糊界線 既然學習與娛樂都需要專注，那它們的差別在哪裡呢？\n我認為，這取決於「興趣」。\n不管需要多少專注力，只要有興趣，它就是娛樂；\n如果缺乏興趣，那往往就被歸類為學習。\n例如一款遊戲，如果出於興趣，那就是單純「好玩就玩」；\n但若以「學習」的心態進行，就會變成「要達成什麼目標、做到什麼程度」。\n再像是一個電影 IP，帶著興趣去看，就是放空自己、盡情享受帶來的震撼；\n但若以「學習」的心態，往往會變成分析細節、研究背景、補完世界觀。\n當然，兩者的界線並不明確，大多取決於個人主觀感受。\n放鬆：精神力的真正補給 既然凡是有目的的行為都需要專注，那麼有些所謂的「放鬆行為」其實也帶有目的。\n像是去超市補貨、去書店買書、甚至「去公園放鬆」。\n一旦帶上目的，我覺得這就不是真正的放鬆，因為大腦沒有真正放空，精神力也不會被恢復。\n某些放鬆方式，可以理解成「用少量體力的消耗，換來精神力的補充」。\n如果體力也不支，那還是單純躺下休息最好。\n或許，真正的休息並不是找一件輕鬆的事去做，而是允許自己什麼都不做。\n總結 學習讓人進步，娛樂讓人興奮，而真正的放鬆，才能讓人恢復。\n生活不該只有追逐與刺激。\n也許我們真正需要的，不是更多的娛樂，而是學會停下來。\n","date":"2025-08-22T22:17:38+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/253/","title":"放鬆不是娛樂：一場精神力的再定義"},{"content":" 📢 本文由 ChatGPT 翻譯 引言：飄零的學習感 為了讓自己的英文程度能稍微提升，我在一些不太重要的地方會盡量使用英文，例如遊戲或日常的應用軟體。可是每次使用時，總會有一種沒有真正掌握到什麼的感覺，彷彿整段經歷都是飄浮不定的，甚至好像自己根本沒經歷過。\n仔細想想，這或許是從「翻譯」到「融入」之間的落差。當母語中文介入時，這段經歷會被牢牢地繫在我的語言與思維裡；但在完全非母語的環境下，這段經歷卻無法與母語產生連結。而我平常又是依靠母語思考，自然就忽視了非母語的思考過程。\n類比：控制的執行感 就我實際的體驗來說，在完全英文的遊戲環境裡，我常常覺得自己什麼都不懂，就算是最簡單的單字也一樣。但如果是和朋友一起連線遊玩，並用中文溝通，感覺又完全不同。那種狀態像是重新切回翻譯模式，讓我瞬間輕鬆了許多，從一片慌亂中轉為多少有點掌握感。\n這也讓我聯想到在東京的生活。即使用日文對話，心裡卻常常沒有什麼實感，總覺得自己像是在執行預先設定好的指令，而不是在「活著」。也因此，我甚至喜歡上聽中文歌，因為只有那樣，在街頭閒逛時才會覺得自己還真實地存在。\n矛盾：理論最優與現實退縮 不過話說回來，這樣的狀態不就是語言學習所推崇的「完全脫離母語思考」的理想環境嗎？當我全身心沉浸在英文遊戲裡，沒有任何中文干擾，理論上應該是最好的學習方式吧？畢竟，這幾乎就等於所謂的 Thinking in English。\n然而，實際感受卻完全相反。當遇到一個不認識的單字時，我立刻會覺得自己什麼都做不了、什麼都不會。這種感覺會自然地引發退縮，讓我乾脆什麼都不做。結果是，我覺得自己的英文程度完全沒有進步，甚至反而更加沒有自信。\n反思：完美奇點的幻覺 回顧我的學習歷程，我突然意識到，自己好像一直沒有真正「學習」過。更多時候，我只是在依靠直覺與經驗判斷。在遊戲或日常生活中，能取得的資訊並不只有語言，還有動作、提示、環境等線索。也許我只是靠這些訊號來決定下一步該做什麼，於是給了自己「聽懂了」的錯覺，但語言本身卻成了被忽略的部分，所以說到底並沒有真正學到語言。\n那麼，我以前的學習方式（不只語言）又是如何呢？似乎總是要等到一個「完美的時機」再投入。除非一切條件都很「完美」，否則我就會主觀認為這樣的努力毫無意義。這大概就像是那句話——「收藏從未停止，學習從未開始。」\n這種心態不只體現在感受上，也表現在對環境與教材的要求。幾乎就像「廣度優先演算法」，在每一個階段都想要達到某種「最優」才肯繼續。否則就會覺得完全沒有意義，就算勉強自己去做，結果也只是無果。\n生活：理性與感性的錯位 這又讓我想起生活方式。對於某些不順心的事情（不管是事件還是物品），短期與長期往往呈現出完全不同的心態。短期內它會擾亂心情，但從長期來看，好像根本不那麼重要。\n就像有些物品，長遠看或許會有用，但眼下完全用不上。只是因為「未來可能需要」就讓自己一直處在不舒服的狀態，最後的結果卻是根本沒派上用場。\n整理東西也是同樣的情況。理性上覺得整理會更好，感性上卻提不起勁，或者總想等到一個「完美的時機」再整理。於是，在這個「完美時機」到來之前，每次想到這件事都會覺得煩躁。\n結論：貌似沒有「正解」 那麼，有沒有一個答案能讓學習或生活變得高效呢？\n我想……大概是沒有的吧。生活中充滿了理性決策與感性決策。也許我打算在某段時間內提升某項能力，但由於未來不可預測，加上情緒狀態不同，每一次執行計畫時的結果，都可能超出或低於預期。\n不過，這並不代表毫無技巧可循。既然新的資訊可能隨時推翻原本的計畫，那麼也許可以嘗試換個角度來約束自己：放棄某個面向，卻在另一個面向補足。比如固定時間，讓學習量浮動；或者設定最少的學習量，再讓時間浮動。\n引申：目的性與新鮮感 說到這裡，我忽然又有個想法。只要一件事情帶有「目的性」，在感性上就會變得難以持續。就算是娛樂，像玩遊戲也是。當我帶著「為了釋放壓力」的目的去玩時，腦子裡反而一直在想：「我有沒有真的放鬆下來？」這種意識本身就成了一種壓力。結果不但沒有舒壓，反而越玩越累，甚至出現類似「電子陽痿」的感覺。\n所以有人提出「多培養一些興趣比較好」。這的確是個不錯的方法。因為在不同情境下，可以選擇不同的釋壓方式（以興趣為前提），就能避免過度依賴單一手段。\n不過，或許本質其實更簡單：就是因為「新鮮感」吧。新事物會帶來新鮮的能量。\n結語：「不可控」的未來 那麼，這篇文章到底寫了什麼呢？老實說，我也不確定。也許只是我混亂思緒下的產物罷了。\n但或許，這才是真正的答案——接受生活的「不可控」。我總妄想用理性架構一切，但似乎……任何理性都無法解釋全部。\n就像「狀態—行為理論」所說，只有在掌握所有變數的情況下，才能百分之百預測結果。但我們怎麼可能獲得生活中的「所有變數」呢？\n也許，無法完全掌握變數，本身就是生活的一個變數吧。\n","date":"2025-08-18T18:27:12+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/252/","title":"漂浮的學習，錯位的人生"},{"content":" 📢 本文由 ChatGPT 翻譯。并且，該軟件只有簡體字 原本只是想隨便寫個小工具，打算用兩天就放著（以前大多都是這樣），沒想到在沒出錯的情況下幫我省下不少時間，越用越順手。\n慢慢地也喚起我以前那個「為什麼不用 SQLite 呢」的想法。確實，每次開 MySQL 真的太麻煩了，於是就誕生了這個版本，終於不用每次都啟動資料庫服務了 （也終於變得比較像給人用的了）\n使用方法 專案位址： https://github.com/yexca/PixivDownloader-SQLite GUI 跟前一代差不多，可以參考 https://blog.yexca.net/archives/211/ 設定說明 使用前需要先設定以下項目：\nrefresh token（Pixiv 登入驗證，參考： Pixiv OAuth Flow ） 下載路徑（預設 D:\\Downloads） 下載說明 使用時只需輸入：\n畫師 ID，或是 作品 ID（若兩者皆輸入，將以畫師 ID 為主） 點擊下載即可下載所有作品並記錄到資料庫（若該畫師尚無記錄則下載所有作品，已有記錄則只下載未下載的部分）\n錯誤處理 目前僅對爬取錯誤進行處理。若出現錯誤提示，有可能是以下原因：\n未設定 refresh token 或 token 已失效 畫師帳號不存在 作品不存在 我沒有加上詳細錯誤說明，如出錯請先檢查以上三點。\n至於其他錯誤（例如軟體直接閃退），可以將 程式根目錄/logs/app_*-*-*.log 中最新的 log 檔寄給我，並說明情況。\n聯絡方式：PixivDownloader#yexca.net（請將 # 換成 @）\n新特性：從 MySQL 改為 SQLite 這次最大變動就是不再需要自建 MySQL，改用輕量化的 SQLite。\n因此也移除了原本不必要的資料庫設定，將設定與 Pixiv 的驗證 Token 整合在一起。\n加了個 icon（隨便請 ChatGPT 畫的），UI 稍作調整，變動不大。\n程式碼初步進行架構化處理……雖然寫到最後又有點亂了就是了 不過說不定哪天我又回來重構一次啦。\n舊版 MySQL 資料庫的遷移方法 雖然我覺得應該沒人用上一版，但還是說一下：由於資料結構不同，最推薦的方式是查詢導出並轉為 INSERT 語法，例如：\n1 2 3 SELECT ID, name, downloadedDate, lastDownloadID, url FROM pic WHERE platform = \u0026#39;pixiv\u0026#39;; 將結果導出為 SQL 語法（我使用的是 Dataflare，它支援這個功能）。\n然後建立一個 Python 檔案，寫入以下內容：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 import sqlite3 conn = sqlite3.connect(\u0026#34;pixiv.db\u0026#34;) cursor = conn.cursor() cursor.execute(\u0026#39;\u0026#39;\u0026#39; Create Table If Not Exists pic ( ID TEXT PRIMARY KEY, name TEXT, downloadedDate TEXT, lastDownloadID TEXT, url TEXT ) \u0026#39;\u0026#39;\u0026#39;) conn.commit() cursor.execute(\u0026#34;\u0026#34;\u0026#34; INSERT INTO `pic` (`ID`, `name`, `downloadedDate`, `lastDownloadID`, `url`) VALUES (\u0026#39;123\u0026#39;, \u0026#39;name1\u0026#39;, \u0026#39;2024-06-08 00:00:00\u0026#39;, \u0026#39;1234\u0026#39;, \u0026#39;https://www.pixiv.net/users/123\u0026#39;), (\u0026#39;234\u0026#39;, \u0026#39;name2\u0026#39;, \u0026#39;2025-02-12 00:05:36\u0026#39;, \u0026#39;2345\u0026#39;, \u0026#39;https://www.pixiv.net/users/234\u0026#39;), (\u0026#39;345\u0026#39;, \u0026#39;name3\u0026#39;, \u0026#39;2025-01-11 17:26:17\u0026#39;, \u0026#39;3456\u0026#39;, \u0026#39;https://www.pixiv.net/users/345\u0026#39;); \u0026#34;\u0026#34;\u0026#34; ) conn.commit() cursor.execute(\u0026#34;\u0026#34;\u0026#34; Select * from pic \u0026#34;\u0026#34;\u0026#34; ) rows = cursor.fetchall() for row in rows: print(row) conn.close() 其中 cursor.execute 的內容請自行替換為你的備份資料。我這裡提供三筆示範資料。\n最後，將產生的資料庫檔案 pixiv.db 放到 程式根目錄/resources 即可。\n一點開發感想：從「亂寫」到「理解混亂」 老實說這次重構是因為上次寫得太亂，覺得非整頓不可，結果改著改著我終於明白為什麼上次會那麼亂了 😂\n不如說，這次的結構也沒好到哪去，寫到一半直接放棄重構，乾脆複製貼上，導致現在有駝峰式命名也有底線命名，真是懶得再改，唉。\n總之算是一個能正常運作的半成品，能用就好了啦～\n","date":"2025-05-18T16:20:33+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/248/","title":"Pixiv 下載器重構記：從亂寫到理解混亂"},{"content":" 📢 本文由 ChatGPT 翻譯 引言 最近在思考自己要繼續做什麼或學些什麼的時候，老是看到「DevOps」這個詞。一開始隨手查了一下，發現裡面提到的技術棧自己差不多都有碰過，還以為這只是像「全端」那樣多掌握幾個工具就好（雖然其實也差不多啦）\n但因為當時沒什麼興趣就耽擱了（其實是沒開發熱情了）\n直到最近躺了快四個月，覺得該掙扎一下，結果又想到這個詞。再深入了解後，只能說\u0026hellip;\u0026hellip;這根本是「捲」到極致了吧，前後端分離就算了，現在是連開發和運維分離都不分人了。\n不過話說回來，當我看到自動流程有 GitHub Action 的時候，就讓我想起以前用 Jekyll 建部落格時也能自動部署。但因為我那時候從其他部落格系統轉過來，習慣用子資料夾分類，而那套部署方式不支援子資料夾，所以我也沒深入研究。既然這次想好好整一整，就來看看現在的 Hugo 部落格能不能自動部署吧 畢竟每次都從容器下回來再上傳真的蠻麻煩的\n工作流程 建立一個 Workflow 的方式是，在 Git 倉庫根目錄的 .github/workflows/ 中建立一個 yaml 檔案，檔名隨意。我這次是部署用途，就命名為 deploy.yml\n整個檔案結構主要分為：名稱、觸發器與工作內容\n名稱 這個就隨意取名即可\n1 name: Build and Deploy Hugo Blog 觸發器 GitHub Action Workflow 支援多種觸發方式，我這裡設成每次 push 都觸發，畢竟通常都是更新文章然後進行構建\n另外加上手動觸發功能，以備有時候 GitHub 出錯需要手動啟動 Workflow\n1 2 3 4 5 on: push: # 當 Git Push 時觸發 branches: - main # 監聽主分支 workflow_dispatch: # 手動觸發 工作內容 我這邊只有一個工作（job），但其實 jobs 可設定多個並行執行。\n先命名這個工作\n1 2 jobs: build-deploy: 接著定義執行的作業環境，我這裡選用 ubuntu：\n1 2 3 jobs: build-deploy: runs-on: ubuntu-latest 接下來定義各步驟，第一步：檢出原始碼\n1 2 3 4 5 6 7 jobs: build-deploy: runs-on: ubuntu-latest steps: - name: Checkout source uses: actions/checkout@v4 安裝 Hugo：\n1 2 3 4 5 6 steps: - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#39;0.140.1\u0026#39; # 这里是我本地的版本，兼容性应该高点 extended: true # 因为我的主题使用了 SCSS 所以必须使用 extended 版本 執行建構指令：\n1 2 3 steps: - name: Build Hugo Site run: hugo --minify 將建構後的內容部署到另一個 GitHub Pages 倉庫：\n1 2 3 4 5 6 7 8 steps: - name: Deploy to BlogWeb repo uses: peaceiris/actions-gh-pages@v3 with: external_repository: yexca/Blog-Web-Hugo publish_branch: main # 推送到目标仓库 yexca/Blog-Web-Hugo 的 main 分支 publish_dir: ./public # 推送的当前仓库的文件夹，Hugo 默认是生成到这个文件夹 personal_token: ${{ secrets.PERSONAL_TOKEN }} 完整合併如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 name: Build and Deploy Hugo Blog on: push: branches: - main workflow_dispatch: jobs: build-deploy: runs-on: ubuntu-latest steps: - name: Checkout source uses: actions/checkout@v4 - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#39;0.140.1\u0026#39; extended: true - name: Build Hugo site run: hugo --minify - name: Deploy to blogWeb repo uses: peaceiris/actions-gh-pages@v3 with: external_repository: yexca/Blog-Web-Hugo publish_branch: main publish_dir: ./public personal_token: ${{ secrets.PERSONAL_TOKEN }} 設定 Token 由於存取其他倉庫需要權限，因此需先產生 Token。\n在 GitHub 的 Settings -\u0026gt; Developer Settings -\u0026gt; Personal access tokens -\u0026gt; Fine-grained tokens 中，產生一組擁有目標倉庫讀寫權限的 Token。\n然後回到原始碼倉庫（例如 yexca/Blog-Source-Hugo），進入 Settings -\u0026gt; Secrets and variables -\u0026gt; Actions -\u0026gt; Repository secrets，新增剛才建立的 Token，名稱需對應 PERSONAL_TOKEN。\n處理自訂網域 若你為 GitHub Pages 設定了自訂網域，需建立一個 CNAME 檔，內容為你的網域。\n但 GitHub Action 的部署會清空再覆蓋內容，因此 CNAME 也會被刪除，所以要在部署前手動加上，可採以下兩種方式：\n方法一：工作流中建立檔案 1 2 3 steps: - name: Add CNAME run: echo \u0026#39;blog.yexca.net\u0026#39; \u0026gt; public/CNAME 方法二：在 Hugo 的 static 資料夾放置 CNAME 因為 static 資料夾會被原樣複製到輸出目錄，也能達成目的。\n主題子模組處理 我原本的主題是以 Git Submodule 引入的，但因為我做了不少修改，若不處理這部分，推送上去的將會是原始 repo 的內容，而非我修改過的版本。\n備份主題 1 cp -r themes/Hugo-Theme-Stack tmp/Hugo-Theme-Stack-Backup 移除子模組 1 2 3 4 git submodule deinit -f themes/Hugo-Theme-Stack git rm -f themes/Hugo-Theme-Stack rm -rf .git/modules/themes/Hugo-Theme-Stack rm .gitmodules 恢復主題 1 2 cp -r tmp/Hugo-Theme-Stack-Backup themes/Hugo-Theme-Stack rm -rf tmp 修復 JS 語法錯誤 我以前為部落格添加了網站執行時間顯示，但當時用了舊的八進位語法：\n1 Date.UTC(2021, 10, 06, 14, 15, 19) 而 Hugo 的 --minify 壓縮指令會對其報錯，改成以下即可：\n1 Date.UTC(2021, 10, 6, 14, 15, 19) 結語 終於不再需要手動編譯了。自從我開始使用 Docker，就習慣將開發環境與本機系統隔離，這樣換電腦或搬服務器只需搬容器即可，也養成了環境潔癖。\n現在好了，連建構與部署也搬到雲端去了，以前是隔離到容器，現在是隔離到 GitHub，算是徹底根治了這毛病。\n不過再回頭看看 DevOps，我倒覺得這其實也是當代技術演進過快導致的產物。\n從早年的機器碼、組合語言，到高階語言，再到容器化部署，一次次技術的「門檻下降」實際上也在偷偷「拉高起跑線」。\n雖然讓程式開發越來越便利，但也使這行的入門門檻不知不覺變高，讓像我這樣的人加速被淘汰啦。\n不過話說回來，工作是工作，生活是生活。技術變快歸變快，世界的節奏、行業的變遷應該還沒快到讓人沒喘息的空間。還是會有留一口氣的餘地吧。\n","date":"2025-05-16T18:14:06+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/247/","title":"擁抱 DevOps：把我的部落格建構與部署丟給 GitHub 處理"},{"content":" 📢 本文由 ChatGPT 翻譯 引言 又一次的自我介紹時，我不由得又想到了我的部落格。\n過去我總是直接打開 Google 搜尋 yexca，點開第一個結果進入我的部落格。\n但自從更換網域後，無數次搜尋 yexca，我的網站卻始終消失在搜尋結果之外。\n起初我並沒有太在意，以為可能有某種懲罰機制吧。畢竟 Google 建議更換網域後最好做一年的 301 重導向，而我當時只做了半年，舊網域就到期了。\n但，已經兩年了吧，再怎麼說，也該恢復了吧？\n而且更離譜的是，搜尋前幾的反而是一些早已不再維護的網站，\n而我，每天更新、調整、折騰的這個部落格，卻彷彿被世界遺忘了一般。\n於是，我開始尋找原因 打開我的部落格，查看 \u0026lt;head\u0026gt; 區塊。\n嗯？\u0026lt;meta name='description'\u0026gt; 怎麼是網頁左邊那句標語？\n啊這，當時配置的時候只是說那句話會出現在那邊，我以為跟 Argon 主題設定一樣呢。那麼也就是說，這網站的描述根本毫無意義啊。\n不過，這句話幾乎陪伴了我整個部落格歷程，我不想輕易放棄它。\n既然如此，那就讓 JSON-LD 來承擔結構化描述的任務吧！\n於是我在主題自定義 \u0026lt;head\u0026gt; 區段加入了：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;script type=\u0026#34;application/ld+json\u0026#34;\u0026gt; { \u0026#34;@context\u0026#34;: \u0026#34;https://schema.org\u0026#34;, \u0026#34;@type\u0026#34;: \u0026#34;Blog\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;yexca\u0026#39;Blog\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;{{ .Site.BaseURL }}\u0026#34;, \u0026#34;inLanguage\u0026#34;: \u0026#34;{{ .Site.Language.Lang }}\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;{{ .Site.Params.description }}\u0026#34;, \u0026#34;author\u0026#34;: { \u0026#34;@type\u0026#34;: \u0026#34;Person\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;yexca\u0026#34; } } \u0026lt;/script\u0026gt; 嗯，同時考慮到是多語言網站，部分內容當然還是使用變數適配會比較好。\n在語言的迷宮中探索 說到多語言網站，那我換個語系搜尋會如何呢？\n於是我在 google.com.hk、google.com.tw、google.com.jp 搜尋 yexca。\n結果日文版可以搜尋到部落格，但中文版卻搜尋不到；英文內容不多，就算了。\n這就很奇怪了，說明 Google 是有把 https://blog.yexca.net 辨識為 yexca，\n那為什麼其他語言版本這麼慘捏？\n繼續排查下去，我發現可能是少了 hreflang 設定，於是我補上了：\n1 2 3 4 5 \u0026lt;link rel=\u0026#34;alternate\u0026#34; hreflang=\u0026#34;x-default\u0026#34; href=\u0026#34;https://blog.yexca.net/\u0026#34; /\u0026gt; \u0026lt;link rel=\u0026#34;alternate\u0026#34; hreflang=\u0026#34;zh-CN\u0026#34; href=\u0026#34;https://blog.yexca.net/\u0026#34; /\u0026gt; \u0026lt;link rel=\u0026#34;alternate\u0026#34; hreflang=\u0026#34;zh-TW\u0026#34; href=\u0026#34;https://blog.yexca.net/zh-tw/\u0026#34; /\u0026gt; \u0026lt;link rel=\u0026#34;alternate\u0026#34; hreflang=\u0026#34;ja\u0026#34; href=\u0026#34;https://blog.yexca.net/ja/\u0026#34; /\u0026gt; \u0026lt;link rel=\u0026#34;alternate\u0026#34; hreflang=\u0026#34;en\u0026#34; href=\u0026#34;https://blog.yexca.net/en/\u0026#34; /\u0026gt; 明確告訴搜尋引擎：不同語言的用戶可以拜訪不同語系版本，但這些都是同一網站。\n順帶一提，這段 \u0026lt;link\u0026gt; 同樣會出現在文章頁面，因為我沒有加條件判斷。雖然不是每篇文章都有多語版本，不過 Google 是可以自己理解的。\n一點點地補上遺漏 但我隨意點開一篇文章，哎呀，裡面還是 JSON-LD 的網站描述，多少有點奇怪。\n於是我加上了條件邏輯：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 {{ if .IsHome }} \u0026lt;!-- 首頁 JSON-LD --\u0026gt; \u0026lt;script type=\u0026#34;application/ld+json\u0026#34;\u0026gt; { \u0026#34;@context\u0026#34;: \u0026#34;https://schema.org\u0026#34;, \u0026#34;@type\u0026#34;: \u0026#34;Blog\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;yexca\u0026#39;Blog\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;{{ .Site.BaseURL }}\u0026#34;, \u0026#34;inLanguage\u0026#34;: \u0026#34;{{ .Site.Language.Lang }}\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;{{ .Site.Params.description }}\u0026#34;, \u0026#34;author\u0026#34;: { \u0026#34;@type\u0026#34;: \u0026#34;Person\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;yexca\u0026#34; } } \u0026lt;/script\u0026gt; {{ else if .IsPage }} \u0026lt;!-- 文章頁 JSON-LD --\u0026gt; \u0026lt;script type=\u0026#34;application/ld+json\u0026#34;\u0026gt; { \u0026#34;@context\u0026#34;: \u0026#34;https://schema.org\u0026#34;, \u0026#34;@type\u0026#34;: \u0026#34;BlogPosting\u0026#34;, \u0026#34;mainEntityOfPage\u0026#34;: { \u0026#34;@type\u0026#34;: \u0026#34;WebPage\u0026#34;, \u0026#34;@id\u0026#34;: \u0026#34;{{ .Permalink }}\u0026#34; }, \u0026#34;headline\u0026#34;: \u0026#34;{{ .Title }}\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;yexca\u0026#39;Blog\u0026#34;, \u0026#34;author\u0026#34;: { \u0026#34;@type\u0026#34;: \u0026#34;Person\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;yexca\u0026#34; }, \u0026#34;publisher\u0026#34;: { \u0026#34;@type\u0026#34;: \u0026#34;Person\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;yexca\u0026#39;Blog\u0026#34; }, \u0026#34;datePublished\u0026#34;: \u0026#34;{{ .Date.Format \u0026#34;2006-01-02\u0026#34; }}\u0026#34;, \u0026#34;dateModified\u0026#34;: \u0026#34;{{ .Lastmod.Format \u0026#34;2006-01-02\u0026#34; }}\u0026#34;, \u0026#34;inLanguage\u0026#34;: \u0026#34;{{ .Site.Language.Lang }}\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;{{ .Params.description | default .Site.Params.description }}\u0026#34; } \u0026lt;/script\u0026gt; {{ end }} 如此一來，首頁與文章就會產生不同的 JSON-LD，不僅語義更正確，也更符合 Google 結構化資料的建議。\n小小的期盼 現在，一切終於補齊了。\n雖然成效不會立刻出現，但我知道，那個訊號，已經送出去了。\n我希望，下次在介紹我的部落格時，\n可以直接打開 Google，搜尋 yexca。\n","date":"2025-04-27T17:38:16+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/246/","title":"為了能搜到自己的名字：一次小站 SEO 排查實踐"},{"content":" 此頁面有使用機器翻譯喲\n並不是所有刷卡的人都是羊毛黨，也不是所有設計系統的人都是工程師。有些人，刷卡像在設計，設計系統像在過生活\n1. 引子：什麼是卡粉？ 說到這，不得不提到之前看到的卡友七大愛好：\n這裡的「中國大陸」是指資金出入受限地區\n想辦法在中國大陸使用外匯 想辦法在境外使用人民幣 想辦法把人民幣匯出中國大陸 想辦法把外匯匯入中國大陸 辦一些在中國大陸幾乎沒用的卡 辦一些在國外更沒用的卡 想辦法讓那些連密碼位數都不到的資金，在一些幾乎沒什麼實際用途的卡片之間來回周轉 中國大陸的銀行密碼慣例為六位數，這裡是卡粉們自嘲「錢比密碼短，還在努力搬」的梗。其他地區可能不適用\n聽起來像是玩金融遊戲，乍看之下就是辦一堆銀行卡、追求回饋、省手續費、划算換匯……好像只是一種「不值錢的小聰明」\n但對真正的卡粉來說：\n卡粉，不是為了省幾塊錢，而是在尋找一個多通道、多節點、多限制下的資金最優路徑設計\n他們不是在薅羊毛，而是在探索這個世界的架構，在做生活系統的最佳化設計\n2. 系統架構設計到底在做什麼？ 為了考取系統架構師資格，往往需要學會很多相關術語，例如模組解耦、效能最佳化、介面規範等等。但拋開這些術語，其實系統架構師的本質任務非常明確：\n在複雜的限制條件下，合理分配資源、規劃路徑、連接各個系統，最終建構出一個既穩定又彈性的整體\n所以系統架構師考慮的不是某行程式碼寫得漂不漂亮，也不只是畫設計圖，而是整個系統能否在現實限制下順利運行。比方說：\n系統之間該如何分工？ 各個服務之間如何呼叫？ 介面要怎麼定義，才能方便未來擴充？ 出現問題時怎麼定位、怎麼隔離影響？ 在預算有限的情況下，怎麼權衡效能與成本？ 系統架構師的角色，有點像在搭積木、也像在修橋鋪路，更像在補丁系統。他們往往不是一開始就擁有完美藍圖，而是在一個混亂甚至破碎的現實中，一點一點規劃路線、加固結構、替換模組、最佳化通路\n簡單來說，就是要在現實條件下，設計出跑得穩、改得動、養得起的系統。不追求「完美設計」，只追求「跑得通」，這就是系統架構師的美學\n雖然我當初只是為了應考而接觸這些知識，但在備考過程中，卻不知不覺重新燃起了我對卡片路徑設計的熱情\n3. 卡粉世界的「架構問題」 卡粉不是無意義的「省點小錢」，系統架構師也不是在搞「高大上的工程設計」。雖然他們活動的場景完全不同，但本質上，他們都在面對同一種問題：\n在規則複雜、成本有限、目標不明的情況下，尋找最優的通路與結構\n卡粉不是單純在辦卡，而是在設計資金流動路徑；\n系統架構師也不是單純在寫程式，而是在規劃資訊流與控制流。\n卡粉常常在思考「怎麼少付手續費、不被風控、還能順利流轉」；\n而架構師則在考量「怎麼減少故障、提升擴展性、讓系統跑得穩」。\n雖然我只是為了考試而認識架構師的思維方式，但回頭一看，這不就是我在玩卡時思考的那些事情嗎？\n卡粉世界 系統架構世界 核心邏輯 手續費 延遲／效能開銷 成本管理 通道限制 API 調用限制 協議相容 卡組織規則 模組規範 合規性 境內外匯差 跨平台相容損耗 多環境適配 卡種多樣性 技術棧多樣性 多模組整合 銀行風控 系統安全策略 風險控制 多卡流轉路徑 資料流向控制 路由與架構設計 卡粉做的不是套利，而是在進行一場關於資金流動結構的設計遊戲\n他們不是在「做事」，而是在「做結構」：不只是找哪張卡回饋最高，而是設計一條路徑，讓資金在卡與卡之間以最小代價、最大效率地完成任務\n他們關注的不是「能不能跑」，而是「跑得是否優雅」；不是「能不能轉出去」，而是「這條流轉過程是否精巧、順暢」\n卡粉在找尋最優卡路徑，其實就像是在解一個「多重限制下的最短路徑問題」；而系統架構師在設計服務拓撲時，則是在權衡「模組耦合度＋SLA（服務等級協議）限制」下的最適組合\n這兩者之間，只是應用場景不同。\n4. 探索路徑的系統實踐 別人只在算哪張卡划算，我在設計一套金融流通系統\n每位卡粉的路徑都是獨一無二的，因為每個人面對的條件都不同：使用的銀行不同、帳戶幣別不同、生活地區不同、資金來源也不同\n真正的樂趣不在於抄別人的攻略，而是透過觀察、實驗、踩坑，找出最適合自己的資金架構\n我記得一開始只是想省點手續費，結果查了一堆資料，發現不同銀行之間轉帳的條件、時間、風控都不同。有些手續費低但轉帳速度慢，有些速度快但限額小，有些甚至完全無預警被退回。整個過程就像在玩一張起初全黑的地圖，一點一點探索通路、開通節點、註記跳板\n一次次的小額嘗試讓我慢慢拼湊出屬於我自己的可用資金路徑。隨著探索深入，我開始刻意繞開高手續費路徑，甚至在幣種兌換中也試圖利用波動換出一點浮盈\n有些一開始看起來「根本做不到」的事情，也在一次次嘗試與測試中漸漸被打通。像是透過虛擬貨幣交易所完成入金、在現實生活中直接使用虛擬貨幣、讓法幣自動轉換為穩定幣，或者使用專門的送金服務將資金匯往某些地區……這些方法繞過了傳統銀行體系，最終完成了原本被認為無法完成的目標\n這個過程，從「無解」到「打通」，就像是一場系統級網路架構的重建。我不是在單純轉帳，而是在重新定義一條資訊與價值的傳輸通路\n聽起來很複雜？但這不就是一個典型的系統流程設計題嗎：\n多個系統之間要如何建立連線、完成資料傳輸？ 不同格式（幣別）要怎麼轉換才能順利被識別？ 哪些節點是可靠的？哪些通路延遲低、失敗率小？ 如何將「資料包」（資金）透過合適的協定（出入金方式）送達最終節點（目標帳戶）？ 整個過程能不能讓用戶（也就是我）在體感上順暢無阻？ 說到底，這就是系統架構的感覺：你不是在堆疊功能，而是在設計一個清晰、穩定、可持續演進的結構網路\n每一張卡是一個節點；每一個匯款接口是一項協定；每一次路線的嘗試與調整，都是一次小規模的架構最佳化\n這背後說穿了就是：路徑規劃 + 接口適配 + 使用者體驗，這不就是系統架構師該做的事嗎？\n卡粉在玩的，從來不只是省錢，而是透過對現實金融網路的解構與重組，掌握系統級控制的樂趣與主導感\n5. 從卡粉中淬鍊出的架構素養 在一次次路徑選擇、失敗嘗試、成本權衡與風控試探中，卡粉其實也在鍛鍊一種架構思維。雖然沒有伺服器、沒有程式碼，但那種「為了結構穩定與效率美感而不斷打磨路徑」的過程，本質上就是一種系統設計能力的實踐\n這些實作經驗，不知不覺內化成了以下這幾類架構素養：\n能力 表現方式 核心精神 熟悉規則 銀行細則、限額通道 文件閱讀能力 整合能力 多卡串接與資金路徑整合 系統整合思維 成本意識 手續費最小化 效能／預算權衡 模型建構 規劃卡間流轉結構 架構建模能力 風控意識 多帳號、多備援設計 高可用性設計 審美追求 資金路徑也要優雅 工程美感 卡粉其實是在用現實世界，模擬訓練一個系統架構師該具備的思維模型\n6. 我的感悟 手續費是敵人，通道是信仰，路徑是藝術\n我之所以成為卡粉，不是因為熱衷刷卡，而是在一次次探索中感受到「結構之美」。也許我們沒有寫程式、沒有部署伺服器，但每一次資金的流動、每一條通路的設計，其實都蘊藏著系統性思考的影子\n從系統架構師的備考過程，到日常生活中設計自己的資金路徑，我漸漸意識到：\n我喜歡的不只是把事情做完，而是讓它的路徑設計得漂亮\n別人眼中的小聰明，是我心中的系統美學；\n別人眼中的羊毛黨，是我內心的生活架構師。\n卡粉不是單純為了省錢，更像是在現實中練習「系統設計」的能力：視覺化問題、逐步迭代、結構清晰、自我滿足\n這不是一種浪費時間，而是一種真實可觸、可日常實踐的「個人系統建構演練」\n卡粉不是在省錢，是在練手；架構不是在發明，是在選擇\n不論是在做架構設計還是在優化卡路徑，最重要的從來不是「能省多少」或「寫幾行程式」，而是那整個過程中，對系統、對結構，甚至對世界運行方式的理解與掌握\n而我，就是那個會在 ATM 前發呆 10 分鐘，只為算清哪條手續費路徑最優的生活架構師\n結語：生活就是最大的架構 我們每天刷卡、轉帳、判斷路徑、做出組合決策，其實就是在進行一場「無形的架構設計實踐」\n系統架構不只是伺服器與 API 的事，它也可能藏在我們的錢包、卡片選擇與支付策略之中\n卡粉的盡頭，也許就是一位生活中的系統架構師\n附錄：我的卡粉路徑偽代碼 這段程式碼並非真正的實作，而是我將現實中資金流轉路徑用架構思維重新建模的嘗試。它就像是一段可讀的生活流程圖，是我對每日卡片路徑操作背後邏輯的抽象化呈現\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // 我的主要跨境資金路徑設計（示意） func RouteCNYtoJPY(CNY float64) JPY float64 { HKD := BOCExchange(CNY, to=\u0026#34;HKD\u0026#34;) log.Printf(\u0026#34;Exchanged %.2f CNY to %.2f HKD\u0026#34;, CNY, HKD) Transfer(HKD, from=\u0026#34;BOC\u0026#34;, to=\u0026#34;BOCHK\u0026#34;, by=\u0026#34;pbservice\u0026#34;) log.Println(\u0026#34;Transferred via pbservice → BOCHK\u0026#34;) Transfer(HKD, from=\u0026#34;BOCHK\u0026#34;, to=\u0026#34;Wise\u0026#34;, by=\u0026#34;fpservice\u0026#34;) log.Println(\u0026#34;Transferred via fps → Wise\u0026#34;) JPY := WiseConvert(HKD, to=\u0026#34;JPY\u0026#34;) log.Printf(\u0026#34;Converted %.2f HKD to %.2f JPY via Wise\u0026#34;, HKD, JPY) Deposit(JPY, to=\u0026#34;Revolut\u0026#34;, with=\u0026#34;ApplePay\u0026#34;) return JPY } 這段偽代碼像是一座由邏輯堆疊出的通路結構，是我與系統架構師世界之間最自然而然的連接\n另註：本文僅為個人經驗與娛樂用途，並非任何財務或法律建議，請讀者自行判斷參考喔～\n","date":"2025-04-22T00:35:15+09:00","image":"https://github.com/yexca/picx-images-hosting/raw/master/2025/04-FromCardEnthusiastToArchitect/250422-TC.13lz2zi90i.webp","permalink":"https://blog.yexca.net/zh-tw/archives/245/","title":"從卡粉到架構師：生活中的系統設計哲學"},{"content":" 此頁面有使用機器翻譯喲\n2023 年 04 月，我開始記帳。2025 年 04 月，我停止了記帳。\n最後一筆記錄：¥0\n起點：為了省錢與掌控 起因很簡單——控制消費，提升金錢意識。剛開始的確非常有效，幫我遏制了一些不好的消費習慣。\n過程：一步步走向最優解與卡粉世界 但慢慢地，為了「更優」的消費，我開始比較、開始尋找最優解。最開始只是商品之間的比較，後來，是付款方式、支付工具，最後，進入了銀行優惠和開卡的世界。\n為了優惠而去開卡，為了便利而去開卡，但這玩意有點上頭，可以說我一步一步走向了卡粉的世界。\n一開始是為了省錢，後來是為了方便，最後——是為了集卡。\n反噬：記帳成為了負擔 於是，記帳本身，逐漸成了負擔。帳戶越來越多，場景越來越複雜，記帳的時間成本、心理成本，早已超過了實際收益。\n我常常為了可能只有幾塊錢的優惠，研究半天。剛開始當然開心，但多了之後，找到最優解不再讓我興奮，反而是一陣空虛取代了最初的喜悅。\n轉變：從最優解到舒服就好 也許是我變了，消費的心態也變了。\n從「按需按惠」，到「差不多就行，自己舒服就行」。\n我也發現，自己早就突破了原先設定的限額，卻沒有因此失控。反而越來越明白，比起省錢，時間和心情更重要。\n反思：我到底為什麼記帳？ 當我因為記帳，而開始：\n因為帳戶多而不斷翻找 因為貨幣轉換而頻繁在記帳軟體創建新帳號 因為商品該不該買而計較半天 因為和朋友出去遊玩消費而破壞心情 我不得不開始反思——我記帳，到底是為了什麼？\n這其中的收益，真的值得嗎？\n決定：放下，歸零，重新出發 於是我嘗試著放下，嘗試著不去管細節，只問自己：「我快樂嗎？」\n結果是——真的很快樂。而支出，也沒有想像中那麼高。\n或許，是習慣讓我潛移默化地比過價。或許，情緒的價值，本來就無法用優惠來衡量。\n所以，我想，是時候放手了。\n記帳，已經完成了它的使命。\n它不再是工具，而是成為了束縛。\n行為習慣是為了更好的生活，當它無法再靠熱情消解，當它反而阻礙了生活，那就該學會告別。\n尾聲：謝謝自己，繼續生活 雖然放棄了自己堅持了兩年的習慣，確實有些不捨。\n但這大概也是人生的一部分吧。沒有什麼可以陪伴一輩子，但只要在一起的那段時光是美好的，這，就足夠了。\n可以說我少了一個象徵性的「我很省」的工具。\n但，我更希望未來的自己，不再是靠數字和記錄來獲得安全感，而是靠真正的從容和自在。\n從可以掌控，到流入未知。\n希望自己能早點適應。\n希望能把省下來的時間，花在更有意義、更值得快樂的事情上。\n所以，\n最後一筆，¥0 附上一段小短文。\n謝謝這兩年認真記錄的自己。\n未來，希望把省下來的時間，花在更有意義、更快樂的事情上。\n就這樣，Archive 了這段經歷。\n記錄是結束，而生活才剛剛開始。\n","date":"2025-04-14T16:23:48+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/244/","title":"從省錢，到生活，再到告別"},{"content":" 此頁面有使用機器翻譯喲\n音之所感系列\n歌曲名稱 翻譯 連結 僕が死のうと思ったのは 曾經我也想過一了百了 https://blog.yexca.net/zh-tw/archives/214 あくあ色ぱれっと aqua 的調色板 https://blog.yexca.net/zh-tw/archives/219 恋の押し売り 戀愛推銷 https://blog.yexca.net/zh-tw/archives/220 17さいのうた 17 歲的歌曲 本文 引言 其實我一開始只是聽懂了有關「寫給自己的信」那部分，覺得跟我第一次聽到時的心情相當契合，所以就一直聽下去了。\n後來嘗試去翻譯這首歌，再加上最近的種種經歷，我感覺自己現在的狀態，好像跟ユイカ當時的情況很像。現在的我，就跟這首歌一樣，只有迷惘：究竟要成為什麼樣的人？未來會是什麼模樣？我又該往哪裡前進呢？\n正面一點，就像歌詞裡所說的，試著接受自己吧。離開那份迷惘，隨便找一件自己感覺喜歡的事情去做吧。\n最後，也想感謝一直鼓勵著我的人，以及那些雖然嘴上沒說鼓勵，但卻在行動上支持我的人。\n歌曲影片 歌詞 こんな私の未熟なうたを　聴いてくれてどうも有難うね 未熟: みじゅく\n感謝你來聽我還很青澀的歌\nもう少しで私は未熟な大人に　なるみたいです\n再過不久，我好像也要變成不成熟的大人了\nなんか笑っちゃうね\n總覺得有點好笑呢\n本当はね\n其實啊\nもっと前を向けるようなうたを　書くつもりだったけど\n本打算寫更加讓人積極的歌\n書けなくて\n卻怎麼也寫不出來\n私はまだ　他の誰かを支えられるほど\n我還沒有達到可以支撐別人的存在\n強くなかったみたい　ごめんね\n看起來並不怎麼要強，真是抱歉吶\n拝啓　未来の私へ　今そこで\n敬啟，未來的我啊，現在在那裡\nどんなことをして　生きていますか\n正做著什麼樣的事情，過著什麼樣的生活呢\n拝啓　今の私へ　今ここで\n敬啟，現在的我啊，現在在此刻\nどんなことをしたら　生きていけるんでしょうか\n我該做些什麼，才可以繼續活下去呢\n\u0026ldquo;好きだからかっこいい\u0026quot;とか　\u0026ldquo;そばにいる\u0026quot;とか\n曾經寫過「因為喜歡才覺得帥」、「想要待在身邊」\n\u0026ldquo;勝手に盗んだ\u0026quot;とか　書いてた\n還有「隨便就偷走你的心」之類的\nどうせだったらもうちょっと　貴方みたいに\n這樣的話，不如再向你\nやさしいうたを書けばよかったね\n寫首溫暖的歌就好了呢\n本当はね　好きなことだけして生きたいの\n其實啊，我只想做喜歡的事情吶\nでもそれは上手な生き方とは言えないから\n但那稱不上成熟的活法\n無駄になっても　意味がなくても\n即使顯得徒勞，毫無意義\n今はここから　離れなきゃいけないの　ごめんね\n現在還是不得不離開了，抱歉吶\n拝啓　未来の私へ　今そこで\n敬啟，未來的我啊，現在在那裡\nどんな大人になって　生きていますか\n變成了什麼樣的大人，過著什麼樣的生活呢\n拝啓　今の私へ　今ここで\n敬啟，現在的我啊，此刻在這裡\nどんな大人になりたいと　言えばいいんでしょうか\n說出「想要成為什麼樣的大人」可以嗎\n「さよなら」は悲しくなるからさ\n「再見」聽起來太悲傷了\n「またね」って言わせて\n請讓我說「下次見」吧\nいつか私が　今みたいな　うたを書けなくなっても\n就算未來哪天我寫不出來這樣的歌了\n怒らないでね\n也請不要怪我\n拝啓　過去の私へ　今の私は\n敬啟，過去的我啊，現在的我\nずっと夢見ていたこと叶えてるよ\n實現了一直以來的夢想喲\n拝啓　今の私へ\n敬啟，現在的我啊\nこんな情けない　うただって歌えばいいよ 情け: なさけ\n唱出這麼軟弱的歌也可以喲\nそれが私だから\n因為那就是我\n拝啓　未来の私へ　今そこは\n敬啟，未來的我啊，現在在那裡\nどんな綺麗な世界が　広がっていますか\n展開著怎樣絢麗多彩的世界呢\n拝啓　今の私へ　今ここが\n敬啟，現在的我啊，現在的時刻\nどんな世界よりも　幸せでした\n比任何世界都要幸福呀\nこんな私の未熟なうたを　聴いてくれてどうも有難うね\n感謝你來聽我還很青澀的歌\nこれから私は未熟な大人に　なる準備をします\n接下來我也要為成為不夠成熟的大人，而好好準備\n「じゃあ またね」\n「那麼，下次見」\n","date":"2025-01-25T16:57:49+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/224/","title":"音之所感 - 《17さいのうた》"},{"content":" 此頁面有使用機器翻譯喲\n音之所感系列\n歌曲名稱 翻譯 連結 僕が死のうと思ったのは 曾經我也想過一了百了 https://blog.yexca.net/zh-tw/archives/214 あくあ色ぱれっと aqua 的調色板 https://blog.yexca.net/zh-tw/archives/219 恋の押し売り 戀愛推銷 本文 17さいのうた 17 歲的歌曲 https://blog.yexca.net/zh-tw/archives/224 引言 其實早就翻譯了捏~(￣▽￣)~*\n歌曲影片 歌詞 ハートマーク作って\n畫個愛心的記號\n届け届け届け\n快一點、傳達到、你心裡\nきっと恋の押し売り\n這大概是戀愛的推銷\n好きで好きでごめん\n好喜歡，太喜歡，抱歉呀\n出会っちゃった！\n和你相遇了！\nときめいちゃった？ ときめく\n心跳加速了嗎？\n私だけ？ドキドキしてるの\n還是只有我？在砰砰心跳呢\nちゃんと気にかけて\n多多在意我啦\n私だけ！甘やかして\n只對我！好好寵愛吧\n(Ah)　君と話す理由欲しくて探している\n（啊）不斷尋找和你聊天的理由\n(なんで？)　強がっていても恋に負けちゃうんだね\n（為什麼？）就算裝作堅強，還是敗給了戀愛呀\nハートマーク作って\n畫個愛心的記號\n届け届け届け\n快一點、傳達到、你心裡\nきっと恋の押し売り\n這大概是戀愛的推銷\n好きで好きでごめん\n好喜歡，太喜歡，抱歉呀\nハートのレスください\n請回覆我的心意\n早く早く早くー！\n快一點、再快點、馬上做~！\nこれは恋の押し売り\n這可是戀愛的強制推銷\n返品なんてダメよ\n退貨？不可以！\n取られたくないんだよ…\n不想被搶走啊\u0026hellip;\n誰よりも可愛くなりたい\n想要變得比誰都可愛\n完全勝利して\n想完全勝利\n私だけって言わせてやる！\n讓你說出「只有我」！\n(Ah)　君の胸を狙う私の恋の銃口\n（啊）我的戀愛槍，瞄準著你的胸口\n(なんで？)　震えちゃうんだろう\n（為什麼？）會不由自主地顫抖呢\nいつか撃ち抜けるまで 撃ち抜く: うちぬく\n直到貫穿為止\nせーっの！BANG\n一、二、砰！\n期待させてよ\n讓我更加期待吧\nもっともっともっと\n多點、再多、更多\n私浮ついちゃって 浮つく: うわつく\n我有點飄飄然了\nバカだバカだごめん\n傻乎乎，真的是，抱歉呀\nハートは忙しくて\n心裡稍微有點忙\nあっちこっちどっちー？\n那裡？這裡？哪裡？\n今はまだまだプロローグ\n現在還只是序幕呢\n押して押して押すの\n按下去、快一點、去推進\n私、君に出会えて変わったの！\n我，和你遇見之後改變了！\nそりゃあ悩んじゃう事もあるけど…\n雖然也有會煩惱的時候。。。\nもっともっと可愛くなりたいって思うし\n但想要變得更加更加可愛\n何より君に好きって言ってもらいたい！\n沒有什麼比得上你對我說喜歡！\n笑顔の私(可愛い)\n笑著的我（可愛捏）\n泣いちゃう私(可愛い)\n哭著的我（可愛捏）\n怒った私(可愛い)\n生氣的我（可愛捏）\n恋する私…\n戀愛中的我。。。\n甘えさせてよ\n讓我撒嬌嘛\nずっとずっとずっと\n始終、一直、永遠\nきっと後悔させない\n一定不會讓你後悔的\nお願い　好きになって\n拜託了，喜歡我吧\nハートマーク作って\n畫一個愛心記號\n届け届け届け\n快一點、傳達到、你心裡\nきっと恋の押し売り\n大概是戀愛的小強推\n好きで好きでごめん\n喜歡你，超喜歡，抱歉呀\nハートのレスください\n請回覆我的心意\n早く早く早くー！\n快一點、再快點、馬上要！\nこれは恋の押し売り\n這可是戀愛的強制推銷\n返品なんてダメよ\n不可以、退貨哦\n","date":"2025-01-20T16:24:43+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/220/","title":"音之所感 - 《恋の押し売り》"},{"content":" 此頁面有使用機器翻譯喲\n音之所感系列\n歌曲名稱 翻譯 連結 僕が死のうと思ったのは 曾經我也想過一了百了 https://blog.yexca.net/zh-tw/archives/214 あくあ色ぱれっと aqua 的調色板 本文 恋の押し売り 戀愛推銷 https://blog.yexca.net/zh-tw/archives/220 17さいのうた 17 歲的歌曲 https://blog.yexca.net/zh-tw/archives/224 引言 第二首本來想選我的 2024 年度歌曲，不過不經意間聽到了 Aqua 的歌，便想到了這首，之前聽的時候只是中間的有一段和我的人生經歷有點類似，所以一直在聽，全曲認真翻譯後才知道染上 Aqua 顏色的梗從這裡來的啊（在 C105 聽到「想染上 aqua 的顏色的話」，還以為是來自《君色に染まる》）\n雖然經歷類似讓我開始慢慢聽上 Aqua 且慢慢喜歡上，但事實上我的「キミがいるから私　いつでも頑張れるんだ」是 Warma 捏，寫到這突然就意識到了一直在影響著我的到底是什麼了，以及如今是為何這樣，不過正如因這首歌的改變，當前的困惑也一定有契機可以化解\n我很克制得沒寫下去，畢竟是一首歡樂的歌，可以說對於偶像路線簡直是太絕了這首歌，同時用詞倒也不是太難（相對於外國人），是我都可以聽懂的程度（doge）\n因為我是去年（2024）接觸到 Aqua 的嘛，因為經常聽到這首歌（3D 直播），還以為是經歷了一些沉澱，然後出了這麼厲害的歌（因為一直在收聽榜第一），沒想到是出道即巔峰啊（《For the Win》是 bilibili 企劃的，暫且不記上），同時之後的歌曲，怎麼說呢，偶像類的都很好，可以說是直接讓我開始喜歡一些偶像風了，以此為契機，倒是喜歡上了偶像演唱會（雖然隨著 Aqua 的畢業也不怎麼感興趣了）\n同時，對比其他翻譯可能有出入，我的翻譯多數是有自己的感情吧，所以部分並不是歌詞本身的意思（事實上 上一首 也是），這個在可能下一个 2024 年度歌曲的翻譯中表現更明顯。我覺得如果只是照抄一個標準的翻譯多少沒啥意義，因為是真正熱愛的事物，多少想留存自己的特色 (染上我的色彩)\n最後捏，我也想染上 Aqua 的色彩捏，畢竟是我最愛的三個人之一 （C105 沒買到立牌真可惜了，結城的也沒買到（悲\n歌曲影片 歌詞 何をしても不器用で　何かとミスしてばっか\n什麼也做不到，做什麼都出錯\nダメダメな私だって\n一無是處的我\nできる事があるの\n也有可以做到的事喔\n凹んで悲しくたって　笑顔にしてあげるんだ 凹む: へこむ\n就算陷入低落，我也會讓你笑起來喔\nここにいるから　早く　私を見つけてね\n因為就在這裡，快一點，找到我吧\nLove You Love You, I love you\n愛你愛你，我愛你\nLove You Love You, Ah,I love you so much\n愛你愛你，我非常愛你\nLove You Love You, I love you\n愛你愛你，我愛你\nLove You Love You\n愛你愛你\n（あぁ　愛してもっと）\n(啊~，更加愛我吧)\nいつでも隣にいるし、いつでも一緒に笑える\n一直都陪在身邊，一直都一起歡笑\n私をたくさん知って　たくさん好きって言って\n多多了解我，多多對我說“喜歡”\nワガママで朝も苦手　ドジだし　ダメダメだけど\n任性也賴床，笨手笨腳還一無是處\nそれでも私の事を　見ててね\n就算那樣也請專注於我\n描く夢の未来へ続く\n向著描繪未來的路\n道をキミと歩けますように\n希望能和你一起走下去\nねぇもっと！好きになってもらいたいの！\n呐，想讓你多多喜歡我！\n頭の中は君ばっか！\n我的腦海裡只有你\nってゆーかそっぽなんて向いてないで！\n話說，別把頭轉開呀！\nあぁもう！ヤキモキしちゃうわ　Ah\n啊啊，真是的！急死人了\nずっとずっと好きがいいの\n一直一直喜歡下去吧\n心の奥もトキメイちゃうくらい\n內心深處都怦然心動的程度\nこっち向いててよね　ダーリン？\n看看我嘛，親愛的？\nあぁもう離さないから、絶対に！\n啊~，再也不會放開你，絕對不會！\nLove You Love You, I love you\n愛你愛你，我愛你\nLove You Love You\n愛你愛你\n（あぁ　愛してもっと）\n(啊~，多多愛我吧)\nキミがいるから私　いつでも頑張れるんだ\n因為有你在身邊，我才能努力下去\n落ち込んで悲しくたって　キミがいるから\u0026hellip;\n就算低落悲傷，因為有你在身邊。。。\nキミがいるから　歩いてこれた\n正因為有你在，我才能走到今天\nキミがいなくちゃ　前も見れない\n如果沒有你，我連前方也看不清\n嫌な事とか辛い事とかあったって\n即使有討厭的，痛苦的事\nキミの力でここまで笑ってこれたんだ\n有你的力量就可以笑著走到現在\n今度はもっと私がぐっとひっぱって　連れて行くんだ\n這次我會更加努力拉著你，一起走下去\nキミがいるから私がいるの\n因為有你在，我才能到這\nこんな私を　愛してくれる？\n你願意愛上這樣的我嗎？\nねぇもっと　ねぇもっと\n呐，多一點，再多點\nまだもっと　受け止めてよね！ねぇいい？\n更多地接受我吧！可以嗎？\nさぁ声を上げて！\n那麼，大聲地說出來吧！\nねぇもっと　ねぇもっと\n呐，多一點，再多點\n好きになってもらいたいの\n想讓你喜歡上我\nいつでも　そう私ばっか みたいにそっぽなんて向かせないわ\n無論何時，我都不允許你把目光移開，只讓我在你心裡\nね、ほら夢中にしちゃうわ　Ah\n呐，看到了吧，已經沉迷了呢~\nずっとずっと好きがいいの！心も体も染まっちゃうくらいに\n一直一直喜歡下去吧，直到你的身心都染上我的色彩\nこっち向いててよねダーリン?\n看向這邊呀，親愛的？\nあぁもう離さないから、絶対に　絶体ね　絶体よ　約束だよ\n啊~，我不會放開你，一定不會、肯定不會、絕對不會，約好了喔\n（あぁ 愛してもっと）\n(啊~，更多地愛我吧)\n","date":"2025-01-20T00:16:48+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/219/","title":"音之所感 - 《あくあ色ぱれっと》"},{"content":" 此頁面有使用機器翻譯喲\n音之所感系列\n歌曲名稱 翻譯 連結 僕が死のうと思ったのは 曾經我也想過一了百了 本文 あくあ色ぱれっと aqua 的調色板 https://blog.yexca.net/zh-tw/archives/219 恋の押し売り 戀愛推銷 https://blog.yexca.net/zh-tw/archives/220 17さいのうた 17 歲的歌曲 https://blog.yexca.net/zh-tw/archives/224 引言 有沒有一種聽力材料，可以讓人不是處於學習的狀態，可以反覆聽，並可以嘗試影子跟讀的呢？這不就是歌曲嗎！\n考慮到我聽歌時只是部分能聽懂，如果深入分析了解歌詞的話，說不定真的可以當成對語言的練習了\n第一首就從一首雖然有點沉重，但可以說陪伴了我大部分時間，我可以百聽不厭的歌曲開始吧\n歌曲影片 歌詞 僕ぼくが死しのうと思おもったのは　ウミネコが桟さん橋ばしで鳴ないたから\n我之所以想過一了百了，是因為黑尾鷗在碼頭啼鳴\n波なみの随意ずいいに浮うかんで消きえる　過去かこも啄ついばんで飛とんでいけ\n隨波浮沉又消逝，連過去也一併啄起飛向遠方\n僕ぼくが死しのうと思おもったのは　誕生日たんじょうびに杏あんずの花はなが咲さいたから\n我之所以想過一了百了，是因為生日時杏花開了\nその木こ漏もれ日びでうたた寝ねしたら　虫むしの死し骸がいと土つちになれるかな\n在那灑落的日影下小憩，是否能化作蟲的遺骸與黃土呢\n薄荷はっか飴あめ　漁港ぎょこうの灯台とうだい　錆さびたアーチ橋ばし　捨すてた自転車じてんしゃ\n薄荷糖、漁港的燈塔、生鏽的拱橋、被拋棄的自行車\n木造もくぞうの駅えきのストーブの前まえで　どこにも旅たび立だてない心こころ\n木造車站爐火前，踏不出旅途的心\n今日きょうはまるで昨日きのうみたいだ　明日あすを変かえるなら今日きょうを変かえなきゃ\n今天就好像昨天一樣，想改變明天的話要從今天開始\n分かってる　分かってる　けれど\n我知道啊，我明白啊，可是。。。\n僕ぼくが死しのうと思おもったのは　心こころが空からっぽになったから\n我之所以想過一了百了，是因為內心已經空寂了\n満みたされないと泣ないているのは　きっと満みたされたいと願ねがうから\n因空虛而哭泣，無非是渴望被填滿\n僕ぼくが死しのうと思おもったのは　靴紐くつひもが解ほどけたから\n我之所以想過一了百了，是因為鞋帶鬆開了\n結むすびなおすのは苦手にがてなんだよ　人ひととの繋つながりもまた然しかり\n重新繫上很麻煩，人際關係也同樣如此\n僕ぼくが死しのうと思おもったのは　少年しょうねんが僕ぼくを見みつめていたから\n我之所以想過一了百了，是因為少年注視著我\nベッドの上うえで土下座どげざしてるよ　あの日ひの僕ぼくにごめんなさいと\n在床上向我土下座，對那天的自己說抱歉\nパソコンの薄うす明あかり　上階じょうかいの部屋へやの生活音せいかつおん\n電腦螢幕的微光，上層房間的生活聲\nインターフォンのチャイムの音おと　耳みみを塞ふせぐ鳥とりかごの少年しょうねん\n門鈴的聲音，捂住耳朵的籠中少年\n見みえない敵てきと戦たたかってる　六畳ろくじょう一間ひとまのドンキホーテ\n在六坪房間的堂吉訶德，與無形之敵在戰鬥著\nゴールはどうせ醜みにくいものさ\n終點反正是醜陋的\n僕ぼくが死しのうと思おもったのは　冷つめたい人ひとと言いわれたから\n我之所以想過一了百了，是因為被人說成冷漠無情\n愛あいされたいと泣ないているのは　人ひとの温ぬくもりを知しってしまったから\n因渴望被愛而哭泣著，是因為已經嘗過人間冷暖\n僕ぼくが死しのうと思おもったのは　あなたが奇麗きれいに笑わらうから\n我之所以想過一了百了，是因為你的笑容如此溫暖\n死しぬことばかり考かんがえてしまうのは　きっと生いきる事ことに真面目まじめすぎるから\n總想着死亡，一定是活得太認真了吧\n僕ぼくが死しのうと思おもったのは　まだあなたに出会であってなかったから\n我之所以想過一了百了，是因為未曾遇見你\nあなたのような人ひとが生うまれた　世界せかいを少すこし好すきになったよ\n正因為有你這樣的人會誕生，才會有點喜歡這個世界\nあなたのような人ひとが生いきてる　世界せかいに少すこし期待きたいするよ\n正因為有你這樣的人存在著，才會對世界有些許期待\n","date":"2025-01-11T01:10:51+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/214/","title":"音之所感 - 《僕が死のうと思ったのは》"},{"content":" 此頁面有使用機器翻譯喲\n引言 今天想對最近設計的半透明、毛玻璃和圓角進行總結，突然想到 2023-12-01 好像做過一個什麼東西，就順便重整一下好了\n頁面背景 現代的 (二次元) 網頁要有一個背景\n1 2 3 4 5 6 7 8 body{ background-image: url(\u0026#39;../img/77194247_p0.jpg\u0026#39;); background-size: cover; background-attachment: fixed; /* 固定 */ background-repeat: no-repeat; /* 不重複 */ padding: 0; margin: 0; } 半透明與毛玻璃 然後在背景上加一個蒙版，實現半透明與毛玻璃效果\n1 2 3 4 5 6 7 8 9 10 11 .layout { /* display: flex; */ margin: 0; padding: 0; display: flex; width: 100vw; height: 100vh; backdrop-filter: blur(2px); /* 背景模糊效果 */ -webkit-backdrop-filter: blur(2px); /* Safari 支援 */ background: rgba(0, 0, 0, 0.4); /* 半透明黑色背景 */ } 網頁的重構 說起來寫文章還是很傷腦筋，做的時候寫會被打斷，做完再寫又會很累不想動，所以我就折衷一下，隨便寫寫就好\n專案地址: https://github.com/yexca/MusicPlayer-Twinkle 順便更新了之前的文章 (簡體中文) https://blog.yexca.net/archives/116/ 用這個方法加了一個範例: https://twinkle.yexca.net 卡片效果 這也屬於現代的設計\n1 2 3 4 5 6 7 8 9 10 .card { width: 300px; padding: 20px; background-color: rgba(255, 255, 255, 0.5); /* 半透明白色背景 */ border-radius: 15px; /* 圓角 */ box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); /* 陰影 */ backdrop-filter: blur(10px); /* 背景模糊效果 */ border: 1px solid rgba(255, 255, 255, 0.3); /* 邊框 */ color: pink; /* 前景文字顏色 */ } 嗯，之後有時間再以卡片為設計來完善這個專案 (又開新坑了)\nTwinkle 另外，專案的內容是 Twinkle 的音樂，具體介紹請參閱\nhttps://twinkle130527.wixsite.com/twinkle https://www.dojin-music.info/circle/1255 SoundCloud\nhttps://soundcloud.com/twintwinkles ","date":"2025-01-05T16:19:36+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/212/","title":"毛玻璃效果"},{"content":" 該文章使用 Google 翻譯處理。\nRedis 是一個基於記憶體的鍵值結構資料庫，是互聯網技術領域使用廣泛的儲存中間件\n官網： https://redis.io 簡體中文網： https://www.redis.net.cn/ Redis 基於記憶體存儲，讀寫效能高，適合儲存熱點資料 (商品、資訊、新聞) 。是用 C 語言開發的一個開源的高效能鍵值對資料庫，儲存 value 類型比較豐富，也被稱為結構化的 NoSql (Not Only SQL) 資料庫\nNoSql 泛指非關係型資料庫，不是要取代關係型資料庫，而是關係型資料庫的補充\n關係型資料庫 (RDBMS)：\nMySQL Oracle DB2 SQLServer 非關係型資料庫 (NoSQL)：\nRedis Mongo DB MemCached Redis 下載安裝與執行 下載地址：\nWindows: https://github.com/microsoftarchive/redis/releases Linux: https://download.redis.io/releases/ cn: http://www.redis.cn/download.html Windows 版直接解壓縮即可使用，Linux 版：\n解壓縮 tar -zxvf redis-4.0.0.tar.gz -C /usr/local 安裝依賴環境 yum install gcc-c++ 進入安裝目錄，編譯 make 進入 redis 的 src 目錄安裝 make install 相關文件說明：\n/usr/local/redis-4.0.0/src/redis-server：Redis 服務啟動腳本 /usr/local/redis-4.0.0/src/redis-cli：Redis 客戶端腳本 /usr/local/redis-4.0.0/redis.conf：Redis 設定檔 服務端啟動，以 Windows 版為例，啟動命令：\n1 redis-server.exe redis.windows.conf 默認端口號為 6379，默認無密碼，啟動完成後可以用客戶端連接\n命令行連接 通過 redis-cli.exe 進行連接\n1 redis-cli.exe -h ip -p port -a password 如果省略，則使用 127.0.0.1:6379\n可以通過修改配置文件 (redis.windows.conf) 設置密碼\n1 requirepass 123456 修改完成後重啟生效\n圖形化連接 Github： https://github.com/qishibo/AnotherRedisDesktopManager 下載安裝後新建連接，輸入相關信息後連接即可\nDocker 部署 拉取鏡像\n1 docker pull redis 獲取配置文件，下載對應版本，抽取配置文件即可，Linux 為 redis.conf\n創建 Redis 數據映射文件夾，例如\n1 2 mkdir /home/redis mkdir /home/redis/data 修改配置文件，傳送至部署機子，例如使用 scp 從 Win 傳至 Linux\n1 scp pathOfFile root@IP:/PathOfFile 啟動\n1 docker run -p 6379:6379 --name redis -v /home/redis/redis.conf:/etc/redis/redis.conf -v /home/redis/data:/data -d redis redis-server /etc/redis/redis.conf 參考資料： https://cloud.tencent.com/developer/article/1670205 Redis 數據類型 Redis 的 key 是字符串類型，value 有 5 種常用的數據類型\n字串 (string)：普通字串 哈希 (hash)：也叫散列 清單 (list)：依插入順序排序，可以有重複元素 集合 (set)：無序集合，不允許重複元素 有序集合 (sorted set/zset)：集合中每個元素關聯一個分數 (score)，根據分數升序排序 Redis 常用命令 Redis 大小寫不敏感\n字符串操作常用命令：\n1 2 3 4 5 6 7 8 # 設置指定 key 值 SET key value # 獲取指定 key 值 GET key # 設置指定 key 值，並將 key 的過期時間設為 seconds 秒 SETEX key seconds value # 只在 key 不存在時才設置 key 的值 SETNX key value hash 是一個 string 類型的 field 和 value 映射表，特別適合存儲對象，常用命令：\n1 2 3 4 5 6 7 8 9 10 # 將哈希表 key 中的 field 值設為 value HSET key field value # 取得儲存在哈希表中指定欄位的值 HGET key field # 刪除儲存在哈希表中的指定字段 HDEL key field # 獲取哈希表中所有字段 HKEYS key # 獲取哈希表中所有值 HVALS key 列表是簡單的字符串列表，按照插入順序排列，常用命令：\n1 2 3 4 5 6 7 8 9 10 11 # 將一個或多個值插入到清單頭部 LPUSH key value1 [value2] # 取得清單指定範圍內的元素 LRANGE key start stop # 移除並取得清單最後一個元素 RPOP key # 取得清單長度 LLEN key # 移出並取得清單的最後一個元素 # 如果清單沒有元素會阻塞清單直到等待逾時或發現可彈出元素為止 BRPOP key1 [key2] timeout 類似隊列，先進先出\n集合是字串型別的無序集合，集合成員唯一，常用指令：\n1 2 3 4 5 6 7 8 9 10 11 12 # 在集合中新增一個或多個成員 SADD key member1 [member2] # 傳回集合中的所有成員 SMEMBERS key # 取得集合的成員數 SCARD key # 傳回給定所有集合的交集 SINTER key2 [key2] # 傳回所有給定集合的並集 SUNION key1 [key2] # 移除集合中一個或多個成員 SREM key member1 [member2] 有序集合是字符串類型元素的集合，每個成員關聯一個 double 類型的分數，常用命令：\n1 2 3 4 5 6 7 8 # 在有序集合中新增一個或多個成員 ZADD key score1 member1 [score2 member2] # 透過索引區間傳回有序集合中指定區間內的成員 ZRANGE key start stop [WITHSCORES] # 有序集合中對指定成員的分數加上增量increment ZINCRBY key increment member # 移除有序集合中的一個或多個成員 ZREM key member1 [member2] 除了各數據類型專有，還有通用命令，即所有類型都可以使用的命令：\n1 2 3 4 5 6 7 8 # 尋找所有符合給定模式(pattern)的key KEYS pattern # pattern可以為* # 檢查指定key是否存在 EXISTS key # 傳回key所儲存的值的類型 TYPE key # 在key存在時刪除key DEL key 在 Java 中操作 Redis 如同使用 JDBC 操作 MySQL 資料庫一樣，需要使用 Redis 的 Java 用戶端進行操作 Redis\nRedis 的 Java 客戶端很多，常用的幾種：\nJedis Lettuce Spring Data Redis Jedis 封裝最好，與Redis 命令相同，是官方推薦；Lettuce 對線程呼叫更好，性能更好；Spring 對Redis 客戶端進行了整合，提供了Spring Data Redis，在Spring Boot 專案中還提供了對應的Starter，即spring-boot-starter-data-redis\nspring data Redis Spring Data Redis 是 Spring 的一部分，提供了在 Spring 應用中透過簡單的配置就可以存取 Redis 服務，對 Redis 底層開發包進行了高度封裝。在 Spring 專案中，可以使用Spring Data Redis來簡化 Redis 操作。網址： https://spring.io/projects/spring-data-redis Maven 座標：\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-data-redis\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; Spring Data Redis 中提供了一個高度封裝類 RedisTemplate 對相關 api 進行了歸類封裝，將同一類型的操作封裝為 operation 接口：\nValueOperations：string 資料操作 SetOperations：set 類型資料操作 ZSetOperations：zset 類型資料操作 HashOperations：hash 類型的資料操作 ListOperations：list 類型的資料操作 配置 Redis 資料來源，設定文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # application spring: profiles: active: dev redis: host: ${sky.redis.host} port: ${sky.redis.port} password: ${sky.redis.password} database: ${sky.redis.database} # -dev sky: redis: host: localhost port: 6379 password: 123456 # 使用哪個資料庫，不填預設為 0 database: 10 Redis 預設有 16 個資料庫 (0-15)，可以透過修改設定檔來指定資料庫的數量\n編寫配置類，建立 RedisTemplate 對象\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 @Configuration @Slf4j public class RedisConfiguration { @Bean public RedisTemplate redisTemplate(RedisConnectionFactory redisConnectionFactory){ log.info(\u0026#34;開始創建 Redis 對象\u0026#34;); RedisTemplate redisTemplate = new RedisTemplate(); // 設定 redis 的連接工廠對象 redisTemplate.setConnectionFactory(redisConnectionFactory); // 設定 redis key 的序列化器 redisTemplate.setKeySerializer(new StringRedisSerializer()); return redisTemplate; } } 此配置類別不是必須的，SpringBoot 框架會自動組裝 RedisTemplate 對象，不過預設的序列化器為 JdkSerializationRedisSerializer，儲存到 Redis 中的資料與原始資料有差別\n字串類型數據 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @SpringBootTest public class RedisTest { @Autowired private RedisTemplate redisTemplate; @Test public void testString(){ // set redisTemplate.opsForValue().set(\u0026#34;name\u0026#34;, \u0026#34;Tom\u0026#34;); // get String name =(String) redisTemplate.opsForValue().get(\u0026#34;name\u0026#34;); System.out.println(name); // setex redisTemplate.opsForValue().set(\u0026#34;code\u0026#34;, \u0026#34;1234\u0026#34;, 2, TimeUnit.MINUTES); // setnx redisTemplate.opsForValue().setIfAbsent(\u0026#34;lock\u0026#34;,\u0026#34;1\u0026#34;); redisTemplate.opsForValue().setIfAbsent(\u0026#34;lock\u0026#34;,\u0026#34;2\u0026#34;); } } 哈希類型數據 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @Test public void testHash(){ HashOperations hashOperations = redisTemplate.opsForHash(); // hset hashOperations.put(\u0026#34;100\u0026#34;, \u0026#34;name\u0026#34;, \u0026#34;Jerry\u0026#34;); hashOperations.put(\u0026#34;100\u0026#34;, \u0026#34;age\u0026#34;, \u0026#34;20\u0026#34;); // hget String name =(String) hashOperations.get(\u0026#34;100\u0026#34;, \u0026#34;name\u0026#34;); System.out.println(name); // hkeys Set keys = hashOperations.keys(\u0026#34;100\u0026#34;); System.out.println(keys); // hvals List values = hashOperations.values(\u0026#34;100\u0026#34;); System.out.println(values); // hdel hashOperations.delete(\u0026#34;100\u0026#34;, \u0026#34;name\u0026#34;); } 列表類型數據 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Test public void testList(){ ListOperations listOperations = redisTemplate.opsForList(); // lpush listOperations.leftPushAll(\u0026#34;mylist\u0026#34;, \u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;); listOperations.leftPush(\u0026#34;mylist\u0026#34;, \u0026#34;d\u0026#34;); // lrange List mylist = listOperations.range(\u0026#34;mylist\u0026#34;, 0, -1); System.out.println(mylist); // rpop listOperations.rightPop(\u0026#34;mylist\u0026#34;); // llen Long size = listOperations.size(\u0026#34;mylist\u0026#34;); System.out.println(size); } 集合類型數據 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 @Test public void testSet(){ SetOperations setOperations = redisTemplate.opsForSet(); // sadd setOperations.add(\u0026#34;set1\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;,\u0026#34;c\u0026#34;,\u0026#34;d\u0026#34;); setOperations.add(\u0026#34;set2\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;,\u0026#34;x\u0026#34;,\u0026#34;y\u0026#34;); // smembers Set members = setOperations.members(\u0026#34;set1\u0026#34;); System.out.println(members); // scard Long size = setOperations.size(\u0026#34;set1\u0026#34;); System.out.println(size); // sinter Set intersect = setOperations.intersect(\u0026#34;set1\u0026#34;, \u0026#34;set2\u0026#34;); System.out.println(intersect); // sunion Set union = setOperations.union(\u0026#34;set1\u0026#34;, \u0026#34;set2\u0026#34;); System.out.println(union); // srem setOperations.remove(\u0026#34;set1\u0026#34;, \u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;); } 有序集合類型數據 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Test public void testZset(){ ZSetOperations zSetOperations = redisTemplate.opsForZSet(); // zadd zSetOperations.add(\u0026#34;zset1\u0026#34;, \u0026#34;a\u0026#34;, 10); zSetOperations.add(\u0026#34;zset1\u0026#34;, \u0026#34;b\u0026#34;, 12); zSetOperations.add(\u0026#34;zset1\u0026#34;, \u0026#34;c\u0026#34;, 9); // zrange Set zset = zSetOperations.range(\u0026#34;zset1\u0026#34;, 0, -1); System.out.println(zset); // zincrby zSetOperations.incrementScore(\u0026#34;zset1\u0026#34;, \u0026#34;c\u0026#34;, 10); // zrem zSetOperations.remove(\u0026#34;zset1\u0026#34;, \u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;); } 通用命令操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @Test public void testCommon(){ // keys Set keys = redisTemplate.keys(\u0026#34;*\u0026#34;); System.out.println(keys); // exists Boolean name = redisTemplate.hasKey(\u0026#34;name\u0026#34;); System.out.println(name); // type for (Object key : keys) { DataType type = redisTemplate.type(key); System.out.println(type.name()); } // del redisTemplate.delete(\u0026#34;set2\u0026#34;); } ","date":"2024-02-23T16:40:34+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/157/","title":"Redis"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 前言 最近？拜讀了《漫畫數位電路》一書，在此簡要記錄。\n書中許多內容並未收錄於此。\n前情提要 數位電路分為 組合電路 與 時序電路。\n組合電路：由目前輸入資訊的組合決定輸出的電路。\n時序電路：帶有「記憶」的電路。\nMIL 符號 邏輯電路的 及閘 與 或閘 符號引申為多個輸入一個輸出。\n符號含義 及閘 (ALL)：多個輸入全為 1，輸出為 1。\n或閘 (EXIST)：若有一個輸入為 1，輸出為 1。\n電路線 有 圓圈 的為 低電位 (0、L)。\n無 圓圈 的為 高電位 (1、H)。\n組合電路的製作 多數決投票電路 多位投票人從兩個結果中選出一個。\n列出真值表，即所有可能發生的情況。\n在真值表 H 輸出處加上底線。\n「輸入線」與「將輸入取反的線」架設框架。\n兩條向下的電路線，第二條為反相線，即從第一條連接 反閘 到第二條。\n連接到 AND (及閘)\n輸入為 L 時，從將輸入取反處開始 (第二列)。\n輸入為 H 時，從最開始的地方畫線 (第一列)。\n然後，接入 AND。\n重複此過程，完成第二步所畫的所有線。\n將 AND 的所有輸出連接到 OR。\n電路的化簡 數位電路設計流程：釐清問題 - 真值表 - 化簡 - 繪製電路。\n透過 卡諾圖 進行化簡。\n真值表轉換為卡諾圖。\n製作真值表時，欄位從最高位元開始，例如 [C、B、A]，結果為 Z。\n卡諾圖是二維的真值表，通常用 0 與 1 表示電位。\n如果三個輸入，可以將行設為 B、A，列設為 C，然後將結果填入二維表。\n化簡前須知\n卡諾圖的 左右 與 上下 都是相連的，因為卡諾圖的橫向與縱向都是按 位元 (1 位) 變化的。\n化簡\n將相鄰的 1 劃分為一個集合。\n尋找行與列的共同點。\n若共同點為某值為 0，則使用 負運算 (或反運算)，即字母上方加一橫槓。\n範例\nC\\BA 00 01 11 10 0 1 1 1 上表中 共同點為 C 為 0，A 為 1，則運算式為 !C * A。 化簡的規則 集合的形狀只能是長、寬為 1、2、4 的矩形 (或正方形)。\n集合可以相互重疊。\n集合的個數越少，面積越大越好。\n註：左右和上下可以構成一個集合；如果無法進一步「形成集合」，則表示電路已無法再化簡。\n化簡後繪製電路圖，只需將所有運算式依照上一步驟的繪圖步驟 (從第三步開始) 進行即可。\n電路的忽略 在剛開始確定輸入時，因為二進位數的特性，可能會有一些不需考慮的輸入。\n例如輸入為月份，需要使用四位二進位數，總共有 16 個輸入，其中 0、13、14、15 均為不需考慮的輸入。\n這類輸入在卡諾圖中可以使用 - 代替，可以納入集合進行化簡。\n時序電路的製作 時序電路需要 組合電路 與 觸發器。\n關於 時序電路 的「記憶」，例如自動販賣機在投幣時會記錄目前投幣總數，若無記憶，則僅有最後一個硬幣的面額。\n引入一個觸發器，例如 時脈 (CLK)，僅在 CLK 觸發時，輸入才會對輸出有影響，否則輸出保持不變。\n以繪製電子骰子為例。\n繪製狀態轉移圖\n隨著時間的變化，電子骰子如何變化？\n若停止為低電位，從 1 開始到 6 再到 1。\n如果為高電位，則在某點一直保持停止。\n用二進位數來表示狀態\n將每種情況或者說狀態使用二進位表示，然後繪製出 狀態轉移表。\n透過狀態轉移表繪製電路，可以使用 D 觸發器儲存狀態。\n設計組合電路\n從 目前的狀態 決定 下一個狀態，實際上就是 組合電路。\n","date":"2022-12-04T16:54:29+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/80/","title":"歐姆社漫畫數位電路讀後"},{"content":" 📢 本文由 gemini-2.5-flash-lite 翻譯 使用 Windows11 部署，其他系統 (如 Linux ) 請參考： AUTOMATIC1111/stable-diffusion-webui: Stable Diffusion web UI 空間佔用 程式：5.3GiB (不含模型)\n運行：5.5GiB 以上\n請確保 C 碟空間至少 6GiB 再運行，否則電腦可能黑屏卡死\n環境 首先是網路環境，請確保連接上網際網路\nGit\n官網： https://git-scm.com/ Python 3.10.6 以上 (最新版本可能不穩定)\n建議 3.10.8： https://www.python.org/downloads/release/python-3108/ 勾選 Add python.exe to PATH\n模型下載\n官方模型 (偏寫實)\n透過磁力下載（請使用正規種子客戶端）\n1 magnet:?xt=urn:btih:3a4a612d75ed088ea542acac52f9f45987488d1c\u0026amp;dn=sd-v1-4.ckpt\u0026amp;tr=udp%3a%2f%2ftracker.openbittorrent.com%3a6969%2fannounce\u0026amp;tr=udp%3a%2f%2ftracker.opentrackr.org%3a1337 其他下載方式\n訪問 AUTOMATIC1111/stable-diffusion-webui Wiki Waifu 模型(二次元啦)\n訪問 hakurei/waifu-diffusion-v1-3 at main 選擇下載\n其他\nStable Diffusion Models (cyberes.github.io) 克隆倉庫 選擇一個合適的位置，右鍵選擇 在終端機中開啟 ，然後輸入以下指令\n1 git clone https://github.com/AUTOMATIC1111/stable-diffusion-webui.git 更新時可以進入該目錄 (stable-diffusion-webui) 後使用 git pull 指令\n設定 將下載的模型放入 /models/Stable-diffusion 目錄\n設定 /webui-user.bat 檔案 在set VENV_DIR= 後任意輸入字串，然後儲存退出\n運行 /webui-user.bat 檔案\n下載檔案過大 (6GiB 左右) ，可能會運行較長時間，期間無進度條提示（若感覺程式終止之類的，可透過網路頻寬使用情況以判斷是否正在下載）\n如果您的顯示卡是 GTX1660 或者算出來的圖是黑色的\n編輯 webui.bat ，在開頭加入以下文字\n1 set COMMANDLINE_ARGS=--precision full --no-half 其他 詳細了解： hua1995116/awesome-ai-painting: AI绘画资料合集（包含国内外可使用平台、使用教程、参数教程、部署教程、业界新闻等等） stable diffusion tutorial、disco diffusion tutorial、 AI Platform 訓練模型： NovelAI hypernetwork 自訓練教程 - 知乎 NovelAI軟體獲取 - novelai 資源站 咩小咩壁紙|NovelAI資源站 關鍵字例子\n1 2 NSFW, Prhololive, uruha_rushia, 1girl, bangs, bare shoulders, red eyes, blue dress, blue green hair, blue sleeves, blush, bow, breasts, chick, collarbone, detached collar, detached sleeves, double bun, eyebrows visible through hair, frills, hair orhament, medium hair, off-shoulder dress 參考文章 最火的AI绘画教程！免费开源，包教会 - 零度解说 【心得】(NSFW) AI 色圖製作體驗 + 關鍵字 @場外休憩區 哈啦板 - 巴哈姆特 ","date":"2022-10-30T16:23:07+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/77/","title":"NovelAI 繪圖 (WebUI)"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 引言 人嘛，有了比較好的就會追求更好的，慾望無窮無盡。本想弄台 NAS，奈何經濟實力不夠，於是透過四個專案在自己電腦弄了入口、動畫、漫畫以及音聲庫，那麼\n承接 上回 ，繼續折騰\n成品展示 全部使用 Docker 部署，理論上應該只要 Docker 支援的平台就能復現\n調整了網域為 link.start.icu，本來沒有 .icu，但瀏覽器無法解析，只能加上 (不過莫名變更好了吧)\n手機訪問圖片顯示中間的 (有一點不太理想)\n有時間把這東西部署到伺服器上搞個導航吧 (不過標題不能直接改有點麻煩，不想弄 JS)\n註：使用 Docker Desktop 部署，所以就沒有寫部署過程了，可看 上回 的部署，過程差不多\n登入 Docker Hub 貌似安裝 Docker 後使用 docker pull 要先登入\n首先到官網註冊帳號： Docker Hub 然後需要先進行初始化，執行命令\n1 gpg --generate-key 輸入相關資訊後注意輸出的 pub 下一行的一串字串，複製並替換為下述命令的 [pub]\n1 pass init [pub] 然後在 Docker Desktop 登入\n動畫 - Jellyfin Docker Hub： jellyfin/jellyfin 官網： Jellyfin: The Free Software Media System 1 docker pull jellyfin/jellyfin 不過封面圖片方面不太理想，個人不是用 NAS，懶得弄了\n可參考： 利用 Jellyfin + Bangumi 打造更舒適的動畫媒體庫 - 初之音 漫畫 - Komga Docker Hub： gotson/komga 官網： Komga 1 docker pull gotson/komga 註：漫畫過多掃描時可能會導致電腦很卡\n音聲 - kikoeru-express Docker Hub： muveex/kikoeru-express Github： kikoeru-project/kikoeru-express 我下載的是 0.6.2 版本 (話說這東西和某網站很像嘛)\n1 docker pull muveex/kikoeru-express:v0.6.2 本來看到文章想用 PLEX 的，但必須登入使用搞得有點不想用了，但介面看起來很好看，忍了。裝完後發現要加自己的媒體庫居然還要安裝它的閉源軟體，這東西可以存取檔案系統幾乎所有檔案 (但存取不了我掛載的) ，解除安裝了，可能我弄 NAS 才會再次使用吧\n引導 - Heimdall Docker Hub： linuxserver/heimdall/ 官網： Heimdall Application Dashboard 1 docker pull linuxserver/heimdall 另在 參考文章第二篇 有提到統一認證，不過我個人不太需要就沒弄了 (主要是看著就很複雜)\n後話 從這次折騰來看，可能並不需要為 NAS 的系統買單，硬體買電腦配件組個主機，軟體裝個 Linux 系統，透過各種開源專案想必應該也可以有不錯的體驗\n指令列操作不來可以裝一些輕量的 GUI，例如 Xface、JWM 之類的\n參考文章 談談如何使用 docker，搭建一台「群暉」_NAS 儲存_什麼值得買 NAS也能用上【統一認證】_NAS 儲存_什麼值得買 使用 Plex \u0026amp; Docker 搭建自己的媒體伺服器 - RIN\u0026rsquo;S HOME 利用 Jellyfin + Bangumi 打造更舒適的動畫媒體庫 - 初之音 ","date":"2022-09-16T15:00:01+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/73/","title":"個人內網折騰"},{"content":" 📢 本文由 gemini-2.5-flash-lite 翻譯 前言 啟用某外掛後台出現 502 錯誤。\n進入資料庫 選擇進入 wp_options 資料表。\n找到 active_plugins 項目，一般在第二頁。\n編輯此項目的 option_value 行。\n刪除不需要的外掛 注意：刪除前請務必備份！！！\n找到不需要的外掛名稱。\n刪除從 i: 開始到 ; 為止的字串，例如 i:1;s:23:\u0026quot;elementor/elementor.php\u0026quot;;\n更改序號，也就是 i: 後面的數字。\n更改總數，也就是最開頭 a: 後面的數字。\n參考文章 從資料庫停用單一 WordPress 外掛 - WordPress - GoDaddy 說明 SG ","date":"2022-09-15T22:17:02+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/72/","title":"WordPress 停用資料庫外掛"},{"content":" 📢 本文由 Gemini-3-flash 翻譯 引言 這個黑幕很好玩啊，非常好玩啊，可惜首頁無法渲染出來，而且 Markdown 編寫渲染也難\n使用方式 撰寫文章時選擇作為 HTML 編輯，插入以下語句\n1 \u0026lt;span class=\u0026#34;heimu\u0026#34; title=\u0026#34;黑幕彈框裡的字\u0026#34;\u0026gt;需要隱藏的文字\u0026lt;/span\u0026gt; 插入 CSS 本來是想著實作首頁也有黑幕，但實際測試發現首頁不會渲染 (為什麼不渲染啊啊啊啊啊啊啊！！！！！！！試著想像 Warma 的聲音)\n進入後台設定，找到頁尾設定，輸入以下程式碼，或者在 WP 的自訂 CSS 處插入，不過需要去掉標籤\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 \u0026lt;style\u0026gt; .heimu, .heimu a, a .heimu, .heimu a.new { background-color: #252525; color: #252525; text-shadow: none; } .heimu:hover, .heimu:active, .heimu:hover .heimu, .heimu:active .heimu { color: white !important; } .heimu:hover a, a:hover .heimu, .heimu:active a, a:active .heimu { color: lightblue !important; } .heimu:hover .new, .heimu .new:hover, .new:hover .heimu, .heimu:active .new, .heimu .new:active, .new:active .heimu { color: #BA0000 !important; } \u0026lt;/style\u0026gt; 註：因 Argon 不會渲染註釋，所以我並不把以下內容放入程式碼中：\n/*閱讀更多：https://zh.moegirl.org/MediaWiki:Mobile.css 本文引自萌娘百科(https://zh.moegirl.org)，文字內容預設使用《創用 CC 姓名標示-非商業性-相同方式分享 3.0》協議。*/\n參考文章 Re：萌娘百科上的黑幕實現 – Vanilla_chan – 博客園 萌百黑幕CSS代码-Hiyoung’blog ","date":"2022-09-05T21:51:23+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/67/","title":"萌娘百科黑幕在 Argon 主題 WordPress 實作"},{"content":" 📢 本文由 gemini-2.5-flash-lite 翻譯 引言 記錄我使用 OpenWRT 路由器連接學校網路的折騰過程，雖然最後的結果挺 emm？但在这个過程中還是了解到不少東西\n起始 通過在瀏覽器搜尋 openwrt通過深瀾認證 得到 恩山無線論壇 帖子回覆下的一個開源專案： coffeehat/BIT-srun-login-script ，通過專案知道了有支援多平台 (包括 openwrt) 的 golang 版本，於是開始折騰\n這是專案作者的文章： 深瀾校園網登錄的分析與 python 實現-北京理工大學版 折騰前 對於 OpenWRT 版本未提供編譯後的版本，即 IPK 文件，又因為我水平不行看不懂 README 便請教同學得知為 Linux 的指令，但在實際操作後得知此命令為編譯 Linux 核心，便放棄在實體機做開始使用虛擬機搞\n參考： Building a custom kernel/zh-cn - Fedora Project Wiki 開始折騰 另朋友發了 configuration - How to fix make error \u0026ldquo;No rule to make target \u0026lsquo;menuconfig\u0026rsquo;\u0026rdquo; when building a kernel for Beagleboard? - Unix \u0026amp; Linux Stack Exchange ，於是我便照著此帖子回答嘗試\n創建虛擬機 因為我使用的 Fedora 自帶虛擬機軟體 盒子，首先嘗試裝 CentOS8，因為我的鏡像文件放到了移動硬碟中，便直接掛載，選擇。結果提示創建失敗，然後我嘗試了 CentOS7，失敗，然後 Ubuntun，失敗\n接連失敗，要不是我之前用這軟體創建過Win10我都快懷疑是不是軟體不行了，打開錯誤日誌，果然看不懂，不過我注意到路徑有中文，於是把路徑改為英文，再次嘗試，失敗\n然後第二天我在想既然是編輯核心，要不使用 kali 吧，於是把 U 盤中 kali 鏡像複製到電腦，雖然最後安裝失敗但成功運行了，難道要把系統放本地才行嗎\n於是我把 CentOS7 的鏡像拷貝到 ~/Documents/ 下，安裝成功。因想著只是編譯 IPK 便只有 root 用戶\n連接網路 本以為在 Linux 下創建 Linux 虛擬機可以直接共享網路的，於是我就直接輸入命令 wget https://cdn.kernel.org/pub/linux/kernel/v5.x/linux-5.19.6.tar.xz，結果就是無法找到 IP 地址，使用命令 ifconfig 發現無 IP\n參考文章 在虛擬機中設置靜態 IP (centos 為例) 使虛擬機連上網路，不過在最後文件修改只需要將 ONBOOT 後的值改為 yes 然後加倆 DNS 就可以了\n安裝git 連上網路後我先裝了個 git，使用 yum install git 即可，然後配置姓名與郵箱\n1 git config --global user.name \u0026#34;Name\u0026#34; 1 git config --global user.email \u0026#34;email@example.com\u0026#34; 傳輸文件 繼續使用 wget 下載 Linux 核心，嘗試了三四次，幾乎都是在 50% 左右下載失敗而且速度很慢\n注：使用 wget -c URL 可實現斷點續傳\n然後就是 盒子 這個軟體貌似支援直接拖拽傳輸，於是我在我的電腦下載好後直接拖過去，失敗，文件沒有被傳輸過去，考慮到傳輸後的文件在 ~/Downloads/ 下，我使用的是 root 帳戶，於是我參考 Linux 添加用戶和管理員用戶 創建了一個用戶 (差點把最後一步刪除用戶也執行了)\n使用命令 su username 切換用戶，創建文件夾 ~/Downloads/，再次拖入還是失敗\n嘗試使用 盒子 的共享功能將電腦的 ~/Public 共享，但我怎麼操作也不能在虛擬機裡看到 (想必這軟體只適配了 RHEL 和 Fedora 吧)\nSSH 傳輸 然後我想到了通過 SSH 傳輸 (因為我輸入 ftp 發現沒這個命令，懶得裝了)\n本地開啟 SSH 連接，然後通過 scp 命令以使用 SSH 傳輸文件\n1 scp username@servername:/path/filename ~/Downloads/ 首先是確定 IP，在虛擬機中輸入命令 ip route 得到 IP 為 10.0.2.2\n然後使用 scp 命令傳輸\n解壓文件 使用 tar 命令解壓文件\n1 tar -xzvf filename.tar.xz emm，非 gzip 壓縮文件，那我不知道怎麼解壓啊\nSSH 傳輸 還是使用 SSH 傳輸吧，在 scp 命令加上 -r 即可傳輸文件夾\n開始嘗試 按照步驟將解壓後的文件放到 /usr/src/ 下，把 /boot 下的 config 放到 /usr/src/linux-5.19.6/.config，結果無論是把配置文件放到 .config/ 下還是放到 .config 都無法運行 make menuconfig 命令\n總結 折騰失敗，下次再來\n不過在我編寫此文章時注意到原帖嘗試直接在 OpenWRT 運行 Python，有時間嘗試一下\n再次嘗試 然後我諮詢了一位過了認證校園網的朋友 (雖然他是普通路由器)，他將路由器的 MAC 地址改為自己電腦的，結果插上網線認證頁面會自動轉發到電腦，然後認證後就有網了，不過是銳捷網頁認證\n然後考慮到深瀾使用的是 Portal 認證也就是 Web 頁面認證，既然是 Web 那想必就是使用 HTTP 了，我是否可以通過編輯 HTTP 報文的方式通過認證呢？那麼 Linux 有命令可以發送 HTTP 報文嗎，我搜了一下，發現 curl 與 wget 命令可以模擬 get 和 post 請求 (於是我打開 Fiddler 開始抓包，企圖還原驗證過程)\n才怪，我用路由器連接上學校網，電腦插上網線連上路由器，輸入認證頁面 IP，認證完成，路由器有網了\nLinux 命令模擬 Http 的 get 或 post 請求 雖然沒用到，不過既然看到了那就記錄一下吧\nGET 請求 curl 1 2 3 4 5 6 7 8 ## 如果這裡的 URL 指向的是一個文件可以直接下載到本地 curl URL ## 顯示全部信息 curl -i URL ## 只顯示頭部信息 curl -I URL ## 顯示 get 請求全過程解析 curl -v URL wget 1 wget URL POST 請求 curl 1 2 3 4 5 6 ## 通過 -d 參數，把訪問的參數放在裡面 curl -d \u0026#34;param1=value1\u0026amp;param2=value2\u0026#34; \u0026#34;URL\u0026#34; curl -d\u0026#39;param1=value1\u0026amp;param2=value2\u0026#39; -X POST URL curl -d \u0026#39;param1=value1\u0026#39; -d \u0026#39;param2=value2\u0026#39; -X POST URL wget 1 2 ## 通過 --post-data 參數實現 wget --post-data \u0026#39;user=name\u0026amp;passwd=passwd\u0026#39; URL 再次總結 有時候不能把某件事想的太複雜，往往很簡單的事只思考而沒實踐就否認這種可能性是錯誤的，這次就是我一開始就把最後再次嘗試部分否決才鬧了這麼一大圈 (要不是流量卡的不行我才不會去試)\n寫到這時我想到了兩句名言\n學而不思則罔，思而不學則殆\n實踐得真知\n所以有些時候還是應該大膽去嘗試，不要因為過多的思考而限制了自己！\n參考文章 求助深瀾校園網 Portal 認證應該怎麼刷固件？-小米無線路由器以及小米無線相關的設備-恩山無線論壇 configuration - How to fix make error \u0026ldquo;No rule to make target \u0026lsquo;menuconfig\u0026rsquo;\u0026rdquo; when building a kernel for Beagleboard? - Unix \u0026amp; Linux Stack Exchange 在虛擬機中設置靜態 IP (centos 為例) - yexca\u0026rsquo;Blog 安裝 Git - 廖雪峰的官方網站 Linux 添加用戶和管理員用戶 - yexca\u0026rsquo;Blog linux 系統下如何進行用戶之間的切換_M李麗的博客-CSDN博客_linux切換系統 使用 ssh 傳輸文件 - 思否 Linux tar 命令-菜鳥教程 Portal 認證原理-曹世宏的博客 Linux 命令發送 Http 的 get 或 post 請求 (curl 和 wget 兩種方法)_cyl937的博客-CSDN博客 ","date":"2022-09-05T21:24:23+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/66/","title":"記錄 OpenWRT 通過深瀾網路認證的折騰過程"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 前言 因為接觸了 YouTube-dl ，下載頻道的所有內容非常好用，但是下載下來是 webm 格式，相容性不是很好，於是查詢了使用 ffmpeg 轉換格式的指令。\n設定檔 後來發現改一下設定檔就行了，在檔案後面加上\n1 --merge-output-format mp4 這是我的設定檔\n1 -o \u0026#39;C:/Users/yexca/Downloads/Video/%(uploader)s/%(upload_date)s%(title)s%(id)s.%(ext)s\u0026#39; --merge-output-format mp4 單一指令 使用以下指令即可快速轉碼\n1 ffmpeg -i before.webm after.mp4 但一個一個轉碼實在是太慢了，於是就想到使用批次處理。\n批次處理 新增記事本，輸入以下程式碼\n1 for %%a in (*.webm) do ffmpeg -i \u0026#34;%%~a\u0026#34; -vcodec copy -f mp4 \u0026#34;%%~na.mp4\u0026#34; 其中 (*.webm) 為原始檔案類型，「%%~na.mp4」為想要產生的檔案類型。\n然後儲存並命名為run.bat 後，放到對應的資料夾執行即可。\n但這樣每次想轉換不同的檔案，還得修改一下，這樣不大實用啊（\ndos 然後我就看了一些 bat 檔案的資料，簡單寫了下面的程式 (需要使用 GB2312 編碼才能在命令列正常輸出中文)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 echo off :0 echo 請輸入數字選擇操作 echo 1.轉碼 echo 2.刪除 echo 3.退出 set /p choice=請選擇 goto %choice% :1 set /p before=請輸入轉碼前檔案格式 set /p after=請輸入轉碼後檔案格式 echo 開始轉碼%before%到%after% for %%a in (*.%before%) do ffmpeg -i \u0026#34;%%~a\u0026#34; -vcodec copy -f %after% \u0026#34;%%~na.%after%\u0026#34; echo 轉碼完成 goto 0 :2 set /p delet=請輸入需要刪除的檔案格式 echo 開始刪除%delet% del *.%delet% del %delet% echo 刪除完成 goto 0 :3 exit 放到對應的資料夾下使用就好了。\n參考文章 youtube-dl 的一些實用技巧 · eisen 部落格 給新手的 20 多個 FFmpeg 指令範例 - 知乎 FDM 當掉了，youtube-dl 慢得要死，烤肉man 的末日到了！ 中 AnnMilne 的評論\n用bat指令執行ffmpeg進行批次轉碼-五仁的紀錄 Bat指令學習 - 陽光雨露\u0026amp; - 部落格園 bat set指令詳解_python資深小白的部落格-CSDN部落格 ","date":"2022-09-05T16:41:38+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/65/","title":"ffmpeg 批次轉換影片格式"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 引言 這是在我閱讀了肖佳老師的書《HTTP 封包擷取實戰》後對 HTTP 相關內容的總結，主要還是訊息相關 (記錄：閱讀此書與寫出此文章耗時 5 天)\nHTTP 協定訊息的結構 HTTP 訊息分為 2 個：一個是 HTTP 請求訊息 (Request)，一個是 HTTP 回應訊息 (Response)\nHTTP 請求訊息 (Request) HTTP 請求訊息分為 3 個部分，第一部分叫起始行 (Request line)，第二部分叫標頭 (Request Header)，第三部分叫主體 (Body)\n第一行中有 Method (請求方法)、URI 和協定版本。例如 GET https://blog.yexca.net/ HTTP/2\n第二部分是 Header (標頭)\n第三部分是 Body (主體)\n注意：Header 標頭和 Body 主體之間有一個空行\nHTTP 回應訊息 (Response) HTTP 回應訊息與請求訊息的結構基本一樣，也分為 3 個部分，第一部分叫回應行 (Response line)，第二部分叫回應標頭 (Response Header)，第三部分是主體 (Body)\n第一行有協定版本、狀態碼和狀態碼訊息。例如 HTTP/2 200\n第二部分是 Header (標頭)\n第三部分是 Body (主體)\n注意：Header 標頭和 Body 主體之間有一個空行\nHTTP 協定請求方法和狀態碼 URL 格式 URL 的全稱為 Uniform Resource Locator，中文譯名為統一資源定位符，用於完整地描述 Internet 上某一處資源的位址\nURL 的基本格式如下：\nschema://host[:port#]/path/.../[?query-string][#anchor]\n屬性 描述 schema (協定) 指定底層使用的協定 (例如：http，https，ftp) host (網域) HTTP 伺服器的 IP 位址或者網域名稱 port# (連接埠) HTTP 伺服器的預設連接埠是 80，這種情況下連接埠號可以省略。如果使用了別的連接埠，則必須指明 path (資源的路徑) 存取資源的路徑 query-string (參數) 發送給 HTTP 伺服器的資料 anchor (錨點) 錨點，頁面內部超連結 HTTP 請求方法 編號 方法 描述 1 GET 請求指定的頁面資訊並傳回實體主體 2 HEAD 類似於 GET 請求，只不過傳回的回應中沒有具體的內容，用於獲取標頭 3 POST 向指定資源提交資料進行處理請求 (例如提交表單或者上傳檔案)，資料被包含在請求體中。POST 請求可能會導致新的資源建立和/或對現有資源的修改 4 PUT 從用戶端向伺服器傳送的資料取代指定文件的內容 5 DELETE 請求伺服器刪除指定的頁面 GET 與 POST 的區別 GET 提交的資料會放在 URL 之後，以 ? 分隔 URL 和傳輸資料 (即 query-string，鍵值對方式)，參數之間以 \u0026amp; 相連\n而 POST 方法是把提交的資料放在 HTTP 封包的 Body 中\nGET 提交的資料大小有限制 (因為瀏覽器對 URL 的長度有限制)\n而 POST 方法提交的資料大小沒有限制\nGET 方式需要使用 Request.QueryString 來取得變數的值\n而 POST 方法透過 Request.Form 來獲取變數的值\nHTTP 狀態碼 HTTP 狀態碼存在於 HTTP 的回應訊息中，其作用是 Web 伺服器用來告訴用戶端發生了什麼事\nHTTP 狀態碼被分為 5 大類，隨著協定的發展，HTTP 規範中會定義更多的狀態碼吧\n狀態碼 已定義範圍 分類 1XX 100～101 資訊提示，表示請求已被成功接收，繼續處理 2XX 200～206 成功，表示請求已被成功接收、理解、接受 3XX 300～305 重新導向，要完成請求，必須進行進一步處理 4XX 400～415 用戶端錯誤，請求有語法錯誤或請求無法實現 5XX 500～505 伺服器錯誤，伺服器未能實現合法的請求 常見狀態碼 名稱 釋義 200 OK：伺服器成功處理了請求 301/302 Moved Permanently (重新導向)：請求的 URL 已移走。Response 中應該包含一個 Location URL，說明資源現在所處的位置 304 Not Modified (未修改)：用戶端的快取資源是最新的，需要用戶端使用快取 404 Not Found：未找到資源 401 禁止存取 501 Internal Server Error：伺服器遇到一個錯誤，使其無法對請求提供服務 206 (Partial Content，部分內容) 206 狀態碼代表伺服器已經成功處理了部分 GET 請求 (只有發送 GET 方法的 HTTP 請求，Web 伺服器才可能傳回 206)\n應用比如說使用下載工具實現斷點續傳或者線上影片播放都是使用 206 狀態碼來實現\n例如現在打開影片網站的一個影片，對於影片所在的 URL\n瀏覽器會發送一個 GET 請求，Header 中包含 Range: bytes=5303296-5336063，意思就是請求得到 5303296-5336063 之間的資料\nWeb 伺服器傳回一個 206 的 HTTP 回應。Header 中包含 Content-Range: bytes 5303296-5336063/12129376，表明這次傳回的內容範圍\n301 與 302 (Moved Permanently，重新導向) 在得到 301 或 302 回應後，瀏覽器會再次請求位於 Location 中傳回的新 URL\n狀態碼 301 和 302 在語法上是一模一樣的，都是在 HTTP 回應的 Location 中傳回新的 URL\n區別在於：\n301 表示舊位址已經被永久移除了，這個資源不可存取了，搜尋引擎會把權重算到新位址\n例如：防止使用者輸錯網域或更換網域\n302 表示舊位址的資源還在，仍然可以存取，這個重新導向只是臨時地從舊位址跳轉到新位址，搜尋引擎會把權重算到新位址\n例如：未登入狀態下存取需要登入才能存取的頁面\n304 (Not Modified，未修改) 狀態碼 304 表示上次的文件已經被快取了，還可以繼續使用\n400 (Bad Request) 狀態碼 400 表示用戶端請求有語法錯誤，發送的 HTTP 請求中的資料有錯誤，例如表單有錯誤或者 Cookie 有錯誤，不能被伺服器所理解\n401 (Unauthorized) 狀態碼 401 是指未授權錯誤。有些網頁採用的是 HTTP 基本認證 (Basic Authentication) ，需要在 HTTP 請求 Header 中帶上 Authentication，否則伺服器會傳回狀態碼 401\n404 (Not Found) 該狀態碼表明伺服器上無法找到請求的資源。除此之外，也可以在伺服器端拒絕請求但不想說明理由時使用\n例如 BV1AB4y1D7Ft 這個影片僅在登入並且收藏的情況下才可見，否則將傳回 404\n403 (Forbidden) 狀態碼 403 表示 Web 用戶端發送的請求被 Web 伺服器拒絕了。如果伺服器想說明為什麼拒絕請求，可以在 Body 中描述原因。但這個狀態碼通常表示伺服器不想說明拒絕原因\n500 (Internal Server Error) 狀態碼 500 代表伺服器內部錯誤。出現錯誤的原因有很多，比如程式碼的錯誤、資料庫連接語句出錯、程式內部拋出異常、空指標錯誤等\n503 (Server Unavailable) 狀態碼 503 表示伺服器暫時不可用。由於伺服器維護或者過載，伺服器目前無法處理請求\n這個狀況是臨時的，並且將在一段時間以後恢復\n了解全部狀態碼 存取： HTTP 狀態碼 - 菜鳥教程 HTTP 協定 Header Header 的語法格式是「key: value」，一行一個。每一個 Header 都有特殊的作用\n快取相關的 Header HTTP 請求與 HTTP 回應都有很多用於快取的 Header。HTTP 快取是指當 Web 請求抵達快取時，如果本地有「已快取的」複本，就可以從本地儲存設備而不是原始伺服器中獲取該檔案\nCookie Cookie 是一種 HTTP 快取，是 HTTP 中非常重要的內容。它由 key=value 的形式組成，比如 ip_country=CN\n瀏覽器把 Cookie 透過 HTTP 請求中的「Cookie: header」發送給 Web 伺服器，Web 伺服器透過 HTTP 回應中的「Set-Cookie: header」把 Cookie 發送給瀏覽器\nAccept Accept 表示瀏覽器用戶端可以接受的媒體類型。例如 Accept: text/html 代表可以接受伺服器傳回 html\n萬用字元 * 代表任意類型，例如 Accept: text/html,*/*;q=0.8 代表瀏覽器可以處理所有的類型。一般瀏覽器用戶端給 Web 伺服器發送的都是類似這個\nAccept-Encoding Accept-Encoding 跟壓縮有關，瀏覽器發送 HTTP 請求告訴 Web 伺服器瀏覽器支援的壓縮形式，例如 Accept-Encoding: gzip, deflate\nAccept-Language Accept-Language 作用是聲明自己接受的語言。注意語言與字元集的區別，中文是語言，中文有多種字元集，例如 GB2312、GBK 等。例如 Accept-Language: en-US,en;q=0.8,zh-CN;q=0.6,zh;q=0.4,zh-TW;q=0.2\nUser-Agent User-Agent 的作用是瀏覽器用來告訴伺服器，用戶端使用的作業系統及版本、CPU 類型、瀏覽器及版本、瀏覽器轉譯引擎、瀏覽器語言、瀏覽器外掛程式等\n例如 User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:103.0) Gecko/20100101 Firefox/103.0 代表 64 位元 Linux 系統，Firefox 是 103.0 版本\n如果想要模擬各種不同的用戶端，只要修改 User-Agent，就可以偽裝成各種用戶端\nReferer Referer 主要用來讓伺服器判斷來源頁面，即使用者是從哪個頁面來的，網站通常用其統計使用者來源，也可以用作防盜連等\nConnection 從 HTTP/1.1 起，系統預設都開啟了 Connection: Keep-Alive，保持連線特性。Keep-Alive 不會永久保持連線，它有一個保持時間，可以在不同的伺服器軟體 (如 Apache) 中設定這個時間\nHost Host 的作用是指定被請求的主機和連接埠號，如果是 80 連接埠號會被自動隱藏\nHTTP 協定中的快取 快取無處不在，有瀏覽器端的快取、伺服器端的快取、代理伺服器的快取，還有 ASP.NET 頁面的快取、物件快取、資料庫快取等等\nHTTP 中具有快取功能的是瀏覽器快取和代理伺服器快取\nHTTP 快取是指當 Web 請求抵達快取時，如果本地有「已快取的」複本，就可以從本地儲存設備而不是從原始伺服器中提取這個文件\n快取的優點：減少了冗餘的資料傳輸，節省了傳輸時間；減少了伺服器的負擔，大大提高了網站的效能；加快了用戶端載入網頁的速度等\n如何判斷快取新鮮度 Web 伺服器透過以下兩種方式來判斷瀏覽器快取是否最新\n瀏覽器把快取檔案的最後修改時間透過 Header 的 If-Modified-Since 告訴 Web 伺服器。瀏覽器收到 HTTP 請求後，在 Header 中將檔案最後修改時間 Last-Modified 與請求訊息的 If-Modified-Since 相比較。若相同則說明檔案是最新的，則發送狀態碼 304 (Not Modified) 給瀏覽器用戶端；若不同則發送狀態碼 200 把最新檔案發送給瀏覽器用戶端\n瀏覽器把快取檔案的 ETag 透過 Header 的 If-None-Match 告訴 Web 伺服器\n與快取有關的 Header HTTP 請求訊息 Header 名稱 釋義 Cache-Control: max-age=0 以秒為單位 If-Modified-Since: Tue, 28 Jun 2022 00:50:56 GMT 快取檔案的最後修改時間 If-None-Match: \u0026ldquo;1771e0c387823da5329c20a76bece83c\u0026rdquo; 快取檔案的 ETag 值 Cache-Control: no-cache 不使用快取 Pragma: no-cache 不使用快取 HTTP 回應訊息 Header 名稱 釋義 Cache-Control: public 回應被快取，並且可以被多用戶存取使用 Cache-Control: private 回應只能作為私有快取，特定使用者使用 Cache-Control: no-cache 提醒瀏覽器要從伺服器提取文件進行驗證 Cache-Control: no-store 絕對禁止快取 (用於機密、敏感檔案) Cache-Control: max-age=60 60s 後快取過期 (相對時間) Date: Thu, 01 Sep 2022 21:56:36 GMT 目前回應發送的時間 Expires: Thu, 01 Sep 2022 21:57:37 GMT 快取過期的時間 (絕對時間) Last-Modified: Tue, 28 Jun 2022 00:50:56 GMT 伺服端檔案的最後修改時間 Etag: \u0026ldquo;1771e0c387823da5329c20a76bece83c\u0026rdquo; 伺服器檔案的 ETag 值 註：瀏覽器總是優先使用 cache-control，如果沒有時才考慮 Expires\nETag ETag 是 Entity Tag (實體標籤) 的縮寫，是根據實體內容生成的一段雜湊 (hash) 字串 (類似於 MD5 或者 SHA1 之後的結果)，可以表示檔案的狀態。當資源發生改變時，ETag 也隨之發生改變\n使用 ETag 主要是為了解決一些 Last-Modified 無法解決的問題，比如說某些伺服器不能精確得到檔案的最後修改時間、一些檔案最後修改時間改變了但是內容不變、某些檔案修改特別頻繁甚至達到了以秒為單位以下等\n註：Last-Modified 只能精確到秒\n瀏覽器不使用快取 使用 Ctrl+Shift+R 快捷鍵強制重新整理瀏覽器，可以讓瀏覽器不使用快取，即瀏覽器的 HTTP 請求訊息的 Header 中帶有 Cache-Control: no-cache，明確告訴 Web 伺服器不使用快取\n註：Pragma: no-cache 與 Cache-Control: no-cache 作用相同，只是 Pragma: no-cache 是 HTTP/1.0 定義的，保留為了相容性\n直接使用快取，不經過伺服器驗證 使用 Ctrl+R 快捷鍵重新整理瀏覽器，瀏覽器會去 Web 伺服器驗證快取\n如果在網址列直接輸入位址並存取，瀏覽器會「直接使用有效的快取」，不會發送 HTTP 請求去伺服器驗證快取，這種情況稱為快取命中 (cache hit)\n公有快取與私有快取 公有快取 Cache-Control: public 可以由多個使用者共享存取，而私有快取 Cache-Control: private 只能單個使用者存取使用\nHTTP 協定壓縮和 URL Encode HTTP 壓縮是指 Web 伺服器和瀏覽器之間壓縮傳輸文字內容的方法。HTTP 採用通用的壓縮演算法，比如用 gzip 來壓縮 HTML、JavaScript、CSS 檔案\nHTTP 內容編碼與壓縮的區別 在 HTTP 協定中，可以對 Body 部分進行編碼，如可以採用 gzip 這樣的編碼，從而達到壓縮的目的；也可以使用其他編碼方式把內容攪亂或加密，以此來防止未被授權的第三方看到文件的內容。所以 HTTP 壓縮其實就是 HTTP 內容編碼的一種\nHTTP 壓縮的過程 瀏覽器發送 HTTP 請求 Header 中帶 Accept-Encoding: gzip,deflate 告訴伺服器瀏覽器支援 gzip 壓縮\nWeb 伺服器接到 HTTP 請求後，先生成原始的 HTTP 回應，包含原始的 Content-Type 與 Content-Length；然後透過 gzip 對 HTTP 回應的 Body 進行編碼，並在編碼後 Header 中的 Content-Type 與 Content-Length 替換為壓縮後的大小，以及加上編碼方式 Content-Encoding: gzip；再把 HTTP 回應發送給瀏覽器\n瀏覽器接到 HTTP 回應後，根據 Content-Encoding: gzip 來對 HTTP 回應進行解碼，獲取到原始 HTTP 回應後顯示出網頁\n註：HTTP 請求也是可以編碼的，但是瀏覽器一般不會對 HTTP 請求編碼\n內容編碼類型 HTTP 定義了一些標準的內容編碼類型，並允許用擴展的形式添加更多的編碼\n在 Header 中的 Content-Encoding 就是使用這些標準化的代號來說明編碼時使用的演算法\n編碼 描述 gzip 表明實體採用 GNU zip 編碼 compress 表明實體採用 UNIX 的檔案壓縮程式 deflate 表明實體是用 zlib 的格式壓縮的 identity 表明沒有對實體進行編碼。當 Header 中沒有 Content-Encoding 時，預設為此情況 gzip、compress 以及 deflate 編碼都是無損壓縮演算法，用於減少傳輸訊息的大小，不會導致資訊缺失。其中 gzip 通常效率最高，使用最為廣泛\n深入理解 Cookie 機制 HTTP 協定是無狀態的，對於瀏覽器的每一次請求，伺服器都會獨立處理，不與之前或之後的請求發生關聯。即使是同一個瀏覽器發送了 3 個請求，伺服器也會獨立處理這 3 個請求，伺服器並不知道這 3 個請求是來自同一個瀏覽器\n工作階段機制與 Cookie 機制 伺服器需要識別瀏覽器請求，就必須弄清楚瀏覽器的請求狀態。既然 HTTP 協定是無狀態的，那就讓伺服器和瀏覽器共同維護一個狀態，這就是工作階段 (Session) 機制\n瀏覽器第一次請求伺服器時，伺服器建立一個工作階段，並將工作階段 ID (Session ID) 作為回應的一部分發送給瀏覽器\n瀏覽器儲存工作階段 ID，並在後續請求中帶上工作階段 ID\n伺服器取得請求中的工作階段 ID 就知道是不是同一個使用者了\n這樣後續請求與第一次請求就產生了關聯，而 Cookie 機制就是一種工作階段機制\n伺服器在記憶體中保存工作階段物件，瀏覽器可以使用 Cookie 機制保存工作階段 ID\nCookie 是什麼 Cookie 是瀏覽器用來儲存少量資料的一種機制，資料以 key=value 形式儲存，多個 Cookie 之間以分號 ; 分隔，瀏覽器發送 HTTP 請求時自動附帶 Cookie 資訊\nCookie 最主要的作用是用來做使用者認證，還可以用於保存使用者的一些其他資訊。也可以用於網際網路精準廣告定向技術，例如使用者瀏覽了某些商品，就可以用 Cookie 記錄下來，然後進行大數據深度分析，實現廣告精準投放\n鑒於此項，目前歐洲的一些國家已經對 Cookie 立法，並規定必須經過使用者的允許才可以保存使用者的 Cookie\nCookie 的屬性 根據網站不同， Cookie 有所不同\nExpires 表示 Cookie 失效的時間，如果不指定則在關閉瀏覽器或頁面時被瀏覽器刪除\nPath 表示 Cookie 所屬的路徑，asp.net 預設為 / 也就是根目錄\n假設在同一個伺服器上的目錄如下：/test/、/test/cd/、/test/dd，Cookie1 的 Path 在 /test/，Cookie2 的在 /test/cd/，那麼 /test/ 下的所有頁面都可以存取到 Cookie1，而 /test/dd/ 的子頁面不能存取 Cookie2。因為 Cookie 只能讓其 Path 路徑下的頁面存取\nHttpOnly 這是個關乎安全方面的屬性，將一個 Cookie 設定為 HttpOnly 後，透過 JavaScript 腳本將無法讀取到 Cookie 資訊，這能有效防止用 XSS 發起攻擊\n一般來說，跟登入相關的 Cookie 必須設定為 HttpOnly\nCookie 的分類與位置 類別 描述 工作階段 Cookie 臨時的 Cookie，記錄了使用者存取站點時的設定與偏好 (例如存取本站時的 Cookie)，關閉瀏覽器後將被刪除 持久 Cookie 儲存在硬碟上，有過期時間。不管退出瀏覽器還是重啟電腦都存在 網站的自動登入就是儲存持久 Cookie，在使用者再次存取相同網站時會先在硬碟中查找相關 Cookie 然後放到 HTTP 請求訊息中發送給伺服器\n那麼持久 Cookie 存在電腦哪裡呢？不同瀏覽器會在各自的獨立空間存放 Cookie，互不干擾\n例如 Linux 下 Firefox 的 Cookie 位置：~/.mozilla/firefox/xxxxxxxx.default-release/cookies.sqlite\nHTTP 基本認證 HTTP 協定是無狀態的，瀏覽器和 Web 伺服器之間可以透過 Cookie 來識別身分。那麼一些桌面應用程式是如何跟 Web 伺服器之間識別身分呢？\n一些網站和 Web 服務使用的是 HTTP 基本認證。有些桌面應用程式也透過 HTTP 協定跟 Web 伺服器互動，桌面應用程式一般不使用 Cookie，而是把使用者名稱+冒號+密碼用 Base64 編碼放在 HTTP 請求 Header 中的 Authorization 發送給服務端，這種方式叫 HTTP 基本認證 (Basic Authentication)\n在基本認證中，Web 伺服器可以拒絕一個事務，要求用戶端提供有效的使用者名稱和密碼，伺服器會傳回 401 狀態碼來初始化認證質詢，並用 WWW-Authenticate 回應首部指定要存取的安全域。瀏覽器收到質詢時，會打開一個對話框請求使用者輸入使用者名稱和密碼，然後將使用者名稱和密碼用 Base64 編碼，再用 Authorization 請求首部發送給伺服器\n一般家用路由器就是使用基本認證， RESTful API 就經常使用基本認證，使用命令 curl -u username:password URI 即可完成基本認證\nHTTP 基本認證的缺點 HTTP 協定是無狀態的，同一個用戶端對伺服器的每個請求都需要認證\nBase64 編碼是可逆的，非常容易破解，所以基本認證相當於以明文的方式傳輸使用者名稱和密碼。所以基本認證一定要用 HTTPS 加密傳輸，稍微安全一點\n使用基本認證登入後，除非關閉瀏覽器或清除歷史記錄，否則無法登出。而 Cookie 機制的話，網站可以提供登出方式以使 Cookie 失效\n無法防止 重送攻擊 摘要認證 摘要認證是針對基本認證存在的諸多問題而進行改良的方案。摘要認證是另一種 HTTP 認證協定，它試圖修復基本認證的嚴重缺陷，進行如下改進\n透過傳遞使用者名稱、密碼等計算出來的摘要來解決以明文方式在網路上發送密碼的問題\n透過伺服器產生隨機數 nonce 的方式防止惡意使用者捕獲並重送認證的握手過程\n透過用戶端產生隨機數 nonce 的方式支援用戶端對伺服器的認證\n透過對內容也加入摘要計算的方式，可以有選擇地防止對訊息內容的篡改\n參考文章 《圖解 HTTP》讀後總結及淺談 - yexca\u0026rsquo;Blog HTTP 狀態碼 - 菜鳥教程 IE/Firefox/Chrome 等瀏覽器保存 Cookie 的位置 - 腳本小娃子 - 博客園 「登錄」還是「登錄」？ - 知乎 重送攻擊 - 維基百科，自由的百科全書 通俗易懂：到底什麼是 REST API？ 表現層狀態轉換 - 維基百科，自由的百科全書 ","date":"2022-09-05T16:03:36+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/64/","title":"HTTP 學習"},{"content":" 📢 本文由 Gemini-3-flash 翻譯 該文章由 Hiyoung 編寫\n其文章: https://blog.hiyoung.icu/2022/09/01/906d191f9a59/ Aria2 是 Linux 下的一個下載工具，這裡介紹 Windows 下的安裝與設定，官方 Aria2 沒有 GUI 介面，所以配合 AriaNG 直接在 Web 介面進行操作。\nAriaNg 是一個讓 aria2 更容易使用的現代 Web 前端。AriaNg 使用純 html \u0026amp; javascript 開發，所以它不需要任何編譯器或執行環境。\n下載 Aria2+AriaNG 最新安裝包 首先先在官網下載安裝包\nAria2 的 Github 地址 – Aria2 官方文件 AriaNG 的 Github 地址 – AriaNG 官方文件 Aria2 選擇對應的作業系統下載壓縮檔即可，AriaNG 解壓縮後放在 Aria2 資料夾即可。\nAriaNg 現在提供三種版本：標準版、單檔案版和 AriaNg Native。\n標準版適合在 Web 伺服器中部署，提供資源快取和按需載入的功能。\n單檔案版適合本地使用，您下載後只要在瀏覽器中打開唯一的 html 檔案即可。\nAriaNg Native 同樣適合本地使用，並且不需要使用瀏覽器。\n新增設定檔 將檔案解壓縮至該目錄下後，你需要再新建立 4 個空檔案 (可以先建一個空 txt 檔案然後修改副檔名)：\nAria2.log （日誌檔案） aria2.session （用於記錄下載歷史，以便斷點續傳） aria2.conf （設定檔） HideRun.vbs （隱藏 cmd 視窗執行時用到的） 修改設定檔 打開剛才建立的 aria2.conf 空檔案，將以下內容填入（用記事本打開即可） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 ## \u0026#39;#\u0026#39;開頭為註解內容, 選項都有相應的註解說明, 根據需要修改 ## ## 被註解的選項填寫的是預設值, 建議在需要修改時再取消註解 ## ## 檔案儲存相關 ## # 檔案的儲存路徑(可使用絕對路徑或相對路徑), 預設: 當前啟動位置 dir=E:\\Aria2Download # 日誌檔案的儲存路徑 log=D:\\aria2-1.36.0-win-64bit-build1\\Aria2.log # 啟用磁碟快取, 0為停用快取, 需1.16以上版本, 預設:16M #disk-cache=32M # 檔案預先分配方式, 能有效降低磁碟碎片, 預設:prealloc # 預先分配所需時間: none \u0026lt; falloc ? trunc \u0026lt; prealloc # falloc和trunc則需要檔案系統和核心支援 # NTFS建議使用falloc, EXT3/4建議trunc, MAC 下需要註解此項 #file-allocation=none # 斷點續傳 continue=true ## 下載連線相關 ## # 最大同時下載任務數, 執行時可修改, 預設:5 #max-concurrent-downloads=5 # 同一伺服器連線數, 新增時可指定, 預設:1 max-connection-per-server=5 # 最小檔案分片大小, 新增時可指定, 取值範圍1M -1024M, 預設:20M # 假定size=10M, 檔案為20MiB 則使用兩個來源下載; 檔案為15MiB 則使用一個來源下載 min-split-size=10M # 單個任務最大執行緒數, 新增時可指定, 預設:5 #split=5 # 整體下載速度限制, 執行時可修改, 預設:0 #max-overall-download-limit=0 # 單個任務下載速度限制, 預設:0 #max-download-limit=0 # 整體上傳速度限制, 執行時可修改, 預設:0 #max-overall-upload-limit=0 # 單個任務上傳速度限制, 預設:0 #max-upload-limit=0 # 停用IPv6, 預設:false #disable-ipv6=true # 連線逾時時間, 預設:60 #timeout=60 # 最大重試次數, 設定為0表示不限制重試次數, 預設:5 #max-tries=5 # 設定重試等待的秒數, 預設:0 #retry-wait=0 ## 進度儲存相關 ## # 從工作階段檔案中讀取下載任務 input-file=D:\\aria2-1.36.0-win-64bit-build1\\aria2.session # 在Aria2退出時儲存`錯誤/未完成`的下載任務到工作階段檔案 save-session=D:\\aria2-1.36.0-win-64bit-build1\\aria2.session # 定時儲存工作階段, 0為退出時才儲存, 需1.16.1以上版本, 預設:0 #save-session-interval=60 ## RPC相關設定 ## # 啟用RPC, 預設:false enable-rpc=true # 允許所有來源, 預設:false rpc-allow-origin-all=true # 允許非外部存取, 預設:false rpc-listen-all=true # 事件輪詢方式, 取值:[epoll, kqueue, port, poll, select], 不同系統預設值不同 #event-poll=select # RPC監聽通訊埠, 通訊埠被佔用時可以修改, 預設:6800 #rpc-listen-port=6800 # 設定的RPC授權權杖, v1.18.4新增功能, 取代 --rpc-user 和 --rpc-passwd 選項 #rpc-secret=\u0026lt;TOKEN\u0026gt; # 設定的RPC存取用戶名, 此選項新版已廢棄, 建議改用 --rpc-secret 選項 #rpc-user=\u0026lt;USER\u0026gt; # 設定的RPC存取密碼, 此選項新版已廢棄, 建議改用 --rpc-secret 選項 #rpc-passwd=\u0026lt;PASSWD\u0026gt; # 是否啟用 RPC 服務的 SSL/TLS 加密, # 啟用加密後 RPC 服務需要使用 https 或者 wss 協定連線 #rpc-secure=true # 在 RPC 服務中啟用 SSL/TLS 加密時的憑證檔案, # 使用 PEM 格式時，您必須通過 --rpc-private-key 指定私鑰 #rpc-certificate=/path/to/certificate.pem # 在 RPC 服務中啟用 SSL/TLS 加密時的私鑰檔案 #rpc-private-key=/path/to/certificate.key ## BT/PT下載相關 ## # 當下載的是一個種子(以.torrent結尾)時, 自動開始BT任務, 預設:true #follow-torrent=true # BT監聽通訊埠, 當通訊埠被封鎖時使用, 預設:6881-6999 listen-port=51413 # 單個種子最大連線數, 預設:55 #bt-max-peers=55 # 打開DHT功能, PT需要停用, 預設:true enable-dht=false # 打開IPv6 DHT功能, PT需要停用 #enable-dht6=false # DHT網路監聽通訊埠, 預設:6881-6999 #dht-listen-port=6881-6999 # 本地節點查找, PT需要停用, 預設:false #bt-enable-lpd=false # 種子交換, PT需要停用, 預設:true enable-peer-exchange=false # 每個種子限速, 對少種的PT很有用, 預設:50K #bt-request-peer-speed-limit=50K # 用戶端偽裝, PT需要 peer-id-prefix=-TR2770- user-agent=Transmission/2.77 # 當種子的分享率達到這個數時, 自動停止做種, 0為一直做種, 預設:1.0 seed-ratio=0.7 # 強制儲存工作階段, 即使任務已經完成, 預設:false # 較新的版本開啟後會在任務完成後依然保留.aria2檔案 #force-save=false # BT校驗相關, 預設:true #bt-hash-check-seed=true # 繼續之前的BT任務時, 無需再次校驗, 預設:false bt-seed-unverified=true # 儲存磁力連結元數據為種子檔案(.torrent檔案), 預設:false bt-save-metadata=true 注意：你需要將下面四行的內容修改為你自己對應的檔案位置：\n1 2 3 4 5 6 7 8 # 檔案的儲存路徑(可使用絕對路徑或相對路徑), 預設: 當前啟動位置 dir=E:\\Aria2Download # 日志檔案的儲存路徑 log=D:\\aria2-1.36.0-win-64bit-build1\\Aria2.log # 從工作階段檔案中讀取下載任務 input-file=D:\\aria2-1.36.0-win-64bit-build1\\aria2.session # 在Aria2退出時儲存`錯誤/未完成`的下載任務到工作階段檔案 save-session=D:\\aria2-1.36.0-win-64bit-build1\\aria2.session 最後兩行的內容是儲存下載歷史的，如果有時 Aria2 不能啟動的話，清空裡面的內容就可以了。\n修改 HideRun.vbs 檔案 打開 HideRun.vbs 檔案，向其中新增\n1 CreateObject(\u0026#34;WScript.Shell\u0026#34;).Run \u0026#34;aria2c.exe --conf-path=aria2.conf\u0026#34;,0 接下來點擊執行 HideRun.vbs 檔案，（注意一定是 HideRun.vbs 檔案而不是那個執行檔！！），如果沒有報錯的話可以直接跳過下面這段：\n注意一下，這裡也可以在檔案前新增具體的檔案目錄前綴，但是前綴的檔案目錄中一定不要有空格。\n例如：\n1 CreateObject(\u0026#34;WScript.Shell\u0026#34;).Run \u0026#34;C:\\Users\\he ne\\Downloads\\aria2c.exe --conf-path=aria2.conf\u0026#34;,0 但是由於 he ne 這一資料夾裡面包含空格，就導致了系統不辨識，類似的常見錯誤位置還多見於：D:\\Program Files (x86)，這裡也是存在空格的，解決方式就是將這一前綴去除即可（但需要該 vbs 檔案位於該 aria2 資料夾下）。\n打開 index.html 打開裡面的 index.html 檔案，如果顯示 「已連線」，則表明搭建成功。\n新增開機自啟動 建立 HideRun.vbs 檔案的捷徑，放入 Windows 的開機自啟動目錄即可：\n在執行視窗中輸入：shell:startup\n這裡便會打開自啟動目錄資料夾，然後將該捷徑拖入即可。\n參考文章：\nAria2+AriaNG 配置指南（Win10 篇） AriaNG 文檔 ","date":"2022-09-01T23:06:38+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/62/","title":"Aria2+AriaNG 配置使用"},{"content":"notify: 📢 本文由 gemini-2.5-flash-lite 翻譯 引言 預設情況下 Fiddler 僅能攔截 HTTP 封包，需要進行設定後才能捕獲 HTTPS 流量。目前大部分網站都使用 HTTPS 或 HSTS，因此開啟 HTTPS 封包攔截功能是很有必要的。\nFiddler 設定 在「設定」-「HTTPS」頁面中，勾選「Capture HTTPS traffic」即可。下方的「Ignore server certificate errors(unsafe)」也可以勾選，但可能存在安全風險，之後請儲存設定。\n瀏覽器設定 啟用 HTTPS 攔截後，使用瀏覽器可能會出現憑證錯誤，提示「連線不安全」或「連線不是私密連線」等訊息。此時需要匯入相關憑證。以 Firefox 為例：\n首先下載 Fiddler 憑證。在上一部的設定頁面中，點擊「Export root cerificate to Desktop」即可將憑證匯出至桌面 (~/Desktop/)。\n然後進入 Firefox 的設定，在「隱私與安全性」-「憑證」頁面中匯入剛剛下載的憑證，並在彈出的視窗中全選信任相關選項。\n匯入完成後，即可正常瀏覽網頁，Fiddler 也能正常攔截 HTTPS 的請求與回應。\n","date":"2022-09-01T08:17:32+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/61/","title":"Fiddler 攔截 HTTPS 封包"},{"content":" 📢 本文由 Gemini-3-flash 翻譯 引言 今天使用 Git 推送時出現提示 fatal: unable to access 'https://github.com/yexca-VRChat/yexca-VRChat.github.io.git/': Failed to connect to 127.0.0.1 port 1081 after 2074 ms: Connection refused，重新啟動電腦也沒用，於是尋找解決方法 (為什麼不讓我存取自己的儲存庫)\n解決過程 經查閱相關資料後得知與代理伺服器（Proxy）有關，但我代理伺服器是設在路由器上啊\n於是我連線到另一個普通路由器再次推送，還是出現同樣的問題\n接著嘗試設定 Git 的代理伺服器也無果\n1 2 git config --global --unset http.proxy git config --global --unset https.proxy 最後想到我 WinXray 貌似、好像、大概開過吧，然後打開一看，果然開啟了 PAC，關閉後再次推送成功\n參考文章 fatal: unable to access \u0026lsquo;https://github.com/fmoraless/e-commerce.git/\u0026rsquo;: Failed to connect to 127.0.0.1 port 56832: Connection refuse · Issue #11981 · desktop/desktop 解決 git 下載出現：Failed to connect to 127.0.0.1 port 1080: Connection refused 拒絕連線錯誤_點亮～黑夜的博客-CSDN博客 git 報錯:解決拒絕存取問題_Huang_milk的博客-CSDN博客 ","date":"2022-08-15T02:44:47+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/58/","title":"GitHub 拒絕存取 Connection refused"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 引言 使用 Git 可以更好地和朋友一起管理程式碼，也方便同步程式碼。由於我比較喜歡靜態網站，因此使用 Git 同步網頁檔案非常實用。\n安裝 Git 登入 ROOT 帳號，依序輸入以下指令\n1 2 yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel perl-devel yum install git 建立使用者 建立一個 Git 使用者群組和使用者，用於執行 Git 服務\n1 2 groupadd git useradd git -g git 公開金鑰獲取 此部分為自己電腦的公開金鑰，以 Windows 為例\n在 %UserProfile%/.ssh/ 目錄下 id_rsa.pub 檔案儲存\n如果沒有此檔案，開啟 cmd 執行 ssh-keygen 指令會自動產生\n匯入公開金鑰 將待匯入的公開金鑰匯入 /home/git/.ssh/authorized_keys 檔案中，一行一個。如果沒有該檔案，則建立一個\n1 2 3 4 5 cd /home/git/ mkdir .ssh chmod 755 .ssh touch .ssh/authorized_keys chmod 644 .ssh/authorized_keys 然後使用 vi 或 vim 指令將公開金鑰匯入，使用參考： vim 文字編輯 初始化 Git 儲存庫 選定一個目錄作為 Git 儲存庫，假設為 /home/gitrepo/repo.git\n1 2 3 4 5 cd /home mkdir gitrepo chown git:git gitrepo cd gitrepo git init --bare repo.git 以上指令 Git 會建立一個空儲存庫，伺服器上的 Git 儲存庫通常都以 .git 結尾。然後，將儲存庫所屬使用者改為 git：\n1 chown -R git:git runoob.git 克隆儲存庫 1 2 3 git clone git@您的IP:倉庫目錄 // 例如 git clone git@127.0.0.1:/home/gitrepo/repo.git 同步目錄 自動同步功能用到的是 Git 的掛鉤 (hook) 功能\n進入儲存庫目錄 /home/gitrepo/repo.git\n1 2 cd /home/gitrepo/repo.git cd hooks 建立並編輯檔案 post-receive\n1 vi post-receive 在該檔案寫入以下內容\n1 2 #!/bin/sh git --work-tree=同步到的目錄 --git-dir=倉庫位置 checkout -f 例如\n1 2 #!/bin/sh git --work-tree=/home/www/hexo --git-dir=/home/gitrepo/repo.git checkout -f 然後設定該檔案讀寫權限\n1 chmod +x post-receive 改變 repo.git 目錄的擁有者為 git 使用者\n1 chown -R git:git /home/gitrepo/repo.git 更新程式碼 如果你能確定什麼都沒有改動過只是更新本地程式碼，直接使用\n1 git pull 正規流程\n1 2 3 4 5 6 7 8 9 // 查看本地分支檔案資訊，確保更新時不產生衝突 git status // 如果檔案有修改，可以還原到最初狀態; 如果檔案需要更新到伺服器上，應該先合併 (merge) 到伺服器，再更新到本地 git checkout – [file name] // 查看目前分支情況 git branch // 如果分支為本地分支，則需切換到伺服器的遠端分支 git checkout remote branch git pull 其他指令 1 2 3 4 git branch // 看看分支 git checkout aaa // 切換分支aaa git branck aaa // 建立aaa分支 git chechout -b aaa // 本地建立 aaa分支，同時切換到aaa分支。只有提交的時候才會在伺服器上建立一個分支 禁用 git 使用者的 shell 登入權限 出於安全考量，我們要讓 git 使用者不能透過 shell 登入。可以編輯 /etc/passwd 來實現\n1 vi /etc/passwd 將\n1 git:x:1004:1004::/home/git:/bin/bash 改為\n1 git:x:1004:1004::/home/git:/usr/bin/git-shell 這樣 git 使用者可以透過 ssh 正常使用 git，但是無法登入 sehll\n參考文章 Linux chown 指令-菜鳥教學 Git 伺服器建置-菜鳥教學 Git - 產生 SSH 公開金鑰 SSH key 的介紹與在 Git 中的使用 - 簡書 Git - 在伺服器上建置 Git git 更新程式碼到本地_ftToday 的部落格-CSDN 部落格 如何在伺服器上建置 hexo 部落格-阿里云開發者社群 Linux 權限詳解（chmod、600、644、700、711、755、777、4755、6755、7755）_林20 的部落格-CSDN 部落格 詳細解析 Linux /etc/passwd 檔案 - Jtianlin - 部落格園 ","date":"2022-08-13T10:28:50+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/57/","title":"建立 Git 伺服器並同步到指定目錄"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 這篇文章由 Hiyoung 撰寫\n其文章: https://blog.hiyoung.icu/2022/08/11/607cac6fe835/ 現在主流串流媒體網站都支援外連嵌入程式碼，但是 B 站 (什麼時候倒閉?) 現在 (2022/8/11) 內建的外連引用預設為 360P，且不能調節解析度，非常地討厭，與 Youtube 相比高下立判，下面重點介紹一下 B 站引用外連的參數和方法。\nBilibili 外連引用 原版引用連結：\n1 \u0026lt;pre class=\u0026#34;language-html\u0026#34; data-info=\u0026#34;HTML\u0026#34; data-role=\u0026#34;codeBlock\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token tag\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token tag\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026lt;\u0026lt;/span\u0026gt;iframe\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token attr-name\u0026#34;\u0026gt;src\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token attr-value\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation attr-equals\u0026#34;\u0026gt;=\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;//player.bilibili.com/player.html?aid=80433022\u0026amp;bvid=BV1GJ411x7h7\u0026amp;cid=137649199\u0026amp;page=1\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token attr-name\u0026#34;\u0026gt;scrolling\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token attr-value\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation attr-equals\u0026#34;\u0026gt;=\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;no\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token attr-name\u0026#34;\u0026gt;border\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token attr-value\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation attr-equals\u0026#34;\u0026gt;=\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;0\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token attr-name\u0026#34;\u0026gt;frameborder\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token attr-value\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation attr-equals\u0026#34;\u0026gt;=\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;no\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token attr-name\u0026#34;\u0026gt;framespacing\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token attr-value\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation attr-equals\u0026#34;\u0026gt;=\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;0\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token attr-name\u0026#34;\u0026gt;allowfullscreen\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token attr-value\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation attr-equals\u0026#34;\u0026gt;=\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;true\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token tag\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token tag\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026lt;/\u0026lt;/span\u0026gt;iframe\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; 修改後引用連結：\n1 \u0026lt;pre class=\u0026#34;language-html\u0026#34; data-info=\u0026#34;HTML\u0026#34; data-role=\u0026#34;codeBlock\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token tag\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token tag\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026lt;\u0026lt;/span\u0026gt;iframe\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token attr-name\u0026#34;\u0026gt;src\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token attr-value\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation attr-equals\u0026#34;\u0026gt;=\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;//player.bilibili.com/player.html?aid=80433022\u0026amp;bvid=BV1GJ411x7h7\u0026amp;cid=137649199\u0026amp;page=1\u0026amp;as_wide=1\u0026amp;high_quality=1\u0026amp;danmaku=1\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token attr-name\u0026#34;\u0026gt;scrolling\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token attr-value\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation attr-equals\u0026#34;\u0026gt;=\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;no\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token attr-name\u0026#34;\u0026gt;border\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token attr-value\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation attr-equals\u0026#34;\u0026gt;=\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;0\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token attr-name\u0026#34;\u0026gt;frameborder\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token attr-value\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation attr-equals\u0026#34;\u0026gt;=\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;no\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token attr-name\u0026#34;\u0026gt;framespacing\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token attr-value\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation attr-equals\u0026#34;\u0026gt;=\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;0\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token attr-name\u0026#34;\u0026gt;allowfullscreen\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token attr-value\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation attr-equals\u0026#34;\u0026gt;=\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;true\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token tag\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token tag\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026lt;/\u0026lt;/span\u0026gt;iframe\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; 嗶哩嗶哩外連 key 說明 key 說明 aid 之前 B 站使用的 AV 號 bvid 目前的 BV 號 page 第幾個影片, 起始下標為 1 (預設值也是 1) 就是 B 站影片選集裡的第幾個影片 as_wide 是否寬螢幕 【1: 寬螢幕, 0: 小螢幕】 high_quality 是否高畫質 【1: 高畫質 (最高 1080p) / 0: 最低影片畫質 (預設)】 danmaku 是否開啟彈幕 【1: 開啟 (預設), 0: 關閉】 vd_source=XXX\u0026amp;t=XXX 可加上精準空降位址 YouTube 外連引用 使用預設的 YouTube 外連即可，更進階功能可自行去 官方教學 學習。\n1 \u0026lt;pre class=\u0026#34;language-html\u0026#34; data-info=\u0026#34;HTML\u0026#34; data-role=\u0026#34;codeBlock\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token tag\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token tag\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026lt;\u0026lt;/span\u0026gt;iframe\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token attr-name\u0026#34;\u0026gt;width\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token attr-value\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation attr-equals\u0026#34;\u0026gt;=\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;560\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token attr-name\u0026#34;\u0026gt;height\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token attr-value\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation attr-equals\u0026#34;\u0026gt;=\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;315\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token attr-name\u0026#34;\u0026gt;src\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token attr-value\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation attr-equals\u0026#34;\u0026gt;=\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;https://www.youtube.com/embed/OgcCOwj7wNY\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token attr-name\u0026#34;\u0026gt;title\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token attr-value\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation attr-equals\u0026#34;\u0026gt;=\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;YouTube video player\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token attr-name\u0026#34;\u0026gt;frameborder\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token attr-value\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation attr-equals\u0026#34;\u0026gt;=\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;0\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token attr-name\u0026#34;\u0026gt;allow\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token attr-value\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation attr-equals\u0026#34;\u0026gt;=\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token attr-name\u0026#34;\u0026gt;allowfullscreen\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token tag\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token tag\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026lt;/\u0026lt;/span\u0026gt;iframe\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; 影片演示 請前往 https://blog.hiyoung.icu/2022/08/11/607cac6fe835/ 觀看效果\nYoutube 1 2 3 4 5 6 7 8 9 \u0026lt;iframe allow=\u0026#34;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\u0026#34; allowfullscreen=\u0026#34;\u0026#34; frameborder=\u0026#34;0\u0026#34; height=\u0026#34;315\u0026#34; loading=\u0026#34;lazy\u0026#34; src=\u0026#34;https://www.youtube.com/embed/ucbx9we6EHk\u0026#34; title=\u0026#34;YouTube video player\u0026#34; width=\u0026#34;560\u0026#34;\u0026gt;\u0026lt;/iframe\u0026gt; ### Bilibili (修改前) \u0026lt;iframe allowfullscreen=\u0026#34;true\u0026#34; border=\u0026#34;0\u0026#34; frameborder=\u0026#34;no\u0026#34; framespacing=\u0026#34;0\u0026#34; scrolling=\u0026#34;no\u0026#34; src=\u0026#34;//player.bilibili.com/player.html?aid=499408391\u0026amp;bvid=BV16K411N7qj\u0026amp;cid=230404689\u0026amp;page=1\u0026amp;as_wide=1\u0026#34;\u0026gt; \u0026lt;/iframe\u0026gt; ### Bilibili (修改後) \u0026lt;iframe allowfullscreen=\u0026#34;true\u0026#34; border=\u0026#34;0\u0026#34; frameborder=\u0026#34;no\u0026#34; framespacing=\u0026#34;0\u0026#34; scrolling=\u0026#34;no\u0026#34; src=\u0026#34;//player.bilibili.com/player.html?aid=499408391\u0026amp;bvid=BV16K411N7qj\u0026amp;cid=230404689\u0026amp;page=1\u0026amp;high_quality=1\u0026amp;danmaku=1\u0026#34;\u0026gt; \u0026lt;/iframe\u0026gt; 參考資料： Sanarous 部落格 和 Google 外連 API 教學 ","date":"2022-08-12T00:11:17+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/56/","title":"部落格影片外連引用"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 前言 最早接觸 RSS 還是逛神社的時候，但當我知道有這麼個東西的時候 RSS 就幾乎凋零，不過還有類似於 RSSHub 之類的還在繼續為之奮鬥，不過 RSSHub 時常因網路問題無法連線，慢慢地就放棄了。隨著發現的部落格越來越多，為了能夠即時獲取更新以及記錄自己閱讀過以及未閱讀的文章，我再次使用 RSS\nRSS 簡介 RSS 的全稱是 Really Simple Syndication（簡易資訊聚合），它是一種訊息來源的格式規範，網站可以按照這種格式規範提供文章的標題、摘要、全文等資訊給訂閱使用者，使用者可以透過訂閱不同網站 RSS 連結的方式將不同的資訊來源進行聚合，在一個工具裡閱讀這些內容\n換句話說，與當前主流媒體推薦內容使我們被動獲取資訊不同，RSS 是主動尋找知識的過程，需要我們主動發掘資訊來源，而且只會顯示自己訂閱資訊來源的內容\n為什麼使用 RSS 拿起手機，打開資訊類 App，首頁就是推薦，再加上永遠刷不到底部的設計和基於大數據的喜好推薦，很容易就將一天的時間陷入這些觀點單一、毫無營養的內容。我不喜歡這種時間消逝的感覺，雖然學習之餘需要放鬆刷一下，但我始終堅持放鬆應該要由自己掌控，不應被這種被動式接受，所以使用 RSS 也是我對資訊繭房的一種抵抗吧\n往小了說，可能是為了標記自己未閱讀的文章，獲取自己關注的部落格的文章，也為了不錯過大神的文章吧\n往大了說，在現如今推薦演算法不斷升級、不斷精確的情況下，資訊繭房愈加嚴重，慢慢地失去了主動獲取資訊的能力，從而導致自己視野受限，甚至於失去學習能力\n如何使用 首先需要 RSS 閱讀器，我選擇 QuiteRSS ，是一款開源軟體\n然後需要 RSS 訂閱來源，這個需要自行尋找啦，如果網站不提供可以到 RSSHub 尋找是否有發布相關訂閱來源 (請保持網路環境正常)\n如何尋找 RSS 訂閱來源： 如何尋找要與 Feedzy RSS Feeds 一起使用的 RSS Feed URL 比如說本站的簡體中文 RSS 訂閱來源： https://blog.yexca.net/feed.xml 檢測是否為訂閱來源： Feed Validator for Atom and RSS 複製訂閱來源，打開軟體，建立新訊息來源即可\n後記 唉，本來想著描述得挺好的，但真正寫的時候我發現我無法使用語言來表達自己所要抒發的情感，不是無法使用語言表達，只是可能我深受各種網路資訊毒害，可能……已經不會寫文章了吧……\n寫之前想了很多，但真到寫的時候卻完全不知道怎麼表達，就這樣吧！\n參考文章/推薦閱讀 求問神社的 rss 是啥啊 高效獲取資訊，你需要這份 RSS 入門指南 - 騰訊雲開發者社區 RSS - 維基百科 RSS 凋零——主動獲取資訊到推送時代 什麼是 RSS？ ","date":"2022-08-09T16:08:14+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/55/","title":"RSS"},{"content":"notify: 📢 本文由 gemini-2.5-flash 翻譯 前言 昨日玩遊戲時接取第一個任務的記錄，由於是複述，部分細節可能與實際情況不同。\n接取任務 在通過某神秘人的考驗後取得 HackShop 的網站，接到第一個任務。\n任務內容為：「The client wants the login credentials of the user Daronane. The remote ip of the victim is 54.44.37.52. It\u0026rsquo;s important that you access the correct machine behind the public ip. The victim\u0026rsquo;s ip LAN is 172.16.6.7。」\n任務分析 任務要求為 Daronane 的登入憑證，受害者的公開 IP 位址為 54.44.37.52，區域網路 IP 位址為 172.16.6.7。\n初步試探 依照 Grey Hack 單人模式遊戲攻略（1）-MapleGe 文章所述的方法嘗試。\n首先使用 whois 指令取得管理員電子郵件地址為 Eggett@sabmi.net，向該電子郵件寄送 Login issue 郵件以取得 Daronane 的密碼 pierra。\n嘗試使用 SSH 連線 54.44.37.52，輸入指令 ssh Daronane@pierra 54.44.37.52 後發現連線失敗，錯誤訊息為 incorrect user/password。\n我懷疑是我輸入錯誤 (畢竟是手動輸入的帳號密碼)，然後嘗試了幾次，甚至複製貼上也是帳號或密碼錯誤，便停止嘗試。\n我使用瀏覽器存取該 IP 位址，自然是沒什麼線索，只有一行文字 Metlifegroup. Everything you need for your tech company 與一張圖片 (貌似是樹莓派)，猜測該網站可能是一個討論區，而受害者 Daronane 為該討論區的使用者？\n遊戲中文化 想到在存取 HackShop 時彈出的 Exploits 教學有部分我沒看懂，於是尋找該遊戲的中文化，開啟創意工坊，果然找到了該遊戲的繁體中文化 [简体中文](simplified Chinese)，訂閱後重新啟動遊戲，卻發現介面沒有中文化。\n找到創意工坊的下載位址：steam資料夾\\steamapps\\workshop\\content\\605230\\2825584160。透過閱讀 README.md 檔案得知，需要將該資料夾下的內容放至 C:\\Users\\%UserName%\\AppData\\LocalLow\\Loading Home\\Grey Hack\\ 資料夾下。\n事實上，只需要將 custom_lang.json 放入上述資料夾即可。\n重新進入遊戲後，在左側的 language 選擇 Chinese 即可中文化。\n閱讀手冊 閱讀中文化後手冊的 Exploits 部分 (發現跟沒中文化差不多)，還是不大理解這個東西是做什麼的。\n繼續探尋 繼續搜尋相關攻略，卻一無所獲，直到看到文章 Grey Hack: 一個比較簡單的任務 - 嗶哩嗶哩 。\n文章中腳本小子一詞使我了解到這個 Exploits 相當於現實中的攻擊腳本。\n錯誤探索 到 HackShop 下載工具 scanlib 與 scanrouter。\n嘗試執行指令 scanlib 54.44.37.52，提示 Missing metaxploit，看不懂。\n使用指令 nmap 54.44.37.52，得知該伺服器開放兩個連接埠，分別為 22 和 80，各自提供 SSH 與 HTTP 服務。\n使用指令 scanrouter 得知該伺服器有 Kernel_router.so:V1.0.0，然後尋找相關腳本，找到一個腳本描述為 Get access to a shell，沒有要求。\n我將該腳本下載到 /home/yexca/hacktool，然後在終端機進入該資料夾並輸入指令 KernelRouterAccess 54.44.37.52，錯誤提示為 Can't find metaxploit library in the /lib path or the current folder。\n註：一開始沒有重新命名，後來重新命名為 KernelRouterAccess，本文以此名稱為例撰寫，本文其他腳本均為後續重新命名，與商店中原名稱不同\n從錯誤來看是缺少檔案，看到 /lib 難道是對方伺服器沒有相應檔案無法辨識，因此無法進入嗎？\n再次思索 考慮到透過 nmap 指令得知這個伺服器開放 22 和 80 埠，又上述猜測受害者為該討論區使用者，於是到 HackShop 尋找 http 腳本，找到一個腳本描述為 Grant access to the file /etc/passwd and decipher its contents，要求為 Minimum number of 1 users registered in the computer，也就是至少一名使用者，該網站為討論區，估計應該不會直接使用 root 帳號進行開發吧，而且估計是多使用者開發。\n下載腳本後輸入指令 HttpPasswd 54.44.37.52 80，和使用上一個腳本一樣提示 Can't find metaxploit library in the /lib path or the current folder。\n我並沒有感到驚訝，因為透過 scanrouter 指令掃描只發現 Kernel_router.so:V1.0.0，沒有 libhttp.so 之類的函式庫。\n事實上我選擇 HTTP 腳本，也是由於上述文章提到其實只要完成任務就行，不需要遠端連線，你在本機執行腳本也不會留下痕跡。\n然後我想著那就繼續嘗試 SSH 吧，便進入 HackShop 尋找相應腳本，找到一個腳本描述為 Take advantage of a vulnerability in the ssh service to inject a new password to a registered user，要求為 Any user logged in the computer，也就是有使用者登入過，考慮到開發該網站一定需要登入，所以該要求應該可以達到。\n下載腳本後輸入指令 SSHPasswd 54.44.37.52 22，還是提示 Can't find metaxploit library in the /lib path or the current folder。\n這**怎麼玩？？？貴伺服器的 /lib 是什麼都沒有嗎？難道我要每種腳本都試一遍來確定 /lib 有什麼嗎？？？？那我豈不是會破產啊。\n進入正軌 於是我借助搜尋引擎尋找攻略，卻發現沒有。\n再次回想之前看到的錯誤條件 Can't find metaxploit library in the /lib path or the current folder，我只看到了前面的 /lib 以及看不懂的 metaxploit，仔細查看後面有一個 or the current folder，這個 目前資料夾 是指什麼呢？難道是我電腦上該腳本所在的資料夾，那我為了進攻豈不是要把相應的函式庫像 libssh.so 之類的都下載一遍？\n開啟黑市，並沒有像 libssh.so 之類的函式庫，聯想到該遊戲有指令 apt-get，在現實 Linux 中可以下載相關程式，於是在遊戲中輸入指令 apt-get search ssh，果不其然有一個 libssh.so，使用指令 apt-get install libssh.so 安裝 SSH。\n安裝完成後輸入指令 SSHPasswd 54.44.37.52 22，結果還是提示 Can't find metaxploit library in the /lib path or the current folder。\n我真是服了！！！\n再次開啟 HackShop，我把 Tools 下的每個商品都看了一遍，其中 metaxploit.so 引起我的注意，這不就是錯誤訊息中的那個 metaxploit 嘛！再結合錯誤訊息中的 current folder，是不是因為缺少這個東西才報錯啊。\n下載至腳本所在的資料夾 (/home/yexca/hacktool)，考慮到 scanrouter 指令只掃描到 Kernel_router.so，嘗試執行 KernelRouterAccess 54.44.37.52，果然，取得了進入權限！\n取得權限 取得進入權限後，想著先去刪除紀錄檔，輸入指令 FileExplorer.exe，存取 /var/system.log，提示 Permission denied，權限不足。然後發現這個腳本取得的是訪客權限，那我找密碼檔案吧，存取 /etc/passwd，還是提示 Permission denied (事實上我幾乎把該電腦的檔案都看了一遍)。\n啊這，那我買這個腳本有什麼用啊！\n因為 SSH 腳本是更改密碼，風險較高，所以我使用 HTTP 腳本來取得密碼。輸入指令 HttpPasswd 54.44.37.52 80，結果提示 can't read /etc/passwd. Permission denied，看到取得的權限是 guest，我**\n最後還是使用 SSH 腳本，輸入指令 SSHPasswd 54.44.37.52 22，輸入新密碼 114514，成功修改了 Farraze 的密碼。\n輸入指令 ssh Farraze@114514 54.44.37.52，成功進入受害者的機器，輸入指令 cat /etc/passwd，成功取得 root 的密碼加密資訊。\n在本機新建一個檔案 (touch mima.txt)，將 root 密碼資訊複製到裡面，然後解密 decipher mima.txt，成功取得 root 的密碼為 44444 (這密碼也太隨便了吧)。\n輸入指令 exit 中斷連線，接著輸入 ssh root@44444 54.44.37.52，成功以 root 權限登入。\n進入機器 進入後第一件事就是刪除紀錄檔，然後該機器的使用者有 Ralancl 和 Farraze，沒有受害者 Daronane，果然是討論區使用者嗎？但我將這台機器翻了一遍也沒找到相關東西 (順便把這兩個帳戶的錢轉到我的帳戶上啦~)\n回想任務內容，提到了 IP 172.16.6.7。\n輸入指令 ping 172.16.6.7，顯示 Ping successful，使用自己的電腦無法 Ping 通 (這根本是廢話，內部網路的機器怎麼可能 Ping 通)。\n輸入指令 nmap 172.16.6.7 查看開放埠，提示 command not found，指令未找到。\n啊這，那我只好將我電腦的指令檔案放到該電腦的 /bin 目錄下了。\n複製過去後再次輸入指令 nmap 172.16.6.7，可以看到開放了 3306 埠，服務為 employees，這是什麼東西？\n透過搜尋引擎得知 3306 埠一般為資料庫埠，也就是說需要使用 SQL 的腳本。\n取得密碼 進入 HackShop，搜尋相關腳本，找到一個腳本描述為 Take advantage of a vulnerability in the sql service to inject a new password to a registered user，要求為 Any user logged in the computer，也就是有使用者登入過，資料庫的建立必然要有使用者登入過啊。\n下載後輸入指令 SqlChangePasswd 172.16.6.7 3306，提示 Connection refused. Address unreachable，存取被拒。確實，資料庫肯定是白名單的啦。\n將腳本與 metaxploit.so 放到受害者機器 /root 資料夾下，再次輸入指令，修改密碼為 114514，修改使用者為 Osquel。\n那麼現在問題來了，我修改密碼然後呢？這伺服器只開放了 3306 埠，我也進不去啊 XD\n好吧，再次進入 HackShop，搜尋相關腳本，找到一個腳本描述為 Prints the contents of the file /etc/passwd，要求為 Any user logged in the computer，也就是有使用者登入過，和剛剛腳本的要求一樣。\n將腳本放到受害者機器 /root 資料夾下，輸入指令 SqlPrintPasswd 172.16.6.7 3306，得到該機器所有使用者的密碼，其中有受害者 Daronane 的。\n複製到自己的電腦並解密後得到密碼為：pierra。\n？？？我將此密碼傳送給客戶，得到了肯定的答覆？？？\n我**\n精彩！ (來自於 YouTuber 黑鏢客 的梗)\n後記 一開始就透過電子郵件取得了密碼，然後我一番折騰後再次取得了密碼 (這真的讓我超無言的)。\n收入為 200，但我購買腳本花費遠大於 200 (整體來說還是蠻虧的)，不過腳本可以重複使用，而且探索的過程也是很有趣的喔！\n這款遊戲的攻略可以說幾乎沒有啊，如果您正在尋找相關攻略，希望這篇文章能有所幫助。\n","date":"2022-08-03T22:41:06+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/54/","title":"記錄 Grey Hack 第一個任務 (取得密碼)"},{"content":" 📢 本文由 Gemini-3-flash 翻譯 這篇文章由 Hiyoung 撰寫\n其文章: https://blog.hiyoung.icu/2022/08/03/0b5e2db181ab/ 最近經常要使用 GitHub 儲存我學習過程中的程式碼，發現無法直接上傳資料夾，於是在網路上查了一下如何使用 Git 上傳，所以寫篇部落格文章記錄一下。\nGitHub 端操作 1. 複製儲存庫網址 本地端操作 1. 在本地端新建一個空資料夾 我這裡已經 clone 完成\n2. 在資料夾內開啟 Git Bash 視窗 3. Clone 遠端儲存庫 1 2 \u0026lt;pre class=\u0026#34;language-bash\u0026#34; data-info=\u0026#34;bash\u0026#34; data-role=\u0026#34;codeBlock\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token function\u0026#34;\u0026gt;git\u0026lt;/span\u0026gt; clone + 你的儲存庫網址 \u0026lt;span class=\u0026#34;token function\u0026#34;\u0026gt;git\u0026lt;/span\u0026gt; clone https://github.com/hiyoung3937/study_code.git //範例 4. 直接將需要上傳的檔案拖入即可 5. 上傳 1 2 3 4 5 \u0026lt;pre class=\u0026#34;language-bash\u0026#34; data-info=\u0026#34;bash\u0026#34; data-role=\u0026#34;codeBlock\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token builtin class-name\u0026#34;\u0026gt;cd\u0026lt;/span\u0026gt; study_code.git //根據自己的遠端儲存庫名稱輸入 \u0026lt;span class=\u0026#34;token function\u0026#34;\u0026gt;git\u0026lt;/span\u0026gt; init \u0026lt;span class=\u0026#34;token function\u0026#34;\u0026gt;git\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token function\u0026#34;\u0026gt;add\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token builtin class-name\u0026#34;\u0026gt;.\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token function\u0026#34;\u0026gt;git\u0026lt;/span\u0026gt; commit -m “你的提交訊息” \u0026lt;span class=\u0026#34;token function\u0026#34;\u0026gt;git\u0026lt;/span\u0026gt; push 指令說明 clone + 儲存庫網址 複製你的儲存庫至本地端 cd + 你的遠端儲存庫名 進入到遠端儲存庫內 (根據自己的儲存庫名稱輸入) git init 初始化 Git git add . 將工作區的檔案新增至暫存區（「.」是目前目錄下的所有檔案，也可只輸入資料夾名稱） git commit -m “你的提交訊息” 將暫存區的檔案新增至本地端儲存庫 git push 推送至遠端儲存庫（可能需要輸入帳號與密碼） ","date":"2022-08-03T12:49:27+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/53/","title":"使用 Git 上傳檔案至 GitHub"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 前言 哪個男孩不想用命令列執行一些東西來耍帥呢？之前我稍微了解過 youtube-dl，但看起來太複雜就沒去用，今天嘗試用過之後發現超級好用啊！\n環境 安裝 Python3.7+ 直接到 Python 官網 下載並安裝即可，安裝時記得勾選Add Python x.x to PATH\n安裝 yt-dlp yt-dlp 是基於 youtube-dl 修改的，實際測試下載速度比較快。\n下載 進入 releases 下載 yt-dlp.exe\n設定 把下載的檔案放到一個固定位置，開啟 我的電腦 的 內容，進入 進階系統設定 -\u0026gt; 環境變數 -\u0026gt; 系統變數，選取 Path，點選編輯，在新視窗點選新增，輸入 yt-dlp.exe 檔案所在的資料夾路徑。\n接著連續點三個 確定 來關閉所有視窗。\n測試 按下 Win+R 輸入 cmd，然後按 Enter 鍵。\n在 cmd 中輸入 yt-dlp，如果出現 Usage: yt-dlp [OPTIONS] URL [URL...] 就代表設定成功。\n更新 在 cmd 中輸入 yt-dlp -U 即可。\n下載影片 直接在 cmd 中輸入 yt-dlp+空白鍵+YouTube 影片連結 即可開始下載。\n預設會下載 720P 的畫質，儲存位置在 C:/Users/%UserName%/\n修改下載儲存位置 在 C:\\Users\\%UserName%\\AppData\\Roaming 建立一個資料夾並命名為 yt-dlp，接著進入剛建立的資料夾內，再建立一個檔案 config.txt。\n在檔案內輸入以下程式碼\n1 -o \u0026#39;C:/Users/%UserName%/Downloads/Video/%(title)s.%(ext)s\u0026#39; 其中 C:/Users/%UserName%/Downloads/Video/ 為下載目錄。\n%(title)s.%(ext)s 為儲存檔案名稱的格式，此處為影片標題.影片副檔名。\n下載 1080P 因為 1080P (含) 以上的影片是音訊和視訊分離的，所以需要先下載 ffmpeg。\nffmpeg 進入 官網 ，左下角選擇系統類型，接著選擇下載。\n我選擇的是 Releases · BtbN/FFmpeg-Builds ，下載 ffmpeg-n5.0-latest-win64-gpl-5.0.zip。\n接著放到一個固定資料夾，並把 bin 檔案目錄放到系統變數裡。\n測試 開啟 cmd，輸入 ffmpeg -version，如果出現版本號就代表設定成功。\n查詢命令 輸入 yt-dlp -D [URL] 即可查看目前影片的所有格式 (僅查詢，不下載)。\n下載命令 輸入 yt-dlp -f [ID] [URL] 來下載指定格式的影片，也可以使用 [ID]+[ID] 組合來下載影片和音訊，也就是 yt-dlp -f [ID]+[ID] [URL]，下載完成後會自動合併。\n註：下載最高畫質與音訊：-f \u0026quot;bv+ba/b\u0026quot;\n呼叫 aria2 在下載命令後加入 --external-downloader aria2c --external-downloader-args \u0026quot;-x 16 -k 1M\u0026quot; 即可。\n下載字幕 1 2 3 4 5 6 7 outube-dl --write-sub [url] // 這樣會下載一個 vtt 格式的英文字幕和 mkv 格式的 1080p 影片下來 youtube-dl --write-sub --skip-download [url] // 下載單獨的 vtt 字幕檔，而不會下載影片 youtube-dl --write-sub --all-subs [url] // 下載所有語言的字幕 (如果有的話) youtube-dl --write-auto-sub [url] // 下載自動產生的字幕 (YouTube only) 下載影片清單 1 2 3 4 5 6 7 youtube-dl -f [format code] [palylist_url] // 這種方式可以下載指定清晰度的 mp4 影片 youtube-dl [playlist_url] // 下載影片清單，這種方式下載的影片可能是 mkv 格式或 webm 格式 youtube-dl -cit [playlist_url] // 下載影片清單，這種方式下載的影片可能是 mkv 格式或 webm 格式 youtube-dl --yes-playlist [url] // 當連結為影片清單時，則下載該清單的影片，跟上面的一樣，可能是 mkv 或 webm 格式 視覺化介面 Releases · jely2002/youtube-dl-gui 參考文章 yt-dlp 的 Github 頁面 【備份】youtube-dl 使用介紹 - 簡書 一篇搞懂 Windows 系統【目錄變數】的相關知識_黑就黑到底的部落格-CSDN部落格_username變數 ","date":"2022-07-25T12:52:27+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/52/","title":"用命令列下載 YouTube 影片"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 前言 近日上網時發現一款覺得還不錯的字型，便找尋更換字型的方法。但實際使用下來並沒有那麼驚艷\n方法一 左下方「管理」-「設定」(或者快速鍵CTRL+,)進入設定介面，找到「Editor:Font Family」\n將預設的 Consolas, 'Courier New', monospace 改為要更換的字型即可\n方法二 Ctrl + Shift + P -\u0026gt; 輸入 settings.json -\u0026gt; 選擇 「Preferences:Open Settings(JSON)」 開啟 settings.json 檔案，然後將 \u0026quot;editor.fontFamily\u0026quot;: \u0026quot;要更改的字型\u0026quot;加入到 {} 中並儲存即可\n中英文字型分開設定 我們可以觀察到 VS Code 的預設字型有三種，以 , 區隔：Consolas, 'Courier New', monospace，若要為中英文設定不同的字型，只需要將第一個和第二個分別設定一個英文字型和一個中文字型（英文字型, 中文字型）即可，例如SF NS Mono, '楷體'\n","date":"2022-07-13T17:47:57+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/51/","title":"VS Code 更換字型"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 似乎沒有解決方法，不過可以將快速存取中自己加入的全部刪除 (恢復預設)\n前往 C:\\\\Users\\\\使用者名稱\\\\AppData\\\\Roaming\\\\Microsoft\\\\Windows\\\\Recent\\\\AutomaticDestinations，將此資料夾目錄下的檔案備份後全部刪除\n參考文章 FTP 位址無法從快速存取中移除，但其他資料夾可以 – Microsoft Community ","date":"2022-06-27T13:31:58+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/50/","title":"Windows 網路位址 (FTP 位址) 取消快速存取"},{"content":" 📢 本文由 Gemini-3-flash 翻譯 引言 今天嘗試了一下之前試過的無線中繼，發現已經忘記怎麼做了，果然實作過的東西還是要寫篇文章記錄一下比較好。\n在本文中，將 OpenWRT 路由器連接的 Wi-Fi 稱為上層路由，OpenWRT 路由器稱為路由器。\n前提 確保路由器與上層路由的 LAN 埠位址（即進入路由器後台的位址）不可與上層路由一致，若一致將無法上網。\n修改路由器 LAN 埠位址 進入路由器後台的「網路」-「介面」，點擊「LAN」的「修改」，更改其「IPv4 位址」即可。\n例如上層路由後台位址為 192.168.1.1，路由器可改為 192.168.5.1。\n修改完成並「儲存並套用」後，在瀏覽器輸入修改後的位址即可訪問路由器後台。\n路由器連接 Wi-Fi 進入「網路」-「無線」，點擊「掃描」，找到要連接的 Wi-Fi，點擊「加入網路」，輸入網路名稱與密碼，點擊「提交」，然後點擊「儲存並套用」即可。\n路由器開啟 Wi-Fi 如果路由器支援 2.4G 與 5G 雙頻段，可以選擇與上一步不同的頻段建立 Wi-Fi，這樣相容性最好。（如果另一個頻段已經有一個 Wi-Fi，可能已經可以使用了）\n如果只有單頻段，則在相同頻段新建一個。必須要新建，且不一定會成功，畢竟有些路由器不支援單網卡同時接收與發送。\n設定 Wi-Fi 與一般流程相同，在「網路」-「無線」處新增，輸入 SSID（即 Wi-Fi 名稱）和密碼，然後「儲存並套用」即可。\n參考文章 OpenWrt 进阶教程之无线中继配置指南 - 爱一枝梅 ","date":"2022-06-23T14:50:21+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/49/","title":"OpenWRT 無線中繼"},{"content":" 📢 本文由 Gemini-3-flash 翻譯 引言 由於騰訊雲函數從六月開始收費，於是便棄用改在自己的伺服器上架設\n既然六月收費為什麼現在才寫文章呢？因為可能還有三個月的免費試用我米遊社的 Cookie 過期更換，故紀錄一下\n工具 \u0026amp; 原教學 原神簽到小助手 每日福利不用愁 - 銀彈博客 由於原文介紹了多種使用方法，自己的閱讀體驗不是太好，故寫此文\n騰訊雲函數處理 請將騰訊雲函數凍結以確保不會產生費用\n當然，如果沒什麼其他需求可直接註銷帳號，但註銷帳號需要手持身分證照片，請注意\n前提 伺服器可以連接上米哈遊的伺服器 https://mihoyo.com 可在 SSH 命令列視窗輸入 ping mihoyo.com 測試是否可以連線\n我的一個伺服器就連不上，只好換一個，唉\nDocker 安裝 可以直接使用一鍵腳本進行安裝，實測 Debian 10 和 CentOS 7 正常安裝 (請使用 root 帳戶)\n安裝指令如下：\n1 curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun 也可以使用中國大陸 daocloud 一鍵安裝指令：\n1 curl -sSL https://get.daocloud.io/docker | sh 腳本安裝 使用以下指令即可\n1 docker pull yindan/genshinhelper CentOS 錯誤 我使用 CentOS 安裝時出現錯誤 Can't Connect to Docker Daemon\n請確保使用 root 帳戶，然後輸入以下指令\n1 systemctl start docker 簡易使用 Cookie 獲取 獲取米遊社 Cookie 請參考： 原神樹脂查看/推播 – yexca\u0026rsquo;Blog 注意：Cookie 應包含 account_id 和 cookie_token 兩個欄位\n多帳號在不同 Cookie 中間加 # 即可，例如 Cookie1#Cookie2#Cookie3\n簡易配置 1 2 3 4 docker run -d --name=genshinhelper \\ -e COOKIE_MIHOYOBBS=\u0026#34;\u0026lt;COOKIE_MIHOYOBBS\u0026gt;\u0026#34; \\ --restart always \\ yindan/genshinhelper:latest 將自己的 Cookie 替換上述指令的 \u0026lt;COOKIE_MIHOYOBBS\u0026gt; 即可\n重新配置/更新 Cookie 重新配置好像需要解除安裝再重裝，然後再進行配置\n或者使用設定檔只需替換 Cookie 就可以了吧 (沒用過，Cookie 有效期很長的)\n常用指令 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 查看 Docker 所有的容器 docker ps -a # 查看日誌 docker logs -f genshinhelper --tail 100 # 重啟 docker restart genshinhelper # 更新 docker pull yindan/genshinhelper docker rm -f genshinhelper # 之後依據基本使用或進階使用重新部署 # 卸載 docker rm -f genshinhelper docker image rm genshinhelper 進階使用 可下載範例檔案修改\nGithub: config.json Telegram: https://t.me/genshinhelperupdates/5 安裝 假設設定檔位於伺服器的 /etc/genshin/config.json，使用以下指令映射配置\n1 2 3 4 docker run -d --name=genshinhelper \\ -v /etc/genshin:/app/genshincheckinhelper/config \\ --restart always \\ yindan/genshinhelper:latest 配置 設定檔可以只留下需要的參數，把非必須的參數刪除，例如只需要 Cookie\n則設定檔除了保持完整也可以寫成：\n1 2 3 { \u0026#34;COOKIE_MIHOYOBBS\u0026#34;: \u0026#34;\u0026lt;COOKIE_MIHOYOBBS\u0026gt;\u0026#34;, } 設定檔新增 RANDOM_SLEEP_SECS_RANGE：隨機延遲休眠秒數範圍，單位：秒。設置成 \u0026ldquo;0-0\u0026rdquo; 為取消延遲。 CHECK_IN_TIME：每日簽到時間。該時間和執行環境的時間有關，和時區無關。如果是 docker，可以用 TZ=Asia/Shanghai 設置時區。 CHECK_RESIN_SECS：原神原粹樹脂檢測間隔時間，單位：秒。 COOKIE_RESIN_TIMER：需要開啟原粹樹脂檢測帳號的 cookie。 SHOPTOKEN：微信積分商城的 token，透過封包擷取獲取。 ONEPUSH：推播配置。notifier 為推播名稱，params 為所需參數。詳見後文。\nOnePush 推播參數一覽 推播名稱 / notifier: bark\n參數大全 / params:\n{\u0026lsquo;required\u0026rsquo;: [\u0026lsquo;key\u0026rsquo;], \u0026lsquo;optional\u0026rsquo;: [\u0026rsquo;title\u0026rsquo;, \u0026lsquo;content\u0026rsquo;, \u0026lsquo;sound\u0026rsquo;, \u0026lsquo;isarchive\u0026rsquo;, \u0026lsquo;icon\u0026rsquo;, \u0026lsquo;group\u0026rsquo;, \u0026lsquo;url\u0026rsquo;, \u0026lsquo;copy\u0026rsquo;, \u0026lsquo;autocopy\u0026rsquo;]}\n推播名稱 / notifier: custom\n參數大全 / params:\n{\u0026lsquo;required\u0026rsquo;: [\u0026lsquo;url\u0026rsquo;], \u0026lsquo;optional\u0026rsquo;: [\u0026lsquo;method\u0026rsquo;, \u0026lsquo;datatype\u0026rsquo;, \u0026lsquo;data\u0026rsquo;]}\n推播名稱 / notifier: dingtalk\n參數大全 / params:\n{\u0026lsquo;required\u0026rsquo;: [\u0026rsquo;token\u0026rsquo;], \u0026lsquo;optional\u0026rsquo;: [\u0026rsquo;title\u0026rsquo;, \u0026lsquo;content\u0026rsquo;, \u0026lsquo;secret\u0026rsquo;, \u0026lsquo;markdown\u0026rsquo;]}\n推播名稱 / notifier: discord\n參數大全 / params:\n{\u0026lsquo;required\u0026rsquo;: [\u0026lsquo;webhook\u0026rsquo;], \u0026lsquo;optional\u0026rsquo;: [\u0026rsquo;title\u0026rsquo;, \u0026lsquo;content\u0026rsquo;, \u0026lsquo;username\u0026rsquo;, \u0026lsquo;avatar_url\u0026rsquo;, \u0026lsquo;color\u0026rsquo;]}\n推播名稱 / notifier: pushplus\n參數大全 / params:\n{\u0026lsquo;required\u0026rsquo;: [\u0026rsquo;token\u0026rsquo;, \u0026lsquo;content\u0026rsquo;], \u0026lsquo;optional\u0026rsquo;: [\u0026rsquo;title\u0026rsquo;, \u0026rsquo;topic\u0026rsquo;, \u0026lsquo;markdown\u0026rsquo;]}\n推播名稱 / notifier: qmsg\n參數大全 / params:\n{\u0026lsquo;required\u0026rsquo;: [\u0026lsquo;key\u0026rsquo;], \u0026lsquo;optional\u0026rsquo;: [\u0026rsquo;title\u0026rsquo;, \u0026lsquo;content\u0026rsquo;, \u0026lsquo;mode\u0026rsquo;, \u0026lsquo;qq\u0026rsquo;]}\n推播名稱 / notifier: serverchan\n參數大全 / params:\n{\u0026lsquo;required\u0026rsquo;: [\u0026lsquo;sckey\u0026rsquo;, \u0026rsquo;title\u0026rsquo;], \u0026lsquo;optional\u0026rsquo;: [\u0026lsquo;content\u0026rsquo;]}\n推播名稱 / notifier: serverchanturbo\n參數大全 / params:\n{\u0026lsquo;required\u0026rsquo;: [\u0026lsquo;sctkey\u0026rsquo;, \u0026rsquo;title\u0026rsquo;], \u0026lsquo;optional\u0026rsquo;: [\u0026lsquo;content\u0026rsquo;, \u0026lsquo;channel\u0026rsquo;, \u0026lsquo;openid\u0026rsquo;]}\n推播名稱 / notifier: telegram\n參數大全 / params:\n{\u0026lsquo;required\u0026rsquo;: [\u0026rsquo;token\u0026rsquo;, \u0026lsquo;userid\u0026rsquo;], \u0026lsquo;optional\u0026rsquo;: [\u0026rsquo;title\u0026rsquo;, \u0026lsquo;content\u0026rsquo;, \u0026lsquo;api_url\u0026rsquo;]}\n推播名稱 / notifier: wechatworkapp\n參數大全 / params:\n{\u0026lsquo;required\u0026rsquo;: [\u0026lsquo;corpid\u0026rsquo;, \u0026lsquo;corpsecret\u0026rsquo;, \u0026lsquo;agentid\u0026rsquo;], \u0026lsquo;optional\u0026rsquo;: [\u0026rsquo;title\u0026rsquo;, \u0026lsquo;content\u0026rsquo;, \u0026rsquo;touser\u0026rsquo;, \u0026lsquo;markdown\u0026rsquo;]}\n推播名稱 / notifier: wechatworkbot\n參數大全 / params:\n{\u0026lsquo;required\u0026rsquo;: [\u0026lsquo;key\u0026rsquo;], \u0026lsquo;optional\u0026rsquo;: [\u0026rsquo;title\u0026rsquo;, \u0026lsquo;content\u0026rsquo;, \u0026lsquo;markdown\u0026rsquo;]}\n推播例子 1 2 3 4 5 telegram ONEPUSH={\u0026#34;notifier\u0026#34;:\u0026#34;telegram\u0026#34;,\u0026#34;params\u0026#34;:{\u0026#34;markdown\u0026#34;:false,\u0026#34;token\u0026#34;:\u0026#34;xxxx\u0026#34;,\u0026#34;userid\u0026#34;:\u0026#34;xxx\u0026#34;}} discord ONEPUSH={\u0026#34;notifier\u0026#34;:\u0026#34;discord\u0026#34;,\u0026#34;params\u0026#34;:{\u0026#34;markdown\u0026#34;:true,\u0026#34;webhook\u0026#34;:\u0026#34;https://discord.com/api/webhooks/xxxxxx\u0026#34;}} docker 設定檔對應目錄為：/etc/genshin:/app/genshincheckinhelper/config\n","date":"2022-06-09T13:33:42+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/47/","title":"原神自動簽到 (Linux 伺服器 Docker)"},{"content":" 📢 本文由 Gemini-3-flash 翻譯 引言 在學習 Markdown 用法 後，感覺非常好用 (最近的文章都是使用 Markdown 寫的)，又因為程式設計或 GitHub 架站 會與 Markdown 接觸，而我寫程式使用 VS Code (看嘉然)，因此尋找是否可以即時預覽。\n快速鍵 在 Markdown 檔案介面 (.md 檔案)，點擊一下檔案介面 (滑鼠文字游標在檔案內)，然後按下 CTRL+K 後按下 V 即可，注意使用英文輸入法。\n以上是即時預覽，可以按 CTRL+Shift+V 開啟新視窗預覽。\n按鈕 在 Markdown 檔案右上角有個 開啟側邊預覽 按鈕，點擊即可。\n指令面板 按 CTRL+Shift+P 開啟指令面板，然後輸入 markdown 就能看到一些指令。\n參考文章 Visual Studio Code 撰寫並即時預覽 Markdown ","date":"2022-06-09T00:03:34+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/46/","title":"VS Code 即時預覽 Markdown"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 前言 首先我不是嘉心糖，我只是覺得很可愛 (我剛開始甚至都不知道是嘉然)，然後這個 Bug 蠻多，自動啟動不是每次都能觸發，但她太可愛啦\n然後這個擴充套件還可以改背景，但我個人不是太喜歡就沒改\n效果預覽如下 安裝 開啟 VS Code 然後在 擴充套件 搜尋 A-SOUL-live2d 安裝\n擴充套件網址： A-SOUL-live2d - Visual Studio Marketplace 其實可以直接去擴充套件那邊看，有安裝過程，不用看我寫的垃圾文章\n簡易使用 安裝完畢重新啟動 VS Code，然後在資源檢視最下方會有 LIVE2D-A-SOUL，展開 (不能展開就重新啟動 VS Code)\n然後在 補充設定 處 產生 擴充套件依賴檔案，重新啟動 VS Code，點擊 啟動 live2d\n右下角就會出現嘉然囉，可以把滑鼠移上去，拖曳右上角第三個圖示以移動位置，第一個點擊改變大小\n調整完位置，大小後可以在 設定資訊 處開啟 自動啟動，然後點擊 儲存目前設定 就可以開啟 VS Code 就能看見嘉然囉~\n其他 以下複製自擴充套件介紹\n基本操作\n啟動、關閉 live2d： 字面意思，會啟動看板人物，初始預設位置右下角 儲存目前設定： 在調整 live2d 大小縮放和拖曳位置後，可儲存資訊，下次啟動時自動帶入 重設預設位置： 目前位置異常，無法拖曳移動時可重設使用【縮放大小也會重設】 背景圖片 點擊切換： 點擊按鈕為人物右側圖示第二個 儲存背景圖片： 需要目前背景圖片存在才會生效。只能儲存一份，再次點擊會覆蓋舊的 載入背景圖片： 載入儲存的背景圖片 定時切換： 字面意思，可查看 切換按鈕 是否旋轉判斷是否開啟定時功能 背景圖片樣式設定 下載背景圖片 設定資訊\n自動啟動： 字面意思，開啟後。VS Code 啟動，live2d 自動啟動 定位依賴： 人物定位的依賴角 補充設定\n擴充套件依賴檔案： 擴充套件依賴檔案會在初次安裝擴充套件並啟動時自動產生 產生： live2d 無法正常啟動時，可嘗試點擊該按鈕，強制重新產生覆蓋設定資訊 移除： 解除安裝該擴充套件前，請盡可能先執行該操作。可移除擴充套件對 VS Code 檔案的所有修改 人物功能\n目光跟隨滑鼠 【缺點，暫時無法實現整個頁面的跟隨】 點擊互動 A-SOUL 粉絲導航網站入口 切換背景圖片 切換模型 溜冰場 音訊測試 一個魂二創網站入口 模型來源 關於警告 使用時會跳出 Code 損壞警告，原作者指出\n本擴充套件是透過修改 VS Code 的 js 檔案的方式執行 所以會在初次安裝，或者 VS Code 升級的時候，出現以下提示，請選擇 【不再提示】\n音訊支援 目前擴充套件僅一個簡易的語音測試，暫且可以不用考慮該功能\nVS Code 使用的 Electron 版本不包含 ffmpeg ，需替換內建的 ffmpeg 動態連結庫才能正常播放 (每次更新 VS Code 都需重新替換)\nVS Code for Windows 1.31.0 - 1.35.1 不需替換，1.36.0 後無此待遇\nVS Code for macOS 1.43+ 替換後閃退 解決方案 解除安裝 首先將 補充設定 移除，然後在 擴充套件 介面解除安裝擴充套件即可\n","date":"2022-06-01T06:01:00+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/45/","title":"VS Code 右下角嘉然"},{"content":" 📢 本文由 Gemini-3-flash 翻譯 引言 最近基於 GitHub Pages 弄了一個個人頁面 (已經沒了)，記錄一下如何使用 GitHub Pages 建站以及自訂網域。\n本文沒有建站系統等，因為我也就寫了一個 Markdown 檔案。\n建立 GitHub 存放庫 首先需要註冊一個 GitHub 帳號，登入後 建立一個新存放庫 。\n其中 Repository name 為 username.github.io，例如我的 GitHub 使用者名稱為 yexca，則輸入 yexca.github.io。\nGit 環境安裝 Windows 環境直接從 Git 官網直接 下載安裝程式 即可。\n安裝完成後，開啟 Git Bash，在命令列輸入以下程式碼：\n1 2 git config --global user.name \u0026#34;Your Name\u0026#34; git config --global user.email \u0026#34;email@example.com\u0026#34; 其中 Your Name 替換為您的姓名，email@example.com 替換為您的電子郵件。\n例如我的：\n1 2 git config --global user.name \u0026#34;yexca\u0026#34; git config --global user.email \u0026#34;yexca@duck.com\u0026#34; GitHub Desktop 安裝 如果您熟悉 Git 的操作 熟悉 Git 操作怎麼會來看我的文章，這一步可以跳過。\n直接進入 GitHub Desktop 官網 下載安裝即可。\n複製存放庫 開啟 GitHub Desktop 後登入 GitHub 帳號，選擇一個空資料夾將上一步建立的存放庫複製 (Clone) 到本機。\n然後軟體會出現一個存放庫變動介面，右方會有一些快捷操作。\n這裡我使用 VS Code，點擊 Open in Visual Studio Code 在 VS Code 開啟。\n建立網站 這裡直接建立一個 README.md 檔案使用 Markdown 編輯 (這裡順便放一個我寫的 Markdown 筆記)。\n編輯完成並儲存後，在 GitHub Desktop 點擊 Commit to main，然後點擊右方 Push origin 即可。\n至此訪問 username.github.io 即可看到網站內容，如果沒看到請等一段時間。\n自訂網域 GitHub Pages 進入剛剛建立的存放庫頁面，點擊 Settings，左側找到 Pages，在 Custom domain 處輸入自訂網域然後點擊 Save。\n註：在這裡可以進行 Jekyll 建站主題的選擇。\nDNS 在網域的 DNS 解析處新增一個 CNAME 類型解析，將網域指向 username.github.io，其中 username 為您的 GitHub 使用者名稱。\nHTTPS 這裡我用 GitHub 的不知為何沒成功，於是使用 Cloudflare 。\n在 DNS 解析處啟用代理，然後在 SSL/TLS 的 邊緣憑證 處將 一律使用 HTTPS 打開即可。\n其他建站 因無部落格需求，我只是寫一個簡單的檔案，如果是建立部落格之類的可以使用一些建站工具：\nJekyll GitHub 官方支援的建站 VuePress 中文網 Markdown 推薦 Gitbook 適合建立說明文件類網站 LOFFER Gridea 一個靜態部落格寫作客戶端 Hexo 快速、簡潔且高效的部落格框架 Hugo 參考文章 GitHub Pages 快速入門 - GitHub Docs GitHub Pages 部落格：自訂網域，HTTPS，CAA — 浮雲的部落格 GitHub Pages 搭建教程 安裝 Git - 廖雪峰的官方網站 ","date":"2022-05-28T15:30:43+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/44/","title":"GitHub Pages 建站及自訂網域"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 前言 最近因建立 雲端硬碟網站 而了解了一下 Markdown，發現這東西非常好用，於是寫了一份學習筆記。\n可以透過 線上編輯器 邊看邊學，也可以下載一些 編輯器 。\n個人編寫 Markdown 的工具為 Typora 。\n複習可以去看官方的速查表 Markdown 語法速查表 。\n標題 建立標題，只需#+空白+標題文字，總共有六個層級，對應 HTML 的 h1~h6。\n1 2 3 4 5 6 # 這是一級標題 ## 這是二級標題 ### 這是三級標題 #### 這是四級標題 ##### 這是五級標題 ###### 這是六級標題 一般的網頁編寫，第一層標題是網頁標題，第二層開始為內文，用到第四層就差不多了。\n換行 只需在上一行末尾加上兩個以上的空白後 Enter (或換行) 即可，有些編輯器可以直接換行。\n例如以下程式碼：\n1 2 這是第一行 //這裡有兩個空白，後面也有→ 這是第二行 效果如下：\n這是第一行 //這裡有兩個空白，後面也有→\n這是第二行\n斜體 \u0026amp; 粗體 斜體是在文字前後加上一個 *，粗體是在文字前後加上兩個 **。\n例如以下程式碼：\n1 2 3 *這是斜體* **這是粗體** ***這是斜體加粗體*** 效果如下：\n這是斜體\n這是粗體\n這是斜體加粗體\n引用區塊 建立引言區塊只需在段落開頭添加 \u0026gt;+空白+內容。\n例如以下程式碼：\n1 2 3 \u0026gt; 這是一級引言 \u0026gt;\u0026gt; 這是二級引言 \u0026gt;\u0026gt;\u0026gt; 這是三級引言 效果如下：\n這是一級引言\n這是二級引言\n這是三級引言\n清單 可以建立有序清單和無序清單。\n有序清單 在清單項目前添加 數字+.+空白+內容 即可。\n例如以下程式碼：\n1 2 3 1. 第一項 2. 第二項 3. 第三項 效果如下：\n第一項 第二項 第三項 無序清單 使用 +，- 或 *+空白+ 內容 即可，但請不要混用 (為了相容性)。\n子項目可以使用 四個空白 或一個 TAB 然後用父項目格式即可。\n不過為了符合 (markdownlint) 規範，一篇文章中的所有無序清單應盡量使用相同的符號，例如都使用 -。\n例如以下程式碼：\n1 2 3 4 5 6 - 第一項 - 第一項子項目一 - 第一項子項目二 - 第一項子項目二的子項目一 - 第二項 - 第三項 效果如下：\n第一項 第一項子項目一 第一項子項目二 第一項子項目二的子項目一 第二項 第三項 程式碼 單行 將要變成程式碼的內容放在 \u0026ldquo;`\u0026rdquo; 中即可，如果程式碼中有 \u0026ldquo;`\u0026rdquo; ，請使用 \u0026ldquo;``\u0026quot;。\n例如以下程式碼：\n1 2 `將此內容變成程式碼區塊` ``此內容中含有\u0026#39;`\u0026#39;喔~`` 效果如下：\n將此內容變成程式碼區塊\n此內容中含有'`'喔~\n程式碼區塊 可以透過將每一行縮排四個空白或一個 TAB。\n或者上下行 \u0026ldquo;```\u0026rdquo; 包住，若要使用語法高亮，請在上方 \u0026ldquo;```\u0026rdquo; 後寫上語言類型。\n為了符合規範，請盡量使用第二種方式。\n例如以下程式碼：\n1 2 3 4 5 6 7 \\`\\`\\` C include\u0026lt;stdio.h\u0026gt; int main(void) { printf(\u0026#34;Hello World\u0026#34;); } \\`\\`\\` 效果如下：\n1 2 3 4 5 include\u0026lt;stdio.h\u0026gt; int main(void) { printf(\u0026#34;Hello World\u0026#34;); } 分隔線 在單獨一行使用三個及以上的 *，- 或 _ 即可。\n為了規範，請盡量使用三個星號。\n例如以下程式碼：\n1 *** 效果如下：\n連結 簡易連結 直接將連結或電子郵件地址使用 \u0026lt;\u0026gt; 括起來即可。\n例如以下程式碼：\n1 2 \u0026lt;https://yexca.net\u0026gt; \u0026lt;yexca@duck.com\u0026gt; 效果如下：\nhttps://yexca.net yexca@duck.com 自訂文字的連結 [超連結顯示名](超連結地址 \u0026quot;超連結 title\u0026quot;)，其中 \u0026quot;超連結 title\u0026quot; 可以不用填寫。\n例如以下程式碼：\n1 2 [yexca 的部落格](https://blog.yexca.net) [yexca 的部落格](https://blog.yexca.net \u0026#34;其實是yexca和Hiyoung的部落格\u0026#34;) 效果如下：\nyexca 的部落格 yexca 的部落格 參考型連結 例如以下程式碼：\n1 2 3 4 [blog]: https://blog.yexca.net [contact]: \u0026lt;mailto:yexca@duck.com\u0026gt; 這是我的[個人部落格][blog]，有問題可以[聯絡我][contact]。 效果如下：\n這是我的 個人部落格 ，有問題可以 聯絡我 。\n圖片 插入圖片 ![圖片 alt](圖片連結 \u0026quot;圖片 title\u0026quot;)，其中 圖片 alt 為當圖片載入失敗時顯示的內容，圖片 title 為滑鼠移到圖片上顯示的內容。\n請注意：部分 Markdown 編輯器不支援 圖片 title (例如本站這個主題)，為了規範，請至少確保填寫 圖片 alt。\n例如以下程式碼：\n1 ![圖片](https://cdn.statically.io/gh/yexca/picx-images-hosting@master/2023/04-網站背景/blog-background.2p10z489pjc0.webp \u0026#34;這是本站的背景圖片\u0026#34;) 效果如下：\n圖片包含連結 使用連結的語法，將圖片放在 [] 裡面即可。\n例如以下程式碼：\n1 [![圖片](https://cdn.statically.io/gh/yexca/picx-images-hosting@master/2023/04-網站背景/blog-background.2p10z489pjc0.webp)](https://www.pixiv.net/artworks/82542737) 效果如下：\n跳脫字元 如果有不想被 Markdown 格式化的字元，只需要在前方加上 \\ 即可。\n例如以下程式碼：\n1 2 我想打出*但這會變成斜體* 加上跳脫字元\\*後面就不會變成斜體，而且可以顯示 效果如下：\n我想打出但這會變成斜體\n加上跳脫字元*後面就不會變成斜體，而且可以顯示\n內嵌 HTML 直接使用即可，以摺疊標籤為例：\n例如以下程式碼：\n1 2 3 4 5 6 7 \u0026lt;details\u0026gt; \u0026lt;summary\u0026gt; 點我試試看 \u0026lt;/summary\u0026gt; 被發現啦 \u0026lt;/details\u0026gt; 我可以用Markdown**變粗**，也可以同時用HTML\u0026lt;i\u0026gt;變斜\u0026lt;/i\u0026gt; 因為本站主題無法直接解析 H5，所以不提供範例。\n表格 使用三個或多個 - 建立每欄的標題，使用 | 分隔每欄，使用 : 向左、向右或置中對齊 (非必要)。\n例如以下程式碼：\n1 2 3 |標題|內容|備註| |:---|:---:|---:| |靠左對齊|置中|靠右對齊| 效果如下：\n標題 內容 備註 靠左對齊 置中 靠右對齊 請注意：不可以在表格中加入標題、引言、清單、圖片或 HTML 標籤等等。\n刪除線 在要刪除的內容前後加上 ~~。\n例如以下程式碼：\n1 我永遠喜歡 ~~戰爭文學博士~~ Warma 效果如下：\n我永遠喜歡 戰爭文學博士 Warma\n待辦事項清單 使用 -+空白+[ ] 或 [x]+空白+內容。\n例如以下程式碼：\n1 2 - [ ] 這個還沒完成呢 - [x] 這個完成啦 效果如下：\n這個還沒完成呢 這個完成啦 使用 Emoji 表情符號 複製貼上 大部分情況可以直接複製 Emojipedia 上的表情符號直接貼上，請確保網頁編碼為 UTF-8。\n使用表情符號簡碼 這需要 Markdown 應用程式支援，以冒號 : 開頭和結尾。\n可以透過 表情符號簡碼列表 查詢。\n例如以下程式碼：\n1 :blush:,:smiley: 效果如下：\n😊,😃\n註腳 類似於論文參考文獻的註標。\n例如以下程式碼：\n1 2 3 4 5 6 這裡引用了維基百科[^1]，這裡引用了 Github[^2]。 也可以使用英文，但不能使用空白或 TAB[^yexca]。 [^1]: 這裡可以使用文字，然後會顯示在上方相應的位置 [^2]: 或者使用連結 [Github](https://github.com/yexca) [^yexca]: [個人首頁](https://lit.link/yexca) 效果如下，參考的內容在文章最尾端，點擊註標即可查看。\n這裡引用了維基百科1，這裡引用了 Github2。 也可以使用英文，但不能使用空白或 TAB3。\n請注意：部分編輯器不支援。\n參考文章 Markdown 官方教學 Markdown 學習 這裡可以使用文字，然後會顯示在上方相應的位置\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n或者使用連結 Github \u0026#160;\u0026#x21a9;\u0026#xfe0e;\n個人首頁 \u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2022-05-28T00:59:23+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/43/","title":"Markdown 簡述 (學習筆記)"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 引言 本人可以直接連線進入遊戲，但加速器等方式無法進入遊戲，加上每次進入遊戲都要關閉虛擬私人網路較為麻煩，尋找相關資料卻無果，故撰寫此文。（遊戲為 iOS 日服）\n正文 透過查看日誌檔案，確定了進入遊戲時連線的網域名稱。\n將以下網域名稱加入 DIRECT 即可：\n1 sekai.colorfulpalette.org 後記 本想詳細說明的，卻發現遊戲出了國際服和台服，如果要詳細寫估計要花費很長時間並進行校對，懶～\n","date":"2022-05-19T15:01:25+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/42/","title":"プロセカ的 IP 規則"},{"content":" 📢 本文由 Gemini-3-flash 翻譯 前言 2022 年 03 月 22 日，OBS 在 Steam 上架了，雖然方便更新，但每次使用都要開啟 Steam 實在有點麻煩。\n正文 在 Steam 收藏庫介面右鍵點擊 OBS Studio，依序選擇「管理 \u0026gt; 瀏覽本機檔案」。\n在檔案總管中進入路徑 bin/64bit 或 bin/32bit，找到 obs64 或 obs32。\n直接點擊這個檔案就可以啟動 OBS，因此可以將其固定到「開始」畫面或建立捷徑。\n按右鍵選擇「建立捷徑」，將捷徑放到桌面即可。\n","date":"2022-04-11T22:19:48+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/37/","title":"免啟動 Steam 開啟 OBS"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 一、查詢時間戳 開啟網頁 https://member.bilibili.com/x2/creative/h5/calendar/event?ts=0 按下 CTRL+F，輸入 jointime，找到 jointime 後面的數字就是時間戳\n將時間戳複製\n二、轉換時間戳 開啟網站 時間戳 (Unix timestamp) 轉換工具 – 線上工具 在對應位置輸入時間戳，點擊轉換即可\n參考資料 UP主教學如何查看自己的B站註冊時間，精確到秒！bilibili ","date":"2022-04-09T13:47:52+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/36/","title":"查詢B站註冊時間(精確到秒)"},{"content":" 📢 本文由 Gemini-3-flash 翻譯 前言 今日我在撰寫文章時，發現 PicX 圖床無法使用並提示 Bad credentials，於是便尋找解決方法。\n結論 其實就是 GitHub 的 Token 到期了，然後在電子信箱裡會收到一封郵件，標題為 [GitHub] Your personal access token has expired\n郵件有三行，第二行 If this token is still needed 後面有個連結，點擊打開並重新建立即可。\n注意設定 Expiration 即 Token 期限。\n重新建立後需要在 PicX 將圖床設定重置一下。\n具體參考： 使用PicX自建免費圖床 – yexca’Blog ","date":"2022-03-22T16:30:12+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/35/","title":"使用 PicX 圖床上傳圖片提示 \"Bad credentials\""},{"content":" 📢 本文由 Gemini-3-flash 翻譯 引言 這篇文章是我自行蒐集的一些免費圖床，部分圖床曾經使用過。當然，如果您想要使用圖床，我推薦您閱讀 使用 PicX 自建免費圖床 – yexca’Blog 一、路過圖床 官網連結： 路過圖床 – 免費圖片上傳, 專業圖片外鏈, 免費公共圖床 高速穩定，單圖最大 10MB\n二、ImgURL 官網連結： ImgURL 免費圖床 訪客每日限 10 次上傳，單圖最大 5MB\n三、SM.MS 官網連結： Image Upload – SM.MS – Simple Free Image Hosting 老牌圖床，現在訪客禁止上傳，普通使用者單圖最大 5MB， 5GB 儲存空間\n（另外該圖床的圖片直連連結網域是 loli.net）\n四、KinhPicture 官網連結： KinhPicture – 聚合圖床 島主的聚合圖床，支援阿里、百度、AWS S3 等 15 個介面，單圖限制 2~32MB\n五、極兔圖床 官網連結： 極兔圖床 – 免費圖床, 匿名圖床, 免費 CDN 圖床, 圖床 API, 專業的圖片代管商 最大可上傳 10MB 的圖片\n六、Gimhoy 圖床 官網連結： Gimhoy 圖床 - 無限制永久免費圖 七、bayimg 官網連結： bayimg – free uncensored image hosting ","date":"2022-03-20T16:54:36+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/33/","title":"圖床網站總結"},{"content":" 📢 本文由 gemini-2.5-flash-lite 翻譯 引言 近期購入了 Beat Saber (雖然是透過阿根廷區)，於是便想著新增自訂歌曲。透過 Steam 的評論區得知 WGzeyu 大佬做了相關教學，但由於我的目的比較單純，而教學內容又相當完整，因此特地撰寫這篇文章來總結。\n一、準備工作 註：2022.03.25：今日修改相關內容時發現 1.20.0 版本已有 Mod，請直接參閱第二部分。同時，恢復資料的部分已更新。\n1）降級 由於目前最新版本 1.20.0 並沒有相關 Mod，因此需要先進行降級。待 Mod 更新後，可以再升級回最新版本。\n\u0026lt;1\u0026gt; 下載 1.19.0 或更早的版本 可至 WGzeyu 大佬提供的網盤 下載。選擇想下載的版本後進行下載。\n檔案直連： 1.19.0 Steam 版 \u0026lt;2\u0026gt; 替換 1.20.0 版本 解壓縮下載的檔案，然後透過 Steam 開啟遊戲目錄。返回上一層後，將「Beat Saber」資料夾重新命名為「Beat Saber 1.20.0」，接著將剛剛下載的檔案重新命名為「Beat Saber」並移動到此資料夾。\n\u0026lt;3\u0026gt; 如何恢復資料 \u0026lt;1\u0026gt; 使用 Steam 開啟遊戲目錄，刪除 UserData 資料夾內的 Beat Saber IPA。 \u0026lt;2\u0026gt; 複製以下資料夾 (依需求複製)： * UserData (Mod 設定) * CustomSabers (光劍模型) * CustomPlatforms (場景模型) * CustomAvatars (人物模型) * CustomNotes (方塊模型) \u0026lt;3\u0026gt; 然後進入「Beat Saber 1.20.0」資料夾，貼上複製的這些資料夾。在彈出的提示中，選擇【替換】。 \u0026lt;4\u0026gt; 開啟「Beat Saber」資料夾，進入 Beat Saber_Data 資料夾，剪下 CustomLevels 資料夾。 \u0026lt;5\u0026gt; 進入「Beat Saber 1.20.0」資料夾，進入 Beat Saber_Data 資料夾，貼上剪下的那個資料夾。在彈出的提示中，選擇【替換】。\n最後將「Beat Saber」資料夾刪除，將「Beat Saber 1.20.0」資料夾重新命名為「Beat Saber」。\n2）相關軟體 \u0026lt;1\u0026gt; Mod 管理器 \u0026ldquo;ModAssistant\u0026rdquo; 此軟體有英文版和中文版，請依需求下載。網盤下載： 網盤連結 檔案直連： ModAssistant 中文增強版 Mod 安裝器，支援 PC 不支援 Quest \u0026lt;2\u0026gt; BeatSaber 歌曲路徑管理器 可透過上述網盤連結下載，檔案直連： BeatSaber 歌曲路徑管理器 (5.3 版本，可能因更新而失效)\n\u0026lt;3\u0026gt; Resilio Sync 可透過上述網盤連結下載，官網連結： Resilio Sync 檔案直連： Resilio Sync 64 位元 3）資料夾 上述軟體中，除了 Resilio Sync 外，皆為單一檔案應用程式，可放置於常用軟體資料夾。\n另外，需在您想存放歌曲的位置建立一個資料夾，例如「E:\\games\\Beat Saber Song\\」，位置可自行決定。\n二、步驟 1）開啟 Beat Saber 一次 2）開啟 \u0026ldquo;ModAssistant\u0026rdquo; 點擊同意後即可進入左方的 \u0026ldquo;Mod\u0026rdquo; 介面。左下方可選擇遊戲版本。選擇好後即可安裝 Mod，或直接開始安裝。\n若速度過慢，可在「選項」中將軟體來源改為國內。\n3）開啟 Beat Saber 一次 4）開啟 Resilio Sync 此部分步驟請參考： Beat Saber 曲包資源同步 – Resilio Sync (wgzeyu.com) 反正最後都是需要開啟這個網頁的，既然已有步驟，我就不在此處撰寫了（懶惰）。\n下載資料夾目錄即選擇上一步建立的資料夾。\n5）開啟 BeatSaber 歌曲路徑管理器 初次開啟時，請依照提示進行選擇。然後點擊「新增目錄」，選擇放置歌曲的目錄 (即上一步下載的資料夾目錄)。\n接著點擊「儲存列表」即可。\n三、後續 當然，如果您有其他需求，請參考 WGzeyu 的 教學 。\n","date":"2022-03-18T17:46:00+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/31/","title":"Beat Saber 新增自訂歌曲清單"},{"content":" 📢 此頁面有使用機器翻譯喲 引言 在玩了 Beat Saber 和 VRchat 等 VR 遊戲後突然想到 i 社有部分遊戲支援 VR，本人最喜歡玩戀活，於是試著進行遊玩，但卻遇到相關問題，本文僅作記錄。另 VR 版則無劇情，本人使用原版所以遇到問題較少。\n前提/條件 以下圖片和部分文字來自 Oculus 官網 Support ，部分英文自己進行了翻譯，鑑於本人英文不是太好，請以官方原內容為準，以下列出主要內容，詳情請參考 Oculus Link 的相容性要求 資料線要求 Oculus Link 需使用能夠支援資料和電源連接的優質 USB 資料線。為獲得最佳舒適體驗，您還應確保資料線長度至少為 3 米 (10 英尺)\n電腦要求 配件 推薦配置 CPU Intel i5-4590 / AMD Ryzen 5 1500X 或更高版本 顯卡 請參閱下面的 GPU 表 記憶體 8 GB+ 記憶體 作業系統 Win10 USB 介面 1 個 USB 介面 Oculus Link 支援的 GPU NVIDIA GPU 支援 暫時不支援 NVIDIA Titan Z X NVIDIA Titan X X NVIDIA GeForce GTX 970 X NVIDIA GeForce GTX 1060 Desktop, 3GB X NVIDIA GeForce GTX 1060 Desktop, 6GB X NVIDIA GeForce GTX 1060M X NVIDIA GeForce GTX 1070(all) X NVIDIA GeForce GTX 1080(all) X NVIDIA GeForce GTX 1650 X NVIDIA GeForce GTX 1650 Super X NVIDIA GeForce GTX 1660 X NVIDIA GeForce GTX 1660 TI X NVIDIA GeForce RTX 20-series (all) X NVIDIA GeForce RTX 30-series (all) X AMD GPU 支援 暫時不支援 AMD 200 Series X AMD 300 Series X AMD 400 Series X AMD 500 Series X AMD 5000 Series X AMD 6000 Series X AMD Vega Series X 一、進入遊戲 進入遊戲 VR 版本直接打開 KoikatuVR.exe 即可，由於使用 steam 串流，故可提前進入 steamVR\n進入遊戲前請確保戴上耳機，房門鎖緊等以預防突發情況，如不能做到請注意行為 XD\n問題一：無法進入 steamVR 一、確保安裝相關軟體 1）steamVR 安裝 首先打開 steam，然後按 Win+R，輸入 steam://run/250820，按下回車便會自動安裝 steamVR\n2）Oculus 安裝 訪問 官網下載 ，注意：安裝完成後會下載相關檔案，完成後會要求登錄帳號，請確保網絡環境正常 (台灣應該沒事 XD)\n如要求提供支付方式，可尋找 跳過 按鈕\n如果登入一直在加載，無法成功登入 可通過修改 Hosts 解決，推薦使用火絨打開 hosts 檔案進行修改\n如果不使用火絨，打開 C:\\Windows\\System32\\drivers\\etc，找到 hosts 這個檔案，用記事本打開\n在檔案末尾添加如下內容\n1 2 3 4 157.240.11.49 graph.oculus.com 157.240.11.49 www2.oculus.com 157.240.8.49 scontent.oculuscdn.com 157.240.8.49 securecdn.oculus.com 然後保存即可，如果不是使用火絨，請保存到一個地方然後移回原目錄並將副檔名 .txt 去除\n二、確保 Link 線正常 事實上，連接 Quest2 的時候 Oculus 軟體會有一步選擇是否檢測 Link 線，可通過此進行檢測，如果當時未進行檢測，可選擇 設備 - Quest2 和 Touch-USB 檢測 進行檢測\n三、確保設置正常 1）Quest2 設備設置 使用 USB 連接 PC 和 Quest2 時 Quest 會彈出 允許訪問資料，請選擇拒絕，如果選擇了 允許，請拔下再重新連接選擇 拒絕\n2）Oculus 軟體設置 其實直接打開 steamVR 會有彈窗 是否允許未知來源 此時選擇允許即可\n當然，可以在軟體的 設置 - 通用 - 未知來源 進行打開\n四、還是無法打開？換個姿勢試試 如果以上都沒問題但還是無法打開 steamVR，則可使用下述方式\n1）Quest2 設備 當連接 PC 後一般會有彈窗 啟用 Oculus Link，此時選擇 啟用 即可\n如果上述未選擇 啟用 或沒有彈窗，可在下方任務欄的最左方即 快速設置 中找到 Oculus Link，點擊即可打開\n2）啟動 steamVR 不會有人不知道 steamVR 怎麼啟動吧 (doge)\n如果先連接 VR 設備再打開 steam，那麼 steam 的介面右上方應該有 “VR” 標識，點擊即可打開\n如果無此標識，可在任務欄 (或者說右下托盤) 裡找到 steam 圖標，鼠標右擊，倒數第二個即為 steamVR\n當然，可以在 steam 庫中將 工具 也顯示，這樣可以在 steam 庫中看見 steamVR\n二、開始遊戲 我不知道這裡應該寫什麼，分這個標題是因為問題二與遊戲有關，那就寫其他的吧 (doge)\n點擊 KoikatuVR.exe 會自動打開 steamVR，所以可以在 Quest2 設備打開 Oculus Link 後直接打開 KoikatuVR 即可\n注意：遊戲會在桌面有一個視窗，可透過 Win+D 最小化所有視窗，但當摘下頭顯再次戴上時好像會再次出現，請注意\n問題二：無法開始遊戲/不知如何開始 如果您閱讀其他文章或觀看相關影片可能會得到僅支援部分設備 (支持啥我忘了)，如果和我一樣去測試了 VR kanojo 能否正常運行，也可能會以為是靠注視，其實不然 (我就是想多寫點)\n只需要按下 “搖桿” 即可出現選擇線，按下前 “扳機鍵” 即可選擇 (更多操作請看 三、操作說明)\n問題三：開始遊戲後一直白屏，電腦上 \u0026ldquo;LOADING\u0026rdquo; 一直在一半 可進 コイカツ！ DL 版 ，點擊下方 體験版・無料ダウンロード 中的 コイカツ VR パッチ 進行下載\n檔案直鏈： コイカツ VR パッチ 下載解壓後會有一個可執行檔，運行後會出現 コイカツ！VR_0531 更新版 資料夾，將裡面 setup 資料夾內容移到遊戲根目錄並覆蓋即可\n注意：此方法來源作者指出姿勢會變成只有三個，由於我並未遊玩，所以我沒有姿勢 (本來想著 VR 玩劇情的，但 VR 不能玩劇情)，以下為作者給出解決 (部分內容有修改)\n姿勢是在故事模式裡用過什麼姿勢，在 vr 裡才能用，所以在故事模式裡戰鬥的時候把所有姿勢都點一遍，點完就換就行，然後到晚上存檔，在退出換 vr，然後姿勢就齊了\n原文地址： 兄弟們有沒有玩了 vr 的 三、操作說明 此部分為自行遊玩得出，僅作部分說明，其他操作請自行參考其他文章\n1）開始遊戲 進入遊戲後會有俩選項，分別為\nスタート，即 start，即開始\nエンド，即 End，即結束\n按下 \u0026ldquo;搖桿\u0026rdquo;，會出現一條線，可進行選擇 (前 \u0026ldquo;扳機鍵\u0026rdquo;)\n2）進入本番 左右手手腕部分會出現文字，可通過左右控制器上方按鍵即 Y 和 B 進行切換\n一共有倆個，進入戰鬥後有三個 (多了一個 移動)，分別為\n日文 英文 中文 作用 アクション Action 行動 前 \u0026ldquo;扳機鍵\u0026rdquo; 可進行各種操作 側 \u0026ldquo;扳機鍵\u0026rdquo; 可打開菜單 按下 \u0026ldquo;搖桿\u0026rdquo; 可進行選擇 システム system 系統 前 \u0026ldquo;扳機鍵\u0026rdquo; 可重置位置 移動 Move 移動 前 \u0026ldquo;扳機鍵\u0026rdquo; 按住可改變視角 3）注意 僅可在 \u0026ldquo;アクション\u0026rdquo; 時按下 \u0026ldquo;搖桿\u0026rdquo; 可以進行選擇\n參考文章 Oculus Link 兄弟們有沒有玩了 vr 的 Oculus 用戶端在 Win10 上面無法安裝或登陸的解決方法_國韻的部落格 - CSDN 部落格_oculus 無法連接伺服器 中國移動的日文 (別問我為什麼會參考這個，問就是不會日文)\n","date":"2022-03-18T16:54:23+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/30/","title":"使用 Quest2 VR 玩戀愛活動 (戀活 / koikatu) 遇到的問題及解決"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 本文章由 Hiyoung 編寫\n第一章：了解 Web 及網路基礎 1.1 簡介 為了理解 HTTP，應事先了解一下 TCP/IP 協定家族。我們通常使用的網路（包括網際網路）是在 TCP/IP 協定家族的基礎上運作，而 HTTP 屬於其內部的一個子集。在網際網路上的設備若要相互通訊，雙方就必須遵從相同的規則，我們將這些規則稱為協定。（TCP/IP 是對網際網路相關的各類協定家族的一個總稱，包括但不限於：PPPoE、HTTP、TCP、IP、UDP、IEEE 802.3…）\n在 TCP/IP 協定家族中，按照層次從上到下分為：應用層、傳輸層、網路層、資料鏈結層。\n網際網路協定套件-維基百科 在使用 TCP/IP 協定家族進行通訊時，用戶端會從應用層往下走，伺服端會從資料鏈結層往上走。用戶端在層與層之間傳輸資料時，每經過一層時會為其加上該層的段首資訊。相反地，伺服端會一層一層地消去首部。這種將資料資訊包裝起來的方法叫做封裝。\n1.2 IP、TCP 與 DNS 1.2.1 IP 協定 IP 協定位於網路層，TCP/IP 中的 IP 指的是 IP 協定，與 IP 位址並非同一回事。IP 協定的作用是將各種資料封包傳送給對方。各種 IP 位址可以和 MAC 位址進行配對。IP 位址可變換，但 MAC 位址基本上不會更改。IP 位址指明了節點被分配到的位址，MAC 位址是指網路卡所屬的固定位址。\n1.2.2 MAC 位址 IP 之間的通訊依賴 MAC 位址。通常會使用 ARP 協定 來根據通訊方的 IP 位址反查出對應的 MAC 位址。\n1.2.3 TCP 協定 按層次分，TCP 位於傳輸層，提供位元組流服務（Byte Stream Service）——為了方便傳輸，將大塊資料分割成以報文段（segment）為單位的資料封包進行管理。簡而言之，TCP 協定為了更容易傳送大數據才將資料分割，而且 TCP 協定能夠確認資料最終是否送達對方。\n為了確認資料是否送達對方，TCP 採用了三次握手策略。握手過程中使用了 TCP 的旗標（flag）——SYN（synchronize）和 ACK（acknowledgement）。\n1.2.4 負責網域名稱解析的 DNS 服務 電腦既可以被賦予 IP 位址，也可以被賦予主機名和網域名稱。DNS 協定提供透過網域名稱查找 IP 位址，或逆向從 IP 位址反查網域名稱的服務。\n1.3 URL 與 URI 1.3.1 區別與關係 與 URI（統一資源識別碼）相比，我們更熟悉 URL（Uniform Resource Locator，統一資源定位符）。URL 正是使用網頁瀏覽器等存取網頁時需要輸入的網頁位址。例如 https://www.bilibili.com/ 就是 URL。URI 用字串識別某個網際網路資源，而 URL 表示資源的地點（網際網路上所處的位置）。可見 URL 是 URI 的子集。URI 可被視為定位符（URL）、名稱（URN）或兩者兼具。 統一資源名稱 （URN）如同一個人的名稱，而 統一資源定位符 （URL）代表一個人的住址。換言之，URN 定義某事物的身份，而 URL 提供查找該事物的方法。\n1.3.2 URI 格式 表示指定的 URI，要使用涵蓋所有必要資訊的絕對 URI、絕對 URL 以及相對 URL。\n相對 URL，是指從瀏覽器中基本 URI 處指定的 URL，形如 /image/logo.gif。\n絕對 URI 的格式：\n登入資訊（認證）：指定使用者名稱和密碼作為從伺服端獲取資源時必要的登入資訊（身份認證）。此項是可選項。\n伺服器位址：使用絕對 URI 必須指定待存取的伺服器位址。位址可以是類似 hackr.jp 這種 DNS 可解析的名稱，或是 192.168.1.1 這類 IPv4 位址名稱，還可以是 [0:0:0:0:0:0:0:1] 這樣用方括號括起來的 IPv6 位址名稱。\n伺服器連接埠號：指定伺服器連接的網路連接埠號。此項也是可選項，若使用者省略則自動使用預設連接埠號。\n帶層次的文件路徑：指定伺服器上的檔案路徑來定位特指的資源。這與 UNIX 系統的檔案目錄結構相似。\n查詢字串：針對已指定的檔案路徑內的資源，可以使用查詢字串傳入任意參數。此項為可選項。\n片段識別符：使用片段識別符通常可標記出已獲取資源中的子資源（文件內的某個位置）。但在 RFC 中並沒有明確規定其使用方法。該項也為可選項。\n第二章：簡單的 HTTP 協定 2.1 HTTP 簡介 HTTP 是一種不保存狀態的協定，所謂不保存狀態是指 HTTP 協定本身並不會對每次的請求和回應之間的通訊狀態進行保存。所以引入了 Cookie 技術來保存通訊狀態。（註：這本 HTTP 書籍出版較早，現在使用保存狀態的技術是由 cookie、session 和 token 共同實現的）\n2.2 常用的 HTTP 方法 GET：獲取資源\nGET 方法是用來請求 URL 指定的資源。指定資源經伺服端解析後返回回應內容。\nPOST：傳輸實體主體\nPOST 用於向伺服器傳輸資料，當獲取的資料過大時也會使用 POST 方法。\nGET 與 POST 的區別：\n先下結論，GET 與 POST 方法沒有實質區別，只是報文格式不同。\n請求參數長度限制：GET 請求長度最多 1024kb，POST 對請求資料沒有限制。\n請求參數：GET 請求參數是透過 URL 傳遞的，多個參數以 \u0026amp; 連接，POST 請求放在 request body 中。 請求快取：GET 請求會被快取，而 POST 請求不會，除非手動設定。 安全性：POST 比 GET 安全，GET 請求在瀏覽器回溯時是無害的，而 POST 會再次請求。 歷史紀錄：GET 請求參數會被完整保留在歷史紀錄裡，而 POST 中的參數不會被保留。 編碼方式：GET 請求只能進行 URL 編碼，而 POST 支援多種編碼方式。 對參數的資料類型：GET 只接受 ASCII 字元，而 POST 沒有限制。\n此外， HTTP 還有 PUT、HEAD、DELETE 等方法 在此不細細展開。\n2.3 HTTP 的持久連線（三次握手四次揮手） 持久連線的特點是，只要任意一端沒有明確提出斷開連線，則保持 TCP 連線狀態。\n三次握手：建立 TCP 連線 四次揮手：斷開 TCP 連線\n在持久連線中使用管線化技術，可以不用等待回應即可直接傳送下一個請求。\n2.4 使用 Cookie 的狀態管理 Cookie 會根據從伺服端傳送的回應報文內一個叫做 Set-Cookie 的首部欄位資訊，通知用戶端保存 Cookie。當下次用戶端再往該伺服器傳送請求時，用戶端會自動在請求報文中加入 Cookie 值後傳送出去。\nCookie 資訊是在伺服端產生並傳送給用戶端進行保存的。\n第三章 HTTP 報文資訊 3.1 HTTP 的請求與回應報文結構 用於 HTTP 協定交互的資訊被稱為 HTTP 報文。請求端（用戶端）的 HTTP 報文叫做請求報文，回應端（伺服端）的叫做回應報文。由 8 位元組流組成，透過 HTTP 通訊傳輸。\n請求行：包含用於請求的方法、請求 URI 和 HTTP 版本。\n狀態行：包含表明回應結果的狀態碼、原因短語和 HTTP 版本。\n首部欄位：包含表示請求與回應的各種條件和屬性的各類首部。一般有 4 種首部，分別是：通用首部、請求首部、回應首部和實體首部。\n其他：可能包含 HTTP 的 RFC 裡未定義的首部（Cookie 等）。\n3.2 編碼傳輸與分塊傳輸 HTTP 在傳輸資料過程中，透過編碼提升傳輸速率。\n3.2.1 報文主體與實體主體的差異 實體：作為請求或回應的有效負載資料（補充項）被傳輸，其內容由實體首部和實體主體組成。\nHTTP 報文的主體用於傳輸請求或回應的實體主體。**通常，報文主體等於實體主體。**只有當傳輸中進行編碼操作時，實體主體的內容發生變化，才導致它與報文主體產生差異。\n3.2.2 分割傳送實體主體 在 HTTP 通訊過程中傳輸大容量資料時，透過將資料分割成多塊，能讓瀏覽器逐步顯示頁面。將實體主體分塊的功能稱為分塊傳輸編碼。分塊傳輸編碼會將實體主體分成多個塊。每一塊都會用十六進制來標記塊的大小，而實體主體的最後一塊會使用「0(CR+LF)」來標記。\n所謂的塊也就是常稱的封包。\n第四章 返回結果的 HTTP 狀態碼 4.1 狀態碼的類別 藉助狀態碼，使用者可以知道伺服器是否正常處理了請求，狀態碼種類繁多但常用的大概只有 14 種。\n4.2 2XX 成功 4.2.1 200 OK 表示從用戶端傳來的請求在伺服端被正常處理了。在回應報文內，隨狀態碼一起返回的資訊會因方法的不同而發生改變。\n4.2.2 204 No Content 該狀態碼代表伺服器接收的請求已成功處理，但在返回的回應報文中不含實體的主體部分。\n4.3 3XX 重導向 重點介紹一下 301 重導向與 302 重導向，還有其他狀態碼可自行查看。\n4.3.1 301 Moved Permanently 301 重導向是永久性的重導向。該狀態碼表示請求的資源已被分配了新的 URI，以後應使用資源現在所指的 URI。例如像下方給出的請求 URI，當指定資源路徑的最後忘記添加斜線「/」時，就會產生 301 狀態碼。\nhttp://excample.com/sample\n4.3.2 302 Found 302 重導向是臨時性的重導向。該狀態碼表示請求的資源已被分配了新的 URI，希望使用者（本次）能使用新的 URI 存取。與 301 Moved Permanently 狀態碼相似，但 302 狀態碼代表的資源不是被永久移動，只是臨時性質的。\n4.4 4XX 用戶端錯誤 有 400 Bad Request、401 Unauthorized、403 Forbidden、404 Not Found。重點介紹一下 404 Not Found。\n4.4.1 404 Not Found 該狀態碼表明伺服器上無法找到請求的資源。除此之外，也可以在伺服端拒絕請求且不想說明理由時使用。\n4.5 5XX 伺服端錯誤 5XX 的回應結果表明伺服器本身發生錯誤。\n第五章 Web 伺服器 5.1 通訊資料轉發程式：代理、閘道器、隧道 5.1.1 代理 代理伺服器的基本行為就是接收用戶端傳送的請求後轉發給其他伺服器。代理不改變請求 URI，會直接傳送給前方持有資源的目標伺服器。值得一提的是，代理是指對用戶端的代理（也稱為前向代理），而反向代理是指對伺服器的代理。\n使用代理伺服器可以利用快取技術減少網路頻寬的流量，有時也會為了資訊安全而使用代理。\n快取代理 代理轉發回應時，快取代理（Caching Proxy）會預先將資源的副本（快取）保存在代理伺服器上。當代理再次接收到對相同資源的請求時，就可以不從來源伺服器那裡獲取資源，而是將之前快取的資源作為回應返回。\n反向代理 反向代理的優點有很多：\n對用戶端隱藏伺服器（叢集）的 IP 位址\n安全：作為 應用層防火牆 ，為網站提供對基於 Web 的攻擊行為（例如 DoS / DDoS ）的防護，更容易排除 惡意軟體 等\n為後端伺服器（叢集）統一提供加密和 SSL 加速（如 SSL 終端代理）\n負載平衡 ，若伺服器叢集中有負載較高者，反向代理透過 URL 重寫 ，根據連線請求從負載較低者獲取與所需相同的資源或備援\n對於靜態內容及短時間內有大量存取請求的動態內容提供 快取服務 對一些內容進行 壓縮 ，以節約 頻寬 或為網路頻寬不佳的網路提供服務\n5.1.2 閘道器 閘道器的工作機制與代理十分相似。而閘道器能使通訊線路上的伺服器提供非 HTTP 協定服務。\n","date":"2022-03-16T23:56:48+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/29/","title":"《圖解HTTP》讀後總結與淺談"},{"content":" 📢 本文由 Gemini-3-flash 翻譯 注意 此文章複製自 《unity學習筆記》——將MMD模型匯入unity ，僅用於個人記錄使用，部分內容有修改\n方法 1：利用 Unity 外掛程式直接讀取 FBX 模型 第一步：安裝外掛程式 MMD4Mecanim (Beta) 外掛程式網址： Stereoarts Homepage （應外掛程式作者要求，請勿上傳至 GitHub）\n檔案直連： MMD4Mecanim_Beta_20200105.zip 第二步：開啟 Unity，連按兩次下載好的外掛程式中的 MMD4Mecanim.unitypackage 檔案 第三步：將 MMD 模型（全部）檔案匯入 Unity 選擇自動產生的 .MMD4Mecanim，點擊同意（此時可加入動畫、音樂等）\n此方法的好處是可以最大限度地還原 MMD 原本的渲染效果，而且不需要自行重新設定著色器 (Shader)，並且不需藉助 Unity 以外的其他軟體。\n方法 2：利用 Blender 外掛程式將 MMD 模型轉為 FBX 匯入 第一步：安裝 Blender 外掛程式 GitHub: cats-blender-plugin 此外掛程式可以讓 Blender 辨識 MMD 的 PMX 檔案，然後可以根據需要使用 Blender 匯出成 FBX、STL 等格式（FBX 為 Unity 可辨識的格式）。\n第二步：將匯出的 FBX 模型與原模型的所有材質一起匯入 Unity 在匯入 Unity 時，效果或渲染風格可能與原本的不一致，需要自行設定著色器 (Shader)。\n自行設定著色器的好處是可以在 Unity 中統一不同模型的美術風格，或者如果是為了方便起見，可以在 Unity Asset Store 下載相應風格的模型，將下載模型的著色器套用至匯入的 MMD 模型即可（模型動作也可以套用，顏色可以自行修改）。\n","date":"2022-03-10T13:15:26+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/28/","title":"將 MMD 模型匯入 Unity"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 前言 在日常撰寫文章時，經常會需要插入圖片（雖然我最近的文章都沒有圖片），但是如果使用自己的伺服器，會比較耗費流量，而且載入速度也不是特別快。這時候就需要使用圖床了，然而多數免費圖床會不時地出現圖片遺失、速度緩慢等問題，因此我開始探索如何自建圖床。\n然而，如果特意花錢租用雲端伺服器來託管圖片，又太貴不划算；使用付費圖床則多數有流量或空間限制。於是我無意間發現了一個專案，這是一款基於 GitHub API \u0026amp; jsDelivr 開發，並具備 CDN 加速功能的圖床管理工具。\nPicX 圖床簡介 官方網站： PicX 圖床 專案位址： XPoet/picx: 基於 GitHub API \u0026amp; jsDelivr 開發的具有 CDN 加速功能的圖床管理工具 官方文件： 快速開始-PicX 圖床 特色：只需選擇一個 GitHub 儲存庫作為圖床，然後在 PicX 官網 完成 Token 綁定和相應設定即可使用，免下載與安裝，就這麼簡單。\n快速開始 首先，建立一個 GitHub 儲存庫 點擊連結 Create a New Repository Repository name 輸入一個名稱（例如 image-hosting）\n儲存庫屬性必須選擇 Public\n接著，建立一個具有 repo 權限的 GitHub Token 點擊連結 New personal access token 輸入 Note（即名稱，例如 picx-image-hosting）\n注意：「Expiration」為此 Token 的有效期限，請務必選擇。 如果您過早讀到這篇文章而未進行設定，請參考： 使用 PicX 圖床上傳圖片提示「Bad credentials」– yexca’Blog Select scopes 勾選 repo，然後建立 Token\n注意：新產生的 Token 只會顯示一次，請妥善保管，如有遺失，重新產生即可。\n最後，到官網輸入 Token 設定 開啟 PicX官網 ，進入圖床設定，填入 Token\n然後選擇儲存庫和目錄方式\n建立目錄：需手動輸入一個新目錄。（使用 / 可建立多層目錄，例如：A01/A02 表示建立了二級目錄，最多支援建立三層目錄。） 根目錄：圖片將直接儲存在儲存庫根目錄下。 自動目錄：自動產生日期格式 YYYYMMDD 的目錄。例如：20200909。 好的，圖床已經設定完成，開始使用吧！\n其他設定 設定預設開啟圖片壓縮，可在「我的設定」中進行修改\n","date":"2022-02-17T23:02:13+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/27/","title":"使用 PicX 自建免費圖床"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 前言 由於學校的教務系統查看課表不夠便利，而且第三方課表存在一定的資安疑慮並且廣告很多，於是我便想著把課表匯入日曆，我選擇匯入 Outlook 日曆，這樣可以實現在 iOS、Windows 和 Android 多個裝置上同步。\n準備工作 一台電腦 一支 Android 手機 電腦安裝 Chrome 瀏覽器： 官方網站連結 手機安裝 WakeUp 課表： 官方網站連結 第一步，匯出課表 一、使用 Chrome 開啟教務系統網址，進入課表介面\n二、匯出 HTML 檔案\n首先複製以下程式碼\n1 javascript:void(function(u,s){s=document.body.appendChild(document.createElement(\u0026#39;script\u0026#39;));s.src=u+\u0026#39;?ts=\u0026#39;+Date.now();s.charset=\u0026#39;UTF-8\u0026#39;}(\u0026#39;https://the-red-hat-was-uncovered.gitee.io/supwisdom-course-table/dist.js\u0026#39;)) 接著是加入我的最愛，Windows 下的快速鍵是 Ctrl + D\n按下快速鍵後，可以直接點選「更多」按鈕，來編輯剛才加入的我的最愛，這時候可以修改名稱和 URL（網址），名稱取個好記的（例如「WakeUp 匯出課表」），URL（網址）那邊貼上剛剛複製的程式碼！然後再儲存。\n最後點擊剛剛加入的我的最愛網址（如上所述），此時瀏覽器會自動下載「教務.html」檔案（也就是下一步要用的檔案）\n第二步，匯入 WakeUp 課表 一、將上一步匯出的檔案傳送到手機上\n二、匯入課表至 WakeUp 課表\n手機開啟 WakeUp 課表，匯入新課表（右上方第二個），點選「從 HTML 檔案匯入」\n「選擇學校/教務類型」選擇「樹維教務（簡易匯入）」 ，不用選擇學校，然後選擇檔案後點選右下角\n匯入完成後請注意選擇正確的開學日期或是當前週數\n第三步，匯入日曆 在 WakeUp 課表點選右上方第三個匯出，選擇「匯出為 ICS（日曆用）格式」\n如果是 Android 手機可找到檔案目錄，點擊檔案，用日曆開啟即可\n如果是 iOS 手機可透過寄送電子郵件（帶附件）的方式傳送到手機登入的電子郵件信箱，然後點擊附件匯入\n參考文章 樹維教務簡易匯入 ","date":"2022-02-16T17:53:16+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/26/","title":"將課表匯入日曆（樹維教務）"},{"content":" 📢 本文由 gemini-2.5-flash-lite 翻譯 國內工具 使用站長工具的連接埠掃描，輸入IP位址或網域名稱和連接埠後點擊開始掃描\n如果顯示關閉，則連接埠未開啟或無法連線\n工具連結： 連接埠掃描 – 站長工具 國外工具 使用 you get signal 的 Port Forwarding Tester 進行掃描\n進入後會自動填寫您的IP和 80 連接埠，可修改為想要掃描的IP和連接埠後點擊 Check\n如果出現紅旗並顯示 port ** is closed on ***.***.***.*** 則連接埠未開啟或無法連線\n工具連結： Open Port Check Tool – Test Port Forwarding on Your Router ","date":"2022-02-13T19:46:38+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/25/","title":"查看伺服器連接埠是否開啟"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 引言 由於 QQ 軟體過於臃腫且權限過大，並且經常性卡住無法載入，因此便尋找其他方法。首先是透過 Telegram 收發 QQ 訊息，但設定較為複雜且並不穩定，於是棄用並改用 VS Code。\n插件簡介 名稱: QQ\nID: takayama.vscode-qq\n說明: lite qq for chat in working\n版本: 1.4.2\n發布者: takayama\nVS Marketplace 連結: VS Code QQ Extension GitHub 專案位址： vscode-qq 註：本程式不在本地儲存任何訊息紀錄和圖片。暫不支援臨時對話。\n安裝 首先安裝 VS Code，造訪 官網 點擊 Download 即可下載安裝。\n然後造訪上述 VS Code QQ Extension 連結點擊 Install 即可自動開啟 VS Code 安裝。\n或者打開 VS Code 在左側「延伸模組」(或按 CTRL+SHIFT+X)，然後搜尋 QQ (注意大寫)，點擊第一個安裝。\n功能 按快速鍵「CTRL+SHIFT+P」打開命令面板。\n輸入「QQ Explorer: Login」（或只輸入「login」會顯示對應選項）後按 Enter。\n然後根據提示輸入帳號密碼即可登入成功，此時會顯示相關功能。\n輸入「QQ Explorer: 搜尋好友」即可搜尋好友。\n輸入「QQ Explorer: 搜尋群組」即可搜尋群組。\n設定 在登入成功後控制面板便會有設定，進入設定為 JSON 檔案編輯，內容如下：\n1 2 3 4 5 6 7 8 9 { \u0026#34;account\u0026#34;: ***********, // QQ 號碼 \u0026#34;password\u0026#34;: \u0026#34;********************************\u0026#34;, // QQ 密碼 \u0026#34;platform\u0026#34;: 5, // 登入平台，可更改「1: 手機, 3: 手錶(功能不完整), 4: PC, 5: pad(預設)」 \u0026#34;show_me_add_group_request\u0026#34;: false, \u0026#34;theme\u0026#34;: \u0026#34;default\u0026#34;, // UI 主題，可更改「default(預設) 和 console(控制台風格)」 \u0026#34;theme_css\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;theme_js\u0026#34;: \u0026#34;\u0026#34; } 可自訂主題，詳情參考： 修改/自定義 UI 主題 ","date":"2022-02-11T21:47:56+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/24/","title":"使用 VS Code 收發 QQ 訊息"},{"content":" 📢 本文由 gemini-2.5-flash-lite 翻譯 引言 Potplayer 是非常優秀的影片播放軟體，但最近的版本右下角開始有彈出廣告，非常令人困擾。本文將介紹兩種方法來解決右下角彈窗問題。\n使用無彈窗的舊版本（推薦） 最後一個沒有廣告彈窗的版本是 1.7.18958。\n舊版本的所有 PotPlayer 都可以從以下網址下載：\nPotPlayer 舊版本下載 1.7.18958 版本直接下載連結： 64 位元 | 32 位元 安裝完成後，開啟「設定」（按 F5），在「基本設定」-\u0026gt;「自動更新」中選擇「不使用自動更新」。\n使用綠色版 註：此版本的個人使用體驗感覺不是太好，例如無法靠近吸附視窗、以原始檔案比例開啟等。\n藍奏雲連結 by zdBryan\n一般執行 = 安裝版（包含開始選單捷徑及程式解除安裝捷徑）\n右鍵解壓縮 = 綠色版（本身不提供便攜式軟體，需手動執行綠化處理）\n版本特色\n1、移除驗證，移除右下角空白廣告彈窗！解除安裝時可選擇備份設定。 2、禁止背景網路請求：境外廣告、傳送日誌、檢查升級。 3、整合額外的音訊解碼器及影片解碼器元件。 4、預設配置：一般設定 + 預設啟用自訂解碼器 H.265/HEVC 及硬體加速。 5、刪除 TV 直播列表、登入程式、日誌管理、訊息通知、多語言等不必要的檔案。 參考文章 關於 Potplayer 右下角彈窗解決方案 PotPlayer v1.7.21589 綠色版 ","date":"2022-02-06T21:37:45+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/23/","title":"移除 Potplayer 右下角彈窗"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 前言 (閒聊) 閒暇之餘，於是便想鑽研一下路由器當作網路閘道器（但事後才發現這台路由器的儲存空間太小，無法安裝太多外掛程式，簡直是白忙了一整個下午）\n2022.02.17 更新：無意間發現了一個內建網路閘道器的 FIR300M 韌體，但由於支援的方法過於老舊，若要刷入，請注意辨別。\n原文連結： 更新編譯方法 - FIR300M/FIR302M 的 Openwrt 韌體 免拆機刷 百度網盤： 提取碼: vouv OpenWRT 簡介 OpenWRT 是基於 Linux 的路由器作業系統，擁有許多強大的外掛程式和較佳的擴充性，並且可以透過 SSH 進行連線\n官方網站： OpenWrt Wiki - Welcome to the OpenWrt Project OpenWRT 通用教學： 從零開始學習 OpenWrt: 刷機 + 使用 + 編譯教學 準備工作 一、軟體 HFS 二、適用於 FIR300M 的 OpenWRT 韌體: 百度網盤 三、電腦開啟 Telnet 服務，請參考 win10 如何開啟 telnet 服務 （Win11 也適用，控制台可以在設定中搜尋進入） 簡要步驟 一、登入路由器管理介面 (192.168.1.1) 並登入 二、造訪 http://192.168.1.1/goform/Diagnosis?pingAddr=192.168.1.100|echo\u0026quot;\u0026quot;|telnetd 三、開啟命令提示字元 (cmd)，輸入: telnet 192.168.1.1 四、將韌體傳輸到路由器，等待完成 五、此時進入路由器管理介面即為 OpenWRT (初始無密碼，直接登入即可) 六、點擊 System-Language and Style 可將語系改為中文 詳細步驟 (第四步) 開啟 HFS，將「準備工作」第二步中的韌體重新命名為「1.bin」並拖曳到視窗中\n在命令提示字元 (cmd) 輸入指令「telnet 192.168.1.1」並成功連線後，依序輸入以下指令\n1 2 3 cd /tmp wget http://192.168.1.100/1.bin // 請將「192.168.1.100」替換為您的機器 IP mtd_write -r write 1.bin Kernel // (注意，這裡的 K 是大寫) 執行成功後路由器會自動重新啟動，所以會顯示「連線中斷」\n外掛程式安裝 在 OpenWRT 管理介面點擊「系統-軟體包」即可安裝相應外掛程式\n建議到 Github 尋找相應的外掛程式，當然也可以自行編寫\n因為安裝外掛程式需要網路位址，可以直接複製 Github 相應專案 Release 中的 ipk 檔案連結\n自己編寫要如何安裝？您都已經會自己編寫了，還會不懂這個嗎？ (doge)\n注意事項 外掛程式安裝需要與路由器相容，部分外掛程式可能需要環境依賴，也就是需要先安裝其他外掛程式。\n具體可以透過錯誤訊息進行判斷\n參考文章 FIR300M 免拆機刷 Openwrt 教學 路由器刷韌體——斐訊路由器 FIR300M 刷 OpenWrt 韌體教學 HFS – 超好用的本機檔案分享工具，快速從電腦傳輸檔案到手機等裝置 許迎果 第 215 期 OpenWrt 外掛程式的安裝與移除 ","date":"2022-02-06T20:44:10+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/22/","title":"FIR300M 路由器刷韌體 OpenWRT"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 引言 (廢話) 有時候會有在 Word 文件中插入程式碼的需求，但是直接把程式碼複製過去會不怎麼美觀，而且沒有高亮顯示看著也相當難受。\n工具一 CodeInWord 在 Word 中優雅展現的程式碼/程式碼高亮/Word 中插入程式碼/程式碼格式化 工具二 Syntax Highlight Code In Microsoft Word 使用說明 沒什麼要說明的，把程式碼複製過去，選擇相對應的語言，點擊生成再複製到 Word 中即可。\n附錄 如果以上網站無法使用，可在搜尋引擎搜尋「syntax highlight code in word」。\n參考文章 如何優雅地在 Microsoft Word 中插入程式碼 ","date":"2022-01-20T14:28:52+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/21/","title":"在 Microsoft Word 中插入程式碼（高亮）"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 前言 在玩其他區域的一些小遊戲時，常常會因為亂碼而無法遊玩，或者發生錯誤而不能執行，這時候就需要轉區以匹配正確的文字。\n雖然可以透過修改 Windows 的地區設定來執行，但很多時候這個方法稍微繁瑣，並且需要重新開機。玩完後如果不改回來，則可能導致正常的軟體無法使用，此時便需要相關的轉區軟體。\n軟體取得 軟體官網： Locale Emulator GitHub 專案位址 (releases)： Locale Emulator – GitHub 設定說明 下載並解壓縮後，點擊「LEInstaller」依照需求為目前使用者或所有使用者安裝。\n安裝完成後，點擊「LEGUI」設定轉區環境 (如果玩日本遊戲則不需要，預設會自動設定)。\n使用說明 找到要開啟的遊戲，右鍵點擊執行檔 (.exe)。\n接著選擇 Locale Emulator，然後選擇對應環境執行 (如果是 Win11，請點擊「顯示更多選項」)。\n廢話 僅作為個人記錄，以供自用，官網上就有使用說明。\n","date":"2022-01-14T15:53:40+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/20/","title":"轉區軟體 Locale Emulator"},{"content":" 該文章使用 Google 翻譯處理。\n順序棧 (數組實作) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #include \u0026lt;stdio.h\u0026gt; // 元素 elem 進棧，a 為數組，top 值為目前堆疊的棧頂位置 int push(int* a,int top,int elem) { a[++top]=elem; return top; } // 資料元素出棧 int pop(int * a,int top) { if (top==-1) { printf(\u0026#34;空堆疊\u0026#34;); return -1; } printf(\u0026#34;彈棧元素：%d\\n\u0026#34;,a[top]); top--; return top; } int main(void) { int a[100]; int top=-1; top = push(a, top, 1); top = push(a, top, 2); top = push(a, top, 3); top = push(a, top, 4); top = pop(a, top); top = pop(a, top); top = pop(a, top); top = pop(a, top); top = pop(a, top); return 0; } 輸出結果：\n彈棧元素：4 彈棧元素：3\n彈棧元素：2 彈棧元素：1 空堆疊\n鏈堆疊 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; typedef struct lineStack{ int data; struct lineStack * next; }lineStack; // stack 為目前的鏈棧，a 表示入棧元素 lineStack* push(lineStack * stack,int a) { // 建立儲存新元素的節點 lineStack * line=(lineStack*)malloc(sizeof(lineStack)); line-\u0026gt;data=a; // 新節點與頭節點建立邏輯關係 line-\u0026gt;next=stack; // 更新頭指標的指向 stack=line; return stack; } // 棧頂元素出鏈棧的實作函數 lineStack * pop(lineStack * stack) { if (stack) { // 宣告一個新指標指向棧頂節點 lineStack * p=stack; // 更新頭指針 stack=stack-\u0026gt;next; printf(\u0026#34;出棧元素：%d \u0026#34;,p-\u0026gt;data); if (stack) { printf(\u0026#34;新棧頂元素：%d\\n\u0026#34;,stack-\u0026gt;data); } else { printf(\u0026#34;堆疊已空\\n\u0026#34;); } free(p); } else { printf(\u0026#34;棧內沒有元素\u0026#34;); return stack; } return stack; } int main(void) { lineStack * stack=NULL; stack=push(stack, 1); stack=push(stack, 2); stack=push(stack, 3); stack=push(stack, 4); stack=pop(stack); stack=pop(stack); stack=pop(stack); stack=pop(stack); stack=pop(stack); return 0; } 輸出結果：\n出棧元素：4 新棧頂元素：3 出棧元素：3 新棧頂元素：2\n出棧元素：2 新棧頂元素：1\n出棧元素：1 堆疊已空 棧內沒有元素\n","date":"2021-11-21T22:19:04+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/17/","title":"資料結構 堆疊程式碼"},{"content":" 該文章使用 Google 翻譯處理。\n程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; // malloc()、exit() #define Size 5 // 對 Size 進行巨集定義，表示順序表申請空間的大小 typedef struct Table { int * head; // 宣告了一個名為head的長度不確定的數組，也叫“動態數組” int length; // 記錄當前順序表的長度 int size; // 記錄順序表分配的儲存容量 }table; // 初始化函數 table initTable() { table t; t.head = (int*)malloc(Size * sizeof(int)); // 建構一個空的順序表，動態申請儲存空間 if (!t.head) // 若申請失敗，作出提示並直接退出程序 { printf(\u0026#34;初始化失敗\u0026#34;); exit(0); } t.length = 0; // 空表的長度初始化為 0 t.size = Size; // 空表的初始儲存空間為 Size return t; } // 插入函數，其中，elem 為插入的元素，add 為插入到順序表的位置 table addTable(table t, int elem, int add) { int i; // 判斷插入本身是否有問題（如果插入元素位置比整張表的長度 +1 還大 (如果相等，是尾隨的情況)，或者插入的位置本身不存在，程序作為提示並自動退出) if (add \u0026gt; t.length + 1 || add \u0026lt; 1) { printf(\u0026#34;插入位置有問題\u0026#34;); return t; } // 做插入操作時，首先需要看順序表是否有多餘的儲存空間提供給插入的元素，如果沒有，則需要申請 if (t.length == t.size) { t.head = (int *)realloc(t.head, (t.size + 1) * sizeof(int)); if (!t.head) { printf(\u0026#34;儲存分配失敗\u0026#34;); return t; } t.size += 1; } // 插入操作，需要將從插入位置開始的後續元素，逐個後移 for (i = t.length - 1; i \u0026gt;= add - 1; i--) { t.head[i + 1] = t.head[i]; } // 後移完成後，直接將所需插入元素，新增至順序表的相應位置 t.head[add - 1] = elem; // 由於添加了元素，所以長度 +1 t.length++; return t; } // 刪除函數 table delTable(table t, int add) { int i; if (add \u0026gt; t.length || add \u0026lt; 1) { printf(\u0026#34;被刪除元素的位置有誤\u0026#34;); exit(0); } for (i = add; i \u0026lt; t.length; i++) { t.head[i - 1] = t.head[i]; } t.length--; return t; } // 尋找函數，其中，elem 表示要尋找的資料元素的值 int selectTable(table t, int elem) { int i; for (i = 0; i \u0026lt; t.length; i++) { if (t.head[i] == elem) { return i + 1; } } return -1; } // 更改函數，其中，elem 為要更改的元素，newElem 為新的資料元素 table amendTable(table t, int elem, int newElem) { int add = selectTable(t, elem); t.head[add - 1] = newElem; return t; } // 輸出順序表中元素的函數 void displayTable(table t) { int i; for (i = 0; i \u0026lt; t.length; i++) { printf(\u0026#34;%d \u0026#34;, t.head[i]); } printf(\u0026#34;\\n\u0026#34;); } int main() { int i, add; table t1 = initTable(); // 在順序表中新增元素 for (i = 1; i \u0026lt;= Size; i++) { t1.head[i - 1] = i; t1.length++; } printf(\u0026#34;原順序表：\\n\u0026#34;); displayTable(t1); printf(\u0026#34;刪除元素 1:\\n\u0026#34;); t1 = delTable(t1, 1); displayTable(t1); printf(\u0026#34;在第 2 的位置插入元素 5:\\n\u0026#34;); t1 = addTable(t1, 5, 2); displayTable(t1); printf(\u0026#34;尋找元素 3 的位置:\\n\u0026#34;); add = selectTable(t1, 3); printf(\u0026#34;%d\\n\u0026#34;, add); printf(\u0026#34;將元素 3 改為 6:\\n\u0026#34;); t1 = amendTable(t1, 3, 6); displayTable(t1); return 0; } 結果 程式運行結果為：\n原順序表： 1 2 3 4 5\n刪除元素 1:\n2 3 4 5\n在第 2 的位置插入元素 5:\n2 5 3 4 5\n尋找元素 3 的位置:\n3\n將元素 3 改為 6:\n2 5 6 4 5\n","date":"2021-11-20T23:01:47+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/16/","title":"資料結構 順序表程式碼"},{"content":" 該文章使用 Google 翻譯處理。\n簡單鍊錶 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include \u0026lt;stdio.h\u0026gt; struct student { long num; float score; struct student *next; }; void main() { struct student a, b, c, *head, *p; a.num = 99101; a.score = 89.5; b.num = 99103; b.score = 90; c.num = 99107; c.score = 85; // 對結點的 num 和 score 成員賦值 head = \u0026amp;a; // 將結點 a 的起始位址賦給頭指標 head a.next = \u0026amp;b; // 將結點 b 的起始位址賦給 a 結點的 next 成員 b.next = \u0026amp;c; c.next = NULL; // c 結點的 next 成員不存放其他結點位址 p = head; // 使 p 指標指向 a 結點 do { printf(\u0026#34;%ld %5.1f\\n\u0026#34;, p-\u0026gt;num, p-\u0026gt;score); // 輸出 p 指向的結點的數據 p = p-\u0026gt;next; // 使 p 指向下一個結點 }while(p != NULL); // 輸出完 c 結點後 p 的值為 NULL system(\u0026#34;pause\u0026#34;); } 記憶體分配函數 malloc 函數 1 void *malloc(unsigned int size); 作用是在記憶體的動態儲存區中分配一個長度為 size 的連接空間。有些函數的值（即傳回值）是一個指向分配空間起始位址的指標（基底型別為 void）。如果些函數未能成功地執行（例如記憶體空間不足）則傳回空指標 NULL。\ncalloc 函數 1 void *calloc(unsigned n, unsigned size); 其作用是在記憶體的動態區儲存中分配 n 個長度為 size 的連續空間。函數傳回一個指向分配空間起始位址的指針，如果分配不成功，則傳回 NULL。 用 calloc 函數可以為一維數組開啟動態儲存空間， n 為數組元素個數，每個元素長度為 size。\nfree 函數 1 void free(void *p); 其作用是釋放由 p 指向的記憶體區，使這部分記憶體區能被其它變數使用， p 是最後一次呼叫 calloc 或 malloc 函數時傳回的值。 free 函數無回傳值​​。請注意：以前的C版本提供的 malloc 和 calloc 函數得到的是指向字元型資料的指標。 ANSI C 提供的 malloc 和 calloc 函數規定為 void * 類型。\n動態鍊錶的實現 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #define NULL 0 #define LEN sizeof(struct student) struct student { long num; float score; struct student *next; }; struct student *create() { struct student *p1, *p2, *head; int num; float score; int n = 0; head = NULL; p1 = p2 = (struct student *)malloc(LEN); printf(\u0026#34;please input num and score.\\n\u0026#34;); scanf(\u0026#34;%d,%f\u0026#34;, \u0026amp;p1-\u0026gt;num, \u0026amp;p1-\u0026gt;score); while(p1-\u0026gt;num != 0) { n ++; if(n == 1) head = p1; else p2-\u0026gt;next = p1; p2 = p1; p1 = (struct student *)malloc(sizeof(struct student)); printf(\u0026#34;please input num and score.\\n\u0026#34;); scanf(\u0026#34;%d,%f\u0026#34;, \u0026amp;p1-\u0026gt;num, \u0026amp;p1-\u0026gt;score); } p2-\u0026gt;next = NULL; return head; } void printlist(struct student *head) { struct student *p; p = head; if(head != NULL) { do { printf(\u0026#34;num=%d score=%f\\n\u0026#34;, p-\u0026gt;num, p-\u0026gt;score); p = p-\u0026gt;next; }while(p != NULL); } } void main() { struct student *head; head = create(); printlist(head); system(\u0026#34;pause\u0026#34;); } // 列印鍊錶 void printlist(struct student *head) { struct student *p; p = head; if(head != NULL) { do { printf(\u0026#34;num=%d score=%5.2f\\n\u0026#34;, p-\u0026gt;num, p-\u0026gt;score); p = p-\u0026gt;next; } while (p != NULL); } /* while(p -\u0026gt; next != NULL) { printf(\u0026#34;num=%d score=%f\\n\u0026#34;, p-\u0026gt;num, p-\u0026gt;score); p = p-\u0026gt;next; }*/ } // 刪除節點 struct student *delNode(struct student *head, int num) { printf(\u0026#34;delNode.\\n\u0026#34;); struct student *p1, *p2; if(head == NULL) { printf(\u0026#34;The List is NULL.\\n\u0026#34;); } else { p1 = head; while(p1-\u0026gt;next != NULL \u0026amp;\u0026amp; p1-\u0026gt;num != num) { p2 = p1; p1 = p1-\u0026gt;next; } if(p1-\u0026gt;num == num) { if(p1 == head) head = p1-\u0026gt;next; else p2-\u0026gt;next = p1-\u0026gt;next; } else printf(\u0026#34;Can not find list num.\\n\u0026#34;); } return head; } // 更新節點 struct student *update(struct student *head, int index, int num, float score) { printf(\u0026#34;update.\\n\u0026#34;); struct student *p; if(head == NULL) { printf(\u0026#34;The List is NULL.\\n\u0026#34;); } else { p = head; while(p-\u0026gt;next != NULL \u0026amp;\u0026amp; p-\u0026gt;num != index) { p = p-\u0026gt;next; } if(p-\u0026gt;num == index) { p-\u0026gt;num = num; p-\u0026gt;score = score; } else printf(\u0026#34;Can not find list index.\\n\u0026#34;); } return head; } // 增加節點 struct student *add(struct student *head, int index, int num, float score) { printf(\u0026#34;add.\\n\u0026#34;); struct student *p1, *p2, *p3; if(head == NULL) { printf(\u0026#34;The List is NULL.\\n\u0026#34;); } else { p1 = p2 = head; while(p1-\u0026gt;next != NULL \u0026amp;\u0026amp; p1-\u0026gt;num != index) { p1 = p1-\u0026gt;next; p2 = p1; } if(p1-\u0026gt;num == index) { p3 = (struct student *)malloc(LEN); p3-\u0026gt;num = num; p3-\u0026gt;score = score; if(p2-\u0026gt;next == NULL) { p2-\u0026gt;next = p3; p3-\u0026gt;next = NULL; } else { p3-\u0026gt;next = p2-\u0026gt;next; p2-\u0026gt;next = p3; } } else printf(\u0026#34;Can not find list index.\\n\u0026#34;); } return head; } ","date":"2021-11-17T12:00:49+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/15/","title":"資料結構 鍊錶程式碼"},{"content":" 該文章使用 Google 翻譯處理。\n該文章由 Hiyoung 編寫，翻譯自 yexca\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 //數組堆疊的實現 #include\u0026lt;stdio.h\u0026gt; #define MaxSize 50 typedef struct Stack_Array{ int data[MaxSize]; int top; }Sqstack,*pSqstack; void Initstack(); //初始化 int Isempty(); //判斷棧空 int Push(); //入堆疊 int Pop(); //出堆疊 int Gettop(); //get 堆疊頂元素 int main(void) //測試 { int val; Sqstack s1; pSqstack ps1=\u0026amp;s1; Initstack(\u0026amp;s1); //初始化 if(Isempty(\u0026amp;s1)) //判斷棧空 printf(\u0026#34;棧為空！\\n\u0026#34;); else printf(\u0026#34;棧不為空！\\n\u0026#34;); printf(\u0026#34;輸入壓棧元素的值\u0026#34;); //壓棧 1 scanf(\u0026#34;%d\u0026#34;,\u0026amp;val); Push (ps1,\u0026amp;val); printf(\u0026#34;輸入壓棧元素的值\u0026#34;); //壓棧 2 scanf(\u0026#34;%d\u0026#34;,\u0026amp;val); Push (ps1,\u0026amp;val); if(Isempty(ps1)) //判斷棧空 printf(\u0026#34;棧為空！\\n\u0026#34;); else printf(\u0026#34;棧不為空！\\n\u0026#34;); if(Gettop(ps1,\u0026amp;val)) //get 堆疊頂元素 printf(\u0026#34;棧頂值為%d\\n\u0026#34;,val); else printf(\u0026#34;棧頂元素查找失敗！\\n\u0026#34;); if(Pop(ps1,\u0026amp;val)) //出棧 printf(\u0026#34;出棧成功，出棧元素為%d\\n\u0026#34;,val); else printf(\u0026#34;出棧失敗！\\n\u0026#34;); return 0; } //初始化 void Initstack (pSqstack ps1) { ps1-\u0026gt;top=-1; return; } //判斷棧空 int Isempty(pSqstack ps1) { if(ps1-\u0026gt;top==-1) return 1; else return 0; } //若棧不滿，則進行壓棧 int Push(pSqstack ps1,int *val)//*val:接受一個地址(int *(\u0026amp;val)) { if(ps1-\u0026gt;top==MaxSize) return 0; else { ps1-\u0026gt;top++; ps1-\u0026gt;data[ps1-\u0026gt;top]=*val;//這裡傳遞的是值，這裡的*val是*(\u0026amp;val),\u0026amp;val是由主調函數輸入 //也可写作ps1-\u0026gt;data[++ps1-\u0026gt;top]=*val; 一定是++ps1-\u0026gt;top return 1; } } //若棧不空，則進行出棧，用val返回棧頂元素 int\tPop(pSqstack ps1,int *val) { if(Isempty(ps1)) return 0; else { *val=ps1-\u0026gt;data[ps1-\u0026gt;top--]; return 1; } } //get棧頂元素，用val返回棧頂元素 int Gettop(pSqstack ps1,int *val) { if(Isempty(ps1)) return 0; else { *val=ps1-\u0026gt;data[ps1-\u0026gt;top]; return 1; } } 圖解簡化\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 //棧的鍊式存儲實現 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #define Stack_Init_Size 10 // 初始化堆疊的最大長度 #define StackIncrement 10 // 若堆疊最大空間不夠時，需要增加的長度 typedef int ElemType; typedef int Status; typedef struct { ElemType *base; // 堆疊底部指針 ElemType *top; // 堆疊頂指針 int stack_size; // 堆疊的最大長度 } SqStack; // 初始化堆疊 Status InitStack(SqStack *S) { // 分配初始空間 S-\u0026gt;base = (ElemType *) malloc(Stack_Init_Size * sizeof(ElemType)); if (!S-\u0026gt;base) { exit(0); } S-\u0026gt;top = S-\u0026gt;base; /// 棧頂與棧底相同 S-\u0026gt;stack_size = Stack_Init_Size; // 堆疊的最大長度等於初始長度 return 1; } // 判斷棧是否為空，只需要判斷棧頂指標與棧底指標是否相同即可 Status EmptyStack(SqStack *S) { return S-\u0026gt;base == S-\u0026gt;top; } // 取得棧的實際長度，棧頂減去棧底指標即為棧的長度 Status LengthStack(SqStack *S) { if (S-\u0026gt;top == S-\u0026gt;base) { return 0; } return (Status) (S-\u0026gt;top - S-\u0026gt;base); } // 取得棧頂的元素，參數e用來存放棧頂的元素 Status GetTopStack(SqStack *S, ElemType *e) { if (S-\u0026gt;top == S-\u0026gt;base) { return 0; } *e = *(S-\u0026gt;top - 1); return 1; } // 進棧，參數e是要進棧的元素 Status PushStack(SqStack *S, ElemType e) { // 若棧的最大長度不會夠用時，重新開闢，增大長度 if (S-\u0026gt;top - S-\u0026gt;base \u0026gt;= S-\u0026gt;stack_size) { S-\u0026gt;base = (ElemType *)realloc(S-\u0026gt;base, (S-\u0026gt;stack_size + StackIncrement) * sizeof(ElemType)); if (!S-\u0026gt;base) { return 0; } // 棧頂指標為棧底指標加上堆疊之前的最大長度 S-\u0026gt;top = S-\u0026gt;base + S-\u0026gt;stack_size; // 堆疊目前的最大長度等於堆疊之前的最大長度與增加的長度總和 S-\u0026gt;stack_size += StackIncrement; } *S-\u0026gt;top++ = e; // 先賦值，後棧頂指標上移 return 1; } // 出棧，參數e用來存放出棧的元素 Status PopStack(SqStack *S, ElemType *e) { if (S-\u0026gt;base == S-\u0026gt;top) { return 0; } *e = *--S-\u0026gt;top; // 棧頂指標先下移，後賦值 return 1; } // 銷毀棧，釋放棧空間，棧頂棧底指標置為NULL，長度置為0 Status DestroyStack(SqStack *S) { free(S-\u0026gt;base); S-\u0026gt;base = S-\u0026gt;top = NULL; S-\u0026gt;stack_size = 0; return 1; } // 遍歷棧，依序列印每個元素 Status StackTraverse(SqStack *S) { ElemType *p; if (S-\u0026gt;top == S-\u0026gt;base) { printf(\u0026#34;Stack is NULL.\\n\u0026#34;); return 0; } p = S-\u0026gt;top; // 由棧頂依序向下遍歷 while (p \u0026gt; S-\u0026gt;base) { p--; printf(\u0026#34;%d \u0026#34;, *p); } printf(\u0026#34;\\n\u0026#34;); return 1; } int main() { SqStack q, *S; S = \u0026amp;q; int i, n, e; printf(\u0026#34;Creat a NULL Stack :\\n\u0026#34;); InitStack(S); printf(\u0026#34;input the length of the Stack :\\n\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (i = 1; i \u0026lt;= n; i++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;e); PushStack(S, e); } printf(\u0026#34;Is the stack NULL?\\n\u0026#34;); if (EmptyStack(S)) { printf(\u0026#34;Yes!\\n\u0026#34;); } else { printf(\u0026#34;No!\\n\u0026#34;); } printf(\u0026#34;The length of stack is %d.\\n\u0026#34;, LengthStack(S)); printf(\u0026#34;The stack is :\\n\u0026#34;); StackTraverse(S); e = GetTopStack(S, \u0026amp;e); printf(\u0026#34;The top data is %d.\\n\u0026#34;, e); printf(\u0026#34;input the data to the stack :\\n\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;e); PushStack(S, e); printf(\u0026#34;The new stack is :\\n\u0026#34;); StackTraverse(S); printf(\u0026#34;Delete the top data : \u0026#34;); e = PopStack(S, \u0026amp;e); printf(\u0026#34;%d\\n\u0026#34;, e); printf(\u0026#34;The new stack is :\\n\u0026#34;); StackTraverse(S); printf(\u0026#34;Destroy the stack :\\n\u0026#34;); DestroyStack(S); StackTraverse(S); return 0; } ","date":"2021-11-11T23:03:27+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/14/","title":"C 資料結構程式碼"},{"content":" 該文章由 ctxbb 編寫，因為是圖片，沒翻譯\n","date":"2021-11-11T18:01:33+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/13/","title":"揚州杏雨後"},{"content":" 該文章使用 Google 翻譯處理。\n雖然米忽悠的米遊社提供了原神樹脂的查看，但是使用電腦時每次查看還要打開手機然後打開米遊社著實有億點不方便\n原作者文章： 自己做了一個樹脂記錄軟件 原文軟件鏈接： 提取碼：1w5b 下載完成後打開，會提示輸入 uid 和 cookie，下面是如何抓取米遊社的 cookie\n首先打開 米遊社 並登錄\n然後按 F12 打開開發者工具，這時刷新網頁\n然後點擊“網絡-ys/”，找到請求標頭，然後在 cookie 右擊複製\n注意：需要的 cookie 字段為 account_id=xxx; cookie_token=xxx，請自行修改\n**2022-6-6 修改 ( hiyoung )**\n由於米哈遊修改了 bbs 可以獲取的 Cookie，導致一次獲取的 Cookie 缺失，所以需要增加步驟\n按下鍵盤上的 F12 或右鍵檢查,開啟開發者工具,點選 Console\n輸入\n1 var cookie=document.cookie;var ask=confirm(\u0026#39;Cookie:\u0026#39;+cookie+\u0026#39;\\n\\nDo you want to copy the cookie to the clipboard?\u0026#39;);if(ask==true){copy(cookie);msg=cookie}else{msg=\u0026#39;Cancel\u0026#39;} 回車執行，並在確認無誤後點擊確定。此時 Cookie 已經復製到你的粘貼板上了\n注意：請使用 Chrome，Edge 獲取也是不完整的 ( yexca )\n","date":"2021-11-10T15:21:30+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/12/","title":"原神樹脂查看與推送"},{"content":" 該文章使用 Google 翻譯處理。\n首先我們找到要下載的視頻 (廢話)，複製圖中框選部分的鏈接\n然後打開 視頻下載解析網站 ，輸入複製的鏈接然後點擊解析視頻圖片 (如需驗證根據網站提示進行即可)\n然後點擊下載視頻即可\n// 這篇好水\n","date":"2021-11-10T11:29:51+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/11/","title":"微博影片下載"},{"content":" 該文章使用 Google 翻譯處理。\n多數情況下，我們瀏覽網頁一般使用瀏覽器或系統自帶的返回，但有些系統的交互邏輯及其不好用，這時在網頁添加一個返回上一頁按鈕可以極大改善瀏覽體驗\n首先，在 WordPress 的後台點擊“外觀-自定義”來到可視化編輯頁面\n在左方找到“額外CSS”選項（一般在最後）\n然後在裡面輸入下方代碼\n1 2 3 4 5 6 7 8 .float-button { position: fixed; height: 90px; width: 40px; bottom: 90px; right: 50px; /* 可以自行修改相關描述 */ } 輸入完成後儲存，然後編輯主題相關介面\n如果您不能訪問服務器文件，可以在 WordPress 後台的“外觀-主題編輯器”中找到要添加的界面修改\n如果您可以存取伺服器文件，可以開啟路徑 網站根目錄/wp-content/themes/\u0026lt;您的主題名稱\u0026gt;/ 然後開啟相應頁面修改\n只需在相關頁面文件插入下面代碼並保存即可\n1 2 3 4 \u0026lt;div class=\u0026#34;float-button\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; name=\u0026#34;Submit\u0026#34; value=\u0026#34;返回\u0026#34; onclick=\u0026#34;javascript:history.back(-1);\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- 可以自行修改相關描述 --\u0026gt; 參考文章 網頁上的「返回上一頁」的幾種實作程式碼 div 套路之懸浮的 button ","date":"2021-11-10T11:06:27+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/10/","title":"WordPress 新增返回上一頁按鈕"},{"content":" 該文章使用 Google 翻譯處理。\n該文章由 Hiyoung 編寫，翻譯自 yexca\n準備條件：win11 專業版及以上，將系統地區調至美國\n在設置-\u0026gt;應用 -\u0026gt; 可選功能 -\u0026gt; 更多Windows功能中勾選虛擬機平台，然後重啟系統即可\n然後下載安裝包，鏈接: https://pan.baidu.com/s/1215GlKeDCHcbE0I2SgtWLg 提取碼: frkx\n下載完成後我們可以看到下面兩個文件：倒數第二個是安卓子系統安裝包，倒數第一個是WSA工具箱用於安裝 apk 文件\n最下面兩份文件\n現在我們以管理員身份打開 Windows power shell\n執行指令：add-appxpackage 空格 + 安卓子系統的文件路徑 (切記指令與路徑之間加一個空格)\n!Win11android_4 出現上面這個即說明安裝成功\n然後在開始選單即可看到安裝完成的安卓子系統，點擊運行，勾選上開發者模式\n解壓縮另一個 zip 檔案運行，即可安裝 apk 文件\n至此即安裝完成\n**********以下內容由 yexca 添加**********\n如果工具箱無法安裝或出現下圖情況，請打開子系統設置，打開第一個選項“文件”，再打開工具箱即可 獲取文件路徑 在文件上鼠標右擊選擇“屬性-安全”，第一行對象名稱即為文件路徑\nWSA 工具箱 原發布地址 ","date":"2021-11-09T23:45:42+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/9/","title":"Win11 官方安卓子系統安裝"},{"content":" 該文章使用 Google 翻譯處理。\n該文章由 Hiyoung 編寫，翻譯自 yexca\n1.SQL ORDER BY 關鍵字 ORDER BY 關鍵字用於對結果集按照一個列或者多個列進行排序。\nORDER BY 關鍵字默認按照升序對記錄進行排序。如果需要按照降序對記錄進行排序，您可以使用 DESC 關鍵字\nSQL ORDER BY 語法 1 2 3 SELECT *column\\_name*,*column\\_name* FROM *table\\_name* ORDER BY *column\\_name*1,*column\\_name*2 ASC|DESC; –ASC 表示升序，DESC 表示降序\n–使用 order by 語句時應放在所有語句的最後使用，並且排序多個列時先排 column\\_name1 再 column\\_name2…\n2.刪除所有數據（delete 和 drop table） 您可以在不刪除表的情況下，刪除表中所有的行。這表示表格結構、屬性、索引將保持不變：DELETE FROM table\\_name;\n或\nDELETE * FROM table\\_name;\n**註釋：**在刪除記錄時要格外小心！因為您不能重來！\nDROP TABLE 語句 DROP TABLE 語句用於刪除表。DROP TABLE table\\_name\n**註釋：**與 elete 不同的是 drop table 會刪除表數據和結果，也是不可逆的！\nDROP DATABASE 語句 DROP DATABASE 語句用於刪除數據庫。DROP DATABASE database\\_name\nTRUNCATE TABLE 語句 如果我們僅僅需要刪除表內的數據，但並不刪除表本身，那麼我們該如何做呢？\n請使用 TRUNCATE TABLE 語句：TRUNCATE TABLE table\\_name\n3.SQL join SQL join 用於把來自兩個或多個表的行結合起來。\n下圖展示了 LEFT JOIN、RIGHT JOIN、INNER JOIN、OUTER JOIN 相關的 7 種用法。\nINNER JOIN：如果表中有至少一個匹配，則返回行(INNER JOIN 與 JOIN 是相同的) LEFT JOIN：即使右表中沒有匹配，也從左表返回所有的行 RIGHT JOIN：即使左表中沒有匹配，也從右表返回所有的行 FULL JOIN：只要其中一個表中存在匹配，則返回行 註釋：SQL 中的 join 語句其實對應數據庫理論中的連接概念，left join、right join 和 inner join 對應自然連接，full join 對應笛卡爾積\n4.SQL 約束 (Constraints) 1 2 3 4 5 6 7 CREATE TABLE table_name ( column_name1 data_type(size) constraint_name, column_name2 data_type(size) constraint_name, column_name3 data_type(size) constraint_name, .... ); NOT NULL – 指示某列不能存儲 NULL 值。 UNIQUE – 保證某列的每行必須有唯一的值。（一個表可以有多個 UNIQUE 約束但只能有一個 primary key，primary key 自動包含 unique 約束） PRIMARY KEY – NOT NULL 和 UNIQUE 的結合。確保某列（或兩個列多個列的結合）有唯一標識，有助於更容易更快速地找到表中的一個特定的記錄。（主鍵） FOREIGN KEY – 保證一個表中的數據匹配另一個表中的值的參照完整性。（外鍵） CHECK – 保證列中的值符合指定的條件。 DEFAULT – 規定沒有給列賦值時的默認值。 5.AUTO INCREMENT 字段 我們通常希望在每次插入新記錄時，自動地創建主鍵字段的值。\n我們可以在表中創建一個 auto-increment 字段。\n下面的 SQL 語句把 “Persons” 表中的 “ID” 列定義為 auto-increment 主鍵字段：CREATE TABLE Persons\n1 2 3 4 5 6 7 ( ID int IDENTITY(1,1) PRIMARY KEY, LastName varchar(255) NOT NULL, FirstName varchar(255), Address varchar(255), City varchar(255) ) 在上面的實例中，IDENTITY 的開始值是 1，每條新記錄遞增 1。\n**提示：**要規定 “ID” 列以 10 起始且遞增 5，請把 identity 改為 IDENTITY(10,5)。\n要在 “Persons” 表中插入新記錄，我們不必為 “ID” 列規定值（會自動添加一個唯一的值）：\n1 2 INSERT INTO Persons (FirstName,LastName) VALUES (\u0026#39;Lars\u0026#39;,\u0026#39;Monsen\u0026#39;) 上面的 SQL 語句會在 “Persons” 表中插入一條新記錄。”ID” 列會被賦予一個唯一的值。”FirstName” 列會被設置為 “Lars”，”LastName” 列會被設置為 “Monsen”。\n6.觸發器 參見： SqlServer 基礎之(觸發器) – wangchuang2017 – 博客園 ","date":"2021-11-08T11:51:18+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/8/","title":"SQL 語句的一些語法細節 (SQL SERVER 語句)"},{"content":" 該文章使用 Google 翻譯處理。\n該文章由 Hiyoung 編寫，翻譯自 yexca\n在安裝完 SQL server 和 navicat 後在 navicat 中添加數據庫：\n1.連接名無要求，按照自己需要命名\n2.打開安裝好的 SQL server 配置管理器\n注意 SQL Server（SQLEXPRESS）要保證在運行中，否則 navicat 無法連接\n雙擊開啟後點選服務，可以看到自己的主機名\n3.此時打開 navicat 在主機的地方填上：主機名 \\SQLEXPRESS (格式)\n4.用戶名填 sa (為安裝 SQL server 時的預設用戶名，具體 SQL server 網路教學很多可以自己參考) ，密碼是自己設定的 (同樣在 SQL server 安裝時設定的密碼)\n5.測試連接成功即可使用\n注：僅個人在安裝過程中遇到的問題，具體安裝教程請參考網絡\n附上 navicat 15 及註冊機： https://pan.baidu.com/s/1cJ1EZ9Gyz6Jp6J03VqcDHA 提取碼：3n7g\n","date":"2021-11-07T23:41:46+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/7/","title":"關於在使用 navicat 連接 SQL server 的一些問題"},{"content":" 該文章使用 Google 翻譯處理。\n該文章由 Hiyoung 編寫，翻譯自 yexca\n其文章 (簡體中文): https://blog.hiyoung.icu/2022/12/15/997871bc263d/ 正文 VSC只是一個純文本編輯器，不是 IDE (集成開發環境)，不含編譯器和許多其它功能，所以編譯器要自己裝好\n第一步：在 vscode 官網下載軟件，鏈接： Visual Studio Code – Code Editing. Redefined 第二步：我們需要下載一個編譯器，C 語言使用 gcc，鏈接： MinGW-w64 – for 32 and 64 bit Windows download | SourceForge.net ，選最新版本中的 x86\\_64-posix-seh 即可，網站下載可能較慢，下面給出百度網盤鏈接\n（以下附上百度網盤秒傳鏈接：b48357234368d9ba439fc0db6e86531d#84cbf1dc60abe4fff77d035540ea3132#140697937#mingw64.zip）\n（正常百度網盤鏈接：鏈接: https://pan.baidu.com/s/17FYT\\_Y-s-I2yajFc2MICqw 提取碼: ewis ）\n第三步：將 E:\\mingw64\\bin 添加到系統變量中（盤符根據自己編譯器安裝的位置）\n以 Win11 為例：打開設置-\u0026gt;系統-\u0026gt;關於-\u0026gt;高級系統設置-\u0026gt;環境變量-\u0026gt;系統變量-\u0026gt;點擊Path-\u0026gt;編輯-\u0026gt; 瀏覽-\u0026gt; 把對應文件加入即可\n第四步：\n按 Win+R，運行 cmd（不要跳這一步），輸入 gcc，應該會提示 no input files 而不是“不是內部命令或外部命令”或者“無法將“gcc” 項識別為cmdlet、函數、腳本文件或可運行程序的名稱”。如果是“不是內部命令或外部命令”，說明 gcc 在的文件夾沒有在環境變量的Path中，要加進去才行。如果加了還是這樣，重啟（不要忘記重啟）。如果重啟了還不行，那就是你自己進行的操作有問題。\n輸 gcc -v 可以顯示出 gcc 的版本。如果顯示出來的版本與你剛下的不同/更老，說明 Path 裡原本有老版本的編譯器，可能是安裝其它 IDE 時裝上的。則需要去掉 Path 裡原來的那一個 gcc 的路徑。\n這兩項驗證一定要符合，否則必須修改環境變量。小心別錯刪了。\n第五步：現在打開 vscode，下載相關插件\n第六步：我們需要寫兩個 json 文件，下面依次是 launch.json 和tasks.json（兩個文件名也必須是launch.json 和tasks.json ） 注意看代碼註釋，兩個文件都有幾處地方需要將路徑改為自己編譯器的路徑\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 { // 使用 IntelliSense 了解相關屬性。 // 懸停以查看現有屬性的描述。 // 欲了解更多信息，請訪問: https://go.microsoft.com/fwlink/?linkid=830387 \u0026#34;version\u0026#34;: \u0026#34;0.2.0\u0026#34;, \u0026#34;configurations\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;gcc.exe - 生成和調試活動文件\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;cppdbg\u0026#34;, \u0026#34;request\u0026#34;: \u0026#34;launch\u0026#34;, \u0026#34;program\u0026#34;: \u0026#34;${fileDirname}\\\\bin\\\\$ {fileBasenameNoExtension}.exe\u0026#34;,//這裡意思生成的二進制代碼會放入當前文件的bin文件夾中，我們需要自己新建一個bin文件夾 \u0026#34;args\u0026#34;: [], \u0026#34;stopAtEntry\u0026#34;: false, \u0026#34;cwd\u0026#34;: \u0026#34;${fileDirname}\u0026#34;, \u0026#34;environment\u0026#34;: [], \u0026#34;externalConsole\u0026#34;: false, \u0026#34;MIMode\u0026#34;: \u0026#34;gdb\u0026#34;, \u0026#34;miDebuggerPath\u0026#34;: \u0026#34;E:\\\\mingw64\\\\bin\\\\gdb.exe\u0026#34;, \u0026#34;setupCommands\u0026#34;: [ { \u0026#34;description\u0026#34;: \u0026#34;為 gdb 啟用整齊打印\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;-enable-pretty-printing\u0026#34;, \u0026#34;ignoreFailures\u0026#34;: true } ], \u0026#34;preLaunchTask\u0026#34;: \u0026#34;C/C++: gcc.exe 生成活動文件\u0026#34; } ] } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 { \u0026#34;tasks\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;cppbuild\u0026#34;, \u0026#34;label\u0026#34;: \u0026#34;C/C++: gcc.exe 生成活動文件\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;E:\\\\mingw64\\\\bin\\\\gcc.exe\u0026#34;,//改成自己的檔案路徑 \u0026#34;args\u0026#34;: [ /*\u0026#34;${fileDirname}\\\\*.c\u0026#34;, \u0026#34;-o\u0026#34;, \u0026#34;${fileDirname}\\\\bin\\\\${fileBasenameNoExtension}.exe\u0026#34;, \u0026#34;-g\u0026#34;//多檔編譯*/ \u0026#34;-g\u0026#34;, \u0026#34;${file}\u0026#34;, \u0026#34;-o\u0026#34;, \u0026#34;${fileDirname}\\\\bin\\\\${fileBasenameNoExtension}.exe\u0026#34;//這裡意思產生的二進位程式碼會放入目前檔案的 bin 資料夾中，我們需要自己新建一個 bin 資料夾 ], \u0026#34;options\u0026#34;: { \u0026#34;cwd\u0026#34;: \u0026#34;${fileDirname}\u0026#34; }, \u0026#34;problemMatcher\u0026#34;: [ \u0026#34;$gcc\u0026#34; ], \u0026#34;group\u0026#34;: { \u0026#34;kind\u0026#34;: \u0026#34;build\u0026#34;, \u0026#34;isDefault\u0026#34;: true }, \u0026#34;presentation\u0026#34;: { \u0026#34;echo\u0026#34;: true, \u0026#34;reveal\u0026#34;: \u0026#34;always\u0026#34;, // 執行任務時是否跳到終端面板，可以為 always，silent，never。具體參見 VSC 的文檔 \u0026#34;focus\u0026#34;: true, // 設為 true 後可以使執行 task 時焦點聚集在終端，但對編譯 C/C++ 來說，設為 true 沒有意義 \u0026#34;panel\u0026#34;: \u0026#34;shared\u0026#34; // 不同的檔案的編譯資訊共享一個終端面板 }, \u0026#34;detail\u0026#34;: \u0026#34;調試器生成的任務。\u0026#34; }, { \u0026#34;type\u0026#34;: \u0026#34;cppbuild\u0026#34;, \u0026#34;label\u0026#34;: \u0026#34;(多文件)gcc.exe - 生成和調試活動文件\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;E:\\\\mingw64\\\\bin\\\\gcc.exe\u0026#34;,//改成自己的檔案路徑 \u0026#34;args\u0026#34;: [ \u0026#34;${fileDirname}\\\\*.c\u0026#34;, \u0026#34;-o\u0026#34;, \u0026#34;${fileDirname}\\\\bin\\\\${fileBasenameNoExtension}.exe\u0026#34;,//這裡意思產生的二進位程式碼會放入目前檔案的 bin 資料夾中，我們需要自己新建一個 bin 資料夾 \u0026#34;-g\u0026#34; ], \u0026#34;options\u0026#34;: { \u0026#34;cwd\u0026#34;: \u0026#34;${fileDirname}\u0026#34; }, \u0026#34;problemMatcher\u0026#34;: [ \u0026#34;$gcc\u0026#34; ], \u0026#34;group\u0026#34;: { \u0026#34;kind\u0026#34;: \u0026#34;build\u0026#34;, \u0026#34;isDefault\u0026#34;: true }, \u0026#34;presentation\u0026#34;: { \u0026#34;echo\u0026#34;: true, \u0026#34;reveal\u0026#34;: \u0026#34;always\u0026#34;, // 執行任務時是否跳到終端面板，可以為 always，silent，never。具體參見 VSC 的文檔 \u0026#34;focus\u0026#34;: true, // 設為 true 後可以使執行 task 時焦點聚集在終端，但對編譯 C/C++ 來說，設為 true 沒有意義 \u0026#34;panel\u0026#34;: \u0026#34;shared\u0026#34; // 不同的檔案的編譯資訊共享一個終端面板 }, \u0026#34;detail\u0026#34;: \u0026#34;調試器生成的任務。\u0026#34; } ], \u0026#34;version\u0026#34;: \u0026#34;2.0.0\u0026#34; } 至此設置工作基本結束，vscode 有許多好用的插件可以自己探索，未來也會在寫一篇文章推荐一些好用的插件\n","date":"2021-11-07T23:32:26+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/6/","title":"VsCode 配置 C 語言環境"},{"content":" 該文章使用 Google 翻譯處理。\n正文 安裝完成 VS Code 和 Python 並配置環境變量後\n開啟 VS Code，進入拓展搜尋並下載 Python\n在資源管理器新建一個 Python 原始檔 (.py) 後，資源管理器會在.vscode 資料夾下產生 setting.json 檔案（若沒有自動產生可自行建立）\n開啟 setting.json 文件，並替換為以下程式碼\n1 2 3 4 5 6 { \u0026#34;python.linting.flake8Enabled\u0026#34;: true, \u0026#34;python.linting.flake8Args\u0026#34;: [\u0026#34;--max-line-length=248\u0026#34;], \u0026#34;python.linting.pylintEnabled\u0026#34;: false } 此時回到 python 文件，VS Code 右下會彈出警告，點擊下載\n按 CTRL+SHIFT+P 鍵，輸入 Python: Select Interpreter (即 Python：選擇編譯器)\n然後選擇您下載的編譯器即可\n如果 .vscode 資料夾下有 launch.json 文件，需要在該文件的 configurations 中加入以下程式碼\n1 2 3 4 5 6 7 { \u0026#34;name\u0026#34;: \u0026#34;Python: 目前文件\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;python\u0026#34;, \u0026#34;request\u0026#34;: \u0026#34;launch\u0026#34;, \u0026#34;program\u0026#34;: \u0026#34;${file}\u0026#34;, \u0026#34;console\u0026#34;: \u0026#34;integratedTerminal\u0026#34; } 參考文章 VsCode 配置 Python 環境小白教程 VSCode 配置 Python 教程 ","date":"2021-11-07T11:28:58+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/5/","title":"VsCode 配置 Python 環境"},{"content":" 該文章使用 Google 翻譯處理。\n該文章由 Hiyoung 編寫\nmailto：可以自動調用當前系統默認的郵件客戶端，並自動填充收件人、抄送人、密送人、主題、內容。\n參數說明:\nmailto： 收件人，多個以;分隔\ncc： 抄送人，多個以;分隔\nbcc： 密送人，多以;分隔\nsubject： 主題\nbody： 內容\n各參數間用\u0026amp;連接即可\n例如：\u0026lt;a mailto:***@***.com?subject=this is subject\u0026amp;body=this is body\u0026gt;…\u0026lt;a\u0026gt;\n注：在 elementor 中應在文本編輯器的超鏈接選項中直接填寫 mailto:***@***.com?subject=this is subject\u0026amp;body=this is body 即可\n","date":"2021-11-06T17:05:36+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/4/","title":"如何自動呼叫目前系統預設的郵件用戶端"},{"content":" 該文章使用 Google 翻譯處理。\n正文 首先到待嵌入的視頻將鼠標移到分享按鈕上（不用點擊）\n然後移到嵌入代碼並複制\n（本例代碼如下）\n1 \u0026lt;iframe src=\u0026#34;//player.bilibili.com/player.html?aid=583631611\u0026amp;bvid=BV1Tz4y1X7Bg\u0026amp;cid=206708397\u0026amp;page=1\u0026#34; scrolling=\u0026#34;no\u0026#34; border=\u0026#34;0\u0026#34; frameborder=\u0026#34;no\u0026#34; framespacing=\u0026#34;0\u0026#34; allowfullscreen=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;/iframe\u0026gt; 我們需要這串程式碼中的「aid」和「cid」部分（即 aid=583631611 和 cid=206708397 ）\n然後將 aid 和 cid 填入下方代碼的對應位置\n1 2 3 \u0026lt;div style=\u0026#34;position: relative; padding: 30% 45%;\u0026#34;\u0026gt; \u0026lt;iframe style=\u0026#34;position: absolute; width: 100%; height: 100%; left: 0; top: 0;\u0026#34; src=\u0026#34;https://player.bilibili.com/player.html?cid=206708397\u0026amp;aid=583631611\u0026amp;page=1\u0026amp;as_wide=1\u0026amp;high_quality=1\u0026amp;danmaku=0\u0026#34; frameborder=\u0026#34;no\u0026#34; scrolling=\u0026#34;no\u0026#34;\u0026gt;\u0026lt;/iframe\u0026gt; \u0026lt;/div\u0026gt; （以上代碼中 aid 和 cid 已替換）\n在寫文章的過程若插入影片只需將區塊設為「自訂 HTML」然後把替換好aid和cid的程式碼拷貝過去即可\n如下為示例視頻\n參考文章 關於博客園內嵌入 bilibili 視頻 ","date":"2021-11-06T16:43:20+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/3/","title":"WordPress 嵌入 BiLiBiLi 影片說明"},{"content":" 該文章使用 Google 翻譯處理。\n預設情況下，WordPress 允許作者查看您網站媒體庫中的所有圖像。允許作者查看媒體庫中的所有檔案。 他們還可以查看由管理員 ， 編輯或其他作者上傳的圖像。\n對於許多網站而言，這可能並不重要。 但是，如果您運行一個多作者網站 ，則可能需要更改它。\n首先，進入 網站根目錄/wp-content/themes/您目前使用的主題名稱/\n找到 functions.php 檔案並編輯，在末尾插入如下程式碼即可\n1 2 3 4 5 6 7 8 9 10 11 12 // Limit media library access add_filter( \u0026#39;ajax_query_attachments_args\u0026#39;, \u0026#39;wpb_show_current_user_attachments\u0026#39; ); function wpb_show_current_user_attachments( $query ) { $user_id = get_current_user_id(); if ( $user_id \u0026amp;\u0026amp; !current_user_can(\u0026#39;activate_plugins\u0026#39;) \u0026amp;\u0026amp; !current_user_can(\u0026#39;edit_others_posts \u0026#39;) ) { $query[\u0026#39;author\u0026#39;] = $user_id; } return $query; } 參考文章 如何限制媒體庫對 WordPress 中使用者自己上傳的內容的訪問 ","date":"2021-11-06T14:31:04+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/2/","title":"WordPress 限制使用者存取媒體庫"},{"content":" 該文章使用 Google 翻譯處理。\n歡迎使用 WordPress。這是您的第一篇文章。編輯或刪除它，然後開始寫作吧！\n","date":"2021-11-06T14:15:19+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/1/","title":"Hello World！"}]