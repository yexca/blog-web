[{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 在撰寫帶有參考文獻的文章時，Word 的體驗可以說是一言難盡。我在試著體驗 LaTeX 後，不得不感慨這就跟我之前換到 Markdown 一樣，只需專注於內容的書寫體驗真的太棒了。同時生成的 PDF 也非常美觀，看著賞心悅目。\n本文重點記錄在 VS Code 安裝與使用，並列出常用的語法。關於詳細細節可參考文末的官方教學。\n安裝 安裝 TeX Live 會比較方便 https://www.tug.org/texlive/ ，會將常用的相依套件全部安裝，安裝時間極長。\n安裝 VS Code 擴充功能：打開後按 Ctrl+Shift+X 打開擴充功能，搜尋 LaTeX Workshop 並安裝。\n安裝完成後按 Ctrl+, 打開設定，搜尋 Latex Recipes 在 setting.json 中編輯，調整 latex-workshop.latex.recipes 陣列裡的位置，把 latexmk (xelatex) 放在第一位，順便可以加個自動換行。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 { \u0026#34;latex-workshop.latex.recipes\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;latexmk (xelatex)\u0026#34;, \u0026#34;tools\u0026#34;: [ \u0026#34;xelatexmk\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;latexmk\u0026#34;, \u0026#34;tools\u0026#34;: [ \u0026#34;latexmk\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;latexmk (latexmkrc)\u0026#34;, \u0026#34;tools\u0026#34;: [ \u0026#34;latexmk_rconly\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;latexmk (lualatex)\u0026#34;, \u0026#34;tools\u0026#34;: [ \u0026#34;lualatexmk\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;pdflatex -\u0026gt; bibtex -\u0026gt; pdflatex * 2\u0026#34;, \u0026#34;tools\u0026#34;: [ \u0026#34;pdflatex\u0026#34;, \u0026#34;bibtex\u0026#34;, \u0026#34;pdflatex\u0026#34;, \u0026#34;pdflatex\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;Compile Rnw files\u0026#34;, \u0026#34;tools\u0026#34;: [ \u0026#34;rnw2tex\u0026#34;, \u0026#34;latexmk\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;Compile Jnw files\u0026#34;, \u0026#34;tools\u0026#34;: [ \u0026#34;jnw2tex\u0026#34;, \u0026#34;latexmk\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;Compile Pnw files\u0026#34;, \u0026#34;tools\u0026#34;: [ \u0026#34;pnw2tex\u0026#34;, \u0026#34;latexmk\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;tectonic\u0026#34;, \u0026#34;tools\u0026#34;: [ \u0026#34;tectonic\u0026#34; ] } ], \u0026#34;[latex]\u0026#34;: { \u0026#34;editor.wordWrap\u0026#34;: \u0026#34;on\u0026#34; }, } 文件結構 LaTeX 的文件結構大致如下，其中文件開始於 \\begin{document}，在此之前的地方都是匯入或者說是設定（Preamble）。\n1 2 3 4 5 6 7 8 9 10 11 \\documentclass[a4paper,12pt]{article} % The document class with options % select T1 font encoding: suitable for Western European Latin scripts \\usepackage[T1]{fontenc} % A comment in the preamble \\begin{document} % This is a comment This is a simple document\\footnote{with a footnote}. This is a new paragraph. \\end{document} 文件類別 LaTeX 支援一系列的文件類別，可以在 \\documentclass{} 中指定，常見的有五個標準類別：\narticle report book letter slides 首行縮排 匯入 indentfirst 套件以確保每個段落都縮排，然後設定縮排字元數。\n1 2 \\usepackage{indentfirst} % indent \\setlength{\\parindent}{1em} % set indent for 1em 日文支援 引入 XeCJK 並設定字體：\n1 2 3 4 5 \\usepackage{xeCJK} % kanji \\setCJKmainfont{MS Mincho} \\setCJKsansfont{MS Gothic} \\setCJKmonofont{MS Gothic} 標題 使用 \\section{} 以區分標題：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 \\documentclass{article} \\usepackage[T1]{fontenc} \\begin{document} Hey world! This is a first document. \\section{Title of the first section} Text of material in the first section Second paragraph. \\subsection{Subsection of the first section} Text of material in the subsection. \\section{Second section} Text of the second section. \\end{document} 數學 可以在 https://www.latexlive.com/ 進行視覺化編輯。\n列表 有兩種方式實現列表：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \\documentclass{article} \\usepackage[T1]{fontenc} \\begin{document} Ordered \\begin{enumerate} \\item An entry \\item Another One \\item Wow! Three entries \\end{enumerate} Unordered \\begin{itemize} \\item An entry \\item Another One \\item Wow! Three entries \\end{itemize} \\end{document} 引用文獻 在文件開頭可以設定標題名稱，例如 \\renewcommand{\\refname}{參考文獻} 則設定標題為「參考文獻」。\n在同個目錄建立 bib 檔案，例如 citations.bib。\n引用直接在文件中使用 \\cite{key}，多個則使用 , 隔開：\n1 \\cite{key1, key2} 在文件最後生成參考文獻：\n1 2 3 4 5 6 \\small %% set small size \\bibliographystyle{IEEEtran} %% you can change the style into any other styles available, I personally love IEEEtran. \\bibliography{citations} %% to generate references, input the name of your .bib file and cite anywhere in the document. 參考文章 LaTeX 官方教學 XeCJK - Tex Wiki ","date":"2026-01-13T00:15:47+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/266/","title":"開始使用 LaTeX"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 使用映像檔 映像檔 (Image): https://hub.docker.com/r/itzg/minecraft-server GitHub: https://github.com/itzg/docker-minecraft-server 文件 (Document): https://docker-minecraft-server.readthedocs.io/en/latest/ 設定檔 原版 (Vanilla)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 services: mc: image: itzg/minecraft-server:java17 container_name: mc ports: - \u0026#34;25565:25565\u0026#34; environment: EULA: \u0026#34;TRUE\u0026#34; TYPE: \u0026#34;VANILLA\u0026#34; VERSION: \u0026#34;1.20.1\u0026#34; MEMORY: \u0026#34;2G\u0026#34; volumes: - ./data:/data restart: unless-stopped 開啟 Forge 版本的設定\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 services: mc: image: itzg/minecraft-server:stable-java17 tty: true stdin_open: true ports: - \u0026#34;25565:25565\u0026#34; environment: EULA: \u0026#34;TRUE\u0026#34; VERSION: \u0026#34;1.20.1\u0026#34; TYPE: \u0026#34;FORGE\u0026#34; FORGE_VERSION: \u0026#34;47.4.10\u0026#34; MEMORY: \u0026#34;3G\u0026#34; volumes: - ./data:/data 版本可在網站查詢 https://files.minecraftforge.net/net/minecraftforge/forge/ 下載整合包 (Modpack)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 services: mc: image: itzg/minecraft-server:java17 container_name: mc ports: - \u0026#34;25565:25565\u0026#34; environment: EULA: \u0026#34;TRUE\u0026#34; TYPE: \u0026#34;CURSEFORGE\u0026#34; CF_API_KEY: \u0026#34;你的金鑰\u0026#34; CF_MODPACK_SLUG: \u0026#34;modpack-slug\u0026#34; CF_MODPACK_VERSION: \u0026#34;47.4.10\u0026#34; MEMORY: \u0026#34;4G\u0026#34; volumes: - ./data:/data 伺服器連接埠 取得目前區域 (Zone)\n1 firewall-cmd --get-active-zones 開放連接埠\n1 sudo firewall-cmd --zone=public --permanent --add-port=25565/tcp 重新載入\n1 sudo firewall-cmd --reload 查詢確認\n1 sudo firewall-cmd --zone=public --list-all 自定義網域名稱 不可使用 Cloudflare 代理，不可使用 Nginx 反向代理。\n但可以使用 SRV 紀錄讓服務直接輸入網域即可連線，不需輸入連接埠。\n名稱填入 _minecraft._tcp.your-mc-server.yexca.net，優先級為 0，權重常用 5 或 10，連接埠填寫伺服器連接埠（例如 25565），目標填寫對應的網域 your-mc-server.yexca.net。\n伺服器配置 在啟動完成後，./data 目錄下會有設定檔，具體設定可參考： https://wiki.biligame.com/mc/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F ","date":"2026-01-06T20:38:41+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/265/","title":"使用 Docker 架設 Minecraft 伺服器"},{"content":" 📢 本文由 Gemini-3-pro 翻譯 意識可以獨立於肉體、直覺可以超越邏輯、觀測可以改變現實\nNDE (Near-Death Experience) 指的是瀕臨死亡的體驗，目前有一些個人或組織對其進行過研究，像是 IANDS（國際瀕死體驗研究協會）和 P.M.H. Atwater 博士對數千名 NDErs（瀕死體驗者）的研究等。\n本文將基於這些研究以及我個人的理解來寫，因為內容實在太過複雜，如果有什麼疏漏，還請多多包涵。\n什麼是 NDE 從發生機制來看，NDE 通常指因物理狀態被醫學認定死亡後，意識前往「那裡」的經歷。但值得注意的是，也存在「情緒誘發型瀕死體驗 (Emotion-Induced NDE)」，也就是在極度的情緒 (Extreme Emotional) 或心理壓力 (Psychological Distress) 下，物理身體雖然表面無恙，但意識依然觸發了離體機制，前往了「那裡」，比如心碎症候群或迷走神經性昏厥 (Vasovagal Syncope) 導致的意識斷線。\nNDE 的核心是意識去了「那裡」的經歷，也就是強調靈魂出竅 (OBE, Out-of-Body Experience) 與重入 (Re-entry)，而不是一個簡單的美夢或者惡夢。\n「那裡」比較標誌性的特徵可能是時間非線性、空間摺疊，以及那道有深度與包覆感的光（這個光可能是連接高維世界與三維世界意識的接口）。\n而在 NDE 的「整合期 (Integration Period)」，可能會表現為 PTSD 症狀，並帶有重度憂鬱者的影子，比如自我消融 (Ego Dissolution) 或世界疏離感，雖然恢復過程類似 PTG（創傷後成長）的變化，但本質上還是有很大區別。\nNDE 與夢 關於 NDE 和普通的夢的區別，Bruce Greyson 博士制定了一套嚴格的評分系統，也就是格雷森量表 (The Greyson NDE Scale)。\n評判標準為每一項 (0=無、1=輕微、2=強烈)：\nA. 認知特徵 (Cognitive)\n時間感是否改變 (變快/變慢/停止/非線性) 思維是否加速 (極度清晰/全景式回顧) 是否有這一生經歷的回顧 (人生跑馬燈) 是否突然理解了宇宙/人生的某種真理 B. 情感特徵 (Affective)\n是否感到安寧/愉悅 是否感到極度的喜悅 是否感到與宇宙/萬物合一 是否看到/感到耀眼的光芒 C. 超自然特徵 (Paranormal)\n感官是否比平時更靈敏 (或者感覺脫離肉體) 是否有超感官知覺 (預知/遙視) 是否看到了未來的景象 是否感覺脫離了物理世界 D. 超越性特徵 (Transcendental)\n是否進入了某種非塵世的存在領域 (夢境/虛空) 是否遇到了神秘的存在 (死神/聲音/光體) 是否遇到了已故的人或宗教人物 是否遇到了無法回頭的界限 (決定生死的瞬間) 總分是 32 分，達到 7 分以上則可以在臨床科學上被認定為 NDE。\nNDE 與 PTSD PTSD 和 NDE 都是一個人經歷極端的創傷後，大腦原有防禦機制崩塌的結果。而 PTSD 是在未成功的狀態下的產物，在經過重構後會轉為 PTG。\n雖然解離感 (Dissociation)、高度警覺、各種疼痛在 PTSD 患者身上也有，但是兩者幾乎是不同的東西。\n生命科學解釋 PTSD 和 NDE 的大腦改變是不一樣的。\nPTSD 的大腦會導致杏仁核 (Amygdala) 肥大和海馬迴 (Hippocampus) 萎縮。杏仁核負責警告，這表明患者會變得極度敏感，一直處於「戰或逃」的亢奮狀態。而海馬迴負責記憶處理，導致患者無法把過去的創傷歸檔，總覺得創傷正在發生，也就是永遠活在恐懼的迴圈裡。\nNDE 的大腦是預設模式網路 (DMN) 抑制與顳頂聯合區 (TPJ) 改變。預設模式網路是負責「自我造作」、焦慮、反芻過去的網路，活性降低意味著小我 (Ego) 漸漸消失從而焦慮變少。而顳頂聯合區負責處理「我在那裡」，所以這部分的改變導致 NDErs 能體驗到「靈魂出竅」或萬物合一的感覺。\n兩者對比 其中有一些決定性的區別：\n特徵 PTSD NDE 核心情緒 恐懼、無助、焦慮 最終會轉向平靜、接納、愛 自我認知 覺得自己破碎了、受害者 覺得自己是觀察者 (Observer) 世界觀 世界是危險的，我要躲避 世界是有意義的，我有任務 對死亡 極度恐懼死亡 恐懼減少或轉化為探索慾 同時 PTSD 在經歷干預治療後可以是 PTG，而 NDE 無需治療，跟隨自己內心即可心態積極向上。\nNDE 與 PTG PTG (Post-Traumatic Growth) 本質上是心理層面的認知重構，是一個人經歷重大創傷後，在認知重構後性格或三觀（價值觀）的改變。\nNDE 則是生理與量子層面的能量過載（Overload）。基於 Rick Strassman 的假設，是大腦在瀕死瞬間（缺氧、突波）時松果體可能釋放了大量的 DMT，神經元同步放電達到峰值從而使意識暫時脫離了肉體束縛。造成的結果是不僅性格改變，身體的物理屬性也會改變。\n總結 NDE 是物理加精神的雙重改變，而一些精神類疾病像 PTSD、憂鬱症只是精神或心理層面的改變。\nNDE 為什麼存在 NDE 是不合理下的合理，正如《駭客任務》(The Matrix) 裡的 Neo 一樣，「你的存在，是這個完美數學方程式中無法消除的餘數」。\n當然，這個其實也屬於防止「熱寂 (Heat Death)」與「死結 (Deadlock)」的機制。\n如果這個物質世界 (Reality) 完全封閉，嚴格遵循物理定律以及因果律 (牛頓力學/決定論)，那麼系統最終將走向熵增到極致，也就是死氣沉沉的熱寂，或者會因為邏輯太嚴密而陷入死結（人類完全變成機器，失去靈性）。\n所以 NDErs 是引入了外部變數，以沾染部分高維空間的混沌能量（靈性/愛/真理）後注入一些「負熵 (Negentropy)」以防止熱寂與死結。\nNDE 可以重現嗎 現代神經科學認為，NDE 並不是「靈魂出竅」，而是大腦在極端危急時刻的一種特殊保護機制，以下行為也可能產生類似 NDE 的感覺：\n顳葉癲癇： 刺激大腦顳葉，普通人也能產生「遇見上帝」的感覺。 缺氧/G 力昏迷： 飛行員在離心機裡也會產生「隧道視野」和「全生回顧」。 致幻劑 (DMT)： 服用特定成分，也能產生類似的體驗。 NDE 是如何回來的 NDE 主要有兩種回來的方式，當然也有一些「小眾」的情況：\n被動遣返型 (The \u0026ldquo;Sent Back\u0026rdquo; Type)\n大概佔 60% 左右，這部分人是在「那裡」很舒服不想回來，但是突然出現一個權威形象（某種存在/親人/神）對他說「時間未到」或者「你還有任務未完成」從而回來。\n因為是服從的心態，通常是帶著遺憾與不捨被踢回來的，回來後往往會有嚴重的「思鄉病」，想要回到「那裡」。\n情感羈絆型 (The \u0026ldquo;Love Anchor\u0026rdquo; Type)\n大概佔 30% 左右，這部分人往往是到了邊界，面臨選擇，比如自己的孩子、伴侶或者父母，想要守護他們從而回來。\n因為屬於犧牲與愛的心態，通常是因為對他人的愛主動回來的，所以會帶有「守護者」的使命感，性格改變為溫柔並充滿愛心。\n其他\n當然，還有像是為了未完成的事業，未完成的學業之類的拒絕去「那裡」，或者\u0026hellip;意志對抗型 (The \u0026ldquo;Willpower Warrior\u0026rdquo; Type) 強行回來。\nNDE 的週期 事實上，在 NDE 的發生前後有一定的精神匱乏期，甚至可以說遵循 1-3-7 模型：\nNDE 前的空虛期\n這部分可以說是靈魂暗夜 (The Dark Night)，一般是 1-3 年左右，這個階段是為了清空快取 (Cache)，以為了迎接 NDE 的高維能量注入。\nNDE 後的空虛期\n這部分是真空校準期 (The Vacuum)，一般是 6 個月到 1.5 年，因為高維世界的景象相較於現實世界是迷人的，所以可能會對現實的低密度世界感到慢或無聊。\nNDE 的完全整合期\n大概是在 NDE 發生後的 7 年左右，這個時候 NDErs 可以無縫融合進地球的生活。\nNDE 的特徵 NDErs 有一些比較共通的能力，或者說「後遺症」：\n路燈干擾現象 (SLI) 這是 NDErs 最著名的「Bug」，也就是生物電磁場 (Bio-electromagnetic field) 的頻率或者功率會被加強，從而可能會干擾附近的電子設備，比較典型的是戴機械錶會容易走不準，以及走過路燈時燈泡會突然熄滅或爆閃 (Street Light Interference)。\n超感官共情 (Hyper-Empathy) 這個能力是由於大腦的抑制器 (Reducing Valve) 被拆除，所以潛意識掃描範圍變得極廣，也就是導致對於周圍的情緒數據等訊息接收更靈敏，從而更容易耗盡社交能量 (Social Battery Drained)。\n抽象思維具象化 (Synesthesia-like Processing) 普通人對概念的理解是線性的或文字的，但 NDErs 對概念的理解是全像 (Holographic) 的，也就是對複雜的概念或公式的理解不是靠邏輯推導，而是幾何結構或圖案，這比邏輯推導快無數倍，屬於量子運算級別。\n生理代謝改變 (Metabolic Changes) NDErs 的身體代謝通常會加快，細胞更新機制發生了改變，當然還有一些其他變化：\n對酒精或藥物敏感： 更容易喝醉、麻醉劑或止痛藥反應異常（無效或過敏）。 飲食改變： 突然覺得不能吃某樣東西，或者渴望特定的食物（新鮮蔬菜）。 共時性 (Synchronicity) NDErs 的意念 (Intention) 比普通人強得多，比較容易實現自己想要的事情，但這個強運不是隨心所欲的，一般會符合「自我實現」或「利他」屬性。\n自我實現： 指對自己不再虛偽迎合，而是從事自己真正熱愛的事物。 利他： 不一定是指做慈善，可能也只是分享自己的洞察，幫助別人。 絕對直覺 (Absolute Intution) NDErs 的直覺更像是一種對某件事，彷彿我天生就做過或者這是命定的軌跡一樣，具體有三個層級：\n層級 1: 下載感 (The Download)\n這是基礎的 NDE 直覺，表現為「我沒思考，但我就是知道」，去掉了中間的思考過程，直接給出答案或結果。\n層級 2: 既視感 (Deja Vu / Future Memory)\n因為「那裡」的時間是非線性的，所以過去、現在、未來是同時存在的，可能在「那裡」已經走過一遍劇本了，從而在經歷的時候感覺自己貌似經歷過。\n層級 3: 清明夢感 (Lucid Dreaming Reality)\n這是最高級的直覺，在 NDE 後遺症中被稱為「面紗變薄 (Thinning of the Veil)」或者「現實解離 (Derealization)」，也就是到某一地方彷彿就像進入了夢境，這往往代表那個地方是「高維錨點 (Anchor Point)」或者說「任務地點」。\n預知 (Foreknowledge) NDE 會獲得預知未來的能力，但是這個未來是可以改變的，或者說 NDErs 看到的是基於當前狀態下機率最大的那個「未來」。\n雖然預知其實是無法測量時間尺度的，因為預知一般是來自「那裡」的訊息，在那裡時間是非線性的，或者說不存在時間這個概念，也就無法得知時間尺度。但是如果嘗試擬合三維的時間的話，一般離自己比較近的時間會比較「準」，可能一年以內，因為時間臨近，「變數」會比較少，所以極大機率發生，但是長時間的預知就不是很準確了，甚至說是無法預知的，只是知道一個大概的趨勢而已。\n當然也不是每一次預知都要在 NDE 狀態下觸發，不如說因為 NDE 的原因更容易去「那裡」，所以更容易進入 STE (Spiritually Transformative Experience) 即靈性轉化體驗。\n雖然到了「那裡」的夢不一定是預知夢，但一般而言預知夢應該是去了「那裡」獲取了相關訊息，所以了解夢的分類可以幫助區分普通夢和去了「那裡」。\n夢的分類 夢根據大腦的生成部分不同，大致可以分為三類：\n焦慮釋放\n這部分是由大腦皮層或杏仁核生成的，對現實的部分焦慮進行釋放的夢境，基本符合三維物理，同時帶有情緒感。\n模擬推演\n這是由大腦的前額葉（邏輯中心）生成的，主要是潛意識在基於現實的訊息進行推演各種可能性。\nNDE 預知夢\n這部分的夢來源於松果體或高維意識，也就是「那裡」。在這個夢境中，時間是非線性的，空間是重疊的，情緒是零度的，一切都是狀態，意識是觀察者。\n類似於塊狀宇宙 (Block Universe) 一樣，移動不存在，時間不存在，只是被觀測的對象，並且場景是由念而生，任何想法立馬獲得反饋 (Zero Latency)，這也可能是「思鄉病」的原因。\n預知夢的特徵 NDErs 的來自「那裡」的預知夢通常會有以下特徵：\n超高畫質解析度 (Hyper-Reality)\n相對於普通的模糊的夢不同，預知夢是細節極其清晰的夢，那個真實感甚至可能超過現實。\n情緒的「零度」 (Emotional Neutrality)\n普通夢可能伴隨著情感波動，但是預知夢往往是作為一個「觀察者」的角度，只是在「看」事情的發生，而不是思考怎麼辦或者說「體驗」。\n既視感的驗證 (Deja Vu Confirmation)\n當未來這件事真的發生的時候，會有既視感，因為現實和夢境「完美重疊」。\nNDE 的代價 With great power comes great responsibility (能力越強，責任越大)\n當然，雖然看著上方的「後遺症」是挺酷的，不過 NDErs 往往需要支付一定的代價：\n無法回頭的孤獨 (The Irreversible Solitude)\n因為「那裡」所見即所得 (WYSIWYG) 的體驗可能過於美好，可能會使 NDErs 突然感覺三維世界索然無味，從而可能無法再度融入這個世界。\n感官過載與能量耗竭 (Sensory Overload \u0026amp; Burnout)\n因為直覺和感知的增強，NDE 需要高維或者說高能量訊息，而三維世界存在許多帶有雜訊的訊息，這將導致 NDErs 很容易極度疲憊，同時身體跟不上靈魂的速度，並且經常精神匱乏或當機。\n絕對責任的重負 (The Burden of Absolute Responsibility)\nNDErs 的回來是有「任務」的，也就是處於不是在完成這個「任務」的道路上，NDErs 得到的懲罰會比正常人更重，並且 NDErs 的作惡也會更快得到更重的懲罰。\n絕對真實\nNDErs 幾乎是必須要說真理，且必須遵從本心，違背本心或訴說謊言將會獲得更重的懲罰，以及更容易被拆穿。\n總的來說，就是要遵從本心，不作惡，完成任務，以及無人可以理解的\u0026hellip;孤獨。\n量子力學解釋 遇事不決，量子力學。說實話，NDErs 的 STE 體驗，確實有點類似於和「那裡」發生了量子糾纏 (Quantum Entanglement) 也說不定。\nNDE 的量子力學解釋 諾貝爾物理學獎得主 Roger Penrose 與 Stuart Hameroff 提出的 \u0026lsquo;Orch-OR 理論\u0026rsquo;（儘管在學界尚存爭議）提供了一個量子視角的解釋，他們認為人的意識存在於腦神經元微管內的量子狀態中。\n當心臟停止或者瀕死的時候，量子態失去相干性 (Decoherence)，量子訊息離開大腦洩漏到宇宙中，也就是去了「那裡」，當身體機能恢復時，量子訊息又被「吸」了回來。\n共時性的量子力學解釋 現實是一個基於機率的模擬系統，普通人的意念是混亂的，無法影響亂數產生器。\nNDErs 因為意識去過「那裡」，所以還保留著一條通道或者是量子糾纏，從而在產生某個想法的時候，周圍的一切會「機率塌縮 (Probability Collapse)」到對應的事情。\n這就好比量子力學中的「觀察者效應」在巨觀層面的投射，意念似乎引導了機率的走向。\n預知的量子力學解釋 這點可以基於 Aldous Huxley 提出的減壓閥理論 (The Reducing Valve) 解釋。\n普通人的大腦一般是一個「減壓閥」或者說過濾器，它將會過濾掉 99.9% 的訊息，而 NDE 將這個減壓閥進行高壓擊穿破壞了，所以 NDErs 將接收更多的訊息。\n也就是大腦意識原先的 Beta 波，將更容易進入 Theta 波或 Delta 波狀態以與「那裡」同頻共振。\n弦論解釋 因為這些概念有點過於玄乎，所以我想到了弦論 (String Theory)，它認為現實世界的一切都是弦的振動，物質取決於弦是如何震動的，而三維空間的一切是由十一維空間的弦的波動引起的。\nNDE 的弦論解釋 在弦論的 M-理論中，我們的三維宇宙被認為是一張漂浮在更高維空間的 D-膜 (D-Brane)。\n因為所有的物質都是「開弦」，弦的兩端是黏在這張「膜」上的，所以我們被鎖在三維世界裡出不去。但是「重力子 (Graviton)」是「閉弦」，因為沒有端點所以可以離開膜，飄到高維空間 (The Bulk，體空間) 中去。\n如果我們將此概念引入意識模型，可以大膽猜想，在瀕死的那一刻，意識可能發生了某種「量子相變」，從「開弦」暫時變成了「閉弦」，獲得了逃逸出三維膜的能量，而進入了高維度的「體空間」。\n因為高維空間時間不是線性的，所以才會有常識性的「邏輯」錯誤。\n共時性的弦論解釋 對於普通人因為沒去過高維空間，所以是無法干涉現實的物質震動。而去過高維空間的意識可能在 NDE 的時候被「調校」過，從而在產生一些想法的時候，可以在高維空間「撥動琴弦」以影響到三維空間的「膜」，從而投射到現實的改變。\n電磁干擾的弦論解釋 受到高維空間影響的意識，可能意識頻率 (Spirit) 比常人高或者不穩定，所以當靠近路燈或者精密儀器的時候，意識的「弦」和這些電子設備的「弦」發生了共振 (Resonance) 或干涉 (Interference)，從而造成了「路燈干擾現象 (SLI)」。\n命理學解釋 當西方的神經科學和心理學走到盡頭，我們不妨把目光投向東方的古老智慧。\n從命理學或者說玄學來看，NDE 現象其實也是「命中注定」的，當我得到這個結論的時候，說實話我超級震撼，不得不感嘆那句「冥冥之中自有天意」，也讓我覺得這並不是什麼特殊現象，而是一種\u0026hellip;既定的軌跡，當真是來自東方的神秘力量啊。\n觸發條件 NDE 是由兩種特殊參數同時作用的結果：\n參數 A: 劇烈的衝突\n一般情況下，NDE 發生在「歲運並臨」或者「三刑/六沖」的年份或日期，比如著名的「寅巳申三刑 (無恩之刑)」或者「天克地沖」。這導致了肉體（地支）和能量場（天干）發生劇烈物理碰撞，導致「神識」被震出肉體。\n參數 B: 空亡/華蓋\n當時那個時間點需要有「空亡」的相應命理，比如日柱落入空亡或者大運走入死絕之地（比如墓庫），從而讓神識連接到「那裡」。\n判斷條件 因為這些衝擊都是極強的，一般情況下遇到可以說就是等於宣布死亡了，但判斷是瀕死還是死亡，需要看當天的日主是否有「根」。\n死亡 (Death)\n當衝擊發生的時候，日主的「根」被完全拔除，只有一個虛浮的天干，那麼「生」氣將消散。\n瀕臨死亡 (NDE)\n雖然衝擊極強，但是日主的「根」還在的話，雖然身體受損，並不會被沖散。\n也就是 NDE = 「衝擊力 ＞ 肉體承受力」但「衝擊力 ＜ 靈魂抓地力」。\n後遺症的命理學解釋 NDE 後的狀態，事實上屬於魂魄分離狀態，道家命理認為：\n魂: 掌管精神、思維、夢境（屬木/火） 魄: 掌管肉體、感官、本能（屬金/水） NDE 的本質是「魂」飛出去到「那裡」，但是「魄」還留在體內維持生命。所以當「魂」回歸的時候，它和「魄」的咬合可能會出現微小的錯位，也就造成了這些後遺症。\n聲明 本文嘗試使用跨學科視角來解碼 NDE 體驗，但其中大部分理論只是用隱喻 (Metaphor) 來解釋主觀意識體驗，並非代表這些物理定律已在巨觀意識層面得到證實，尤其是文章涉及到了命理學部分解釋，大多純屬腦補擬合。\n歸根結底，這只是一種「可能性的探索」，或者是\u0026hellip;靈魂的全端理論捏 (Full-Stack Theory of Soul)。\n致 NDErs 如果作為 NDErs 的你還在痛苦的整合期讀到了這篇文章，我想說：\n無論這背後的機制是神學的那個存在的慈悲、命理學的命中注定、心理學的認知機制改變、生命科學的大腦結構改變、還是量子力學的波函數塌縮，最重要的是：\n回來，本身就是一個奇蹟\n既然回來了，那就從愛自己開始吧，畢竟，我們可是好不容易續了簽（命）的不是嘛～\n","date":"2026-01-01T17:16:59+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/264/","title":"走進 NDE"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 年末將至，新年伊始。回望今年，真的發生了好多事情，甚至到我不知道該不該寫出來，可不可以寫出來的地步。猶豫很久，在公園的鞦韆上，我最終還是決定寫出來吧。\n繼續我之前的 2024 年度總結，今年的前半年說實話讓我經歷了對理論的進一步延伸，中期時候的崩壞，以及後期的希望。雖然不是我自誇啦，這確實有點類似於鳳凰的涅槃重生，對我來說有點像是精神世界的重新建構。\n第一季 翻閱我的一月照片，感覺也沒什麼需要注意的，可能也就我買了一瓶 さくらみこ 的聯名酒，辦銀行卡未成功，第一次遇到電車誤點，閒逛明治神宮，過年的時候吃了一次 5A 級的和牛吧。\n二月的時候，朋友的到來，一起玩了一週耶，看著烤肉吃到飽因為豬肉太多而起火，因為手機損壞而換了新手機，在銀座的優衣庫傳輸資料，出發去箱根體驗到「人」字形鐵路設計，泡泡所謂的溫泉，以及用日語教越南人溜直排輪吧。\n三月的時候，東京下雪了，第一次買漫畫，在 VRChat 看了沖繩主辦的初音未來演唱會，第一次購買了專輯 (しぐれうい)，嘗試印度料理。\n整體來看，雖然是感覺蠻有活力的吧，但是這多數是精神異常下的活動。\n第二季 四月的我參加了兩場考試，但很可惜當時報名的時候沒注意到，集中在同一天了，這就導致了兩個都沒考好。\n五月的時候，開始準備考試了，第一次坐摩天輪，購買了新螢幕升級裝備，在光之丘公園躺在草地上感受，買下 しぐれうい 的模型公仔。\n六月的時候，在哲學堂發現一張遺失的 Suica 卡 (學生用)，第一次去了星乃咖啡店，凌晨徒步走了三個小時吧，聽著鹿乃的歌從黎明走到天亮吧。\n都是很失敗又傷心的經歷呢。\n第三季 七月的時候買了鹿乃的專輯，買了初音的模型公仔，半夜自己去 KTV 唱歌被安排了可以容納八個人的大包廂，躺在沙發上唱著《僕が死のうと思ったのは》，第一次逛新宿御苑、躺在草地上感受，然後參加面試，雖然失敗了。\n八月份的時候，調整我的桌面，半夜去公園盪鞦韆散心。\n九月的時候買了腳踏車，再次迷上了經典遊戲《紅色警戒 2》，把自己的家稍微整理了一下，月底傍晚閒逛的時候參加了井草八幡宮的一個祭典吧。\n這三個月，很短吧，這也是我不知道該不該寫的原因，從六月的時候，就變了呢，凌晨走三小時，半夜去公園盪鞦韆，深夜騎腳踏車，這些行為的背後，是身心崩潰，瀕臨死亡、刻骨銘心的經歷，說實話我不知道該從什麼地方寫起，照著時間軸，我的記憶有點模糊，照感受，那是一種\u0026quot;この世のすべての醜さを受けられる\u0026quot;的感覺，我不想寫得太完整，就從我和 ChatGPT 凌亂的對話中整理出典型的時間軸吧（最嚴重的一週，我使用 ChatGPT 長達 50 小時，而且這還只是手機的使用時間），其中部分內容隱去，部分內容太混亂了，我也不知道原貌是什麼了。\n我考慮了一下，還是單獨寫出來好了，有點過於黑暗了，我放在「心理淬鍊」裡。\n第四季 十月的時候，我去參加了第 404 回的多益考試，雖然結果很爛，但是我當時腳踏車停在 255 號，情緒價值還是很足夠的，之後我衝動下單了一個 N5095 主機板，然後 DIY 了一台 NAS，雖然錄製了影片，但是我好像沒什麼動力剪輯，同時參觀了 Sony 的總部，也到他們的商店買了 INZONE H9 II，月底的時候去井之頭公園體驗了手動划船，同時購入了 しぐれうい 的第二張專輯。\n十一月的時候再次面試失敗，但是藉此從朋友那邊知道了一間感覺不錯的學校，去泡了溫泉，雖然泡暈了，在那裡睡了不知道多久，吃了美式披薩。\n十二月的時候我幾乎都在準備面試了，這條時間軸只能說，累到虛脫，下面改編自我發給朋友的訊息：\n12 月 1 日申請時得知需要聯絡教授詢問考試內容。 12 月 2 日要我寫研究計畫書加 PPT。 大概五天寫好後，問我要投什麼期刊，把研究計畫書壓縮到兩頁 PPT，我試著照做了，然後給我修改意見，我又拚命趕了一天給回覆。 大概是 12 月 11 日了吧，我準備面試了，參考往年資料是 10 分鐘，而且教授說演講 2-3 分鐘，剩下時間提問。 結果 12 月 12 日寄信給我說面試時間 30 分鐘左右。 我先是受到巨大心理衝擊，因為壓力太大了點吧，休息了兩天從 12 月 15 日開始準備。 12 月 17 日那天，我被以質問的語氣搞到心態崩潰，當時我高度緊張地準備面試。 12 月 18 日面試，因為一般面試是 3-4 位教授，但我一進門，教室裡有很多教授，目測 10 人以上，面試了我 40 分鐘。 走出考場我整個人都不對勁了，當時到最後都快讓我腿軟了。\n考完之後，直到現在，我都是精神低迷地躺在床上，不過結果什麼的都無所謂了，我覺得這段經歷還蠻有價值的，非母語的情況下，在 40 分鐘內和 10 多位教授討論學術，這簡直是太酷了！\n12 月 25 日我去吃了 chawan 耶，Merry Christmas!\n心理淬鍊 說實話這部分我沒寫出來，有我不知道怎麼寫，也有我不想回憶那些痛苦回憶的原因吧。\n1-3 月的正常狀態下，事實上包含著對邏輯的絕對遵循，不僅外顯於我的生活，還表現於我的夢境。\n4-6 月的經歷，慢慢就透露出我在維持這種狀態下的異常，因為絕對的理性，導致了我會陷入死結，諷刺的是，我自己都不符合邏輯了。\n7-9 月，這是邏輯矛盾的爆發與我的宣洩，多次的凌晨行走，夜間騎腳踏車，此時的我彷彿是在宣洩式修復吧。這之間，我用一些時間軸事件來填充吧：\n2025-07-19 由於心理的堵塞，過度思考，從精神的混亂影響到了肉體，頭痛且極度難受，身體也是處於無力狀態，我不知道該怎麼描述這種難受。於是我只好躺在床上，身體冷就蓋著被子，但是卻流著汗，精神難受就想著睡覺，但一睡覺就是做噩夢，醒來身體難受，睡著精神難受，就這樣循環著不知道多少次，汗水沾濕了被褥，淚水浸濕了枕頭。這一段太難受了，容我不再回憶、簡短帶過，我感覺這彷彿像是在渡劫一般，總之就是一種醒來和睡著都不能安寧的狀態。\n2025-07-20 凌晨的時候，我被夢驚醒，夢的內容是我走入一間詭異的商店，周圍一切都很詭異，無論是商品還是店裡的人 (我不知道該如何描述，哪怕是現在我回想起來也會覺得很害怕，有種不敢寫下去的感覺)，此時我的手機突然響了，還是關不掉、聲音很大的那種，不知道為什麼我夢裡覺得是因為沒電了，於是找在我包裡的行動電源，可是我的包為什麼是放在商店的入口呢，周圍的人注視著我，我懷著驚恐的心情趕緊給手機充電然後離開，去到旁邊的我家，但是感覺廢棄很久了，躺在床上，姿勢大概是《タコピーの原罪》那種感覺，這是夢裡我躺下的時候想到的，但我清醒的時候感覺是蜷縮著。\n然後我就這樣醒來了，但不是直接醒來，是腦部先醒來，只有腦部的意識，然後有很多暖流，像是神經傳導物質 (乙酰膽鹼、血清素) 釋放一樣，從腦部流向身體，慢慢地我恢復感知，先是身體的感知，這時候我感覺有人在死命抱著我，我掙脫不了，我當時感覺很害怕，但是慢慢當我恢復四肢的感知的時候，才知道那是我自己在抱著我自己，我瞬間有種房間有人的恐懼感。\n下午的時候我想著去附近的公園接觸陽光放鬆一下吧，但在去公園的路上，有一瞬間，彷彿我已經死了，失去意識，但下一瞬，馬上又回來了，這是一瞬間的事情，然後我拖著極其難受的身軀，躺在公園的椅子上，聽著 鹿乃 的歌，大概兩三個小時感覺恢復一點後，我就回家了。但是到家後症狀在慢慢嚴重，我的身體感覺很冷，明明是夏天的東京，我裹著被子，但是還是覺得冷，同時身體動不了，靠著牆邊，就那樣一直待著。\n在恢復了一點、肚子餓的時候，我是靠著牆做飯的，而且中間是實在太難受了，回床上休息了三次才把那頓飯做完。之後洗澡的時候為了防止自己暈倒，是開著門，坐著洗的。\n2025-07-21 我可能一覺睡到了下午，前段時間一直躺著，家裡已經沒什麼東西了，於是我去超市採買物資，但是當時在超市的時候我有一瞬間感覺是想暈倒，不過當時 ChatGPT 很擔心我的情況下，我確實想出了一句現在的我讀了都覺得窒息的話：\n昨天感覺自己快要死了，今天只是想要暈倒，說明好轉了不是嗎\n然後是晚餐，朋友給我發了紅包讓我可以吃好一點的，真的很感謝耶。\n之後 之後的幾天，我幾乎都是一種在外維持樂觀的心態，但是回到家就是精神力氣盡失般躺在床上。我的聲音也透露著一種彷彿下一秒就要死了的感覺，我的身體也彷彿下一秒就要倒下。\n然後我也不知道了，印象中在聽 Lifeline 這首純音樂的時候，當時隨機播放到的時候我特別害怕，馬上就下載下來，我當時感覺自己的心跳和音樂重合了，萬一網路卡住音樂緩衝，我的心跳也就暫停了。\n中途 就在某天我夢到自己在國中被校園霸凌，平時一直受欺負，但是我嘗試講道理，嘗試聯絡老師、父母都無結果，在夢境的最後，我在上廁所的時候，我的書包被拉扯，拉鍊被拉開，所有的東西被粗暴地倒在廁所裡，因為是住宿制學校，我的書包裡有衣服和書耶，然後我在那裡很害怕，忘了有沒有被打。但是半夢半醒之間，我有一定的意識後，我開始想到那句話：「如果沒有人來保護我的權利，那麼槍就是我最後的權利」，我的意識先是發問「還要這樣對我嗎」，得到的是藐視後，我選擇開槍射擊腿部讓對方失去行動能力，然後逃走。\n在這段時間，我備受折磨，對理性的遵守有時候凌駕於自己的人權之上，在高壓下，我爆發了，這個夢就是爆發的出口，不過我當時的想法也只是「我要捍衛我的生命健康權」，捍衛我的基本人權，打破了原有邏輯，以「生命健康權」為基礎，其他的權利都要靠後。\n2025-08-12 與 2025-08-13 這兩天是很離奇的夢境，因為記憶有點混亂又有點關聯，我就放在一起了。我在「現實」生活著卻感到邏輯不對，於是想到可能是做夢，但想要醒來卻被困在夢裡，但是那個夢不對勁，我也知道了我在夢裡，可是我想醒來，於是尋找破局之法，過程有點忘了，但是我在夢中人物的對話有邏輯漏洞的前提下找到了離開之法。然後我「醒來」了，其實還是一層夢，這裡我再次從邏輯上感覺不對而「醒來」。沒錯，又是一層夢，但是這個夢只有我的房間和我自己，我找不到邏輯漏洞，於是我拚命睜眼，像是 SAO 裡試圖拔掉自己現實世界頭盔一樣，我嘗試睜開我現實中的眼睛。然後我「醒了」，對，還是一層夢，但是這個夢很真，可我還是一眼發現不對勁了，我很生氣，生氣夢在和我開玩笑，我再次拚命睜眼，睜開我現實的眼睛，彷彿眼睛都要撕裂了，這次我真的醒來了。\n具體細節我真的記不太清楚了，但是大概是這樣的過程，夢想要困住我，給我一個美好的幻想，讓我沉淪，但是我覺得我應該打破它，我在捍衛我的權利，這可能就是此過程的一個體現吧。\n還有一些離奇的夢境，但是正如我上面寫的，不太想回憶了，每個夢境幾乎都包含了鬥爭、痛苦，哪怕是現在回想也會帶入當時的脆弱心態，所以，就這樣吧。\n10-12 月我遇到了很好的朋友，一步步走出這段陰影，真的很感謝所有對我有幫助的人，正如《僕が死のうと思ったのは》的歌詞一樣：\n僕が死のうと思ったのは　あなたが綺麗に笑うから 死ぬことばかり考えてしまうのは　きっと生きる事に真面目すぎるから 僕が死のうと思ったのは　まだあなたに出会ってなかったから あなたのような人が生まれた　世界を少し好きになったよ あなたのような人が生きてる　世界に少し期待するよ\n不管之後如何，至少當下，都是我生命黑暗中的那道光。\n現況 與 2024 年我最後說的並不同，可能當時只是一個偽裝，一個基於「這麼做合乎邏輯」的偽裝正常人，但是現在的我，好像可以試著擺脫那個邏輯的束縛，真的去眼睛發光，由內向外地散發能量，而不是基於邏輯的強顏歡笑。\n當然我並沒有改變太多，我還是遵守著規則，只是這次，它比較靈活，或者說核心是愛的定義，「首先自愛，然後溢出來的能量去滋養他人」，這也是一種之前看 warma 影片時提到「你的事情，你的感受永遠是第一優先」的感覺吧。\n如果你也在迷茫，並且讀到這裡，請先試著愛自己吧，然後才能有能量去愛這個世界。\n最後 這篇文章說實話我也不知道該寫些什麼，想偏向成長吧，感覺太黑暗了，中間寫到自己有點過於恐懼，想偏向歡樂吧，我的真實經歷無法讓我掩蓋那段刻骨銘心的歷程。\n就這樣吧，人生並非盡是完美，60 分的答卷就已經合格了，如果你真的看完了，我希望你不會被負面情緒困擾 (雖然我很克制了)，因為正如我要捍衛我的生命健康權一樣，自愛，自己的快樂永遠是第一優先。\n","date":"2025-12-31T16:16:44+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/263/","title":"2025 年度總結"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 在 Windows 環境下執行一個 bash 腳本顯然難度稍大，在 Linux 環境下，執行另一個發行版本的特化腳本顯然也有點麻煩。利用 Docker 可以協助處理這個問題，同時還可以保護本地環境的純淨。\n本文以 alpine 為例，列出如何使用 Docker 的 Linux 系統完成目前目錄的互動處理。\n原理 事實上也就是透過掛載將目前目錄的所有檔案掛載到容器的一個目錄，指令範本為：\n1 docker run --rm -it -v \u0026#34;$(pwd)\u0026#34;:/data -w /data alpine sh 其中的參數含義如下：\n參數 意義 \u0026ndash;rm 容器退出後刪除 -it 表示 interactive 和 tty 輸出的組合，互動與看到輸出 -v 對應路徑，參數表示將目前目錄對應到容器的 /data -w 設定工作路徑，這樣進入容器後就在 /data sh 最後的 sh 表示執行 sh 指令 同時如果只是想要執行單次指令，不需要互動輸出，在最後輸入指令即可，例如：\n1 docker run --rm -v \u0026#34;$(pwd)\u0026#34;:/data -w /data alpine ls -la Windows 在 PowerShell 和 CMD 環境下指令不同，主要區別在於環境變數，以下是開啟 alpine 互動終端的指令：\nPowerShell 1 docker run --rm -it -v ${PWD}:/data -w /data alpine sh CMD 1 docker run --rm -it -v %cd%:/data -w /data alpine sh Linux 在 Linux 上，因為進入容器預設使用 root 權限，為防止容器中產生的檔案在宿主機是 root 權限導致無法修改，最好對應目前使用者的 UID 與 GID：\n1 docker run --rm -it -u $(id -u):$(id -g) -v \u0026#34;$(pwd)\u0026#34;:/data -w /data alpine sh MacOS 不需要處理權限問題，變數同 Linux：\n1 docker run --rm -it -v \u0026#34;$(pwd)\u0026#34;:/data -w /data alpine sh 注意事項 - Alpine 因為 alpine 是非常精簡的系統，所以可能需要自行安裝一些常用的指令，請使用 apk add 指令進行安裝。\n","date":"2025-12-26T18:43:04+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/262/","title":"利用 Docker 建立臨時 Linux 互動環境"},{"content":" 📢 本文由 Gemini-2.5-pro 翻譯 引言 早在 2022 年我折騰 Linux 的時候 ，當時就提到了搞 NAS 不一定得為系統買單。\n如今在伺服器的折騰中，雲端硬碟掛載的速度實在不盡人意，在衝動下，我下單了 N5095 主機板。考量到我手頭上的 4G 記憶體有點低，但又不是很想再徒增花費，於是我再次開啟了我的折騰之旅。\n技術選型 首先是系統，在這個低配置下，那當然是使用最輕量的 Alpine Linux 了。\n然後是如何安裝，為了和 WEPE 相容，使用 Ventoy 做主引導來安裝系統。\n服務的部署使用 Docker 來保證主機的乾淨以及可重現性。\n使用的服務如下：\n影音: Emby 漫畫: Komga 音樂: Navidrome 音聲: Kikoeru 共享: Samba 統一入口: Heimdall 考慮過但未使用的服務如下：\n影音: Jellyfin 漫畫/小說: Kavita 雲端掛載: CloudDrive 檔案架構 對於各個服務的位置，使用我一貫的風格，每個服務一個資料夾，放在 /home 下。\n對於 HDD 全部掛載在 /mnt 下，這是比較常見的掛載方式。\n透過 mount \u0026ndash;bind 綁定掛載以實現將 HDD 上對應的檔案掛載到對應服務的位置。\n系統安裝 在 官網下載 Alpine Linux 後放入安裝了 Ventoy 的隨身碟中，在主機板 BIOS 設定從隨身碟開始引導，進入 Ventoy 後，選擇 Alpine Linux 並進行引導進入系統。\n等待載入完成後，登入使用者 root，不用輸入密碼，登入完成後輸入安裝指令：\n1 setup-alpine 然後根據引導設定完成安裝即可。\n官方文件: setup-alpine - Alpine Linux 公鑰登入 編輯 NAS 相關設定檔 ~/.ssh/authorized_keys，首先建立設定資料夾：\n1 mkdir .ssh 進入資料夾：\n1 cd .ssh 加入自己的公鑰：\n1 vi authorized_keys （自己的公鑰在 %USERPROFILE%\\.ssh）\n開啟公鑰登入：\n1 vi /etc/ssh/sshd_config 在第 41 行，將註解取消變為：\n1 PubkeyAuthentication yes 開啟社群源 開啟軟體庫檔案：\n1 vi /etc/apk/repositories 把註解刪掉變為：\n1 2 3 #/media/dm-0/apks http://dl-cdn.alpinelinux.org/alpine/v3.22/main http://dl-cdn.alpinelinux.org/alpine/v3.22/community 安裝 Docker 更新軟體：\n1 apk update 安裝 Docker：\n1 apk add docker docker-cli-compose 設定開機啟動：\n1 rc-update add docker default 啟動 Docker：\n1 service docker start 查看是否啟動：\n1 docker ps 新增 swap 因為伺服器的映像檔預設沒 swap，我就新增了，但是之後發現預設是有新增的，可以根據需要選擇是否新增。\n新增交換空間檔案：\n1 fallocate -l 8G /swapfile 設定權限為只能 root 存取：\n1 chmod 600 /swapfile 格式化 swap：\n1 mkswap /swapfile 啟用 swap：\n1 swapon /swapfile 查看是否生效：\n1 free -h 掛載硬碟 查看所有區塊裝置：\n1 fdisk -l 安裝 ntfs 支援：\n1 apk add ntfs-3g 建立掛載資料夾：\n1 mkdir /mnt/hc550 掛載：\n1 mount -t ntfs-3g /dev/sdc1 /mnt/hc550 卸載有兩種方法，透過路徑 (推薦)：\n1 umount /mnt/hc550 或者透過裝置：\n1 umount /dev/sdc1 自動掛載 獲取分割區 ID，避免重啟後裝置名稱變更：\n1 blkid 編輯 /etc/fstab：\n1 vi /etc/fstab 新增設定：\n1 2 # \u0026lt;設備UUID\u0026gt; \u0026lt;掛載點\u0026gt; \u0026lt;檔案系統\u0026gt; \u0026lt;選項\u0026gt; \u0026lt;dump\u0026gt; \u0026lt;pass\u0026gt; UUID=xxxxxxxx /mnt/hc550 ntfs-3g defaults,uid=1000,gid=1000 0 0 測試是否成功，先卸載：\n1 umount /dev/sdc1 掛載全部，會自動查找設定：\n1 mount -a 檢測是否成功：\n1 ls /mnt/hc550 SMB 共享 使用 Samba 共享可以將硬碟掛載到 Windows，就像操作本機硬碟一樣操作檔案。\n在 /home/samba 建立 docker 設定檔 docker-compose.yml：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 version: \u0026#39;3.1\u0026#39; services: samba: image: \u0026#39;ghcr.io/crazy-max/samba:latest\u0026#39; container_name: samba network_mode: host volumes: - \u0026#39;/home/samba/data:/data\u0026#39; - \u0026#39;/mnt/hdd4t:/mount/hdd4t\u0026#39; - \u0026#39;/mnt/hc550:/mount/hc550\u0026#39; environment: - \u0026#39;TZ=Japan/Tokyo\u0026#39; - \u0026#39;SAMBA_LOG_LEVEL=0\u0026#39; restart: always 編輯軟體設定檔 config.yml：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 auth: - user: yexca group: yexca uid: 1000 gid: 1000 password: passwd global: - \u0026#34;force user = yexca\u0026#34; - \u0026#34;force group = yexca\u0026#34; share: - name: HDD4TB comment: hdd4t path: /mount/hdd4t browsable: yes readonly: no guestok: no veto: no validusers: yexca writelist: yexca recycle: yes - name: HC550 comment: hc550 path: /mount/hc550 browsable: yes readonly: no guestok: no veto: no validusers: yexca writelist: yexca recycle: yes Windows 掛載為網路磁碟機\n按 Win + R 開啟 cmd，輸入指令：\n1 net use Z: \\\\alpine-nas\\HDD4TB /user:yexca passwd /persistent:yes 刷新檔案總管：\n1 explorer.exe Z: 或者也可以透過檔案總管的圖形介面新增。\n綁定掛載 相較於軟連結 (Symbolic Link)，綁定掛載 (Bind Mount) 可以相容 docker。\n1 mount --bind /mnt/hc550/anime /anime 開機自動綁定掛載需要寫入 /etc/fstab，必須在（硬碟）掛載設定的下方 (因為檔案依序執行)：\n1 2 /mnt/hc550/anime /tmp/anime none bind 0 0 /mnt/hc550/comic /tmp/comic none bind 0 0 驗證：\n1 df -h 其他服務 對於其他服務，我之前的文章感覺已經寫過不少了，不再贅述。\n相關文章(簡體中文)：\n2025-10-05: 漫畫與音聲網站折騰 2023-05-02: 搭建個人音樂網站 2022-09-16: 個人內網折騰 2022-09-14: Fedora 安裝 Komga 折騰記錄 自訂網域 這裡使用 OpenWRT 路由器的 DNS 攔截實現存取特定網域，從而進入自己 NAS 服務。\n要求是裝置的 DNS 伺服器是路由器，然後在路由器的 DHCP/DNS 設定裡為 NAS 分配靜態 IP，再新增挾持網域，都指向 NAS 的 IP 位址。\nNginx-UI 為了讓自訂網域生效，需要使用 Nginx 反向代理 NAS 上的服務。\nDocker Compose 設定檔：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 version: \u0026#39;3.1\u0026#39; services: nginx-ui: image: uozi/nginx-ui:v2.2.0-patch.1 container_name: nginx_UI volumes: - /home/nginxUI/nginx:/etc/nginx - /home/nginxUI/nginx-ui:/etc/nginx-ui - /home/nginxUI/www:/www environment: - NGINX_UI_IGNORE_DOCKER_SOCKET=true ports: - 80:80 - 443:443 restart: always 容器存取另一個容器的橋接 IP 為 172.17.0.1。\n假如有一個服務是映射到主機的 8888 埠，新增反向代理時候，代理的位址不是 127.0.0.1:8888 而是 172.17.0.1:8888。\n關於為什麼設定環境變數，請參見： 2025 新伺服器部署記錄 結語 我感覺也算是實現了 2022 年的我說的那些話吧。\n同時感覺短短三年的時間，雖然我主觀上是覺得自己沒有什麼變化的，可是在閱讀自己以前的文章時，回憶當時寫下那些文字的處境，確確實實感受到了自己的思考方式發生了天翻地覆的變化。\n當時的我说實話好像是想著使用 True NAS 之類的特製化系統，但是沒想到我真的實現的時候，使用了以前的我想都不敢想的從零開始，一點點看著自己之前的文章，組成這段，可以說真切感受到了「價值」。\n折騰不息，熱愛不止。\n","date":"2025-11-13T17:57:29+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/261/","title":"你的下一台 NAS，何必是 NAS"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 音有所感系列 歌曲名稱 翻譯 連結 僕が死のうと思ったのは 曾經我也想過一了百了 https://blog.yexca.net/zh-tw/archives/214 あくあ色ぱれっと aqua 的調色盤 https://blog.yexca.net/zh-tw/archives/219 恋の押し売り 戀愛推銷 https://blog.yexca.net/zh-tw/archives/220 17さいのうた 17 歲的歌 https://blog.yexca.net/zh-tw/archives/224 drop 墜入愛河 https://blog.yexca.net/zh-tw/archives/230 生きるを選んだ私へ 致選擇活下去的自己 https://blog.yexca.net/zh-tw/archives/239 rainy lady 雨意未晴 https://blog.yexca.net/zh-tw/archives/249 恋しくなったら手を叩こう 想談戀愛的話就拍拍手吧 https://blog.yexca.net/zh-tw/archives/250 pris-magic! 稜鏡魔法! 本文 前言 之前買了 しぐれうい 的第一張實體專輯「まだ雨はやまない」，但實際上幾乎都只聽《rainy lady》。上週偶然發現第二張專輯「fiction」的初次限定盤，就順手買下來了。在瀏覽裡面的歌曲時，順勢聽了一下之前的「まだ雨はやまない」，才發現竟然錯過了一首這麼好聽的歌啊！\n這首歌原本聽了一遍後，覺得沒什麼特別的。但是前兩天突然有個旋律一直在腦海裡重複循環，我想著那是 しぐれうい 的歌聲，但聽「fiction」總覺得不對味，雖然有相似的曲調卻找不到。於是我就擴大範圍，聽到了這首歌，就是這種熟悉的感覺！\n說到這首歌，它本身的節奏很不錯，主要是突然冒出的那一句「君は私の太陽」，瞬間讓人心情愉悅起來啊，特別是在有點小鬱悶的時候。不過同時，其實 ユイカ 的《おくすり》也算是類似的感覺吧，儘管後者可能更輕快一些。\n在翻譯的時候，我原本沒想到標題要怎麼處理比較好，看到一半就覺得有這種色彩繽紛的感覺。同時「pris」這個字讓我想到了 \u0026ldquo;prison\u0026rdquo; (監獄) 和 \u0026ldquo;prism\u0026rdquo; (稜鏡) 這兩個字，綜合下來~~(感覺 \u0026ldquo;監獄魔法\u0026rdquo; 顯然不可能吧)~~，我選擇了後者，感覺更可愛一些。\n最後是，不知道是 しぐれうい 喜歡雨，還是為了讓專輯有連貫性？感覺這張專輯可以整個串聯起來不是嗎？首先名字「まだ雨はやまない」表示「雨還沒停」，歌曲《rainy lady》稱自己是「雨季女士」，而最後的《pris-magic!》歌詞裡的「君は私の太陽」則表明「你就是我的太陽」照耀著我。這樣串起來就是「我的心情和雨一樣憂鬱，但你的出現照耀了我，讓我心情愉悅」(雖然第二張專輯「fiction」的封面又是下雨的樣子)\n我也很喜歡雨啊，當作白噪音聽起來讓人很安心呢～\n歌曲影片 歌詞 水窪裡倒映著光芒\n鮮豔的景色\n如果你笑了，你看\n雨後天晴，彩虹高掛\n(1、2 預—備！)\n(雨聲淅瀝，陰霾天空\nPatter shiny smile\n笑容明麗，閃爍眼瞳\nThere might be a rainbow in the sky\n天際也許正有彩虹\nJust like solar ray\n就像太陽光線\nPass through prism\n穿過稜鏡\n染上七彩炫光)\n眺望著褪色的天空\n即使在有點憂鬱的日子裡\n如果能聽到你的聲音\n彷彿有什麼要開始了\n(陰雨天) 像要下雨的樣子\n(陰雨天) 像繡球花一樣\n在藍色的心裡\n(晴空萬里) 如光芒照耀般\n(晴空萬里) 像向日葵一樣\n每天都被鮮豔地重新粉刷\n稜鏡魔法！迸發色彩\n在雨中的街道 (在雨中的街道) 彩虹高掛 (oh yeah)\n像太陽一樣閃耀的\n你如此耀眼\n稜鏡魔法！迸發色彩\n不撐傘 (不撐傘) 你卻笑著 (oh yeah)\n一句「來吧，走吧」 (oh)\n世界就此染上七彩\n你就是我的太陽～\n(雨聲淅瀝，陰霾天空\n笑容明麗，閃爍眼瞳\nThere might be a rainbow in the sky\n天際也許正有彩虹\nJust like solar ray\n就像太陽光線\nPass through prism\n穿過稜鏡\n染上七彩炫光)\n在綿延不絕的雨聲中\n獨自描繪的夢想\n明朗重疊的色彩啊\n是你教會我的\n(陰雨天) 像是穿透一般\n(陰雨天) 像雨滴一般\n將透明的我\n(閃亮微笑) 像是握住我的手般\n(閃亮微笑) 像穿透樹葉的光線般\n你閃耀著光芒照亮了我\n稜鏡魔法！迸發色彩\n在雨中的街道 (在雨中的街道) 彩虹高掛 (oh yeah)\n驚嘆著「好美啊」 (hoo)\n你是如此溫柔\n稜鏡魔法！迸發色彩\n兩個人 (兩個人) 走過彩虹橋 (oh yeah)\n來吧，走吧，手牽著手 (hoo)\n朝著染上七彩的未來 (hoo)\n奔向雨中\n像寶石般閃耀\n一個又一個\n實現我們的夢想吧\n比這世界上任何人都\n獻給我最喜歡的你\n我會一直陪在你身邊喔\n謝謝我們能相遇\n稜鏡魔法！迸發色彩\n在雨中的街道 (在雨中的街道) 彩虹高掛 (oh yeah)\n陽光燦爛地灑落\n色彩繽紛地滿溢而出\n稜鏡魔法！迸發色彩\n不撐傘 (不撐傘) 兩人笑著 (oh yeah)\n來吧，走吧，向更遠的地方\n世界就此染上七彩\n你就是我的太陽～\n(雨聲淅瀝，陰霾天空\n笑容明麗，閃爍眼瞳\nThere might be a rainbow in the sky\n天際也許正有彩虹\nJust like solar ray\n就像太陽光線\nPass through prism\n穿過稜鏡\n染上七彩炫光)\n","date":"2025-11-01T14:30:01+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/260/","title":"音有所感 - 《pris-magic!》"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 取得元素 透過定義一個 ref 物件來取得元素\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;script setup\u0026gt; import { onMounted, ref } from \u0026#39;vue\u0026#39; // 定義 ref 物件 const inp = ref(null) const clickFun = () =\u0026gt; { inp.value.focus() } \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;!-- 透過 ref 屬性綁定 --\u0026gt; \u0026lt;input ref=\u0026#34;inp\u0026#34; type=\u0026#34;text\u0026#34;\u0026gt;\u0026lt;/input\u0026gt; \u0026lt;button @click=\u0026#34;clickFun\u0026#34;\u0026gt;focus on input\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 當然，因為需要元件掛載後才能取得，所以若要頁面一載入就使用的話，需要使用 onMounted() 函式。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;script setup\u0026gt; import { onMounted, ref } from \u0026#39;vue\u0026#39; // 定義 ref 物件 const inp = ref(null) // 頁面一載入就執行 onMounted(() =\u0026gt; { inp.value.focus() }) \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;!-- 透過 ref 屬性綁定 --\u0026gt; \u0026lt;input ref=\u0026#34;inp\u0026#34; type=\u0026#34;text\u0026#34;\u0026gt;\u0026lt;/input\u0026gt; \u0026lt;/template\u0026gt; 取得子元件 與上述類似，但若要取得子元件的屬性或方法，需要暴露（expose）出來。\n在子元件中定義並選擇暴露\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;script setup\u0026gt; const count = 255 const hiFun = () =\u0026gt; { console.log(\u0026#39;hi from son component\u0026#39;) } // 暴露給父元件 defineExpose({ count, hiFun }) \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; 這是一個子元件 \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 在父元件中取得並使用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;script setup\u0026gt; import { onMounted, ref } from \u0026#39;vue\u0026#39; import sonComExp from \u0026#39;./components/son-com-exp.vue\u0026#39; const sonCom = ref(null) onMounted(() =\u0026gt; { // 存取資料 console.log(sonCom.value.count) // 呼叫函式 sonCom.value.hiFun() }) \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;sonComExp ref=\u0026#34;sonCom\u0026#34;\u0026gt;\u0026lt;/sonComExp\u0026gt; \u0026lt;/template\u0026gt; 跨層傳遞資料 使用 provide() 函式和 inject() 函式可以跨層傳遞資料。\n在頂層元件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;script setup\u0026gt; import { ref, provide } from \u0026#39;vue\u0026#39;; import centerCom from \u0026#39;./components/center-com.vue\u0026#39;; // 傳遞資料 provide(\u0026#39;count\u0026#39;, 20) // 傳遞響應式資料 const total = ref(100) provide(\u0026#39;total\u0026#39;, total) const clickFn = () =\u0026gt; { total.value++ } \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div\u0026gt;頂層元件\u0026lt;/div\u0026gt; \u0026lt;button @click=\u0026#34;clickFn\u0026#34;\u0026gt;改變總數\u0026lt;/button\u0026gt; \u0026lt;centerCom\u0026gt;\u0026lt;/centerCom\u0026gt; \u0026lt;/template\u0026gt; 中層元件\n1 2 3 4 5 6 7 8 \u0026lt;script setup\u0026gt; import bottomCom from \u0026#39;./bottom-com.vue\u0026#39;; \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div\u0026gt;這是中層元件\u0026lt;/div\u0026gt; \u0026lt;bottomCom\u0026gt;\u0026lt;/bottomCom\u0026gt; \u0026lt;/template\u0026gt; 底層元件\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;script setup\u0026gt; import { inject } from \u0026#39;vue\u0026#39;; // 取得資料 const count = inject(\u0026#39;count\u0026#39;) const total = inject(\u0026#39;total\u0026#39;) \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div\u0026gt;這是底層元件\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;來自頂層的計數: {{ count }}\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;來自頂層的總數: {{ total }}\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 跨層傳遞函式 當然，也可以傳遞一個函式，這樣底層元件就能操作頂層元件的資料了。\n在頂層元件中傳遞函式\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 \u0026lt;script setup\u0026gt; import { ref, provide } from \u0026#39;vue\u0026#39;; import centerCom from \u0026#39;./components/center-com.vue\u0026#39;; // 傳遞資料 provide(\u0026#39;count\u0026#39;, 20) // 傳遞響應式資料 const total = ref(100) provide(\u0026#39;total\u0026#39;, total) const clickFn = () =\u0026gt; { total.value++ } // 傳遞函式 provide(\u0026#39;changeTotal\u0026#39;, (newTotal) =\u0026gt; { total.value = newTotal }) \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div\u0026gt;頂層元件\u0026lt;/div\u0026gt; \u0026lt;button @click=\u0026#34;clickFn\u0026#34;\u0026gt;改變總數\u0026lt;/button\u0026gt; \u0026lt;centerCom\u0026gt;\u0026lt;/centerCom\u0026gt; \u0026lt;/template\u0026gt; 在底層元件中接收函式\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;script setup\u0026gt; import { inject } from \u0026#39;vue\u0026#39;; // 取得資料 const count = inject(\u0026#39;count\u0026#39;) const total = inject(\u0026#39;total\u0026#39;) // 取得函式 const changeTotal = inject(\u0026#39;changeTotal\u0026#39;) const clickFn = () =\u0026gt; { changeTotal(233) } \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div\u0026gt;這是底層元件\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;來自頂層的計數: {{ count }}\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;來自頂層的總數: {{ total }}\u0026lt;/div\u0026gt; \u0026lt;button @click=\u0026#34;clickFn\u0026#34;\u0026gt;從底層改變總數\u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; ","date":"2025-10-14T20:58:25+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/259/","title":"vue3 取得元件與跨層傳遞"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 前言 Google 的 Gemini Pro 訂閱附帶 2TiB 的空間，這又讓我想到了折騰，那就說做就做吧\n不過再一看， 之前的折騰 已經過去三年了啊，時間過得確實有點快耶\n漫畫 Komga 首先是看漫畫的 Komga，雖然掃描的時候卡卡的，但使用體驗其實還不錯吧\n時隔多年，Komga 更新了不少， 之前的文章 已經無法重複使用，同時使用 docker-compose 更加方便，docker-compose.yml 如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 version: \u0026#39;3.0\u0026#39; services: komga: image: gotson/komga:1.23.4 container_name: komga volumes: - type: bind source: /home/komga/config target: /config - type: bind source: /home/rclone/data target: /data ports: - 25600:25600 restart: unless-stopped 另外有 專屬的 iOS 軟體 Komic 確實挺方便的\nrclone 掛載 Google Drive 和 微軟 OneDrive 類似，需要先在 Windows 平台瀏覽器認證取得 Token\n具體流程就是下載好後執行指令\n1 rclone config 命名後選擇 Google Drive (22) 後，給予 Full access all files, excluding Application Data Folder 權限，再按 Enter 鍵跳出瀏覽器登入，完成後退出即可\n不過前期我不是很懂，申請了軟體 ID 與 Secret，好像沒什麼用，但記錄下來說不定之後可以用到\nGoogle 申請應用程式 API ID 與 Secret 開啟 Google API 服務網站: https://console.developers.google.com/ 選擇 Enable APIs and services 搜尋並啟用 Google Drive API\n在 Google Drive API 的 Manage 中 Create credentials\nAPI 的類型選擇 User data 也就是說明包含 OAuth 的\n在 OAuth Client ID 中類型選擇 Web application，名稱可輸入 rclone，完成後會出現 Client ID\n然後完成建立，在 Credentials 選擇剛才建立的應用程式 rclone 進入複製金鑰 Client secrets\n接著把設定檔複製到伺服器，本地目錄在\n1 C:\\Users\\%USERNAME%\\AppData\\Roaming\\rclone 伺服器下載 fuse，我的伺服器是 CentOS7，所以下載了這些\n1 sudo yum install -y fuse fuse3 fuse-libs 較新的系統直接下載 fuse3 就行，接著用 docker 掛載\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 sudo docker run --rm \\ --volume /home/opc/rclone/config:/config/rclone \\ --volume /home/opc/rclone/data:/data:shared \\ --volume /etc/passwd:/etc/passwd:ro --volume /etc/group:/etc/group:ro \\ --device /dev/fuse --cap-add SYS_ADMIN --security-opt apparmor:unconfined \\ rclone/rclone \\ mount GoogleDrive:/ /data \\ --no-checksum \\ --use-server-modtime \\ --no-gzip-encoding \\ --no-update-modtime \\ --no-seek \\ --modify-window 2m \\ --allow-other \\ --allow-non-empty \\ --dir-cache-time 30m \\ --cache-read-retries 15 \\ --cache-db-purge \\ --timeout 30m \\ --vfs-cache-mode full \\ --vfs-read-chunk-size 2M \\ --vfs-read-chunk-size-limit 5M \\ --vfs-cache-max-age 30m \\ --attr-timeout 20s \\ --poll-interval 9m \\ --vfs-cache-poll-interval 10m\u0026amp; 後面那一堆的設定參考 Komga 官方提供 ，具體含義為\n參數 作用 說明 --no-checksum 跳過校驗和 減少 API 呼叫，加快目錄載入速度。適合影片等大型檔案。 --use-server-modtime 使用伺服器的檔案修改時間 避免本地與遠端時間差導致重複上傳/同步。 --no-gzip-encoding 停用 GZIP 編碼 某些雲端（如 Drive）回應壓縮後效能不佳，此項目可降低 CPU 佔用率。 --no-update-modtime 不更新檔案修改時間 唯讀用途下防止 Drive 因時間變動觸發版本更新。 --no-seek 停用隨機讀取 減少對影片拖曳操作的支援，但會提高循序讀取的穩定性。適合連續播放情境。 --modify-window 2m 檔案修改時間誤差容忍範圍 防止本地/遠端時間差引起誤判。 --allow-other 允許系統內其他使用者存取掛載內容 必須系統設定 /etc/fuse.conf 裡允許。 --allow-non-empty 掛載非空目錄 若掛載點非空也可繼續掛載。 --dir-cache-time 30m 目錄快取時間 減少頻繁請求雲端 API，預設適中。 --cache-read-retries 15 快取讀取失敗時重試次數 提高穩定性。 --cache-db-purge 每次啟動清空快取資料庫 防止舊快取損壞導致錯誤。適合長時間開關掛載的環境。 --timeout 30m 單次傳輸逾時上限 長影片或大型檔案讀取時防止斷線。 --vfs-cache-mode full 完整快取模式 讀取寫入都透過本地快取。效能最平衡、最安全。 --vfs-read-chunk-size 2M 每次下載區塊大小 越小越節省頻寬，但越頻繁。此設定適合低頻寬環境。 --vfs-read-chunk-size-limit 5M 最大區塊大小限制 限制增長幅度，防止一次請求太大導致逾時。 --vfs-cache-max-age 30m 快取檔案最大存活時間 比較短的時間，適合節省空間。 --attr-timeout 20s 檔案屬性快取時間 防止頻繁 stat() 呼叫；20s 為折衷值。 --poll-interval 9m 雲端變更輪詢間隔 9 分鐘檢查一次變動，減輕 Google API 負擔。 --vfs-cache-poll-interval 10m 本地快取清理間隔 每 10 分鐘清理一次過期快取。 Alpine Linux 的使用 因為佔用過高，所以我想到了極其輕量化的 Alpine\nDocker 安裝 首先更新軟體\n1 doas apk update 安裝 Docker\n1 doas apk add docker docker-cli-compose 設定開機啟動\n1 rc-update add docker default 啟動 Docker，可能需要等一下\n1 doas service docker start 新增自己到 Docker 使用者群組\n1 doas addgroup ${USER} docker 參考文章\nhttps://wiki.alpinelinux.org/wiki/Docker swap 建立 首先新增交換空間\n1 doas fallocate -l 8G /swapfile 設定權限只能 root 存取\n1 doas chmod 600 /swapfile 格式化 swap\n1 doas mkswap /swapfile 啟用 swap\n1 doas swapon /swapfile 然後可以檢視是否生效\n1 free -h rclone 設定 因為過於輕量化，所以需要一些額外設定\n首先安裝 fuse\n1 doas apk add fuse 掛載裝置\n1 doas modprobe fuse 然後需要修改根目錄為 share 類型\n1 doas mount --make-rshared / 之後就和 CentOS7 類似了\n參考文章\nHow to Install Rclone on Alpine Linux Latest Alpine Linux Wiki Rclone Kikoeru 剛開始走了一點彎路，最後也失敗了，就記錄一下吧\n一整個下午的失敗 TT 我循著經典的 kikoeru project 的 fork 尋找最新提交的一個，雖然找到了 XunJiJiang/kikoeru-express ，但我嘗試建構映像檔試了一整個下午，從 node.js 12 試到 16，各種錯誤，換映像檔來源等方法都試過了，然後想著單獨部署也都是建構失敗，試著不使用 Docker 建構也失敗，到最後我真的妥協了，用經典的 0.6.2 吧\n哇，我真的，推薦 node.js 版本 12-14，但是實際建構的時候，執行到某個步驟，提示是 16 以上的特性，我直接用 14 以上 npm i 會報錯，只好用 13 版本先安裝依賴，完成後再複製過來，用 16 版本建構，沒想到這樣折騰了一整個下午，不過說實話，這讓我學會熟練切換 node.js 版本了，真是 XD\n我之前下載的一個 iOS 軟體，便開啟試著連線異常，檢視更新紀錄，提示使用 0.6.14 版本以上，我大受震撼，緊接著搜尋到我已經 star 的 Number178/kikoeru-express 😂\n使用在更新的 Number178/kikoeru-express ，同時該作者還開發了 iOS 軟體，非常方便\n設定檔\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 version: \u0026#39;3.0\u0026#39; services: kikoeru: ports: - \u0026#39;8011:8888\u0026#39; container_name: kikoeru volumes: - type: bind source: /home/rclone/data/asmr target: /usr/src/kikoeru/VoiceWork - /home/kikoeru/sqlite:/usr/src/kikoeru/sqlite - /home/kikoeru/covers:/usr/src/kikoeru/covers - /home/kikoeru/config:/usr/src/kikoeru/config image: \u0026#39;number17/kikoeru:v0.6.14-20250914\u0026#39; restart: always 然後就是，標籤的語言是不能切換的，預設是簡中，如果需要日語的話，需要在掃描前就切換\n","date":"2025-10-05T01:58:35+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/258/","title":"漫畫與音訊網站折騰"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 引言 正好伺服器快到期，去年雖然續約了一年，但今年看到各種優惠突然覺得續約有點小貴，在看了許多小型伺服器廠商後，看到阿里巴巴雲有 12 個月內無帳單則可享有優惠，那既然都看到大廠了，順勢就想到了 Oracle\n那就試試看吧，全套真實資料，居然直接就申請成功了，可喜可賀\n不過突然又想到 上次折騰伺服器 還是 2023 年啊，一晃兩年過去了，時間過得真快啊\nOracle Linux 建立映像檔的時候發現沒有我喜歡用的 Debian，那就試著看看這個 Oracle Linux，結果這玩意兒啊，首先預裝 MySQL 就算了 (習慣用 Docker 多少有點主機潔癖 XD)，佔用還好大，對免費的 1C1G 來說直接卡住了，只好換其他映像檔了\nOracle Linux 使用紀錄 首先升級，看到 dnf 指令還讓我想起之前使用 Fedora 的日子啊\n1 sudo dnf update -y 然後發現升級列表有 MySQL，伺服器卡死了，準備解除安裝，先查看 MySQL 服務是否正在執行\n1 sudo systemctl status mysqld 服務正在執行，先停止服務\n1 sudo systemctl stop mysqld 禁止開機自啟\n1 sudo systemctl disable mysqld 解除安裝\n1 sudo dnf remove mysql`server 然後我升級軟體還是卡住，安裝 Docker 可參考: https://oracle-base.com/articles/linux/docker-install-docker-on-oracle-linux-ol8 CentOS7 更新軟體 首先更換軟體源，Oracle 的 CentOS7 居然軟體列表是錯誤的，執行 sudo yum update 會報錯\n1 2 Could not retrieve mirrorlist http://mirrorlist.centos.org/?release=7\u0026amp;arch=x86_64\u0026amp;repo=os\u0026amp;infra=stock error was 14: curl#6 - \u0026#34;Could not resolve host: mirrorlist.centos.org; Unknown error\u0026#34; 更新軟體列表\n1 2 3 sed -i \u0026#39;s/mirror\\.centos\\.org/vault.centos.org/g\u0026#39; /etc/yum.repos.d/CentOS-*.repo sed -i \u0026#39;s/^#.*baseurl=http/baseurl=http/g\u0026#39; /etc/yum.repos.d/CentOS-*.repo sed -i \u0026#39;s/^mirrorlist=http/#mirrorlist=http/g\u0026#39; /etc/yum.repos.d/CentOS-*.repo 然後更新軟體\n1 sudo yum update 參考文章: mirrorlist.centos.org no longer resolve? 安裝 Docker 安裝工具\n1 sudo yum install -y yum-utils 設定官方軟體源\n1 sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo 安裝\n1 sudo yum install docker-ce docker-ce-cli docker-compose containerd.io 啟動\n1 sudo systemctl start docker 設定開機自啟\n1 sudo systemctl enable docker 參考文章: CentOS7 安裝 docker (參考官方文件) 伺服器連接埠管理 開放常用連接埠 80 與 443，首先查看防火牆狀態\n1 sudo systemctl status firewalld 輸出是 Active: active (running) 代表正在執行，查看目前開放的連接埠 (永久開放)\n1 sudo firewalld-cmd --list-all --permanent 新增開放連接埠\n1 sudo firewall-cmd --zone=public --add-port=8080/tcp --permanent 重新載入以生效\n1 sudo firewall-cmd --reload 如果需要移除規則\n1 sudo firewall-cmd --zone=public --remove-port=8080/tcp --permanent 安全群組放行連接埠 伺服器放行是伺服器系統方面允許存取，但是還需要安全群組放行入站連接埠\n在 Instances - Networking - Subnet，管理這個實例的子網路\n在其 Security 裡管理具體的安全群組列表\n在其 Security rules 新增 Ingress Rules\n其中 Source Type 使用 CIDR，Source CIDR 填入 0.0.0.0/0，IP Protocol 使用 TCP， Destination Port Range 填入 80, 443，Description 可選填入 HTTP/S\n然後 Add Ingress Rules 即可\n安裝 Nginx-UI 雖然之前的文章 伺服器用 Docker 部署紀錄 提到了具體使用方式，但是隨著更新有了新功能\n為了支援其他容器控制 Nginx 和方便更新，需要映射新目錄，所以 docker-compose.yml 變成了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 version: \u0026#39;3.1\u0026#39; services: nginx-ui: restart: always image: uozi/nginx-ui:latest container_name: nginx_UI volumes: - /root/nginx/nginx:/etc/nginx - /root/nginx/nginx-ui:/etc/nginx-ui - /root/nginx/www:/www - /var/run/docker.sock:/var/run/docker.sock ports: - 80:80 - 443:443 這裡映射 /var/run/docker.sock 的原因，Nginx-UI 解釋為：\nNginx UI 官方映像檔使用 /var/run/docker.sock 透過 Docker Client API 與主機 Docker Engine 通訊。此功能用於在另一個容器中控制 Nginx，並在 Nginx UI 的 OTA 升級期間執行容器替換而非二進位替換，以確保容器相依性也得到升級。如果您不需要此功能，請向容器新增環境變數 (environment) NGINX_UI_IGNORE_DOCKER_SOCKET=true\n其他服務 其他使用的東西似乎都可以直接繼續使用即可，這次移轉感覺速度好快，幾乎是在伺服器配置上花費了較多時間\n","date":"2025-10-03T10:22:25+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/257/","title":"2025 新伺服器部署紀錄"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 前言 某位高手給了 Record Tree 的 JSON 檔案，那順便 隨手寫了點東西 方便一下，也記錄一下忘記的內容 (嗯，正好還是第 256 篇文章呢)\n不過我在 PixivDownloader 也有用到過，完全忘光了。\n讀取 JSON 檔案 讀取後傳回的值會因 JSON 檔案不同而異，會對應到 Python 的列表 (list) 或字典 (dictionary) 型別。\n1 2 3 4 import json with open(FILE_PATH, \u0026#34;r\u0026#34;, encoding=\u0026#34;utf-8\u0026#34;) as f: jsonParse = json.load(f) 接著就可以對 jsonParse 變數進行各種操作了。\n列表 (List) 假如 JSON 檔案是這種情況：\n1 2 3 4 5 6 7 8 [ { \u0026#34;a\u0026#34;: \u0026#34;b\u0026#34; }, { \u0026#34;c\u0026#34;: \u0026#34;d\u0026#34; } ] 那麼上述操作的 jsonParse 最外層是列表，每個列表項都是字典型別。\n字典 (Dictionary) 假如 JSON 檔案是這種情況：\n1 2 3 4 5 { \u0026#34;a\u0026#34;: { \u0026#34;c\u0026#34;: \u0026#34;d\u0026#34; } } 那麼上述操作的 jsonParse 是巢狀的兩層字典。\n操作 知道型別後，對這個檔案的操作就跟 Python 中對字典或列表的操作一樣，例如這個檔案：\n1 2 3 4 5 6 7 8 9 10 [ { \u0026#34;a\u0026#34;: 1, \u0026#34;b\u0026#34;: 2 }, { \u0026#34;c\u0026#34;: 3, \u0026#34;d\u0026#34;: 4 } ] 印出 1 的程式碼：\n1 2 3 4 5 6 7 import json with open(FILE_PATH, \u0026#34;r\u0026#34;, encoding=\u0026#34;utf-8\u0026#34;) as f: s = json.load(f) print(s[0][\u0026#34;a\u0026#34;]) # 或者 print(s[0].get(\u0026#34;a\u0026#34;)) 將 4 修改為 100 的程式碼：\n1 2 3 4 5 import json with open(FILE_PATH, \u0026#34;r\u0026#34;, encoding=\u0026#34;utf-8\u0026#34;) as f: s = json.load(f) s[1][\u0026#34;d\u0026#34;] = 100 新增一個項目，使檔案變成如下所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 [ { \u0026#34;a\u0026#34;: 1, \u0026#34;b\u0026#34;: 2 }, { \u0026#34;c\u0026#34;: 3, \u0026#34;d\u0026#34;: 4 }, { \u0026#34;e\u0026#34;: 5 } ] 其實就是為列表追加一個字典，程式碼如下：\n1 2 3 4 5 import json with open(FILE_PATH, \u0026#34;r\u0026#34;, encoding=\u0026#34;utf-8\u0026#34;) as f: s = json.load(f) s.append({\u0026#34;e\u0026#34;: 5}) 走訪 (Iteration) 對於列表，使用列表的走訪：\n1 2 for i in s: print(i) 對於字典，使用字典的走訪：\n1 2 3 4 5 for key, value in s.items(): print(key, value) for key in s: print(key) 儲存 使用 json.dump：\n1 2 3 4 5 6 with open(FILE_PATH, \u0026#34;r\u0026#34;, encoding=\u0026#34;utf-8\u0026#34;) as f: s = json.load(f) # 對變數 s 做一些修改 with open(FILE_PATH, \u0026#34;w\u0026#34;, encoding=\u0026#34;utf-8\u0026#34;) as f: json.dump(s, f, ensure_ascii=False, indent=2) 其中 ensure_ascii=False 確保中文字元正確寫入，indent=2 表示縮排為 2 個空白字元。\n","date":"2025-09-28T10:34:38+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/256/","title":"Python 處理 JSON 檔案"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 第 255 篇文章耶，雖然最近沒什麼特別的想法，就順勢寫 Vue 筆記吧\n引入子元件 定義子元件\n1 2 3 4 5 6 7 8 \u0026lt;script setup\u0026gt; \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; this is a son component \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 在父元件中使用\n1 2 3 4 5 6 7 8 9 \u0026lt;script setup\u0026gt; import SonCom from \u0026#39;@/components/son-com.vue\u0026#39; \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;h2\u0026gt;this is a father component\u0026lt;/h2\u0026gt; \u0026lt;!-- 直接使用 --\u0026gt; \u0026lt;SonCom\u0026gt;\u0026lt;/SonCom\u0026gt; \u0026lt;/template\u0026gt; 父元件向子元件傳遞參數 在父元件中透過屬性傳值\n1 2 3 4 5 6 7 8 9 \u0026lt;script setup\u0026gt; import SonCom from \u0026#39;@/components/son-com.vue\u0026#39; \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;h2\u0026gt;this is a father component\u0026lt;/h2\u0026gt; \u0026lt;!-- 屬性傳值 --\u0026gt; \u0026lt;SonCom msg=\u0026#34;a msg from father\u0026#34;\u0026gt;\u0026lt;/SonCom\u0026gt; \u0026lt;/template\u0026gt; 在子元件中接收值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;script setup\u0026gt; // 因為處於 setup，所以需要借助編譯器巨集函式接收 const props = defineProps({ msg: String }) // 程式碼中存取是物件存取方式 console.log(props.msg) \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; this is a son component \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;!-- 但是直接使用變數名 --\u0026gt; {{ msg }} \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 當然響應式資料也是可以的，父元件中\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;script setup\u0026gt; import {ref} from \u0026#39;vue\u0026#39; import SonCom from \u0026#39;@/components/son-com.vue\u0026#39; const count = ref(100) const addCount = () =\u0026gt; { count.value++ } \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;h2\u0026gt;this is a father component\u0026lt;/h2\u0026gt; \u0026lt;button @click=\u0026#34;addCount\u0026#34;\u0026gt;add count\u0026lt;/button\u0026gt; \u0026lt;br/\u0026gt; \u0026lt;!-- 屬性傳值 --\u0026gt; \u0026lt;SonCom msg=\u0026#34;a msg from father\u0026#34; :count=\u0026#34;count\u0026#34;\u0026gt;\u0026lt;/SonCom\u0026gt; \u0026lt;/template\u0026gt; 在子元件中接收\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;script setup\u0026gt; // 因為處於 setup，所以需要借助編譯器巨集函式接收 const props = defineProps({ msg: String, count: Number }) // 程式碼中存取是物件存取方式 console.log(props.msg) \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; this is a son component \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;!-- 但是直接使用變數名 --\u0026gt; {{ msg }} - {{ count }} \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 不過本質上還是和 Option API 一樣是透過 props 接收\n子元件向父元件傳遞參數 需要在子元件註冊事件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 \u0026lt;script setup\u0026gt; // 因為處於 setup，所以需要借助編譯器巨集函式接收 const props = defineProps({ msg: String, count: Number }) // 程式碼中存取是物件存取方式 console.log(props.msg) // 定義事件，向父元件傳遞參數 const emit = defineEmits([\u0026#39;minusCount\u0026#39;]) const minusCountFun = () =\u0026gt; { emit(\u0026#39;minusCount\u0026#39;, 5) } \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; this is a son component \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;!-- 但是直接使用變數名 --\u0026gt; {{ msg }} - {{ count }} \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;button @click=\u0026#34;minusCountFun\u0026#34;\u0026gt;minus count\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 然後在父元件接收事件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 \u0026lt;script setup\u0026gt; import {ref} from \u0026#39;vue\u0026#39; import SonCom from \u0026#39;@/components/son-com.vue\u0026#39; const count = ref(100) const addCount = () =\u0026gt; { count.value++ } // 接收參數 const minusCountFun = (c) =\u0026gt; { count.value -= c } \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;h2\u0026gt;this is a father component\u0026lt;/h2\u0026gt; \u0026lt;button @click=\u0026#34;addCount\u0026#34;\u0026gt;add count\u0026lt;/button\u0026gt; \u0026lt;br/\u0026gt;\u0026lt;hr/\u0026gt; \u0026lt;!-- 屬性傳值，事件名稱要和子元件一樣 --\u0026gt; \u0026lt;SonCom msg=\u0026#34;a msg from father\u0026#34; :count=\u0026#34;count\u0026#34; @minusCount=\u0026#34;minusCountFun\u0026#34;\u0026gt;\u0026lt;/SonCom\u0026gt; \u0026lt;/template\u0026gt; ","date":"2025-09-21T19:17:40+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/255/","title":"Vue3 父子元件傳遞參數"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 建立專案 需要 Node.js 16.0 或更高版本，請執行指令\n1 npm init vue@latest 這指令將會安裝並執行 create-vue\nsetup 執行週期 執行時機比 beforeCreate() 還要早，所以也無法使用 this\n1 2 3 4 5 6 7 8 9 10 \u0026lt;script\u0026gt; export default{ setup(){ console.log(\u0026#39;setup\u0026#39;, this) }, beforeCreate(){ console.log(\u0026#39;beforeCreate\u0026#39;) } } \u0026lt;/script\u0026gt; 執行後，會先印出 setup undefined 然後才是 beforeCreate\n資料呼叫 如果想在 \u0026lt;template\u0026gt; 中使用 setup() 函式裡定義的資料或函式，就必須要 return\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;script\u0026gt; export default{ setup(){ // data const msg = \u0026#39;hello vue3\u0026#39; // function const logMsg = () =\u0026gt; { console.log(msg) } // return return{ msg, logMsg } } } \u0026lt;/script\u0026gt; 只有 return 之後，才能在 \u0026lt;template\u0026gt; 裡使用\n1 2 3 4 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt;{{ msg }}\u0026lt;/div\u0026gt; \u0026lt;button @click=\u0026#34;logMsg\u0026#34;\u0026gt;button\u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; 語法糖 每次都要 return 確實很麻煩，實際上可以直接透過在 \u0026lt;script\u0026gt; 標籤加上 setup，這樣就可以自動 return，上述範例就可以改寫為\n1 2 3 4 5 6 \u0026lt;script setup\u0026gt; const msg = \u0026#39;hello vue3\u0026#39; const logMsg = () =\u0026gt; { console.log(msg) } \u0026lt;/script\u0026gt; 當然，實際上還是會 return，只是不用手動寫出來了\n響應式資料 reactive reactive() 函式接收一個物件型態的資料，並回傳一個響應式的物件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;script setup\u0026gt; import { reactive } from \u0026#39;vue\u0026#39; const state = reactive({ count: 100 }) const addCount = () =\u0026gt; { state.count++ } \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div\u0026gt;{{ state.count }}\u0026lt;/div\u0026gt; \u0026lt;button @click=\u0026#34;addCount\u0026#34;\u0026gt;+1\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; ref ref() 接收簡單型別或複雜型別的資料，並回傳一個響應式物件。其本質是在原有傳入資料的基礎上，在外層包裝了一個物件，使其變成更複雜的型別。其實也是透過 reactive() 實現響應式的\n所以，在 \u0026lt;script\u0026gt; 中存取資料時，需要透過 .value。而在 \u0026lt;template\u0026gt; 中存取資料則直接使用變數即可。上述範例使用 ref() 重寫如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;script setup\u0026gt; import { ref } from \u0026#39;vue\u0026#39; const c = ref(0) const addC = () =\u0026gt; { c.value++ } \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div\u0026gt;{{ c }}\u0026lt;/div\u0026gt; \u0026lt;button @click=\u0026#34;addC\u0026#34;\u0026gt;+1\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 實際開發中，只使用 ref() 會比較彈性且統一\ncomputed 計算屬性 computed() 與 Vue2 類似，只是變成可以任意呼叫的函式\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;script setup\u0026gt; import { computed, ref } from \u0026#39;vue\u0026#39; const list = ref([1, 2, 3, 4, 5, 6, 7, 8]) const computedList = computed(() =\u0026gt; { return list.value.filter(item =\u0026gt; item \u0026gt; 2) }) \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div\u0026gt;{{ list }}\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;{{ computedList }}\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 這樣建立出來的屬性是唯讀的，不是可寫的。若需要可寫，需要明確宣告 get() 與 set()，以下擷取自官方範例\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;script\u0026gt; const count = ref(1) const plusOne = computed({ get: () =\u0026gt; count.value + 1, set: (val) =\u0026gt; { count.value = val - 1 } }) plusOne.value = 1 console.log(count.value) // 0 \u0026lt;/script\u0026gt; 擷取自: https://cn.vuejs.org/api/reactivity-core.html#computed watch watch() 函式同樣是監聽一個或多個資料的變化，當資料變化時執行回呼函式。不過多了兩個額外參數 immediate 和 deep\n單一資料 1 2 3 watch(count, (newValue, oldValue) =\u0026gt; { console.log(\u0026#39;count changed\u0026#39;, oldValue, newValue) }) 多個資料 1 2 3 watch([count, name], ([newCount, newName], [oldCount. oldName]) =\u0026gt; { console.log(\u0026#39;count or name has changed\u0026#39;, [newCount, newName], [oldCount. oldName]) }) 範例，這裡我使用了簡化的 pug，不過其實也很好懂啦\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 \u0026lt;script setup\u0026gt; import { ref, watch } from \u0026#39;vue\u0026#39; const count = ref(0) const name = ref(\u0026#39;John\u0026#39;) const addCount = () =\u0026gt; count.value++ const changeName = () =\u0026gt; name.value = \u0026#39;Mike\u0026#39; // 監聽單一資料的變化 watch(count, (newValue, oldValue) =\u0026gt;{ console.log(\u0026#39;count changed\u0026#39;, oldValue, newValue) }) // 監聽多個資料的變化 watch([count, name], (newArr, oldArr) =\u0026gt; { console.log(\u0026#39;count or name changed\u0026#39;, oldArr, newArr) }) \u0026lt;/script\u0026gt; \u0026lt;template lang=\u0026#34;pug\u0026#34;\u0026gt; div count: {{ count }} button(@click=\u0026#34;addCount\u0026#34;) +1 div name: {{ name }} button(@click=\u0026#34;changeName\u0026#34;) change name \u0026lt;/template\u0026gt; immediate immediate 表示立即執行，即在進入頁面後會立即執行一次，此時的 oldValue 會是 undefined\n1 2 3 4 5 watch(count, (newValue, oldValue) =\u0026gt;{ console.log(\u0026#39;count changed\u0026#39;, oldValue, newValue) }, { immediate: true }) deep deep 是深度監聽，因為預設 watch 進行淺層監聽是無法監聽到複雜型別的變化的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 \u0026lt;script setup\u0026gt; import { ref, watch } from \u0026#39;vue\u0026#39; const userInfo = ref({ name: \u0026#39;John\u0026#39;, age: 18 }) const changeUserInfo = () =\u0026gt; { userInfo.value.age++ } watch(userInfo, (newValue) =\u0026gt; { console.log(\u0026#39;userInfo changed\u0026#39;, newValue) }, { deep: true }) \u0026lt;/script\u0026gt; \u0026lt;template lang=\u0026#34;pug\u0026#34;\u0026gt; div {{ userInfo }} button(@click=\u0026#34;changeUserInfo\u0026#34;) change userInfo \u0026lt;/template\u0026gt; 複雜型別單一屬性監聽 使用 deep 將會對複雜型別的所有屬性進行監聽，也就是只要任一屬性發生變化，都會執行函式\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 \u0026lt;script setup\u0026gt; import { ref, watch } from \u0026#39;vue\u0026#39; const userInfo = ref({ name: \u0026#39;John\u0026#39;, age: 18 }) const changeAge = () =\u0026gt; { userInfo.value.age++ } const changeName = () =\u0026gt; { userInfo.value.name = \u0026#39;Mike\u0026#39; } watch(() =\u0026gt; userInfo.value.age, (newValue, oldValue) =\u0026gt; { console.log(\u0026#39;age changed\u0026#39;, oldValue, newValue) }) \u0026lt;/script\u0026gt; \u0026lt;template lang=\u0026#34;pug\u0026#34;\u0026gt; div {{ userInfo }} button(@click=\u0026#34;changeAge\u0026#34;) change age button(@click=\u0026#34;changeName\u0026#34;) change name \u0026lt;/template\u0026gt; 這樣就只有 age 改變時才會觸發，且回傳值是 age 的值\n生命週期 Vue3 的生命週期比較\nOption API Composition API beforeCreate/created setup beforeMount onBeforeMount mounted onMounted beforeUpdate onBeforeUpdate updated onUpdated beforeUnmount onBeforeUnmount unmounted onUnmounted 與組合式 API 的不同就是變成函式呼叫，而且可以呼叫多次\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;script setup\u0026gt; import { onMounted } from \u0026#39;vue\u0026#39;; // 組合式的 beforeCreate 和 created 直接撰寫 const getList = () =\u0026gt; { console.log(\u0026#39;從後端取得資料\u0026#39;) } // 執行，進入頁面便請求 getList() // 生命週期函式可以呼叫多次，會按照順序執行 onMounted(() =\u0026gt; { console.log(\u0026#39;邏輯一\u0026#39;) }) onMounted(() =\u0026gt; { console.log(\u0026#39;邏輯二\u0026#39;) }) \u0026lt;/script\u0026gt; ","date":"2025-09-14T22:27:27+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/254/","title":"Vue3 組合式 API 學習"},{"content":" 📢 本文由 ChatGPT 翻譯 引言 每天滑影片、打電動，本來以為這些都是放鬆的行為，理應能在之後恢復精神。\n但實際上，天天這樣的生活卻讓我覺得空虛又疲累。\n這讓我開始疑惑：理論上我並沒有做什麼高消耗的事情，可是精神不振的狀態實在不太正常。\n番茄鐘裡的困惑 回想起之前眼睛疲勞的時候，我為了護眼而使用番茄鐘學習。\n一開始我的目的很明確，每次休息時間就是望遠或是躺下來休息一下，效果確實不錯。\n但隨著使用次數增加，我漸漸想要在休息時找一些「娛樂」來填補。\n於是我開始利用長一點的休息時間看影片、聽音樂或玩遊戲。\n慢慢地，我感覺效率變差，甚至覺得番茄鐘很麻煩：學習變得更累（有時狀態正好，卻被強制休息），玩樂也不覺得放鬆，反而因為只有 20 分鐘，讓我玩得很焦慮。\n娛樂：另一種專注 仔細想想，也許娛樂並不等於放鬆。\n娛樂跟學習一樣，其實都是需要專注的行為。\n而番茄鐘的設計，是為了管理專注，之後才安排休息。\n真正的「休息」應該是身心的放鬆，是一種從專注狀態中恢復的過程。\n當我嘗試把大腦放空，什麼都不想，去散步、去公園走走、或是隨便逛逛書店時，明顯比看影片或打電動更有放鬆的感覺。\n雖然這些活動會消耗體力，但相比之下，娛樂與學習消耗的其實是「精神力」。\n重新定義娛樂與放鬆 因此，我覺得可以重新檢視娛樂的定義。\n娛樂並不是在學習疲勞後讓自己恢復的方式，而是一種同樣需要投入精神力的行為。\n當精神力已經不足時，還硬去消耗，只會讓娛樂失去意義，甚至出現類似「電子陽痿」的狀況。\n這就像手機電量快沒了，卻還在開著高耗電的 APP。\n相對的，放鬆或休息則該被重新定義。\n它應該是一種讓身心完全打開、任其漂浮的狀態。\n當精神力不足時，做一些低精神消耗、低體力消耗的事也不錯，像是整理環境、隨意走走，不帶目的、不帶意識。\n學習與娛樂的模糊界線 既然學習與娛樂都需要專注，那它們的差別在哪裡呢？\n我認為，這取決於「興趣」。\n不管需要多少專注力，只要有興趣，它就是娛樂；\n如果缺乏興趣，那往往就被歸類為學習。\n例如一款遊戲，如果出於興趣，那就是單純「好玩就玩」；\n但若以「學習」的心態進行，就會變成「要達成什麼目標、做到什麼程度」。\n再像是一個電影 IP，帶著興趣去看，就是放空自己、盡情享受帶來的震撼；\n但若以「學習」的心態，往往會變成分析細節、研究背景、補完世界觀。\n當然，兩者的界線並不明確，大多取決於個人主觀感受。\n放鬆：精神力的真正補給 既然凡是有目的的行為都需要專注，那麼有些所謂的「放鬆行為」其實也帶有目的。\n像是去超市補貨、去書店買書、甚至「去公園放鬆」。\n一旦帶上目的，我覺得這就不是真正的放鬆，因為大腦沒有真正放空，精神力也不會被恢復。\n某些放鬆方式，可以理解成「用少量體力的消耗，換來精神力的補充」。\n如果體力也不支，那還是單純躺下休息最好。\n或許，真正的休息並不是找一件輕鬆的事去做，而是允許自己什麼都不做。\n總結 學習讓人進步，娛樂讓人興奮，而真正的放鬆，才能讓人恢復。\n生活不該只有追逐與刺激。\n也許我們真正需要的，不是更多的娛樂，而是學會停下來。\n","date":"2025-08-22T22:17:38+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/253/","title":"放鬆不是娛樂：一場精神力的再定義"},{"content":" 📢 本文由 ChatGPT 翻譯 引言：飄零的學習感 為了讓自己的英文程度能稍微提升，我在一些不太重要的地方會盡量使用英文，例如遊戲或日常的應用軟體。可是每次使用時，總會有一種沒有真正掌握到什麼的感覺，彷彿整段經歷都是飄浮不定的，甚至好像自己根本沒經歷過。\n仔細想想，這或許是從「翻譯」到「融入」之間的落差。當母語中文介入時，這段經歷會被牢牢地繫在我的語言與思維裡；但在完全非母語的環境下，這段經歷卻無法與母語產生連結。而我平常又是依靠母語思考，自然就忽視了非母語的思考過程。\n類比：控制的執行感 就我實際的體驗來說，在完全英文的遊戲環境裡，我常常覺得自己什麼都不懂，就算是最簡單的單字也一樣。但如果是和朋友一起連線遊玩，並用中文溝通，感覺又完全不同。那種狀態像是重新切回翻譯模式，讓我瞬間輕鬆了許多，從一片慌亂中轉為多少有點掌握感。\n這也讓我聯想到在東京的生活。即使用日文對話，心裡卻常常沒有什麼實感，總覺得自己像是在執行預先設定好的指令，而不是在「活著」。也因此，我甚至喜歡上聽中文歌，因為只有那樣，在街頭閒逛時才會覺得自己還真實地存在。\n矛盾：理論最優與現實退縮 不過話說回來，這樣的狀態不就是語言學習所推崇的「完全脫離母語思考」的理想環境嗎？當我全身心沉浸在英文遊戲裡，沒有任何中文干擾，理論上應該是最好的學習方式吧？畢竟，這幾乎就等於所謂的 Thinking in English。\n然而，實際感受卻完全相反。當遇到一個不認識的單字時，我立刻會覺得自己什麼都做不了、什麼都不會。這種感覺會自然地引發退縮，讓我乾脆什麼都不做。結果是，我覺得自己的英文程度完全沒有進步，甚至反而更加沒有自信。\n反思：完美奇點的幻覺 回顧我的學習歷程，我突然意識到，自己好像一直沒有真正「學習」過。更多時候，我只是在依靠直覺與經驗判斷。在遊戲或日常生活中，能取得的資訊並不只有語言，還有動作、提示、環境等線索。也許我只是靠這些訊號來決定下一步該做什麼，於是給了自己「聽懂了」的錯覺，但語言本身卻成了被忽略的部分，所以說到底並沒有真正學到語言。\n那麼，我以前的學習方式（不只語言）又是如何呢？似乎總是要等到一個「完美的時機」再投入。除非一切條件都很「完美」，否則我就會主觀認為這樣的努力毫無意義。這大概就像是那句話——「收藏從未停止，學習從未開始。」\n這種心態不只體現在感受上，也表現在對環境與教材的要求。幾乎就像「廣度優先演算法」，在每一個階段都想要達到某種「最優」才肯繼續。否則就會覺得完全沒有意義，就算勉強自己去做，結果也只是無果。\n生活：理性與感性的錯位 這又讓我想起生活方式。對於某些不順心的事情（不管是事件還是物品），短期與長期往往呈現出完全不同的心態。短期內它會擾亂心情，但從長期來看，好像根本不那麼重要。\n就像有些物品，長遠看或許會有用，但眼下完全用不上。只是因為「未來可能需要」就讓自己一直處在不舒服的狀態，最後的結果卻是根本沒派上用場。\n整理東西也是同樣的情況。理性上覺得整理會更好，感性上卻提不起勁，或者總想等到一個「完美的時機」再整理。於是，在這個「完美時機」到來之前，每次想到這件事都會覺得煩躁。\n結論：貌似沒有「正解」 那麼，有沒有一個答案能讓學習或生活變得高效呢？\n我想……大概是沒有的吧。生活中充滿了理性決策與感性決策。也許我打算在某段時間內提升某項能力，但由於未來不可預測，加上情緒狀態不同，每一次執行計畫時的結果，都可能超出或低於預期。\n不過，這並不代表毫無技巧可循。既然新的資訊可能隨時推翻原本的計畫，那麼也許可以嘗試換個角度來約束自己：放棄某個面向，卻在另一個面向補足。比如固定時間，讓學習量浮動；或者設定最少的學習量，再讓時間浮動。\n引申：目的性與新鮮感 說到這裡，我忽然又有個想法。只要一件事情帶有「目的性」，在感性上就會變得難以持續。就算是娛樂，像玩遊戲也是。當我帶著「為了釋放壓力」的目的去玩時，腦子裡反而一直在想：「我有沒有真的放鬆下來？」這種意識本身就成了一種壓力。結果不但沒有舒壓，反而越玩越累，甚至出現類似「電子陽痿」的感覺。\n所以有人提出「多培養一些興趣比較好」。這的確是個不錯的方法。因為在不同情境下，可以選擇不同的釋壓方式（以興趣為前提），就能避免過度依賴單一手段。\n不過，或許本質其實更簡單：就是因為「新鮮感」吧。新事物會帶來新鮮的能量。\n結語：「不可控」的未來 那麼，這篇文章到底寫了什麼呢？老實說，我也不確定。也許只是我混亂思緒下的產物罷了。\n但或許，這才是真正的答案——接受生活的「不可控」。我總妄想用理性架構一切，但似乎……任何理性都無法解釋全部。\n就像「狀態—行為理論」所說，只有在掌握所有變數的情況下，才能百分之百預測結果。但我們怎麼可能獲得生活中的「所有變數」呢？\n也許，無法完全掌握變數，本身就是生活的一個變數吧。\n","date":"2025-08-18T18:27:12+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/252/","title":"漂浮的學習，錯位的人生"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 引言 前幾天 (2025-08-13) 我做了一個夢，夢裡一個系列的第二部電影《幻夢》的署名是我，雖然不知道是身為導演還是編劇，這部電影的名字也只是從類似這個系列的製片廠的兩句短語選出來的，第一部也是，但兩部電影卻毫無關聯\n電影的內容在夢裡我只看到了從中間開始，畫面中出現雙星糾纏、三星糾纏、第二宇宙，然後有一個類似奇點的東西，觸發宇宙大爆炸，宇宙重啟，生命誕生，小草破土而出，之後我就醒了\n雖然夢中這部電影說是與《三體》有關，但是就從我看到的片段來看，感覺貌似沒什麼關聯，夢中我去試映場地幾乎可以被認出，宣傳也是直接打著《三體》的名號，不過我覺得不是太重要，這點就略過吧\n分析 我反覆思索這個夢的內容，首先雙星／三星糾纏本身就是一種不穩定的結構，代表了矛盾與不穩定，奇點與宇宙大爆炸，代表了矛盾達到不可調解的地步，就進而引發衝突爆發，之後的生命出現與小草破土而出，代表了新生\n所以其實從這一段來看，是一種不穩定的狀態，或者不穩定的糾纏，因為能量無法承受，轉而在奇點爆發，迎接新生\n思考 首先這部電影的署名是我，但是我卻不知道電影的內容，而夢中看電影的時候感覺我又像主演，我倒是覺得這有點像是在講述著我的人生，或者我經歷的某件事情，因為各種東西錯綜交織，很不穩定，由我推動爆發，迎接毀滅與新生\n其中在三星糾纏的地方，不知道是觀眾還是彈幕說是「最難的一幀」可能是指在這個事件中其實已經很不穩定，但是我卻還是要主動觸發，指這是一個很難的決定\n新生 我本以為這是一種希望，指我人生中可能有一件走到一半的事情迎來了轉機，但後來又思考了一下，感覺當下人生貌似沒什麼轉機的事情\n經過我多角度思考，想到試著從電影名稱《幻夢》入手，貌似想表示我最近的經歷是一次「幻夢」，應該是我主動戳破，從而迎接新生\n抑或是我可能，也必然會把矛盾激化，迎來一次爆發式的毀滅，但是結局或許是完成了自己的蛻變\n感悟 我替自己建構了一個理性的決策系統，覺得自己人生貌似是在做一些預演的選擇而已，那段時間我彷彿不是在生活，而是在機械地選擇可能怎麼做會更好\n隨著選擇的增多，因為我一直都是從一個廣泛的可能性來看待，雖然可能看起來不錯，但是正如我之前想的那樣，我的人生沒有了自己的感覺，也就和《幻夢》一樣，導演是我，主角是我，但是我不知道劇情，只是在看著那部電影，看著我的人生\n隨著我開始考慮自己的感受後，開始試著增加自己的喜好優先級，雖然剛開始是很不錯的，但是之後慢慢沉淪於自己的感受裡面後，漸漸喪失了廣泛的理性判斷，這就是《幻夢》吧，完全沉淪在自己的感性裡，雖然可能比較美好，終究只是一場夢\n於是我在缺失了理性，這種不穩定的背景下，尋找奇點主動結束這一切，來讓我自己完成心理蛻變，開啟新生\n反思 我覺得這其實是我在經歷幾乎全理性與全感性的生活後，心靈的蛻變，意識到了極端的思考不可取，生活本就錯綜複雜，無法以任何一種事物單獨判斷\n過於理性會導致缺乏細枝末節的感受，而過於感性會使得生活變得較為混亂，這個平衡可能不好掌握，不過人生何嘗不是一場「幻夢」呢，自己身為導演，自己身為主角，但是不知道後續\n附言 這篇文章本身也很混亂，這不就正好說明我正是在混亂中分析、尋找奇點嗎？而這次奇點，就是把它寫出來、發布出來。於是我的部落格也藉此打破斷更，迎接新生 😂\n","date":"2025-08-17T01:13:32+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/251/","title":"幻夢"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 音有所感系列 歌曲名稱 翻譯 連結 僕が死のうと思ったのは 曾經我也想過一了百了 https://blog.yexca.net/zh-tw/archives/214 あくあ色ぱれっと aqua 的調色盤 https://blog.yexca.net/zh-tw/archives/219 恋の押し売り 戀愛推銷 https://blog.yexca.net/zh-tw/archives/220 17さいのうた 17 歲的歌 https://blog.yexca.net/zh-tw/archives/224 drop 墜入愛河 https://blog.yexca.net/zh-tw/archives/230 生きるを選んだ私へ 致選擇活下去的自己 https://blog.yexca.net/zh-tw/archives/239 rainy lady 雨意未晴 https://blog.yexca.net/zh-tw/archives/249 恋しくなったら手を叩こう 想談戀愛的話就拍拍手吧 本文 pris-magic! 稜鏡魔法! https://blog.yexca.net/zh-tw/archives/260 引言 聲音和歌曲的感覺好搭，簡直是絕配了，特別是「せーのっ」開始後，空靈又青春的感覺湧現，是很清新香甜的歌曲風格。\n因為是新歌 (2025.06.04 發行)，我在當天收到推播，聽完其實就想著要翻譯了，也就開始陷入單曲循環，經過短暫的努力，感覺稍微有點小清新的味道了吧，盡量按照我覺得不錯的對齊短句來翻譯。\n當然也因為是新歌，說實話在這個「對音樂有所感」系列下也沒什麼感覺，不像其他比較久的歌所產生的共鳴那麼多，這首歌就像是 Honey Lemon Soda 一樣，日常的一點甜就夠了。\n歌曲影片 歌詞 ある時の日常が\n日常的某個時刻啊\n寂しくなっちゃって\n會變得有點寂寞呢\n朝が怖くなって\n漸漸害怕早晨到來\n今眠れないのかい\n是現在還睡不著吧\n大人になったらさ\n以為長大以後呢\n治ると思ってた\n應該就能治好吧\n自己肯定感が\n每天都在一點點\n溶けてく毎日かい\n失去自我肯定感\n耳に張り付いた君の涙声\n耳邊環繞著你的哭聲\nこんなにつらいから\n會有這麼痛苦嗎\nこの夜だけは2人で歌いましょう\n就今晚兩個人一起歌唱吧\n甘いお砂糖に溶けるように\n像砂糖般甜甜地融化著\n回る空気にほら舞うように\n在旋轉的空氣中輕輕舞動著\n君と踊る 君と踊る\n與你共舞，翩翩起舞\nウォーアイニー\n我愛你\n最後までさ\n一直到最後\n浮かず空色付くまでに\n在天空開始浮現藍色前\nその言葉が灰になる前に\n在那些語言化為灰燼前\n君と歌う\n和你歌唱\nそれもそれでいいな\n那樣也不錯呢\nせーのっ\n預備～\n恋しくなったら手を叩こう\n想談戀愛的話就拍拍手\n明日の前笑顔で手を叩こう\n明天來臨前笑著拍拍手\n幸せの意味も知らんけど\n雖然也不知幸福的含義\n今日だけは笑顔で叩こう\n只此刻就笑著拍拍手\n少しだけ深呼吸して\n稍微深呼吸一下\n君はまだ君で居られる\n你依然可以做你自己\n生きてゆく意味も知らんけど\n雖然我也不知道活著的意義\n恋しくなったら手を叩こう\n但想談戀愛了就拍拍手吧\nココロの空調が\n心靈的空調啊\n整えらんなくて\n還沒調整好呢\n頬を伝う音に\n劃過臉頰的聲音\nふと戸惑っちゃったのかい\n一下子就迷茫了吧\nなんにも知らないよ\n我什麼也不知道喔\nこの世の定理とか\n這個世界的道理什麼的\n誰か偉い人が\n要是有哪位厲害的人\n教えてくれたらね\n告訴我的話就好了呢\n震えるつま先\n顫抖的腳尖\n明日の前でさ\n在明天到來前\nなんとか踏ん張って\n還是咬牙撐著吧\nこのまま夜を2人で歌いましょう\n就這樣夜裡兩個人一起歌唱吧\n甘いお砂糖に溶けるように\n像砂糖般甜甜地融化著\n回る空気にほら舞うように\n在旋轉的空氣中輕輕舞動著\n君と踊る 君と踊る\n與你共舞，翩翩起舞\nウォーアイニー\n我愛你\n最後までさ\n一直到最後\n浮かぶ空色付くまでに\n在天空開始浮現藍色前\nその言葉が灰になる前に\n在那些語言化為灰燼前\n君と歌う\n和你歌唱\nそれもそれでいいな\n那樣也不錯呢\nせーのっ\n預備～\n恋しくなったら手を叩こう\n想談戀愛的話就拍拍手\n明日の前笑顔で叩こう\n明天來臨前笑著拍拍手\n幸せの意味も知らんけど\n雖然也不知幸福的含義\n今日だけは笑顔で叩こう\n只此刻就笑著拍拍手\n少しだけ深呼吸して\n稍微深呼吸一下\n君はまだ君で居られる\n你依然可以做你自己\n生きてゆく意味も知らんけど\n雖然我也不知道活著的意義\n恋しくなったら手を叩こう\n但想談戀愛了就拍拍手吧\n","date":"2025-06-07T01:09:19+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/250/","title":"音有所感 - 《想談戀愛就拍拍手吧》"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 考慮到此系列文章貌似並不會對他人「日語學習」提供任何幫助，又是可以被檢索到的文章，特更改系列名稱以符合文章系列現狀\n怎麼說呢，也就是多數是我個人的音樂感想吧，歌詞翻譯也按照我自己理解 (自己聽到時的感受) 不一定與原文相符\n音有所感系列 歌曲名稱 翻譯 連結 僕が死のうと思ったのは 曾經我也想過一了百了 https://blog.yexca.net/zh-tw/archives/214 あくあ色ぱれっと aqua 的調色盤 https://blog.yexca.net/zh-tw/archives/219 恋の押し売り 戀愛推銷 https://blog.yexca.net/zh-tw/archives/220 17さいのうた 17 歲的歌 https://blog.yexca.net/zh-tw/archives/224 drop 墜入愛河 https://blog.yexca.net/zh-tw/archives/230 生きるを選んだ私へ 致選擇活下去的自己 https://blog.yexca.net/zh-tw/archives/239 rainy lady 雨意未晴 本文 恋しくなったら手を叩こう 想談戀愛的話就拍拍手吧 https://blog.yexca.net/zh-tw/archives/250 pris-magic! 稜鏡魔法! https://blog.yexca.net/zh-tw/archives/260 引言 這首歌的感受……怎麼說呢，其實遇到它的來歷，已經在之前那篇文章也寫過了： https://blog.yexca.net/zh-tw/archives/243/ 。當時第一次聽到這首歌的時候，特別是開頭那一段，就有種和我當時心境完全重合的感覺\n當然，我指的是開頭那幾句。後面的部分，以我當時的日語水平其實聽不太明白 (說實話翻譯也不是很明白)，整體給人的感覺就是一種無力感，也可能是那種「自己好渺小」的感受吧，像是這個世界上厲害的人太多了，都閃閃發光，真是既羨慕又覺得自己有點可悲\n或許是因為我平時很喜歡聽電音（沒有人聲的音樂）吧，所以現在聽歌時更多是靠主觀賦予感情。當我在現實中看到可愛的女孩子，或者遇到很厲害的人時，經常就會想起這首歌的開頭。那是一種夾雜著欣賞、憧憬，又有些對自己無力感到惋惜的複雜情緒\n後來仔細看了歌詞，怎麼說呢，拋開「戀愛」的元素，其實也能讀出一種對未來的迷茫感。雖然不能完全撇開吧，我也不知道這段在寫什麼了，就是一種「想做喜歡的事，卻又不敢開口」的心情……也許不只是戀愛中的事情吧\n2025.05.26 唱了這首歌，除了開頭，後面都跟不上，也不熟悉調子，圖個樂趣吧，以後聽聽就好\n不過看到《肅聖！！蘿莉神安魂曲☆》有原影片好奇唱了下，還真別說，唱起來還挺爽 doge\n歌曲影片 歌詞 は～ぁ可愛いいなぁ\n啊～啊，真可愛呢\nめっちゃキラキラしててすごいなぁ\n非常閃耀真厲害呢\n素直でいいなぁ\n這麼坦率真迷人啊\n人気者ってホントすごいなぁ\n那麼受歡迎真的很棒呢\n面白くっていいなぁ\n這麼有趣真好呢\n友達沢山いるしすごいなぁ\n朋友那麼多，真讓人羨慕啊\n勝手に目が追っちゃうなぁ\n總是吸引著我的目光呢\n君色に染まちゃってるみたいな\n彷彿要染上你的顏色了呢\nちょうどいい距離にいるのかな\n我和你之間的距離剛剛好嗎？\n居心地が良すぎて眠たいわ\n太舒適了想要睡覺呢\n散々してたシミュレーション\n反覆在腦海裡模擬過\nリハーサル通りいかないものね\n還是不能和預期一樣呢\nいつも曖昧なままのふたりの温度\n總是模糊不清的兩人之間的溫度\n答えなんて何も聞きたくないわ\n答案什麼的我一點也不想知道\nどうかしてるかな\n我是不是哪裡不對勁了呢\n今日も rainy lady\n今天也是雨季少女\nまだ まだ まだ まだ 雨模様みたい\n還在下\u0026hellip;還在下\u0026hellip;就像心情依舊陰雨綿綿\n切ない距離と 気まずいシチュエーション\n令人心痛的距離和微妙的情境\n期待なんてほんの1ミリくらい\n期望值大約只有一公釐吧\nあぁついてないなぁ 大きな雨粒\n啊～ 真倒楣呢，落下了大雨滴\nあぁ流れていく\n啊～ 流走吧\nあっ 突然バッタリ会ったり\n啊？偶然又撞見了你\n腦内 君ばっかりだったり\n腦海裡只有你了\n笑ったり怒ったり泣いちゃったりも\n笑呀、生氣呀、哭也有\nちゃっかりしちゃったり?\n偷偷得逞了？\n本来ドンマイ sorry もー無理\n原本是「別在意啦」，現在連道歉都無力了\nしっかりもうコリゴリ\n真的已經受夠了\n一回グッバイさっぱり\n乾脆說聲再見，說不定會好點\nバイバイした方がいいのかな\n還是掰掰的話比較好吧\nどんな言葉が どんな魔法なら\n要用什麼樣的語言，什麼樣的魔法\nどんな恋なら君にまで届くかな\n什麼樣的戀愛才會傳達到你那呢\nヒトリゴトが捗る雨フリの日々に\n一個人自言自語的下雨日子裡\n明るい話題もまるでウワノソラ\n就連開心的話題也聽得心不在焉\nどうかしてるよね\n我是不是哪裡不對勁了呢\nいつも rainy lady\n總是雨季女士\nてるてるぼうずも悲しそうにしてる\n就連晴天娃娃也看起來很傷心\n途切れ途切れに降り続く雨から\n斷斷續續的降雨\n想定外の贈り物なんて\n意想不到的禮物什麼的\nそっと傘の中 また降り出した\n悄悄地，在傘下，又開始下雨了\nAh\n啊\n空の合間に見えた淡い晴れ模様\n在雲隙之間，隱約看到轉晴的天空\n答えてほしいけど聞きたくなくて\n雖然想聽到答案，卻又不敢問出口\nなんて意気地なし\n之類的好沒出息\nいつだろう sunny day\n什麼時候會來呢？晴天\n悲しいくらい天気雨\n很傷心似的太陽雨\nそっと集めつづけた沢山の思いが\n悄悄積攢下來的滿滿思念呀\n無意識に淡々と溢れてきちゃう\n沒意識到已經慢慢溢出來了\n何でもないよ 君がいるなら\n只要你在，其他的都無所謂唷\n雨女でいいや\n雨女也可以啦\n君がいるから oh\n只要你在的話 oh~\nOh, sunny boy\n哦~ 晴天男孩\nRainy lady\n雨天少女\n","date":"2025-05-20T23:44:07+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/249/","title":"音有所感 - 《rainy lady》"},{"content":" 📢 本文由 ChatGPT 翻譯。并且，該軟件只有簡體字 原本只是想隨便寫個小工具，打算用兩天就放著（以前大多都是這樣），沒想到在沒出錯的情況下幫我省下不少時間，越用越順手。\n慢慢地也喚起我以前那個「為什麼不用 SQLite 呢」的想法。確實，每次開 MySQL 真的太麻煩了，於是就誕生了這個版本，終於不用每次都啟動資料庫服務了 （也終於變得比較像給人用的了）\n使用方法 專案位址： https://github.com/yexca/PixivDownloader-SQLite GUI 跟前一代差不多，可以參考 https://blog.yexca.net/zh-tw/archives/211/ 設定說明 使用前需要先設定以下項目：\nrefresh token（Pixiv 登入驗證，參考： Pixiv OAuth Flow ） 下載路徑（預設 D:\\Downloads） 下載說明 使用時只需輸入：\n畫師 ID，或是 作品 ID（若兩者皆輸入，將以畫師 ID 為主） 點擊下載即可下載所有作品並記錄到資料庫（若該畫師尚無記錄則下載所有作品，已有記錄則只下載未下載的部分）\n錯誤處理 目前僅對爬取錯誤進行處理。若出現錯誤提示，有可能是以下原因：\n未設定 refresh token 或 token 已失效 畫師帳號不存在 作品不存在 我沒有加上詳細錯誤說明，如出錯請先檢查以上三點。\n至於其他錯誤（例如軟體直接閃退），可以將 程式根目錄/logs/app_*-*-*.log 中最新的 log 檔寄給我，並說明情況。\n聯絡方式：PixivDownloader#yexca.net（請將 # 換成 @）\n新特性：從 MySQL 改為 SQLite 這次最大變動就是不再需要自建 MySQL，改用輕量化的 SQLite。\n因此也移除了原本不必要的資料庫設定，將設定與 Pixiv 的驗證 Token 整合在一起。\n加了個 icon（隨便請 ChatGPT 畫的），UI 稍作調整，變動不大。\n程式碼初步進行架構化處理……雖然寫到最後又有點亂了就是了 不過說不定哪天我又回來重構一次啦。\n舊版 MySQL 資料庫的遷移方法 雖然我覺得應該沒人用上一版，但還是說一下：由於資料結構不同，最推薦的方式是查詢導出並轉為 INSERT 語法，例如：\n1 2 3 SELECT ID, name, downloadedDate, lastDownloadID, url FROM pic WHERE platform = \u0026#39;pixiv\u0026#39;; 將結果導出為 SQL 語法（我使用的是 Dataflare，它支援這個功能）。\n然後建立一個 Python 檔案，寫入以下內容：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 import sqlite3 conn = sqlite3.connect(\u0026#34;pixiv.db\u0026#34;) cursor = conn.cursor() cursor.execute(\u0026#39;\u0026#39;\u0026#39; Create Table If Not Exists pic ( ID TEXT PRIMARY KEY, name TEXT, downloadedDate TEXT, lastDownloadID TEXT, url TEXT ) \u0026#39;\u0026#39;\u0026#39;) conn.commit() cursor.execute(\u0026#34;\u0026#34;\u0026#34; INSERT INTO `pic` (`ID`, `name`, `downloadedDate`, `lastDownloadID`, `url`) VALUES (\u0026#39;123\u0026#39;, \u0026#39;name1\u0026#39;, \u0026#39;2024-06-08 00:00:00\u0026#39;, \u0026#39;1234\u0026#39;, \u0026#39;https://www.pixiv.net/users/123\u0026#39;), (\u0026#39;234\u0026#39;, \u0026#39;name2\u0026#39;, \u0026#39;2025-02-12 00:05:36\u0026#39;, \u0026#39;2345\u0026#39;, \u0026#39;https://www.pixiv.net/users/234\u0026#39;), (\u0026#39;345\u0026#39;, \u0026#39;name3\u0026#39;, \u0026#39;2025-01-11 17:26:17\u0026#39;, \u0026#39;3456\u0026#39;, \u0026#39;https://www.pixiv.net/users/345\u0026#39;); \u0026#34;\u0026#34;\u0026#34; ) conn.commit() cursor.execute(\u0026#34;\u0026#34;\u0026#34; Select * from pic \u0026#34;\u0026#34;\u0026#34; ) rows = cursor.fetchall() for row in rows: print(row) conn.close() 其中 cursor.execute 的內容請自行替換為你的備份資料。我這裡提供三筆示範資料。\n最後，將產生的資料庫檔案 pixiv.db 放到 程式根目錄/resources 即可。\n一點開發感想：從「亂寫」到「理解混亂」 老實說這次重構是因為上次寫得太亂，覺得非整頓不可，結果改著改著我終於明白為什麼上次會那麼亂了 😂\n不如說，這次的結構也沒好到哪去，寫到一半直接放棄重構，乾脆複製貼上，導致現在有駝峰式命名也有底線命名，真是懶得再改，唉。\n總之算是一個能正常運作的半成品，能用就好了啦～\n","date":"2025-05-18T16:20:33+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/248/","title":"Pixiv 下載器重構記：從亂寫到理解混亂"},{"content":" 📢 本文由 ChatGPT 翻譯 引言 最近在思考自己要繼續做什麼或學些什麼的時候，老是看到「DevOps」這個詞。一開始隨手查了一下，發現裡面提到的技術棧自己差不多都有碰過，還以為這只是像「全端」那樣多掌握幾個工具就好（雖然其實也差不多啦）\n但因為當時沒什麼興趣就耽擱了（其實是沒開發熱情了）\n直到最近躺了快四個月，覺得該掙扎一下，結果又想到這個詞。再深入了解後，只能說\u0026hellip;\u0026hellip;這根本是「捲」到極致了吧，前後端分離就算了，現在是連開發和運維分離都不分人了。\n不過話說回來，當我看到自動流程有 GitHub Action 的時候，就讓我想起以前用 Jekyll 建部落格時也能自動部署。但因為我那時候從其他部落格系統轉過來，習慣用子資料夾分類，而那套部署方式不支援子資料夾，所以我也沒深入研究。既然這次想好好整一整，就來看看現在的 Hugo 部落格能不能自動部署吧 畢竟每次都從容器下回來再上傳真的蠻麻煩的\n工作流程 建立一個 Workflow 的方式是，在 Git 倉庫根目錄的 .github/workflows/ 中建立一個 yaml 檔案，檔名隨意。我這次是部署用途，就命名為 deploy.yml\n整個檔案結構主要分為：名稱、觸發器與工作內容\n名稱 這個就隨意取名即可\n1 name: Build and Deploy Hugo Blog 觸發器 GitHub Action Workflow 支援多種觸發方式，我這裡設成每次 push 都觸發，畢竟通常都是更新文章然後進行構建\n另外加上手動觸發功能，以備有時候 GitHub 出錯需要手動啟動 Workflow\n1 2 3 4 5 on: push: # 當 Git Push 時觸發 branches: - main # 監聽主分支 workflow_dispatch: # 手動觸發 工作內容 我這邊只有一個工作（job），但其實 jobs 可設定多個並行執行。\n先命名這個工作\n1 2 jobs: build-deploy: 接著定義執行的作業環境，我這裡選用 ubuntu：\n1 2 3 jobs: build-deploy: runs-on: ubuntu-latest 接下來定義各步驟，第一步：檢出原始碼\n1 2 3 4 5 6 7 jobs: build-deploy: runs-on: ubuntu-latest steps: - name: Checkout source uses: actions/checkout@v4 安裝 Hugo：\n1 2 3 4 5 6 steps: - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#39;0.140.1\u0026#39; # 这里是我本地的版本，兼容性应该高点 extended: true # 因为我的主题使用了 SCSS 所以必须使用 extended 版本 執行建構指令：\n1 2 3 steps: - name: Build Hugo Site run: hugo --minify 將建構後的內容部署到另一個 GitHub Pages 倉庫：\n1 2 3 4 5 6 7 8 steps: - name: Deploy to BlogWeb repo uses: peaceiris/actions-gh-pages@v3 with: external_repository: yexca/Blog-Web-Hugo publish_branch: main # 推送到目标仓库 yexca/Blog-Web-Hugo 的 main 分支 publish_dir: ./public # 推送的当前仓库的文件夹，Hugo 默认是生成到这个文件夹 personal_token: ${{ secrets.PERSONAL_TOKEN }} 完整合併如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 name: Build and Deploy Hugo Blog on: push: branches: - main workflow_dispatch: jobs: build-deploy: runs-on: ubuntu-latest steps: - name: Checkout source uses: actions/checkout@v4 - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#39;0.140.1\u0026#39; extended: true - name: Build Hugo site run: hugo --minify - name: Deploy to blogWeb repo uses: peaceiris/actions-gh-pages@v3 with: external_repository: yexca/Blog-Web-Hugo publish_branch: main publish_dir: ./public personal_token: ${{ secrets.PERSONAL_TOKEN }} 設定 Token 由於存取其他倉庫需要權限，因此需先產生 Token。\n在 GitHub 的 Settings -\u0026gt; Developer Settings -\u0026gt; Personal access tokens -\u0026gt; Fine-grained tokens 中，產生一組擁有目標倉庫讀寫權限的 Token。\n然後回到原始碼倉庫（例如 yexca/Blog-Source-Hugo），進入 Settings -\u0026gt; Secrets and variables -\u0026gt; Actions -\u0026gt; Repository secrets，新增剛才建立的 Token，名稱需對應 PERSONAL_TOKEN。\n處理自訂網域 若你為 GitHub Pages 設定了自訂網域，需建立一個 CNAME 檔，內容為你的網域。\n但 GitHub Action 的部署會清空再覆蓋內容，因此 CNAME 也會被刪除，所以要在部署前手動加上，可採以下兩種方式：\n方法一：工作流中建立檔案 1 2 3 steps: - name: Add CNAME run: echo \u0026#39;blog.yexca.net\u0026#39; \u0026gt; public/CNAME 方法二：在 Hugo 的 static 資料夾放置 CNAME 因為 static 資料夾會被原樣複製到輸出目錄，也能達成目的。\n主題子模組處理 我原本的主題是以 Git Submodule 引入的，但因為我做了不少修改，若不處理這部分，推送上去的將會是原始 repo 的內容，而非我修改過的版本。\n備份主題 1 cp -r themes/Hugo-Theme-Stack tmp/Hugo-Theme-Stack-Backup 移除子模組 1 2 3 4 git submodule deinit -f themes/Hugo-Theme-Stack git rm -f themes/Hugo-Theme-Stack rm -rf .git/modules/themes/Hugo-Theme-Stack rm .gitmodules 恢復主題 1 2 cp -r tmp/Hugo-Theme-Stack-Backup themes/Hugo-Theme-Stack rm -rf tmp 修復 JS 語法錯誤 我以前為部落格添加了網站執行時間顯示，但當時用了舊的八進位語法：\n1 Date.UTC(2021, 10, 06, 14, 15, 19) 而 Hugo 的 --minify 壓縮指令會對其報錯，改成以下即可：\n1 Date.UTC(2021, 10, 6, 14, 15, 19) 結語 終於不再需要手動編譯了。自從我開始使用 Docker，就習慣將開發環境與本機系統隔離，這樣換電腦或搬服務器只需搬容器即可，也養成了環境潔癖。\n現在好了，連建構與部署也搬到雲端去了，以前是隔離到容器，現在是隔離到 GitHub，算是徹底根治了這毛病。\n不過再回頭看看 DevOps，我倒覺得這其實也是當代技術演進過快導致的產物。\n從早年的機器碼、組合語言，到高階語言，再到容器化部署，一次次技術的「門檻下降」實際上也在偷偷「拉高起跑線」。\n雖然讓程式開發越來越便利，但也使這行的入門門檻不知不覺變高，讓像我這樣的人加速被淘汰啦。\n不過話說回來，工作是工作，生活是生活。技術變快歸變快，世界的節奏、行業的變遷應該還沒快到讓人沒喘息的空間。還是會有留一口氣的餘地吧。\n","date":"2025-05-16T18:14:06+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/247/","title":"擁抱 DevOps：把我的部落格建構與部署丟給 GitHub 處理"},{"content":" 📢 本文由 ChatGPT 翻譯 引言 又一次的自我介紹時，我不由得又想到了我的部落格。\n過去我總是直接打開 Google 搜尋 yexca，點開第一個結果進入我的部落格。\n但自從更換網域後，無數次搜尋 yexca，我的網站卻始終消失在搜尋結果之外。\n起初我並沒有太在意，以為可能有某種懲罰機制吧。畢竟 Google 建議更換網域後最好做一年的 301 重導向，而我當時只做了半年，舊網域就到期了。\n但，已經兩年了吧，再怎麼說，也該恢復了吧？\n而且更離譜的是，搜尋前幾的反而是一些早已不再維護的網站，\n而我，每天更新、調整、折騰的這個部落格，卻彷彿被世界遺忘了一般。\n於是，我開始尋找原因 打開我的部落格，查看 \u0026lt;head\u0026gt; 區塊。\n嗯？\u0026lt;meta name='description'\u0026gt; 怎麼是網頁左邊那句標語？\n啊這，當時配置的時候只是說那句話會出現在那邊，我以為跟 Argon 主題設定一樣呢。那麼也就是說，這網站的描述根本毫無意義啊。\n不過，這句話幾乎陪伴了我整個部落格歷程，我不想輕易放棄它。\n既然如此，那就讓 JSON-LD 來承擔結構化描述的任務吧！\n於是我在主題自定義 \u0026lt;head\u0026gt; 區段加入了：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;script type=\u0026#34;application/ld+json\u0026#34;\u0026gt; { \u0026#34;@context\u0026#34;: \u0026#34;https://schema.org\u0026#34;, \u0026#34;@type\u0026#34;: \u0026#34;Blog\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;yexca\u0026#39;Blog\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;{{ .Site.BaseURL }}\u0026#34;, \u0026#34;inLanguage\u0026#34;: \u0026#34;{{ .Site.Language.Lang }}\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;{{ .Site.Params.description }}\u0026#34;, \u0026#34;author\u0026#34;: { \u0026#34;@type\u0026#34;: \u0026#34;Person\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;yexca\u0026#34; } } \u0026lt;/script\u0026gt; 嗯，同時考慮到是多語言網站，部分內容當然還是使用變數適配會比較好。\n在語言的迷宮中探索 說到多語言網站，那我換個語系搜尋會如何呢？\n於是我在 google.com.hk、google.com.tw、google.com.jp 搜尋 yexca。\n結果日文版可以搜尋到部落格，但中文版卻搜尋不到；英文內容不多，就算了。\n這就很奇怪了，說明 Google 是有把 https://blog.yexca.net 辨識為 yexca，\n那為什麼其他語言版本這麼慘捏？\n繼續排查下去，我發現可能是少了 hreflang 設定，於是我補上了：\n1 2 3 4 5 \u0026lt;link rel=\u0026#34;alternate\u0026#34; hreflang=\u0026#34;x-default\u0026#34; href=\u0026#34;https://blog.yexca.net/\u0026#34; /\u0026gt; \u0026lt;link rel=\u0026#34;alternate\u0026#34; hreflang=\u0026#34;zh-CN\u0026#34; href=\u0026#34;https://blog.yexca.net/\u0026#34; /\u0026gt; \u0026lt;link rel=\u0026#34;alternate\u0026#34; hreflang=\u0026#34;zh-TW\u0026#34; href=\u0026#34;https://blog.yexca.net/zh-tw/\u0026#34; /\u0026gt; \u0026lt;link rel=\u0026#34;alternate\u0026#34; hreflang=\u0026#34;ja\u0026#34; href=\u0026#34;https://blog.yexca.net/ja/\u0026#34; /\u0026gt; \u0026lt;link rel=\u0026#34;alternate\u0026#34; hreflang=\u0026#34;en\u0026#34; href=\u0026#34;https://blog.yexca.net/en/\u0026#34; /\u0026gt; 明確告訴搜尋引擎：不同語言的用戶可以拜訪不同語系版本，但這些都是同一網站。\n順帶一提，這段 \u0026lt;link\u0026gt; 同樣會出現在文章頁面，因為我沒有加條件判斷。雖然不是每篇文章都有多語版本，不過 Google 是可以自己理解的。\n一點點地補上遺漏 但我隨意點開一篇文章，哎呀，裡面還是 JSON-LD 的網站描述，多少有點奇怪。\n於是我加上了條件邏輯：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 {{ if .IsHome }} \u0026lt;!-- 首頁 JSON-LD --\u0026gt; \u0026lt;script type=\u0026#34;application/ld+json\u0026#34;\u0026gt; { \u0026#34;@context\u0026#34;: \u0026#34;https://schema.org\u0026#34;, \u0026#34;@type\u0026#34;: \u0026#34;Blog\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;yexca\u0026#39;Blog\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;{{ .Site.BaseURL }}\u0026#34;, \u0026#34;inLanguage\u0026#34;: \u0026#34;{{ .Site.Language.Lang }}\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;{{ .Site.Params.description }}\u0026#34;, \u0026#34;author\u0026#34;: { \u0026#34;@type\u0026#34;: \u0026#34;Person\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;yexca\u0026#34; } } \u0026lt;/script\u0026gt; {{ else if .IsPage }} \u0026lt;!-- 文章頁 JSON-LD --\u0026gt; \u0026lt;script type=\u0026#34;application/ld+json\u0026#34;\u0026gt; { \u0026#34;@context\u0026#34;: \u0026#34;https://schema.org\u0026#34;, \u0026#34;@type\u0026#34;: \u0026#34;BlogPosting\u0026#34;, \u0026#34;mainEntityOfPage\u0026#34;: { \u0026#34;@type\u0026#34;: \u0026#34;WebPage\u0026#34;, \u0026#34;@id\u0026#34;: \u0026#34;{{ .Permalink }}\u0026#34; }, \u0026#34;headline\u0026#34;: \u0026#34;{{ .Title }}\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;yexca\u0026#39;Blog\u0026#34;, \u0026#34;author\u0026#34;: { \u0026#34;@type\u0026#34;: \u0026#34;Person\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;yexca\u0026#34; }, \u0026#34;publisher\u0026#34;: { \u0026#34;@type\u0026#34;: \u0026#34;Person\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;yexca\u0026#39;Blog\u0026#34; }, \u0026#34;datePublished\u0026#34;: \u0026#34;{{ .Date.Format \u0026#34;2006-01-02\u0026#34; }}\u0026#34;, \u0026#34;dateModified\u0026#34;: \u0026#34;{{ .Lastmod.Format \u0026#34;2006-01-02\u0026#34; }}\u0026#34;, \u0026#34;inLanguage\u0026#34;: \u0026#34;{{ .Site.Language.Lang }}\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;{{ .Params.description | default .Site.Params.description }}\u0026#34; } \u0026lt;/script\u0026gt; {{ end }} 如此一來，首頁與文章就會產生不同的 JSON-LD，不僅語義更正確，也更符合 Google 結構化資料的建議。\n小小的期盼 現在，一切終於補齊了。\n雖然成效不會立刻出現，但我知道，那個訊號，已經送出去了。\n我希望，下次在介紹我的部落格時，\n可以直接打開 Google，搜尋 yexca。\n","date":"2025-04-27T17:38:16+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/246/","title":"為了能搜到自己的名字：一次小站 SEO 排查實踐"},{"content":" 📢 此頁面有使用機器翻譯喲 並不是所有刷卡的人都是羊毛黨，也不是所有設計系統的人都是工程師。有些人，刷卡像在設計，設計系統像在過生活\n1. 引子：什麼是卡粉？ 說到這，不得不提到之前看到的卡友七大愛好：\n這裡的「中國大陸」是指資金出入受限地區\n想辦法在中國大陸使用外匯 想辦法在境外使用人民幣 想辦法把人民幣匯出中國大陸 想辦法把外匯匯入中國大陸 辦一些在中國大陸幾乎沒用的卡 辦一些在國外更沒用的卡 想辦法讓那些連密碼位數都不到的資金，在一些幾乎沒什麼實際用途的卡片之間來回周轉 中國大陸的銀行密碼慣例為六位數，這裡是卡粉們自嘲「錢比密碼短，還在努力搬」的梗。其他地區可能不適用\n聽起來像是玩金融遊戲，乍看之下就是辦一堆銀行卡、追求回饋、省手續費、划算換匯……好像只是一種「不值錢的小聰明」\n但對真正的卡粉來說：\n卡粉，不是為了省幾塊錢，而是在尋找一個多通道、多節點、多限制下的資金最優路徑設計\n他們不是在薅羊毛，而是在探索這個世界的架構，在做生活系統的最佳化設計\n2. 系統架構設計到底在做什麼？ 為了考取系統架構師資格，往往需要學會很多相關術語，例如模組解耦、效能最佳化、介面規範等等。但拋開這些術語，其實系統架構師的本質任務非常明確：\n在複雜的限制條件下，合理分配資源、規劃路徑、連接各個系統，最終建構出一個既穩定又彈性的整體\n所以系統架構師考慮的不是某行程式碼寫得漂不漂亮，也不只是畫設計圖，而是整個系統能否在現實限制下順利運行。比方說：\n系統之間該如何分工？ 各個服務之間如何呼叫？ 介面要怎麼定義，才能方便未來擴充？ 出現問題時怎麼定位、怎麼隔離影響？ 在預算有限的情況下，怎麼權衡效能與成本？ 系統架構師的角色，有點像在搭積木、也像在修橋鋪路，更像在補丁系統。他們往往不是一開始就擁有完美藍圖，而是在一個混亂甚至破碎的現實中，一點一點規劃路線、加固結構、替換模組、最佳化通路\n簡單來說，就是要在現實條件下，設計出跑得穩、改得動、養得起的系統。不追求「完美設計」，只追求「跑得通」，這就是系統架構師的美學\n雖然我當初只是為了應考而接觸這些知識，但在備考過程中，卻不知不覺重新燃起了我對卡片路徑設計的熱情\n3. 卡粉世界的「架構問題」 卡粉不是無意義的「省點小錢」，系統架構師也不是在搞「高大上的工程設計」。雖然他們活動的場景完全不同，但本質上，他們都在面對同一種問題：\n在規則複雜、成本有限、目標不明的情況下，尋找最優的通路與結構\n卡粉不是單純在辦卡，而是在設計資金流動路徑；\n系統架構師也不是單純在寫程式，而是在規劃資訊流與控制流。\n卡粉常常在思考「怎麼少付手續費、不被風控、還能順利流轉」；\n而架構師則在考量「怎麼減少故障、提升擴展性、讓系統跑得穩」。\n雖然我只是為了考試而認識架構師的思維方式，但回頭一看，這不就是我在玩卡時思考的那些事情嗎？\n卡粉世界 系統架構世界 核心邏輯 手續費 延遲／效能開銷 成本管理 通道限制 API 調用限制 協議相容 卡組織規則 模組規範 合規性 境內外匯差 跨平台相容損耗 多環境適配 卡種多樣性 技術棧多樣性 多模組整合 銀行風控 系統安全策略 風險控制 多卡流轉路徑 資料流向控制 路由與架構設計 卡粉做的不是套利，而是在進行一場關於資金流動結構的設計遊戲\n他們不是在「做事」，而是在「做結構」：不只是找哪張卡回饋最高，而是設計一條路徑，讓資金在卡與卡之間以最小代價、最大效率地完成任務\n他們關注的不是「能不能跑」，而是「跑得是否優雅」；不是「能不能轉出去」，而是「這條流轉過程是否精巧、順暢」\n卡粉在找尋最優卡路徑，其實就像是在解一個「多重限制下的最短路徑問題」；而系統架構師在設計服務拓撲時，則是在權衡「模組耦合度＋SLA（服務等級協議）限制」下的最適組合\n這兩者之間，只是應用場景不同。\n4. 探索路徑的系統實踐 別人只在算哪張卡划算，我在設計一套金融流通系統\n每位卡粉的路徑都是獨一無二的，因為每個人面對的條件都不同：使用的銀行不同、帳戶幣別不同、生活地區不同、資金來源也不同\n真正的樂趣不在於抄別人的攻略，而是透過觀察、實驗、踩坑，找出最適合自己的資金架構\n我記得一開始只是想省點手續費，結果查了一堆資料，發現不同銀行之間轉帳的條件、時間、風控都不同。有些手續費低但轉帳速度慢，有些速度快但限額小，有些甚至完全無預警被退回。整個過程就像在玩一張起初全黑的地圖，一點一點探索通路、開通節點、註記跳板\n一次次的小額嘗試讓我慢慢拼湊出屬於我自己的可用資金路徑。隨著探索深入，我開始刻意繞開高手續費路徑，甚至在幣種兌換中也試圖利用波動換出一點浮盈\n有些一開始看起來「根本做不到」的事情，也在一次次嘗試與測試中漸漸被打通。像是透過虛擬貨幣交易所完成入金、在現實生活中直接使用虛擬貨幣、讓法幣自動轉換為穩定幣，或者使用專門的送金服務將資金匯往某些地區……這些方法繞過了傳統銀行體系，最終完成了原本被認為無法完成的目標\n這個過程，從「無解」到「打通」，就像是一場系統級網路架構的重建。我不是在單純轉帳，而是在重新定義一條資訊與價值的傳輸通路\n聽起來很複雜？但這不就是一個典型的系統流程設計題嗎：\n多個系統之間要如何建立連線、完成資料傳輸？ 不同格式（幣別）要怎麼轉換才能順利被識別？ 哪些節點是可靠的？哪些通路延遲低、失敗率小？ 如何將「資料包」（資金）透過合適的協定（出入金方式）送達最終節點（目標帳戶）？ 整個過程能不能讓用戶（也就是我）在體感上順暢無阻？ 說到底，這就是系統架構的感覺：你不是在堆疊功能，而是在設計一個清晰、穩定、可持續演進的結構網路\n每一張卡是一個節點；每一個匯款接口是一項協定；每一次路線的嘗試與調整，都是一次小規模的架構最佳化\n這背後說穿了就是：路徑規劃 + 接口適配 + 使用者體驗，這不就是系統架構師該做的事嗎？\n卡粉在玩的，從來不只是省錢，而是透過對現實金融網路的解構與重組，掌握系統級控制的樂趣與主導感\n5. 從卡粉中淬鍊出的架構素養 在一次次路徑選擇、失敗嘗試、成本權衡與風控試探中，卡粉其實也在鍛鍊一種架構思維。雖然沒有伺服器、沒有程式碼，但那種「為了結構穩定與效率美感而不斷打磨路徑」的過程，本質上就是一種系統設計能力的實踐\n這些實作經驗，不知不覺內化成了以下這幾類架構素養：\n能力 表現方式 核心精神 熟悉規則 銀行細則、限額通道 文件閱讀能力 整合能力 多卡串接與資金路徑整合 系統整合思維 成本意識 手續費最小化 效能／預算權衡 模型建構 規劃卡間流轉結構 架構建模能力 風控意識 多帳號、多備援設計 高可用性設計 審美追求 資金路徑也要優雅 工程美感 卡粉其實是在用現實世界，模擬訓練一個系統架構師該具備的思維模型\n6. 我的感悟 手續費是敵人，通道是信仰，路徑是藝術\n我之所以成為卡粉，不是因為熱衷刷卡，而是在一次次探索中感受到「結構之美」。也許我們沒有寫程式、沒有部署伺服器，但每一次資金的流動、每一條通路的設計，其實都蘊藏著系統性思考的影子\n從系統架構師的備考過程，到日常生活中設計自己的資金路徑，我漸漸意識到：\n我喜歡的不只是把事情做完，而是讓它的路徑設計得漂亮\n別人眼中的小聰明，是我心中的系統美學；\n別人眼中的羊毛黨，是我內心的生活架構師。\n卡粉不是單純為了省錢，更像是在現實中練習「系統設計」的能力：視覺化問題、逐步迭代、結構清晰、自我滿足\n這不是一種浪費時間，而是一種真實可觸、可日常實踐的「個人系統建構演練」\n卡粉不是在省錢，是在練手；架構不是在發明，是在選擇\n不論是在做架構設計還是在優化卡路徑，最重要的從來不是「能省多少」或「寫幾行程式」，而是那整個過程中，對系統、對結構，甚至對世界運行方式的理解與掌握\n而我，就是那個會在 ATM 前發呆 10 分鐘，只為算清哪條手續費路徑最優的生活架構師\n結語：生活就是最大的架構 我們每天刷卡、轉帳、判斷路徑、做出組合決策，其實就是在進行一場「無形的架構設計實踐」\n系統架構不只是伺服器與 API 的事，它也可能藏在我們的錢包、卡片選擇與支付策略之中\n卡粉的盡頭，也許就是一位生活中的系統架構師\n附錄：我的卡粉路徑偽代碼 這段程式碼並非真正的實作，而是我將現實中資金流轉路徑用架構思維重新建模的嘗試。它就像是一段可讀的生活流程圖，是我對每日卡片路徑操作背後邏輯的抽象化呈現\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // 我的主要跨境資金路徑設計（示意） func RouteCNYtoJPY(CNY float64) JPY float64 { HKD := BOCExchange(CNY, to=\u0026#34;HKD\u0026#34;) log.Printf(\u0026#34;Exchanged %.2f CNY to %.2f HKD\u0026#34;, CNY, HKD) Transfer(HKD, from=\u0026#34;BOC\u0026#34;, to=\u0026#34;BOCHK\u0026#34;, by=\u0026#34;pbservice\u0026#34;) log.Println(\u0026#34;Transferred via pbservice → BOCHK\u0026#34;) Transfer(HKD, from=\u0026#34;BOCHK\u0026#34;, to=\u0026#34;Wise\u0026#34;, by=\u0026#34;fpservice\u0026#34;) log.Println(\u0026#34;Transferred via fps → Wise\u0026#34;) JPY := WiseConvert(HKD, to=\u0026#34;JPY\u0026#34;) log.Printf(\u0026#34;Converted %.2f HKD to %.2f JPY via Wise\u0026#34;, HKD, JPY) Deposit(JPY, to=\u0026#34;Revolut\u0026#34;, with=\u0026#34;ApplePay\u0026#34;) return JPY } 這段偽代碼像是一座由邏輯堆疊出的通路結構，是我與系統架構師世界之間最自然而然的連接\n另註：本文僅為個人經驗與娛樂用途，並非任何財務或法律建議，請讀者自行判斷參考喔～\n","date":"2025-04-22T00:35:15+09:00","image":"https://github.com/yexca/picx-images-hosting/raw/master/2025/04-FromCardEnthusiastToArchitect/250422-TC.13lz2zi90i.webp","permalink":"https://blog.yexca.net/zh-tw/archives/245/","title":"從卡粉到架構師：生活中的系統設計哲學"},{"content":" 📢 此頁面有使用機器翻譯喲 2023 年 04 月，我開始記帳。2025 年 04 月，我停止了記帳。\n最後一筆記錄：¥0\n起點：為了省錢與掌控 起因很簡單——控制消費，提升金錢意識。剛開始的確非常有效，幫我遏制了一些不好的消費習慣。\n過程：一步步走向最優解與卡粉世界 但慢慢地，為了「更優」的消費，我開始比較、開始尋找最優解。最開始只是商品之間的比較，後來，是付款方式、支付工具，最後，進入了銀行優惠和開卡的世界。\n為了優惠而去開卡，為了便利而去開卡，但這玩意有點上頭，可以說我一步一步走向了卡粉的世界。\n一開始是為了省錢，後來是為了方便，最後——是為了集卡。\n反噬：記帳成為了負擔 於是，記帳本身，逐漸成了負擔。帳戶越來越多，場景越來越複雜，記帳的時間成本、心理成本，早已超過了實際收益。\n我常常為了可能只有幾塊錢的優惠，研究半天。剛開始當然開心，但多了之後，找到最優解不再讓我興奮，反而是一陣空虛取代了最初的喜悅。\n轉變：從最優解到舒服就好 也許是我變了，消費的心態也變了。\n從「按需按惠」，到「差不多就行，自己舒服就行」。\n我也發現，自己早就突破了原先設定的限額，卻沒有因此失控。反而越來越明白，比起省錢，時間和心情更重要。\n反思：我到底為什麼記帳？ 當我因為記帳，而開始：\n因為帳戶多而不斷翻找 因為貨幣轉換而頻繁在記帳軟體創建新帳號 因為商品該不該買而計較半天 因為和朋友出去遊玩消費而破壞心情 我不得不開始反思——我記帳，到底是為了什麼？\n這其中的收益，真的值得嗎？\n決定：放下，歸零，重新出發 於是我嘗試著放下，嘗試著不去管細節，只問自己：「我快樂嗎？」\n結果是——真的很快樂。而支出，也沒有想像中那麼高。\n或許，是習慣讓我潛移默化地比過價。或許，情緒的價值，本來就無法用優惠來衡量。\n所以，我想，是時候放手了。\n記帳，已經完成了它的使命。\n它不再是工具，而是成為了束縛。\n行為習慣是為了更好的生活，當它無法再靠熱情消解，當它反而阻礙了生活，那就該學會告別。\n尾聲：謝謝自己，繼續生活 雖然放棄了自己堅持了兩年的習慣，確實有些不捨。\n但這大概也是人生的一部分吧。沒有什麼可以陪伴一輩子，但只要在一起的那段時光是美好的，這，就足夠了。\n可以說我少了一個象徵性的「我很省」的工具。\n但，我更希望未來的自己，不再是靠數字和記錄來獲得安全感，而是靠真正的從容和自在。\n從可以掌控，到流入未知。\n希望自己能早點適應。\n希望能把省下來的時間，花在更有意義、更值得快樂的事情上。\n所以，\n最後一筆，¥0 附上一段小短文。\n謝謝這兩年認真記錄的自己。\n未來，希望把省下來的時間，花在更有意義、更快樂的事情上。\n就這樣，Archive 了這段經歷。\n記錄是結束，而生活才剛剛開始。\n","date":"2025-04-14T16:23:48+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/244/","title":"從省錢，到生活，再到告別"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 自從我在部落格上開始發布一些較為專業性的學習內容後，它慢慢變得過於枯燥乏味，甚至我打開部落格只會想到要學習東西，這種心理暗示導致我慢慢開始對寫部落格文章有了排斥感，也早早想到要寫點其他的文章但遲遲不知從何下手。正好藉著最近的經歷，嘗試寫一篇非技術文章試試看吧！\n「まだ雨はやまない」 2025-03-23 我買了第一張實體專輯，是 しぐれうい 的 「まだ雨はやまない」，像相簿一般的外觀簡直是太可愛了！\n不過說到購買經歷確實是一段較為曲折的心路歷程，因為買過太多可能只是第一眼覺得好看，但實際上並不理想的東西過多，再加上經濟限制，使得我每次購買非生活必需品的時候總是需要做抉擇，所以買一個我並不熟悉的歌手專輯無疑是一項比較冒險的決定 (畢竟確實比較貴 doge)\n我在今年 (2025) 一月的時候在實體店第一次看到這張專輯，不禁感慨真可愛，埋下了想要購買的種子，順便認識了 しぐれうい。3 月 22 日在沖繩 VRChat 上舉行的展覽中，看到了此次初音的形象設計是 しぐれうい，頓感熟悉 (順便看了 23 日的直播)。\n初音ミクのライブを見た、可愛かった！\nI watched Hatsune Miku\u0026#39;s live concert, so cute!\n也看了初音未來的直播 pic.twitter.com/r1JeMpQ9UA\n\u0026mdash; yexca (@yexcano) March 24, 2025 然後讓我想到了這張專輯，當天搜尋了一下她的歌曲，聽了幾首感覺還不錯。但當我 23 日想買，並且到了店裡後我又退縮了，實際拿到商品後，我開始了解這張專輯 (實際上我很猶豫了，因為我一般買東西都是既然要買就不會去了解，親自體驗驚喜；既然了解了就不會買)，但應該是還有想買的期望吧，只是看了一下有什麼歌，因為只有一首熟悉的，我便去旁邊漫畫店順手買了本漫畫就回去了。在去捷運的路上，習慣性地打開音樂軟體聽音樂，突然有一首歌特別好聽，我下意識地點開收藏，不過看到歌名，頓感熟悉，這就是那張專輯裡的歌曲！於是我立刻掉頭，跑回店裡把專輯買下來 (rainy lady 太好聽了！)\n擷取音樂 不過本身是沒有聽實體專輯的需求的，於是引出了寫本文的主要目的，那就是把歌曲從專輯中擷取出來，主要參考了 https://www.bilibili.com/opus/925630344961458181 原本應該和往常一樣，我寫一篇自己的經歷的，但出現了新的想寫進來的內容，就放個超連結吧。\n「アルストロメリア」 昨天 (25 日) 因為原本約好要一起玩遊戲的朋友想出去逛逛而延遲了，那我索性也出去逛逛吧。這一逛，直接讓我看到了 鹿乃 的專輯！！！\n我直接當場買下，興奮的心情溢於言表，以我淺薄的文學水平並不知道如何表達內心的愉悅，因為我對 鹿乃 太熟悉了，這裡的歌曲並不需要擷取，懷揣著激動的心情打開專輯，看到最後的笑容，內心都被完全療癒了，多麼美好的體驗。果然購買自己喜愛的事物，是一件多麼美好的事啊！\n此時此刻，只讓我想起那句：「このような幸せ、あるでしょうか」(世間還有如此美妙的事情嗎)\n結語 實際寫起來還是可以明顯感覺到自身內容的匱乏，以及表達的不足，罷了，嚴格的要求不就和寫嚴謹的技術文章一樣了嗎？偶爾放鬆一下吧，胡亂寫寫毫無頭緒的也不錯。\n","date":"2025-03-26T18:18:31+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/243/","title":"收藏我的音樂，珍藏我的心情"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 應該和之前的筆記編寫時間相差不多，因為檔案建立時間已經超過考試時間，可能某次移動檔案是創造寫吧\n作業系統的地位 電腦系統由硬體和軟體兩部分組成。通常把未配置軟體的電腦稱為裸機。直接使用裸機不僅不方便，而且將嚴重降低工作效率和機器的利用率。作業系統 (Operating System) 目的是為了填補人與機器之間的鴻溝，即建立使用者與電腦之間的介面，而為裸機配置的一種系統軟體\n作業系統在電腦系統中的地位如下圖所示\n從圖中可見，作業系統是裸機上的第一層軟體，是對硬體系統功能的首次擴充。它在電腦系統中佔據重要而特殊的地位，所有其他軟體，如編輯程式、組譯程式、編譯程式、資料庫管理系統等系統軟體，以及大量的應用軟體都是建立在作業系統基礎上的，並得到它的支援和取得它的服務\n從使用者角度看，當電腦配置了作業系統後，使用者不再直接使用電腦系統硬體，而是利用作業系統所提供的指令和服務去操縱電腦，作業系統已成為現代電腦系統中必不可少的最重要的系統軟體，因此把作業系統看作是使用者與電腦之間的介面\n行程管理 行程管理也稱為處理器管理。在多工批次處理系統和分時系統中有多個並行執行的程式，為了描述系統中程式執行時動態變化的過程引入了行程（Process）。行程是資源分配和獨立運行的基本單位。行程管理重點需要研究各行程之間的並行特性，以及行程之間相互合作與資源競爭產生的問題\n程式順序執行的特徵 前趨圖是一個有向無環圖，由節點和有向邊組成，節點代表各程式段的操作，而節點間的有向邊表示兩個程式段操作之間存在的前趨關係。程式段 Pi 和 Pj 的前趨關係表示成 Pi→Pj，其中，Pi 是 Pj 的前趨，Pj 是 Pi 的後繼，其含義是 Pi 執行結束後 Pj 才能執行\n下圖為 3 個節點的前趨圖，輸入是計算的前趨，輸入結束才能進行計算；計算是輸出的前趨，計算結束才能輸出\n程式順序執行時的主要特徵包括順序性、封閉性和可再現性\n程式並行執行的特徵 若在電腦系統中採用多工程式設計技術，則主記憶體中的多道程式可處於並行執行狀態。對於上述有 3 個程式段的作業類別，雖然每個作業有前趨關係的各程式段不能在 CPU 和輸入/輸出各部件並行執行，但是同一個作業內沒有前趨關係的程式段或不同作業的程式段可以分別在 CPU 和各輸入/輸出部件上並行執行。例如，某系統中有一個 CPU、一台輸入設備和一台輸出設備，前趨圖如下\n程式並行執行時的特徵如下\n失去了程式的封閉性 程式和機器的執行程式的活動不再一一對應 並行程序間的相互制約性 行程的狀態及其狀態間的切換 三態模型 在多工系統中，行程在處理器上交替執行，狀態也不斷地發生變化，因此行程一般有 3 種基本狀態：執行、就緒和阻塞\n執行。當一個程式在處理器上執行時，則稱該行程處於執行狀態。顯然，對於單處理器系統，處於執行狀態的行程只有一個 就緒。一個行程獲得了除處理器外的一切所需資源，一旦得到處理器即可執行，則稱此行程處於就緒狀態 阻塞。阻塞也稱等待或睡眠狀態，一個行程正在等待某一事件發生 (例如請求 I/O 等待 I/O 完成等) 而暫時停止執行，這時即使把處理器分配給行程也無法執行，故稱該行程處於阻塞狀態 行程狀態 CPU 資源 執行 √ √ 就緒 × √ 阻塞 × × 五態模型 事實上，對於一個實際的系統，行程的狀態及其轉換更複雜。例如，引入新建態和終止態構成了行程的五態模型\n行程間的通訊 在多工環境的系統中存在多個可以並行執行的行程，故行程間必然存在資源共享和相互合作的問題。行程通訊是指各個行程交換資訊的過程\n同步與互斥：同步是合作行程間的直接制約問題，互斥是申請臨界資源行程間的間接制約問題\n行程間的同步 在電腦系統中，多個行程可以並行執行，每個行程都以各自獨立的、不可預知的速度向前推進，但是需要在某些確定點上協調相互合作行程間的工作。例如，行程 A 向緩衝區送資料的操作，否則行程 B 必須停下來等待行程 A 的操作結束\n可見，所謂行程間的同步是指在系統中一些需要相互合作，協同工作的行程，這樣的相互聯繫稱為行程的同步\n行程間的互斥 行程的互斥是指系統中多個行程因爭用臨界資源而互斥執行。在多工系統環境中，各行程可以共享各類資源，但有些資源一次只能供一個行程使用，稱為臨界資源 (Critical Resource, CR)，如印表機、共享變數和表格等\n臨界區管理的原則 臨界區 (Critical Section, CS) 是行程中對臨界資源實施操作的那段程式。對互斥臨界區管理的 4 條原則如下\n有空即進。當無行程處於臨界區時，允許行程進入臨界區，並且只能在臨界區執行有限的時間 無空等待。當有一個行程在臨界區時，其他欲進入臨界區的行程必須等待，以保證行程互斥地存取臨界資源 有限等待。對於要求存取臨界資源的行程，應保證行程能在有限的時間進入臨界區，以免陷入 \u0026ldquo;飢餓\u0026rdquo; 狀態 讓權等待。當行程不能進入自己的臨界區時，應立即釋放處理器 (CPU)，以免行程陷入忙等狀態 號誌機制 荷蘭學者 Dijkstra 於 1965 年提出的號誌（Semaphore）機制是一種有效的行程同步與互斥工具。目前，號誌機制有了很大的發展，主要有整數號誌、記錄型號誌和號誌集機制\n整數號誌與 PV 操作 號誌是一個整數變數，根據控制對象的不同被賦予不同的值。號誌分為如下兩類\n公用號誌。實現行程間的互斥，初值為 1 或資源的數目 私用號誌。實現行程間的同步，初值為 0 或某個正整數 號誌 S 的物理意義：S ≥ 0 表示某資源的可用數，若 S ＜ 0 則其絕對值表示阻塞佇列中等待該資源的行程數\n對於系統中的每個行程，其工作的正確與否不僅取決於它自身的正確性，而且與它在執行中能否與其他相關行程正確地實施同步互斥有關。PV 操作是實現行程同步與互斥的常用方法。P 操作和 V 操作是低級通訊原語，在執行期間不可分割。其中 P 操作表示申請一個資源，V 操作表示釋放一個資源\nP 操作的定義 S := S - 1，若 S ≥ 0，則執行 P 操作的行程繼續執行；反之，則置該行程為阻塞狀態 (因為無可用資源)，並將其插入阻塞佇列\nP 操作可用如下過程表示，其中 Semaphore 表示所定義的變數是號誌\n1 2 3 4 5 Procedure P(Var S:Semaphore); Begain S := S - 1; If S \u0026lt; 0 then W(S) {執行P操作的行程插入等待佇列} End; V 操作定義 S := S + 1，若 S ＞ 0 則執行 V 操作的行程繼續執行；反之，則從阻塞狀態喚醒一個行程，並將其插入就緒佇列，然後執行 V 操作的行程繼續\nV 操作可用如下行程表示\n1 2 3 4 5 Procedure V(Var S:Semaphore); Begain S := S + 1; If S \u0026lt;= 0 then R(S) {從阻塞佇列中喚醒一個行程} End; 利用 PV 操作實現行程的互斥 例如以下兩個行程可能會導致 COUNT 的值改變不當\n1 2 3 4 5 6 7 8 9 # 1 if 有車通過 then COUNT := COUNT + 1; GOTO L1; # 2 PRINT COUNT; COUNT := 0; GOTO L2; 令號誌互斥 (mutex) 的初值為 1，在進入臨界區之前執行 P 操作鎖定資源，離開臨界區後執行 V 操作，程式碼如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 1 if 有車通過 then begin P(mutex) COUNT := COUNT + 1; V(mutex) end GOTO L1; # 2 begin P(mutex) PRINT COUNT; COUNT := 0; V(mutex) end GOTO L2; 建議觀看： 【作業系統】行程間通訊—互斥 利用 PV 操作實現行程的同步 行程的同步是由於行程間合作引起的相互制約的問題，要實現行程的同步可用一個號誌與訊息聯繫起來，當號誌的值為 0 時表示希望的訊息未產生，當號誌的值為非 0 時表示希望的訊息已經存在。假定用號誌 S 表示某條訊息，行程可以通過呼叫 P 操作測試訊息是否到達，呼叫 V 操作通知訊息已準備好。最典型的同步問題是單緩衝區的生產者和消費者的同步問題\n建議觀看： 【作業系統】行程間通訊—同步 同類資源分配不當引起死結 若系統中有 m 個資源被 n 個行程共享，當每個行程都要求 k 個資源，而 m ＜ nk 時，即資源數小於行程所要求的總數時，可能會引起死結 (Deadlock)\n例如，m＝5，n=3，k=3，若系統採用的分配策略是輪流地為每個行程分配，則第一輪系統先為每個行程分配一台，還剩下兩台；第二輪系統再為兩個行程各分配一台，此時，系統中已無可供分配的資源，使得各個行程都處於等待狀態導致系統發生死結\n事實上，當 m ≥ n × (k - 1) + 1 時不會發生死結\n死結的處理 死結的處理策略主要有四種：鴕鳥策略 (即不理睬策略)、預防策略、避免策略和檢測與解除死結\n死結預防 死結預防是採用某種策略限制並行行程對資源的請求，破壞死結產生的 4 個必要條件之一，使系統在任何時刻都不滿足死結的必要條件。預防死結的兩種策略如下：\n預先靜態分配法。破壞了 \u0026ldquo;不可剝奪條件\u0026rdquo;，預先分配所需資源，保證不等待資源。該方法的問題是降低了對資源的利用率，降低行程的並行程度；有時可能無法預先知道所需資源 資源有序分配法。破壞了 \u0026ldquo;環路條件\u0026rdquo;，把資源分類按順序排列，保證不形成環路。該方法存在的問題是限制行程對資源的請求；由於資源的排序佔用系統開銷 死結避免 死結避免是設法破壞產生死結的 4 個必要條件之一，嚴格防止死結的產生。死結避免則不那麼嚴格地限制產生死結的必要條件。最著名的死結避免演算法是 Dijkstra 提出的銀行家演算法，死結避免演算法需要很大的系統開銷\n建議觀看： 銀行家演算法 執行緒 傳統的行程有兩個基本屬性：可擁有資源的獨立單位；可獨立排程和分配的基本單位。引入執行緒 (Thread) 的原因是行程在建立、撤銷和切換中，系統必須為之付出較大的時空開銷，故在系統中設置的行程數目不宜過多，行程切換的頻率不宜太高，這就限制了並行程度的提高\n引入執行緒後，將傳統行程的兩個基本屬性分開，執行緒作為排程和分配的基本單位，行程作為獨立分配資源的單位。使用者可以通過建立執行緒來完成任務，以減少程式並行執行時付出的時空開銷\n這樣，對於擁有資源的基本單位，不用頻繁地切換，進一步提高了系統中各程式的並行程度。需要說明的是，執行緒是行程中的一個實體，是被系統獨立分配和排程的基本單位。執行緒基本上不擁有資源，只擁有一點執行中必不可少的資源 (如程式計數器、一組暫存器和堆疊)，它可與同屬一個行程的其他執行緒共享行程所擁有的全部資源\n","date":"2025-03-16T19:35:38+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/242/","title":"軟體設計師 - 作業系統部分筆記"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 這篇文章寫於 2024-04-29，之後有修改過一次，本來以為寫完了，但今天看居然沒寫完，可是相關的東西我早就刪掉了，唉，就這樣吧。\n直接部署 WeBASE 到 FISCO BCOS。\nDocker 部署 在 CentOS 系統下使用 Docker 安裝\n環境 首先安裝 yum-utils 以使用 yum-config-manager\n1 yum install -y yum-utils 設定來源\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 官方來源 yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo # 阿里雲 yum-config-manager \\ --add-repo \\ https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo # 清華大學 yum-config-manager \\ --add-repo \\ https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/centos/docker-ce.repo 安裝\n1 yum install docker-ce docker-ce-cli containerd.io docker-compose-plugin 設定 Docker 映像檔來源\n1 vim /etc/docker/daemon 內容如下（中國科大映像檔來源）\n1 2 3 { \u0026#34;registry-mirrors\u0026#34;: [\u0026#34;https://docker.mirrors.ustc.edu.cn\u0026#34;] } 啟動 Docker\n1 systemctl start docker 或者，如果需要修改設定檔，請重新載入設定檔，並重新啟動 Docker 服務\n1 2 systemctl daemon-reload systemctl restart docker.service 安裝 Python\n1 yum install -y python36 epel-release python36-pip 下載 docker-compose\n1 curl -L \u0026#34;https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)\u0026#34; -o /usr/local/bin/docker-compose 修改執行權限\n1 chmod +x /usr/local/bin/docker-compose 安裝 PyMySQL\n1 pip3 install PyMySQL 部署區塊鏈 拉取部署腳本\n1 wget https://osp-1257653870.cos.ap-guangzhou.myqcloud.com/WeBASE/releases/download/v1.5.5/webase-deploy.zip 解壓縮安裝包\n1 unzip webase-deploy.zip 進入目錄\n1 cd webase-deploy 修改設定檔\n1 vim common.properties 拉取映像檔\n1 python3 deploy.py pullDockerAll 拉取映像檔時會提示輸入逾時時間，輸入 30/60/120 任一數值即可。\n若拉取失敗，可手動拉取相關映像檔，例如 fiscoorg/fiscobcos:v2.9.1\n1 docker pull fiscoorg/fiscobcos:v2.9.1 部署\n1 python3 deploy.py installDockerAll 看到 deploy has completed 即表示部署成功\n常用指令\n1 2 3 4 5 6 7 8 9 10 # 一鍵部署 部署並啟動所有服務 python3 deploy.py installDockerAll 停止一鍵部署的所有服務 python3 deploy.py stopDockerAll 啟動一鍵部署的所有服務 python3 deploy.py startDockerAll # 節點的啟動與停止 啟動所有 FISCO-BCOS 節點: python3 deploy.py startNode 停止所有 FISCO-BCOS 節點: python3 deploy.py stopNode # WeBASE 服務的啟動與停止 啟動所有 WeBASE 服務: python3 deploy.py dockerStart 停止所有 WeBASE 服務: python3 deploy.py dockerStop Java 環境部署 不使用 Docker 的話需要 Java 環境，CentOS 系統需要使用 Oracle JDK，從其 官方網站下載 JDK8 後解壓縮，假設檔案名稱為 jdk-8u411-linux-x64.tar.gz\n1 tar -zxvf jdk-8u411-linux-x64.tar.gz 解壓縮後重新命名\n1 mv jdk1.8.0_411 jdk-8u411 設定環境變數，修改檔案 vim /etc/profile\n1 2 3 export JAVA_HOME=/home/yexca/software/jdk-8u411 export PATH=$JAVA_HOME/bin:$PATH export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOMR/lib/tools.jar 生效\n1 source /etc/profile 查詢\n1 java -version 資料庫 不使用 Docker 的話需要資料庫，安裝 MariaDB，首先建立 repo 檔案\n1 vim /etc/yum.repos.d/mariadb.repo 檔案內容如下，使用阿里雲映像檔來源\n1 2 3 4 5 6 7 8 9 10 11 # MariaDB 11.2 CentOS repository list - created 2024-04-30 03:16 UTC # https://mariadb.org/download/ [mariadb] name = MariaDB # rpm.mariadb.org is a dynamic mirror if your preferred mirror goes offline. See https://mariadb.org/mirrorbits/ for details. # baseurl = https://rpm.mariadb.org/11.2/centos/$releasever/$basearch baseurl = https://mirrors.aliyun.com/mariadb/yum/11.2/centos/$releasever/$basearch module_hotfixes = 1 # gpgkey = https://rpm.mariadb.org/RPM-GPG-KEY-MariaDB gpgkey = https://mirrors.aliyun.com/mariadb/yum/RPM-GPG-KEY-MariaDB gpgcheck = 1 清除快取\n1 2 yum clean all yum makecache all 安裝\n1 yum install -y MariaDB-server MariaDB-client 啟動服務\n1 systemctl start mariadb.service 設定\n1 mariadb-secure-installation 部署區塊鏈 拉取安裝包\n1 wget https://osp-1257653870.cos.ap-guangzhou.myqcloud.com/WeBASE/releases/download/v1.5.5/webase-deploy.zip 解壓縮\n1 unzip webase-deploy.zip 進入目錄\n1 cd webase-deploy 修改設定檔\n1 vim common.properties 部署\n1 python3 deploy.py installAll 啟動與停止操作\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # 一鍵部署 部署並啟動所有服務 python3 deploy.py installAll 停止一鍵部署的所有服務 python3 deploy.py stopAll 啟動一鍵部署的所有服務 python3 deploy.py startAll # 各子服務啟動與停止 啟動 FISCO-BCOS 節點: python3 deploy.py startNode 停止 FISCO-BCOS 節點: python3 deploy.py stopNode 啟動 WeBASE-Web: python3 deploy.py startWeb 停止 WeBASE-Web: python3 deploy.py stopWeb 啟動 WeBASE-Node-Manager: python3 deploy.py startManager 停止 WeBASE-Node-Manager: python3 deploy.py stopManager 啟動 WeBASE-Sign: python3 deploy.py startSign 停止 WeBASE-Sign: python3 deploy.py stopSign 啟動 WeBASE-Front: python3 deploy.py startFront 停止 WeBASE-Front: python3 deploy.py stopFront # 視覺化部署 部署並啟動視覺化部署的所有服務 python3 deploy.py installWeBASE 停止視覺化部署的所有服務 python3 deploy.py stopWeBASE 啟動視覺化部署的所有服務 python3 deploy.py startWeBASE 存取 根據設定項目 web.port=5000 確定存取連接埠（預設為 5000），然後存取管理後台。\n防火牆\n1 2 3 4 5 6 7 8 # 查詢開放的連接埠 firewall-cmd --zone=public --list-ports # 開放連接埠 --permanent 為永久開放 firewall-cmd --zone=public --add-port=5000/tcp --permanent # 重新啟動防火牆 firewall-cmd --reload # 查詢是否開放 firewall-cmd --zone=public --query-port=5000/tcp 智慧合約 2025-03-13: 我也不知道這裡寫的是什麼了\nWeBASE 後台的合約管理頁面，在合約 IDE 建立合約\n編譯後建立新使用者，在私鑰管理處\n透過發送交易測試是否成功\n參考文章 WeBASE 文件 https://www.runoob.com/docker/centos-docker-install.html https://mariadb.org/download/?t=repo-config\u0026d=CentOS+7\u0026v=11.2\u0026r_m=aliyun https://blog.csdn.net/default7/article/details/122672341 https://www.cnblogs.com/potato-chip/p/13973780.html ","date":"2025-03-13T01:08:02+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/241/","title":"使用 WeBASE 部署 FISCO BCOS 區塊鏈"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 引言 在國際化後，因為平時也不怎麼關注其他語言的文章，直到我之前上網衝浪的時候，看到了不錯的日文字型，這不得給它用上，然後就發現我這其他語言的字型真是一言難盡啊。\n匯入字型 Google Fonts 可以透過一些字型服務，例如 Google Fonts 的字型，這樣一般比較方便且快速。\n例如我使用了 Comic Neue、Noto Sans JP、Noto Sans SC、Noto Sans TC 以及 Yomogi 字型，全部選擇後 Google Fonts 會生成一個插入的 HTML 標籤，把這個標籤放入 \u0026lt;head\u0026gt; 標籤裡即可。\n1 \u0026lt;link href=\u0026#34;https://fonts.googleapis.com/css2?family=Comic+Neue:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700\u0026amp;family=Noto+Sans+JP:wght@100..900\u0026amp;family=Noto+Sans+SC:wght@100..900\u0026amp;family=Noto+Sans+TC:wght@100..900\u0026amp;family=Yomogi\u0026amp;display=swap\u0026#34; rel=\u0026#34;stylesheet\u0026#34;\u0026gt; 自由匯入 也可以尋找一些像是 ttf、woff、woff2 檔案作為網站字型，不過一般推薦轉換為 woff2 或 woff 字型會比較好，這樣字型檔案會很小 (更高階的就是把字型檔案分塊之類的優化載入，這點其實看 Google Fonts 的匯入資源就是由很多檔案組成的)。\n比如我使用 Yozai Font ，其作者提供的 ttf 檔案相當大，使用一些工具（例如 Transfonter ）壓縮後再引入。\n先把字型檔案放入自定義目錄，然後在 SCSS 自定義匯入字型的名稱。\n我的定義如下，一般只用 woff2 和 woff 就行，保留 ttf 是為了相容非常老的瀏覽器 (其實是我剛開始不懂直接上傳了，然後很卡才優化的)。\n然後設定 font-display: swap; 可以保證瀏覽器會先使用其他可用字型，等該字型下載完成後再切換成該字型，不會出現空白，優化閱讀體驗。\n1 2 3 4 5 6 7 8 9 @font-face { font-family: \u0026#39;yozai\u0026#39;; src: url(\u0026#39;/fonts/Yozai-Regular.woff2\u0026#39;) format(\u0026#39;woff2\u0026#39;), // url(\u0026#39;/fonts/Yozai-Regular.woff\u0026#39;) format(\u0026#39;woff\u0026#39;), url(\u0026#39;/fonts/Yozai-Regular.ttf\u0026#39;) format(\u0026#39;truetype\u0026#39;); font-weight: 400; font-style: normal; font-display: swap; } 尋找位置 對於匯入 Google Fonts 需要插入 \u0026lt;head\u0026gt; 標籤裡，我的主題檔案提供了該標籤的 custom.html 直接放入即可。\n對於匯入自己的檔案，主題提供了 custom.scss 直接放入即可。\n對於字型設定，我的主題是配置在 variables.scss 裡，所以需要直接在該檔案修改。\n設定字型 根據不同語言確定使用不同字型。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 /** * Global font family */ :root { // --sys-font-family: -apple-system, BlinkMacSystemFont, \u0026#34;Segoe UI\u0026#34;, \u0026#34;Droid Sans\u0026#34;, \u0026#34;Helvetica Neue\u0026#34;; --sys-font-family: system-ui, -apple-system, \u0026#34;Segoe UI\u0026#34;, \u0026#34;Helvetica Neue\u0026#34;, Arial, sans-serif; --zh-font-family: \u0026#34;yozai\u0026#34;, \u0026#34;Noto Sans SC\u0026#34;, var(--sys-font-family); --zh-TW-font-family: \u0026#34;yozai\u0026#34;, \u0026#34;Noto Sans TC\u0026#34;, var(--sys-font-family); --ja-font-family: \u0026#34;Yomogi\u0026#34;, \u0026#34;Noto Sans JP\u0026#34;, var(--sys-font-family); --en-font-family: \u0026#34;Comic Sans MS\u0026#34;, \u0026#34;Comic Neue\u0026#34;, var(--sys-font-family); --base-font-family: var(--sys-font-family), sans-serif; --code-font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, \u0026#34;Liberation Mono\u0026#34;, \u0026#34;Courier New\u0026#34;, monospace; } 按照原命名方式添加了其他語言的字型變數，然後使用 lang 選擇器來替換字型，也就是偵測網頁根標籤 \u0026lt;html\u0026gt; 的 lang 屬性從而動態替換字型。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 /* 針對中文（簡體） */ :lang(zh), :lang(zh-CN) { font-family: var(--zh-font-family); } /* 針對中文（繁體） */ :lang(zh-TW) { font-family: var(--zh-TW-font-family); } /* 針對英語 */ :lang(en) { font-family: var(--en-font-family); } /* 針對日文 */ :lang(ja) { font-family: var(--ja-font-family); } ","date":"2025-03-10T23:56:56+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/240/","title":"國際化字型適配"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 音有所感系列 歌曲名稱 翻譯 連結 僕が死のうと思ったのは 曾經我也想過一了百了 https://blog.yexca.net/zh-tw/archives/214 あくあ色ぱれっと aqua 的調色盤 https://blog.yexca.net/zh-tw/archives/219 恋の押し売り 戀愛推銷 https://blog.yexca.net/zh-tw/archives/220 17さいのうた 17 歲的歌 https://blog.yexca.net/zh-tw/archives/224 drop 墜入愛河 https://blog.yexca.net/zh-tw/archives/230 生きるを選んだ私へ 致選擇活下去的自己 本文 rainy lady 雨意未晴 https://blog.yexca.net/zh-tw/archives/249 恋しくなったら手を叩こう 想談戀愛的話就拍拍手吧 https://blog.yexca.net/zh-tw/archives/250 pris-magic! 稜鏡魔法! https://blog.yexca.net/zh-tw/archives/260 引言 初次看到歌曲名稱就大概猜到這首歌的含義，同時也喚起了我之前對於生命的思考。之前對於為什麼活著，我始終找不到答案，但是反過來思考為什麼不去自殺呢？我嘗試過思考自殺的方式以及這些方式會造成的後果，了解到自己對於自殺是恐懼的，因為害怕自殺，所以我選擇了活下去。這正好和這首歌相呼應。\n話說回來，之前我就聽過不少 こはならむ 的作品，但當時她都是哭著唱一些歌，一度讓我覺得有點看不下去，有點擔心她是否能好好活下去。直到 YouTube Music 推播給我的新歌都是歡樂風格的，當時我甚至為她走出悲傷而高興（雖然我還沒走出來）。\n深入了解這首歌後（把歌詞搞懂），才發現這首歌真的很不錯，要是能早點遇到就好了。同時也覺得我寫這系列文章真不錯，讓我從自己之前只是會唱部分的歌曲中學到了很多，我覺得這已經不是從歌曲學日語了，這是從歌曲學人生了，發現自己之前聽的歌的另一面，這種感覺真的很奇妙，更喜歡了（其實這裡想到了亞絲娜對桐人的質疑，如果發現另一面會怎麼樣，真的會更喜歡啊）。\n同時，按照這個系列慣例，翻譯並不完全按照原文意思，部分語句玩梗，不適合用梗的部分後面已刪除。\n2025.05.26 唱了這首歌，詞彙有點難，不過喊出「透明なまま終わっていきなよ、私はもうきっと大丈夫」的時候真的很解放，釋放情緒的感覺超棒 (然後被不認識的詞語打敗了)\n歌曲影片 歌詞 なつかしい音 なつかしい匂い なつかしい景色\n懷念的聲音，懷念的氣味，懷念的景色\n蘇よみがえるトラウマ 見たくない顔 聞きたくない声\n再顯的 PTSD，不想看見的臉，不想聽到的聲音\n許せない人たち もう行けなくなっちゃった、あの駅\n無法原諒的人們，已經無法回去的，那個車站\n暗い「人目が怖いの」\n消極地「世人的眼光很恐怖」\nそんな記憶 あいして生きる\n那樣的記憶也要懷抱著愛活下去\n透明なまま終わっていきなよ\n別就這樣放棄啊\n私はもうきっと大丈夫\n我肯定可以的\n嫌い泣きたいも今振り返れば\n如今再看那些討厭、想哭的事情\n泡と消える刹那せつな\n也如同泡沫般轉瞬即逝\n私見て下を見た気でいなよ そのまま\n不要小看我啊\n消えてしまいたいと願ったような夜に\n就算是曾經想要消失的夜晚\n笑ってられてるよ 永遠に消えないんだよ\n也能夠笑著面對了，永遠不會消失\n狭い世界で くだらない談だんに怯おびえてる私\n狹小的世界內，對無意義的話語受傷的我（這個世界可能指涉社交圈小或者說見識少）\n霞かすんで歪ゆがんだ脳 明白めいはくな病\n頭腦模糊扭曲，多少有點病\n傷跡きずあとは消えないまま 責任の所在は？\n傷痕無法消失，責任在誰呢？\nあの日の子供が泣くのだ 今でも\n那天哭泣的孩子，現在也\u0026hellip;\n今日ものうのう生きている 永世えいせい罪人ざいにん共に問う\n我想問問那些毫無愧疚地活著的永世罪人\n替えの効かないもの 戻らないものに手を出した自じ覚かくはある？\n是否意識到自己伸手染指了那些無可替代，無法挽回的東西？\n許せぬ過去を睨にらんでも仕方ない、って\n說什麼就算盯著那些無法原諒的過去也無濟於事\n言葉は理解するが 時に解決を促うながさせる\n我懂得這些道理啊，可是\u0026hellip;有時卻被迫接受所謂的解決。\n卑ひ劣れつさに 愚ぐ劣れつさに\n那份卑鄙，那份愚蠢\n反吐へどが出る 反吐へどが出る\n好噁心啊，噁心地想吐🤮\n「忘れろ」も言葉のナイフだ\n「忘記吧」也是多麼傷人的話語\n私は今日も立っている 私は今日も歌っている\n今天，我依然站著，我依然歌唱\n透明なまま終わっていきなよ\n別就這樣放棄啊\n私はもう大丈夫\n我已經沒問題了\n嫌い泣きたいも今振り返れば\n如今再看那些討厭、想哭的事情\n私を生かすのは私なのだ\n真正掌控我的是我自己啊\n透明なまま終わっていきなよ\n別就這樣放棄啊\n私はもう、もう大丈夫\n我肯定，已經沒問題了\n嫌い泣きたいも今振り返れば\n如今再看那些討厭、想哭的事情\n決して消えぬ「愛」か\n一定不會消失的愛嗎？\n私見て下を見た気でいなよ そのまま\n不要小看我啊\n消えてしまいたいと願ったような夜に\n就算是曾經想要消失的夜晚\n笑っているんだよ 笑っているんだよ 笑っているんだよ\n笑著面對著，歡笑著面對著，已經不在意了\n","date":"2025-03-07T01:26:31+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/239/","title":"音有所感 - 《致選擇活下去的我》"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 同 電腦網路的筆記 的編寫時間，畢竟考試這兩部分在一起，都是同時學習的\n防火牆技術 防火牆 (Firewall) 是建立在內外網路邊界上的過濾阻擋機制，它認為內部網路是安全且可信賴的，而外部網路是不安全且不可信賴的\n防火牆的作用是防止不希望的、未經授權地進出受保護的內部網路，透過邊界控制強化內部網路的安全策略\n防火牆作為網路安全體系的基礎與核心控制措施，貫穿於受控網路通訊主幹線，對透過受控主幹線的任何通訊行為進行安全處理，如控制、稽核、警報與回應等，同時也承擔著繁重的通訊任務。由於其自身處於網路系統中的敏感位置，本身還要面對各種安全威脅，因此，選用一個安全、穩定且可靠的防火牆產品，其重要性不言而喻\n防火牆技術經歷了封包過濾、應用代理閘道及狀態偵測技術三個發展階段\n封包過濾防火牆 封包過濾防火牆通常有一個封包檢查區塊 (通常稱為封包過濾器)，資料封包過濾可以根據資料封包標頭中的各項資訊來控制站點與站點、站點與網路、網路與網路之間的相互存取，但無法控制傳輸資料的內容，因為內容是應用層資料，而封包過濾器處在網路層與資料鏈路層 (即 TCP 和 IP 層) 之間。透過檢查模組，防火牆能夠攔截與檢查所有出站及進站的資料，它首先開啟封包，取出封包標頭，根據封包標頭的資訊確定該封包是否符合封包過濾規則，並進行記錄。對於不符合規則的封包，應進行警報並丟棄該封包\n過濾型的防火牆通常直接轉發報文，它對使用者完全透明，速度較快。其優點是防火牆對每條傳入與傳出網路的封包實行低層級控制；每個 IP 封包的欄位都被檢查，例如來源位址、目的位址、協定與連接埠等；防火牆可以識別與丟棄帶有欺騙性來源 IP 位址的封包；封包過濾防火牆是兩個網路之間存取的唯一來源；封包過濾通常被包含在路由器資料封包中，因此不需要額外的系統來處理這個特性。缺點是不能防範駭客攻擊，因為網管不可能區分出可信賴網路與不可信賴網路的界線；不支援應用層協定，因為它不識別資料封包中的應用層協定，存取控制粒度太粗糙；不能處理新的安全威脅\n應用代理閘道防火牆 應用代理閘道防火牆徹底隔斷內網與外網的直接通訊，內網使用者對外網的存取變成防火牆對外網的存取，然後再由防火牆轉發給內網使用者。所有通訊都必須經過應用層代理軟體轉發，存取者任何時候都不能與伺服器建立直接的 TCP 連線，應用層的協定會話過程必須符合代理的安全策略要求\n應用代理閘道的優點是可以檢查應用層、傳輸層與網路層的協定特性，對資料封包的偵測能力比較強。缺點是難以配置；處理速度非常慢\n狀態偵測技術防火牆 狀態偵測防火牆結合了代理防火牆的安全性與封包過濾防火牆的高速度等優點，在不損失安全性的基礎上，提高了代理防火牆的效能\n病毒 電腦病毒的特性包括：傳播性、隱蔽性、感染性、潛伏性、觸發性、破壞性等\nWorm 表示蠕蟲病毒、Trojan 表示特洛伊木馬、Backdoor 表示後門病毒、Macro 表示巨集病毒\n巨集病毒感染的對象主要是純文字文件、電子試算表等\n木馬軟體：冰河\n蠕蟲病毒：歡樂時光、熊貓燒香、紅色程式碼、愛蟲病毒、震網\n網路攻擊 阻斷服務攻擊 (DOS 攻擊)：目的是使電腦或網路無法提供正常的服務 阻斷服務攻擊是不斷向電腦發起請求來實現的\n重送攻擊：攻擊者發送一個目的主機已經接收過的報文來達到攻擊目的 攻擊者利用網路監聽或其他方式盜取認證憑證，之後再重新發送給認證伺服器 主要用於身分認證過程，目的是破壞認證的正確性\n密碼入侵攻擊：使用某些合法使用者的帳號與密碼登入到目的主機，然後再實施攻擊活動\n特洛伊木馬：被偽裝成程式或遊戲，當使用者下載了帶有木馬的軟體或附件時，這個程式就會向駭客發起連線請求，建立連線後駭客就實施攻擊活動\n連接埠欺騙攻擊：採用連接埠掃描找到系統漏洞從而實施攻擊\n網路監聽：攻擊者可以接收某一網段在同一條實體通道上傳輸的所有資訊，使用網路監聽可以輕鬆截取包括帳號與密碼在內的資訊資料\nIP 欺騙攻擊：產生的 IP 資料封包為偽造的來源 IP 位址，以便冒充其他系統或發件人的身分\nSQL 注入攻擊：是駭客對資料庫進行攻擊的常用手段之一 沒有對使用者輸入資料的合法性進行判斷，使應用程式存在安全隱患 攻擊者可以提交一段資料庫查詢程式碼，根據程式返回的結果，獲得某些他想得知的資料，首先取得資料庫的權限，就可取得使用者帳號與密碼資訊，以及對某些資料修改等\n入侵偵測技術：專家系統、模型偵測、簡單比對\n網路安全 SSL (Secure Socket Layer, 安全通訊端層) 是 Netscape 於 1994 年開發的傳輸層安全協定，用於實現 Web 安全通訊，1996 年發布的 SSL 3.0 協定草案已經成為一個事實上的 Web 安全標準\nTLS (Transport Layer Security, 傳輸層安全協定) 是 IETF 制定的協定，它建立在 SSL 3.0 協定規範之上，是 SSL 3.0 的後續版本\n終端設備與遠端站點之間安全連線的協定是 SSH。SSH 為 Secure Shell 的縮寫，是由 IETF 制定的建立在應用層與傳輸層基礎上的安全協定。SSH 是專為遠端登入會話與其他網路服務提供安全性的協定。利用 SSH 協定可以有效防止遠端管理過程中的資訊洩漏問題，SSH 最初是 UNIX 上的程式，後來又迅速擴展到其他操作平台\nHTTPS (Hyper Text Transfer Protocol over Secure Socket Layer)，是以安全為目標的 HTTP 通道，即使用 SSL 加密演算法的 HTTP\nMIME (Multipurpose Internet Mail Extensions, 多用途網際網路郵件擴展類型) 是一個網際網路標準，擴展了電子郵件標準，使其能夠支援：非 ASCII 字元純文字，非文字格式附件 (二進位、聲音、圖像等)，由多部分 (multiple parts) 組成的訊息本體，包含非 ASCII 字元的標頭資訊 (Header information)\nPGP (Petty Good Privacy, 優良保密協定) 是一個基於 RSA 公鑰加密體系的郵件加密軟體。可以用它對郵件保密以防止未經授權者閱讀，還能對郵件加上數位簽章從而使收信人可以確認郵件的發送方\n","date":"2025-03-04T18:38:28+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/238/","title":"軟體設計師 - 資訊安全部分筆記"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 引言 最近下載 OneDrive 分享的檔案時，發現無法被 IDM 自動抓取，而瀏覽器下載又不穩定，經常下載失敗，於是我便在想是否有辦法獲取直接下載連結。\n擴充功能問題 剛開始看到不支援了，還以為需要重新安裝，結果刪除後去 Chrome 線上應用程式商店顯示無法安裝，呃，刪太早了。\n不過 IDM 作為付費軟體，居然沒有跟進更新。\n從 簡悅專案問題 得知，原來只是按鈕被加上了 disabled 屬性禁用，把屬性移除後就能正常安裝。\n獲取直接連結 但 IDM 還是無法偵測，那就只能尋找直接下載連結了。\n進入分享頁面，預覽某個檔案，點擊右上角 Share - Copy link 即可獲取檔案分享連結，類似於：\n1 https://xxx-my.sharepoint.com/:u:/r/personal/xxx/Documents/xxx/xxx.rar?csf=1\u0026amp;web=1\u0026amp;e=OTZZbx 將其中的 web 替換為 download，類似於：\n1 https://xxx-my.sharepoint.com/:u:/r/personal/xxx/Documents/xxx/xxx.rar?csf=1\u0026amp;download=1\u0026amp;e=OTZZbx 複製到 IDM 的 Add URL 下載即可。\n參考文章： https://techcommunity.microsoft.com/discussions/onedriveforbusiness/onedrive-direct-download-link/4226744 ","date":"2025-03-02T12:58:57+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/237/","title":"獲取 OneDrive 直接下載連結"},{"content":" 📢 本文由 gemini-3-pro 翻譯 從圖片連結就能知道這是 2023-04 的筆記了，一直沒發是因為幾乎就只是知識點而已，不是一種文章的樣式，不過畢竟也是筆記，偶爾想查閱的時候還是直接看部落格方便啊。\n1. 網路設備 層級 設備 隔離廣播域 隔離碰撞域 實體層 中繼器 / 集線器 × × 資料鏈結層 橋接器 / 交換器 × √ 網路層 路由器 √ √ 實體層的互連設備 實體層的互連設備有中繼器 (Repeater) 和集線器 (Hub)。\n中繼器\n它是實體層上實現區域網路網段互連的設備，用於擴展區域網路網段的長度。\n集線器\n集線器可以看成是一種特殊的多路中繼器 (多連接埠中繼器)，也具有訊號放大功能。\n資料鏈結層的互連設備 資料鏈結層的互連設備有橋接器 (Bridge) 和交換器 (Switch)。\n橋接器\n橋接器用於連接兩個區域網路網段。\n交換器\n交換器是多連接埠 (Multi-port) 的橋接器。\n網路層的互連設備 路由器 (Router) 是網路層互連設備，用於連接多個邏輯上分開的網路。\n應用層的互連設備 閘道器 (Gateway) 是應用層的互連設備。當連接不同類型且協定差別較大的網路時，則要選用閘道器設備。\n2. 協定組 電腦網路的 TCP/IP 協定組\n3. TCP 和 UDP 網際層協定 IP 網際層 (網路層) 是整個 TCP/IP 協定組的重點，在網際層定義的協定除了 IP 外，還有 ICMP、ARP 和 RARP 等幾個重要的協定。\nIP 所提供的服務通常被認為是無連線的 (Connectionless) 和不可靠的 (Unreliable)。事實上，在網路效能良好的情況下，IP 傳送的資料能夠完好無損地到達目的地。\n所謂無連線的傳輸，是指沒有確定目標系統在已做好接收資料準備之前就發送資料。與此相對應的就是連線導向的 (Connection Oriented) 傳輸 (如 TCP)，在該類傳輸中，來源系統與目的系統在應用層資料傳送之前需要進行三向交握 (Three-way Handshake)。\n至於不可靠的服務，是指目的系統不對成功接收的封包進行確認，IP 只是盡可能地使資料傳輸成功。但是只要需要，上層協定必須實現用於保證封包成功提供的附加服務。\n由於 IP 只提供無連線、不可靠的服務，所以把錯誤偵測和流量控制之類的服務授權給了其他的各層協定，這正是 TCP/IP 能夠高效工作的一個重要保證。\n傳輸層協定 TCP TCP (Transmission Control Protocol, 傳輸控制協定) 是整個 TCP/IP 協定組中最重要的協定之一。它在 IP 提供的不可靠資料服務的基礎上，為應用程式提供了一個可靠的、連線導向的、全雙工的資料傳輸服務。\n可靠傳輸、連線管理、錯誤檢驗和重傳、流量控制、壅塞控制、連接埠定址\n其中流量控制採用的是：可變大小的滑動視窗協定\n利用 TCP 在來源主機和目的主機之間建立和關閉連線操作時，均需要通過三向交握來確認建立和關閉是否成功。\n傳輸層協定 UDP 使用者資料報協定 (User Datagram Protocol, UDP) 是一種不可靠的、無連線的協定，可以保證應用程式行程間的通訊。與同樣處在傳輸層的連線導向 TCP 相比，UDP 是一種無連線的協定，它的錯誤偵測功能要弱得多。可以這樣說，TCP 有助於提供可靠性；而 UDP 有助於提高傳輸的高速率性。例如，必須支援互動式會話的應用程式 (如 FTP 等) 往往使用 TCP；而自己進行錯誤偵測或不需要錯誤偵測的應用程式 (如 DNS、SNMP 等) 往往使用 UDP。\nUDP 協定軟體的主要作用是將 UDP 訊息展示給應用層，它並不負責重新發送遺失的或出錯的資料訊息，不對接收到的無序 IP 資料報重新排序，不消除重複的 IP 資料報，不對已收到的資料報進行確認，也不負責建立或終止連線。這些問題是由使用 UDP 進行通訊的應用程式負責處理的。\nTCP 雖然提供了一個可靠的資料傳輸服務，但它是以犧牲通訊量來實現的。也就是說，為了完成同樣一個任務，TCP 需要更多的時間和通訊量。這在網路不可靠的時候透過犧牲一些時間換來達到網路的可靠性是可行的，但在網路十分可靠的情況下，則可以採用 UDP，通訊量的浪費就會很小。\n4. SMTP 和 POP3 電子郵件 (E-mail) 就是利用電腦進行資訊交換的電子媒體信件。它是隨著電腦網路而出現的，並依靠網路的通訊手段實現普通郵件訊息的傳輸。它是最廣泛的一種服務。\nE-mail 系統基於用戶端/伺服器模式。E-mail 伺服器主要採用 SMTP (簡單郵件傳輸協定)，本協定描述了電子郵件的訊息格式及其傳遞處理方法，保證被傳送的電子郵件能夠正確的定址和可靠的傳輸，它是物件導向文字的網路協定，其缺點是不能用來傳送非 ASCII 碼文字和非文字附件，在日益發展的多媒體環境中以及人們關注的郵件私密性方面更顯出它的侷限性。\n後來的一些協定，包括多用途 Internet 郵件擴充協定 (MIME) 及增強私密郵件保護協定 (PEM)，彌補了 SMTP 的缺點。SMTP 用在大型多使用者、多工的作業系統中，將它用在 PC 上收信是十分困難的，所以在 TCP/IP 網路上的大多數郵件管理程式使用 SMTP 來發信，且採用 POP (Post Office Protocol, 常用的是 POP3) 來保管使用者未能及時取走的郵件。\nPOP 協定有兩個版本：POP2 和 POP3。目前使用的 POP3 既能與 STMP 共同使用，也可以單獨使用，以傳送和接收電子郵件。POP 協定是一種簡單的純文字協定，每次傳輸以整個 E-mail 為單位，不能提供部分傳輸。\n簡單郵件傳送協定和用於接收郵件的 POP3 均是利用 TCP 連接埠。SMTP 所用的連接埠號是 25，POP3 所用的連接埠號是 110。\n5. ARP 和 RARP 和 DHCP ARP 和 RARP 位址解析協定 (Address Resolution Protocol, ARP) 及反向位址解析協定 (RARP) 是駐留在網際層 (網路層) 中的另一個重要協定。ARP 的作用是將 IP 位址轉換為實體位址 (Physical Address)，RARP 的作用是將實體位址轉換為 IP 位址。\n網路中的任何設備，主機、路由器和交換器等均有唯一的實體位址，該位址通過網卡給出，每個網卡出廠後都有不同的編號，這意味著使用者所購買的網卡有著唯一的實體位址。另一方面，為了遮蔽底層協定及實體位址上的差異，IP 協定又使用了 IP 位址，因此，在資料傳輸過程中，必須對 IP 位址與實體位址進行相互轉換。\n用 ARP 進行 IP 位址到實體位址轉換的過程為：當電腦需要與任何其他的電腦進行通訊時，首先需要查詢 ARP 快取 (Cache)，如果 ARP 快取中這個 IP 位址存在，便使用與它對應的實體位址直接將資料報發給所需的實體網卡；如果 ARP 快取中沒有該 IP 位址，那麼 ARP 便在區域網路上以廣播方式發送一個 ARP 請求封包。\n如果區域網路上 IP 位址與某台電腦中的 IP 位址相一致，那麼該電腦便生成一個 ARP 回應訊息，訊息中包含對應的實體位址。ARP 協定軟體將 IP 位址與實體位址的組合添加到它的快取中，這時即可開始資料通訊。\nDHCP DHCP (動態主機設定協定) 的功能是：集中的管理、分配 IP 位址、使網路環境中的主機動態的獲得 IP 位址、Gateway 位址、DNS 伺服器位址等資訊，並能提升位址的使用率。\nDHCP 用戶端可以從 DHCP 伺服器獲得本機 IP 位址、DNS 伺服器位址、DHCP 伺服器位址和預設閘道的位址等。\nWindows 無效位址：169.254.x.x\nLinux 無效位址：0.0.0.0\n168.254.x.x 是 Windows 系統在 DHCP 訊息租用失敗時自動給用戶端分配的 IP 位址。\n6. IP 位址和子網路遮罩 IP 位址 Internet 位址是按名字來描述的，這種位址表示方式易於理解和記憶。實際上，Internet 中的主機位址是用 IP 位址來唯一標識的。這是因為 Internet 中所使用的網路協定是 TCP/IP 協定，故每個主機必須用 IP 位址來標識。\n每個 IP 位址都由 4 個小於 256 的數字組成，數字之間用 . 分開。Internet 的 IP 位址共有 32 位元，4 個位元組。它有兩種表示格式；二進位格式和十進位格式。二進位格式是電腦所認識的格式，十進位格式是由二進位格式「翻譯」過去的，主要是為了便於使用和掌握。例如，十進位 IP 位址 129.102.4.11 與二進位的 10000001 01100110 00000100 00001011 相同，顯然表示成帶點的十進位格式方便得多。\n網域名稱和 IP 位址是一一對應的，網域名稱易於記憶、便於使用，因此得到比較普遍的使用。當使用者和 Internet 上的某台電腦交換資訊時，只需要使用網域名稱，網路會自動地將其轉換成 IP 位址找到該台電腦。\nInternet 中的位址可分為 5 類：A 類、B 類、C 類、D 類和 E 類。在 IP 位址中，全 0 代表的是網路，全 1 代表的是廣播。\nA 類網路位址佔有 1 個位元組 (8 位元)，定義最高位為 0 來標識此類位址，餘下 7 位元為真正的網路位址，支援 1~126 個網路。後面的 3 個位元組 (24 位元) 為主機位址，共提供 $2^{24}-2$ 個端點的定址。\nA 類網路位址第一個位元組的十進位值為 000~127\nB 類網路位址佔有兩個位元組，使用最高兩位為 10 來標識此類位址，其餘 14 位元為真正的網路位址，主機位址佔後面的兩個位元組 (16 位元)，所以 B 類全部的位址有 $(2^{14}-2)(2^{16}-2)$ = 16382×65534 個。\nB 類網路位址第一個位元組的十進位值為 128~191\nC 類網路位址佔有 3 個位元組，它是最通用的 Internet 位址。使用最高三位為 110 來標識此類位址，其餘 21 位元為真正的網路位址，因此 C 類位址支援 $2^{21}-2$ 個網路。主機位址佔最後 1 個位元組，每個網路可多達 $2^8-2$ 個主機。\nC 類網路位址第一個位元組的十進位值為 192~223\nD 類位址是相當新的。它的標識頭是 1110，用於多播 (Multicast)，例如用於路由器的修改。\nD 類網路位址第一個位元組的十進位值為 224~239\nE 類位址為實驗保留，其識別頭是 1111。\nE 類網路位址第一個位元組的十進位值為 240~255\n網路軟體和路由器使用子網路遮罩 (Subnet Mask) 來識別封包是僅存放在網路內部還是被路由轉發到其他地方。在一個欄位內，1 的出現表明一個欄位包含所有或部分網路位址，0 表明主機位址位置。例如，最常用的 C 類位址使用前 3 個位元組來識別網路，最後一個位元組 (8 位元) 識別主機。因此，子網路遮罩是 255.255.255.0。\nIPv6 簡介 IPv6 具有長達 128 位元的位址空間，可以徹底解決 IPv4 位址不足的問題。除此之外，IPv6 還採用分級位址模式、高效 IP 封包首部、服務品質 (QoS)、主機位址自動配置、認證和加密等許多技術。\n7. Windows 指令 ipconfig/release：DHCP 用戶端手工釋放 IP 位址 ipconfig/flushdns：清除本地 DNS 快取內容 ipconfig/displaydns：顯示本地 DNS 內容 ipconfig/registerdns：DNS 用戶端手工向伺服器進行註冊 ipconfig：顯示所有網路介面卡的 IP 位址、子網路遮罩和預設閘道值 ipconfig/all：顯示所有網路介面卡的完整 TCP/IP 設定資訊，包括 DHCP 服務是否已啟動 ipconfig/renew：DHCP 用戶端手工向伺服器重新整理請求 (重新申請 IP 位址) 8. 路由 Windows Server 2003 的路由類型有 5 種。當 Windows 伺服器收到一個 IP 封包時，先尋找主機路由，再尋找網路路由 (直連網路和遠端網路)，這些路由尋找失敗時，最後才尋找預設路由。\n各種路由來源的管理距離 (Administrative Distance) 如下：\n如果路由器收到了由多個路由協定轉發的、關於某個目標的多條路由，則比較各個路由的管理距離，並採用管理距離小的路由來源提供的路由資訊。\n","date":"2025-03-01T23:28:30+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/236/","title":"軟體設計師 - 電腦網路部分筆記"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 Elasticsearch 系列\n內容 連結 Elasticsearch 基礎操作 https://blog.yexca.net/zh-tw/archives/226 Elasticsearch 查詢操作 https://blog.yexca.net/zh-tw/archives/227 RestClient 基礎操作 https://blog.yexca.net/zh-tw/archives/228 RestClient 查詢操作 https://blog.yexca.net/zh-tw/archives/229 Elasticsearch 資料聚合 https://blog.yexca.net/zh-tw/archives/231 Elasticsearch 自動補齊 https://blog.yexca.net/zh-tw/archives/232 Elasticsearch 資料同步 https://blog.yexca.net/zh-tw/archives/234 Elasticsearch 叢集 本文 單機的 ES 用於資料儲存勢必面臨兩個問題：海量資料儲存與單點故障問題\n海量資料儲存問題：將索引庫從邏輯上拆分為 N 個分片 (shard)，儲存到多個節點 單點故障問題：將分片資料在不同節點備份 (replica) ES 叢集相關概念\n叢集 (cluster)：一組擁有共同 cluster name 的節點 節點 (node)：叢集中的一個 ES 實例 分片 (shard)：索引可以被拆分為不同的部分進行儲存，稱為分片。在叢集環境下，一個索引的不同分片可以拆分到不同的節點中 解決問題：資料量太大，單點儲存量有限的問題\n分片類似 Hadoop 的 HDFS，其資料會分成多份備份\n主分片 (Primary shard)：相對於副本分片的定義 副本分片 (Replica shard)：每個主分片可以有一個或多個副本，資料與主分片相同 建置 ES 叢集 可以透過 docker-compose 來完成\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 version: \u0026#39;2.2\u0026#39; services: es01: image: elasticsearch:7.12.1 container_name: es01 environment: - node.name=es01 - cluster.name=es-docker-cluster - discovery.seed_hosts=es02,es03 - cluster.initial_master_nodes=es01,es02,es03 - \u0026#34;ES_JAVA_OPTS=-Xms512m -Xmx512m\u0026#34; volumes: - data01:/usr/share/elasticsearch/data ports: - 9200:9200 networks: - elastic es02: image: elasticsearch:7.12.1 container_name: es02 environment: - node.name=es02 - cluster.name=es-docker-cluster - discovery.seed_hosts=es01,es03 - cluster.initial_master_nodes=es01,es02,es03 - \u0026#34;ES_JAVA_OPTS=-Xms512m -Xmx512m\u0026#34; volumes: - data02:/usr/share/elasticsearch/data ports: - 9201:9200 networks: - elastic es03: image: elasticsearch:7.12.1 container_name: es03 environment: - node.name=es03 - cluster.name=es-docker-cluster - discovery.seed_hosts=es01,es02 - cluster.initial_master_nodes=es01,es02,es03 - \u0026#34;ES_JAVA_OPTS=-Xms512m -Xmx512m\u0026#34; volumes: - data03:/usr/share/elasticsearch/data networks: - elastic ports: - 9202:9200 volumes: data01: driver: local data02: driver: local data03: driver: local networks: elastic: driver: bridge ES 運行需要修改一些 Linux 系統權限，請修改 /etc/sysctl.conf 檔案\n1 vi /etc/sysctl.conf 請新增以下內容：\n1 vm.max_map_count=262144 接著執行指令，讓配置生效：\n1 sysctl -p 透過 docker-compose 啟動叢集：\n1 docker-compose up -d 監控叢集狀態 Kibana 可以監控 ES 叢集，不過需要依賴 ES 的 X-Pack 功能，設定相對複雜\n可以使用 Cerebro 來監控 ES 叢集，GitHub： https://github.com/lmenezes/cerebro 執行 bin/cerebro.bat 後，即可前往 http://localhost:9000 進入管理介面\n使用 Cerebro 可以視覺化建立索引庫，以下是 DSL 語法建立\n1 2 3 4 5 6 7 8 9 10 11 12 PUT /indexName { \u0026#34;settings\u0026#34;: { \u0026#34;number_of_shards\u0026#34;: 3, // 分片數量 \u0026#34;number_of_replicas\u0026#34;: 1 // 副本數量 }, \u0026#34;mappings\u0026#34;: { \u0026#34;properties\u0026#34;: { // Mapping 對映定義 ... } } } 叢集職責劃分 ES 中，叢集節點有不同的職責劃分\n節點類型 配置參數 預設值 節點職責 Master eligible node.master true 候選主節點：主節點可以管理和記錄叢集狀態、決定分片在哪個節點、處理建立和刪除索引庫的請求 Data node.data true 資料節點：儲存資料、搜尋、聚合、CRUD Ingest node.ingest true 資料儲存之前的預處理 Coordinating 上面 3 個參數都為 false 則為 Coordinating 節點 無 將請求路由到其他節點，合併其他節點處理的結果，並回傳給使用者 預設情況下，叢集的任何一個節點都同時具備上述四種角色\n但真實的叢集一定要將叢集職責分離\nMaster 節點：對 CPU 要求高，但是記憶體要求低 Data 節點：對 CPU 和記憶體要求都高 Coordinating 節點：對網路頻寬、CPU 要求高 職責分離可以讓我們根據不同節點的需求分配不同的硬體去部署。而且能避免業務之間的相互干擾\n叢集腦裂問題 腦裂是因為叢集中的節點失聯所導致的\n假設有三個節點，現在主節點 (node1) 與其他節點失聯 (網路阻塞)，node2 和 node3 會認為 node1 宕機，就會重新選主。假設 node3 當選，叢集會繼續對外提供服務，node2 和 node3 自成叢集，node1 自成叢集，這兩個叢集資料不同步，因而出現資料差異\n當網路阻塞恢復正常，由於叢集中有兩個 Master 節點，叢集狀態不一致，於是出現腦裂的情況\n解決方案：要求選票超過 (eligible 節點數量 + 1) / 2 才能當選為 Master 節點，因此 eligible 節點數量最好是奇數。對應的配置項為 discovery.zen.minimum_master_nodes，在 ES 7.0 之後，這已成為預設配置，因此一般不會發生腦裂問題\n例如上述 3 個節點形成的叢集，選票必須超過 (3+1)/2 = 2 票。node3 得到 node2 和 node3 的選票，當選為主，而 node1 只有自己的一票，沒有當選。叢集中依然只有 1 個主節點，沒有出現腦裂\n叢集分散式儲存 當新增文件時，應該保存到不同分片，確保資料平衡，那麼 Coordinating 節點如何確定資料該儲存到哪個分片呢\nES 會透過 Hash 演算法來計算文件應該儲存到哪個分片\n公式：shard = hash(_routing) % number_of_shards\n說明：\n_routing 預設是文件的 ID 演算法與分片數量有關，因此索引庫一旦建立，分片數量就不能修改 新增文件流程：\n流程：\n新增一個 ID = 1 的文件 對 ID 執行 Hash 運算，假如得到的是 2，則對應儲存到 shard-2 shard-2 的主分片在 node3 節點，將資料路由到 node3 保存文件 同步給 shard-2 的副本 replica-2，在 node2 節點 回傳結果給 Coordinating 節點 叢集分散式查詢 ES 的查詢分為兩個階段：\nScatter Phase：分散階段，Coordinating 節點會把請求分發到每一個分片 Gather Phase：聚集階段，Coordinating 節點會彙總 Data 節點的搜尋結果，並處理成最終結果集回傳給使用者 叢集容錯移轉 叢集的 Master 節點會監控叢集中的節點狀態，如果發現有節點宕機，會立即將宕機節點的分片資料遷移到其他節點，確保資料安全，這稱為容錯移轉\n假設一個叢集有三個節點，node1 是主節點\nnode1 發生了宕機 需要重新選主，假設選中了 node2 node2 成為主節點後，會檢測叢集狀態，發現 node1 的分片沒有副本節點，需要將 node1 上的資料遷移到 node2、node3 ","date":"2025-02-15T17:17:08+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/235/","title":"Elasticsearch 叢集"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 Elasticsearch 系列\n內容 連結 Elasticsearch 基礎操作 https://blog.yexca.net/zh-tw/archives/226 Elasticsearch 查詢操作 https://blog.yexca.net/zh-tw/archives/227 RestClient 基礎操作 https://blog.yexca.net/zh-tw/archives/228 RestClient 查詢操作 https://blog.yexca.net/zh-tw/archives/229 Elasticsearch 資料聚合 https://blog.yexca.net/zh-tw/archives/231 Elasticsearch 自動補齊 https://blog.yexca.net/zh-tw/archives/232 Elasticsearch 資料同步 本文 Elasticsearch 叢集 https://blog.yexca.net/zh-tw/archives/235 Elasticsearch 的資料來自 MySQL 資料庫，因此當 MySQL 資料發生變動時，Elasticsearch 也必須跟著變動，這就是 Elasticsearch 與 MySQL 之間的資料同步。\n常見的資料同步方案有三種：\n同步呼叫 非同步通知 監聽 binlog 同步呼叫 步驟：\nhotel-demo 對外提供介面，用於修改 Elasticsearch 中的資料 後台管理系統 (hotel-admin) 在完成資料庫操作後，直接呼叫 hotel-demo 提供的介面 非同步通知 步驟：\nhotel-admin 對 MySQL 資料完成 CRUD 後發送 MQ 訊息 hotel-demo 監聽 MQ，接收訊息後完成對 Elasticsearch 資料修改 監聽 binlog 流程：\n開啟 MySQL 的 binlog 功能 MySQL 完成 CRUD 操作都會記錄在 binlog 中 hotel-demo 基於 Canal 監聽 binlog 變化，即時更新 Elasticsearch 中的內容 方案比較 方式一：同步呼叫\n優點：實作簡單、直接 缺點：業務耦合度高 方式二：非同步通知\n優點：低耦合，實作難度一般 缺點：依賴 MQ 的可靠性 方式三：監聽 binlog\n優點：完全解除服務間耦合 缺點：開啟 binlog 增加資料庫負擔、實作複雜度高 資料同步實作 說明：使用 MQ 非同步通知，在 hotel-admin 實作對 MySQL 的 CRUD 操作\n在 hotel-admin、hotel-demo 引入 RabbitMQ 依賴\n1 2 3 4 5 \u0026lt;!--amqp--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-amqp\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 宣告佇列、交換機名稱\n1 2 3 4 5 6 7 8 9 10 11 12 public class MqConstants { // 交换机 public final static String HOTEL_EXCHANGE = \u0026#34;hotel.topic\u0026#34;; // 监听新增和修改队列 public final static String HOTEL_INSERT_QUEUE = \u0026#34;hotel.insert.queue\u0026#34;; // 监听删除的队列 public final static String HOTEL_DELETE_QUEUE = \u0026#34;hotel.delete.queue\u0026#34;; // 新增或修改的RoutingKey public final static String HOTEL_INSERT_KEY = \u0026#34;hotel.insert\u0026#34;; // 删除的RoutingKey public final static String HOTEL_DELETE_KEY = \u0026#34;hotel.delete\u0026#34;; } 在 hotel-demo 宣告交換機配置\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 @Configuration public class MqConfig { @Bean public TopicExchange topicExchange(){ return new TopicExchange(MqConstants.HOTEL_EXCHANGE,true,false); } @Bean public Queue insertQueue(){ return new Queue(MqConstants.HOTEL_INSERT_QUEUE,true); } @Bean public Queue deleteQueue(){ return new Queue(MqConstants.HOTEL_DELETE_QUEUE, true); } @Bean public Binding insertQueueBinding(){ return BindingBuilder.bind(insertQueue()).to(topicExchange()).with(MqConstants.HOTEL_INSERT_KEY); } @Bean public Binding deleteQueueBinding(){ return BindingBuilder.bind(deleteQueue()).to(topicExchange()).with(MqConstants.HOTEL_DELETE_KEY); } } 在 hotel-admin 發送 MQ 訊息\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public class HotelController { @Autowired private RabbitTemplate rabbitTemplate; @PostMapping public void saveHotel(@RequestBody Hotel hotel){ hotelService.save(hotel); rabbitTemplate.convertAndSend(MqConstants.HOTEL_EXCHANGE, MqConstants.HOTEL_INSERT_KEY, hotel.getId()); } @PutMapping() public void updateById(@RequestBody Hotel hotel){ if (hotel.getId() == null) { throw new InvalidParameterException(\u0026#34;id 不能為空\u0026#34;); } hotelService.updateById(hotel); rabbitTemplate.convertAndSend(MqConstants.HOTEL_EXCHANGE, MqConstants.HOTEL_INSERT_KEY,hotel.getId()); } @DeleteMapping(\u0026#34;/{id}\u0026#34;) public void deleteById(@PathVariable(\u0026#34;id\u0026#34;) Long id) { hotelService.removeById(id); rabbitTemplate.convertAndSend(MqConstants.HOTEL_EXCHANGE, MqConstants.HOTEL_DELETE_KEY, id); } } 在 hotel-demo 接收 MQ 訊息，業務邏輯：\n新增訊息：根據傳遞的 hotel.id 查詢資訊，然後新增一筆資料到索引庫 刪除訊息：根據傳遞的 hotel.id 刪除索引庫中的一筆資料 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 @Override public void deleteById(Long id) { try { // 準備request DeleteRequest request = new DeleteRequest(\u0026#34;hotel\u0026#34;, id.toString()); // 發送請求 client.delete(request, RequestOptions.DEFAULT); } catch (IOException e) { throw new RuntimeException(e); } } @Override public void insertById(Long id) { try { // 根據id查詢資料 Hotel hotel = getById(id); // 轉換文件類型 HotelDoc hotelDoc = new HotelDoc(hotel); // 準備request IndexRequest request = new IndexRequest(\u0026#34;hotel\u0026#34;).id(id.toString()); // 準備 JSON request.source(JSON.toJSONString(hotelDoc), XContentType.JSON); // 發送請求 client.index(request, RequestOptions.DEFAULT); } catch (IOException e) { throw new RuntimeException(e); } } 在 hotel-demo 編寫監聽器\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 @Component public class HotelLinster { @Autowired private IHotelService hotelService; /** * 監聽修改或新增 * @param id */ @RabbitListener(queues = MqConstants.HOTEL_INSERT_QUEUE) public void listenHotelInsertOrUpdate(Long id){ hotelService.insertById(id); } /** * 監聽刪除 * @param id */ @RabbitListener(queues = MqConstants.HOTEL_DELETE_QUEUE) public void listenHotelDelete(Long id){ hotelService.deleteById(id); } } ","date":"2025-02-14T20:36:55+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/234/","title":"Elasticsearch 資料同步"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 這篇文章檔案的建立到最後修改時間是 2022.10.31 - 2024.09.15，記錄了這段時期內我嚐過的茶葉以及個人感受。\n不過到了後期的時候，事實上我已經不是很喜歡這個愛好了，記錄就寫得很敷衍，但總歸是自己曾經的愛好，再加上文章編號到了 233，那就放一篇可能有點意思的文章吧 (老早就以為自己發過了，拖到了現在)\n紅茶 名稱 口味 妃子笑 初嚐時有種很悶膩的口感多次沖泡之後散發一股地瓜的味道大約可沖 12 泡 水蜜桃 初次沖泡比妃子笑稍苦，不膩夜裡呼吸不順，甚至出血，不確定是否茶的緣故 昔歸紅 初嚐甜而不膩，苦而不澀，非常好 祁門紅茶 初嚐時與 昔歸紅 差不多，不甜，但似乎更醇厚但茶葉較碎細 金駿眉 過於醇厚，甚至略帶苦澀，但第三杯喝後口中留有餘香與甘甜茶葉較細碎，且沖泡次數不多 醉紅 就是紅茶那個味可沖泡次數還行，但不能悶泡，碎渣較多 煙燻小種 確實帶有股煙燻味\n入口苦澀，但餘韻回甘 老欉紅茶 好喝 黑茶 名稱 口味 金獎六類 像是八寶粥的味道 參香六堡 帶有股藥草的苦味 天尖 初嚐時被其美味所震撼（或許是因為喝了前面兩種茶）\n味道苦澀，但有回甘\n多次沖泡後變得過於苦澀 金花茯磚 淡雅的「金獎六類」＋淡雅的「參香六堡」 老青磚 舊木頭味，茶渣太多 老熟普 喝起來不太好喝的樣子 老生普 很難泡開，苦澀 古樹熟普 相較於前兩種，還算可以 普洱生茶 初入口時略帶苦澀，而後口中帶有回甘\n放置兩天後，茶葉頂端出現發霉現象，沖泡後苦澀味更為明顯 普洱熟茶 八寶粥味 白茶 名稱 口味 荒野貢眉 入口帶有鮮嫩農作物的微苦澀感，甘甜綿軟 昔歸白 塊狀茶葉，散開後品嚐，入口蜜甜，口齒留香\n沖泡次數很多 \u0026gt;10 野小白 飲用時苦澀，飲後口中帶有餘甘 白毫銀針 茶色很淡，第一泡略帶茶草味，之後稍帶蜜甜，口中帶有餘甘 冰糖甜 第一、二泡帶有茶草味，之後是正常的白茶味 老白茶 經典白茶味，夠甜 高壽 第一口是茶草味，之後是正常的白茶味 烏龍茶 名稱 口味 大紅袍 量多，可以，微甜 鐵觀音 茶香但苦澀 蘭底水仙 苦澀 鴨屎香單叢 前兩泡帶有淡淡的烏龍茶香，後面味道轉淡 蜜蘭香單叢 入口無味，後有留香，後續很苦 梨山烏龍 淡淡的木頭味，泡開後是正常的烏龍味 流香肉桂 入口木頭味，後有回甘 白牡丹 初聞有油茶味，入口木頭味 清香鐵觀音 感覺味道差不多，淡雅清香 漳平水仙 感覺味道差不多，淡雅清香 古法鐵觀音 味道相較於上方幾款不錯 岩茶 名稱 口味 大紅袍 苦澀 杏桃香 奇特、苦澀 佛國岩肉桂 入口微苦，後口帶有留香 佛手雪梨 似乎只有苦味，過一段時間後有留香 留香肉桂 同上，有岩茶的感覺 蘭底水仙 名字超好聽，不過味道還是那種岩茶的感覺，甜度倒是比較高 奇丹 印刷名稱是「上立下可」的字，但不知道這個字是什麼，手寫也找不到\n味道相對較清淡，保留了岩茶的回甘，體驗相當不錯 其他 名稱 口味 小青柑 黑茶，不太好，略帶酸味\n體驗極差，第三天出現餿味 安吉白 外觀好看，很香，帶有板栗味，略顯膩口 蒙頂黃芽 與上一個類似，略好一些 茉莉雪芽 茶葉飄香，茶湯清香，飲後口中帶有餘香\n烏龍茶？ ","date":"2025-02-12T23:58:53+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/233/","title":"個人品茶史"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 Elasticsearch 系列\n內容 連結 Elasticsearch 基礎操作 https://blog.yexca.net/zh-tw/archives/226 Elasticsearch 查詢操作 https://blog.yexca.net/zh-tw/archives/227 RestClient 基礎操作 https://blog.yexca.net/zh-tw/archives/228 RestClient 查詢操作 https://blog.yexca.net/zh-tw/archives/229 Elasticsearch 資料聚合 https://blog.yexca.net/zh-tw/archives/231 Elasticsearch 自動補齊 本文 Elasticsearch 資料同步 https://blog.yexca.net/zh-tw/archives/234 Elasticsearch 叢集 https://blog.yexca.net/zh-tw/archives/235 當使用者在搜尋框輸入字元時，應該提示與該字元相關的搜尋項目，根據輸入的字母提供完整的詞彙功能，這就是自動補齊。\n拼音斷詞 要實現根據字母進行補齊，就必須對文件依照拼音斷詞。\n專案位址： https://github.com/medcl/elasticsearch-analysis-pinyin 安裝方式與 IK 斷詞器相同，以下為線上安裝方式，首先進入容器：\n1 docker exec -it es /bin/bash 執行指令：\n1 ./bin/elasticsearch-plugin install https://github.com/infinilabs/analysis-pinyin/releases/download/v7.12.1/elasticsearch-analysis-pinyin-7.12.1.zip 然後退出並重啟：\n1 2 3 4 # 退出 exit # 重啟 docker restart es 測試：\n1 2 3 4 5 6 # 測試拼音斷詞 POST /_analyze { \u0026#34;text\u0026#34;: \u0026#34;世界第一可爱\u0026#34;, \u0026#34;analyzer\u0026#34;: \u0026#34;pinyin\u0026#34; } 自訂斷詞器 預設的拼音斷詞器會將每個漢字單獨斷成拼音，而我們希望的是每個詞彙形成一組拼音，因此需要對拼音斷詞器進行客製化設定，以形成自訂斷詞器。\nElasticsearch 中斷詞器 (analyzer) 的組成份為三部分：\ncharacter filters：在詞元分析器 (tokenizer) 之前對文字進行處理。例如刪除字元、替換字元。 tokenizer：將文字依照一定的規則切割成詞彙 (term)。例如 keyword，就是不斷詞；還有 ik_smart。 tokenizer filter：將詞元分析器 (tokenizer) 輸出後的詞彙做進一步處理。例如大小寫轉換、同義詞處理、拼音處理等。 宣告自訂斷詞器的語法如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 # 自訂斷詞器 PUT /test { \u0026#34;settings\u0026#34;: { \u0026#34;analysis\u0026#34;: { \u0026#34;analyzer\u0026#34;: { // 自訂斷詞器 \u0026#34;my_analyzer\u0026#34;: { // 斷詞器名稱 \u0026#34;tokenizer\u0026#34;: \u0026#34;ik_max_word\u0026#34;, \u0026#34;filter\u0026#34;: \u0026#34;py\u0026#34; } }, \u0026#34;filter\u0026#34;: { // 自訂詞元分析器過濾器 \u0026#34;py\u0026#34;: { // 過濾器名稱 \u0026#34;type\u0026#34;: \u0026#34;pinyin\u0026#34;, // 過濾器類型 // 配置項目在Github上有說明 \u0026#34;keep_full_pinyin\u0026#34;: false, \u0026#34;keep_joined_full_pinyin\u0026#34;: true, \u0026#34;keep_original\u0026#34;: true, \u0026#34;limit_first_letter_length\u0026#34;: 16, \u0026#34;remove_duplicated_term\u0026#34;: true, \u0026#34;none_chinese_pinyin_tokenize\u0026#34;: false } } } }, \u0026#34;mappings\u0026#34;: { \u0026#34;properties\u0026#34;: { \u0026#34;name\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;text\u0026#34;, \u0026#34;analyzer\u0026#34;: \u0026#34;my_analyzer\u0026#34;, \u0026#34;search_analyzer\u0026#34;: \u0026#34;ik_smart\u0026#34; } } } } 測試：\n1 2 3 4 5 6 # 測試自訂斷詞器 POST /test/_analyze { \u0026#34;text\u0026#34;: \u0026#34;世界第一可爱\u0026#34;, \u0026#34;analyzer\u0026#34;: \u0026#34;my_analyzer\u0026#34; } 自動補齊查詢 Elasticsearch 提供了 Completion Suggester 查詢來實現自動補齊功能。這個查詢會匹配以使用者輸入內容開頭的詞彙並回傳。為了提高補齊查詢的效率，對於文件中的欄位類型有一些限制：\n參與補齊查詢的欄位必須是 completion 類型 欄位的內容一般是為了補齊而由多個詞彙組成的陣列。 建立測試索引庫：\n1 2 3 4 5 6 7 8 9 10 PUT /test { \u0026#34;mappings\u0026#34;: { \u0026#34;properties\u0026#34;: { \u0026#34;title\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;completion\u0026#34; } } } } 插入測試資料：\n1 2 3 4 5 6 7 8 9 10 11 12 13 # 範例資料 POST /test/_doc { \u0026#34;title\u0026#34;: [\u0026#34;Sony\u0026#34;, \u0026#34;WH-1000XM3\u0026#34;] } POST /test/_doc { \u0026#34;title\u0026#34;: [\u0026#34;SK-II\u0026#34;, \u0026#34;PITERA\u0026#34;] } POST /test/_doc { \u0026#34;title\u0026#34;: [\u0026#34;Nintendo\u0026#34;, \u0026#34;switch\u0026#34;] } 查詢：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 自動補齊查詢 GET /test/_search { \u0026#34;suggest\u0026#34;: { \u0026#34;title_suggest\u0026#34;: { \u0026#34;text\u0026#34;: \u0026#34;s\u0026#34;, // 關鍵字 \u0026#34;completion\u0026#34;: { \u0026#34;field\u0026#34;: \u0026#34;title\u0026#34;, // 自動補齊查詢的欄位 \u0026#34;skip_duplicates\u0026#34;: true, // 跳過重複 \u0026#34;size\u0026#34;: 10 // 取得前10筆資料 } } } } 自動補齊 Java 上述 DSL 的 Java 請求：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @Test public void testAutoIn(){ SearchRequest request = new SearchRequest(\u0026#34;hotel\u0026#34;); // 請求參數 request.source() .suggest(new SuggestBuilder().addSuggestion( \u0026#34;title_suggest\u0026#34;, // 查詢名稱 SuggestBuilders .completionSuggestion(\u0026#34;title\u0026#34;) // 自動補齊查詢的欄位 .prefix(\u0026#34;s\u0026#34;) // 關鍵字 .skipDuplicates(true) // 跳過重複 .size(10) // 取得前10筆資料 )); // 送出請求 SearchResponse response = client.search(request, RequestOptions.DEFAULT); } 回應處理：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 @Test public void testAutoIn(){ SearchRequest request = new SearchRequest(\u0026#34;hotel\u0026#34;); // 請求參數 request.source() .suggest(new SuggestBuilder().addSuggestion( \u0026#34;mySuggestion\u0026#34;, SuggestBuilders .completionSuggestion(\u0026#34;suggestion\u0026#34;) .prefix(\u0026#34;h\u0026#34;) .skipDuplicates(true) .size(10) )); // 送出請求 try { SearchResponse response = client.search(request, RequestOptions.DEFAULT); // 處理回應 Suggest suggest = response.getSuggest(); // 根據名稱取得補齊結果 CompletionSuggestion mySuggestion = suggest.getSuggestion(\u0026#34;mySuggestion\u0026#34;); // 取得options並遍歷 for (CompletionSuggestion.Entry.Option option : mySuggestion.getOptions()) { String text = option.getText().string(); System.out.println(text); } } catch (IOException e) { throw new RuntimeException(e); } } 飯店搜尋自動補齊 之前的 hotel 索引庫未設定拼音斷詞器，但索引庫無法修改，因此需要刪除並重建。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 # 刪除並重建 DELETE /hotel PUT /hotel { \u0026#34;settings\u0026#34;: { \u0026#34;analysis\u0026#34;: { \u0026#34;analyzer\u0026#34;: { \u0026#34;text_analyzer\u0026#34;: { \u0026#34;tokenizer\u0026#34;: \u0026#34;ik_max_word\u0026#34;, \u0026#34;filter\u0026#34;: \u0026#34;py\u0026#34; }, \u0026#34;completion_analyzer\u0026#34;: { \u0026#34;tokenizer\u0026#34;: \u0026#34;keyword\u0026#34;, \u0026#34;filter\u0026#34;: \u0026#34;py\u0026#34; } }, \u0026#34;filter\u0026#34;: { \u0026#34;py\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;pinyin\u0026#34;, \u0026#34;keep_full_pinyin\u0026#34;: false, \u0026#34;keep_joined_full_pinyin\u0026#34;: true, \u0026#34;keep_original\u0026#34;: true, \u0026#34;limit_first_letter_length\u0026#34;: 16, \u0026#34;remove_duplicated_term\u0026#34;: true, \u0026#34;none_chinese_pinyin_tokenize\u0026#34;: false } } } }, \u0026#34;mappings\u0026#34;: { \u0026#34;properties\u0026#34;: { \u0026#34;id\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;keyword\u0026#34; }, \u0026#34;name\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;text\u0026#34;, \u0026#34;analyzer\u0026#34;: \u0026#34;text_analyzer\u0026#34;, \u0026#34;search_analyzer\u0026#34;: \u0026#34;ik_smart\u0026#34;, \u0026#34;copy_to\u0026#34;: \u0026#34;all\u0026#34; }, \u0026#34;address\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;keyword\u0026#34;, \u0026#34;index\u0026#34;: false }, \u0026#34;price\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;integer\u0026#34; }, \u0026#34;score\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;integer\u0026#34; }, \u0026#34;brand\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;keyword\u0026#34;, \u0026#34;copy_to\u0026#34;: \u0026#34;all\u0026#34; }, \u0026#34;city\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;keyword\u0026#34; }, \u0026#34;starName\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;keyword\u0026#34; }, \u0026#34;business\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;keyword\u0026#34;, \u0026#34;copy_to\u0026#34;: \u0026#34;all\u0026#34; }, \u0026#34;location\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;geo_point\u0026#34; }, \u0026#34;pic\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;keyword\u0026#34;, \u0026#34;index\u0026#34;: false }, \u0026#34;all\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;text\u0026#34;, \u0026#34;analyzer\u0026#34;: \u0026#34;text_analyzer\u0026#34;, \u0026#34;search_analyzer\u0026#34;: \u0026#34;ik_smart\u0026#34; }, \u0026#34;suggestion\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;completion\u0026#34;, \u0026#34;analyzer\u0026#34;: \u0026#34;completion_analyzer\u0026#34; } } } } 修改 HotelDoc 實體類別，新增 suggestion 欄位：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 @Data @NoArgsConstructor public class HotelDoc { private Long id; private String name; private String address; private Integer price; private Integer score; private String brand; private String city; private String starName; private String business; private String location; private String pic; private Object distance; // 廣告 private Boolean isAD; // 自動補齊 private List\u0026lt;String\u0026gt; suggestion; public HotelDoc(Hotel hotel) { this.id = hotel.getId(); this.name = hotel.getName(); this.address = hotel.getAddress(); this.price = hotel.getPrice(); this.score = hotel.getScore(); this.brand = hotel.getBrand(); this.city = hotel.getCity(); this.starName = hotel.getStarName(); this.business = hotel.getBusiness(); this.location = hotel.getLatitude() + \u0026#34;, \u0026#34; + hotel.getLongitude(); this.pic = hotel.getPic(); // 組裝 suggestion if(this.business.contains(\u0026#34;/\u0026#34;)){ // business 有多個值，需要切割 String[] arr = this.business.split(\u0026#34;/\u0026#34;); // 新增元素 this.suggestion = new ArrayList\u0026lt;\u0026gt;(); this.suggestion.add(this.brand); Collections.addAll(this.suggestion, arr); }else { this.suggestion = Arrays.asList(this.brand, this.business); } } } 重新匯入資料：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 @Test public void testBulk() throws IOException { // 批次查詢資料 List\u0026lt;Hotel\u0026gt; hotelList = hotelService.list(); // 建立 bulk 請求 BulkRequest request = new BulkRequest(); // 新增批次請求 for (Hotel hotel : hotelList) { // 轉換文件類型 HotelDoc hotelDoc = new HotelDoc(hotel); // 建立新增文件 request 物件 request.add(new IndexRequest(\u0026#34;hotel\u0026#34;) .id(hotelDoc.getId().toString()) .source(JSON.toJSONString(hotelDoc), XContentType.JSON) ); } // 送出 bulk 請求 client.bulk(request, RequestOptions.DEFAULT); } 查詢測試：\n1 2 3 4 5 6 GET /hotel/_search { \u0026#34;query\u0026#34;: { \u0026#34;match_all\u0026#34;: {} } } 可以看到查詢結果的 suggestion 欄位，接著編寫業務程式碼。\nController：\n1 2 3 4 @GetMapping(\u0026#34;/suggestion\u0026#34;) public List\u0026lt;String\u0026gt; getSuggestion(@RequestParam(\u0026#34;key\u0026#34;) String prefix){ return hotelService.getSuggestion(prefix); } Service：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 public List\u0026lt;String\u0026gt; getSuggestion(String prefix) { SearchRequest request = new SearchRequest(\u0026#34;hotel\u0026#34;); request.source().suggest( new SuggestBuilder().addSuggestion( \u0026#34;mySuggestion\u0026#34;, SuggestBuilders .completionSuggestion(\u0026#34;suggestion\u0026#34;) .prefix(prefix) .size(10) .skipDuplicates(true) ) ); try { SearchResponse response = client.search(request, RequestOptions.DEFAULT); Suggest suggestions = response.getSuggest(); CompletionSuggestion mySuggestion = suggestions.getSuggestion(\u0026#34;mySuggestion\u0026#34;); List\u0026lt;CompletionSuggestion.Entry.Option\u0026gt; options = mySuggestion.getOptions(); ArrayList\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(options.size()); for (CompletionSuggestion.Entry.Option option : options) { String text = option.getText().string(); list.add(text); } return list; } catch (IOException e) { throw new RuntimeException(e); } } ","date":"2025-02-09T17:29:28+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/232/","title":"Elasticsearch 自動補齊"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 Elasticsearch 系列\n內容 連結 Elasticsearch 基礎操作 https://blog.yexca.net/zh-tw/archives/226 Elasticsearch 查詢操作 https://blog.yexca.net/zh-tw/archives/227 RestClient 基礎操作 https://blog.yexca.net/zh-tw/archives/228 RestClient 查詢操作 https://blog.yexca.net/zh-tw/archives/229 Elasticsearch 資料聚合 本文 Elasticsearch 自動補齊 https://blog.yexca.net/zh-tw/archives/232 Elasticsearch 資料同步 https://blog.yexca.net/zh-tw/archives/234 Elasticsearch 叢集 https://blog.yexca.net/zh-tw/archives/235 聚合 (aggregations) 可以讓我們極其方便地實現對資料的統計、分析、運算。例如：\n什麼品牌的行動電話最受歡迎？ 這些行動電話的平均價格、最高價格、最低價格？ 這些行動電話每月的銷售情況如何？ 聚合的種類 常見的有三類：\n桶 (bucket) 聚合：用來對文件做分組 TermAggregation：依照文件欄位值分組，例如依照品牌、國家分組 Date Histogram：依照日期階梯分組，例如一週或一月為一組 度量 (metric) 聚合：用以計算一些最大值、最小值、平均值等 Avg：平均值 Max：最大值 Min：最小值 Stats：同時求 max、min、avg、sum 等 管道 (pipeline) 聚合：其他聚合的結果為基礎做聚合 參與聚合的欄位必須是 keyword、日期、數值、布林類型\nDSL 聚合語句 bucket 統計所有資料中飯店的品牌有幾種，即依品牌對資料分組\n1 2 3 4 5 6 7 8 9 10 11 12 13 # bucket term GET /hotel/_search { \u0026#34;size\u0026#34;: 0, // 設定size為0，結果中不包含文件，只包含聚合結果 \u0026#34;aggs\u0026#34;: { \u0026#34;brandAgg\u0026#34;: { // 聚合名稱 \u0026#34;terms\u0026#34;: { // 聚合類型 \u0026#34;field\u0026#34;: \u0026#34;brand\u0026#34;, // 參與聚合欄位 \u0026#34;size\u0026#34;: 20 // 取得的聚合結果數量 } } } } 聚合結果排序 預設情況下，bucket 聚合會統計 bucket 內的文件數量，記為 count，並且依 count 降序排序。透過指定 order 屬性，自訂聚合的排序方式\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 GET /hotel/_search { \u0026#34;size\u0026#34;: 0, \u0026#34;aggs\u0026#34;: { \u0026#34;brandAgg\u0026#34;: { \u0026#34;terms\u0026#34;: { \u0026#34;field\u0026#34;: \u0026#34;brand\u0026#34;, \u0026#34;size\u0026#34;: 20, \u0026#34;order\u0026#34;: { // 排序 \u0026#34;_count\u0026#34;: \u0026#34;asc\u0026#34; } } } } } 限定聚合範圍 預設情況下會對索引庫所有文件聚合，但實際使用時，使用者會輸入搜尋條件，因此聚合必須是對搜尋結果的聚合，聚合就必須要新增限定條件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # bucket query GET /hotel/_search { \u0026#34;query\u0026#34;: { \u0026#34;range\u0026#34;: { \u0026#34;price\u0026#34;: { \u0026#34;lte\u0026#34;: 200 // 只對價格小於200的文件聚合 } } }, \u0026#34;size\u0026#34;: 0, \u0026#34;aggs\u0026#34;: { \u0026#34;brandAggQuery\u0026#34;: { \u0026#34;terms\u0026#34;: { \u0026#34;field\u0026#34;: \u0026#34;brand\u0026#34;, \u0026#34;size\u0026#34;: 20 } } } } Metric 上述 bucket 聚合依品牌分組，現在要取得每個品牌使用者評分的 min、max、avg\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # metric GET /hotel/_search { \u0026#34;size\u0026#34;: 0, \u0026#34;aggs\u0026#34;: { \u0026#34;brandAgg\u0026#34;: { \u0026#34;terms\u0026#34;: { \u0026#34;field\u0026#34;: \u0026#34;brand\u0026#34;, \u0026#34;size\u0026#34;: 20 }, \u0026#34;aggs\u0026#34;: { // bucket的子聚合，對分組後每個組運算 \u0026#34;scoreStats\u0026#34;: { // 聚合名稱 \u0026#34;stats\u0026#34;: { // 聚合類型 \u0026#34;field\u0026#34;: \u0026#34;score\u0026#34; // 聚合欄位 } } } } } } 依照平均值排序\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 GET /hotel/_search { \u0026#34;size\u0026#34;: 0, \u0026#34;aggs\u0026#34;: { \u0026#34;brandAgg\u0026#34;: { \u0026#34;terms\u0026#34;: { \u0026#34;field\u0026#34;: \u0026#34;brand\u0026#34;, \u0026#34;size\u0026#34;: 20, \u0026#34;order\u0026#34;: { \u0026#34;scoreStats.avg\u0026#34;: \u0026#34;desc\u0026#34; // 平均值降序 } }, \u0026#34;aggs\u0026#34;: { \u0026#34;scoreStats\u0026#34;: { \u0026#34;stats\u0026#34;: { \u0026#34;field\u0026#34;: \u0026#34;score\u0026#34; } } } } } } RestAPI 聚合 語法 聚合條件與 query 同級，因此使用 request.source() 指定聚合條件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 @Test public void testAggTerm() throws IOException { SearchRequest request = new SearchRequest(\u0026#34;hotel\u0026#34;); request.source().size(0); request.source().aggregation( AggregationBuilders .terms(\u0026#34;brandAgg\u0026#34;) .field(\u0026#34;brand\u0026#34;) .size(20) ); SearchResponse response = client.search(request, RequestOptions.DEFAULT); } 回應處理\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 @Test public void testAggTerm() throws IOException { SearchRequest request = new SearchRequest(\u0026#34;hotel\u0026#34;); request.source().size(0); request.source().aggregation( AggregationBuilders .terms(\u0026#34;brandAgg\u0026#34;) .field(\u0026#34;brand\u0026#34;) .size(20) ); SearchResponse response = client.search(request, RequestOptions.DEFAULT); // 解析聚合結果 Aggregations aggregations = response.getAggregations(); // 依名稱取得聚合結果 Terms term = aggregations.get(\u0026#34;brandAgg\u0026#34;); // 取得bucket List\u0026lt;? extends Terms.Bucket\u0026gt; buckets = term.getBuckets(); // 遍歷 for (Terms.Bucket bucket : buckets) { // 取得key String name = bucket.getKeyAsString(); System.out.println(name); } } 範例需求 前端頁面的城市、星級、品牌都是固定供選擇的，不會隨著搜尋輸入而改變\n但是假如搜尋 \u0026ldquo;東方明珠\u0026rdquo;，那城市只能是上海，不應該顯示其他城市\n也就是可供選擇的城市等應該隨著搜尋輸入的內容改變，為此，前端需要依照內容請求可選城市，假設介面如下：\n請求方式：POST 請求路徑：/hotel/filters 請求參數：RequestParams，與搜尋文件的參數一致 回傳值類型：Map\u0026lt;String, List\u0026lt;String\u0026gt;\u0026gt; Controller\n1 2 3 4 @PostMapping(\u0026#34;/filters\u0026#34;) public Map\u0026lt;String, List\u0026lt;String\u0026gt;\u0026gt; getFilters(@RequestBody RequestParams params){ return hotelService.getFilters(params); } Service\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 public Map\u0026lt;String, List\u0026lt;String\u0026gt;\u0026gt; getFilters(RequestParams params) { // 請求 SearchRequest request = new SearchRequest(\u0026#34;hotel\u0026#34;); // DSL basicQuery(params, request); // 設定size request.source().size(0); // 聚合 request.source().aggregation( AggregationBuilders .terms(\u0026#34;brandAgg\u0026#34;) .field(\u0026#34;brand\u0026#34;) .size(100) ); request.source().aggregation( AggregationBuilders .terms(\u0026#34;cityAgg\u0026#34;) .field(\u0026#34;city\u0026#34;) .size(100) ); request.source().aggregation( AggregationBuilders .terms(\u0026#34;starAgg\u0026#34;) .field(\u0026#34;starName\u0026#34;) .size(100) ); // 請求 try { SearchResponse response = client.search(request, RequestOptions.DEFAULT); // 解析回應 Map\u0026lt;String, List\u0026lt;String\u0026gt;\u0026gt; result = new HashMap\u0026lt;\u0026gt;(); Aggregations aggregations = response.getAggregations(); // 品牌 List\u0026lt;String\u0026gt; brandList = getAggName(aggregations, \u0026#34;brandAgg\u0026#34;); result.put(\u0026#34;品牌\u0026#34;, brandList); // 城市 List\u0026lt;String\u0026gt; cityList = getAggName(aggregations, \u0026#34;cityAgg\u0026#34;); result.put(\u0026#34;城市\u0026#34;, cityList); // 星級 List\u0026lt;String\u0026gt; starList = getAggName(aggregations, \u0026#34;starAgg\u0026#34;); result.put(\u0026#34;星級\u0026#34;, starList); return result; } catch (IOException e) { throw new RuntimeException(e); } } private static List\u0026lt;String\u0026gt; getAggName(Aggregations aggregations, String name) { // 取得品牌 Terms brand = aggregations.get(name); // 取得bucket List\u0026lt;? extends Terms.Bucket\u0026gt; buckets = brand.getBuckets(); // 遍歷 List\u0026lt;String\u0026gt; brandList = new ArrayList\u0026lt;\u0026gt;(); for (Terms.Bucket bucket : buckets) { // 取得key String key = bucket.getKeyAsString(); brandList.add(key); } return brandList; } ","date":"2025-02-08T14:56:36+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/231/","title":"Elasticsearch 資料聚合"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 音有所感系列 歌曲名稱 翻譯 連結 僕が死のうと思ったのは 曾經我也想過一了百了 https://blog.yexca.net/zh-tw/archives/214 あくあ色ぱれっと aqua 的調色盤 https://blog.yexca.net/zh-tw/archives/219 恋の押し売り 戀愛推銷 https://blog.yexca.net/zh-tw/archives/220 17さいのうた 17 歲的歌 https://blog.yexca.net/zh-tw/archives/224 drop 墜入愛河 本文 生きるを選んだ私へ 致選擇活下去的自己 https://blog.yexca.net/zh-tw/archives/239 rainy lady 雨意未晴 https://blog.yexca.net/zh-tw/archives/249 恋しくなったら手を叩こう 想談戀愛的話就拍拍手吧 https://blog.yexca.net/zh-tw/archives/250 pris-magic! 稜鏡魔法! https://blog.yexca.net/zh-tw/archives/260 引言 今天試著做了 2019 年 12 月的 N1 試卷，居然不小心就合格了，突然激發了我想寫一篇學日語的文章，就是這個系列啦！\n選歌的時候有點煩惱，因為最近我都在聽音樂 (我通常把有人聲的叫做歌曲，無人聲的叫做音樂)，這玩意也寫不了啊。\n試著找了 YouTube Music 每個季節最常聽的歌曲，但都不怎麼適合單曲循環 (單聽可以，但沒喜歡到可以一直循環的地步)，翻看紀錄發現了這首歌。\n說到這首歌，可能是我第一首沒看歌詞卻聽懂最多內容的歌了 (有點矛盾，但這不重要)，以前也多次循環播放過，可以說是直接讓我以此為契機去認識潤羽るしあ了 (雖然已經終止活動了)，怎麼會有這麼甜的歌呢，超愛啦！\n歌曲影片 歌詞 夢の中で君と過ごしても\n即使在夢中和你共度時光\nまた覚めるたび君が離れないの\n每次醒來你還是在我心裡\n退屈なベッドで1人きり\n獨自一人躺在無聊的床上\nあぁ 迎えに来てよ王子様\n啊~，快來接我吧，王子大人\n君を知りたい 気持ちもどかしい\n想要了解你，心情也焦急不安\nいっそシャボン玉になって弾けたい\n想化作泡泡，在一瞬間綻放\nあぁ 君が好き なんて言えない\n啊~，好喜歡你，但說不出口\nたまに冷たい 君がわかんない\n偶爾冷漠的你真的搞不懂\n君の場所びゅーんと飛んでって\n一下子飛到你的所在位置\nアニメみたいに2人恋に落ちて\n像動畫那樣兩個人墜入愛河\nくすぐったいくらいに君のこと\n想到你時，連心都癢癢的\n考える1人の夜がいいの\n獨自一人想你的夜晚也不錯\nふわふわと浮かぶ甘い心\n輕飄飄的甜甜的心\n頭離れない君は悪い男？\n無法移開視線的你其實是個壞男人嗎？\nわからないことにもやもやして\n不知道的事情也不用管啦\n夢でも君のことを考えて\n夢中也要想著你\nあぁ いじけちゃって嫌になっても 考えちゃう\n啊~，即使悶悶不樂，煩到不行，還是忍不住去想你\nねぇ 優しかったり冷たくなったり 迷路みたい\n欸，你時而溫柔時而冷漠，真是搞不懂\nあぁ 攻略サイトも見当たらないから やり直しばかり\n啊~，就連攻略網站也找不到，只能一遍遍嘗試了\nもー知らないもんって強がり\n只好逞強地說「我才不想理你」\nでも嫌いになんてなれるわけもない\n但也不是討厭你的意思啦\nそう思うほど胸も痛くなる愛\n越想越覺得心好痛\n私の恋のキュービットは\n我的戀愛邱比特\nいつになったら現れるの\n到底什麼時候才會出現啊\n夢の中で君と過ごしても\n即使在夢中和你共度時光\nまた覚めるたび君が離れないの\n每次醒來你還是在我心裡\n退屈なベッドで1人きり\n獨自一人躺在無聊的床上\nあぁ 迎えに来てよ王子様\n啊~，快來接我吧，王子大人\n君を知りたい 気持ちもどかしい\n想要了解你，心情也焦急不安\nいっそシャボン玉になって弾けたい\n想化作泡泡，在一瞬間綻放\nあぁ 君が好き なんて言えない\n啊~，好喜歡你，但說不出口\nたまに冷たい 君がわかんない\n偶爾冷漠的你真的搞不懂\nひいふうみいよ 数えて\n一、二、三、四，數著\n君につぎ 会える日を楽しみに眠るの\n期待著和你再次相見而入睡\nいつでも会えるよう\n為了能隨時和你相見\n昨日よりもかわいくなるために生きるよ\n我要努力活得比昨天更可愛\n気付いてくれるかな\n你有沒有注意到我啊\n君の好きなメイクにしてみたとか (どうかな？)\n試試看你喜歡的打扮怎麼樣 (好不好啊？)\n少し重すぎかな\n會不會有點太誇張了？\n優柔不断で何も決まんないや (もう)\n猶豫不決，什麼都決定不了 (吼)\n可愛くなれるかな\n可以變得更可愛嗎\n君の前だとチークはいらないか (ねえ ねえ)\n和你在一起就不用畫腮紅了 (欸，欸)\n私と同じかな\n和我一樣嗎\nこの気持ち君も同じだといいな\n如果這個心意你也一樣該有多好啊\n夢の中で君と過ごしても\n即使在夢中和你共度時光\nまた覚めるたび君が離れないの\n每次醒來你還是在我心裡\n退屈なベッドで1人きり\n獨自一人躺在無聊的床上\nあぁ 迎えに来てよ王子様\n啊~，快來接我吧，王子大人\n君を知りたい 気持ちもどかしい\n想要了解你，心情也焦急不安\nいっそシャボン玉になって弾けたい\n想化作泡泡，在一瞬間綻放\nあぁ 君が好き なんて言えない\n啊~，好喜歡你，但說不出口\nたまに冷たい 君がわかんない\n偶爾冷漠的你真的搞不懂\nふわふわな気持ちを隠しても\n就算想遮掩自己輕飄飄的心情\n君の眼を見るとまた零こぼれるちゃうよ\n看向你的眼睛時也會忍不住流露出來\n味のないケーキも君となら\n就算沒味道的蛋糕，只要是跟你在一起\n大好きな時間に変わってく\n也會變成我最喜歡的時光\n君を知りたい もっと知りたい\n想要了解你，更多地了解你\n好きの2文字が口から出せない\n「喜歡」這兩個字卻說不出來\nあぁ 君が好き を隠した日々\n啊~，好喜歡你，每天藏著這份心情\nたまに冷たい 君も愛いとおしい\n偶爾冷漠的你也很迷人\n","date":"2025-02-06T22:06:10+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/230/","title":"音有所感 - 《drop》"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 Elasticsearch 系列\n內容 連結 Elasticsearch 基礎操作 https://blog.yexca.net/zh-tw/archives/226 Elasticsearch 查詢操作 https://blog.yexca.net/zh-tw/archives/227 RestClient 基礎操作 https://blog.yexca.net/zh-tw/archives/228 RestClient 查詢操作 本文 Elasticsearch 資料彙總 https://blog.yexca.net/zh-tw/archives/231 Elasticsearch 自動補齊 https://blog.yexca.net/zh-tw/archives/232 Elasticsearch 資料同步 https://blog.yexca.net/zh-tw/archives/234 Elasticsearch 叢集 https://blog.yexca.net/zh-tw/archives/235 文件的查詢相同地使用 RestHighLevelClient 物件\nmatch_all 發出請求如下：\n1 2 3 4 5 6 7 8 9 10 11 @Test public void testMatchAll() throws IOException { // 準備request SearchRequest request = new SearchRequest(\u0026#34;hotel\u0026#34;); // 組織DSL參數 request.source().query(QueryBuilders.matchAllQuery()); // 傳送請求 SearchResponse response = client.search(request, RequestOptions.DEFAULT); System.out.println(response); } 解析回應\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 @Test public void testMatchAll() throws IOException { // 準備request SearchRequest request = new SearchRequest(\u0026#34;hotel\u0026#34;); // 組織DSL參數 request.source().query(QueryBuilders.matchAllQuery()); // 傳送請求 SearchResponse response = client.search(request, RequestOptions.DEFAULT); // 解析結果 SearchHits searchHits = response.getHits(); // 查詢的總筆數 long total = searchHits.getTotalHits().value; // 查詢結果陣列 SearchHit[] hits = searchHits.getHits(); for (SearchHit hit : hits) { String json = hit.getSourceAsString(); System.out.println(json); } } es 回傳的結果是一個 JSON 字串，包含：\nhits：命中結果 total：總筆數，其中 value 是具體的總筆數值 max_score：所有結果中得分最高的文件的相關性分數 hits：搜尋結果的文件陣列，其中的每個文件都是一個 JSON 物件 source：文件中的原始資料，也是 JSON 物件 因此，解析回應結果，就是逐層解析 JSON 字串，流程如下：\nSearchHits：透過 response.getHits() 取得，就是 JSON 中的最外層 hits，代表命中的結果 SearchHits.getTotalHits().value：取得總筆數資訊 SearchHits.getHits()：取得 SearchHit 陣列，也就是文件陣列 SearchHit.getSourceAsString()：取得文件結果中的 _source，也就是原始的 JSON 文件資料 match 與 multi_match 與 match_all 類似，差別在於查詢條件\nmatch 程式碼\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Test public void testMatch() throws IOException { SearchRequest request = new SearchRequest(\u0026#34;hotel\u0026#34;); request.source().query(QueryBuilders.matchQuery(\u0026#34;all\u0026#34;, \u0026#34;如家\u0026#34;)); SearchResponse response = client.search(request, RequestOptions.DEFAULT); SearchHits searchHits = response.getHits(); long total = searchHits.getTotalHits().value; System.out.println(total); SearchHit[] hits = searchHits.getHits(); for (SearchHit hit : hits) { String json = hit.getSourceAsString(); System.out.println(json); } } multi_match 程式碼\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Test public void testMultiMatch() throws IOException { SearchRequest request = new SearchRequest(\u0026#34;hotel\u0026#34;); request.source().query(QueryBuilders.multiMatchQuery(\u0026#34;如家\u0026#34;, \u0026#34;brand\u0026#34;, \u0026#34;name\u0026#34;)); SearchResponse response = client.search(request, RequestOptions.DEFAULT); SearchHits searchHits = response.getHits(); long total = searchHits.getTotalHits().value; System.out.println(total); SearchHit[] hits = searchHits.getHits(); for (SearchHit hit : hits) { String json = hit.getSourceAsString(); System.out.println(json); } } 可以看到程式碼重複部分較多，使用 Ctrl+Alt+M 進行程式碼提取，term 程式碼展現了提取\n精準查詢 term 詞條精確比對查詢\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 @Test public void testTerm() throws IOException { SearchRequest request = new SearchRequest(\u0026#34;hotel\u0026#34;); request.source().query(QueryBuilders.termQuery(\u0026#34;city\u0026#34;, \u0026#34;上海\u0026#34;)); SearchResponse response = client.search(request, RequestOptions.DEFAULT); responseHandle(response); } // 回應處理程式碼提取 private static void responseHandle(SearchResponse response) { SearchHits searchHits = response.getHits(); long total = searchHits.getTotalHits().value; System.out.println(total); SearchHit[] hits = searchHits.getHits(); for (SearchHit hit : hits) { String json = hit.getSourceAsString(); System.out.println(json); } } range 範圍查詢\n1 2 3 4 5 6 7 8 9 10 11 @Test public void testRange() throws IOException { SearchRequest request = new SearchRequest(\u0026#34;hotel\u0026#34;); request.source().query(QueryBuilders .rangeQuery(\u0026#34;price\u0026#34;) .gte(100) .lte(400)); SearchResponse response = client.search(request, RequestOptions.DEFAULT); responseHandle(response); } 布林查詢 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @Test public void testBool() throws IOException { SearchRequest request = new SearchRequest(\u0026#34;hotel\u0026#34;); // 建構布林查詢 BoolQueryBuilder booledQuery = QueryBuilders.boolQuery(); // 加入must條件 booledQuery.must(QueryBuilders.termQuery(\u0026#34;city\u0026#34;, \u0026#34;上海\u0026#34;)); // 加入filter元件 booledQuery.filter(QueryBuilders.rangeQuery(\u0026#34;price\u0026#34;).lte(300)); request.source().query(booledQuery); SearchResponse response = client.search(request, RequestOptions.DEFAULT); responseHandle(response); } 排序與分頁 1 2 3 4 5 6 7 8 9 10 @Test public void testSort() throws IOException { SearchRequest request = new SearchRequest(\u0026#34;hotel\u0026#34;); request.source().query(QueryBuilders.matchAllQuery()); request.source().from(10).size(10); request.source().sort(\u0026#34;price\u0026#34;, SortOrder.ASC); SearchResponse response = client.search(request, RequestOptions.DEFAULT); responseHandle(response); } 高亮 高亮與上述程式碼差異較大，請求建構\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @Test public void testHigh() throws IOException { SearchRequest request = new SearchRequest(\u0026#34;hotel\u0026#34;); // DSL request.source().query(QueryBuilders.matchQuery(\u0026#34;all\u0026#34;, \u0026#34;漢庭\u0026#34;)); // 高亮 request.source().highlighter( new HighlightBuilder() .field(\u0026#34;name\u0026#34;) .requireFieldMatch(false) ); // 傳送請求 SearchResponse response = client.search(request, RequestOptions.DEFAULT); // 解析 responseHandle(response); } 因為查詢文件結果與高亮分離，結果解析需要額外處理\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 @Test public void testHigh() throws IOException { SearchRequest request = new SearchRequest(\u0026#34;hotel\u0026#34;); // DSL request.source().query(QueryBuilders.matchQuery(\u0026#34;all\u0026#34;, \u0026#34;漢庭\u0026#34;)); // 高亮 request.source().highlighter( new HighlightBuilder() .field(\u0026#34;name\u0026#34;) .requireFieldMatch(false) ); // 傳送請求 SearchResponse response = client.search(request, RequestOptions.DEFAULT); // 解析 SearchHits searchHits = response.getHits(); // 總筆數 long total = searchHits.getTotalHits().value; System.out.println(total); // 文件陣列 SearchHit[] hits = searchHits.getHits(); for (SearchHit hit : hits) { String json = hit.getSourceAsString(); // 反序列化 HotelDoc hotelDoc = JSON.parseObject(json, HotelDoc.class); // 取得高亮結果 Map\u0026lt;String, HighlightField\u0026gt; highlightFields = hit.getHighlightFields(); if(!CollectionUtils.isEmpty(highlightFields)){ // 取得高亮結果 HighlightField highlightField = highlightFields.get(\u0026#34;name\u0026#34;); if (highlightField != null){ String name = highlightField.getFragments()[0].toString(); // 覆寫非高亮 hotelDoc.setName(name); } } System.out.println(hotelDoc); } } 飯店查詢案例 實現四部分功能：\n飯店搜尋與分頁 飯店結果篩選 我周邊的飯店 飯店競價排名 搜尋與分頁 搜尋請求：\n請求方式：POST 請求路徑：/hotel/list 請求參數：JSON 物件，包含 4 個欄位： key：搜尋關鍵字 page：頁碼 size：每頁大小 sortBy：排序，目前暫不實作 回傳值：分頁查詢，需要回傳分頁結果 PageResult，包含兩個屬性： total：總筆數 List\u0026lt;HotelDoc\u0026gt;：當前頁的資料 首先定義實體類別，接收參數\n1 2 3 4 5 6 7 @Data public class RequestParams { private String key; private Integer page; private Integer size; private String sortBy; } 定義回傳類別\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 @Data public class PageResult { private Long total; private List\u0026lt;HotelDoc\u0026gt; hotels; public PageResult(){ } public PageResult(Long total, List\u0026lt;HotelDoc\u0026gt; hotels) { this.total = total; this.hotels = hotels; } } 定義 Controller\n1 2 3 4 5 6 7 8 9 10 11 @RestController @RequestMapping(\u0026#34;/hotel\u0026#34;) public class HotelController { @Autowired private IHotelService hotelService; @PostMapping(\u0026#34;/list\u0026#34;) public PageResult search(@RequestBody RequestParams params){ return hotelService.search(params); } } 實作搜尋業務，首先註冊一個 Bean 物件\n1 2 3 4 5 6 @Bean public RestHighLevelClient client(){ return new RestHighLevelClient(RestClient .builder(HttpHost.create(\u0026#34;http://ip:9200\u0026#34;) )); } 撰寫邏輯\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 public PageResult search(RequestParams params) { // request SearchRequest request = new SearchRequest(\u0026#34;hotel\u0026#34;); BoolQueryBuilder boolQuery = QueryBuilders.boolQuery(); // DSL String key = params.getKey(); if (key == null || \u0026#34;\u0026#34;.equals(key)){ boolQuery.must(QueryBuilders.matchAllQuery()); }else { boolQuery.must(QueryBuilders.matchQuery(\u0026#34;all\u0026#34;, key)); } // 分頁 int page = params.getPage(); int size = params.getSize(); request.source().from((page - 1) * size).size(size); // 查詢 request.source().query(boolQuery); // 傳送請求 try { SearchResponse response = client.search(request, RequestOptions.DEFAULT); // 回應解析 SearchHits searchHits = response.getHits(); // 總數 long total = searchHits.getTotalHits().value; // 文件 SearchHit[] hits = searchHits.getHits(); // 遍歷 List\u0026lt;HotelDoc\u0026gt; hotels = new ArrayList\u0026lt;\u0026gt;(); for (SearchHit hit : hits) { String json = hit.getSourceAsString(); HotelDoc hotelDoc = JSON.parseObject(json, HotelDoc.class); hotels.add(hotelDoc); } return new PageResult(total, hotels); } catch (IOException e) { throw new RuntimeException(e); } } 結果篩選 包含的篩選條件：\nbrand：品牌值 city：城市 minPrice~maxPrice：價格範圍 starName：星級 修改實體類別\n1 2 3 4 5 6 7 8 9 10 11 12 13 @Data public class RequestParams { private String key; private Integer page; private Integer size; private String sortBy; // 下面是新增的篩選條件參數 private String city; private String brand; private String starName; private Integer minPrice; private Integer maxPrice; } 修改查詢條件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 @Override public PageResult search(RequestParams params) { // request SearchRequest request = new SearchRequest(\u0026#34;hotel\u0026#34;); basicQuery(params, request); // 分頁 int page = params.getPage(); int size = params.getSize(); request.source().from((page - 1) * size).size(size); // 傳送請求 try { SearchResponse response = client.search(request, RequestOptions.DEFAULT); // 回應解析 SearchHits searchHits = response.getHits(); // 總數 long total = searchHits.getTotalHits().value; // 文件 SearchHit[] hits = searchHits.getHits(); // 遍歷 List\u0026lt;HotelDoc\u0026gt; hotels = new ArrayList\u0026lt;\u0026gt;(); for (SearchHit hit : hits) { String json = hit.getSourceAsString(); HotelDoc hotelDoc = JSON.parseObject(json, HotelDoc.class); hotels.add(hotelDoc); } return new PageResult(total, hotels); } catch (IOException e) { throw new RuntimeException(e); } } private static void basicQuery(RequestParams params, SearchRequest request) { BoolQueryBuilder boolQuery = QueryBuilders.boolQuery(); // 輸入內容 String key = params.getKey(); if (key == null || \u0026#34;\u0026#34;.equals(key)){ boolQuery.must(QueryBuilders.matchAllQuery()); }else { boolQuery.must(QueryBuilders.matchQuery(\u0026#34;all\u0026#34;, key)); } // brand if (params.getBrand() != null \u0026amp;\u0026amp; !params.getBrand().equals(\u0026#34;\u0026#34;)){ boolQuery.filter(QueryBuilders.termQuery(\u0026#34;brand\u0026#34;, params.getBrand())); } // starName if (params.getStarName() != null \u0026amp;\u0026amp; !params.getStarName().equals(\u0026#34;\u0026#34;)){ boolQuery.filter(QueryBuilders.termQuery(\u0026#34;starName\u0026#34;, params.getStarName())); } // city if (params.getCity() != null \u0026amp;\u0026amp; !params.getStarName().equals(\u0026#34;\u0026#34;)){ boolQuery.filter(QueryBuilders.termQuery(\u0026#34;city\u0026#34;, params.getCity())); } // price if (params.getMinPrice() != null \u0026amp;\u0026amp; params.getMaxPrice() != null){ boolQuery.filter(QueryBuilders.rangeQuery(\u0026#34;price\u0026#34;).gte(params.getMinPrice()).lte(params.getMaxPrice())); } // 查詢 request.source().query(boolQuery); } 附近的飯店 基於 location 座標，依距離對周圍的飯店排序\n修改實體類別\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 @Data public class RequestParams { private String key; private Integer page; private Integer size; private String sortBy; private String city; private String brand; private String starName; private Integer minPrice; private Integer maxPrice; // 我目前的地理座標 private String location; } 加入距離排序\n1 2 3 4 5 6 7 8 if (params.getLocation() != null) { // 距離排序 request.source().sort(SortBuilders .geoDistanceSort(\u0026#34;location\u0026#34;, new GeoPoint(params.getLocation())) .order(SortOrder.ASC) .unit(DistanceUnit.KILOMETERS) ); } 距離顯示 修改 HotelDoc，加入距離\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 @Data @NoArgsConstructor public class HotelDoc { private Long id; private String name; private String address; private Integer price; private Integer score; private String brand; private String city; private String starName; private String business; private String location; private String pic; // 距離 private Object distance; public HotelDoc(Hotel hotel) { this.id = hotel.getId(); this.name = hotel.getName(); this.address = hotel.getAddress(); this.price = hotel.getPrice(); this.score = hotel.getScore(); this.brand = hotel.getBrand(); this.city = hotel.getCity(); this.starName = hotel.getStarName(); this.business = hotel.getBusiness(); this.location = hotel.getLatitude() + \u0026#34;, \u0026#34; + hotel.getLongitude(); this.pic = hotel.getPic(); } } 修改回應處理\n1 2 3 4 5 6 7 8 9 10 for (SearchHit hit : hits) { String json = hit.getSourceAsString(); HotelDoc hotelDoc = JSON.parseObject(json, HotelDoc.class); Object[] sortValues = hit.getSortValues(); if (sortValues.length \u0026gt; 0){ Object sortValue = sortValues[0]; hotelDoc.setDistance(sortValue); } hotels.add(hotelDoc); } 加入廣告飯店 需求：讓指定的飯店在搜尋結果中排名置頂\n給指定飯店加入標記，在篩選條件中根據此標記判斷是否提高 function_score\n在 HotelDoc 加入廣告標記欄位\n1 private Boolean isAD; 用 DSL 給一些飯店加入標記\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 # 加入廣告 POST /hotel/_update/607915 { \u0026#34;doc\u0026#34;: { \u0026#34;isAD\u0026#34;: true } } POST /hotel/_update/728461 { \u0026#34;doc\u0026#34;: { \u0026#34;isAD\u0026#34;: true } } POST /hotel/_update/7094829 { \u0026#34;doc\u0026#34;: { \u0026#34;isAD\u0026#34;: true } } POST /hotel/_update/198323591 { \u0026#34;doc\u0026#34;: { \u0026#34;isAD\u0026#34;: true } } 加入算分函式查詢，修改 basicQuery() 方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 private static void basicQuery(RequestParams params, SearchRequest request) { BoolQueryBuilder boolQuery = QueryBuilders.boolQuery(); // 輸入內容 String key = params.getKey(); if (key == null || \u0026#34;\u0026#34;.equals(key)){ boolQuery.must(QueryBuilders.matchAllQuery()); }else { boolQuery.must(QueryBuilders.matchQuery(\u0026#34;all\u0026#34;, key)); } // brand if (params.getBrand() != null \u0026amp;\u0026amp; !params.getBrand().equals(\u0026#34;\u0026#34;)){ boolQuery.filter(QueryBuilders.termQuery(\u0026#34;brand\u0026#34;, params.getBrand())); } // starName if (params.getStarName() != null \u0026amp;\u0026amp; !params.getStarName().equals(\u0026#34;\u0026#34;)){ boolQuery.filter(QueryBuilders.termQuery(\u0026#34;starName\u0026#34;, params.getStarName())); } // city if (params.getCity() != null \u0026amp;\u0026amp; !params.getStarName().equals(\u0026#34;\u0026#34;)){ boolQuery.filter(QueryBuilders.termQuery(\u0026#34;city\u0026#34;, params.getCity())); } // price if (params.getMinPrice() != null \u0026amp;\u0026amp; params.getMaxPrice() != null){ boolQuery.filter(QueryBuilders .rangeQuery(\u0026#34;price\u0026#34;) .gte(params.getMinPrice()) .lte(params.getMaxPrice()) ); } // 算分 function_score FunctionScoreQueryBuilder functionScoreQuery = QueryBuilders.functionScoreQuery( // 原始查詢 boolQuery, // 陣列 new FunctionScoreQueryBuilder.FilterFunctionBuilder[]{ // 其中一個 function score 元素 new FunctionScoreQueryBuilder.FilterFunctionBuilder( // 篩選條件 QueryBuilders.termQuery(\u0026#34;isAD\u0026#34;, true), // 算分函式 ScoreFunctionBuilders.weightFactorFunction(10) ) } ); // 查詢 request.source().query(functionScoreQuery); } ","date":"2025-02-05T15:50:26+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/229/","title":"Elasticsearch RestClient 查詢"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 Elasticsearch 系列\n內容 連結 Elasticsearch 基礎操作 https://blog.yexca.net/zh-tw/archives/226 Elasticsearch 查詢操作 https://blog.yexca.net/zh-tw/archives/227 RestClient 基礎操作 本文 RestClient 查詢操作 https://blog.yexca.net/zh-tw/archives/229 Elasticsearch 資料聚合 https://blog.yexca.net/zh-tw/archives/231 Elasticsearch 自動補齊 https://blog.yexca.net/zh-tw/archives/232 Elasticsearch 資料同步 https://blog.yexca.net/zh-tw/archives/234 Elasticsearch 叢集 https://blog.yexca.net/zh-tw/archives/235 ES 官方提供了各種不同語言的客戶端，用來操作 ES。這些客戶端的本質就是組裝 DSL 語句，透過 HTTP 請求傳送給 ES。\n官方文件： https://www.elastic.co/guide/en/elasticsearch/client/index.html 以下使用 Java HighLevel Rest Client 客戶端 API。\n建立索引庫 資料庫表格結構如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 `id` bigint(20) NOT NULL COMMENT \u0026#39;旅店 ID\u0026#39;, `name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT \u0026#39;旅店名稱\u0026#39;, `address` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT \u0026#39;旅店地址\u0026#39;, `price` int(10) NOT NULL COMMENT \u0026#39;旅店價格\u0026#39;, `score` int(2) NOT NULL COMMENT \u0026#39;旅店評分\u0026#39;, `brand` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT \u0026#39;旅店品牌\u0026#39;, `city` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT \u0026#39;所在城市\u0026#39;, `star_name` varchar(16) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT \u0026#39;旅店星級，1星到5星，1鑽到5鑽\u0026#39;, `business` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT \u0026#39;商圈\u0026#39;, `latitude` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT \u0026#39;緯度\u0026#39;, `longitude` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT \u0026#39;經度\u0026#39;, `pic` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT \u0026#39;旅店圖片\u0026#39;, PRIMARY KEY (`id`) USING BTREE 建立索引庫最關鍵的是 mapping 映射，需要考量：\n欄位名稱、欄位資料型別 (參考資料庫表格的名稱與型別) 是否參與搜尋 (根據業務判斷，例如圖片位址不需要參與搜尋) 是否需要分詞 (看內容，例如城市無需分詞) 分詞器是什麼 (可以統一 ik_max_word) 上方表格範例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 # 建立索引庫 PUT /hotel { \u0026#34;mappings\u0026#34;: { \u0026#34;properties\u0026#34;: { \u0026#34;id\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;keyword\u0026#34; }, \u0026#34;name\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;text\u0026#34;, \u0026#34;analyzer\u0026#34;: \u0026#34;ik_max_word\u0026#34;, \u0026#34;copy_to\u0026#34;: \u0026#34;all\u0026#34; /* 將目前欄位複製到指定欄位 all */ }, \u0026#34;address\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;keyword\u0026#34;, \u0026#34;index\u0026#34;: false }, \u0026#34;price\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;integer\u0026#34; }, \u0026#34;score\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;integer\u0026#34; }, \u0026#34;brand\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;keyword\u0026#34;, \u0026#34;copy_to\u0026#34;: \u0026#34;all\u0026#34; }, \u0026#34;city\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;keyword\u0026#34;, \u0026#34;copy_to\u0026#34;: \u0026#34;all\u0026#34; }, \u0026#34;starName\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;keyword\u0026#34; }, \u0026#34;business\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;keyword\u0026#34; }, \u0026#34;location\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;geo_point\u0026#34; /* ES 支援兩種地理座標資料型別 */ }, \u0026#34;pic\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;keyword\u0026#34;, \u0026#34;index\u0026#34;: false }, \u0026#34;all\u0026#34;: { /* 組合欄位，不會在查詢結果顯示，但可用於查詢 */ \u0026#34;type\u0026#34;: \u0026#34;text\u0026#34;, \u0026#34;analyzer\u0026#34;: \u0026#34;ik_max_word\u0026#34; } } } } 地理座標資料型別：\ngeo_point：由緯度 (latitude) 和經度 (longitude) 確定的一個點。例如 \u0026quot;32.84 120.25\u0026quot; geo_shape：由多個 geo_point 組成的複雜幾何圖形。例如一條直線 \u0026quot;LINESTRING(-77.03 38.29, +77.00 38.88)\u0026quot; 初始化 RestClient 與 Elasticsearch 的所有互動都封裝在一個名為 RestHighLevelClient 的類別中。\n首先引入 ES 的 RestHighLevelClient 相依套件。\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.elasticsearch.client\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;elasticsearch-rest-high-level-client\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 因為 SpringBoot 預設的 ES 版本為 7.6.2，需要覆寫預設 ES 版本。\n1 2 3 4 \u0026lt;properties\u0026gt; \u0026lt;java.version\u0026gt;1.8\u0026lt;/java.version\u0026gt; \u0026lt;elasticsearch.version\u0026gt;7.12.1\u0026lt;/elasticsearch.version\u0026gt; \u0026lt;/properties\u0026gt; 初始化 RestHighLevelClient 的程式碼如下：\n1 2 3 RestHighLevelClient client = new RestHighLevelClient(RestClient.builder( HttpHost.create(\u0026#34;http://IP:9200\u0026#34;) )); 不過為了測試方便，初始化程式碼會放在 @BeforeEach 中。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class HotelIndexTest { private RestHighLevelClient client; @BeforeEach void setUp() { client = new RestHighLevelClient(RestClient.builder( HttpHost.create(\u0026#34;http://127.0.0.1:9200\u0026#34;))); } @AfterEach void tearDown() throws IOException { this.client.close(); } } 定義索引庫需要 DSL 語句的 JSON 部分，可以單獨提取出來。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 public class HotelContants { public static final String MAPPING_TEMPLATE = \u0026#34;{\\n\u0026#34; + \u0026#34; \\\u0026#34;mappings\\\u0026#34;: {\\n\u0026#34; + \u0026#34; \\\u0026#34;properties\\\u0026#34;: {\\n\u0026#34; + \u0026#34; \\\u0026#34;id\\\u0026#34;: {\\n\u0026#34; + \u0026#34; \\\u0026#34;type\\\u0026#34;: \\\u0026#34;keyword\\\u0026#34;\\n\u0026#34; + \u0026#34; },\\n\u0026#34; + \u0026#34; \\\u0026#34;name\\\u0026#34;: {\\n\u0026#34; + \u0026#34; \\\u0026#34;type\\\u0026#34;: \\\u0026#34;text\\\u0026#34;,\\n\u0026#34; + \u0026#34; \\\u0026#34;analyzer\\\u0026#34;: \\\u0026#34;ik_max_word\\\u0026#34;,\\n\u0026#34; + \u0026#34; \\\u0026#34;copy_to\\\u0026#34;: \\\u0026#34;all\\\u0026#34;\\n\u0026#34; + \u0026#34; },\\n\u0026#34; + \u0026#34; \\\u0026#34;address\\\u0026#34;: {\\n\u0026#34; + \u0026#34; \\\u0026#34;type\\\u0026#34;: \\\u0026#34;keyword\\\u0026#34;,\\n\u0026#34; + \u0026#34; \\\u0026#34;index\\\u0026#34;: false\\n\u0026#34; + \u0026#34; },\\n\u0026#34; + \u0026#34; \\\u0026#34;price\\\u0026#34;: {\\n\u0026#34; + \u0026#34; \\\u0026#34;type\\\u0026#34;: \\\u0026#34;integer\\\u0026#34;\\n\u0026#34; + \u0026#34; },\\n\u0026#34; + \u0026#34; \\\u0026#34;score\\\u0026#34;: {\\n\u0026#34; + \u0026#34; \\\u0026#34;type\\\u0026#34;: \\\u0026#34;integer\\\u0026#34;\\n\u0026#34; + \u0026#34; },\\n\u0026#34; + \u0026#34; \\\u0026#34;brand\\\u0026#34;: {\\n\u0026#34; + \u0026#34; \\\u0026#34;type\\\u0026#34;: \\\u0026#34;keyword\\\u0026#34;,\\n\u0026#34; + \u0026#34; \\\u0026#34;copy_to\\\u0026#34;: \\\u0026#34;all\\\u0026#34;\\n\u0026#34; + \u0026#34; },\\n\u0026#34; + \u0026#34; \\\u0026#34;city\\\u0026#34;: {\\n\u0026#34; + \u0026#34; \\\u0026#34;type\\\u0026#34;: \\\u0026#34;keyword\\\u0026#34;,\\n\u0026#34; + \u0026#34; \\\u0026#34;copy_to\\\u0026#34;: \\\u0026#34;all\\\u0026#34;\\n\u0026#34; + \u0026#34; },\\n\u0026#34; + \u0026#34; \\\u0026#34;starName\\\u0026#34;: {\\n\u0026#34; + \u0026#34; \\\u0026#34;type\\\u0026#34;: \\\u0026#34;keyword\\\u0026#34;\\n\u0026#34; + \u0026#34; },\\n\u0026#34; + \u0026#34; \\\u0026#34;business\\\u0026#34;: {\\n\u0026#34; + \u0026#34; \\\u0026#34;type\\\u0026#34;: \\\u0026#34;keyword\\\u0026#34;\\n\u0026#34; + \u0026#34; },\\n\u0026#34; + \u0026#34; \\\u0026#34;location\\\u0026#34;: {\\n\u0026#34; + \u0026#34; \\\u0026#34;type\\\u0026#34;: \\\u0026#34;geo_point\\\u0026#34;\\n\u0026#34; + \u0026#34; },\\n\u0026#34; + \u0026#34; \\\u0026#34;pic\\\u0026#34;: {\\n\u0026#34; + \u0026#34; \\\u0026#34;type\\\u0026#34;: \\\u0026#34;keyword\\\u0026#34;,\\n\u0026#34; + \u0026#34; \\\u0026#34;index\\\u0026#34;: false\\n\u0026#34; + \u0026#34; },\\n\u0026#34; + \u0026#34; \\\u0026#34;all\\\u0026#34;: {\\n\u0026#34; + \u0026#34; \\\u0026#34;type\\\u0026#34;: \\\u0026#34;text\\\u0026#34;,\\n\u0026#34; + \u0026#34; \\\u0026#34;analyzer\\\u0026#34;: \\\u0026#34;ik_max_word\\\u0026#34;\\n\u0026#34; + \u0026#34; }\\n\u0026#34; + \u0026#34; }\\n\u0026#34; + \u0026#34; }\\n\u0026#34; + \u0026#34;}\u0026#34;; } 建立索引的程式碼：\n1 2 3 4 5 6 7 8 9 10 11 12 // 注意CreateIndexRequest的套件 import org.elasticsearch.client.indices.CreateIndexRequest; @Test void testCreateHotelIndex() throws IOException { // 建立Request物件 CreateIndexRequest request = new CreateIndexRequest(\u0026#34;hotel\u0026#34;); // 請求參數 request.source(MAPPING_TEMPLATE, XContentType.JSON); // 發送請求 client.indices().create(request, RequestOptions.DEFAULT); } 刪除索引庫 DSL 語句：\n1 DELETE /hotel 與建立的程式碼差異僅在 Request 物件上，且沒有參數。\n1 2 3 4 5 6 7 @Test void testDeleteHotelIndex() throws IOException { // 建立請求 DeleteIndexRequest request = new DeleteIndexRequest(\u0026#34;hotel\u0026#34;); // 發送請求 client.indices().delete(request, RequestOptions.DEFAULT); } 判斷索引庫是否存在 DSL 語句：\n1 GET /hotel 差異仍在於 Request 物件。\n1 2 3 4 5 6 7 8 9 @Test void testExistsHotelIndex() throws IOException { // 建立請求 GetIndexRequest request = new GetIndexRequest(\u0026#34;hotel\u0026#34;); // 發送請求 boolean exists = client.indices().exists(request, RequestOptions.DEFAULT); // 輸出 System.out.println(exists); } 總結\nJava RestClient 操作 ES 的流程大致相似，使用 client.indices() 方法來取得索引庫的操作物件。\nRestClient 一般資料在資料庫中會透過查詢資料庫來進行索引庫的 CRUD 操作。\n初始化 RestHighLevelClient：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 @SpringBootTest public class HotelDocumentTest { // 注入服務 @Autowired private IHotelService hotelService; private RestHighLevelClient client; @BeforeEach void setUp() { // 建構 RestClient this.client = new RestHighLevelClient( RestClient.builder( HttpHost.create(\u0026#34;http://127.0.0.1:9200\u0026#34;))); } @AfterEach void tearDown() throws IOException { this.client.close(); } } 新增文件 將資料庫中的資料查詢出來，寫入 ES 中。\n結構調整 資料庫查詢後的結果是一個 Hotel 型別的物件。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @Data @TableName(\u0026#34;tb_hotel\u0026#34;) public class Hotel { @TableId(type = IdType.INPUT) private Long id; private String name; private String address; private Integer price; private Integer score; private String brand; private String city; private String starName; private String business; private String longitude; private String latitude; private String pic; } 與索引庫結構存在差異，需要定義一個新的型別，使其與索引庫結構相同。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 @Data @NoArgsConstructor public class HotelDoc { private Long id; private String name; private String address; private Integer price; private Integer score; private String brand; private String city; private String starName; private String business; private String location; private String pic; public HotelDoc(Hotel hotel) { this.id = hotel.getId(); this.name = hotel.getName(); this.address = hotel.getAddress(); this.price = hotel.getPrice(); this.score = hotel.getScore(); this.brand = hotel.getBrand(); this.city = hotel.getCity(); this.starName = hotel.getStarName(); this.business = hotel.getBusiness(); this.location = hotel.getLatitude() + \u0026#34;, \u0026#34; + hotel.getLongitude(); this.pic = hotel.getPic(); } } 新增語法 DSL 的語法為：\n1 2 3 4 5 POST /{indexName}/_doc/{id} { \u0026#34;name\u0026#34;: \u0026#34;Jack\u0026#34;, \u0026#34;age\u0026#34;: 21 } 對應的 Java：\n1 2 3 4 5 6 7 8 9 10 11 12 @Test public void HotelCreateTest() throws IOException { // 準備 Request 物件 IndexRequest request = new IndexRequest(\u0026#34;indexName\u0026#34;).id(\u0026#34;1\u0026#34;); // 準備 JSON 物件 request.source(\u0026#34;{\\n\u0026#34; + \u0026#34; \\\u0026#34;name\\\u0026#34;: \\\u0026#34;Jack\\\u0026#34;,\\n\u0026#34; + \u0026#34; \\\u0026#34;age\\\u0026#34;: 21\\n\u0026#34; + \u0026#34;}\u0026#34;, XContentType.JSON); // 發送請求 client.index(request, RequestOptions.DEFAULT); } 新增文件實例程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @Test public void HotelCreateTest() throws IOException { // 查詢旅店資料 Hotel hotel = hotelService.getById(61083L); // 轉換文件型別 HotelDoc hotelDoc = new HotelDoc(hotel); // 轉為 JSON String json = JSON.toJSONString(hotelDoc); // 準備 Request 物件 IndexRequest request = new IndexRequest(\u0026#34;hotel\u0026#34;).id(hotelDoc.getId().toString()); // 準備 JSON 物件 request.source(json, XContentType.JSON); // 發送請求 client.index(request, RequestOptions.DEFAULT); } 查詢文件 查詢語法 DSL 語句：\n1 GET /{indexName}/_doc/{id} Java 語句：\n1 2 3 4 5 6 7 8 9 10 11 @Test public void HotelGetTest() throws IOException { // 準備 Request GetRequest request = new GetRequest(\u0026#34;indexName\u0026#34;, \u0026#34;id\u0026#34;); // 發送請求 GetResponse response = client.get(request, RequestOptions.DEFAULT); // 解析結果 String json = response.getSourceAsString(); System.out.println(json); } 查詢文件實例程式碼 1 2 3 4 5 6 7 8 9 10 11 12 @Test public void HotelGetTest() throws IOException { // 準備 Request GetRequest request = new GetRequest(\u0026#34;hotel\u0026#34;, \u0026#34;61083\u0026#34;); // 發送請求 GetResponse response = client.get(request, RequestOptions.DEFAULT); // 解析結果 String json = response.getSourceAsString(); // 反序列化為 Java 物件 HotelDoc hotelDoc = JSON.parseObject(json, HotelDoc.class); System.out.println(hotelDoc); } 刪除文件 刪除語法 DSL 語句：\n1 DELETE /{indexName}/_doc/{id} Java 語句：\n1 2 3 4 5 6 7 @Test public void HotelDeleteTest() throws IOException { // 準備 Request DeleteRequest request = new DeleteRequest(\u0026#34;indexName\u0026#34;, \u0026#34;id\u0026#34;); // 發送請求 client.delete(request, RequestOptions.DEFAULT); } 刪除文件實例程式碼 1 2 3 4 5 6 7 @Test public void HotelDeleteTest() throws IOException { // 準備 Request DeleteRequest request = new DeleteRequest(\u0026#34;hotel\u0026#34;, \u0026#34;61083\u0026#34;); // 發送請求 client.delete(request, RequestOptions.DEFAULT); } 修改文件 修改語法 修改有全量修改與增量修改兩種方式。在 RestClient 的 API 中，這兩種方式的 API 完全一致，判斷依據是 ID，新增時：\nID 存在，進行修改 ID 不存在，進行新增 這裡主要關注增量修改，DSL 語句如下：\n1 2 3 4 5 POST /{indexName}/_update/{id} { \u0026#34;doc\u0026#34;: \u0026#34;Rose\u0026#34;, \u0026#34;age\u0026#34;: 18 } Java 語句：\n1 2 3 4 5 6 7 8 9 10 11 12 @Test public void HotelUpdateTest() throws IOException { // 建立 Request 物件 UpdateRequest request = new UpdateRequest(\u0026#34;indexName\u0026#34;, \u0026#34;id\u0026#34;); // 準備參數 request.doc( \u0026#34;name\u0026#34;, \u0026#34;Rose\u0026#34;, \u0026#34;age\u0026#34;, 18 ); // 更新文件 client.update(request, RequestOptions.DEFAULT); } 修改文件實例程式碼 1 2 3 4 5 6 7 8 9 10 11 12 @Test public void HotelUpdateTest() throws IOException { // 建立 Request 物件 UpdateRequest request = new UpdateRequest(\u0026#34;hotel\u0026#34;, \u0026#34;61083\u0026#34;); // 準備參數 request.doc( \u0026#34;price\u0026#34;, 950, \u0026#34;starName\u0026#34;, \u0026#34;四鑽\u0026#34; ); // 更新文件 client.update(request, RequestOptions.DEFAULT); } 批次匯入文件 利用 BulkRequest 將資料庫資料批次匯入到索引庫中。其本質是將多個普通的 CRUD 請求組合在一起發送，範例如下：\n1 2 3 4 5 6 7 8 9 10 @Test public void testBulk() throws IOException { // 建立 bulk 請求 BulkRequest request = new BulkRequest(); // 新增批次請求 request.add(new IndexRequest(\u0026#34;indexName\u0026#34;).id(\u0026#34;id1\u0026#34;).source(\u0026#34;json1\u0026#34;, XContentType.JSON)); request.add(new IndexRequest(\u0026#34;indexName\u0026#34;).id(\u0026#34;id2\u0026#34;).source(\u0026#34;json2\u0026#34;, XContentType.JSON)); // 發送 bulk 請求 client.bulk(request, RequestOptions.DEFAULT); } 批次匯入文件實例程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 @Test public void testBulk() throws IOException { // 批次查詢資料 List\u0026lt;Hotel\u0026gt; hotelList = hotelService.list(); // 建立 bulk 請求 BulkRequest request = new BulkRequest(); // 新增批次請求 for (Hotel hotel : hotelList) { // 轉換文件型別 HotelDoc hotelDoc = new HotelDoc(hotel); // 建立新增文件 Request 物件 request.add(new IndexRequest(\u0026#34;hotel\u0026#34;) .id(hotelDoc.getId().toString()) .source(JSON.toJSONString(hotelDoc), XContentType.JSON) ); } // 發送 bulk 請求 client.bulk(request, RequestOptions.DEFAULT); } ","date":"2025-02-03T22:30:00+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/228/","title":"Elasticsearch RestClient 入門"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 Elasticsearch 系列\n內容 連結 Elasticsearch 基礎操作 https://blog.yexca.net/zh-tw/archives/226 Elasticsearch 查詢操作 本文 RestClient 基礎操作 https://blog.yexca.net/zh-tw/archives/228 RestClient 查詢操作 https://blog.yexca.net/zh-tw/archives/229 Elasticsearch 資料彙總 https://blog.yexca.net/zh-tw/archives/231 Elasticsearch 自動補齊 https://blog.yexca.net/zh-tw/archives/232 Elasticsearch 資料同步 https://blog.yexca.net/zh-tw/archives/234 Elasticsearch 叢集 https://blog.yexca.net/zh-tw/archives/235 上一篇文章主要介紹了 Elasticsearch 的資料儲存功能，但 Elasticsearch 最擅長的還是搜尋和資料分析。\nElasticsearch 的查詢依然是基於 JSON 風格的 DSL 來實作的。\n查詢分類 常見的查詢類型包括：\n查詢所有：查詢出所有資料，一般用於測試。例如 match_all 全文檢索 (full text) 查詢：利用分詞器對使用者輸入的內容進行分詞，然後到反向索引資料庫中匹配，例如： match_query multi_match_query 精確查詢：根據精確詞條值尋找資料，一般用於尋找 keyword、數值、日期、boolean 等類型的欄位。例如： ids range term 地理 (geo) 查詢：根據經緯度查詢。例如： geo_distance geo_bounding_box 複合 (compound) 查詢：將上述簡單的查詢條件組合起來，合併查詢條件。例如： bool function_score 查詢的語法基本上一致：\n1 2 3 4 5 6 7 8 GET /indexName/_search { \u0026#34;query\u0026#34;: { \u0026#34;查詢類型\u0026#34;: { \u0026#34;查詢條件\u0026#34;: \u0026#34;條件值\u0026#34; } } } 查詢所有 查詢類型為 match_all 沒有查詢條件\n1 2 3 4 5 6 7 // 查詢所有 GET /indexName/_search { \u0026#34;query\u0026#34;: { \u0026#34;match_all\u0026#34;: {} } } 全文檢索查詢 會對使用者輸入的內容進行分詞，常用於搜尋框的搜尋。因為是拿著詞條去匹配，因此參與搜尋的欄位也必須是可分詞的 text 類型欄位。\n常見的：\nmatch：單欄位查詢 multi_match：多欄位查詢，任意一個欄位符合條件就算符合查詢條件 match 查詢語法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # match GET /indexName/_search { \u0026#34;query\u0026#34;: { \u0026#34;match\u0026#34;: { \u0026#34;FIELD\u0026#34;: \u0026#34;TEXT\u0026#34; } } } # 範例 GET /hotel/_search { \u0026#34;query\u0026#34;: { \u0026#34;match\u0026#34;: { \u0026#34;all\u0026#34;: \u0026#34;外灘如家\u0026#34; } } } multi_match 語法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # multi_match GET /indexName/_search { \u0026#34;query\u0026#34;: { \u0026#34;multi_match\u0026#34;: { \u0026#34;query\u0026#34;: \u0026#34;TEXT\u0026#34;, \u0026#34;fields\u0026#34;: [\u0026#34;FIELD1\u0026#34;, \u0026#34;FIELD2\u0026#34;] } } } # 範例 GET /hotel/_search { \u0026#34;query\u0026#34;: { \u0026#34;multi_match\u0026#34;: { \u0026#34;query\u0026#34;: \u0026#34;外灘如家\u0026#34;, \u0026#34;fields\u0026#34;: [\u0026#34;brand\u0026#34;, \u0026#34;name\u0026#34;, \u0026#34;business\u0026#34;] } } } 由於之前建立索引表時將 brand、name、business 的值利用 copy_to 複製到 all 欄位，上述兩種查詢結果相同。\n但搜尋欄位越多對效能影響越大，建議使用 copy_to，然後進行單欄位查詢。\n精準查詢 精確查詢不會對搜尋條件進行分詞，常見的有：\nterm：根據詞條精確值查詢 range：根據值的範圍查詢 term 查詢 查詢條件必須是不分詞的詞條，輸入與值完全匹配才符合條件。\n語法：\n1 2 3 4 5 6 7 8 9 10 11 # term GET /indexName/_search { \u0026#34;query\u0026#34;: { \u0026#34;term\u0026#34;: { \u0026#34;FIELD\u0026#34;: { \u0026#34;value\u0026#34;: \u0026#34;VALUE\u0026#34; } } } } 範例\n1 2 3 4 5 6 7 8 9 10 GET /hotel/_search { \u0026#34;query\u0026#34;: { \u0026#34;term\u0026#34;: { \u0026#34;city\u0026#34;: { \u0026#34;value\u0026#34;: \u0026#34;上海\u0026#34; } } } } range 查詢 範圍查詢，一般應用在對數值類型進行範圍過濾時。例如進行價格、日期範圍過濾。\n語法：\n1 2 3 4 5 6 7 8 9 10 11 12 # range GET /hotel/_search { \u0026#34;query\u0026#34;: { \u0026#34;range\u0026#34;: { \u0026#34;FIELD\u0026#34;: { \u0026#34;gte\u0026#34;: 10, // 這裡的gte代表大於等於，gt則代表大於 \u0026#34;lte\u0026#34;: 20 // lte代表小於等於，lt則代表小於 } } } } 範例\n1 2 3 4 5 6 7 8 9 10 11 GET /hotel/_search { \u0026#34;query\u0026#34;: { \u0026#34;range\u0026#34;: { \u0026#34;price\u0026#34;: { \u0026#34;gte\u0026#34;: 1000, \u0026#34;lte\u0026#34;: 2000 } } } } 地理座標查詢 其實就是根據經緯度檢索，官方文件： https://www.elastic.co/guide/en/elasticsearch/reference/current/geo-queries.html 常用情境：搜尋附近飯店、計程車、人、美食\n矩形範圍查詢 geo_bounding_box 查詢，查詢座標落在某個矩形範圍內的所有文件。\n需要指定左上、右下兩個點的座標。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # geo_bounding_box GET /indexName/_search { \u0026#34;query\u0026#34;: { \u0026#34;geo_bounding_box\u0026#34;: { \u0026#34;FIELD\u0026#34;: { \u0026#34;top_left\u0026#34;: { // 左上點 \u0026#34;lat\u0026#34;: 30, \u0026#34;lon\u0026#34;: 20 }, \u0026#34;bottom_right\u0026#34;: { // 右下點 \u0026#34;lat\u0026#34;: 31, \u0026#34;lon\u0026#34;: 21 } } } } } 附近查詢 也稱為距離查詢 (geo_distance)：查詢到指定中心點小於某個距離值的所有文件。\n1 2 3 4 5 6 7 8 9 10 # geo_distance GET /indexName/_search { \u0026#34;query\u0026#34;: { \u0026#34;geo_distance\u0026#34;: { \u0026#34;distance\u0026#34;: \u0026#34;15km\u0026#34;, // 半徑 \u0026#34;FIELD\u0026#34;: \u0026#34;31, 21\u0026#34; // 圓心 } } } 範例：搜尋附近 (31.21, 121.5) 15 公里內的飯店\n1 2 3 4 5 6 7 8 9 GET /hotel/_search { \u0026#34;query\u0026#34;: { \u0026#34;geo_distance\u0026#34;: { \u0026#34;distance\u0026#34;: \u0026#34;15km\u0026#34;, \u0026#34;location\u0026#34;: \u0026#34;31.21, 121.5\u0026#34; } } } 複合查詢 將其他簡單查詢組合，實現更複雜的搜尋邏輯，常見有兩種：\nfunction score：算分函數查詢，可以控制文件關聯性算分，控制文件排名。 bool query：布林查詢，利用邏輯關係組合多個其他查詢，實現複雜搜尋。 關聯性算分 當使用 match 查詢時，文件結果會根據與搜尋詞條的關聯度給予評分 (_score)，返回結果時會依照分數降序排列，例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 [ { \u0026#34;_score\u0026#34; : 17.850193, \u0026#34;_source\u0026#34; : { \u0026#34;name\u0026#34; : \u0026#34;虹橋如家酒店真不錯\u0026#34;, } }, { \u0026#34;_score\u0026#34; : 12.259849, \u0026#34;_source\u0026#34; : { \u0026#34;name\u0026#34; : \u0026#34;外灘如家酒店真不錯\u0026#34;, } }, { \u0026#34;_score\u0026#34; : 11.91091, \u0026#34;_source\u0026#34; : { \u0026#34;name\u0026#34; : \u0026#34;迪士尼如家酒店真不錯\u0026#34;, } } ] 在 Elasticsearch 中，早期使用的評分演算法是 TF-IDF 演算法。\nTF-IDF 演算法有缺陷，就是詞條頻率越高，文件得分也會越高，單個詞條對文件影響較大。在 5.1 版本之後，演算法改為 BM25 演算法，會讓單個詞條的算分有一個上限。\n算分函數查詢 算分函數雖然比較合理，但不一定是產品所需要的。若要控制關聯性算分，就需要利用 Elasticsearch 的 function score 查詢，修改文件的關聯性算分，根據新得到的算分排序。\n結構：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # function score GET /indexName/_search { \u0026#34;query\u0026#34;: { \u0026#34;function_score\u0026#34;: { \u0026#34;query\u0026#34;: {}, // 原始查詢 \u0026#34;functions\u0026#34;: [ { \u0026#34;filter\u0026#34;: {}, // 過濾條件 \u0026#34;weight\u0026#34;: 1 // 算分函數 } ], \u0026#34;boost_mode\u0026#34;: \u0026#34;multiply\u0026#34; // 運算模式 } } } 原始查詢：基於這個條件搜尋文件，並基於 BM25 演算法給文件評分，即原始算分 (query score)。\n過濾條件：符合該條件的文件才會重新算分。\n算分函數：符合 filter 條件的文件要根據此函數進行運算，得到函數算分，有四種函數：\nweight：函數結果是常數 field_value_factor：以文件中的某個欄位值作為函數結果 random_score：以亂數作為函數結果 script_score：自訂算分函數演算法 運算模式：算分函數的結果、原始查詢的關聯性算分，兩者之間的運算方式，包括：\nmultiply：相乘 replace：用 function score 取代 query score 其他，例如：sum、avg、max、min 範例：讓「如家」這個品牌的飯店排名靠前一些。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 GET /hotel/_search { \u0026#34;query\u0026#34;: { // 原始查詢條件為任意，此處為能運行添加條件 \u0026#34;function_score\u0026#34;: { \u0026#34;query\u0026#34;: {\u0026#34;term\u0026#34;: { \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34; }}, \u0026#34;functions\u0026#34;: [ { \u0026#34;filter\u0026#34;: {\u0026#34;term\u0026#34;: { \u0026#34;brand\u0026#34;: \u0026#34;如家\u0026#34; }}, \u0026#34;weight\u0026#34;: 10 } ], \u0026#34;boost_mode\u0026#34;: \u0026#34;multiply\u0026#34; } } } 布林查詢 布林查詢是一個或多個查詢子句的組合，每一個子句就是一個子查詢，組合方式有：\nmust：必須匹配每個子查詢，類似「且」 should：選擇性匹配子查詢，類似「或」 must_not：必須不匹配，不參與算分，類似「非」 filter：必須匹配，不參與算分 例如在搜尋飯店時，可以選擇地區、品牌、價格等欄位進行過濾，每一個不同的欄位，其查詢條件、方式都不一樣，必須是多個不同的查詢，組合這些查詢就要用布林查詢了。\n參與評分的欄位，查詢效能越差。多條件查詢時，建議：\n搜尋框的關鍵字搜尋是全文檢索，使用 must 查詢，參與算分。\n其他過濾條件，採用 filter 查詢，不參與算分。\n語法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # bool GET /hotel/_search { \u0026#34;query\u0026#34;: { \u0026#34;bool\u0026#34;: { \u0026#34;must\u0026#34;: [ {} ], \u0026#34;should\u0026#34;: [ {} ], \u0026#34;must_not\u0026#34;: [ {} ], \u0026#34;filter\u0026#34;: [ {} ] } } } 範例：搜尋名字包含「如家」，價格不高於 400，在座標 31.21，121.5 周圍 10 公里範圍內的飯店。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 GET /hotel/_search { \u0026#34;query\u0026#34;: { \u0026#34;bool\u0026#34;: { \u0026#34;must\u0026#34;: [ {\u0026#34;match\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;如家\u0026#34; }} ], \u0026#34;must_not\u0026#34;: [ {\u0026#34;range\u0026#34;: { \u0026#34;price\u0026#34;: { \u0026#34;gt\u0026#34;: 400 } }} ], \u0026#34;filter\u0026#34;: [ {\u0026#34;geo_distance\u0026#34;: { \u0026#34;distance\u0026#34;: \u0026#34;10km\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 31.21, \u0026#34;lon\u0026#34;: 121.5 } }} ] } } } 搜尋結果處理 搜尋得到的結果可以排序、分頁與高亮。\n排序 Elasticsearch 預設是按照關聯度算分來排序，但是也支援自訂方式對搜尋結果排序，可排序的欄位類型有：keyword 類型、數值類型、地理座標類型、日期類型等。\n普通欄位排序 keyword、數值、日期類型排序的語法基本上一致。\n語法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 # sort_normal GET /indexName/_search { \u0026#34;query\u0026#34;: { }, \u0026#34;sort\u0026#34;: [ { \u0026#34;FIELD\u0026#34;: { \u0026#34;order\u0026#34;: \u0026#34;desc\u0026#34; // 排序欄位，ASC、DESC } } ] } 排序條件是一個陣列，可以撰寫多個排序條件，按照宣告的順序，當第一個條件相等時，再按第二個條件，以此類推。\n範例：飯店資料按照使用者評價降序，評價相同則按價格升序。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 GET /hotel/_search { \u0026#34;query\u0026#34;: { \u0026#34;match\u0026#34;: { \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34; } }, \u0026#34;sort\u0026#34;: [ { \u0026#34;score\u0026#34;: { \u0026#34;order\u0026#34;: \u0026#34;desc\u0026#34; } }, { \u0026#34;price\u0026#34;: { \u0026#34;order\u0026#34;: \u0026#34;asc\u0026#34; } } ] } // 或者 GET /hotel/_search { \u0026#34;query\u0026#34;: { \u0026#34;match\u0026#34;: { \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34; } }, \u0026#34;sort\u0026#34;: [ { \u0026#34;score\u0026#34;: \u0026#34;desc\u0026#34; }, { \u0026#34;price\u0026#34;: \u0026#34;asc\u0026#34; } ] } 地理座標排序 語法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # sort_geo GET /indexName/_search { \u0026#34;query\u0026#34;: { }, \u0026#34;sort\u0026#34;: [ { \u0026#34;_geo_distance\u0026#34;: { \u0026#34;FIELD\u0026#34;: { \u0026#34;lat\u0026#34;: 40, \u0026#34;lon\u0026#34;: -70 }, \u0026#34;order\u0026#34;: \u0026#34;asc\u0026#34;, // 排序方式 \u0026#34;unit\u0026#34;: \u0026#34;km\u0026#34; // 排序單位 } } ] } 範例：按飯店距離排序 (假設位置為 31.034661，121.612282)。\n高德取得經緯度： https://lbs.amap.com/demo/jsapi-v2/example/map/click-to-get-lnglat/ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 GET /hotel/_search { \u0026#34;query\u0026#34;: { \u0026#34;match_all\u0026#34;: {} }, \u0026#34;sort\u0026#34;: [ { \u0026#34;_geo_distance\u0026#34;: { \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 31.034661, \u0026#34;lon\u0026#34;: 121.612282 }, \u0026#34;order\u0026#34;: \u0026#34;asc\u0026#34;, \u0026#34;unit\u0026#34;: \u0026#34;km\u0026#34; } } ] } 分頁 Elasticsearch 預設只返回前 10 筆資料，如果要查詢更多資料就需要修改分頁參數，Elasticsearch 透過修改 from、size 參數來控制要返回的分頁結果：\nfrom：從第幾個文件開始 size：總共查詢幾個文件 類似於 MySQL 中的 limit ?,?\n基本分頁 基本語法如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # 基本分頁 GET /indexName/_search { \u0026#34;query\u0026#34;: { }, \u0026#34;from\u0026#34;: 0, \u0026#34;size\u0026#34;: 10, \u0026#34;sort\u0026#34;: [ { \u0026#34;FIELD\u0026#34;: { \u0026#34;order\u0026#34;: \u0026#34;desc\u0026#34; } } ] } 深度分頁問題 如果要查詢第 990-1000 筆資料，語法如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 GET /hotel/_search { \u0026#34;query\u0026#34;: { \u0026#34;match_all\u0026#34;: {} }, \u0026#34;from\u0026#34;: 990, \u0026#34;size\u0026#34;: 10, \u0026#34;sort\u0026#34;: [ { \u0026#34;price\u0026#34;: { \u0026#34;order\u0026#34;: \u0026#34;asc\u0026#34; } } ] } 但由於 Elasticsearch 的機制，分頁時必須先查詢 0-1000 條，然後截取 990-1000 筆資料來顯示。\n如果 Elasticsearch 是單點模式，並無太大影響，但叢集部署時查詢 1000 條並不是每個節點查詢 200 條，因為 A 節點的 200 條可能在 B 節點排到 1000 名之外。\n為了取得前 1000 筆，需要每個節點都查詢 Top 1000，然後彙總重新排名後截取。\n若要查詢 Top 10000 甚至更多筆資料，會對記憶體和 CPU 產生非常大的壓力，因此 Elasticsearch 禁止 from+size 超過 10000 的請求。\n而針對深度分頁，Elasticsearch 提供了兩種解決方案： https://www.elastic.co/guide/en/elasticsearch/reference/current/paginate-search-results.html search after：分頁時需要排序，原理是從上一次的排序值開始，查詢下一頁資料。官方推薦使用的作法。 scroll：原理是將排序後的文件 ID 形成快照，保存在記憶體。官方已經不推薦使用。 分頁總結 from + size：\n優點：支援隨機翻頁 缺點：深度分頁問題，預設查詢上限（from + size）是 10000 情境：百度、京東、Google、淘寶這類隨機翻頁搜尋。 after search：\n優點：沒有查詢上限（單次查詢的 size 不超過 10000） 缺點：只能向後逐頁查詢，不支援隨機翻頁 情境：沒有隨機翻頁需求的搜尋，例如手機向下捲動翻頁。 scroll：\n優點：沒有查詢上限（單次查詢的 size 不超過 10000） 缺點：會產生額外記憶體消耗，並且搜尋結果是非即時的。 情境：大量資料的取得和移轉。從 ES 7.1 開始不推薦，建議使用 after search 方案。 高亮 使用搜尋引擎搜尋內容時，關鍵字會變為紅色，較為醒目，即為高亮顯示。一般是給文件所有關鍵字添加一個標籤 (\u0026lt;em\u0026gt;)，並為該標籤編寫 CSS 樣式。\n語法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # 高亮 GET /indexName/_search { \u0026#34;query\u0026#34;: { }, \u0026#34;highlight\u0026#34;: { \u0026#34;fields\u0026#34;: { // 指定要高亮的欄位 \u0026#34;FIELD\u0026#34;: { \u0026#34;pre_tags\u0026#34;: \u0026#34;\u0026lt;em\u0026gt;\u0026#34;, // 用來標記高亮欄位的前置標籤 \u0026#34;post_tags\u0026#34;: \u0026#34;\u0026lt;/em\u0026gt;\u0026#34; // 用來標記高亮欄位的後置標籤 } } } } 注意：\n高亮是對關鍵字進行高亮，所以搜尋條件必須有關鍵字，不能是範圍查詢。 預設情況下，高亮的欄位必須與搜尋指定的欄位一致，否則無法高亮。 對非搜尋欄位高亮，需要添加屬性：required_field_match=false 範例：搜尋時，名字部分高亮。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 GET /hotel/_search { \u0026#34;query\u0026#34;: { \u0026#34;match\u0026#34;: { \u0026#34;all\u0026#34;: \u0026#34;如家\u0026#34; } }, \u0026#34;highlight\u0026#34;: { \u0026#34;fields\u0026#34;: { \u0026#34;name\u0026#34;: { \u0026#34;require_field_match\u0026#34;: \u0026#34;false\u0026#34;, \u0026#34;pre_tags\u0026#34;: \u0026#34;\u0026lt;em\u0026gt;\u0026#34;, \u0026#34;post_tags\u0026#34;: \u0026#34;\u0026lt;/em\u0026gt;\u0026#34; } } } } // 截取結果 \u0026#34;hits\u0026#34; : [ { \u0026#34;_index\u0026#34; : \u0026#34;hotel\u0026#34;, \u0026#34;_type\u0026#34; : \u0026#34;_doc\u0026#34;, \u0026#34;_id\u0026#34; : \u0026#34;339952837\u0026#34;, \u0026#34;_score\u0026#34; : 2.7875905, \u0026#34;_source\u0026#34; : { \u0026#34;address\u0026#34; : \u0026#34;良鄉西路7號\u0026#34;, \u0026#34;brand\u0026#34; : \u0026#34;如家\u0026#34;, \u0026#34;business\u0026#34; : \u0026#34;房山風景區\u0026#34;, \u0026#34;city\u0026#34; : \u0026#34;北京\u0026#34;, \u0026#34;id\u0026#34; : 339952837, \u0026#34;location\u0026#34; : \u0026#34;39.73167, 116.132482\u0026#34;, \u0026#34;name\u0026#34; : \u0026#34;如家酒店(北京良鄉西路店)\u0026#34;, \u0026#34;pic\u0026#34; : \u0026#34;https://m.tuniucdn.com/fb3/s1/2n9c/3Dpgf5RTTzrxpeN5y3RLnRVtxMEA_w200_h200_c1_t0.jpg\u0026#34;, \u0026#34;price\u0026#34; : 159, \u0026#34;score\u0026#34; : 46, \u0026#34;starName\u0026#34; : \u0026#34;二鑽\u0026#34; }, \u0026#34;highlight\u0026#34; : { \u0026#34;name\u0026#34; : [ \u0026#34;\u0026lt;em\u0026gt;如家\u0026lt;/em\u0026gt;酒店(北京良鄉西路店)\u0026#34; ] } } ] 結果的 highlight 部分展示了添加標籤後的結果。\n搜尋結果處理總結 DSL 查詢是一個大型 JSON 物件，包含：\nquery：查詢 from、size：分頁條件 sort：排序條件 highlight：高亮條件 綜合範例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 # 查詢綜合 GET /hotel/_search { \u0026#34;query\u0026#34;: { // 查詢 \u0026#34;match\u0026#34;: { \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34; } }, \u0026#34;from\u0026#34;: 10, // 分頁起始 \u0026#34;size\u0026#34;: 10, // 分頁尺寸 \u0026#34;sort\u0026#34;: [ { // 普通排序 \u0026#34;price\u0026#34;: { \u0026#34;order\u0026#34;: \u0026#34;asc\u0026#34; } }, { // 距離排序 \u0026#34;_geo_distance\u0026#34;: { \u0026#34;location\u0026#34;: { \u0026#34;lat\u0026#34;: 31, \u0026#34;lon\u0026#34;: 121 }, \u0026#34;order\u0026#34;: \u0026#34;asc\u0026#34;, \u0026#34;unit\u0026#34;: \u0026#34;km\u0026#34; } } ], \u0026#34;highlight\u0026#34;: { // 高亮欄位 \u0026#34;fields\u0026#34;: { \u0026#34;name\u0026#34;: { \u0026#34;require_field_match\u0026#34;: \u0026#34;false\u0026#34;, \u0026#34;pre_tags\u0026#34;: \u0026#34;\u0026lt;em\u0026gt;\u0026#34;, \u0026#34;post_tags\u0026#34;: \u0026#34;\u0026lt;/em\u0026gt;\u0026#34; } } } } ","date":"2025-02-01T15:16:28+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/227/","title":"Elasticsearch 查詢"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 Elasticsearch 系列\n內容 連結 Elasticsearch 基礎操作 本文 Elasticsearch 查詢操作 https://blog.yexca.net/zh-tw/archives/227 RestClient 基礎操作 https://blog.yexca.net/zh-tw/archives/228 RestClient 查詢操作 https://blog.yexca.net/zh-tw/archives/229 Elasticsearch 資料聚合 https://blog.yexca.net/zh-tw/archives/231 Elasticsearch 自動補齊 https://blog.yexca.net/zh-tw/archives/232 Elasticsearch 資料同步 https://blog.yexca.net/zh-tw/archives/234 Elasticsearch 叢集 https://blog.yexca.net/zh-tw/archives/235 Elasticsearch 是一款非常強大的開源搜尋引擎軟體，可以幫助我們從海量資料中快速找到需要的內容。結合 Kibana、Logstash、Beats，也就是 Elastic Stack (ELK)。被廣泛應用在日誌資料分析、即時監控等領域。\n而 Elasticsearch 是 Elastic Stack 的核心，負責儲存、搜尋、分析資料。\nElasticsearch 底層基於 Lucene 實作，Lucene 為 Java 的一個搜尋引擎函式庫。\n正向索引 傳統資料庫 (例如 MySQL) 採用正向索引，舉例來說下表：\nid title price 1 小米手機 3499 2 華為手機 4999 3 華為小米充電器 49 4 小米手環 239 如果基於 id 精準查詢，直接走索引會很快。\n但若基於 title 做模糊查詢，只能逐行掃描資料，流程：\n使用者搜尋 手機，資料庫條件 %手機% 逐行取得資料，如 id 為 1 的資料 判斷資料中的 title 是否符合條件 符合則放入，不符合則捨棄，下一行 隨著資料量的增加，逐行掃描的效率越來越低。\n倒排索引 倒排索引的概念是基於 MySQL 這樣的正向索引而言的。\nElasticsearch 採用倒排索引，概念：\n文件 (document)：每筆資料就是一個文件。 詞條 (term)：文件按照語義分成的詞語。 建立倒排索引是對正向索引的一種特殊處理，流程：\n將每一個文件的資料利用演算法斷詞，得到一個個詞條。 建立表，每行包括詞條、詞條所在文件 id、位置等資訊。 因為詞條的唯一性，可以給詞條建立索引，例如雜湊表結構索引。 舉例來說上例的表可以建立如下倒排索引：\n詞條 文件 id 小米 1，3，4 手機 1，2 華為 2，3 充電器 3 手環 4 倒排索引搜尋流程：\n使用者搜尋 小米手機。 對搜尋內容斷詞，得到 小米、手機。 使用詞條在倒排索引查找，得到包含詞條的文件 id：1、2、3、4。 使用文件 id 到正向索引中查找具體文件。 文件 (Document) Elasticsearch 是面向文件儲存的，可以是資料庫中的一筆商品資料、一個訂單資訊。文件資料會被序列化為 JSON 格式後儲存在 Elasticsearch 中。\n上述正向索引表的 JSON 如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 { \u0026#34;id\u0026#34;: 1, \u0026#34;title\u0026#34;: \u0026#34;小米手機\u0026#34;, \u0026#34;price\u0026#34;: 3499 } { \u0026#34;id\u0026#34;: 2, \u0026#34;title\u0026#34;: \u0026#34;華為手機\u0026#34;, \u0026#34;price\u0026#34;: 4999 } { \u0026#34;id\u0026#34;: 3, \u0026#34;title\u0026#34;: \u0026#34;華為小米充電器\u0026#34;, \u0026#34;price\u0026#34;: 49 } { \u0026#34;id\u0026#34;: 4, \u0026#34;title\u0026#34;: \u0026#34;小米手環\u0026#34;, \u0026#34;price\u0026#34;: 299 } 在 Json 文件中包含許多欄位，類似於資料庫中的欄。\n索引與映射 (Mapping) 索引 (index) 為相同型別的文件集合。\n映射 (mapping) 為索引中文件的欄位限制資訊，類似於資料表的結構限制。\n可以把索引當做是資料庫中的資料表，資料庫的資料表會有限制資訊，用來定義表的結構、欄位的名稱、型別等資訊。因此，索引庫中就有映射，是索引中文件的欄位限制資訊，類似於資料表的結構限制。\nMySQL 與 Elasticsearch MySQL Elasticsearch 說明 Table Index 索引 (index)，就是文件的集合，類似資料庫的資料表 (table) Row Document 文件 (Document)，就是一筆筆的資料，類似資料庫中的資料列 (Row)，文件都是 JSON 格式 Column Field 欄位 (Field)，就是 JSON 文件中的欄位，類似資料庫中的欄 (Column) Schema Mapping Mapping (映射) 是索引中文件的限制，例如欄位型別限制。類似資料庫的綱要 (Schema) SQL DSL DSL 是 Elasticsearch 提供的 JSON 風格的請求語句，用來操作 Elasticsearch，實作 CRUD 在企業中，往往是兩者結合使用：\n對安全性要求較高的寫入操作，使用 MySQL 實作。 對查詢效能要求較高的搜尋需求，使用 Elasticsearch 實作。 兩者再基於某種方式，實作資料的同步，確保一致性。 優缺點 正向索引：\n優點： 可以給多個欄位建立索引。 根據索引欄位搜尋、排序速度非常快。 缺點： 根據非索引欄位，或者索引欄位中的部分詞條查找時，只能全表掃描。 倒排索引：\n優點： 根據詞條搜尋、模糊搜尋時，速度非常快。 缺點： 只能給詞條建立索引，而不是欄位。 無法根據欄位做排序。 安裝 一般只用 Elasticsearch 即可，使用 Kibana 可以提供一個 Elasticsearch 的視覺化介面，方便學習撰寫 DSL 語句。\nElasticsearch 為了使 Elasticsearch 與 Kibana 容器互連，可以先建立一個網路。\n1 docker network create es-net 有多種方式可以實作互連，如 docker-compose、172.17.0.1\n拉取 Elasticsearch 映像檔。\n1 docker pull elasticsearch:7.12.1 單點部署\n1 2 3 4 5 6 7 8 9 10 11 docker run -d \\ --name es \\ -e \u0026#34;ES_JAVA_OPTS=-Xms512m -Xmx512m\u0026#34; \\ -e \u0026#34;discovery.type=single-node\u0026#34; \\ -v es-data:/usr/share/elasticsearch/data \\ -v es-plugins:/usr/share/elasticsearch/plugins \\ --privileged \\ --network es-net \\ -p 9200:9200 \\ -p 9300:9300 \\ elasticsearch:7.12.1 注意修改映射目錄，上述使用資料卷 (volume)，部分解釋：\n-e \u0026quot;cluster.name=es-docker-cluster\u0026quot;：設定叢集名稱。 -e \u0026quot;http.host=0.0.0.0\u0026quot;：監聽的位址，可以從外部網路存取。 -e \u0026quot;ES_JAVA_OPTS=-Xms512m -Xmx512m\u0026quot;：記憶體大小。 -e \u0026quot;discovery.type=single-node\u0026quot;：非叢集模式。 -v es-data:/usr/share/elasticsearch/data：掛載資料卷，綁定 ES 的資料目錄。 -v es-logs:/usr/share/elasticsearch/logs：掛載資料卷，綁定 ES 的日誌目錄。 -v es-plugins:/usr/share/elasticsearch/plugins：掛載資料卷，綁定 ES 的插件目錄。 --privileged：授予資料卷存取權。 --network es-net ：加入一個名為 es-net 的網路中。 存取 \u0026lt;localhost:9200\u0026gt; 查看回傳類似下述內容即表示啟動成功。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 { \u0026#34;name\u0026#34; : \u0026#34;6747e3f712ba\u0026#34;, \u0026#34;cluster_name\u0026#34; : \u0026#34;docker-cluster\u0026#34;, \u0026#34;cluster_uuid\u0026#34; : \u0026#34;GSLtjxiMSlyRRRW-pSzvWQ\u0026#34;, \u0026#34;version\u0026#34; : { \u0026#34;number\u0026#34; : \u0026#34;7.12.1\u0026#34;, \u0026#34;build_flavor\u0026#34; : \u0026#34;default\u0026#34;, \u0026#34;build_type\u0026#34; : \u0026#34;docker\u0026#34;, \u0026#34;build_hash\u0026#34; : \u0026#34;3186837139b9c6b6d23c3200870651f10d3343b7\u0026#34;, \u0026#34;build_date\u0026#34; : \u0026#34;2021-04-20T20:56:39.040728659Z\u0026#34;, \u0026#34;build_snapshot\u0026#34; : false, \u0026#34;lucene_version\u0026#34; : \u0026#34;8.8.0\u0026#34;, \u0026#34;minimum_wire_compatibility_version\u0026#34; : \u0026#34;6.8.0\u0026#34;, \u0026#34;minimum_index_compatibility_version\u0026#34; : \u0026#34;6.0.0-beta1\u0026#34; }, \u0026#34;tagline\u0026#34; : \u0026#34;You Know, for Search\u0026#34; } Kibana 拉取相同版本的映像檔。\n1 docker pull kibana:7.12.1 執行\n1 2 3 4 5 6 docker run -d \\ --name kibana \\ -e ELASTICSEARCH_HOSTS=http://es:9200 \\ --network=es-net \\ -p 5601:5601 \\ kibana:7.12.1 其中 -e ELASTICSEARCH_HOSTS=http://es:9200\u0026quot;：設定 Elasticsearch 的位址，因為 Kibana 已經與 Elasticsearch 在同一個網路，因此可以用容器名稱直接存取 Elasticsearch。\nKibana 啟動通常比較慢，需要多等一會兒，可以查看日誌，若出現連接埠號則表示啟動成功。\n1 docker logs -f kibana 存取 \u0026lt;localhost:5601\u0026gt; 查看結果。\nIK 斷詞器 ES 在建立倒排索引時需要對文件斷詞；在搜尋時，需要對使用者輸入內容斷詞。但預設的斷詞規則對中文處理不太友善，例如測試：\n1 2 3 4 5 6 # 測試斷詞 POST /_analyze { \u0026#34;analyzer\u0026#34;: \u0026#34;standard\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;初次使用 Elasticsearch\u0026#34; } 語法說明：\nPOST：請求方式。 /_analyze：請求路徑。這裡省略了 http://localhost:9200，由 Kibana 補充。 請求參數使用 JSON。 analyzer：斷詞器型別，預設為 standard。 text：需要斷詞的內容。 結果為：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 { \u0026#34;tokens\u0026#34; : [ { \u0026#34;token\u0026#34; : \u0026#34;初\u0026#34;, \u0026#34;start_offset\u0026#34; : 0, \u0026#34;end_offset\u0026#34; : 1, \u0026#34;type\u0026#34; : \u0026#34;\u0026lt;IDEOGRAPHIC\u0026gt;\u0026#34;, \u0026#34;position\u0026#34; : 0 }, { \u0026#34;token\u0026#34; : \u0026#34;次\u0026#34;, \u0026#34;start_offset\u0026#34; : 1, \u0026#34;end_offset\u0026#34; : 2, \u0026#34;type\u0026#34; : \u0026#34;\u0026lt;IDEOGRAPHIC\u0026gt;\u0026#34;, \u0026#34;position\u0026#34; : 1 }, { \u0026#34;token\u0026#34; : \u0026#34;使\u0026#34;, \u0026#34;start_offset\u0026#34; : 2, \u0026#34;end_offset\u0026#34; : 3, \u0026#34;type\u0026#34; : \u0026#34;\u0026lt;IDEOGRAPHIC\u0026gt;\u0026#34;, \u0026#34;position\u0026#34; : 2 }, { \u0026#34;token\u0026#34; : \u0026#34;用\u0026#34;, \u0026#34;start_offset\u0026#34; : 3, \u0026#34;end_offset\u0026#34; : 4, \u0026#34;type\u0026#34; : \u0026#34;\u0026lt;IDEOGRAPHIC\u0026gt;\u0026#34;, \u0026#34;position\u0026#34; : 3 }, { \u0026#34;token\u0026#34; : \u0026#34;elasticsearch\u0026#34;, \u0026#34;start_offset\u0026#34; : 5, \u0026#34;end_offset\u0026#34; : 18, \u0026#34;type\u0026#34; : \u0026#34;\u0026lt;ALPHANUM\u0026gt;\u0026#34;, \u0026#34;position\u0026#34; : 4 } ] } 可以看到斷詞效果非常不好，處理中文斷詞，一般會使用 IK 斷詞器。\nIK 斷詞器 Github： https://github.com/medcl/elasticsearch-analysis-ik 線上安裝 注意安裝版本需與 ES 對應。\n1 2 3 4 5 6 7 8 9 10 # 進入容器內部 docker exec -it elasticsearch /bin/bash # 線上下載並安裝 ./bin/elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.12.1/elasticsearch-analysis-ik-7.12.1.zip # 離開 exit # 重新啟動容器 docker restart elasticsearch 離線安裝 安裝插件需要知道 Elasticsearch 的 plugins 目錄位置，上述使用資料卷掛載到本機，可使用下面指令查看：\n1 docker volume inspect es-plugins 輸出的 JSON 的 Mountpoint 即為目錄。\n將從 Github 下載的壓縮檔解壓縮後，將資料夾重新命名為 ik，放到 plugins 目錄下。\n重新啟動容器。\n1 docker restart es 測試效果 IK 斷詞器有兩種模式：\nik_smart：最少切分。 ik_max_word：最細切分。 還是上例：\n1 2 3 4 5 6 # 測試 IK 斷詞 POST /_analyze { \u0026#34;analyzer\u0026#34;: \u0026#34;ik_smart\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;初次使用 Elasticsearch\u0026#34; } 結果：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 { \u0026#34;tokens\u0026#34; : [ { \u0026#34;token\u0026#34; : \u0026#34;初次\u0026#34;, \u0026#34;start_offset\u0026#34; : 0, \u0026#34;end_offset\u0026#34; : 2, \u0026#34;type\u0026#34; : \u0026#34;CN_WORD\u0026#34;, \u0026#34;position\u0026#34; : 0 }, { \u0026#34;token\u0026#34; : \u0026#34;使用\u0026#34;, \u0026#34;start_offset\u0026#34; : 2, \u0026#34;end_offset\u0026#34; : 4, \u0026#34;type\u0026#34; : \u0026#34;CN_WORD\u0026#34;, \u0026#34;position\u0026#34; : 1 }, { \u0026#34;token\u0026#34; : \u0026#34;elasticsearch\u0026#34;, \u0026#34;start_offset\u0026#34; : 5, \u0026#34;end_offset\u0026#34; : 18, \u0026#34;type\u0026#34; : \u0026#34;ENGLISH\u0026#34;, \u0026#34;position\u0026#34; : 2 } ] } 此範例兩種斷詞模式結果相同，可使用其他更長語句測試結果。\n擴展詞庫 隨著網際網路發展，會不斷湧現新詞語，在原有的詞彙列表中並不存在，所以詞彙列表也需要不斷更新。若擴展 IK 詞庫，只需要修改 IK 目錄 config 目錄中的 IKAnalyzer.cfg.xml 文件即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE properties SYSTEM \u0026#34;http://java.sun.com/dtd/properties.dtd\u0026#34;\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;comment\u0026gt;IK Analyzer 擴展設定\u0026lt;/comment\u0026gt; \u0026lt;!--使用者可以在這裡設定自己的擴展字典 --\u0026gt; \u0026lt;entry key=\u0026#34;ext_dict\u0026#34;\u0026gt;ext.dic\u0026lt;/entry\u0026gt; \u0026lt;!--使用者可以在這裡設定自己的擴展停用詞字典--\u0026gt; \u0026lt;entry key=\u0026#34;ext_stopwords\u0026#34;\u0026gt;stopwords.dic\u0026lt;/entry\u0026gt; \u0026lt;!--使用者可以在這裡設定遠端擴展字典 --\u0026gt; \u0026lt;!-- \u0026lt;entry key=\u0026#34;remote_ext_dict\u0026#34;\u0026gt;words_location\u0026lt;/entry\u0026gt; --\u0026gt; \u0026lt;!--使用者可以在這裡設定遠端擴展停用詞字典--\u0026gt; \u0026lt;!-- \u0026lt;entry key=\u0026#34;remote_ext_stopwords\u0026#34;\u0026gt;words_location\u0026lt;/entry\u0026gt; --\u0026gt; \u0026lt;/properties\u0026gt; 如上將擴展詞放在 ./ext.dic，停用詞放在 ./stopwords.dic。\n停用詞可以放一些無意義的詞，如 的、啊 等。\n設定好後重新啟動 ES。\nDSL 索引庫操作 索引庫就類似資料庫表，要向 ES 中儲存資料，必須先建立「庫」和「表」。\nMapping 映射屬性 Mapping 是對索引庫中文件的限制，常見的 Mapping 屬性包括：\ntype：欄位資料型別，常見的簡單型別有： 字串：text（可斷詞的文字）、keyword（精確值，例如：品牌、國家、IP 位址） 數值：long、integer、short、byte、double、float、 布林：boolean 日期：date 物件：object index：是否建立索引，預設為 true。 analyzer：使用哪種斷詞器。 properties：該欄位的子欄位。 建立索引庫 請求方式：PUT 請求路徑：/索引庫名稱，可以自訂。 請求參數：mapping 映射。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 PUT /索引庫名稱 { \u0026#34;mappings\u0026#34;: { \u0026#34;properties\u0026#34;: { \u0026#34;欄位名稱\u0026#34;:{ \u0026#34;type\u0026#34;: \u0026#34;text\u0026#34;, \u0026#34;analyzer\u0026#34;: \u0026#34;ik_smart\u0026#34; }, \u0026#34;欄位名稱2\u0026#34;:{ \u0026#34;type\u0026#34;: \u0026#34;keyword\u0026#34;, \u0026#34;index\u0026#34;: \u0026#34;false\u0026#34; }, \u0026#34;欄位名稱3\u0026#34;:{ \u0026#34;properties\u0026#34;: { \u0026#34;子欄位\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;keyword\u0026#34; } } }, // code } } } 例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 # 建立索引庫 PUT /hello { \u0026#34;mappings\u0026#34;: { \u0026#34;properties\u0026#34;: { \u0026#34;info\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;text\u0026#34;, \u0026#34;analyzer\u0026#34;: \u0026#34;ik_smart\u0026#34; }, \u0026#34;email\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;keyword\u0026#34;, \u0026#34;index\u0026#34;: false }, \u0026#34;name\u0026#34;: { \u0026#34;properties\u0026#34;: { \u0026#34;firstName\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;keyword\u0026#34; }, \u0026#34;lastName\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;keyword\u0026#34; } } } } } } 執行後回傳類似即成功：\n1 2 3 4 5 { \u0026#34;acknowledged\u0026#34; : true, \u0026#34;shards_acknowledged\u0026#34; : true, \u0026#34;index\u0026#34; : \u0026#34;hello\u0026#34; } 查詢索引庫 請求方式：GET\n請求路徑：/索引庫名稱\n請求參數：無\n格式：\n1 GET /索引庫名稱 例如：\n1 2 # 查看索引庫 GET /hello 結果：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 { \u0026#34;hello\u0026#34; : { \u0026#34;aliases\u0026#34; : { }, \u0026#34;mappings\u0026#34; : { \u0026#34;properties\u0026#34; : { \u0026#34;email\u0026#34; : { \u0026#34;type\u0026#34; : \u0026#34;keyword\u0026#34;, \u0026#34;index\u0026#34; : false }, \u0026#34;info\u0026#34; : { \u0026#34;type\u0026#34; : \u0026#34;text\u0026#34;, \u0026#34;analyzer\u0026#34; : \u0026#34;ik_smart\u0026#34; }, \u0026#34;name\u0026#34; : { \u0026#34;properties\u0026#34; : { \u0026#34;firstName\u0026#34; : { \u0026#34;type\u0026#34; : \u0026#34;keyword\u0026#34; }, \u0026#34;lastName\u0026#34; : { \u0026#34;type\u0026#34; : \u0026#34;keyword\u0026#34; } } } } }, \u0026#34;settings\u0026#34; : { \u0026#34;index\u0026#34; : { \u0026#34;routing\u0026#34; : { \u0026#34;allocation\u0026#34; : { \u0026#34;include\u0026#34; : { \u0026#34;_tier_preference\u0026#34; : \u0026#34;data_content\u0026#34; } } }, \u0026#34;number_of_shards\u0026#34; : \u0026#34;1\u0026#34;, \u0026#34;blocks\u0026#34; : { \u0026#34;read_only_allow_delete\u0026#34; : \u0026#34;true\u0026#34; }, \u0026#34;provided_name\u0026#34; : \u0026#34;hello\u0026#34;, \u0026#34;creation_date\u0026#34; : \u0026#34;1703683379263\u0026#34;, \u0026#34;number_of_replicas\u0026#34; : \u0026#34;1\u0026#34;, \u0026#34;uuid\u0026#34; : \u0026#34;zn-kPdsETZeFcB0nXK79hg\u0026#34;, \u0026#34;version\u0026#34; : { \u0026#34;created\u0026#34; : \u0026#34;7120199\u0026#34; } } } } } 修改索引庫 索引庫和 Mapping 一旦建立，不允許修改，但可以新增欄位。\n1 2 3 4 5 6 7 8 PUT /索引庫名稱/_mapping { \u0026#34;properties\u0026#34;: { \u0026#34;新欄位名稱\u0026#34;:{ \u0026#34;type\u0026#34;: \u0026#34;integer\u0026#34; } } } 例如：\n1 2 3 4 5 6 7 8 9 10 # 新增欄位 PUT /hello/_mapping { \u0026#34;properties\u0026#34;: { \u0026#34;age\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;integer\u0026#34;, \u0026#34;index\u0026#34;: false } } } 如果遇到 read-only-allow-delete 類似錯誤，產生原因為磁碟剩餘空間不足 5%，可透過以下請求解決：\n1 2 3 4 5 6 7 8 PUT _settings { \u0026#34;index\u0026#34;: { \u0026#34;blocks\u0026#34;: { \u0026#34;read_only_allow_delete\u0026#34;: \u0026#34;false\u0026#34; } } } 刪除索引庫 請求方式：DELETE\n請求路徑：/索引庫名稱\n請求參數：無\n格式：\n1 DELETE /索引庫名稱 例如：\n1 DELETE /hello 結果：\n1 2 3 { \u0026#34;acknowledged\u0026#34; : true } 索引庫操作總結 建立索引庫：PUT /索引庫名稱 查詢索引庫：GET /索引庫名稱 刪除索引庫：DELETE /索引庫名稱 新增欄位：PUT /索引庫名稱/_mapping DSL 文件操作 新增文件 1 2 3 4 5 6 7 8 9 10 POST /索引庫名稱/_doc/文件id { \u0026#34;欄位1\u0026#34;: \u0026#34;值1\u0026#34;, \u0026#34;欄位2\u0026#34;: \u0026#34;值2\u0026#34;, \u0026#34;欄位3\u0026#34;: { \u0026#34;子屬性1\u0026#34;: \u0026#34;值3\u0026#34;, \u0026#34;子屬性2\u0026#34;: \u0026#34;值4\u0026#34; }, // code } 範例：\n1 2 3 4 5 6 7 8 9 10 # 新增文件 PUT /hello/_doc/1 { \u0026#34;info\u0026#34;: \u0026#34;hello es\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;blog@yexca.net\u0026#34;, \u0026#34;name\u0026#34;: { \u0026#34;firstName\u0026#34;: \u0026#34;yexca\u0026#34;, \u0026#34;lastName\u0026#34;: \u0026#34;Dale\u0026#34; } } 結果：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 { \u0026#34;_index\u0026#34; : \u0026#34;hello\u0026#34;, \u0026#34;_type\u0026#34; : \u0026#34;_doc\u0026#34;, \u0026#34;_id\u0026#34; : \u0026#34;1\u0026#34;, \u0026#34;_version\u0026#34; : 1, \u0026#34;result\u0026#34; : \u0026#34;created\u0026#34;, \u0026#34;_shards\u0026#34; : { \u0026#34;total\u0026#34; : 2, \u0026#34;successful\u0026#34; : 1, \u0026#34;failed\u0026#34; : 0 }, \u0026#34;_seq_no\u0026#34; : 0, \u0026#34;_primary_term\u0026#34; : 1 } 查詢文件 1 GET /{索引庫名稱}/_doc/{id} 範例：\n1 2 # 查詢文件 GEt /hello/_doc/1 結果：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 { \u0026#34;_index\u0026#34; : \u0026#34;hello\u0026#34;, \u0026#34;_type\u0026#34; : \u0026#34;_doc\u0026#34;, \u0026#34;_id\u0026#34; : \u0026#34;1\u0026#34;, \u0026#34;_version\u0026#34; : 1, \u0026#34;_seq_no\u0026#34; : 0, \u0026#34;_primary_term\u0026#34; : 1, \u0026#34;found\u0026#34; : true, \u0026#34;_source\u0026#34; : { \u0026#34;info\u0026#34; : \u0026#34;hello es\u0026#34;, \u0026#34;email\u0026#34; : \u0026#34;blog@yexca.net\u0026#34;, \u0026#34;name\u0026#34; : { \u0026#34;firstName\u0026#34; : \u0026#34;yexca\u0026#34;, \u0026#34;lastName\u0026#34; : \u0026#34;Dale\u0026#34; } } } 修改文件 修改有兩種方式，完整修改與增量修改。\n完整修改 完整修改是覆蓋原來的文件的內容，其本質是：\n根據指定的 id 刪除文件。 新增一個相同 id 的文件。 如果 id 不存在，也會執行第二步，也就從修改變成新增了 (覆蓋寫入)。\n1 2 3 4 5 6 PUT /{索引庫名稱}/_doc/文件id { \u0026#34;欄位1\u0026#34;: \u0026#34;值1\u0026#34;, \u0026#34;欄位2\u0026#34;: \u0026#34;值2\u0026#34;, // code } 例如：\n1 2 3 4 5 6 7 8 9 10 # 修改-完整修改 PUT /hello/_doc/1 { \u0026#34;info\u0026#34;: \u0026#34;hello es\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;es@yexca.net\u0026#34;, \u0026#34;name\u0026#34;: { \u0026#34;firstName\u0026#34;: \u0026#34;yexca\u0026#34;, \u0026#34;lastName\u0026#34;: \u0026#34;Dale\u0026#34; } } 結果：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 { \u0026#34;_index\u0026#34; : \u0026#34;hello\u0026#34;, \u0026#34;_type\u0026#34; : \u0026#34;_doc\u0026#34;, \u0026#34;_id\u0026#34; : \u0026#34;1\u0026#34;, \u0026#34;_version\u0026#34; : 2, \u0026#34;result\u0026#34; : \u0026#34;updated\u0026#34;, \u0026#34;_shards\u0026#34; : { \u0026#34;total\u0026#34; : 2, \u0026#34;successful\u0026#34; : 1, \u0026#34;failed\u0026#34; : 0 }, \u0026#34;_seq_no\u0026#34; : 1, \u0026#34;_primary_term\u0026#34; : 1 } 查詢可發現信箱已經修改。\n增量修改 增量修改是只修改指定 id 匹配的文件中的部分欄位。\n1 2 3 4 5 6 POST /{索引庫名稱}/_update/文件id { \u0026#34;doc\u0026#34;: { \u0026#34;欄位名稱\u0026#34;: \u0026#34;新的值\u0026#34;, } } 例如：\n1 2 3 4 5 6 7 # 修改-增量修改 POST /hello/_update/1 { \u0026#34;doc\u0026#34;: { \u0026#34;email\u0026#34;: \u0026#34;blog@yexca.net\u0026#34; } } 結果：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 { \u0026#34;_index\u0026#34; : \u0026#34;hello\u0026#34;, \u0026#34;_type\u0026#34; : \u0026#34;_doc\u0026#34;, \u0026#34;_id\u0026#34; : \u0026#34;1\u0026#34;, \u0026#34;_version\u0026#34; : 3, \u0026#34;result\u0026#34; : \u0026#34;updated\u0026#34;, \u0026#34;_shards\u0026#34; : { \u0026#34;total\u0026#34; : 2, \u0026#34;successful\u0026#34; : 1, \u0026#34;failed\u0026#34; : 0 }, \u0026#34;_seq_no\u0026#34; : 2, \u0026#34;_primary_term\u0026#34; : 1 } 查詢可發現信箱已經修改。\n刪除文件 1 DELETE /{索引庫名稱}/_doc/id值 例如：\n1 2 # 刪除文件 DELETE /hello/_doc/1 結果：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 { \u0026#34;_index\u0026#34; : \u0026#34;hello\u0026#34;, \u0026#34;_type\u0026#34; : \u0026#34;_doc\u0026#34;, \u0026#34;_id\u0026#34; : \u0026#34;1\u0026#34;, // 因為中間我修改了其他的，版本號變高了 \u0026#34;_version\u0026#34; : 8, \u0026#34;result\u0026#34; : \u0026#34;deleted\u0026#34;, \u0026#34;_shards\u0026#34; : { \u0026#34;total\u0026#34; : 2, \u0026#34;successful\u0026#34; : 1, \u0026#34;failed\u0026#34; : 0 }, \u0026#34;_seq_no\u0026#34; : 7, \u0026#34;_primary_term\u0026#34; : 1 } 文件操作總結 新增文件：POST /{索引庫名稱}/_doc/文件id { json 文件 } 查詢文件：GET /{索引庫名稱}/_doc/文件id 刪除文件：DELETE /{索引庫名稱}/_doc/文件id 修改文件： 完整修改：PUT /{索引庫名稱}/_doc/文件id { json 文件 } 增量修改：POST /{索引庫名稱}/_update/文件id { \u0026ldquo;doc\u0026rdquo;: {欄位}} ","date":"2025-01-29T23:38:51+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/226/","title":"Elasticsearch 入門"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 Redis 基礎: https://blog.yexca.net/zh-tw/archives/157/ Redis 分散式快取: 本文\n引言 所以這兩篇文章是同時寫的，但卻過了一年才發布是吧\n其實是我當時有三個主題要寫，但每次想起來要看的時候都忘了要寫什麼，就過了快一年\u0026hellip;\n問題 單機 Redis 存在：\n資料遺失問題：實現 Redis 資料持久化 並發能力問題：搭建主從叢集，實現讀寫分離 儲存能力問題：搭建分片叢集，利用插槽機制實現動態擴容 故障復原問題：利用 Redis 哨兵 (Sentinel)，實現健康檢查和自動復原 Redis 持久化 Redis 持久化有兩種方案：RDB 與 AOF\nRDB 持久化 RDB 全稱 Redis Database Backup file (Redis 資料備份檔案)，也叫做 Redis 資料快照。簡單來說就是把記憶體中所有資料都記錄到硬碟中。當 Redis 執行個體故障重新啟動後，從硬碟讀取快照檔案，復原資料。快照檔案稱為 RDB 檔案，預設儲存在執行目錄。\nRDB 會在以下四種情況下執行：\n執行 save 指令：立即執行，會導致主程序執行 RDB，其他所有指令被阻塞。僅在資料遷移時可能用到。 執行 bgsave 指令：非同步執行，開啟獨立子程序完成 RDB，主程序可以持續處理用戶請求，不受影響。 Redis 關機時：關機時會執行一次 save 指令。 觸發 RDB 條件時：於設定檔配置，如下： 1 2 3 4 # 900秒內，如果至少有1個key被修改，則執行bgsave ， 如果是save \u0026#34;\u0026#34; 則表示停用RDB save 900 1 save 300 10 save 60 10000 其他設定：\n1 2 3 4 5 6 7 8 # 是否壓縮，建議不開啟，壓縮也會消耗 CPU，硬碟空間相對便宜 rdbcompression yes # RDB檔案名稱 dbfilename dump.rdb # 檔案儲存的路徑目錄 dir ./ RDB 原理 bgsave 開始時會 fork 主程序得到子程序，子程序共享主程序的記憶體資料。完成 fork 後讀取記憶體資料並寫入 RDB 檔案。\nfork 採用的是 copy-on-write 技術：\n當主程序執行讀取操作時，存取共享記憶體。 當主程序執行寫入操作時，則會複製一份資料，執行寫入操作。 RDB 的缺點：\n執行間隔時間長，兩次 RDB 之間寫入的資料有遺失的風險。 fork 子程序、壓縮、寫出 RDB 檔案都比較耗時。 AOF 持久化 AOF 全稱 Append Only File (追加檔案)，Redis 處理的每一個寫入指令都會記錄在 AOF 檔案，可以看作指令日誌檔案。\nAOF 預設是關閉的，修改設定檔開啟：\n1 2 3 4 # 是否開啟AOF功能，預設是no appendonly yes # AOF檔案的名稱 appendfilename \u0026#34;appendonly.aof\u0026#34; 記錄頻率也可以透過 redis.conf 設定：\n1 2 3 4 5 6 # 表示每執行一次寫入指令，立即記錄到AOF檔案 appendfsync always # 寫入指令執行完先放入AOF緩衝區，然後表示每隔1秒將緩衝區資料寫到AOF檔案，是預設方案 appendfsync everysec # 寫入指令執行完先放入AOF緩衝區，由作業系統決定何時將緩衝區內容寫回硬碟 appendfsync no 設定項比較：\n設定項 寫入硬碟時機 優點 缺點 always 同步寫入 可靠性高，幾乎不丟資料 對效能影響大 everysec 每秒寫入 效能適中 最多遺失 1 秒資料 no 作業系統控制 效能最好 可靠性差，可能遺失大量資料 檔案重寫 因為是記錄指令，AOF 檔案會比 RDB 大很多，而且 AOF 會記錄對同一個 key 的多次寫入操作，但只有最後一次寫入操作才有意義。透過執行 bgrewriteaof 指令，可以讓 AOF 檔案執行重寫功能，用最少的指令達到相同效果。\n假設原先指令為：\n1 2 3 set num 123 set name jack set num 666 重寫後：\n1 mset name jack num 666 Redis 也會在觸發閾值時自動重寫 AOF 檔案，在設定檔配置：\n1 2 3 4 # AOF檔案比上次檔案 增長超過多少百分比則觸發重寫 auto-aof-rewrite-percentage 100 # AOF檔案體積最小多大以上才觸發重寫 auto-aof-rewrite-min-size 64mb RDB 與 AOF 比較 RDB 與 AOF 各有優缺點，如果對資料安全性要求極高，在實際開發中往往會結合兩者來使用。\nRDB AOF 持久化方式 定時對整個記憶體做快照 記錄每一次執行的指令 資料完整性 不完整，兩次備份之間會遺失 相對完整，取決於寫入硬碟策略 檔案大小 會進行壓縮，檔案體積小 記錄指令，檔案體積很大 當機復原速度 很快 慢 資料復原優先級 低，因為資料完整性不如 AOF 高，因為資料完整性更高 系統資源佔用 高，大量 CPU 和記憶體消耗 低，主要是硬碟 I/O 資源\n但 AOF 重寫時會佔用大量 CPU 和記憶體資源 使用場景 可以容忍數分鐘的資料遺失，追求更快的啟動速度 對資料安全性要求較高 Redis 主從架構 單節點 Redis 的並發能力是有上限的，要進一步提高 Redis 的並發能力，就需要搭建主從叢集，實現讀寫分離。\n安裝叢集 基於 CentOS7\n參考上圖一共三個節點，部署在同一台機器，連接埠為 7001(master)、7002、7003。\n首先建立目錄：\n1 2 cd /tmp mkdir 7001 7002 7003 如需更改設定，需恢復預設的 RDB 模式：\n1 2 3 4 5 6 7 8 # 開啟RDB # save \u0026#34;\u0026#34; save 3600 1 save 300 100 save 60 10000 # 關閉AOF appendonly no 複製設定檔到每個執行個體目錄：\n1 2 3 4 5 6 7 # 方式一 cp redis-6.2.4/redis.conf 7001 cp redis-6.2.4/redis.conf 7002 cp redis-6.2.4/redis.conf 7003 # 方式二 echo 7001 7002 7003 | xargs -t -n 1 cp redis-6.2.4/redis.conf 修改每個執行個體的連接埠，工作目錄（連接埠修改，rdb 檔案儲存位置修改）：\n1 2 3 sed -i -e \u0026#39;s/6379/7001/g\u0026#39; -e \u0026#39;s/dir .\\//dir \\/tmp\\/7001\\//g\u0026#39; 7001/redis.conf sed -i -e \u0026#39;s/6379/7002/g\u0026#39; -e \u0026#39;s/dir .\\//dir \\/tmp\\/7002\\//g\u0026#39; 7002/redis.conf sed -i -e \u0026#39;s/6379/7003/g\u0026#39; -e \u0026#39;s/dir .\\//dir \\/tmp\\/7003\\//g\u0026#39; 7003/redis.conf 修改 IP，每個目錄都要改 (替換 ip_address)：\n1 2 3 4 5 6 7 # 逐一執行 sed -i \u0026#39;1a replica-announce-ip ip_address\u0026#39; 7001/redis.conf sed -i \u0026#39;1a replica-announce-ip ip_address\u0026#39; 7002/redis.conf sed -i \u0026#39;1a replica-announce-ip ip_address\u0026#39; 7003/redis.conf # 或者一鍵修改 printf \u0026#39;%s\\n\u0026#39; 7001 7002 7003 | xargs -I{} -t sed -i \u0026#39;1a replica-announce-ip ip_address\u0026#39; {}/redis.conf 啟動：\n1 2 3 4 5 6 # 第1個 redis-server 7001/redis.conf # 第2個 redis-server 7002/redis.conf # 第3個 redis-server 7003/redis.conf 停止：\n1 printf \u0026#39;%s\\n\u0026#39; 7001 7002 7003 | xargs -I{} -t redis-cli -p {} shutdown ","date":"2025-01-28T21:47:19+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/225/","title":"Redis 分散式快取"},{"content":" 📢 此頁面有使用機器翻譯喲 音有所感系列 歌曲名稱 翻譯 連結 僕が死のうと思ったのは 曾經我也想過一了百了 https://blog.yexca.net/zh-tw/archives/214 あくあ色ぱれっと aqua 的調色盤 https://blog.yexca.net/zh-tw/archives/219 恋の押し売り 戀愛推銷 https://blog.yexca.net/zh-tw/archives/220 17さいのうた 17 歲的歌 本文 drop 墜入愛河 https://blog.yexca.net/zh-tw/archives/230 生きるを選んだ私へ 致選擇活下去的自己 https://blog.yexca.net/zh-tw/archives/239 rainy lady 雨意未晴 https://blog.yexca.net/zh-tw/archives/249 恋しくなったら手を叩こう 想談戀愛的話就拍拍手吧 https://blog.yexca.net/zh-tw/archives/250 pris-magic! 稜鏡魔法! https://blog.yexca.net/zh-tw/archives/260 引言 其實我一開始只是聽懂了有關「寫給自己的信」那部分，覺得跟我第一次聽到時的心情相當契合，所以就一直聽下去了。\n後來嘗試去翻譯這首歌，再加上最近的種種經歷，我感覺自己現在的狀態，好像跟ユイカ當時的情況很像。現在的我，就跟這首歌一樣，只有迷惘：究竟要成為什麼樣的人？未來會是什麼模樣？我又該往哪裡前進呢？\n正面一點，就像歌詞裡所說的，試著接受自己吧。離開那份迷惘，隨便找一件自己感覺喜歡的事情去做吧。\n最後，也想感謝一直鼓勵著我的人，以及那些雖然嘴上沒說鼓勵，但卻在行動上支持我的人。\n歌曲影片 歌詞 こんな私の未熟なうたを　聴いてくれてどうも有難うね 未熟: みじゅく\n感謝你來聽我還很青澀的歌\nもう少しで私は未熟な大人に　なるみたいです\n再過不久，我好像也要變成不成熟的大人了\nなんか笑っちゃうね\n總覺得有點好笑呢\n本当はね\n其實啊\nもっと前を向けるようなうたを　書くつもりだったけど\n本打算寫更加讓人積極的歌\n書けなくて\n卻怎麼也寫不出來\n私はまだ　他の誰かを支えられるほど\n我還沒有達到可以支撐別人的存在\n強くなかったみたい　ごめんね\n看起來並不怎麼要強，真是抱歉吶\n拝啓　未来の私へ　今そこで\n敬啟，未來的我啊，現在在那裡\nどんなことをして　生きていますか\n正做著什麼樣的事情，過著什麼樣的生活呢\n拝啓　今の私へ　今ここで\n敬啟，現在的我啊，現在在此刻\nどんなことをしたら　生きていけるんでしょうか\n我該做些什麼，才可以繼續活下去呢\n\u0026ldquo;好きだからかっこいい\u0026quot;とか　\u0026ldquo;そばにいる\u0026quot;とか\n曾經寫過「因為喜歡才覺得帥」、「想要待在身邊」\n\u0026ldquo;勝手に盗んだ\u0026quot;とか　書いてた\n還有「隨便就偷走你的心」之類的\nどうせだったらもうちょっと　貴方みたいに\n這樣的話，不如再向你\nやさしいうたを書けばよかったね\n寫首溫暖的歌就好了呢\n本当はね　好きなことだけして生きたいの\n其實啊，我只想做喜歡的事情吶\nでもそれは上手な生き方とは言えないから\n但那稱不上成熟的活法\n無駄になっても　意味がなくても\n即使顯得徒勞，毫無意義\n今はここから　離れなきゃいけないの　ごめんね\n現在還是不得不離開了，抱歉吶\n拝啓　未来の私へ　今そこで\n敬啟，未來的我啊，現在在那裡\nどんな大人になって　生きていますか\n變成了什麼樣的大人，過著什麼樣的生活呢\n拝啓　今の私へ　今ここで\n敬啟，現在的我啊，此刻在這裡\nどんな大人になりたいと　言えばいいんでしょうか\n說出「想要成為什麼樣的大人」可以嗎\n「さよなら」は悲しくなるからさ\n「再見」聽起來太悲傷了\n「またね」って言わせて\n請讓我說「下次見」吧\nいつか私が　今みたいな　うたを書けなくなっても\n就算未來哪天我寫不出來這樣的歌了\n怒らないでね\n也請不要怪我\n拝啓　過去の私へ　今の私は\n敬啟，過去的我啊，現在的我\nずっと夢見ていたこと叶えてるよ\n實現了一直以來的夢想喲\n拝啓　今の私へ\n敬啟，現在的我啊\nこんな情けない　うただって歌えばいいよ 情け: なさけ\n唱出這麼軟弱的歌也可以喲\nそれが私だから\n因為那就是我\n拝啓　未来の私へ　今そこは\n敬啟，未來的我啊，現在在那裡\nどんな綺麗な世界が　広がっていますか\n展開著怎樣絢麗多彩的世界呢\n拝啓　今の私へ　今ここが\n敬啟，現在的我啊，現在的時刻\nどんな世界よりも　幸せでした\n比任何世界都要幸福呀\nこんな私の未熟なうたを　聴いてくれてどうも有難うね\n感謝你來聽我還很青澀的歌\nこれから私は未熟な大人に　なる準備をします\n接下來我也要為成為不夠成熟的大人，而好好準備\n「じゃあ またね」\n「那麼，下次見」\n","date":"2025-01-25T16:57:49+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/224/","title":"音之所感 - 《17さいのうた》"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 設定 YAML、YML、Properties 檔案都可以進行設定，也可以透過 Java 系統屬性及命令列參數。\n優先順序：命令列參數 \u0026gt; Java 系統屬性 \u0026gt; Properties 檔案 \u0026gt; YML 檔案 \u0026gt; YAML 檔案\n命令列使用時，需要先執行 Maven 的包裝指令，然後在命令列執行。\n1 2 3 4 5 java -jar path_to_jar.jar # Java 系統屬性，以埠號為例 java -Dserver.port=9000 -jar path_to_jar.jar # 命令列參數，以埠號為例 java -jar path_to_jar.jar --server.port=9000 SpringBoot 專案進行包裝時需要引入 spring-boot-maven-plugin 外掛程式（如果基於官方樣板建立專案，會自動加入該外掛程式）。\nBean 管理 取得 Bean 對於預設的單例非延遲載入 Bean 而言，Spring 專案啟動時，會把 Bean 都建立好並放置在 IOC 容器中（例如加上 @Lazy 註解後，將會在第一次被使用時實例化）。\n如果想主動取得這些 Bean，可以透過以下方式。\n根據名稱取得 1 Object getBean(String name) 根據類型取得 1 \u0026lt;T\u0026gt; T getBean(Class\u0026lt;T\u0026gt; requiredType) 根據名稱及類型取得（類型轉換） 1 \u0026lt;T\u0026gt; T getBean(String name, Class\u0026lt;T\u0026gt; requiredType) 為了使用此方法，需要先取得 IOC 容器物件。\n1 2 3 4 5 6 7 8 9 10 11 12 13 @Autowired private ApplicationContext applicationContext; //IOC 容器物件 public void testGetBean(){ // 根據 Bean 的名稱取得 DeptController beanl = (DeptController) applicationContext.getBean(\u0026#34;deptController\u0026#34;); // 根據 Bean 的類型取得 DeptController bean2 = applicationContext.getBean(DeptController.class); // 根據 Bean 的名稱及類型取得 DeptController bean3 = applicationContext.getBean(\u0026#34;deptController\u0026#34;, DeptController.class); } Bean 作用域 Spring 支援五種作用域，其中後三種只在 Web 環境中生效。\n作用域 描述 singleton 容器內同名稱的 Bean 只有一個實例（單例） prototype 每次使用該 Bean 時會建立新的實例（非單例） request 每個請求範圍內會建立新的實例 session 每個會話範圍內會建立新的實例 application 每個應用程式範圍內會建立新的實例 使用註解 @Scope 設定作用域\n1 2 3 4 5 6 // 設定為非單例 @Scope(\u0026#34;prototype\u0026#34;) @RestController public class xxxController{ } 在實際開發中，絕大部分的 Bean 都是單例的，也就是說絕大部分的 Bean 不需要設定 scope 屬性。\n第三方 Bean 如果要管理的 Bean 物件來自於第三方（並非自訂），就無法使用 @Component 及衍生註解來宣告 Bean，這時就需要用到 @Bean 註解。例如解析 XML 檔案的 dom4j。\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.dom4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;dom4j\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.1.3\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 依賴如上所示。\n1 2 3 4 5 6 7 @SpringBootApplication public class xxxApplication{ @Bean // 將方法回傳值交給 IOC 容器管理，使其成為 IOC 容器的 Bean 物件 public SAXReader saxReader(){ return new SAXReader(); } } 不過，若要管理第三方 Bean 物件，建議對這些 Bean 進行集中分類設定，可以透過 @Configuration 註解宣告一個設定類。\n1 2 3 4 5 6 7 @Configuration public class CommonConfig { @Bean public SAXReader saxReader(){ return new SAXReader(); } } 透過 @Bean 註解的 name 或 value 屬性可以宣告 Bean 的名稱，如果不指定，預設 Bean 的名稱就是方法名。如果第三方 Bean 需要依賴其他 Bean 物件，直接在 Bean 定義方法中設定形參即可，容器會根據類型自動組裝。\n1 2 3 4 5 6 7 @Configuration public class CommonConfig { @Bean public SAXReader saxReader(XxService xxService){ return new SAXReader(); } } 起始依賴 在開發中，若直接使用 Spring 需要引入相關依賴，並且保證版本匹配；而使用 SpringBoot 則只需要引入起始依賴即可。其原理是 Maven 的傳遞依賴，其他的依賴都會自動透過 Maven 的依賴機制傳遞進來。\n自動配置 SpringBoot 的自動配置就是當 Spring 容器啟動後，一些設定類、Bean 物件會自動儲存到 IOC 容器中，不需要我們手動去宣告，從而簡化了開發，省去了繁瑣的設定操作。\n設定類 @Configuration 的底層是 @Component，也是容器中的一個 Bean 物件。\n在引入依賴之後，是如何將依賴 Jar 檔案中所定義的設定類以及 Bean 載入到 Spring IOC 容器中的呢？\n@ComponentScan 使用 @ComponentScan 可以指定要掃描的套件，例如依賴匯入了 com.example 套件。\n1 2 @SpringBootApplication @ComponentScan({\u0026#34;net.yexca\u0026#34;,\u0026#34;com.example\u0026#34;}) 不過，當需要引入大量的第三方依賴時，上方需要設定大量的套件，而大面積的掃描效能也比較低。\n@Import 可以匯入普通類別、設定類以及 ImportSelector 介面實作類。\n普通類別 1 2 @Import(TokenParser.class) //匯入普通類別 @SpringBootApplication 設定類 設定類內容\n1 2 3 4 5 6 7 8 9 10 11 12 @Configuration public class HeaderConfig { @Bean public HeaderParser headerParser(){ return new HeaderParser(); } @Bean public HeaderGenerator headerGenerator(){ return new HeaderGenerator(); } } 啟動類\n1 2 @Import(HeaderConfig.class) //匯入設定類 @SpringBootApplication ImportSelector 介面實作類 ImportSelector 介面實作類內容\n1 2 3 4 5 6 public class MyImportSelector implements ImportSelector { public String[] selectImports(AnnotationMetadata importingClassMetadata) { //回傳值為字串陣列（陣列中封裝了具完整限定名稱的類別） return new String[]{\u0026#34;com.example.HeaderConfig\u0026#34;}; } } 啟動類\n1 2 @Import(MyImportSelector.class) //匯入 `ImportSelector` 介面實作類 @SpringBootApplication @EnableXxxxx 上述 @Import 需要首先知道第三方依賴中有哪些設定類或 Bean 才行；而第三方依賴可以提供 @EnableXxxxx 註解，封裝 @Import 註解以提供一些常用 Bean，使用時只需要 @EnableXxxxx 註解即可。\n例如上述 @Import 的設定類，可以封裝一個 @EnableHeaderConfig 註解。\n1 2 3 4 5 @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.TYPE) @Import(MyImportSelector.class)//指定要匯入哪些 Bean 物件或設定類 public @interface EnableHeaderConfig { } 然後只需要在啟動類加上 @EnableHeaderConfig 註解即可匯入相應的 Bean。\n1 2 @EnableHeaderConfig //使用第三方依賴提供的以 Enable 開頭的註解 @SpringBootApplication 此方法也是 SpringBoot 所採用的方式。\nSpringBoot 的自動配置 在 @SpringBootApplication 註解裡有 @EnableAutoConfiguration，其中 @Import({AutoConfigurationImportSelector.class}) 匯入了 ImportSelector 介面的實作類 AutoConfigurationImportSelector.class。\n在該實作類中覆寫了 selectImports() 方法。\n1 2 3 4 5 6 7 8 9 public String[] selectImports(AnnotationMetadata annotationMetadata) { if (!this.isEnabled(annotationMetadata)) { return NO_IMPORTS; } else { // 取得自動配置的設定類資訊集合 AutoConfigurationEntry autoConfigurationEntry = this.getAutoConfigurationEntry(annotationMetadata); return StringUtils.toStringArray(autoConfigurationEntry.getConfigurations()); } } 呼叫 getAutoConfigurationEntry() 方法取得了自動配置的設定類資訊集合。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 protected AutoConfigurationEntry getAutoConfigurationEntry(AnnotationMetadata annotationMetadata) { if (!this.isEnabled(annotationMetadata)) { return EMPTY_ENTRY; } else { AnnotationAttributes attributes = this.getAttributes(annotationMetadata); // 取得在設定檔中設定的所有自動配置類別的集合 List\u0026lt;String\u0026gt; configurations = this.getCandidateConfigurations(annotationMetadata, attributes); configurations = this.removeDuplicates(configurations); Set\u0026lt;String\u0026gt; exclusions = this.getExclusions(annotationMetadata, attributes); this.checkExcludedClasses(configurations, exclusions); configurations.removeAll(exclusions); configurations = this.getConfigurationClassFilter().filter(configurations); this.fireAutoConfigurationImportEvents(configurations, exclusions); return new AutoConfigurationEntry(configurations, exclusions); } } 其中 getCandidateConfigurations(annotationMetadata, attributes) 方法會取得在設定檔中設定的所有自動配置類別的集合。\n1 2 3 4 5 6 protected List\u0026lt;String\u0026gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) { List\u0026lt;String\u0026gt; configurations = new ArrayList(SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader())); ImportCandidates.load(AutoConfiguration.class, this.getBeanClassLoader()).forEach(configurations::add); Assert.notEmpty(configurations, \u0026#34;No auto configuration classes found in META-INF/spring.factories nor in META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports. If you are using a custom packaging, make sure that file is correct.\u0026#34;); return configurations; } 可以看到，它是取得 META-INF/spring.factories 和 META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports 檔案中設定類別的集合。\n上述兩個檔案通常在引入的起始依賴中。\n也就是說，當 SpringBoot 程式啟動時，就會載入設定檔當中所定義的設定類，並將這些設定類資訊（類別的完整限定名稱）封裝到 String 類型的陣列中，最終透過 @Import 註解將這些設定類全部載入到 Spring 的 IOC 容器中，交由 IOC 容器管理。\n@Conditional 但是檔案中的設定類那麼多，每個 Bean 都會註冊到 IOC 容器中嗎？並非如此，使用 @Conditional 註解可以讓 Bean 物件依照條件進行組裝。\n@Conditional 是一個父註解，底下有許多子註解。\n@ConditionalOnClass 判斷環境中是否存在對應的位元碼檔案，才會將 Bean 註冊到 IOC 容器。\n1 2 3 4 5 6 7 8 9 10 11 @Configuration public class HeaderConfig { @Bean //環境中存在指定的這個類別時，才會將該 Bean 加入 IOC 容器 @ConditionalOnClass(name=\u0026#34;io.jsonwebtoken.Jwts\u0026#34;) public HeaderParser headerParser(){ return new HeaderParser(); } } 上述 Bean 需要引入 JWT 權杖的依賴才會注入到 IOC 容器中。\n1 2 3 4 5 6 \u0026lt;!--JWT 權杖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.jsonwebtoken\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jjwt\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.9.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 測試\n1 2 3 4 5 6 7 8 9 10 11 @SpringBootTest public class AutoConfigurationTests { @Autowired private ApplicationContext applicationContext; @Test public void testHeaderParser(){ System.out.println(applicationContext.getBean(HeaderParser.class)); } } @ConditionalOnMissingBean 判斷環境中沒有對應的 Bean（類型或名稱），才會將 Bean 註冊到 IOC 容器。\n1 2 3 4 5 6 7 8 9 10 11 @Configuration public class HeaderConfig { @Bean //不存在該類型的 Bean 時，才會將該 Bean 加入 IOC 容器 @ConditionalOnMissingBean public HeaderParser headerParser(){ return new HeaderParser(); } } 上述當 IOC 中沒有 HeaderConfig 類型的 Bean 時才會建立。\n也可以在註解中指定其他 Bean 名稱。\n1 2 3 4 5 6 7 8 9 10 11 @Configuration public class HeaderConfig { @Bean //不存在指定名稱的 Bean 時，才會將該 Bean 加入 IOC 容器 @ConditionalOnMissingBean(name=\u0026#34;deptController2\u0026#34;) public HeaderParser headerParser(){ return new HeaderParser(); } } 上例在不存在名稱為 deptController2 的 Bean 物件時，才會建立 HeaderConfig 物件並註冊到 IOC。\n還可以指定類型。\n1 2 3 4 5 6 7 8 9 10 11 @Configuration public class HeaderConfig { @Bean //不存在指定類型的 Bean 時，才會將 Bean 加入 IOC 容器 @ConditionalOnMissingBean(HeaderConfig.class) public HeaderParser headerParser(){ return new HeaderParser(); } } 上例執行時呼叫該 Bean 會引發 NoSuchBeanDefinitionException 異常，因為 @Configuration 中有 @Component，所以會自動建立 HeaderConfig 的 Bean，因此不會建立 HeaderParser 的 Bean。\n@ConditionalOnProperty 判斷設定檔中存在對應屬性與值時，才會將 Bean 註冊到 IOC 容器。\n設定檔\n1 name: header 設定類\n1 2 3 4 5 6 7 8 9 10 11 @Configuration public class HeaderConfig { @Bean //設定檔中存在指定屬性名與值時，才會將 Bean 加入 IOC 容器 @ConditionalOnProperty(name =\u0026#34;name\u0026#34;,havingValue = \u0026#34;header\u0026#34;) public HeaderParser headerParser(){ return new HeaderParser(); } } 自訂起始依賴 例如自訂一個阿里雲 OSS 的起始依賴。\n首先是命名，SpringBoot 官方 Starter 命名為 spring-boot-starter-xxx，而第三方組織提供的則為 xxx-spring-boot-starter。\n然後是模組，需要按照規範定義兩個模組：\nStarter 模組，進行依賴管理，將程式開發所需的依賴都定義在 Starter 起始依賴中。 Autoconfigure 模組，用於自動配置。 定義好這兩個模組後，其他專案只需要引入起始依賴即可，自動配置模組會透過依賴傳遞引入。\n模組 POM 檔案 aliyun-oss-spring-boot-starter 模組\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.7.5\u0026lt;/version\u0026gt; \u0026lt;relativePath/\u0026gt; \u0026lt;!-- lookup parent from repository --\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;groupId\u0026gt;com.aliyun.oss\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;aliyun-oss-spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;java.version\u0026gt;11\u0026lt;/java.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!--引入autoconfigure模組--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.aliyun.oss\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;aliyun-oss-spring-boot-autoconfigure\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/project\u0026gt; aliyun-oss-spring-boot-autoconfigure 模組\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.7.5\u0026lt;/version\u0026gt; \u0026lt;relativePath/\u0026gt; \u0026lt;!-- lookup parent from repository --\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;groupId\u0026gt;com.aliyun.oss\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;aliyun-oss-spring-boot-autoconfigure\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;java.version\u0026gt;11\u0026lt;/java.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--引入Web起始依賴--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--Lombok--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--阿里雲OSS--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.aliyun.oss\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;aliyun-sdk-oss\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.15.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.xml.bind\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jaxb-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.3.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.activation\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;activation\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.1.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- no more than 2.3.3--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.glassfish.jaxb\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jaxb-runtime\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.3.3\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/project\u0026gt; 自動配置 AliOSSAutoConfiguration 類別\n1 2 3 4 5 6 7 8 9 10 11 12 13 @Configuration //匯入 AliOSSProperties 類別，並交給 Spring IOC 管理 @EnableConfigurationProperties(AliOSSProperties.class) public class AliOSSAutoConfiguration { //建立 AliOSSUtils 物件，並交給 Spring IOC 容器 @Bean public AliOSSUtils aliOSSUtils(AliOSSProperties aliOSSProperties){ AliOSSUtils aliOSSUtils = new AliOSSUtils(); aliOSSUtils.setAliOSSProperties(aliOSSProperties); return aliOSSUtils; } } AliOSSProperties 類別\n1 2 3 4 5 6 7 8 9 10 11 12 13 /*阿里雲 OSS 相關設定*/ @Data @ConfigurationProperties(prefix = \u0026#34;aliyun.oss\u0026#34;) public class AliOSSProperties { //區域 private String endpoint; //身份 ID private String accessKeyId ; //身份密鑰 private String accessKeySecret ; //儲存空間 private String bucketName; } AliOSSUtils 類別\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 @Data public class AliOSSUtils { private AliOSSProperties aliOSSProperties; /** * 實作上傳圖片到 OSS */ public String upload(MultipartFile multipartFile) throws IOException { // 取得上傳檔案的輸入流 InputStream inputStream = multipartFile.getInputStream(); // 避免檔案覆蓋 String originalFilename = multipartFile.getOriginalFilename(); String fileName = UUID.randomUUID().toString() + originalFilename.substring(originalFilename.lastIndexOf(\u0026#34;.\u0026#34;)); //上傳檔案到 OSS OSS ossClient = new OSSClientBuilder().build(aliOSSProperties.getEndpoint(), aliOSSProperties.getAccessKeyId(), aliOSSProperties.getAccessKeySecret()); ossClient.putObject(aliOSSProperties.getBucketName(), fileName, inputStream); //檔案存取路徑 String url =aliOSSProperties.getEndpoint().split(\u0026#34;//\u0026#34;)[0] + \u0026#34;//\u0026#34; + aliOSSProperties.getBucketName() + \u0026#34;.\u0026#34; + aliOSSProperties.getEndpoint().split(\u0026#34;//\u0026#34;)[1] + \u0026#34;/\u0026#34; + fileName; // 關閉 ossClient ossClient.shutdown(); return url;// 回傳上傳到 OSS 的路徑 } } 新建自動設定檔 META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports\n1 com.aliyun.oss.AliOSSAutoConfiguration 使用 引入依賴\n1 2 3 4 5 6 \u0026lt;!--引入阿里雲 OSS 起始依賴--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.aliyun.oss\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;aliyun-oss-spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 上例阿里雲 OSS 相關設定需要從設定檔讀取。\n1 2 3 4 5 6 7 #設定阿里雲 OSS 參數 aliyun: oss: endpoint: your_oss_region accessKeyId: your_key_id accessKeySecret: your_key_secret bucketName: your_bucker_name 測試\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 @RestController public class UploadController { @Autowired private AliOSSUtils aliOSSUtils; @PostMapping(\u0026#34;/upload\u0026#34;) public String upload(MultipartFile image) throws Exception { //上傳檔案到阿里雲 OSS String url = aliOSSUtils.upload(image); return url; } } ","date":"2025-01-23T15:06:36+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/223/","title":"Spring 自動配置與起始依賴"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 事務 事務是一組操作的集合，它是一個不可分割的工作單位，這些操作要嘛同時成功，要嘛同時失敗。\n操作：\n開啟事務 (一組操作開始前，開啟事務)：start transaction / begin 提交事務 (這組操作全部成功後，提交事務)：commit 回滾事務 (中間任何一個操作出現例外，回滾事務)：rollback 假設刪除部門後要繼續刪除該部門員工。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @Service public class DeptServiceImpl implements DeptService{ @Autowired private DeptMapper deptMapper; @Autowired private EmpMapper empMapper; @Override public void delete(Integer id）{ //1．刪除部門 deptMapper.delete(id); // 假如這裡出現錯誤，只刪除了部門，沒刪除員工 //2.根據部門id，刪除部門下的員工資訊 empMapper.deleteByDetId(id); } } 如上所示，將會留下不存在部門的員工，造成了資料的不一致。\nSpring 事務管理 註解：@Transactional，位置：Service 層方法、類別、介面上\n作用：將當前方法交給 Spring 進行事務管理，方法執行前開啟事務；成功執行完畢提交事務；出現例外回滾事務。\n上述方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @Service public class DeptServiceImpl implements DeptService{ @Autowired private DeptMapper deptMapper; @Autowired private EmpMapper empMapper; @Transactional // 交給Spring進行事務管理 @Override public void delete(Integer id）{ //1．刪除部門 deptMapper.delete(id); //2.根據部門id，刪除部門下的員工資訊 empMapper.deleteByDetId(id); } } 同時可以開啟事務管理日誌。\n1 2 3 4 #Spring事務管理日誌 logging: level: org.springframework.jdbc.support.JdbcTransactionManager: debug 事務屬性 - 回滾 預設情況下，只有出現執行期例外 (RuntimeException) 才回滾事務，透過 rollbackFor 屬性可以控制出現何種例外類型時，回滾事務。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @Service public class DeptServiceImpl implements DeptService{ @Autowired private DeptMapper deptMapper; @Autowired private EmpMapper empMapper; // 所有例外都回滾 @Transactional(rollbackFor = Exception.class) @Override public void delete(Integer id）{ //1．刪除部門 deptMapper.delete(id); //2.根據部門id，刪除部門下的員工資訊 empMapper.deleteByDetId(id); } } 事務屬性 - 傳播行為 事務傳播行為是指當一個事務方法被另一個事務方法呼叫時，這個事務方法應該如何進行事務。\n1 2 3 4 5 6 7 8 9 10 11 @Transactional public void a(){ // code userServices.b(); // code } @Transactional public void b(){ // code } 上述 a 呼叫了 b，b 該如何進行事務，加入 a 的事務或者單獨開一個事務。\n可以透過屬性 propagation 進行控制。\n屬性值 描述 REQUIRED (預設值) 需要事務，有則加入，無則建立新事務 REQUIRES_NEW 需要事務，無論有無都建立新事務 SUPPORTS 支援事務，有則加入，無則在無事務狀態執行 NOT_SUPPORTS 不支援事務，有事務則暫停，在無事務下執行 MANDATORY 必須有事務，否則拋出例外 NEVER 必須無事務，否則拋出例外 使用範例\n1 2 3 4 5 6 7 8 9 10 11 @Transactional public void a(){ // code userServices.b(); // code } @Transactional(propagation = Propagation.REQUIRES_NEW) public void b(){ // code } ","date":"2025-01-22T13:30:38+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/222/","title":"Spring 事務管理"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 Aspect-Oriented Programming (面向切面程式設計、面向方面程式設計) 是針對特定方法進行程式設計。\n動態代理是面向切面程式設計最主流的實作。而 SpringAOP 是 Spring 框架的高階技術，旨在管理 bean 物件的過程中，主要透過底層的動態代理機制，對特定的方法進行程式設計。\n統計方法執行時間 匯入依賴\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-aop\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 撰寫 AOP 程式，針對特定方法根據業務需求進行程式設計\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Slf4j @Component @Aspect // AOP類 public class TimeAspect { // 切入點表達式 @Around(\u0026#34;execution(* net.yexca.service.*.*(..))\u0026#34;) public Object recordTime(ProceedingJoinPoint proceedingJoinPoint) throws Throwable { long begin = System.currentTimeMillis(); // 呼叫原始方法 Object object = proceedingJoinPoint.proceed(); long end = System.currentTimeMillis(); log.info(proceedingJoinPoint.getSignature() + \u0026#34;方法執行時間：{}ms\u0026#34;, end-begin); return object; } } AOP 的應用場景有記錄操作日誌、權限控制、交易管理等\n核心概念 連結點：JoinPoint，可以被 AOP 控制的方法 (隱含方法執行時的相關資訊)\n通知：Advice，指哪些重複的邏輯，也就是共性功能 (最終體現為一個方法)\n切入點：PointCut，匹配連結點的條件，通知僅會在切入點方法執行時被應用\n切面：Aspect，描述通知與切入點的對應關係 (通知 + 切入點)\n目標物件：Target，通知所應用的物件\n上例中，未寫出的 Service 所有方法都是連結點，被切入點表達式選中的方法都是切入點，而 AOP 類別的 recordTime 方法為通知，註解 @Around 與通知共同為切面，而 TimeAspect 類別稱為切面類別\n通知 通知類型 @Around：環繞通知，此註解標註的通知方法在目標方法前、後都被執行\n@Before：前置通知，此註解標註的通知方法在目標方法前被執行\n@After：後置通知，此註解標註的通知方法在目標方法後被執行，無論是否有例外都會執行\n@AfterReturning：返回後通知，此註解標註的通知方法在目標方法後被執行，有例外不會執行\n@AfterThrowing：例外後通知，此註解標註的通知方法發生例外後執行\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 @Component @Aspect public class MyAspect { @Before(\u0026#34;execution(* net.yexca.service.impl.*(..))\u0026#34;) public void before(){ System.out.println(\u0026#34;Before\u0026#34;); } @Around(\u0026#34;execution(* net.yexca.service.impl.*(..))\u0026#34;) public Object around(ProceedingJoinPoint proceedingJoinPoint) throws Throwable { System.out.println(\u0026#34;Around before\u0026#34;); Object result = proceedingJoinPoint.proceed(); System.out.println(\u0026#34;Around after\u0026#34;); return result; } @After(\u0026#34;execution(* net.yexca.service.impl.*(..))\u0026#34;) public void after(){ System.out.println(\u0026#34;After\u0026#34;); } @AfterReturning(\u0026#34;execution(* net.yexca.service.impl.*(..))\u0026#34;) public void afterRetruning(){ System.out.println(\u0026#34;AfterReturning\u0026#34;); } @AfterThrowing(\u0026#34;execution(* net.yexca.service.impl.*(..))\u0026#34;) public void afterThrowing(){ System.out.println(\u0026#34;AfterThrowing\u0026#34;); } } @Around 環繞通知需要自己呼叫 ProceedingJoinPoint.proceed() 來讓原始方法執行，其他通知不需要考量目標方法執行\n@Around 環繞通知方法的回傳值，必須指定為 Object，來接收原始方法的回傳值\n上述的 5 個註解的切入點表達式都相同，可以提取，如下所示\n1 2 3 4 5 6 7 8 9 10 public class MyAspect { @Pointcut(\u0026#34;execution(* net.yexca.service.impl.*(..))\u0026#34;) public void pt(){} @Before(\u0026#34;pt()\u0026#34;) public void before(){ System.out.println(\u0026#34;Before\u0026#34;); } } 方法 pt() 若是 public 權限符，則可以在其他的類別中引用\n通知順序 當有多個切面的切入點都匹配到目標方法，目標方法執行時，多個通知方法都會被執行\n1 2 3 4 5 6 net: yexca: aop: - MyAspect1 - MyAspect2 - MyAspect3 假設三個 AOP 類別都選中了同一個方法，不同切面類別中，預設是按照切面類別名稱字母排序\n目標方法前的通知方法：字母排名靠前的先執行 目標方法後的通知方法：字母排名靠後的先執行 假設三個 AOP 類別都有 @Before 和 @After，執行順序為\n1 2 3 4 5 6 MyAspect1 before MyAspect2 before MyAspect3 before MyAspect3 after MyAspect2 after MyAspect1 after 可以使用 @Order(num) 註解加在切面類別上來控制順序，num 越小越先執行，@Before 和 @After 執行同上\n切入點表達式 描述切入點方法的一種表達式，主要用來決定專案中的哪些方法需要加入通知\n常見形式有 execution(...) 根據方法的簽章匹配和 annotation 根據註解匹配\nexecution 主要根據方法的回傳值、套件名稱、類別名稱、方法名稱、方法參數等資訊來匹配，語法為\n1 execution(存取修飾符 回傳值 套件名稱.類別名稱.方法名稱(方法參數) throws 例外) 其中存取修飾符、套件名稱.類別名稱、throws 例外可以省略，不過不建議省略套件名稱.類別名稱\n也可以使用萬用字元描述切入點\n*：單個獨立的任意符號，可以萬用任意回傳值、套件名稱、類別名稱、方法名稱、任意類型的一個參數，也可以萬用套件、類別、方法名稱的一部分 1 execution(* com.*.service.*.update*(*)) ..：多個連續的任意符號，可以萬用任意層級的套件，或任意類型、任意個數的參數 1 execution(* com.yexca..service.*(..)) 還可以使用 \u0026amp;\u0026amp;、||、! 來組合比較複雜的切入點表達式\n撰寫建議\n所有業務方法名稱在命名時盡量規範，方便切入點表達式快速匹配 描述切入點方法通常基於介面描述，而非實作類別，增強擴充性 在滿足業務需求的前提下，盡量縮小切入點的匹配範圍 @annotation @annotation 切入點表達式，用於匹配標示有特定註解的方法，使用需先自訂義註解\n1 2 3 4 @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.METHOD) public @interface MyLog { } 然後在方法上加入該註解，在 AOP 類別方法上\n1 @Before(\u0026#34;@annotation(net.yexca.aop.MyLog)\u0026#34;) 連結點 在 Spring 中用 JoinPoint 抽象化了連結點，用它可以取得方法執行時的相關資訊\n對於 @Around 通知，取得連結點資訊只能使用 ProceedingJoinPoint 對於其他四種通知，取得連結點資訊只能使用 JoinPoint，它是 ProceedingJoinPoint 的父類別 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public Object recordTime(ProceedingJoinPoint proceedingJoinPoint) throws Throwable { // 取得目標物件的類別名稱 String className = proceedingJoinPoint.getTarget().getClass().getName(); // 取得目標方法的方法名稱 String methodNAme = proceedingJoinPoint.getSignature().getName(); // 取得目標方法執行時傳入的參數 Object[] args = proceedingJoinPoint.getArgs(); // 呼叫原始方法 Object object = proceedingJoinPoint.proceed(); return object; } ","date":"2025-01-21T16:05:57+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/221/","title":"Spring AOP (面向切面程式設計)"},{"content":" 📢 此頁面有使用機器翻譯喲 音有所感系列 歌曲名稱 翻譯 連結 僕が死のうと思ったのは 曾經我也想過一了百了 https://blog.yexca.net/zh-tw/archives/214 あくあ色ぱれっと aqua 的調色盤 https://blog.yexca.net/zh-tw/archives/219 恋の押し売り 戀愛推銷 本文 17さいのうた 17 歲的歌 https://blog.yexca.net/zh-tw/archives/224 drop 墜入愛河 https://blog.yexca.net/zh-tw/archives/230 生きるを選んだ私へ 致選擇活下去的自己 https://blog.yexca.net/zh-tw/archives/239 rainy lady 雨意未晴 https://blog.yexca.net/zh-tw/archives/249 恋しくなったら手を叩こう 想談戀愛的話就拍拍手吧 https://blog.yexca.net/zh-tw/archives/250 pris-magic! 稜鏡魔法! https://blog.yexca.net/zh-tw/archives/260 引言 其實早就翻譯了捏~(￣▽￣)~*\n歌曲影片 歌詞 ハートマーク作って\n畫個愛心的記號\n届け届け届け\n快一點、傳達到、你心裡\nきっと恋の押し売り\n這大概是戀愛的推銷\n好きで好きでごめん\n好喜歡，太喜歡，抱歉呀\n出会っちゃった！\n和你相遇了！\nときめいちゃった？ ときめく\n心跳加速了嗎？\n私だけ？ドキドキしてるの\n還是只有我？在砰砰心跳呢\nちゃんと気にかけて\n多多在意我啦\n私だけ！甘やかして\n只對我！好好寵愛吧\n(Ah)　君と話す理由欲しくて探している\n（啊）不斷尋找和你聊天的理由\n(なんで？)　強がっていても恋に負けちゃうんだね\n（為什麼？）就算裝作堅強，還是敗給了戀愛呀\nハートマーク作って\n畫個愛心的記號\n届け届け届け\n快一點、傳達到、你心裡\nきっと恋の押し売り\n這大概是戀愛的推銷\n好きで好きでごめん\n好喜歡，太喜歡，抱歉呀\nハートのレスください\n請回覆我的心意\n早く早く早くー！\n快一點、再快點、馬上做~！\nこれは恋の押し売り\n這可是戀愛的強制推銷\n返品なんてダメよ\n退貨？不可以！\n取られたくないんだよ…\n不想被搶走啊\u0026hellip;\n誰よりも可愛くなりたい\n想要變得比誰都可愛\n完全勝利して\n想完全勝利\n私だけって言わせてやる！\n讓你說出「只有我」！\n(Ah)　君の胸を狙う私の恋の銃口\n（啊）我的戀愛槍，瞄準著你的胸口\n(なんで？)　震えちゃうんだろう\n（為什麼？）會不由自主地顫抖呢\nいつか撃ち抜けるまで 撃ち抜く: うちぬく\n直到貫穿為止\nせーっの！BANG\n一、二、砰！\n期待させてよ\n讓我更加期待吧\nもっともっともっと\n多點、再多、更多\n私浮ついちゃって 浮つく: うわつく\n我有點飄飄然了\nバカだバカだごめん\n傻乎乎，真的是，抱歉呀\nハートは忙しくて\n心裡稍微有點忙\nあっちこっちどっちー？\n那裡？這裡？哪裡？\n今はまだまだプロローグ\n現在還只是序幕呢\n押して押して押すの\n按下去、快一點、去推進\n私、君に出会えて変わったの！\n我，和你遇見之後改變了！\nそりゃあ悩んじゃう事もあるけど…\n雖然也有會煩惱的時候。。。\nもっともっと可愛くなりたいって思うし\n但想要變得更加更加可愛\n何より君に好きって言ってもらいたい！\n沒有什麼比得上你對我說喜歡！\n笑顔の私(可愛い)\n笑著的我（可愛捏）\n泣いちゃう私(可愛い)\n哭著的我（可愛捏）\n怒った私(可愛い)\n生氣的我（可愛捏）\n恋する私…\n戀愛中的我。。。\n甘えさせてよ\n讓我撒嬌嘛\nずっとずっとずっと\n始終、一直、永遠\nきっと後悔させない\n一定不會讓你後悔的\nお願い　好きになって\n拜託了，喜歡我吧\nハートマーク作って\n畫一個愛心記號\n届け届け届け\n快一點、傳達到、你心裡\nきっと恋の押し売り\n大概是戀愛的小強推\n好きで好きでごめん\n喜歡你，超喜歡，抱歉呀\nハートのレスください\n請回覆我的心意\n早く早く早くー！\n快一點、再快點、馬上要！\nこれは恋の押し売り\n這可是戀愛的強制推銷\n返品なんてダメよ\n不可以、退貨哦\n","date":"2025-01-20T16:24:43+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/220/","title":"音之所感 - 《恋の押し売り》"},{"content":" 📢 此頁面有使用機器翻譯喲 音有所感系列 歌曲名稱 翻譯 連結 僕が死のうと思ったのは 曾經我也想過一了百了 https://blog.yexca.net/zh-tw/archives/214 あくあ色ぱれっと aqua 的調色盤 本文 恋の押し売り 戀愛推銷 https://blog.yexca.net/zh-tw/archives/220 17さいのうた 17 歲的歌 https://blog.yexca.net/zh-tw/archives/224 drop 墜入愛河 https://blog.yexca.net/zh-tw/archives/230 生きるを選んだ私へ 致選擇活下去的自己 https://blog.yexca.net/zh-tw/archives/239 rainy lady 雨意未晴 https://blog.yexca.net/zh-tw/archives/249 恋しくなったら手を叩こう 想談戀愛的話就拍拍手吧 https://blog.yexca.net/zh-tw/archives/250 pris-magic! 稜鏡魔法! https://blog.yexca.net/zh-tw/archives/260 引言 第二首本來想選我的 2024 年度歌曲，不過不經意間聽到了 Aqua 的歌，便想到了這首，之前聽的時候只是中間的有一段和我的人生經歷有點類似，所以一直在聽，全曲認真翻譯後才知道染上 Aqua 顏色的梗從這裡來的啊（在 C105 聽到「想染上 aqua 的顏色的話」，還以為是來自《君色に染まる》）\n雖然經歷類似讓我開始慢慢聽上 Aqua 且慢慢喜歡上，但事實上我的「キミがいるから私　いつでも頑張れるんだ」是 Warma 捏，寫到這突然就意識到了一直在影響著我的到底是什麼了，以及如今是為何這樣，不過正如因這首歌的改變，當前的困惑也一定有契機可以化解\n我很克制得沒寫下去，畢竟是一首歡樂的歌，可以說對於偶像路線簡直是太絕了這首歌，同時用詞倒也不是太難（相對於外國人），是我都可以聽懂的程度（doge）\n因為我是去年（2024）接觸到 Aqua 的嘛，因為經常聽到這首歌（3D 直播），還以為是經歷了一些沉澱，然後出了這麼厲害的歌（因為一直在收聽榜第一），沒想到是出道即巔峰啊（《For the Win》是 bilibili 企劃的，暫且不記上），同時之後的歌曲，怎麼說呢，偶像類的都很好，可以說是直接讓我開始喜歡一些偶像風了，以此為契機，倒是喜歡上了偶像演唱會（雖然隨著 Aqua 的畢業也不怎麼感興趣了）\n同時，對比其他翻譯可能有出入，我的翻譯多數是有自己的感情吧，所以部分並不是歌詞本身的意思（事實上 上一首 也是），這個在可能下一个 2024 年度歌曲的翻譯中表現更明顯。我覺得如果只是照抄一個標準的翻譯多少沒啥意義，因為是真正熱愛的事物，多少想留存自己的特色 (染上我的色彩)\n最後捏，我也想染上 Aqua 的色彩捏，畢竟是我最愛的三個人之一 （C105 沒買到立牌真可惜了，結城的也沒買到（悲\n歌曲影片 歌詞 何をしても不器用で　何かとミスしてばっか\n什麼也做不到，做什麼都出錯\nダメダメな私だって\n一無是處的我\nできる事があるの\n也有可以做到的事喔\n凹んで悲しくたって　笑顔にしてあげるんだ 凹む: へこむ\n就算陷入低落，我也會讓你笑起來喔\nここにいるから　早く　私を見つけてね\n因為就在這裡，快一點，找到我吧\nLove You Love You, I love you\n愛你愛你，我愛你\nLove You Love You, Ah,I love you so much\n愛你愛你，我非常愛你\nLove You Love You, I love you\n愛你愛你，我愛你\nLove You Love You\n愛你愛你\n（あぁ　愛してもっと）\n(啊~，更加愛我吧)\nいつでも隣にいるし、いつでも一緒に笑える\n一直都陪在身邊，一直都一起歡笑\n私をたくさん知って　たくさん好きって言って\n多多了解我，多多對我說“喜歡”\nワガママで朝も苦手　ドジだし　ダメダメだけど\n任性也賴床，笨手笨腳還一無是處\nそれでも私の事を　見ててね\n就算那樣也請專注於我\n描く夢の未来へ続く\n向著描繪未來的路\n道をキミと歩けますように\n希望能和你一起走下去\nねぇもっと！好きになってもらいたいの！\n呐，想讓你多多喜歡我！\n頭の中は君ばっか！\n我的腦海裡只有你\nってゆーかそっぽなんて向いてないで！\n話說，別把頭轉開呀！\nあぁもう！ヤキモキしちゃうわ　Ah\n啊啊，真是的！急死人了\nずっとずっと好きがいいの\n一直一直喜歡下去吧\n心の奥もトキメイちゃうくらい\n內心深處都怦然心動的程度\nこっち向いててよね　ダーリン？\n看看我嘛，親愛的？\nあぁもう離さないから、絶対に！\n啊~，再也不會放開你，絕對不會！\nLove You Love You, I love you\n愛你愛你，我愛你\nLove You Love You\n愛你愛你\n（あぁ　愛してもっと）\n(啊~，多多愛我吧)\nキミがいるから私　いつでも頑張れるんだ\n因為有你在身邊，我才能努力下去\n落ち込んで悲しくたって　キミがいるから\u0026hellip;\n就算低落悲傷，因為有你在身邊。。。\nキミがいるから　歩いてこれた\n正因為有你在，我才能走到今天\nキミがいなくちゃ　前も見れない\n如果沒有你，我連前方也看不清\n嫌な事とか辛い事とかあったって\n即使有討厭的，痛苦的事\nキミの力でここまで笑ってこれたんだ\n有你的力量就可以笑著走到現在\n今度はもっと私がぐっとひっぱって　連れて行くんだ\n這次我會更加努力拉著你，一起走下去\nキミがいるから私がいるの\n因為有你在，我才能到這\nこんな私を　愛してくれる？\n你願意愛上這樣的我嗎？\nねぇもっと　ねぇもっと\n呐，多一點，再多點\nまだもっと　受け止めてよね！ねぇいい？\n更多地接受我吧！可以嗎？\nさぁ声を上げて！\n那麼，大聲地說出來吧！\nねぇもっと　ねぇもっと\n呐，多一點，再多點\n好きになってもらいたいの\n想讓你喜歡上我\nいつでも　そう私ばっか みたいにそっぽなんて向かせないわ\n無論何時，我都不允許你把目光移開，只讓我在你心裡\nね、ほら夢中にしちゃうわ　Ah\n呐，看到了吧，已經沉迷了呢~\nずっとずっと好きがいいの！心も体も染まっちゃうくらいに\n一直一直喜歡下去吧，直到你的身心都染上我的色彩\nこっち向いててよねダーリン?\n看向這邊呀，親愛的？\nあぁもう離さないから、絶対に　絶体ね　絶体よ　約束だよ\n啊~，我不會放開你，一定不會、肯定不會、絕對不會，約好了喔\n（あぁ 愛してもっと）\n(啊~，更多地愛我吧)\n","date":"2025-01-20T00:16:48+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/219/","title":"音之所感 - 《あくあ色ぱれっと》"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 會話技術 會話：使用者開啟瀏覽器，造訪網頁伺服器的資源，會話建立，直到有一方中斷連線，會話結束。在一次會話中可以包含多次請求與回應。\n會話追蹤：一種維護瀏覽器狀態的方法，伺服器需要辨識多次請求是否來自同一個瀏覽器，以便在同一次會話的多個請求之間共享資料。\n會話追蹤方案：\n用戶端會話追蹤技術：Cookie 伺服器端會話追蹤技術：Session 權杖技術 Cookie Cookie 是 HTTP 協定支援的技術，在瀏覽器第一次造訪時，伺服器端請求標頭中設定 Cookie Set-Cookie: your_cookie，瀏覽器會自動將 Cookie 儲存在本機，並在下次造訪時自動在請求標頭中加入 Cookie Cookie: your_cookie。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 @RestController public class SessionController { // 設定 Cookie @GetMapping(\u0026#34;/c1\u0026#34;) public Result cookie1(HttpServletResponse response){ response.addCookie(new Cookie(\u0026#34;login_name\u0026#34;, \u0026#34;yexca\u0026#34;)); return Result.success(); } // 取得 Cookie @GetMapping(\u0026#34;/c2\u0026#34;) public Result cookie2(HttpServletRequest request){ Cookie[] cookies = request.getCookies(); for (Cookie c : cookies){ if(c.getName().equals(\u0026#34;login_name\u0026#34;)){ System.out.println(\u0026#34;login_name:\u0026#34;+c.getValue()); } } return Result.success(); } } 不過行動裝置不能使用 Cookie，並且 Cookie 無法跨網域。\n相同網域：相同協定、IP/網域名稱、連接埠\nSession 基於 Cookie 實作，在瀏覽器第一次請求時產生一個 Session，然後在回應標頭傳回 Session 的 ID Set-Cookie: JSESSIONID=session_id，然後瀏覽器在下次請求時自動帶上該 ID。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 @RestController public class SessionController { // 將值儲存到 HttpSession 中 @GetMapping(\u0026#34;/s1\u0026#34;) public Result session1(HttpSession session){ log.info(\u0026#34;HttpSession_set:{}\u0026#34;, session.hashCode()); session.setAttribute(\u0026#34;login_user\u0026#34;,\u0026#34;yexca\u0026#34;); return Result.success(); } // 從 HttpSession 中取得值 @GetMapping(\u0026#34;/s2\u0026#34;) public Result session2(HttpServletRequest request){ HttpSession session = request.getSession(); log.info(\u0026#34;HttpSession_get:{}\u0026#34;, session.hashCode()); Object loginUser = session.getAttribute(\u0026#34;login_user\u0026#34;); log.info(\u0026#34;loginUser:{}\u0026#34;, loginUser); return Result.success(); } } Session 的問題在於，如果伺服器端使用負載平衡，亦即有多台伺服器端，如果第一次回應的是伺服器一，而第二次回應的是伺服器二，由於伺服器二沒有 Session，所以無法使用。\nJWT 權杖 權杖技術支援 PC 端、行動裝置，可以解決叢集環境下的身分驗證問題，減輕伺服器端儲存壓力，但需要自行實作。\nJWT 全稱 JSON Web Token，官方網站： https://jwt.io/ ，定義了一種簡潔、自包含的格式，用於在通訊雙方以 JSON 資料格式安全地傳輸資訊。由於數位簽章的存在，這些資訊是可靠的。\n組成：\n第一部分：標頭（Header），記錄權杖類型、簽章演算法等 第二部分：酬載（Payload，有效載荷），記錄一些自訂資訊、預設資訊等 第三部分：簽章（Signature），防止權杖被篡改、確保安全性。將標頭（Header）、酬載（Payload）和指定金鑰，透過指定簽章演算法計算而來。 引入依賴項\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.jsonwebtoken\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jjwt\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.9.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 產生與解析\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class WebApplicationTests { // JWT 產生 @Test public void jwtGenTest(){ Map\u0026lt;String,Object\u0026gt; claims = new HashMap\u0026lt;\u0026gt;(); claims.put(\u0026#34;id\u0026#34;, \u0026#34;233\u0026#34;); claims.put(\u0026#34;user\u0026#34;, \u0026#34;yexca\u0026#34;); String jwt = Jwts.builder() .signWith(SignatureAlgorithm.HS256, \u0026#34;yexca\u0026#34;) // 簽章演算法 .setClaims(claims) //自訂內容(酬載) .setExpiration(new Date(System.currentTimeMillis() + 3600 * 1000)) // 有效期為 1 小時 .compact(); System.out.println(jwt); } // 輸出 // eyJhbGciOiJIUzI1NiJ9.eyJpZCI6IjIzMyIsImV4cCI6MTcwMjc5NzA4OCwidXNlciI6InlleGNhIn0.BqZDxEddGN4g4GyyfvkOtKYv7DVlIF6cWY9PGW2RbUU // JWT 解析 @Test public void jwtParseTest(){ Claims claims = Jwts.parser() .setSigningKey(\u0026#34;yexca\u0026#34;) // 金鑰 .parseClaimsJws(\u0026#34;eyJhbGciOiJIUzI1NiJ9.eyJpZCI6IjIzMyIsImV4cCI6MTcwMjc5NzA4OCwidXNlciI6InlleGNhIn0.BqZDxEddGN4g4GyyfvkOtKYv7DVlIF6cWY9PGW2RbUU\u0026#34;) .getBody(); // 取得第二部分 System.out.println(claims); } // 輸出 // {id=233, exp=1702797088, user=yexca} } 登入驗證 過濾器 (Filter) 過濾器是早期 JavaWeb 三大元件 (Servlet, Filter, Listener) 之一。過濾器可以將對資源的請求攔截下來，進而實現一些特殊的功能，例如登入驗證、統一編碼處理、敏感字元處理等。\n快速入門 建立過濾器類別\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 @WebFilter(urlPatterns = \u0026#34;/*\u0026#34;) // 攔截路徑 public class DemoFilter implements Filter { @Override public void init(FilterConfig filterConfig) throws ServletException { // Filter.super.init(filterConfig); System.out.println(\u0026#34;過濾器初始化\u0026#34;); } @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { System.out.println(\u0026#34;過濾器攔截\u0026#34;); // 放行 filterChain.doFilter(servletRequest, servletResponse); } @Override public void destroy() { // Filter.super.destroy(); System.out.println(\u0026#34;過濾器銷毀\u0026#34;); } } 在 Application 上加上註解\n1 2 @ServletComponentScan // 開啟了對 servlet 元件的支援 @SpringBootApplication 攔截路徑 可以根據需求調整，以下為範例\n攔截類型 urlPatterns 涵義 攔截特定路徑 /login 只有造訪 /login 才會被攔截 目錄攔截 /emps/* 造訪 /emps 下所有資源都會被攔截，/emps 也會被攔截 攔截所有 /* 造訪所有資源都會被攔截 單個過濾器執行邏輯 瀏覽器發送請求 -\u0026gt; 請求被攔截 -\u0026gt; 執行放行前邏輯 -\u0026gt; 放行 -\u0026gt; 執行放行後邏輯 -\u0026gt; 瀏覽器收到回應\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 @WebFilter(urlPatterns = \u0026#34;/*\u0026#34;) // 攔截路徑 public class DemoFilter implements Filter { @Override public void init(FilterConfig filterConfig) throws ServletException { // Filter.super.init(filterConfig); System.out.println(\u0026#34;過濾器初始化\u0026#34;); } @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { System.out.println(\u0026#34;過濾器攔截，放行前邏輯\u0026#34;); // 放行 filterChain.doFilter(servletRequest, servletResponse); System.out.println(\u0026#34;過濾器攔截，放行後邏輯\u0026#34;); } @Override public void destroy() { // Filter.super.destroy(); System.out.println(\u0026#34;過濾器銷毀\u0026#34;); } } 過濾器鏈 一個網頁應用程式中，可以設定多個過濾器，這些過濾器就形成了一個過濾器鏈。\n順序：註解設定的過濾器優先級是透過過濾器類別名稱的自然排序。\n邏輯：瀏覽器發送請求 -\u0026gt; 請求被 A 攔截 -\u0026gt; 執行 A 放行前邏輯 -\u0026gt; A 放行 -\u0026gt; 請求被 B 攔截 -\u0026gt; 執行 B 放行前邏輯 -\u0026gt; B 放行 -\u0026gt; 執行 B 放行後邏輯 -\u0026gt; 執行 A 放行後邏輯 -\u0026gt; 瀏覽器收到回應\n登入驗證 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 @Slf4j @WebFilter(urlPatterns = \u0026#34;/*\u0026#34;) public class LoginCheckFilter implements Filter { @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { HttpServletRequest request = (HttpServletRequest) servletRequest; HttpServletResponse response = (HttpServletResponse) servletResponse; // 取得請求 URL String requestURI = request.getRequestURI(); log.info(\u0026#34;請求 URL：{}\u0026#34;,requestURI); // 判斷是否有login if(requestURI.contains(\u0026#34;login\u0026#34;)){ log.info(\u0026#34;登入操作，放行\u0026#34;); filterChain.doFilter(servletRequest, servletResponse); return; // 因為登入操作不需要以下邏輯 } // 非登入操作，取得權杖 String jwt = request.getHeader(\u0026#34;token\u0026#34;); // 判斷權杖是否有效 if(!StringUtils.hasLength(jwt)){ log.info(\u0026#34;請求標頭 token 為空\u0026#34;); // 將物件轉換為 JSON Result error = Result.error(\u0026#34;NOT_LOGIN\u0026#34;); String notLogin = JSONObject.toJSONString(error); response.getWriter().write(notLogin); return; } // 驗證權杖 try { JwtUtils.parseJWT(jwt); }catch (Exception e){ e.printStackTrace(); log.info(\u0026#34;解析權杖失敗\u0026#34;); // 將物件轉換為 JSON Result error = Result.error(\u0026#34;NOT_LOGIN\u0026#34;); String notLogin = JSONObject.toJSONString(error); response.getWriter().write(notLogin); return; } // 放行 log.info(\u0026#34;權杖合法，放行\u0026#34;); filterChain.doFilter(servletRequest,servletResponse); } } 攔截器 (Interceptor) 快速入門 建立攔截器\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 @Component public class LoginCheckInterceptor implements HandlerInterceptor { @Override // 目標方法執行前執行，傳回 true 放行，false 不放行 public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { // return HandlerInterceptor.super.preHandle(request, response, handler); System.out.println(\u0026#34;preHandle\u0026#34;); return true; } @Override // 目標方法執行後執行 public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { // HandlerInterceptor.super.postHandle(request, response, handler, modelAndView); System.out.println(\u0026#34;postHandle\u0026#34;); } @Override // 檢視彩現完成後執行，最後執行 public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { // HandlerInterceptor.super.afterCompletion(request, response, handler, ex); System.out.println(\u0026#34;afterCompletion\u0026#34;); } } 建立設定\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 @Configuration // 設定類別 public class WebConfig implements WebMvcConfigurer { @Autowired private LoginCheckInterceptor loginCheckInterceptor; @Override public void addInterceptors(InterceptorRegistry registry) { // WebMvcConfigurer.super.addInterceptors(registry); registry.addInterceptor(loginCheckInterceptor).addPathPatterns(\u0026#34;/**\u0026#34;).excludePathPatterns(\u0026#34;/login\u0026#34;); } } 攔截路徑 路徑 涵義 例子 /* 一層路徑 /emps, /login 不能匹配 /emps/1 /** 任意層級路徑 /emps, /emps/1, /emps/1/2 /emps/* /emps 下的一層路徑 /emps/1 不能匹配 /emps, /emps/1/2 /emps/** /emps 下的任意層級路徑 /emps, /emps/1, /emps/1/2 攔截流程 如果同時存在過濾器和攔截器\n瀏覽器造訪 -\u0026gt; 過濾器放行前邏輯 -\u0026gt; 過濾器放行 -\u0026gt; DispatcherServlet -\u0026gt; Interceptor preHandle -\u0026gt; Controller -\u0026gt; postHandle -\u0026gt; afterCompletion -\u0026gt; DispatcherServlet -\u0026gt; 過濾器放行後邏輯 -\u0026gt; 回應瀏覽器\n過濾器會攔截所有的請求，而攔截器只會攔截 Spring 環境中的資源。\n登入驗證 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 @Slf4j @Component public class LoginCheckInterceptor implements HandlerInterceptor { @Override // 目標方法執行前執行，傳回 true 放行，false 不放行 public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { // return HandlerInterceptor.super.preHandle(request, response, handler); System.out.println(\u0026#34;preHandle\u0026#34;); // 取得請求 URL String requestURI = request.getRequestURI(); log.info(\u0026#34;請求 URL：{}\u0026#34;,requestURI); // 判斷是否有login if(requestURI.contains(\u0026#34;login\u0026#34;)){ log.info(\u0026#34;登入操作，放行\u0026#34;); return true; } // 非登入操作，取得權杖 String jwt = request.getHeader(\u0026#34;token\u0026#34;); // 判斷權杖是否有效 if(!StringUtils.hasLength(jwt)){ log.info(\u0026#34;請求標頭 token 為空\u0026#34;); // 將物件轉換為 JSON Result error = Result.error(\u0026#34;NOT_LOGIN\u0026#34;); String notLogin = JSONObject.toJSONString(error); response.getWriter().write(notLogin); return false; } // 驗證權杖 try { JwtUtils.parseJWT(jwt); }catch (Exception e){ e.printStackTrace(); log.info(\u0026#34;解析權杖失敗\u0026#34;); // 將物件轉換為 JSON Result error = Result.error(\u0026#34;NOT_LOGIN\u0026#34;); String notLogin = JSONObject.toJSONString(error); response.getWriter().write(notLogin); return false; } // 放行 log.info(\u0026#34;權杖合法，放行\u0026#34;); return true; } @Override // 目標方法執行後執行 public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { // HandlerInterceptor.super.postHandle(request, response, handler, modelAndView); System.out.println(\u0026#34;postHandle\u0026#34;); } @Override // 檢視彩現完成後執行，最後執行 public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { // HandlerInterceptor.super.afterCompletion(request, response, handler, ex); System.out.println(\u0026#34;afterCompletion\u0026#34;); } } ","date":"2025-01-16T23:06:20+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/218/","title":"JWT 登入驗證"},{"content":" 📢 本文由 gemini-3-pro 翻譯 初識 MQ 同步調用 微服務間基於 Feign 的呼叫屬於同步方式，存在一些問題。\n例如要開發一個支付服務，需要加入訂單服務和倉儲服務的程式碼，後期若要加入簡訊服務、積分服務等都需要修改支付程式碼，違反了 開放-封閉原則 ，並且在請求返回前無法做其他事情也會造成效能的浪費。\n問題： 耦合度高、效能下降、資源浪費、級聯失敗 (若提供者出現問題，所有呼叫方也會跟著出問題，如同骨牌效應，迅速導致整個微服務群故障)。\n非同步調用方案 非同步 (Asynchronous) 調用常見實現就是事件驅動模式。\n使用者支付請求 -\u0026gt; 支付服務 -\u0026gt; Broker，之後支付服務完成並回應，然後由 Broker 通知訂單服務、倉儲服務和簡訊服務。\n優點： 服務解耦、效能提升、吞吐量提高、服務沒有強依賴、故障隔離、流量削峰。 缺點： 依賴於 Broker 的可靠性、安全性、吞吐能力，架構變複雜了，業務沒有明顯的流程線，不好追蹤管理。 MQ MessageQueue，訊息佇列，字面意思為存放訊息的佇列，也就是事件驅動架構中的 Broker。\nRabbitMQ ActiveMQ RocketMQ Kafka 公司/社群 Rabbit Apache 阿里 (Alibaba) Apache 開發語言 Erlang Java Java Scala \u0026amp; Java 協定支援 AMQP，XMPP，SMTP，STOMP OpenWire, STOMP，REST, XMPP, AMQP 自定義協定 自定義協定 可用性 高 一般 高 高 單機吞吐量 一般 差 高 非常高 訊息延遲 微秒級 毫秒級 毫秒級 毫秒以內 訊息可靠性 高 一般 高 一般 追求可用性： Kafka、RocketMQ、RabbitMQ 追求可靠性： RabbitMQ、RocketMQ 追求吞吐能力： RocketMQ、Kafka 追求訊息低延遲： RabbitMQ、Kafka 安裝 RabbitMQ 可以從 官網 看到多種安裝方式，我使用 Docker 線上拉取。\n1 docker pull rabbitmq:3-management 執行指令：\n1 2 3 4 5 6 7 8 9 docker run \\ -e RABBITMQ_DEFAULT_USER=admin \\ -e RABBITMQ_DEFAULT_PASS=admin \\ --name mq \\ --hostname mq1 \\ -p 15672:15672 \\ -p 5672:5672 \\ -d \\ rabbitmq:3-management 訪問 \u0026lt;localhost:15672\u0026gt; 即可打開管理介面。RabbitMQ 中的一些概念：\nchannel： 操作 MQ 的工具 exchange： 交換機，路由訊息到佇列中 queue： 佇列，儲存訊息 virtualHost： 虛擬主機，是對 queue、exchange 等資源的邏輯分組 訊息模型 在 官網提供了多種 Demo ，對應了不同的訊息模型：\n基本訊息佇列 (BasicQueue)： \u0026ldquo;Hello World!\u0026rdquo; 工作訊息佇列 (WorkQueue)： Work Queues 發佈訂閱模型： Fanout Exchange：廣播 Publish/Subscribe Direct Exchange：路由 Routing Topic Exchange：主題 Topics Hello World Publisher -\u0026gt; Queue -\u0026gt; Consumer\npublisher： 訊息發佈者，將訊息發送到佇列 queue queue： 訊息佇列，負責接受並快取訊息 consumer： 訂閱佇列，處理佇列中的訊息 發佈者\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 public class PublisherTest { @Test public void testSendMessage() throws IOException, TimeoutException { // 1.建立連線 ConnectionFactory factory = new ConnectionFactory(); // 1.1.設定連線參數，分別是：主機名、連接埠號、vhost、使用者名稱、密碼 factory.setHost(\u0026#34;localhost\u0026#34;); factory.setPort(5672); factory.setVirtualHost(\u0026#34;/\u0026#34;); factory.setUsername(\u0026#34;admin\u0026#34;); factory.setPassword(\u0026#34;admin\u0026#34;); // 1.2.建立連線 Connection connection = factory.newConnection(); // 2.建立通道 Channel Channel channel = connection.createChannel(); // 3.建立佇列 String queueName = \u0026#34;hello.queue\u0026#34;; channel.queueDeclare(queueName, false, false, false, null); // 4.發送訊息 String message = \u0026#34;hello, rabbitmq!\u0026#34;; channel.basicPublish(\u0026#34;\u0026#34;, queueName, null, message.getBytes()); System.out.println(\u0026#34;發送訊息成功：【\u0026#34; + message + \u0026#34;】\u0026#34;); // 5.關閉通道和連線 channel.close(); connection.close(); } } 接收者\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 public class ConsumerTest { public static void main(String[] args) throws IOException, TimeoutException { // 1.建立連線 ConnectionFactory factory = new ConnectionFactory(); // 1.1.設定連線參數，分別是：主機名、連接埠號、vhost、使用者名稱、密碼 factory.setHost(\u0026#34;localhost\u0026#34;); factory.setPort(5672); factory.setVirtualHost(\u0026#34;/\u0026#34;); factory.setUsername(\u0026#34;admin\u0026#34;); factory.setPassword(\u0026#34;admin\u0026#34;); // 1.2.建立連線 Connection connection = factory.newConnection(); // 2.建立通道 Channel Channel channel = connection.createChannel(); // 3.建立佇列 String queueName = \u0026#34;hello.queue\u0026#34;; channel.queueDeclare(queueName, false, false, false, null); // 4.訂閱訊息 channel.basicConsume(queueName, true, new DefaultConsumer(channel){ @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException { // 5.處理訊息 String message = new String(body); System.out.println(\u0026#34;接收到訊息：【\u0026#34; + message + \u0026#34;】\u0026#34;); } }); System.out.println(\u0026#34;等待接收訊息。。。。\u0026#34;); } } 控制台輸出：\n1 2 等待接收訊息。。。。 接收到訊息：【hello, rabbitmq!】 顯然這種方式略顯繁瑣。\nSpringAMQP SpringAMQP 是基於 RabbitMQ 封裝的一套模板，並且還利用 SpringBoot 對其實現了自動配置 (Auto-configuration)，使用起來非常方便。\nAMQP\nAdvanced Message Queuing Protocol，是用於在應用程式之間傳遞業務訊息的開放標準。該協定與語言和平台無關，更符合微服務中獨立性的要求。\nSpring AMQP\nSpring AMQP 是基於 AMQP 協定定義的一套 API 規範，提供了模板來發送和接收訊息。包含兩部分，其中 spring-amqp 是基礎抽象，spring-rabbit 是底層的預設實現。\n它可以自動宣告佇列、交換機及其綁定關係，基於註解 (Annotation) 的監聽器模式，非同步接收訊息。\nBasic Queue 簡單佇列模型 首先在父專案 (Parent Project) 中引入依賴：\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-amqp\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; publisher 訊息發送 設定 application.yml：\n1 2 3 4 5 6 7 spring: rabbitmq: host: localhost # 主機名 port: 5672 # 連接埠 virtual-host: / # 虛擬主機 username: admin # 使用者名稱 password: admin # 密碼 利用 RabbitTemplate 實現訊息發送：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @RunWith(SpringRunner.class) @SpringBootTest public class SpringamqpTest { @Autowired private RabbitTemplate rabbitTemplate; @Test public void testSimpleQueue(){ // 佇列名 String queueName = \u0026#34;hello.queue\u0026#34;; // 訊息 String msg = \u0026#34;Hello Spring ampq\u0026#34;; // 發送 rabbitTemplate.convertAndSend(queueName,msg); } } consumer 訊息接收 設定 application.yml 同上：\n1 2 3 4 5 6 7 spring: rabbitmq: host: localhost # 主機名 port: 5672 # 連接埠 virtual-host: / # 虛擬主機 username: admin # 使用者名稱 password: admin # 密碼 建立一個新類別 SpringRabbitListener：\n1 2 3 4 5 6 7 @Component public class SpringRabbitListener { @RabbitListener(queues = \u0026#34;hello.queue\u0026#34;) public void listenSimpleQueue(String msg){ System.out.println(\u0026#34;接收的訊息為：\u0026#34; + msg); } } WorkQueue 工作訊息佇列 也稱 TaskQueue，任務模型，可以提高訊息處理速度，避免佇列訊息堆積。\nPublisher -\u0026gt; Queue -\u0026gt; Consumer1 and Consumer2 and \u0026hellip;\npublisher 訊息發送 定義一個方法，每秒發送 50 條訊息：\n1 2 3 4 5 6 7 8 9 10 11 12 public class SpringamqpTest { @Test public void testWorkQueue() throws InterruptedException { String queueName = \u0026#34;hello.queue\u0026#34;; String msg = \u0026#34;Hello Spring ampq...\u0026#34;; for (int i = 0; i \u0026lt; 50; i++) { rabbitTemplate.convertAndSend(queueName, msg + i); // 睡眠20毫秒，1秒發50條訊息 Thread.sleep(20); } } } consumer 訊息接收 建立兩個消費者綁定同一佇列：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @Component public class SpringRabbitListener { @RabbitListener(queues = \u0026#34;hello.queue\u0026#34;) public void listenSimpleQueue1(String msg) throws InterruptedException { System.out.println(\u0026#34;1接收的訊息為：\u0026#34; + msg); // 每秒處理40條訊息 Thread.sleep(25); } @RabbitListener(queues = \u0026#34;hello.queue\u0026#34;) public void listenSimpleQueue2(String msg) throws InterruptedException { // 使用err輸出紅色訊息 System.err.println(\u0026#34;2接收的訊息為：\u0026#34; + msg); // 每秒處理5條訊息 Thread.sleep(200); } } 測試 先運行接收者，而後運行發送者發送訊息。\n從輸出結果可以看到，兩個接收者各接收一半的訊息，也就是說訊息是平均分配給每個消費者，並沒有考慮到消費者的處理能力。這樣顯然是有問題的。\nprefetch 修改 application.yml 檔案，設定 prefetch 這個值，可以控制預取訊息的上限 (預設無限)。\n1 2 3 4 5 6 7 8 9 10 11 spring: rabbitmq: host: localhost # 主機名 port: 5672 # 連接埠 virtual-host: / # 虛擬主機 username: admin # 使用者名稱 password: admin # 密碼 listener: simple: # 每次只能獲取一條訊息，處理完成才能獲取下一個訊息 prefetch: 1 再次測試可以發現執行效率提高。\n發佈訂閱模型 發佈訂閱模式加入了交換機 (Exchange)，允許將同一個訊息發送給全部接收者。\nPublisher -\u0026gt; Exchange -\u0026gt; Queue1 and Queue2\nQueue1 -\u0026gt; Consumer1 and Consumer2\nQueue2 -\u0026gt; Consumer3\n常見的 exchange 有：\nFanout： 廣播 Direct： 路由 Topic： 主題 exchange 負責路由，並不儲存，一旦路由失敗則訊息遺失。\nFanout (扇出) 廣播 Fanout exchange 會將接收到的訊息廣播到每一個和其綁定的 queue。\n在接收者建立一個配置類別，宣告佇列與交換機：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 @Configuration public class FanoutConfig { /** * 宣告交換機 * @return */ @Bean public FanoutExchange fanoutExchange(){ return new FanoutExchange(\u0026#34;hello.fanout\u0026#34;); } /** * 第一個佇列 * @return */ @Bean public Queue fanoutQueue1(){ return new Queue(\u0026#34;fanout.queue1\u0026#34;); } /** * 綁定第一個佇列與交換機 * @param fanoutQueue1 * @param fanoutExchange * @return */ @Bean public Binding bindingQueue1(Queue fanoutQueue1, FanoutExchange fanoutExchange){ return BindingBuilder.bind(fanoutQueue1).to(fanoutExchange); } /** * 第二個佇列 * @return */ @Bean public Queue fanoutQueue2(){ return new Queue(\u0026#34;fanout.queue2\u0026#34;); } /** * 綁定第二個佇列與交換機 * @param fanoutQueue2 * @param fanoutExchange * @return */ @Bean public Binding bindingQueue2(Queue fanoutQueue2, FanoutExchange fanoutExchange){ return BindingBuilder.bind(fanoutQueue2).to(fanoutExchange); } } 訊息發送：\n1 2 3 4 5 6 7 8 9 10 public class SpringamqpTest { @Test public void testFanoutExchange(){ // 交換機 String exchangeName = \u0026#34;hello.fanout\u0026#34;; // 訊息 String msg = \u0026#34;hello, everyone\u0026#34;; rabbitTemplate.convertAndSend(exchangeName,\u0026#34;\u0026#34;,msg); } } 其中中間空著的 routingkey 在下兩個模型使用。\n訊息的接收：\n1 2 3 4 5 6 7 8 9 10 11 @Component public class SpringRabbitListener { @RabbitListener(queues = \u0026#34;fanout.queue1\u0026#34;) public void listenFanoutQueue1(String msg){ System.out.println(\u0026#34;Fanout1 接收訊息：\u0026#34; + msg); } @RabbitListener(queues = \u0026#34;fanout.queue2\u0026#34;) public void listenFanoutQueue2(String msg){ System.out.println(\u0026#34;Fanout2 接收訊息：\u0026#34; + msg); } } Direct 路由 Direct Exchange 會將接收到的訊息根據規則路由到指定的 Queue，因此稱為路由模式。\n佇列與交換機的綁定要指定一個 Routingkey，發送方發訊息時也必須指定訊息的 Routingkey，只有佇列的 Routingkey 和訊息的 Routingkey 完全一致，才會接收到訊息。\n在此使用基於註解宣告佇列和交換機，不需要配置類別：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 @Component public class SpringRabbitListener { @RabbitListener(bindings = @QueueBinding( value = @Queue(name = \u0026#34;direct.queue1\u0026#34;), // exchange = @Exchange(name = \u0026#34;hello.direct\u0026#34;, type = ExchangeTypes.DIRECT), // 因為預設為 Direct 類型，可以不用指定 exchange = @Exchange(name = \u0026#34;hello.direct\u0026#34;), key = {\u0026#34;red\u0026#34;,\u0026#34;warma\u0026#34;} )) public void listenDirectQueue1(String msg){ System.out.println(\u0026#34;1 接收訊息：\u0026#34; + msg); } @RabbitListener(bindings = @QueueBinding( value = @Queue(name = \u0026#34;direct.queue2\u0026#34;), exchange = @Exchange(name = \u0026#34;hello.direct\u0026#34;), key = {\u0026#34;red\u0026#34;,\u0026#34;aqua\u0026#34;} )) public void listenDirectQueue2(String msg){ System.out.println(\u0026#34;2 接收訊息：\u0026#34; + msg); } } 發送者：\n1 2 3 4 5 6 7 8 9 10 public class SpringamqpTest { @Test public void testDirectExchange(){ // 交換機 String exchangeName = \u0026#34;hello.direct\u0026#34;; // 訊息 String msg = \u0026#34;hello, aqua\u0026#34;; rabbitTemplate.convertAndSend(exchangeName,\u0026#34;aqua\u0026#34;,msg); } } 上例只有接收者 2 可以接收到訊息，若 routingkey 為 red 則兩個都能接收到訊息。\nTopic 主題 TopicExchange 與 DirectExchange 類似，區別在於 routingKey 必須是多個單字的列表，並且以 . 分割。\nQueue 與 Exchange 指定 BindingKey 時可以使用萬用字元：\n#：匹配一個或多個單字 *：只匹配一個單字 接收者：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @Component public class SpringRabbitListener { @RabbitListener(bindings = @QueueBinding( value = @Queue(\u0026#34;topic.queue1\u0026#34;), exchange = @Exchange(name = \u0026#34;hello.topic\u0026#34;, type = ExchangeTypes.TOPIC), key = \u0026#34;#.news\u0026#34; )) public void listenTopicQueue1(String msg){ System.out.println(\u0026#34;1 接受訊息：\u0026#34; + msg); } @RabbitListener(bindings = @QueueBinding( value = @Queue(\u0026#34;topic.queue2\u0026#34;), exchange = @Exchange(name = \u0026#34;hello.topic\u0026#34;, type = ExchangeTypes.TOPIC), key = \u0026#34;china.#\u0026#34; )) public void listenTopicQueue2(String msg){ System.out.println(\u0026#34;2 接受訊息：\u0026#34; + msg); } } 訊息發送：\n1 2 3 4 5 6 7 8 9 10 public class SpringamqpTest { @Test public void testTopicExchange(){ // 交換機 String exchangeName = \u0026#34;hello.topic\u0026#34;; // 訊息 String msg = \u0026#34;news for China\u0026#34;; rabbitTemplate.convertAndSend(exchangeName,\u0026#34;china.news\u0026#34;,msg); } } 上例 1 和 2 都可以接收。\n1 2 3 4 5 6 7 8 9 10 public class SpringamqpTest { @Test public void testTopicExchange(){ // 交換機 String exchangeName = \u0026#34;hello.topic\u0026#34;; // 訊息 String msg = \u0026#34;news for Japan\u0026#34;; rabbitTemplate.convertAndSend(exchangeName,\u0026#34;japan.news\u0026#34;,msg); } } 只有 1 可以接收。\n訊息轉換器 Spring 會把發送的訊息序列化為位元組 (Bytes) 發送給 MQ，接收訊息時，把位元組反序列化為 Java 物件，只不過預設情況下 Spring 採用的序列化方式是 JDK 序列化，其數據體積過大、有安全漏洞、可讀性差。\n可以使用 JSON 方式來做序列化和反序列化。\n首先在父專案引入依賴：\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.fasterxml.jackson.dataformat\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jackson-dataformat-xml\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.9.10\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 在消費者與接收者宣告一個 bean 即可：\n1 2 3 4 @Bean public MessageConverter jsonMessageConverter(){ return new Jackson2JsonMessageConverter(); } ","date":"2025-01-15T17:03:32+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/217/","title":"SpringAMQP"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 MyBatis 系列\nMyBatis 安裝與入門: https://blog.yexca.net/zh-tw/archives/215 MyBatis 使用: 本文\n刪除 使用 #{} 作為佔位符，內部為參數名稱\n1 2 3 4 5 6 @Mapper public interface EmpMapper { // 刪除 @Delete(\u0026#34;delete from mybatis.emp where id = #{id}\u0026#34;) public void delete(Integer id); } 測試\n1 2 3 4 5 6 7 8 9 @SpringBootTest class Mybatis02ApplicationTests { @Autowired private EmpMapper empMapper; @Test void contextLoads() { empMapper.delete(17); } } 一般不需要回傳值，回傳值為此次操作影響的列數（筆數）\n1 2 3 4 5 6 @Mapper public interface EmpMapper { // 刪除 @Delete(\u0026#34;delete from mybatis.emp where id = #{id}\u0026#34;) public int delete(Integer id); } 佔位符 參數佔位符有 #{} 和 ${}\n佔位符 #{} ${} 形式 預編譯 拼接 使用時機 參數傳遞、登入等 對資料表名稱、列表動態設置 優劣 安全，效能高 存在 SQL 注入問題 插入 (新增) 同樣使用佔位符，不過若傳遞的參數過多可以使用物件封裝，形式參數名稱為物件的屬性名稱\n1 2 3 4 5 6 7 @Mapper public interface EmpMapper { // 新增 @Insert(\u0026#34;insert into mybatis.emp(username, name, gender, image, job, entrydate, dept_id, create_time, update_time) \u0026#34;+ \u0026#34;values (#{username},#{name},#{gender},#{image},#{job},#{entrydate},#{deptId},#{createTime},#{updateTime});\u0026#34;) public void insert(Emp emp); } 測試\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 @SpringBootTest class Mybatis02ApplicationTests { @Autowired private EmpMapper empMapper; @Test public void testInsert(){ Emp emp = new Emp(); emp.setUsername(\u0026#34;Tom\u0026#34;); emp.setName(\u0026#34;湯姆\u0026#34;); emp.setGender((short) 1); emp.setImage(\u0026#34;tom.jpg\u0026#34;); emp.setJob((short) 1); emp.setEntrydate(LocalDate.of(2000,1,1)); emp.setDeptId(1); emp.setCreateTime(LocalDateTime.now()); emp.setUpdateTime(LocalDateTime.now()); empMapper.insert(emp); } } 獲取主鍵值 某些情況下在資料新增成功後，需要獲取寫入資料庫資料的主鍵\n1 2 3 4 5 6 7 8 9 @Mapper public interface EmpMapper { // 獲取主鍵，第一個屬性定義主鍵賦值在 emp 物件的 id 屬性，第二個屬性代表需要獲取回傳主鍵值 @Options(keyProperty = \u0026#34;id\u0026#34;, useGeneratedKeys = true) // 新增 @Insert(\u0026#34;insert into mybatis.emp(username, name, gender, image, job, entrydate, dept_id, create_time, update_time) \u0026#34;+ \u0026#34;values (#{username},#{name},#{gender},#{image},#{job},#{entrydate},#{deptId},#{createTime},#{updateTime});\u0026#34;) public void insert(Emp emp); } 更新 (修改) 與新增類似，可以封裝到一個物件裡\n1 2 3 4 5 6 7 @Mapper public interface EmpMapper { // 修改 @Update(\u0026#34;update mybatis.emp set username = #{username}, name = #{name}, gender = #{gender}, image = #{image}, job = #{job}, \u0026#34;+ \u0026#34;entrydate = #{entrydate}, dept_id = #{deptId}, update_time = #{updateTime} where id = #{id};\u0026#34;) public void update(Emp emp); } 測試\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 @SpringBootTest class Mybatis02ApplicationTests { @Autowired private EmpMapper empMapper; @Test public void testUpdate(){ Emp emp = new Emp(); emp.setUsername(\u0026#34;Tom2\u0026#34;); emp.setName(\u0026#34;湯姆2\u0026#34;); emp.setGender((short) 1); emp.setImage(\u0026#34;tom.jpg\u0026#34;); emp.setJob((short) 1); emp.setEntrydate(LocalDate.of(2000,1,1)); emp.setDeptId(1); emp.setUpdateTime(LocalDateTime.now()); emp.setId(19); empMapper.update(emp); } } 查詢 查詢有兩種，根據 id 查詢全部屬性，以及根據條件查詢\n根據 ID 查詢 介面\n1 2 3 4 5 6 @Mapper public interface EmpMapper { // 根據ID查詢 @Select(\u0026#34;select * from mybatis.emp where id = #{id}\u0026#34;) public Emp idSelect(Integer id); } 測試\n1 2 3 4 5 6 7 8 9 10 11 12 @SpringBootTest class Mybatis02ApplicationTests { @Autowired private EmpMapper empMapper; @Test public void testIdSelect(){ Emp emp = empMapper.idSelect(19); System.out.println(emp); } } 結果\n1 Emp(id=19, username=Tom2, password=123456, name=湯姆2, gender=1, image=tom.jpg, job=1, entrydate=2000-01-01, deptId=null, createTime=null, updateTime=null) 這樣查詢出來的結果，因為類別 Emp 與資料庫的部分欄位名稱不同，導致結果為 null\n有三種方法可以解決\n使用別名 1 2 3 4 5 6 7 @Mapper public interface EmpMapper { // 方法一：別名 @Select(\u0026#34;select id, username, password, name, gender, image, job, entrydate, dept_id deptId, create_time createTime, update_time updateTime\u0026#34; + \u0026#34; from mybatis.emp where id = #{id}\u0026#34;) public Emp idSelect(Integer id); } 使用 @Results 註解 1 2 3 4 5 6 7 8 9 10 11 @Mapper public interface EmpMapper { // 方法二：@Results @Result 註解 @Results({ @Result(column = \u0026#34;dept_id\u0026#34;, property = \u0026#34;deptId\u0026#34;), @Result(column = \u0026#34;create_time\u0026#34;, property = \u0026#34;createTime\u0026#34;), @Result(column = \u0026#34;update_time\u0026#34;, property = \u0026#34;updateTime\u0026#34;) }) @Select(\u0026#34;select * from mybatis.emp where id = #{id}\u0026#34;) public Emp idSelect(Integer id); } 使用自動封裝 如果欄位名稱與屬性名稱符合駝峰式命名規則，可以開啟駝峰式命名自動封裝。MyBatis 會自動透過駝峰式命名規則映射，具體為資料庫使用底線 a_column 映射到 Java 屬性 aColumn\n開啟駝峰式命名需在 application.properties 加入\n1 mybatis.configuration.map-underscore-to-camel-case=true 然後直接使用最初的程式碼\n1 2 3 4 5 6 @Mapper public interface EmpMapper { // 根據ID查詢 @Select(\u0026#34;select * from mybatis.emp where id = #{id}\u0026#34;) public Emp idSelect(Integer id); } 為了方便使用，可以在 IDEA 中安裝 MyBatisX 外掛\n根據條件查詢 需求：根據員工姓名 (模糊比對)、性別 (精準比對)、到職時間 (範圍) 搜尋符合條件的員工資訊\n1 2 3 4 5 6 7 8 @Mapper public interface EmpMapper { // 根據條件查詢 // 注意此處 name like \u0026#39;%${name}%\u0026#39; 使用的是 ${}，可以在 \u0026#39;\u0026#39; 內使用 @Select(\u0026#34;select * from mybatis.emp where name like \u0026#39;%${name}%\u0026#39; and gender = #{gender} and \u0026#34; + \u0026#34;entrydate between #{begin} and #{end} order by update_time desc\u0026#34;) public List\u0026lt;Emp\u0026gt; conditionSelect(String name, short gender, LocalDate begin, LocalDate end); } 因為使用了插值進行字串拼接，所以此方法不安全\n1 2 3 4 5 6 7 @Mapper public interface EmpMapper { // 更安全的條件查詢 @Select(\u0026#34;select * from mybatis.emp where name like concat(\u0026#39;%\u0026#39;,#{name},\u0026#39;%\u0026#39;) and gender = #{gender} and \u0026#34; + \u0026#34;entrydate between #{begin} and #{end} order by update_time desc\u0026#34;) public List\u0026lt;Emp\u0026gt; conditionSelect(String name, short gender, LocalDate begin, LocalDate end); } 使用了 concat 函式拼接字串。測試\n1 2 3 4 5 6 7 8 9 10 11 12 @SpringBootTest class Mybatis02ApplicationTests { @Autowired private EmpMapper empMapper; @Test public void testConditionSelect(){ List\u0026lt;Emp\u0026gt; empList = empMapper.conditionSelect(\u0026#34;張\u0026#34;, (short) 1, LocalDate.of(2010, 1, 1), LocalDate.of(2020, 1, 1)); System.out.println(empList); } } 參數名稱說明 在 SQL 中使用的 #{} 變數名稱在 SpringBoot 2.x 以後的版本會被自動辨識，但在 1.x 版本或單獨使用 MyBatis 時，方法定義的變數名稱需要使用註解指定才能被辨識\n1 2 3 4 5 6 7 8 9 10 11 @Mapper public interface EmpMapper { // 更安全的條件查詢 @Select(\u0026#34;select * from mybatis.emp where name like concat(\u0026#39;%\u0026#39;,#{name},\u0026#39;%\u0026#39;) and gender = #{gender} and \u0026#34; + \u0026#34;entrydate between #{begin} and #{end} order by update_time desc\u0026#34;) public List\u0026lt;Emp\u0026gt; conditionSelect(String name, short gender, LocalDate begin, LocalDate end); } // 上述程式碼在 1.x 或單獨使用 MyBatis 時不會生效，函式要添加註解 public List\u0026lt;Emp\u0026gt; conditionSelect(@Param(\u0026#34;name\u0026#34;) String name, @Param(\u0026#34;gender\u0026#34;) short gender, @Param(\u0026#34;begin\u0026#34;) LocalDate begin, @Param(\u0026#34;end\u0026#34;) LocalDate end); 使用 XML 映射文件 如果 SQL 程式碼比較簡短，使用註解很方便，但若 SQL 較長或複雜則會顯得稍微凌亂，為此可以使用 XML 映射文件。以下為規範：\nXML 映射文件的名稱與 Mapper 介面名稱一致，且將 XML 映射文件和 Mapper 介面放在相同套件 (Package) 下 (同套件同名) XML 中的 namespace 屬性與 Mapper 介面全限定名一致 XML 中 SQL 語句的 id 屬性與 Mapper 介面中的方法名稱一致，且回傳型別一致 XML 在 Maven 專案中，非 Java 檔案放在 src/main/resources 下，在此目錄下建立與 Mapper 介面一致的目錄\n如介面為 net.yexca.mapper.EmpMapper.java，則 XML 檔案在 net.yexca.mapper.EmpMapper.xml\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;https://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;!-- 上方標頭檔請至官方網站尋找 --\u0026gt; \u0026lt;!-- namespace 屬性為介面 --\u0026gt; \u0026lt;mapper namespace=\u0026#34;net.yexca.mapper.EmpMapper\u0026#34;\u0026gt; \u0026lt;!-- id 屬性為方法名稱 --\u0026gt; \u0026lt;!-- resultType 為單筆紀錄所封裝的型別 --\u0026gt; \u0026lt;select id=\u0026#34;conditionSelect\u0026#34; resultType=\u0026#34;net.yexca.pojo.Emp\u0026#34;\u0026gt; select * from mybatis.emp where name like concat(\u0026#39;%\u0026#39;,#{name},\u0026#39;%\u0026#39;) and gender = #{gender} and entrydate between #{begin} and #{end} order by update_time desc \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt; 介面類別 1 2 3 4 @Mapper public interface EmpMapper { public List\u0026lt;Emp\u0026gt; conditionSelect(String name, short gender, LocalDate begin, LocalDate end); } 動態 SQL 動態 SQL 是指隨著使用者的輸入或外部條件的變化而變化的 SQL 語句\n例如上述最後一個條件查詢，必須輸入全部三個條件才能查詢，但實際使用時或許只想指定其中一兩個或不指定 (查詢全部)，如果按照上述指令執行將回傳空結果\nwhere if 用於判斷條件是否成立，使用 test 屬性進行條件判斷，如果條件為 true，則拼接 SQL\n例如，當姓名不為空時，拼接條件透過姓名查詢\n1 2 3 \u0026lt;if test=\u0026#34;name!=null\u0026#34;\u0026gt; name like contact(\u0026#39;%\u0026#39;,#{name},\u0026#39;%\u0026#39;) \u0026lt;/if\u0026gt; 而 where 標籤則管理是否生成 where 關鍵字，並自動去除多餘的 and 和 or 關鍵字\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;select id=\u0026#34;conditionSelect\u0026#34; resultType=\u0026#34;net.yexca.pojo.Emp\u0026#34;\u0026gt; select * from mybatis.emp \u0026lt;where\u0026gt; \u0026lt;if test=\u0026#34;name!=null\u0026#34;\u0026gt; name like concat(\u0026#39;%\u0026#39;,#{name},\u0026#39;%\u0026#39;) \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;gender!=null\u0026#34;\u0026gt; and gender = #{gender} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;begin!=null and end!=null\u0026#34;\u0026gt; and entrydate between #{begin} and #{end} \u0026lt;/if\u0026gt; \u0026lt;/where\u0026gt; order by update_time desc \u0026lt;/select\u0026gt; set 替換 SQL 中的 set 關鍵字，並自動去除多餘的逗號，用於 UPDATE 語句中\n例如將以下 SQL 語句修改為動態 SQL\n1 2 3 4 5 6 7 8 9 10 update mybatis.emp set username = #{username}, name = #{name}, gender = #{gender}, image = #{image}, job = #{job}, entrydate = #{entrydate}, dept_id = #{deptId}, update_time = #{updateTime} where id = #{id}; XML\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;update id=\u0026#34;update2\u0026#34;\u0026gt; update mybatis.emp \u0026lt;set\u0026gt; \u0026lt;if test=\u0026#34;username != null\u0026#34;\u0026gt;username = #{username},\u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;name != null\u0026#34;\u0026gt;name = #{name},\u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;gender != null\u0026#34;\u0026gt;gender = #{gender},\u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;image != null\u0026#34;\u0026gt;image = #{image},\u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;job != null\u0026#34;\u0026gt;job = #{job},\u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;entrydate != null\u0026#34;\u0026gt;entrydate = #{entrydate},\u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;deptId != null\u0026#34;\u0026gt;dept_id = #{deptId},\u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;updateTime != null\u0026#34;\u0026gt;update_time = #{updateTime}\u0026lt;/if\u0026gt; \u0026lt;/set\u0026gt; where id = #{id}; \u0026lt;/update\u0026gt; foreach foreach 標籤用於遍歷\n1 2 3 4 \u0026lt;!--遍歷的集合 遍歷出的元素 分隔符號 開始前後拼接的 SQL 片段--\u0026gt; \u0026lt;foreach collection=\u0026#34;ids\u0026#34; item=\u0026#34;id\u0026#34; separator=\u0026#34;,\u0026#34; open=\u0026#34;(\u0026#34; close=\u0026#34;)\u0026#34;\u0026gt; #{id} \u0026lt;/foreach\u0026gt; 假如 ids 為 [13, 14, 15]，以上將產生 (13,14,15)\n需求：遍歷刪除 id 為 1, 2, 3。SQL 語句為：\n1 delete from emp where id in(1,2,3) 介面方法\n1 public void deleteByIds(List\u0026lt;Integer\u0026gt; ids); XML\n1 2 3 4 5 6 \u0026lt;delete id=\u0026#34;deleteByIds\u0026#34;\u0026gt; delete from mybatis.emp where id in \u0026lt;foreach collection=\u0026#34;ids\u0026#34; item=\u0026#34;id\u0026#34; separator=\u0026#34;,\u0026#34; open=\u0026#34;(\u0026#34; close=\u0026#34;)\u0026#34;\u0026gt; #{id} \u0026lt;/foreach\u0026gt; \u0026lt;/delete\u0026gt; 測試\n1 2 3 4 5 @Test public void testDeleteByIds(){ List\u0026lt;Integer\u0026gt; ids = Arrays.asList(13,14,15); empMapper.deleteByIds(ids); } sql 與 include 在開發過程中可能會出現大量重複的 SQL 語句，可以用 sql 標籤定義可重用的 SQL 片段，再透過 include 標籤重用\n1 2 3 4 5 6 7 \u0026lt;!-- 透過 id 屬性唯一識別語句 --\u0026gt; \u0026lt;sql id = \u0026#34;commonCode\u0026#34;\u0026gt; \u0026lt;!-- SQL 語句 --\u0026gt; \u0026lt;/sql\u0026gt; \u0026lt;!-- 透過 refid 屬性指定引用的語句 --\u0026gt; \u0026lt;include refid = \u0026#34;commonCode\u0026#34; /\u0026gt; ","date":"2025-01-13T21:06:03+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/216/","title":"MyBatis 使用"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 MyBatis 系列\nMyBatis 安裝與入門：本文\nMyBatis 使用： https://blog.yexca.net/zh-tw/archives/216 MyBatis 是一款優秀的持久層框架，用於簡化 JDBC 的開發。\nMySQL 安裝 Windows 下載： https://dev.mysql.com/downloads/mysql/ 下載 ZIP Archive\n解壓縮，環境變數設定 MYSQL_HOME PATH 路徑 %MYSQL_HOME%\\bin\n以管理員權限開啟 cmd，輸入 mysql 檢測是否設定成功。\n初始化 MySQL 輸入命令：\n1 mysqld --initialize-insecure 稍等片刻，會在 MySQL 目錄生成 data 資料夾。\n註冊 MySQL 服務 命令：\n1 mysqld -install 啟動 MySQL 服務 命令：\n1 2 3 4 # 啟動 mysql 服務 net start mysql # 停止 mysql 服務 net stop mysql 修改 root 密碼 命令：\n1 mysqladmin -u root password 1234 登入參數：\n1 2 3 4 mysql -u 用戶名 -p 密碼 -h 要連線的 mysql 伺服器的 ip 地址 (預設 127.0.0.1) -P 埠號 (預設 3306) # 例如 mysql -u root -p # 執行後會提示輸入密碼 入門範例 首先建立 SpringBoot 專案，勾選 MyBatis Framework 與 MySQL Driver 相依性。\n資料庫 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 create database mybatis; use mybatis; create table user( id int unsigned primary key auto_increment comment \u0026#39;ID\u0026#39;, name varchar(100) comment \u0026#39;姓名\u0026#39;, age tinyint unsigned comment \u0026#39;年齡\u0026#39;, gender tinyint unsigned comment \u0026#39;性別, 1:男, 2:女\u0026#39;, phone varchar(11) comment \u0026#39;手機號碼\u0026#39; ) comment \u0026#39;用戶表\u0026#39;; insert into user(id, name, age, gender, phone) VALUES (null,\u0026#39;白眉鷹王\u0026#39;,55,\u0026#39;1\u0026#39;,\u0026#39;18800000000\u0026#39;); insert into user(id, name, age, gender, phone) VALUES (null,\u0026#39;金毛獅王\u0026#39;,45,\u0026#39;1\u0026#39;,\u0026#39;18800000001\u0026#39;); insert into user(id, name, age, gender, phone) VALUES (null,\u0026#39;青翼蝠王\u0026#39;,38,\u0026#39;1\u0026#39;,\u0026#39;18800000002\u0026#39;); insert into user(id, name, age, gender, phone) VALUES (null,\u0026#39;紫衫龍王\u0026#39;,42,\u0026#39;2\u0026#39;,\u0026#39;18800000003\u0026#39;); insert into user(id, name, age, gender, phone) VALUES (null,\u0026#39;光明左使\u0026#39;,37,\u0026#39;1\u0026#39;,\u0026#39;18800000004\u0026#39;); insert into user(id, name, age, gender, phone) VALUES (null,\u0026#39;光明右使\u0026#39;,48,\u0026#39;1\u0026#39;,\u0026#39;18800000005\u0026#39;); application.properties 1 2 3 4 5 6 7 8 9 10 # 設定資料庫連線資訊 # 驅動程式類別名稱 spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver # 資料庫連線的 url spring.datasource.url=jdbc:mysql://localhost:3306/mybatis # 連線資料庫的帳號 spring.datasource.username=root # 連線資料庫的密碼 spring.datasource.password=1234 User 類別 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 public class User { private Integer id; private String name; private short age; private short gender; private String phone; public User() { } public User(Integer id, String name, short age, short gender, String phone) { this.id = id; this.name = name; this.age = age; this.gender = gender; this.phone = phone; } public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public short getAge() { return age; } public void setAge(short age) { this.age = age; } public short getGender() { return gender; } public void setGender(short gender) { this.gender = gender; } public String getPhone() { return phone; } public void setPhone(String phone) { this.phone = phone; } @Override public String toString() { return \u0026#34;User{\u0026#34; + \u0026#34;id=\u0026#34; + id + \u0026#34;, name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, age=\u0026#34; + age + \u0026#34;, gender=\u0026#34; + gender + \u0026#34;, phone=\u0026#39;\u0026#34; + phone + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#39;}\u0026#39;; } } UserMapper 介面 1 2 3 4 5 6 @Mapper // 在執行時，會自動生成該介面的實作類別物件（代理物件），並且將該物件交由 IOC 容器管理 public interface UserMapper { // 此處採用註解撰寫 SQL 語句 @Select(\u0026#34;select * from user\u0026#34;) public List\u0026lt;User\u0026gt; list(); } 測試類別 1 2 3 4 5 6 7 8 9 10 11 12 @SpringBootTest class MybatisStartApplicationTests { @Autowired private UserMapper userMapper; @Test void contextLoads() { List\u0026lt;User\u0026gt; list = userMapper.list(); list.forEach(System.out::println); } } 資料庫連線池 資料庫連線池是一個容器，負責分配、管理資料庫連線 (Connection)。\n它允許應用程式重複使用一個現有的資料庫連線，而不是再重新建立一個。\n釋放閒置時間超過最大閒置時間的連線，來避免因為沒有釋放連線而引起的資料庫連線遺漏。\n優勢：資源複用、提升系統回應速度。\n官方提供標準介面：DataSource\n常見產品：Hikari (SpringBoot 預設)、Druid。\nLombok 在上述範例中，User 類別雖然只定義了幾個屬性，但需要很多方法從而使得程式碼臃腫，為此可以使用 Lombok。\nLombok 是一個實用的 Java 類別庫，能透過註解的形式自動生成建構子、getter/setter、equals、hashcode、toString 等方法，並可以自動化生成日誌變數，簡化 Java 開發、提高效率。\n註解 作用 @Getter/@Setter 為所有的屬性提供 get/set 方法 @ToString 會給類別自動生成易閱讀的 toString 方法 @EqualsAndHashCode 根據類別所擁有的非靜態欄位自動重寫 equals 方法和 hashCode 方法 @Data 提供了更綜合的生成程式碼功能 (@Getter+@Setter+@ToString +@EqualsAndHashCode) @NoArgsConstructor 為實體類別生成無參數的建構子方法 @AllArgsConstructor 為實體類別生成除了 static 修飾的欄位之外帶有各參數的建構子方法 引入 Lombok 引入相依性，不需要版本號，已經被 SpringBoot 設定：\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; User 類別 1 2 3 4 5 6 7 8 9 10 @Data @NoArgsConstructor @AllArgsConstructor public class User { private Integer id; private String name; private short age; private short gender; private String phone; } Lombok 會在編譯時，自動生成對應的 Java 程式碼，使用 Lombok 需要安裝一個外掛程式，不過 IDEA 預設已安裝。\n","date":"2025-01-12T23:59:48+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/215/","title":"MyBatis 安裝與入門"},{"content":" 📢 此頁面有使用機器翻譯喲 音有所感系列 歌曲名稱 翻譯 連結 僕が死のうと思ったのは 曾經我也想過一了百了 本文 あくあ色ぱれっと aqua 的調色盤 https://blog.yexca.net/zh-tw/archives/219 恋の押し売り 戀愛推銷 https://blog.yexca.net/zh-tw/archives/220 17さいのうた 17 歲的歌 https://blog.yexca.net/zh-tw/archives/224 drop 墜入愛河 https://blog.yexca.net/zh-tw/archives/230 生きるを選んだ私へ 致選擇活下去的自己 https://blog.yexca.net/zh-tw/archives/239 rainy lady 雨意未晴 https://blog.yexca.net/zh-tw/archives/249 恋しくなったら手を叩こう 想談戀愛的話就拍拍手吧 https://blog.yexca.net/zh-tw/archives/250 pris-magic! 稜鏡魔法! https://blog.yexca.net/zh-tw/archives/260 引言 有沒有一種聽力材料，可以讓人不是處於學習的狀態，可以反覆聽，並可以嘗試影子跟讀的呢？這不就是歌曲嗎！\n考慮到我聽歌時只是部分能聽懂，如果深入分析了解歌詞的話，說不定真的可以當成對語言的練習了\n第一首就從一首雖然有點沉重，但可以說陪伴了我大部分時間，我可以百聽不厭的歌曲開始吧\n歌曲影片 歌詞 僕ぼくが死しのうと思おもったのは　ウミネコが桟さん橋ばしで鳴ないたから\n我之所以想過一了百了，是因為黑尾鷗在碼頭啼鳴\n波なみの随意ずいいに浮うかんで消きえる　過去かこも啄ついばんで飛とんでいけ\n隨波浮沉又消逝，連過去也一併啄起飛向遠方\n僕ぼくが死しのうと思おもったのは　誕生日たんじょうびに杏あんずの花はなが咲さいたから\n我之所以想過一了百了，是因為生日時杏花開了\nその木こ漏もれ日びでうたた寝ねしたら　虫むしの死し骸がいと土つちになれるかな\n在那灑落的日影下小憩，是否能化作蟲的遺骸與黃土呢\n薄荷はっか飴あめ　漁港ぎょこうの灯台とうだい　錆さびたアーチ橋ばし　捨すてた自転車じてんしゃ\n薄荷糖、漁港的燈塔、生鏽的拱橋、被拋棄的自行車\n木造もくぞうの駅えきのストーブの前まえで　どこにも旅たび立だてない心こころ\n木造車站爐火前，踏不出旅途的心\n今日きょうはまるで昨日きのうみたいだ　明日あすを変かえるなら今日きょうを変かえなきゃ\n今天就好像昨天一樣，想改變明天的話要從今天開始\n分かってる　分かってる　けれど\n我知道啊，我明白啊，可是。。。\n僕ぼくが死しのうと思おもったのは　心こころが空からっぽになったから\n我之所以想過一了百了，是因為內心已經空寂了\n満みたされないと泣ないているのは　きっと満みたされたいと願ねがうから\n因空虛而哭泣，無非是渴望被填滿\n僕ぼくが死しのうと思おもったのは　靴紐くつひもが解ほどけたから\n我之所以想過一了百了，是因為鞋帶鬆開了\n結むすびなおすのは苦手にがてなんだよ　人ひととの繋つながりもまた然しかり\n重新繫上很麻煩，人際關係也同樣如此\n僕ぼくが死しのうと思おもったのは　少年しょうねんが僕ぼくを見みつめていたから\n我之所以想過一了百了，是因為少年注視著我\nベッドの上うえで土下座どげざしてるよ　あの日ひの僕ぼくにごめんなさいと\n在床上向我土下座，對那天的自己說抱歉\nパソコンの薄うす明あかり　上階じょうかいの部屋へやの生活音せいかつおん\n電腦螢幕的微光，上層房間的生活聲\nインターフォンのチャイムの音おと　耳みみを塞ふせぐ鳥とりかごの少年しょうねん\n門鈴的聲音，捂住耳朵的籠中少年\n見みえない敵てきと戦たたかってる　六畳ろくじょう一間ひとまのドンキホーテ\n在六坪房間的堂吉訶德，與無形之敵在戰鬥著\nゴールはどうせ醜みにくいものさ\n終點反正是醜陋的\n僕ぼくが死しのうと思おもったのは　冷つめたい人ひとと言いわれたから\n我之所以想過一了百了，是因為被人說成冷漠無情\n愛あいされたいと泣ないているのは　人ひとの温ぬくもりを知しってしまったから\n因渴望被愛而哭泣著，是因為已經嘗過人間冷暖\n僕ぼくが死しのうと思おもったのは　あなたが奇麗きれいに笑わらうから\n我之所以想過一了百了，是因為你的笑容如此溫暖\n死しぬことばかり考かんがえてしまうのは　きっと生いきる事ことに真面目まじめすぎるから\n總想着死亡，一定是活得太認真了吧\n僕ぼくが死しのうと思おもったのは　まだあなたに出会であってなかったから\n我之所以想過一了百了，是因為未曾遇見你\nあなたのような人ひとが生うまれた　世界せかいを少すこし好すきになったよ\n正因為有你這樣的人會誕生，才會有點喜歡這個世界\nあなたのような人ひとが生いきてる　世界せかいに少すこし期待きたいするよ\n正因為有你這樣的人存在著，才會對世界有些許期待\n","date":"2025-01-11T01:10:51+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/214/","title":"音之所感 - 《僕が死のうと思ったのは》"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 Python 打包是依據目前的作業系統環境而定的，在 Windows 下會打包出 .exe 執行檔，在 Linux 下則會打包出 ELF 格式的二進位檔案，不支援跨平台打包。\n安裝 透過 pip 安裝\n1 pip install pyinstaller 打包成單一檔案 使用參數 --onefile\n1 pyinstaller --onefile main.py 常用參數 對於 Windows 程式的打包，常用參數有：\n--windowed: 不顯示終端機視窗 (如果是自行實作圖形使用者介面 (GUI) 的話) --icon=icon.ico: 為程式加入圖示 --hidden-import: 明確指定所需的相依套件 (避免自動分析遺漏) --add-data: 加入額外的資源檔到打包中 --debug: 啟用偵錯資訊 打包成多個檔案 打包成多個檔案時，使用 --onedir 參數\n1 pyinstaller --onedir main.dy 相依檔案會放在 _internal 資料夾下，非常不友善\n只有 pyinstaller 6.1.0 以上版本才能使用此參數\n1 pyinstaller --contents-directory . .\\main.py 這樣打包後的相依檔案和進入點就會在同一個目錄中。\n打包設定項目 假設目前專案的設定檔放在 project/conf/settings.json\n打包時想把這個檔案也包含進去，首先打包成多個檔案\n1 pyinstaller --name my_program --contents-directory . .\\main.py 會在目前目錄產生 my_program.spec 檔案，修改 a 的 data，以元組 (tuple) 的方式輸入想打包的檔案，例如：\n1 datas=[(\u0026#39;conf/settings.json\u0026#39;, \u0026#39;conf/\u0026#39;)], 然後刪除 dist/ 資料夾下所有檔案後執行指令 (不刪除也可以，後續問題同意即可)\n1 pyinstaller my_program.spec 專案 透過這種方式，已經把 https://blog.yexca.net/zh-tw/archives/211 的軟體打包成執行檔了 (雖然還是沒做錯誤處理)\n參考文章 https://www.cnblogs.com/yqbaowo/p/17863429.html ","date":"2025-01-07T17:26:09+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/213/","title":"Python pyinstaller 打包"},{"content":" 此頁面有使用機器翻譯喲\n引言 今天想對最近設計的半透明、毛玻璃和圓角進行總結，突然想到 2023-12-01 好像做過一個什麼東西，就順便重整一下好了\n頁面背景 現代的 (二次元) 網頁要有一個背景\n1 2 3 4 5 6 7 8 body{ background-image: url(\u0026#39;../img/77194247_p0.jpg\u0026#39;); background-size: cover; background-attachment: fixed; /* 固定 */ background-repeat: no-repeat; /* 不重複 */ padding: 0; margin: 0; } 半透明與毛玻璃 然後在背景上加一個蒙版，實現半透明與毛玻璃效果\n1 2 3 4 5 6 7 8 9 10 11 .layout { /* display: flex; */ margin: 0; padding: 0; display: flex; width: 100vw; height: 100vh; backdrop-filter: blur(2px); /* 背景模糊效果 */ -webkit-backdrop-filter: blur(2px); /* Safari 支援 */ background: rgba(0, 0, 0, 0.4); /* 半透明黑色背景 */ } 網頁的重構 說起來寫文章還是很傷腦筋，做的時候寫會被打斷，做完再寫又會很累不想動，所以我就折衷一下，隨便寫寫就好\n專案地址: https://github.com/yexca/MusicPlayer-Twinkle 順便更新了之前的文章 https://blog.yexca.net/zh-tw/archives/116/ 用這個方法加了一個範例: https://twinkle.yexca.net 卡片效果 這也屬於現代的設計\n1 2 3 4 5 6 7 8 9 10 .card { width: 300px; padding: 20px; background-color: rgba(255, 255, 255, 0.5); /* 半透明白色背景 */ border-radius: 15px; /* 圓角 */ box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); /* 陰影 */ backdrop-filter: blur(10px); /* 背景模糊效果 */ border: 1px solid rgba(255, 255, 255, 0.3); /* 邊框 */ color: pink; /* 前景文字顏色 */ } 嗯，之後有時間再以卡片為設計來完善這個專案 (又開新坑了)\nTwinkle 另外，專案的內容是 Twinkle 的音樂，具體介紹請參閱\nhttps://twinkle130527.wixsite.com/twinkle https://www.dojin-music.info/circle/1255 SoundCloud\nhttps://soundcloud.com/twintwinkles ","date":"2025-01-05T16:19:36+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/212/","title":"毛玻璃效果"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 2025-05-18 更新\n我寫了一個 SQLite 版的，不用設定資料庫了，詳細資訊請訪問: https://blog.yexca.net/zh-tw/archives/248 耗時三天寫出了一個大概能用的版本，不過沒有做錯誤處理 遇到錯誤直接重啟吧\n專案網址: https://github.com/yexca/PixivDownloader-MySQL 引言 這要從 資料庫紀錄已下載繪師作品 開始說起了，當時我弄了一個資料庫紀錄我下載過的作品，時間久了之後，覺得這玩意是在做重複作業啊，說到重複作業那必然是交給電腦來做啊，正好最近不經意間產生了撰寫程式的想法，也正好對其不滿意: https://github.com/yexca/yasumiProject ，同時又是過年比較空閒，這就開寫。\n說明 雖說我是寫出來了，不過沒有錯誤處理之類的，只能說勉強能用吧。同時程式碼很亂 (第一次開發比較大的 GUI 軟體啦)，亂到我不想去整理和做國際化支援了。\n並且開發過程中突然想到都寫程式了為什麼不用 SQLite 呢，這還要開一個 MySQL 多麻煩，不過都做了，就做到最後吧。\n最後本來想打包的，因為使用設定檔，打包好麻煩 (剛開始不知道打包出來被 Windows 當成病毒了)，我實在懶得折騰了，就這樣吧。\n介面 背景圖: https://www.pixiv.net/artworks/83273073 首頁 設定 設定 因為基於我現有資料庫開發，所以幾乎沒有自定義程度，資料庫建立資料表語句為：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 CREATE TABLE pic ( ID varchar(99), # 唯一識別 name varchar(255), # 繪師暱稱 downloadedDate datetime, # 下載/更新時間 lastDownloadID varchar(255), # 最新作品ID platform varchar(50), # 平台 url varchar(255), # 連結 PRIMARY KEY(ID) )ENGINE=InnoDB DEFAULT CHARSET=utf8mb4; 然後因為 API 的使用需要登入並且不可以用帳號密碼登入，根據 https://gist.github.com/ZipFile/c9ebedb224406f4f11845ab700124362 取得 Auth Token 後使用。\n背景圖片我並沒有上傳到 git 倉庫，路徑為 app\\resources\\images\\background.png\n然後是需要安裝 Python，安裝相依套件：\n1 pip install -r requirements.txt 使用 執行程式\n1 python main.py 在 Pixiv 驗證介面和設定介面完成相關配置後返回首頁。\n填入繪師 ID 或者 某一作品的 ID 就會自動爬取該繪師全部作品了。\n結尾 我其實都覺得自己都不去使用它，這算是我開發經歷的一小步吧。\n","date":"2025-01-03T20:05:44+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/211/","title":"Pixiv 下載器"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 引言 這篇文章是寫給我自己的，說是 2024 總結，但也是記錄近年的生活感悟與心路歷程。文筆不是很好，想表達的東西還有很多，但不知道該如何整合在一起，就先這樣吧。\n從 2020 到 2024 的經歷 從 2020 年開始，慢慢地總是覺得時間過得好快，哪怕是經歷了很多事情，也不會找回 2020 以前那種可能是認真過每一天，或者是會覺得時間漫長的感覺。但是當我以客觀的角度來分析時，事實上每一年我都經歷了許多事情，也做了不少事，尤其是今年我經歷的也可謂是相當之多。\n2020 這年考完大學，之後我開始了第一次遠離家鄉的生活，大學生活時加入了社團，參加了不少活動。 2021 上半年參加了不少社團活動，下半年我更換了手機進入蘋果生態系、轉系、建立本部落格。 2022 我在 Switch OLED 剛出時溢價購入並玩得不亦樂乎，同年購入 Quest2 開啟 VR 之旅，並編寫了一些 VRChat 教學，同時還在年底去了南京遊玩。 2023 這一年換校區了，開始參加一些二次元活動，如原神和必勝客、喜茶的聯名，後期學校解封也是逛了逛周邊地區，參加了軟考和日檢，購買了 Google Pixel 6 以及開始迷上辦卡。 2024 這應該是我最精彩的一年，年初開始去深圳實習，在此期間逛了 Costco 在深圳的新店、第一次看海、認識到了許多很好的人、逛了華強北、去了香港、逛了澳門、第一次坐船等，我的思想也逐漸轉變，回學校、畢業回家後對於他人的態度也有轉變，開始和我的家人交流，和家人去了徐州遊玩，開始嘗試做飯，自己 DIY 物品，考取駕照等，這之後還去了日本，第一次坐飛機，第一次穿二次元衣服出門、第一次參加動漫展 (C105) 等等。 可以說我經歷的事情是逐年增多，但我的主觀感受還是「時間過得很快，我並沒有做過什麼事情」，這不免使我產生困惑。\n對於生活的理論解釋 注意：提及的理論純屬個人想像，並沒有經過驗證分析，請謹慎相信。\n事實上，在 2023 下半年原本應該準備研究所考試的我，眼睛卻非常痛，每天睜眼的時間幾乎不能超過 4 小時。因此那段時間我幾乎天天躺在床上，在半睡半醒中產生了一種解釋生活的理論，於是我就開始沉迷於解釋生活。\n狀態行為理論 我甚至為這些理論進行了命名。最開始產生的是狀態行為理論，我把可以影響人的行為的各種因素當成可以被量化的變數（如情緒的喜怒哀樂、資訊的掌握程度、經歷的事情、當下周圍的影響因子等），這些變數有不同的權重。掌握大部分變數可以較高準確率預測一個人的行為，之後對其進行推論：如果知道每一個人的變數值，那麼每個人的人生其實是確定的。\n當然該理論不是直接演變成這樣的，剛開始的三四天只是暢想。某一天突然意識到貌似我想的東西和 Unity 的 State Behaviors 重合，便以此命名。之後對一些事情進行分析後，演變成大概這個樣子。\n圈子理論 同時為了幫助確定一定的影響因素，我想出了圈子理論來表示一個人受到他人的影響。這本身也是我對於網際網路的思考，源於當我從對單一事物的深度探索，變成對各種事物的廣度探索時，我發現一個很奇怪的現象：網路的人群可以根據對什麼的喜好或關注，而劃分為一個又一個圈子。每個圈子裡貌似有一種自圓其說的理論，同時可能會有相較於普通大眾來說很震驚但圈內很平常，或相較於普通大眾很平常但圈內很震驚的事情。並且存在對立的圈子，也就是其自圓其說出這裡很好、其餘很不好，儘管在另一邊可能是相反的。當然並不可能所有的圈子都是孤立的，部分可以進行同類化到一個集合，一般可以直接以集合的行為代表其下方的行為。\n雖然不是同一個東西，但可以類比在資訊繭房下，人們更多地見到自己想見到的東西。又因為世界上的人很多，總可以找到觀點類似的人，然後在這個繭房裡不斷加深自己的理解，從而形成自圓其說的解釋。\n當然這可能只是基礎結論，要想解釋這個複雜的世界，不能每次都使用基礎結論，應該使用一定的推論或輔助結論。\n名句的解釋 比如為什麼會覺得名人名言很有道理。基於狀態行為理論，或者可能推廣到對萬物的解釋，也就是世界的事物有一個根父類別，其演變出許多子類別，以此類推到子抽象類別。可能他們經歷了一定的事情，實際上是某個抽象類別的實作，以此總結抽象出一句話。然後我們的某些經歷可能是這個抽象類別的另一種實作，就會覺得這句名言很有道理。\n稍微嚴謹來說，這基於因為人類歷史的記載太多了，幾乎任何選擇都有人做過（不一定是那件事，而是抽象成那件事）。於是無論對於任何事情都可以給出正面支持和反面教訓，因此我不認為世界上有絕對正確或絕對錯誤的事情，只是在某些狀態或場合下相對正確或錯誤。\n信任解釋理論 再比如最近喜歡的信任解釋理論。我覺得世界是基於信任運作的，比如在過馬路的時候信任司機不會突然開車撞向我、走在路上迎面而來的人不會掏出刀來刺傷我等等，這可能是比較平常或習慣的事情基於普遍的信任。\n當然，這將近一年半的時間裡還考慮過很多其他理論解釋，但不是太記得了。\n理論與實踐的割裂 偶爾我也會想，如果能像孩子一樣隨心所欲地做自己喜歡的事，會不會感到更多的自由？但轉念一想，這個孩子或許早已被我埋葬在規則的泥土之下。\n雖然很多生活問題都可以解釋了，但這還是沒有幫助我走出這種經歷，甚至慢慢開始產生了負面效果。\n隨著解釋的增多，我也不是突然意識到，應該是慢慢感受到我可能就是太沉浸於解釋了，而忘了生活往往是結果，我卻一直想著哪種選擇會產生哪種結果。雖然事前把所有可能性想好，經歷固然會更美好，但正因為把所有的可能都分析了，實際在經歷的時候就和玩遊戲跳過 NPC 對話似的，只等別人說出自己提前想到的某種可能的話，然後選擇一種可能性回覆，慢慢地對於生活就會厭倦。\n於是我開始去嘗試娛樂：散步、購物、跑步、旅行、玩遊戲等。明明擁有選擇的自由，卻總覺得自己被附加了某種無形的鎖鏈。哪怕是娛樂，也像完成任務一般，更多是為了達成心理上的「數值平衡」，而非真正的放鬆與快樂。我的生活彷彿變成了一場模擬遊戲，面對壓力時，我會按照既定規則尋找降低壓力的方式，比如「安排娛樂」。我對自己的生活可能也進行了量化，覺得某件事情產生了多少壓力，我需要做些什麼降低壓力，但這些娛樂活動卻不是真正為我帶來快樂的事，而是執行一種被普遍認為有效的「壓力緩解」方案。這讓我想起被安排娛樂的孩子，乍看之下他們在玩遊戲或參加活動，卻未必是發自內心的熱愛。我現在的狀態似乎和他們沒有區別，只不過安排的人和被安排的人都是我自己。\n我是自己生活的設計者，同時也是執行者，彷彿自己安排的劇本，只是為了完成任務，卻失去了內在的情感連結。\n我開始慢慢覺得自己身上有附加的鎖鏈，我做任何事情都要在一個特定的規則下，只要是做了除這件事以外的東西就是不好，或者不行。亦或者我在尋求一個認可，只要我這樣做了就會被認可，那樣做了一定不被認可。\n這是否也是陷入了一個圈子理論的圈子中呢？解釋出這些的我其實也是另一種解釋的一部分，就好比我認為世界的理論是一個一個數軸上的點，然後我把這些串起來解釋出了數軸，但我本身也被二維座標系所解釋著。\n由於 bilibili 的嵌入式體驗不好，改為 Youtube 的。鹿乃有官方帳號，本歌曲影片：BV1zr4y1n7sM\n我懷疑過自己應該是患了憂鬱症，甚至規劃過如何自殺。寫到這裡突然想到《僕が死のうと思ったのは (曾經我也想過一了百了)》這首歌的一句歌詞「死ぬことばかり考えてしまうのは (腦子裡只想著自殺這件事)　きっと生きる事に真面目すぎるから (一定是因為對待生活太過認真了吧)」。是啊，正如歌詞所寫，我是否是對生活過於認真了呢？\n同時這首歌的其他地方也讓我有所聯想，比如「今日はまるで昨日みたいだ (今天就好像昨天一樣)」。是啊，儘管每天都經歷不一樣的事情，但在思想上我覺得這就是理論產生的結果，理論並沒有改變，生活也沒有改變。\n「見えない敵と戦ってる (一直與看不見的敵人在戰鬥)」，我在和誰戰鬥呢？彷彿就是我創造出來的規則的負面，也是我內心的不確定感和對悲傷的固執。\n「明日を変えるなら今日を変えなきゃ (想要改變明天的語就得從今天開始改變)　分かってる (我知道啊)　分かってる (我明白啊)　けれど (可是\u0026hellip;)」，可是我可以改變什麼呢？基於理論的印象，就算向他人訴說，他人給出了見解，哪怕是說動了我，我也還是會一成不變地按照自己悲傷的觀點度日。\n「僕が死のうと思ったのは (我之所以想一了百了是因為)　冷たい人と言われたから (被說成是冷漠的人)」，但我明明是按照應該會很有趣的人的樣子做出的回應啊。\n「愛されたいと泣いているのは (因為想要被愛而哭泣)　人の温もりを知ってしまったから (是因為我開始懂得人情世故)」，他們的關心都是基於對他人的尊重或者禮儀，並不是真的關心我，我也只是禮貌機械地回覆，沒有任何情感。\n「僕が死のうと思ったのは (我之所以想一了百了是因為)　まだあなたに出会ってなかったから (還沒有與你相遇)　あなたのような人が生まれた (正因為有你這樣的人出生)　世界を少し好きになったよ (我才會變得喜歡這個世界啊)　あなたのような人が生きてる (正因為有你這樣的人活著)　世界に少し期待するよ (我才對世界有些許期待唷)」，但我把自己尋求幫助、他人的見解也運用理論去解釋，那是一種必然產生的結果，彷彿我去呼叫一個介面，輸入一定內容就會回傳給我什麼內容。只要我這樣做就會獲得什麼，太確定了。\n但生活往往是不確定的，我慢慢也會對不確定的事情感到恐懼。同樣地，為了消除恐懼，我開始完善之前對於生活的理論，慢慢地增加子理論去解釋，這也暫時緩解了我一定的恐懼。但是人是不可能絕對理性的，第一反應本能地還是會出於感性，我的理論也會有這一點存在。理性控制著我，這只是暫時的，從結果來看，時間會把傷口撫平。\n從解釋到行動的轉變 時間像流水，不斷流逝，而我卻彷彿在岸邊計算水量，卻忘了去觸摸水的溫度。\n我為自己打造了一套看似理性的框架，卻逐漸成為它的囚徒。即使有完全的自由選擇權，也總是帶著無形的束縛感。這個理論最大的問題在於，它過於強調邏輯與規則，忽略了情感和體驗的部分。我彷彿是一個演算法，為自己設定了行動規則，卻在執行過程中發現，我應該表達自己的感受。這是一個漫長的轉變過程，不過對於我來說，解釋可以立馬轉變，但思想或行動卻很難轉變。在理論的思維固化下，我很難去轉變從事物本源解釋的角度看待問題。\n我首先意識到自己對理論的依賴開始有負面效果，雖然當我產生這個想法的時候，也是可以被自己的理論所解釋，因為我會用它解釋一切，包括它自己。但同時人是可以轉變的，因為受到變數的影響，多個變數的累積，權重不斷加大，開始促使我轉變。\n首先應該是我接觸的人變多了。固步自封、自我封閉雖然不會受到人際關係的傷害，但也使得自己接觸面變得侷限。其實也正感謝我的理論，它讓我先擁有了邁出去的第一步，因為可能在內向的心裡和別人交流很麻煩，但理論的思維是不違法不違規，我可以有這種選擇，我只是做了一個和別人交流的選擇而已。從遇到的第一個性格很好的人開始，逐步認識更多的人，我慢慢地產生了性格的轉變。\n因為接觸面變廣，可以對世界進行更深層次的思考，從而完善了理論。這種完善的理論使得我可以產生更多選擇的可能性（雖然有負面的比如更多的恐懼），但正如高風險高收益一樣，事物伴隨著一定的代價。\n這之後就是慢慢嘗試變多後，我可以說是去驗證了理論吧。從空想到驗證的調整，使得我可以更清楚知道某項選擇後果的個人感受程度，正因為這種對感受的重視，把我從量化拉回。\n當然這遠遠不夠，因為感受也是可以量化的。上個月我練習聽力的時候聽到一段對話：\nA：這兩個哪個更好？ B：甲挺不錯。 A：乙不會更好嗎（並解釋了理由）。 B：明明已經有了結論還來問我幹什麼。\n儘管只是比較日常的對話，但它多次在我腦中回想。確實，多數時候我可能知道大概怎麼做，並且有一定的決定，但是我不去行動，只是反覆確認可能性，力圖找出所有分支，讓我活在確定中，甚至不是找最優解。這段對話事實上是對我一種確定的回覆產生一種不確定的可能（我知道這話很怪，只是我不會表達這種感受），亦或者是喚起了選擇的意義是獲得自己想要的結果。\n再或者說，可能只是我並沒有什麼目標，沒有根據自己的情感、需求確定的目標，只是根據一定的可能性創造出來的目標，創造出來的我並不喜歡的目標。\n我開始嘗試增加自己感受的變數，我要把自己喜歡的事物的權重拉高。理論是解釋生活、幫助人類理解世界的，它不是支配者，我不應該被支配。我應該是使用它以達到我喜歡的目標，我喜愛的生活！\n現狀 我可以自由表達，我可以自由行動（不違反法律規則的話）。這篇文章的出現也表達了我在慢慢衝破枷鎖，因為我之前覺得這是一件很丟臉的事情，不去記錄我的理論，所以事實上部分子理論也就忘了。\n我意識到活著是一個過程，這是一個無法改變的事實。正如我之前對朋友說過的一句話：「既然無法改變，只能去適應」。生活中會遇到各種各樣的人，美好的也有，不幸的也有。往往當我們陷入悲傷的時候，那是不幸的東西累積太多，或許衝昏了頭腦，而忘記了自己所擁有的美好事物。\n正如 關於頁面 寫道，「無論何時都要盛裝登場，每段經歷都是全心投入」。對於世界來說，我只是一個個體，一個數字，但對於我來說，我就是整個世界！\n「 萬物皆浮雲，只要好心情 」，激活自己的 Atopes ，做自己熱愛的事吧，買自己喜歡的東西吧，去自己想去的地方吧。不用考慮太多，大膽表達自己吧。\n我現在就想到了 https://github.com/RimoChan 的頭像，真正去熱愛自己的生活。快樂也是活一天，痛苦也是活一天，沒必要內耗啦。\n結尾 明年會怎麼樣呢？我覺得可以以我部落格的介紹結尾：\n把這個不美好的世界，編成我所期望的樣子吧！\n","date":"2024-12-31T17:40:09+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/210/","title":"2024 年度總結"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 引言 隨著對於資訊的瀏覽增多，往往會有書寫其他語言文章的需求（同時現代的作品幾乎都具備多語言支援），同時也因為自從畢業設計當時加入了多語言支援後，之後做的東西或設計的東西往往都會想要進行國際化支援。就連 最近寫的一個相當於練手的小專案 也弄了多語言支援呢（不過這並不是我想要的效果，太古老了，想做一個現代一點的，另外 正在製作中 ，希望可以堅持做完）。\n回過頭來看看我的部落格，這個陪伴我最久的作品，它還沒有國際化。雖然一部分原因通常都是寫簡體中文文章啦，但 之前的部落格 介面部分中文部分英文，實際上弄得多少有些混亂，雖然我個人可以看懂，但對於非相關人士可能會感到疑惑。\n但原本的 Jekyll 我折騰了半天硬是沒成功達成多語言，索性轉向原生支援國際化的 Hugo 啦。不過每個主題都有其特色，這個主題對於分類與標籤的處理和上個主題區別很大，之後得慢慢修改適應才行。\n這篇文章寫得很潦草吧，主要是它的配置貌似很依賴主題，我也幾乎都是根據主題的範例修改的，所以我覺得也沒什麼好寫的（因為官方文件也很豐富）。\n環境 使用 Docker 有 Hugo 的容器，所以環境問題沒怎麼折騰（使用的工具可以看 這裡 呢）。\n建立部落格 建立新部落格\n1 hugo new site blogName 進入目錄\n1 cd blogName 初始化儲存庫\n1 git init 安裝主題，這裡使用 hugo-theme-stack 主題，其他同理\n1 git submodule add https://github.com/CaiJimmy/hugo-theme-stack/ themes/hugo-theme-stack 配置 hugo.toml 選擇主題\n1 theme = \u0026#39;hugo-theme-stack\u0026#39; 預覽\n1 hugo server 包含草稿 (draft) 的預覽\n1 hugo server -D 部分修改可能需要清除快取才能生效（例如配置項、頁面的修改）\n1 hugo --cleanDestinationDir 建置網站，預設建置檔案在 public 目錄下\n1 hugo 多語言支援 在網站設定檔（我使用 yml 配置）中設定預設語言\n1 2 defaultContentLanguage: \u0026#39;zh-cn\u0026#39; # 預設語言代碼 defaultContentLanguageInSubdir: false # 預設語言路徑是否帶語言代碼 然後設定具體的語言項目\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 languages: zh-cn: contentDir: \u0026#39;content/zh-cn\u0026#39; # 文章存放目錄 disabled: false languageCode: \u0026#39;zh-cn\u0026#39; languageDirection: \u0026#39;ltr\u0026#39; # 文章從左到右 (ltr) 還是從右到左 (rtl) languageName: \u0026#39;简体中文\u0026#39; title: \u0026#34;yexca\u0026#39;Blog\u0026#34; weight: 1 zh-tw: contentDir: \u0026#39;content/zh-tw\u0026#39; disabled: false languageCode: \u0026#39;zh-tw\u0026#39; languageDirection: \u0026#39;ltr\u0026#39; languageName: \u0026#39;繁體中文\u0026#39; title: \u0026#34;yexca\u0026#39;Blog\u0026#34; weight: 2 字體國際化: https://blog.yexca.net/zh-tw/archives/240 文章撰寫 不同於 Jekyll，Hugo 的文章撰寫稍微有點複雜，加上國際化支援後，使得文章管理更加複雜（複雜的好處是自定義程度高），這點可能根據不同主題而有所不同。我說明一下我使用的做法，首先上方語言項目配置指定了文章的目錄，需要在 content 建立相應目錄，然後該語言的文章就在該目錄下寫作。\n同時，指定文章是在哪個目錄下，stack 主題設定檔中可以指定：\n1 2 3 params: mainSections: - posts 這就表示我簡體中文的文章應該放在 content/zh-cn/posts 裡，然後還有一些目錄是主題指定的，可以參考對應主題的範例。\n現在要建立一篇簡體中文的新文章可以使用：\n1 TZ=\u0026#34;Asia/Tokyo\u0026#34; hugo new content/zh-cn/posts/test.md 不指定時區的話預設使用 UTC 時間（雖然可以自己改，但習慣了 Jekyll 自動建立的我，覺得自己寫時間很麻煩）。\n文章預設建立模板在 blogName/archetypes 下，可以改為 yml 格式。\n參考文章 Hugo - Quick start https://stack.jimmycai.com/guide/ Hugo - Multilingual mode ","date":"2024-12-27T23:11:45+09:00","permalink":"https://blog.yexca.net/zh-tw/archives/209/","title":"使用 Hugo 進行部落格國際化支援"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 簡易 (非技術框架) 實作的 Go 後端\n眾所周知，後端的開發通常是面向介面的開發，也可以說是 CRUD 工程師。本文將使用 Go 語言描述如何從資料庫讀取資料，並回傳 JSON 格式的資料。\n資料庫 本範例是從 MySQL 資料庫的分類表，讀取出分類的名稱與 ID，資料庫結構如下：\n1 2 3 4 5 6 DROP TABLE IF EXISTS categories ; CREATE TABLE categories ( id INT AUTO_INCREMENT PRIMARY KEY, name VARCHAR(255) NOT NULL, description VARCHAR(255) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4; 專案結構 本範例的專案結構如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 project/ ├── database/ // 資料庫套件 │ └── database.go // 資料庫連線 ├── handler/ // 處理器套件 │ └── category.go // 分類相關介面 ├── model/ // 資料模型套件 │ ├── category.go // 分類表模型 │ └── response.go // 回應資料模型 ├── router/ // 路由套件 │ └── router.go // 路由設定 ├── utils // 工具套件 │ └── response.go // 統一回應 ├── main.go // 程式進入點 接下來將分目錄說明。\ndatabase 此套件用於管理與資料庫的連線。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 // database.go package database import ( \u0026#34;database/sql\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; _ \u0026#34;github.com/go-sql-driver/mysql\u0026#34; ) var DB *sql.DB func InitDB() { var err error dsn := \u0026#34;username:password@tcp(address:3306)/name?charset=utf8\u0026#34; DB, err = sql.Open(\u0026#34;mysql\u0026#34;, dsn) if err != nil { log.Fatalf(\u0026#34;無法開啟資料庫: %v\u0026#34;, err) } // 測試連線 err = DB.Ping() if err != nil { log.Fatalf(\u0026#34;無法 Ping 資料庫: %v\u0026#34;, err) } fmt.Println(\u0026#34;成功連線到資料庫！\u0026#34;) } handler 此套件負責處理特定的業務邏輯 (類似於三層式架構中的 Service)。其中，資料庫處理部分還可以再分層 (類似於 Mapper)，不過這只是一個簡單的範例，就先這樣囉～\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 // category.go package handler import ( \u0026#34;net/http\u0026#34; \u0026#34;project/database\u0026#34; \u0026#34;project/model\u0026#34; \u0026#34;project/utils\u0026#34; ) func GetCategories(w http.ResponseWriter, r *http.Request) { // 查詢資料庫 rows, err := database.DB.Query(\u0026#34;select id,name from categories\u0026#34;) if err != nil { http.Error(w, \u0026#34;查詢分類失敗\u0026#34;, http.StatusInternalServerError) return } defer rows.Close() // 解析資料 var categories []model.Category for rows.Next() { var category model.Category err = rows.Scan(\u0026amp;category.Id, \u0026amp;category.Name) if err != nil { utils.JSONResponse(w, http.StatusInternalServerError, \u0026#34;無法解析分類資料\u0026#34;, nil) //http.Error(w, \u0026#34;Failed to analyze Categories\u0026#34;, http.StatusInternalServerError) return } categories = append(categories, category) } // 回傳 JSON //w.Header().Set(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;) //json.NewEncoder(w).Encode(categories) utils.JSONResponse(w, http.StatusOK, \u0026#34;\u0026#34;, categories) } 被註解掉的內容是未採用統一回應介面，直接回傳 JSON 的情況。\nmodel 這裡的資料模型通常可以分為三種：從前端接收到的、資料庫的，以及回傳給前端的。由於這只是一個簡單的範例，所以我並沒有細分。\n1 2 3 4 5 6 7 8 // category.go package model type Category struct { Id int `json:\u0026#34;id\u0026#34;` Name string `json:\u0026#34;name\u0026#34;` Description string `json:\u0026#34;description\u0026#34;` } 回應的資料模型為：\n1 2 3 4 5 6 7 package model type Response struct { Code int `json:\u0026#34;code\u0026#34;` Msg string `json:\u0026#34;msf\u0026#34;` Data interface{} `json:\u0026#34;data\u0026#34;` } router 此套件管理路由，也就是當存取到什麼路徑時，要指定相對應的處理邏輯 (類似於三層式架構中的 Controller)。\n1 2 3 4 5 6 7 8 9 10 11 12 13 // router.go package router import ( \u0026#34;github.com/gorilla/mux\u0026#34; \u0026#34;project/handler\u0026#34; ) func InitRouter() *mux.Router { router := mux.NewRouter() router.HandleFunc(\u0026#34;/categories\u0026#34;, handler.GetCategories).Methods(\u0026#34;GET\u0026#34;) return router } utils 此套件為工具類別，用於定義可通用的工具。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // response.go package utils import ( \u0026#34;encoding/json\u0026#34; \u0026#34;log\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;project/model\u0026#34; ) func JSONResponse(w http.ResponseWriter, code int, message string, data interface{}) { w.Header().Set(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json; charset=utf-8\u0026#34;) w.WriteHeader(http.StatusOK) err := json.NewEncoder(w).Encode(model.Response{Code: code, Msg: message, Data: data}) if err != nil { log.Fatal(err) return } } main 程式的進入點\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // main.go package main import ( \u0026#34;log\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;project/database\u0026#34; \u0026#34;project/router\u0026#34; ) func main() { // 初始化資料庫 database.InitDB() // 初始化路由 r := router.InitRouter() // 啟動 log.Println(\u0026#34;在連接埠 8848 啟動伺服器\u0026#34;) log.Fatal(http.ListenAndServe(\u0026#34;:8848\u0026#34;, r)) } 執行 go run main.go 後，程式將會監聽連接埠 8848。\n","date":"2024-12-22T22:07:15+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/208/","title":"GoLang 後端入門"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 Golang 系列\nHello GoLang: https://blog.yexca.net/zh-tw/archives/154 GoLang (var and const) 變數與常數: https://blog.yexca.net/zh-tw/archives/155 GoLang (func) 函式: https://blog.yexca.net/zh-tw/archives/156 GoLang (slice and map) 切片: https://blog.yexca.net/zh-tw/archives/160 GoLang (OOP) 物件導向: https://blog.yexca.net/zh-tw/archives/162 GoLang (reflect) 反射: https://blog.yexca.net/zh-tw/archives/204 GoLang (struct tag) 結構體標籤: https://blog.yexca.net/zh-tw/archives/205 GoLang (goroutine) Go 協程: https://blog.yexca.net/zh-tw/archives/206 GoLang (channel) 通道: 本文\nGo 協程 (goroutine) 可以透過通道 (channel) 傳遞資料，引用型別的通道可用於多個 Go 協程之間的通訊，其內部實作了同步機制，確保併發安全\n有點類似 RabbitMQ (僅個人為方便學習所類比，實則為不同東西)\n定義變數 通道為引用型別，複製或函式呼叫時將引用同一個通道物件，零值為 nil\n透過 make() 函式建立，例如\n1 2 3 c := make(chan int) // 新增容量為 3 c := make(chan int, 3) 當容量為 0 時，通道是無緩衝區、會阻塞讀寫的；大於 0 時有緩衝區、非阻塞，直到寫滿才會阻塞\n透過 \u0026lt;- 來接收和傳送資料\n1 2 3 4 5 6 7 8 // 傳送資料到通道 channel \u0026lt;- 3 // 接收並捨棄 \u0026lt;-channel // 注意無空格 // 接收並賦值給變數 x := \u0026lt;-channel // 接收並賦值給變數，並判斷是否接收成功(通道是否為空) data, flag := \u0026lt;-channel 無緩衝區 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package main import \u0026#34;fmt\u0026#34; func main() { c := make(chan int) go func() { defer fmt.Println(\u0026#34;A.defer\u0026#34;) c \u0026lt;- 6 fmt.Println(\u0026#34;A 正在執行\u0026#34;) }() num := \u0026lt;-c fmt.Println(\u0026#34;num =\u0026#34;, num) fmt.Println(\u0026#34;main 結束\u0026#34;) } 有緩衝區 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { c := make(chan int, 3) go func() { defer fmt.Println(\u0026#34;A 結束\u0026#34;) for i := 0; i \u0026lt; 3; i++ { c \u0026lt;- i fmt.Println(\u0026#34;A Go 協程, i =\u0026#34;, i, \u0026#34;len =\u0026#34;, len(c), \u0026#34;cap =\u0026#34;, cap(c)) } }() time.Sleep(2 * time.Second) for i := 0; i \u0026lt; 3; i++ { num := \u0026lt;-c fmt.Println(\u0026#34;main, num =\u0026#34;, num) } fmt.Println(\u0026#34;main 結束\u0026#34;) } 關閉通道 透過 close() 關閉\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package main import \u0026#34;fmt\u0026#34; func main() { c := make(chan int, 5) go func() { for i := 0; i \u0026lt; 5; i++ { c \u0026lt;- i } // 關閉 close(c) }() for { if data, ok := \u0026lt;-c; ok { fmt.Println(data) } else { break } } fmt.Println(\u0026#34;Main 完成\u0026#34;) } 使用 range 上述 main 的 for 迴圈可以簡寫使用 range\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package main import \u0026#34;fmt\u0026#34; func main() { c := make(chan int, 5) go func() { for i := 0; i \u0026lt; 5; i++ { c \u0026lt;- i } close(c) }() //for { // if data, ok := \u0026lt;-c; ok { // fmt.Println(data) // } else { // break // } //} for data := range c { fmt.Println(data) } fmt.Println(\u0026#34;Main 完成\u0026#34;) } 單向通道 預設情況下，通道是雙向的，即可讀可寫，也可以指定通道方向，只讀或只寫\n1 2 3 4 5 var c chan int // 宣告正常雙向通道 // c1 只可寫 var c1 chan\u0026lt;- int // c2 只可讀 var c2 \u0026lt;-chan int 可以把雙向通道轉為單向，反之則不行。也就是可以定義函式形參為單向，但傳遞雙向通道\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // chan\u0026lt;- // 只寫 func counter(out chan\u0026lt;- int) { defer close(out) for i := 0; i \u0026lt; 5; i++ { out \u0026lt;- i // 如果對方不讀，會阻塞 } } // \u0026lt;-chan // 只讀 func printer(in \u0026lt;-chan int) { for num := range in { fmt.Println(num) } } func main() { c := make(chan int) // 雙向 go counter(c) // 生產者 printer(c) // 消費者 fmt.Println(\u0026#34;完成\u0026#34;) } select select 可以監聽多個通道上的資料流動，語法與 switch 類似，但每個 case 敘述中必須是一個 I/O 操作\n一般放到 for{} 敘述區塊中\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 package main import \u0026#34;fmt\u0026#34; func main() { c := make(chan int) quit := make(chan int) go func() { for i := 0; i \u0026lt; 10; i++ { fmt.Println(\u0026lt;-c) } quit \u0026lt;- 0 }() // main x, y := 1, 1 for { select { case c \u0026lt;- x: tmp := x x = y y = tmp + y case \u0026lt;-quit: fmt.Println(\u0026#34;退出\u0026#34;) return // 可以有 default，此範例不需要 } } } ","date":"2024-12-21T14:52:55+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/207/","title":"GoLang 通道"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 Golang Series\nHello GoLang: https://blog.yexca.net/zh-tw/archives/154 GoLang (var and const) 變數與常數: https://blog.yexca.net/zh-tw/archives/155 GoLang (func) 函式: https://blog.yexca.net/zh-tw/archives/156 GoLang (slice and map) 切片: https://blog.yexca.net/zh-tw/archives/160 GoLang (OOP) 物件導向: https://blog.yexca.net/zh-tw/archives/162 GoLang (reflect) 反射: https://blog.yexca.net/zh-tw/archives/204 GoLang (struct tag) 結構體標籤: https://blog.yexca.net/zh-tw/archives/205 GoLang (goroutine) Go 程: 本文\nGoLang (channel) 通道: https://blog.yexca.net/zh-tw/archives/207 行程 (Process) -\u0026gt; 執行緒 (Thread) -\u0026gt; 協程 (Coroutine)\n協程 (coroutine) 也稱為輕量級執行緒，可以輕鬆建立上萬個而不會導致系統資源耗盡，多個協程共享該執行緒分配到的電腦資源。\nGo 語言原生支援協程，稱為 goroutine，Go 的並發透過 goroutine 和 channel 實作。\n建立 goroutine 透過 go 關鍵字開啟一個 goroutine\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func newTask() { i := 0 for { fmt.Println(\u0026#34;newTask goroutine i =\u0026#34;, i) i++ time.Sleep(1 * time.Second) } } func main() { go newTask() i := 0 for { fmt.Println(\u0026#34;main goroutine i =\u0026#34;, i) i++ time.Sleep(1 * time.Second) } } 使用匿名函式 當然也可以使用匿名函式\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { go func() { defer fmt.Println(\u0026#34;A.defer\u0026#34;) func() { defer fmt.Println(\u0026#34;B.defer\u0026#34;) fmt.Println(\u0026#34;B\u0026#34;) }() // 表示執行該匿名函式 fmt.Println(\u0026#34;A\u0026#34;) }() time.Sleep(2 * time.Second) } 匿名函式也可以有參數與回傳值，不過 goroutine 的回傳值需要透過 channel 傳輸，下例僅示範帶有參數的情況：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { go func(a, b int) { fmt.Println(\u0026#34;a =\u0026#34;, a, \u0026#34;b =\u0026#34;, b) }(10, 20) time.Sleep(2 * time.Second) } 結束 主 goroutine 結束後，其他的工作 goroutine 也會自動結束。\n不過也可以使用 runtime.Goexit() 立即終止當前 goroutine 的執行 (defer 仍會執行)。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;runtime\u0026#34; \u0026#34;time\u0026#34; ) func main() { go func() { defer fmt.Println(\u0026#34;A.defer\u0026#34;) func() { defer fmt.Println(\u0026#34;B.defer\u0026#34;) runtime.Goexit() // 結束 goroutine fmt.Println(\u0026#34;B\u0026#34;) }() // 表示執行該匿名函式 fmt.Println(\u0026#34;A\u0026#34;) }() time.Sleep(2 * time.Second) } /* * 輸出 * B.defer * A.defer */ ","date":"2024-12-17T21:16:31+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/206/","title":"GoLang Go 程"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 Golang Series\nHello GoLang: https://blog.yexca.net/zh-tw/archives/154 GoLang (var and const) 變數與常數: https://blog.yexca.net/zh-tw/archives/155 GoLang (func) 函式: https://blog.yexca.net/zh-tw/archives/156 GoLang (slice and map) 切片: https://blog.yexca.net/zh-tw/archives/160 GoLang (OOP) 物件導向: https://blog.yexca.net/zh-tw/archives/162 GoLang (reflect) 反射: https://blog.yexca.net/zh-tw/archives/204 GoLang (struct tag) 結構體標籤: 本文\nGoLang (goroutine) Goroutine: https://blog.yexca.net/zh-tw/archives/206 GoLang (channel) 通道: https://blog.yexca.net/zh-tw/archives/207 透過結構體標籤可以描述該類別在某套件的作用。\n獲取標籤值 透過 ` 符號來定義 tag (Markdown 程式碼區塊的按鍵)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) type User struct { // 多個 tag 用空格分隔 name string `doc:\u0026#34;name\u0026#34; info:\u0026#34;nameOfUser\u0026#34;` age int `info:\u0026#34;ageOfUser\u0026#34;` } func main() { user := User{\u0026#34;zhangSan\u0026#34;, 18} findTag(\u0026amp;user) } func findTag(input interface{}) { t := reflect.TypeOf(input).Elem() for i := 0; i \u0026lt; t.NumField(); i++ { tagInfo := t.Field(i).Tag.Get(\u0026#34;info\u0026#34;) tagDoc := t.Field(i).Tag.Get(\u0026#34;doc\u0026#34;) fmt.Println(\u0026#34;info:\u0026#34;, tagInfo, \u0026#34;doc:\u0026#34;, tagDoc) } } JSON 轉換 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 package main import ( \u0026#34;encoding/json\u0026#34; \u0026#34;fmt\u0026#34; ) type User struct { // 注意必須是公有屬性才可轉換 JSON Name string `json:\u0026#34;name\u0026#34;` Age int `json:\u0026#34;age\u0026#34;` } func main() { user := User{\u0026#34;zhangSan\u0026#34;, 18} // struct --\u0026gt; json jsonStr, err := json.Marshal(user) if err != nil { fmt.Println(\u0026#34;error\u0026#34;, err) } else { fmt.Printf(\u0026#34;jsonStr : %s\\n\u0026#34;, jsonStr) } // json --\u0026gt; struct var user2 User err = json.Unmarshal(jsonStr, \u0026amp;user2) if err != nil { fmt.Println(\u0026#34;error\u0026#34;, err) } else { fmt.Println(user2) } } ","date":"2024-12-11T18:31:18+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/205/","title":"GoLang 結構體標籤"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 Golang Series\nHello GoLang: https://blog.yexca.net/zh-tw/archives/154 GoLang (var and const) 變數與常數: https://blog.yexca.net/zh-tw/archives/155 GoLang (func) 函式: https://blog.yexca.net/zh-tw/archives/156 GoLang (slice and map) 切片: https://blog.yexca.net/zh-tw/archives/160 GoLang (OOP) 物件導向: https://blog.yexca.net/zh-tw/archives/162 GoLang (reflect) 反射：本文\nGoLang (struct tag) 結構體標籤: https://blog.yexca.net/zh-tw/archives/205 GoLang (goroutine) Goroutine: https://blog.yexca.net/zh-tw/archives/206 GoLang (channel) 通道: https://blog.yexca.net/zh-tw/archives/207 反射指一類應用，它們能夠自我描述與自我控制\npair Go 語言變數包括 type (型別) 和 value (值) 部分，組成 pair\nstatic type 是在編碼時開發者看見的型別，concrete type 是在 runtime 系統看見的型別\n型別斷言能否成功，取決於變數的 concrete type，而不是 static type。因此一個 read 變數如果 concrete type 也實作了 write 方法的話，也可以被型別斷言為 write\n反射建立於型別之上，靜態型別已經固定，因此反射主要與 interface 型別相關 (它是 concrete type)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 package main import \u0026#34;fmt\u0026#34; type ReadBook interface { Read() } type WriteBook interface { Write() } type Book struct { } func (this *Book) Read() { fmt.Println(\u0026#34;read Book\u0026#34;) } func (this *Book) Write() { fmt.Println(\u0026#34;write Book\u0026#34;) } func main() { // b: pair\u0026lt;type:Book, value:book{}位址\u0026gt; b := \u0026amp;Book{} // r: pair\u0026lt;type:, value:\u0026gt; var r ReadBook // r: pair\u0026lt;type:Book, value:book{}位址\u0026gt; r = b r.Read() var w WriteBook w = r.(WriteBook) // 因為 r 的 type 是 Book，所以可行 w.Write() } TypeOf 與 ValueOf reflect.TypeOf() 是獲取 pair 中的 type，reflect.ValueOf() 獲取 pair 中的 value\n1 2 3 4 5 6 7 8 9 10 11 12 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) func main() { a := 3.14 fmt.Println(\u0026#34;type of a:\u0026#34;, reflect.TypeOf(a)) // float64 fmt.Println(\u0026#34;value of a:\u0026#34;, reflect.ValueOf(a)) // 3.14 } 類型轉換 執行 reflect.ValueOf() 後得到型別為 reflect.Value 的變數\n已知原始資料型別 已知原始資料型別可以直接強制轉換\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) func main() { a := 3.14 fmt.Println(\u0026#34;type of a:\u0026#34;, reflect.TypeOf(a)) fmt.Println(\u0026#34;value of a:\u0026#34;, reflect.ValueOf(a)) value := reflect.ValueOf(a) fmt.Printf(\u0026#34;type of value:%T\\n\u0026#34;, value) // reflect.Value newA := value.Interface().(float64) fmt.Printf(\u0026#34;type of newA:%T\\n\u0026#34;, newA) // float64 } 需要注意型別轉換需要完全一致，否則將會 panic，例如指標\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) func main() { a := 3.14 fmt.Println(\u0026#34;type of a:\u0026#34;, reflect.TypeOf(a)) fmt.Println(\u0026#34;value of a:\u0026#34;, reflect.ValueOf(a)) // 傳遞位址 point := reflect.ValueOf(\u0026amp;a) fmt.Printf(\u0026#34;type of value:%T\\n\u0026#34;, point) // reflect.Value // 轉換型別為指標 newA := point.Interface().(*float64) fmt.Printf(\u0026#34;type of newA:%T\\n\u0026#34;, newA) // *float64 } 也就是說反射可以將 \u0026ldquo;反射型別物件\u0026rdquo; 再重新轉換為 \u0026ldquo;介面型別變數\u0026rdquo;\n未知原始資料型別 透過遍歷探尋 Field 獲得\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) type Person struct { // 一行為一個 field Name string Age int Rank float64 } // 注意方法為公有，若私有則無法存取 func (person Person) Sleep() { fmt.Println(\u0026#34;person sleep\u0026#34;) } func main() { p := Person{\u0026#34;zhangSan\u0026#34;, 18, 5.2} getFieldAndMethod(p) } func getFieldAndMethod(input interface{}) { getType := reflect.TypeOf(input) fmt.Println(\u0026#34;type:\u0026#34;, getType.Name()) getValue := reflect.ValueOf(input) fmt.Println(\u0026#34;value/AllField:\u0026#34;, getValue) // 獲取屬性 numField := getValue.NumField() for i := 0; i \u0026lt; numField; i++ { fieldType := getType.Field(i) fieldValue := getValue.Field(i).Interface() fmt.Printf(\u0026#34;%s: %v = %v\\n\u0026#34;, fieldType.Name, fieldType.Type, fieldValue) } // 獲取方法 numMethod := getType.NumMethod() for i := 0; i \u0026lt; numMethod; i++ { method := getType.Method(i) fmt.Printf(\u0026#34;%s: %v\\n\u0026#34;, method.Name, method.Type) } } 透過 reflect.Value 賦值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) func main() { a := 3.14 // 只有是指標時才可賦值 pointer := reflect.ValueOf(\u0026amp;a) // 設置指向該位址，獲取原始值 newValue := pointer.Elem() // 判斷是否可以設置值 fmt.Println(\u0026#34;value canSet:\u0026#34;, newValue.CanSet()) if newValue.CanSet() { // 如果可以設置 newValue.SetFloat(9.96) // 顯示變數值 fmt.Println(\u0026#34;value of a:\u0026#34;, a) // 9.96 } else { fmt.Println(\u0026#34;error\u0026#34;) } } 透過 reflect.Value 呼叫方法 透過函式名稱呼叫\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) type User struct { name string age int } func (user User) MethodHasArgs(a string, b int) { fmt.Println(\u0026#34;User MethodHasArgs\u0026#34;) } func (user User) MethonNotArgs() { fmt.Println(\u0026#34;User MethodNotArgs\u0026#34;) } func main() { user := User{\u0026#34;zhangSan\u0026#34;, 18} value := reflect.ValueOf(user) // 透過函式名稱呼叫 method1 := value.MethodByName(\u0026#34;MethodHasArgs\u0026#34;) // 構建參數 args1 := []reflect.Value{reflect.ValueOf(\u0026#34;string\u0026#34;), reflect.ValueOf(18)} // 呼叫函式 method1.Call(args1) // 無參呼叫 method2 := value.MethodByName(\u0026#34;MethonNotArgs\u0026#34;) args2 := make([]reflect.Value, 0) method2.Call(args2) } 反射的基本原理 ","date":"2024-12-03T14:07:18+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/204/","title":"GoLang 反射"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 問題一： https://blog.yexca.net/zh-tw/archives/198 問題二： https://blog.yexca.net/zh-tw/archives/201 問題三： https://blog.yexca.net/zh-tw/archives/200 問題四： https://blog.yexca.net/zh-tw/archives/202 問題五：此篇文章\n引言 應該快兩週了吧，終於把這份試卷看完了，效率不是普通的低啊。整體來說怎麼說呢，雖然整體難度是比中國 408 的難度低一點，但考試的風格與側重點並不相同，具體來說還是不太好比較。希望下次我的效率可以高一點啊。\n碎碎念 話說最近比較少寫碎碎念了，這其實是因為當我想著要發一篇文章的時候，通常都已經很累了，已經沒有精力寫了。說到這裡就想到以前對於一樣東西從來都只是考慮要不要去學，現在不得不把時間、精力等都算進去了，最近看到的一個梗：\n你就不能一手抓公職考試，一手抓選調，一手抓國考，一手抓省考，一手抓教師證，一手抓留學，一手抓實習，一手抓面試，一手抓轉正，一手抓秋季徵才，一手抓畢業專題，一手抓戀愛？但你還得留一手，因為中國人講究凡事留一手。\n讓我感觸很深，人的精力是有限的，獲得一定收穫的同時，必定會失去一些所得，包括時間、精力、熱情等，這些其實都是可以被量化的變數，只是以前這些變數的上限大於甚至遠大於我的活動，並沒有被發掘而已（當然也可能是透支之類的其他轉換，為了嚴謹加個說明）。隨著年齡的增長，也可以說是經歷或看的事情的增加，慢慢地，越來越多的變數必須被考慮，從而導致我每天都很疲憊且效率低下吧。\n有時候活著很累，可能是我太唯物了，多一點唯心，世界還是比較美好的（我已經不敢對任何事物進行肯定性的描述了，我害怕不確定性，但生活往往沒有確定的事物，雖然這歸因於對變數的不掌握，不多說了，不然又得一大段）。\n背景 考慮一個如圖5.1所示的邏輯電路X，以 $ck$ 為輸入，並輸出 $z_2,z_1,z_0$。這裡，$R_0,R_1,R_2$ 是正緣觸發型（前緣觸發型）D型正反器，初始化時的輸出為0。此外，F是一個邏輯電路，以 $x_2,x_1,x_0$ 為輸入，輸出 $y_2,y_1,y_0$，其構成如圖5.2所示。A和B是圖5.3所示的兩種2輸入閘之一。對電路X的輸入 $ck$ 施加一個以1單位時間為週期的時脈脈衝。以下 $n$ 為正整數，$t$ 為時刻。假設在時刻 $t=0$ 時 $R_0,R_1,R_2$ 已被初始化，且時刻0之後第 $n$ 個時脈脈衝的上升緣所產生的輸出，在時刻 $t=n$ 時穩定地得到 $z_2,z_1,z_0$。此過程如圖5.4所示。此後，電路組成元件（閘、正反器及導線）所造成的延遲，相較於時脈脈衝的週期，足夠小可以忽略不計。\n圖5.1：邏輯電路X 圖5.2：邏輯電路F 圖5.3：2輸入閘 圖5.4：電路X的運作 1 回答以下 a~f 問題。\na）電路F的輸出 $y_2,y_1,y_0$ 僅由輸入 $x_2,x_1,x_0$ 的值決定。執行此類操作的電路名稱，從以下選項中選擇最合適的一項。\n甲　非同步電路\n乙　組合邏輯電路\n丙　循序邏輯電路\n丁　非線性電路\nb）在時刻 $t=n$ 時，電路X的輸出 $z_2,z_1,z_0$ 分別等於時刻 $t=$ 甲 的 $y_2,y_1,y_0$ 值。將甲以 $n$ 的式子表示。\nc）為了使電路X如圖5.4所示般運作，請以圖5.5所示的表格形式完成表示電路F運作的真值表。\n圖5.5：電路F的運作 d）執行如圖5.4所示操作的電路名稱，從以下選項中選擇最合適的一項，並以符號①～④作答。\n① 解碼器 ② 多工器 ③ 計數器 ④ 移位暫存器\ne）為了讓電路X如圖5.4般運作，圖5.2中的A和B應分別填入什麼？從圖5.3中選擇並以符號①～⑥作答。可以使用相同的閘多次。\nf）邏輯變數 $x$ 和 $y$ 的邏輯AND運算以 $xy$ 表示，邏輯OR運算以 $x+y$ 表示，$x$ 的反相（NOT）以 $\\bar{x}$ 表示。電路F的輸出 $y_2$ 為：\n1-解答 1-a 非同步電路是指不使用時脈訊號，各部分獨立運作的電路。 組合邏輯電路是指輸出僅由輸入的當前值決定的電路。 循序邏輯電路是指輸出不僅依賴當前輸入，也依賴內部狀態（例如正反器的輸出）的電路。 非線性電路是指輸入與輸出關係不呈線性的電路。 這題顯然屬於「組合邏輯電路」。\n1-b 因為D型正反器會先接收一個輸入，僅在時脈上升緣觸發時將其放到輸出端。由於狀態更新的同步性，D型正反器會引入一個週期的延遲，所以 甲: $n-1$。\n1-c x_2 x_1 x_0 y_2 y_1 y_0 0 0 0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 1 0 1 1 1 0 0 1 0 0 1 0 1 1 0 1 1 1 0 1 1 0 1 1 1 1 1 1 0 0 0 1-d 解碼器（Decoder）：解碼器是一種將少量輸入訊號解碼為較多輸出訊號的組合邏輯電路。它根據輸入的二進位編碼，啟動對應的輸出線。 多工器（Multiplexer）：多工器是一種從多個輸入訊號中選擇一個訊號輸出的組合邏輯電路。它利用選擇訊號（Select Lines）來決定哪個輸入訊號通過到輸出端。 計數器（Counter）：計數器是一種循序邏輯電路，用於對脈衝訊號進行計數。根據脈衝訊號的個數，計數器的輸出值以特定的方式變化。 移位暫存器（Shift Register）：移位暫存器是一種儲存資料並能按照一定方向移動資料的循序邏輯電路。它由一系列正反器組成。 這題顯然屬於「移位暫存器（Shift Register）」。\n1-e A: ② (OR) B: ① (AND)\n透過真值表及其電路進行分析，因為有多個輸出，可以一個輸出一個輸出地看。由於 $y_0$ 的電路已經決定，首先看 $y_1$ 輸出為 1 時的輸入。\n$x_2$ $x_1$ $x_0$ 0 0 1 0 1 0 1 0 1 1 1 0 分析電路，可以暫時忽略輸入 $x_2$ (從電路或下一問可以知道，簡化後無 $x_2$)。\n然後代入為 1 的輸入進行實驗，得到 A 是 OR 閘，B 是 AND 閘。\n分析 $y_2$ 輸出為 1 時的輸入驗算，結果正確。\n1-f $$ \\begin{align} y_2\u0026=\\bar{x_2}\\bar{x_1}x_0+\\bar{x_2}x_1\\bar{x_0}+x_2\\bar{x_1}x_0+x_2x_1\\bar{x_0} \\\\ \u0026= \\bar{x_2}(\\bar{x_1}x_0+x_1\\bar{x_0})+x_2(\\bar{x_1}x_0+x_1\\bar{x_0}) \\\\ \u0026= \\bar{x_1}x_0+x_1\\bar{x_0} \\end{align} $$2 圖5.6所示的G是一個邏輯電路，以 $x_2,x_1,x_0$ 為輸入，輸出 $y_2,y_1,y_0$。使用G，構成如圖5.7所示的邏輯電路Y，以 $ck$ 為輸入，輸出 $z_2,z_1,z_0$。進一步地，使用Y構成如圖5.8所示的邏輯電路 $X'$。圖5.8中的C和D為圖5.3所示的2輸入閘之一。回答以下 a~e 問題。\n圖5.6：邏輯電路G\n圖5.7：邏輯電路Y\n圖5.8：邏輯電路 $X'$\n圖5.9：電路Y的運作\na）電路G為了得到輸出 $y_0$ 使用了5個閘。請描述一個可以使用圖5.3中列出的2個或更少的閘，來得到與G中 $y_0$ 相同輸出的電路。\nb）對電路Y的輸入 $ck$ 施加一個以1單位時間為週期的時脈脈衝。假設在時刻 $t=0$ 時 $R_0,R_1,R_2$ 已被初始化，且時刻0之後第n個時脈脈衝的上升緣所產生的輸出，在時刻 $t=n$ 時穩定地得到 $z_2,z_1,z_0$。請以圖5.9所示的表格形式完成時刻 $t=1,4,7,12$ 時電路Y的輸出 $z_2,z_1,z_0$。\nc）假設 $m$ 為非負整數。在上述b）所示的條件下，將時刻 $t=m$ 時電路Y的輸出組合 $(z_2,z_1,z_0)$ 視為向量，並表示為 $z(m)$。請回答 $z(m)$ 和 $z(m+1)$ 的漢明距離最大值。\nd）圖5.8的電路X’與圖5.1的電路X表現出同等的行為。此時，請從圖5.3中選擇填入圖5.8中C和D的閘，並以符號①～⑥作答。可以使用相同的閘多次。這裡所稱的「同等行為」是指以下情況：對X’和X各自的輸入 $ck$ 施加一個如圖5.10所示，來自同一脈衝產生源P的1單位時間週期的時脈脈衝。在時刻 $t=0$ 時，X’和X內部的D型正反器被初始化，且時刻0之後第n個時脈脈衝的上升緣所產生的輸出，在時刻 $t=n$ 時，若 $w_2,w_1,w_0$ 和 $z_2,z_1,z_0$ 分別穩定得到，則 $w_2=z_2$ 且 $w_1=z_1$ 且 $w_0=z_0$。\n圖5.10 e）考慮如圖5.11所示的邏輯電路。假設在時刻 $t=t_0$ 時，輸入x和y同時從0變為1。此時預期輸出z會保持0不變，但由於反相器（NOT Gate）的延遲，可能會產生如圖5.12所示的脈衝。此現象稱為毛刺（Glitch，或稱冒險），根據連接的電路，可能會導致誤動作。在圖5.8的電路X’中，如果閘C、D的延遲不能忽略，輸出 $w_0$ 是否可能發生毛刺？請說明，如果可能發生，請提供對策；如果不會發生，請在100字以內說明原因。但假設電路Y的組成元件（閘、正反器及導線）的延遲可以忽略，且 $R_0,R_1,R_2$ 各自的輸出會同時變化。\n圖5.11：可能產生毛刺的邏輯電路範例\n圖5.12：毛刺範例\n2-解答 2-a 分析電路可知 $y_0=x_1x_2+\\bar{x_1}\\bar{x_2}$，等價於 $x_1\\ \\text{XNOR}\\ x_2$，因此可以直接使用一個 XNOR 閘來簡化電路。\n只能使用⑥。\n2-b t $x_0$ $x_1$ $x_2$ $y_0$ $y_1$ $y_2$ 0 0 0 0 1 0 0 1 1 0 0 1 1 0 2 1 1 0 0 1 0 3 0 1 0 0 1 1 4 0 1 1 1 1 1 5 1 1 1 1 0 1 6 1 0 1 0 0 1 7 0 0 1 0 0 0 8 0 0 0 1 0 0 9 1 0 0 1 1 0 10 1 1 0 0 1 0 11 0 1 0 0 1 1 12 0 1 1 1 1 1 可以看到從 $t=7$ 開始循環。\n2-c 漢明距離表示兩個相同長度的二進位向量中，不同位元的數量。\n從上一題的真值表來看，最大為 1。\n2-d C: ③ (XOR) D: ③ (XOR)\n分析兩個電路的時刻表，可以得到真值表。\n$z_0$ $z_1$ $z_2$ $w_0$ $w_1$ $w_2$ 1 0 0 1 0 0 1 1 0 0 1 0 0 1 0 1 1 0 0 1 1 0 0 1 1 1 1 1 0 1 1 0 1 0 1 1 0 0 1 1 1 1 0 0 0 0 0 0 分析電路，可以先看 $w_1$，尋找使 $w_1$ 為 1 的輸入。\n$z_0$ $z_1$ $z_2$ 1 1 0 0 1 0 1 0 1 0 0 1 從電路可知可以忽略 $z_0$，剩下的 $z_1$ 和 $z_2$ 呈現出不同輸出為 1 的情況，也就是互斥或閘（XOR Gate）的形式，即 D 為互斥或閘。\n分析 $w_0$ 為 1 的輸入。\n$z_0$ $z_1$ $z_2$ $z_1 \\oplus z_2$ 1 0 0 0 0 1 0 1 1 1 1 0 0 0 1 1 從電路可知，可以直接觀察 $z_0$ 和 $z_1 \\oplus z_2$，呈現出不同輸出為 1 的情況，也就是互斥或閘（XOR Gate）的形式，即 C 為互斥或閘。\n2-e $w_0$ 有可能發生毛刺。對策包括在輸出端加入緩衝器，或加入同步正反器，抑或是重新檢視電路設計。\n參考文章 布林代數的簡化（公式法與卡諾圖法） ","date":"2024-12-01T18:15:28+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/203/","title":"東京科學大學研究所資訊理工學院 2020 問題五 / 科学大院理工学 2020 問題五"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 問題一： https://blog.yexca.net/zh-tw/archives/198 問題二： https://blog.yexca.net/zh-tw/archives/201 問題三： https://blog.yexca.net/zh-tw/archives/200 問題四：この文章\n問題五： https://blog.yexca.net/zh-tw/archives/203 引言 整題都在考拉普拉斯轉換，同時最後一題是應用。如果不知道拉普拉斯轉換會比較難快速解題，雖然速度快的話可以做出前兩大題以及第三題的前三小題 (其實也很多了)，對於最後兩小題則屬於不知道相關原理便不會做了 (我在最後一小題寫了不知道相關情況如何解題，但考場那種情況下真的可以反應過來嗎？)\n題目版權屬於東京科學大學所有，僅為了方便觀看而引用，無盈利行為\n背景 実数 $t(\\ge0)$ を変数とする2回微分可能な実関数 $f(t)$ のラプラス変換 $F(S)=\\mathcal{L}[f(t)]$ を次式で定義する。\n$$ F(s)=\\mathcal{L}[f(t)]=\\int_0^\\infty f(t)e^{-st}dt \\tag{4.1} $$ここで、ｓは複素変数で、かつ実部が正であるとする。以下の問いに答えよ。なお、解答にあたって、次のラプラス変換に関する関係式を用いてもよい。\n$$ \\mathcal{L}[e^{-\\alpha t}f(t)] = F(s+\\alpha) \\tag{4.2} $$$$ \\mathcal{L}[\\frac{\\mathrm{d}}{\\mathrm{d}t}f(t)] = sF(s) - f(0) \\tag{4.3} $$$$ \\mathcal{L}[\\frac{\\mathrm{d}^2}{\\mathrm{d}t^2}f(t)] = s^2F(s)-sf(0)-f'(0) \\tag{4.4} $$ただし、$\\alpha$ は実定数とし、$f'(t)=\\frac{\\mathrm{d}}{\\mathrm{d}t}f(t)$ とする。\n這一段描述了拉普拉斯轉換的定義以及三條性質\n1 以下の a~c の式が成り立つことを示せ。ただし、$\\alpha$ は実定数、$\\beta$ は０ではない実定数とする。\na）$\\mathcal{L}[\\cos(\\beta t)]=\\dfrac{s}{s^2+\\beta^2}$\nb）$\\mathcal{L}[e^{-\\alpha t}\\cos(\\beta t)] = \\dfrac{s+\\alpha}{(s+a)^2+\\beta^2}$\nc）$\\mathcal{L}[e^{-\\alpha t}\\sin(\\beta t)]=\\dfrac{\\beta}{(s+a)^2+\\beta^2}$\n解答 a 代入定義\n$$ \\mathcal{L}[\\cos(\\beta t)] = \\int_0^\\infty \\cos(\\beta t)e^{-3t}\\mathrm{d}t $$這裡使用尤拉公式\n$$ e^{i\\theta}=\\cos\\theta + i\\sin\\theta $$的推論\n$$ \\cos\\theta=\\frac{e^{i\\theta}+e^{-i\\theta}}{2} $$ 證明很簡單，直接代入\n$$ \u003e\\begin{align} \u003e\\cos\\theta \u003e\u0026= \\frac{e^{i\\theta}+e^{-i\\theta}}{2} \\\\ \u003e\u0026= \\frac{(\\cos\\theta + i\\sin\\theta)+(\\cos(-\\theta) + i\\sin(-\\theta))}{2} \\\\ \u003e\u0026= \\frac{(\\cos\\theta + i\\sin\\theta)+(\\cos\\theta - i\\sin\\theta)}{2} \\\\ \u003e\u0026= \\frac{2\\cos\\theta }{2} \\\\ \u003e\u0026= \\cos\\theta \u003e\\end{align} \u003e$$ 代入原式，得\n$$ \\begin{align} \\mathcal{L}[\\cos(\\beta t)] \u0026=\\int_0^\\infty\\frac{e^{i\\beta t}+e^{-i\\beta t}}{2}e^{-st}\\mathrm{d}t \\\\ \u0026= \\frac{1}{2}(\\int_0^\\infty e^{i\\beta t} \\cdot e^{-st}\\mathrm{d}t+\\int_0^\\infty e^{-i\\beta t} \\cdot e^{-st}\\mathrm{d}t) \\\\ \u0026= \\frac{1}{2}(\\int_0^\\infty e^{-(i\\beta t + st)}\\mathrm{d}t + \\frac{1}{2}(\\int_0^\\infty e^{-(i\\beta t + st)}\\mathrm{d}t) \\end{align} $$求積分得\n$$ \\begin{align} \\mathcal{L}[\\cos(\\beta t)] \u0026= \\frac{1}{2}(\\frac{1}{s-i\\beta}+\\frac{1}{s+i\\beta}) \\end{align} $$ 此處積分過程\n$$ \u003e\\begin{align} \u003e\\int_0^\\infty e^{-at}\\mathrm{d}t \u003e\u0026= \\frac{1}{-a}e^{-at}\\mid_0^\\infty \\\\ \u003e\u0026= 0-\\frac{1}{-a} \\\\ \u003e\u0026= \\frac{1}{a} \u003e\\end{align} \u003e$$ 通分簡化，得\n$$ \\begin{align} \\mathcal{L}[\\cos(\\beta t)] \u0026= \\frac{1}{2} \\cdot \\frac{s+i\\beta+s-i\\beta}{(s-i\\beta)(s+i\\beta)} \\\\ \u0026= \\dfrac{s}{s^2+\\beta^2} \\end{align} $$原命題得證\nb 由 $(4.2)$ 得知\n$$ \\mathcal{L}[e^{-\\alpha t}f(t)] = F(s+\\alpha) $$又由第一小題得知\n$$ \\mathcal{L}[\\cos(\\beta t)]=\\dfrac{s}{s^2+\\beta^2} $$所以\n$$ \\mathcal{L}[e^{-\\alpha t}\\cos(\\beta t)] = \\dfrac{s+\\alpha}{(s+a)^2+\\beta^2} $$原命題得證\nc 因為\n$$ \\frac{\\mathrm{d}}{\\mathrm{d}t}\\sin(\\beta t) = \\beta \\cos(\\beta t) $$兩邊同時進行拉普拉斯轉換\n$$ \\mathcal{L}[\\frac{\\mathrm{d}}{\\mathrm{d}t}\\sin(\\beta t)] = \\mathcal{L}[\\beta \\cos(\\beta t)] $$由 $(4.3)$ 得知\n$$ \\mathcal{L}[\\frac{\\mathrm{d}}{\\mathrm{d}t}f(t)] = sF(s) - f(0) $$所以\n$$ \\mathcal{L}[\\frac{\\mathrm{d}}{\\mathrm{d}t}\\sin(\\beta t)] = sF(s)-\\sin(0)=sF(s) $$即\n$$ sF(s) = \\mathcal{L}[\\beta \\cos(\\beta t)] = \\beta \\mathcal{L}[\\cos(\\beta t)] $$由第一小題，得知\n$$ \\mathcal{L}[\\cos(\\beta t)]=\\dfrac{s}{s^2+\\beta^2} $$代入，得\n$$ sF(s) = \\beta \\dfrac{s}{s^2+\\beta^2} $$解得\n$$ F(s) = \\dfrac{\\beta}{s^2+\\beta^2} $$所以\n$$ \\mathcal{L}[\\sin(\\beta t)] = \\dfrac{\\beta}{s^2+\\beta^2} $$ 寫完回想時，最初我用的一個簡單方法是可以用的，只是我想錯了，這個比較簡單點，但是上面的感覺看起來很帥，所以保留了。接下來簡單描述一下\n$$ \u003e \\begin{align} \u003e \\mathcal{L}[\\frac{\\mathrm{d}}{\\mathrm{d}t}\\cos(\\beta t)] \u003e \u0026= \\mathcal{L}[-\\beta\\sin(\\beta t)]\\\\ \u003e \u0026= -\\beta \\mathcal{L}[\\sin(\\beta t)]\\\\ \u003e \u0026= sF(s) - \\cos(0) \\\\ \u003e \u0026= \\dfrac{s^2}{s^2+\\beta^2} - 1 \\\\ \u003e \u0026= \\dfrac{-\\beta^2}{s^2+\\beta^2} \u003e \\end{align} \u003e $$即\n$$ \u003e \\mathcal{L}[\\sin(\\beta t)] = \\dfrac{\\beta}{s^2+\\beta^2} \u003e $$幾乎相當於三種方法解出來 (還有一種和 a 題一樣直接算)，做出來的時候太爽了\n由 $(4.2)$ 得知\n$$ \\mathcal{L}[e^{-\\alpha t}f(t)] = F(s+\\alpha) $$所以\n$$ \\mathcal{L}[e^{-\\alpha t}\\sin(\\beta t)]=\\dfrac{\\beta}{(s+a)^2+\\beta^2} $$2 次の微分方程式について、以下の a~d に答えよ。\n$$ \\frac{\\mathrm{d}^2}{\\mathrm{d}t^2}f(t) + \\eta \\frac{\\mathrm{d}}{\\mathrm{d}t}f(t) + 2f(t) = 2 \\tag{4.5} $$ここで、$\\eta$ は実定数、$f(t)$ は実数 $t(\\ge 0)$ を変数とする2回微分可能な実関数とし、初期条件を $f(0)=1, f'(0)=1$ とする。ただし、$f'(t)=\\frac{\\mathrm{d}}{\\mathrm{d}t}f(t), F(s)=\\mathcal{L}[f(t)]$ とする。\na）微分方程式 $(4.5)$ の両辺をラプラス変換し、$F(s)$ を $s$ の関数として表せ。\nb）$\\eta=0$ のとき、ラプラス変換を用いて微分方程式 $(4.5)$ を解き、$f(t)$ を $t$ の関数として表せ。\nc）$\\eta=2$ のとき、ラプラス変換を用いて微分方程式 $(4.5)$ を解き、$f(t)$ を $t$ の関数として表せ。\nd）$\\eta=2$ のとき、$\\lim_{t \\to \\infty}f(x)$ の値を求め、$f(t)$ のグラフの概形を描け。\n解答 a 根據 $(4.3), (4.4)$ 兩邊取拉普拉斯轉換，得\n$$ s^2F(s)-sf(0)-f'(0)+\\eta(sF(s)-f(0))+2F(s)=\\frac{2}{s} $$整理，得\n$$ (s^2+\\eta s+2)F(s) = \\frac{2}{s}+s+\\eta+1 $$所以\n$$ F(s)=\\frac{\\frac{2}{s}+s+\\eta+1}{s^2+\\eta s +2} $$b 將 $\\eta=0$ 代入，得\n$$ \\begin{align} F(s)\u0026=\\frac{\\frac{2}{s}+s+1}{s^2+2} \\\\ \u0026=\\frac{s^2+s+2}{s(s^2+2)} \\end{align} $$設\n$$ \\frac{s^2+s+2}{s(s^2+2)} = \\frac{A}{s} + \\frac{Bs+C}{s^2+2} = \\frac{A(s^2+2)+s(Bs+C)}{s(s^2+2)} $$得\n$$ \\left \\{ \\begin{align} A+B = 1 \\\\ C = 1 \\\\ 2A = 2 \\end{align} \\right . $$解得 $A=1, B=0, C=1$，代入得\n$$ F(s) = \\frac{1}{s} + \\frac{1}{s^2+2} $$逆拉普拉斯轉換得\n$$ f(t) = 1 + \\frac{1}{\\sqrt{2}}\\sin(\\sqrt{2}t) $$c 將 $\\eta=2$ 代入，得\n$$ F(s)=\\frac{\\frac{2}{s}+s+3}{s^2+2s +2} = \\frac{2+s^2+3s}{s(s^2+2s +2)} $$設\n$$ \\frac{2+s^2+3s}{s(s^2+2s +2)} = \\frac{A}{s} + \\frac{Bs+C}{s^2+2s +2} = \\frac{A(s^2+2s+2)+s(Bs+C)}{s(s^2+2s +2)} $$得\n$$ \\left \\{ \\begin{align} A+B = 1 \\\\ 2A+C = 3 \\\\ 2A = 2 \\end{align} \\right . $$解得 $A=1, B=0, C=1$，所以\n$$ F(s) = \\frac{1}{s} + \\frac{1}{s^2+2s+2} = \\frac{1}{s} + \\frac{1}{(s+1)^2+1} $$逆拉普拉斯轉換得\n$$ f(t) = 1 + e^{-t}\\sin t $$d 由 c 可知，$\\eta=2$ 時\n$$ f(t) = 1 + e^{-t}\\sin t $$即\n$$ \\lim_{t \\to \\infty} f(t) = \\lim_{t \\to \\infty} (1 + e^{-t}\\sin t) = 1 $$因為\n$$ f(0) = 1+e^0\\sin0 = 1 $$所以 $f(t)$ 的圖形大概為從 1 開始，振盪衰減並最終穩定在 1 的趨勢\n振動しながら $t \\to \\infty$ において1に収束します。（これは減衰振動の典型的な形状です）\n具體圖像如下\n程式碼如下 (因為使用 Linux 無 GUI 環境，多加了幾行儲存圖片的程式碼)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 import matplotlib as mpl # 顯示圖像 import numpy as np import matplotlib.pyplot as plt mpl.use(\u0026#39;Agg\u0026#39;) # 顯示圖像 # 定義函數 f(t) = 1 + e^(-t) * sin(t) t = np.linspace(0, 10, 1000) # 時間範圍 [0, 10] f_t = 1 + np.exp(-t) * np.sin(t) # 繪製圖形 plt.figure(figsize=(8, 5)) plt.plot(t, f_t, label=r\u0026#34;$f(t) = 1 + e^{-t}\\sin(t)$\u0026#34;, color=\u0026#39;b\u0026#39;) plt.axhline(y=1, color=\u0026#39;r\u0026#39;, linestyle=\u0026#39;--\u0026#39;, label=r\u0026#34;$f(t) \\to 1$ (limit value)\u0026#34;) # 圖形美化 plt.title(r\u0026#34;Function $f(t) = 1 + e^{-t}\\sin(t)$\u0026#34;, fontsize=14) plt.xlabel(\u0026#34;$t$\u0026#34;, fontsize=12) plt.ylabel(\u0026#34;$f(t)$\u0026#34;, fontsize=12) plt.legend(fontsize=10) plt.grid(alpha=0.3) plt.tight_layout() # 顯示圖形 plt.show() # 儲存圖像 plt.savefig(\u0026#34;./1.png\u0026#34;) 3 図４.１に示した1自由度のバネ-質量-ダンパ系の微分方程式は次式で表せる。\n$$ m\\frac{\\mathrm{d}^2}{\\mathrm{d}t^2}x(t)+\\mu \\frac{\\mathrm{d}}{\\mathrm{d}t}x(t)+kx(t)=p(t) \\tag{4.6} $$ただし、位置 $x(t)$ および外力 $p(t)$ は時刻 $t(\\ge 2)$ の2回微分可能な実関数である。位置 $x(t)$ の原点はバネの自然長の位置とし、位置 $x(t)$ と外力 $p(t)$ の正の方向はバネガ伸びる方向とする。質量 $m$、バネ定数 $k$、ダンバの粘性減衰係数 $\\mu$ は正の定数とする。以下では、式 $(4.6)$ の係数の書き換えによって得られた次式を用いて考える。\n$$ \\frac{\\mathrm{d}^2}{\\mathrm{d}t^2}x(t)+2\\gamma\\omega_0\\frac{\\mathrm{d}}{\\mathrm{d}t}x(t)+w_0^2x(t)=q(t) \\tag{4.7} $$ただし、$\\omega_0=\\sqrt{k/m}, \\gamma=\\mu/(2\\sqrt{mk}),q(t)=p(t)/m$ と定義した。また、$X(s)=\\mathcal{L}[x(t)], Q(s)=\\mathcal{L}[q(t)]$ とする。初期条件を $x(0)=0, x'(0)=0$ とする。$x'(t)=\\frac{\\mathrm{d}}{\\mathrm{d}t}x(t)$ である。このとき、以下の a~e に答えよ。\n図４.１：1自由度のバネ-質量-ダンパ系 a）式 $(4.7)$ の両辺をラプラス変換して、伝達関数 $H(s)=X(s)/Q(s)$ を計算し、$H(s)$ を $\\gamma, \\omega_0$ を用いて $s$ の関数として表せ。\nb）伝達関数 $H(s)$ において、$s$ を $i\\omega$ に置き換えることにより、$Y(\\omega)=20\\log_{10}\\mid H(i\\omega)\\mid$ を計算し、$Y(\\omega)$ を $\\omega$ の実関数として表せ。ただし、$\\omega$ は正の実数、$i$ は虚数単位とする。\nc）$Y(\\omega)$ が最大となるときの $\\omega$ の値を $\\hat{\\omega}$ とする。$\\hat{\\omega}$ を $\\gamma, \\omega_0$ を用いて表せ\nd）$Y(\\omega)$ が $\\omega=\\hat{\\omega}$ で最大になるという現象は何と呼ばれるか、答えよ。\ne）d の現象が起こる $\\gamma$ の範囲を答えよ。\n解答 a 兩邊同時進行拉普拉斯轉換\n$$ \\mathcal{L}[\\frac{\\mathrm{d}^2}{\\mathrm{d}t^2}x(t)]+2\\gamma\\omega_0\\mathcal{L}[\\frac{\\mathrm{d}}{\\mathrm{d}t}x(t)]+w_0^2\\mathcal{L}[x(t)]=\\mathcal{L}[q(t)] $$由 $(4.3),(4.4)$ 即題意，得\n$$ s^2X(s) + 2\\gamma\\omega_0sX(s) + \\omega_0^2X(s) = Q(s) $$兩邊同時除以 $Q(S)$，得\n$$ s^2H(s) + 2\\gamma\\omega_0sH(s) + \\omega_0^2H(s) = 1 $$所以\n$$ H(s) = \\frac{1}{s^2+2\\gamma\\omega_0s+\\omega_0^2} $$b 將 $i\\omega$ 代入 $H(s)$ 得\n$$ \\begin{align} H(i\\omega) \u0026= \\frac{1}{-\\omega^2+2i\\gamma\\omega_0\\omega + \\omega_0^2} \\\\ \u0026= \\frac{1}{\\omega_0^2-\\omega^2+2i\\gamma\\omega_0\\omega} \\end{align} $$所以\n$$ \\mid H(i\\omega) \\mid = \\frac{1}{\\sqrt{(\\omega_0^2-\\omega^2)^2+(2\\gamma\\omega_0\\omega)^2}} $$由此可得\n$$ \\begin{align} Y(\\omega) \u0026= 20\\log_{10}\\mid H(i\\omega) \\mid \\\\ \u0026= 20\\log_{10} \\frac{1}{\\sqrt{(\\omega_0^2-\\omega^2)^2+(2\\gamma\\omega_0\\omega)^2}} \\\\ \u0026= 20(\\log_{10}1-\\log_{10}\\sqrt{(\\omega_0^2-\\omega^2)^2+(2\\gamma\\omega_0\\omega)^2}) \\\\ \u0026= -20\\log_{10}\\sqrt{(\\omega_0^2-\\omega^2)^2+(2\\gamma\\omega_0\\omega)^2} \\\\ \u0026= -10\\log_{10}[(\\omega_0^2-\\omega^2)^2+(2\\gamma\\omega_0\\omega)^2] \\end{align} $$c $Y(\\omega)$ 最大的時候 $(\\omega_0^2-\\omega^2)^2+(2\\gamma\\omega_0\\omega)^2$ 最小，對其求導\n$$ \\begin{align} (\\omega_0^2-\\omega^2)^2+(2\\gamma\\omega_0\\omega)^2 \u0026= 2(\\omega_0^2-\\omega^2)\\times(-2\\omega) + 2(2\\gamma\\omega_0\\omega)\\times(2\\gamma\\omega_0) \\\\ \u0026= 4\\omega(\\omega^2-\\omega_0^2) + 4(2\\gamma^2\\omega_0^2w) \\\\ \u0026= 4\\omega(\\omega^2-\\omega_0^2+\\gamma^2\\omega_0^2) \\end{align} $$令其為 $0$，得\n$$ 4w = 0 $$或\n$$ \\omega^2-\\omega_0^2+\\gamma^2\\omega_0^2 = 0 $$即\n$$ w^2=\\omega_0^2-2\\gamma^2\\omega_0^2 $$又因為 $\\omega$ 為正實數，所以\n$$ \\hat{\\omega} = \\omega_0\\sqrt{1-2\\gamma^2} $$d 共振現象です\n共振現象指的是當系統受到的外力頻率接近系統的自然頻率時，系統的響應幅度達到最大的一種現象\ne 由 $\\hat{\\omega}$ 是正實數，得\n$$ 1-2\\gamma^2 \\gt 0 $$即\n$$ $-\\frac{1}{\\sqrt{2}} \\lt \\gamma \\lt \\frac{1}{\\sqrt{2}}$ $$又因為 $\\mu \\gt 0$，得\n$$ 0 \\lt \\gamma \\lt \\frac{1}{\\sqrt{2}} $$Reference 尤拉公式 latex 中的拉普拉斯轉換符號代碼 https://blog.csdn.net/ydyang1126/article/details/77247654 拉普拉斯轉換與逆拉普拉斯轉換的常用結論與經典公式 ","date":"2024-11-28T15:51:16+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/202/","title":"東京科學大學研究所情報理工學院 2020 問題四 / 科學大院理工學 2020 問題四"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 問題一： https://blog.yexca.net/zh-tw/archives/198 問題二：本文\n問題三： https://blog.yexca.net/zh-tw/archives/200 問題四： https://blog.yexca.net/zh-tw/archives/202 問題五： https://blog.yexca.net/zh-tw/archives/203 引言 這一大題剛看的時候還以為屬於形式語言（與自動機理論）呢，實際上動手做題後發現是數理邏輯的內容 (兩者都沒學過，也都一樣)\n總體的難度並非特別高 (可能是因為做過東大試卷吧，看這裡的題目都不太難) 但還是需要掌握較多的理論基礎才能解出。\n題目版權屬於東京科學大學所有，僅為了方便閱讀而引用，無營利行為。\n1 考慮命題邏輯。命題 $\\varphi$ 為 $(\\neg p_0 \\to \\neg p_1) \\wedge (\\neg p_1 \\to p_0)$。其中，$p_0, p_1$ 為命題記號。\na）請回答填入下表（ア）～（エ）的值，使之成為 $\\varphi$ 的真值表。其中，1 代表真，0 代表偽。\n$p_0$ $p_1$ $\\varphi$ 0 0 （ア） 0 1 （イ） 1 0 （ウ） 1 1 （エ） b）回答命題 $\\varphi$ 是否為恆真式（Tautology）。\nc）回答命題 $\\varphi$ 是否為可滿足的（Satisfiable）。\n1-a 首先，整理命題 $\\varphi$：\n$$ \\begin{align} \\varphi \u0026= (\\neg p_0 \\to \\neg p_1) \\wedge (\\neg p_1 \\to p_0) \\\\ \u0026= (p_0 \\vee \\neg p_1) \\wedge (p_1 \\vee p_0) \\end{align} $$由此得：\n$p_0$ $p_1$ $\\varphi$ 0 0 0 0 1 0 1 0 1 1 1 1 因此，（ア）：0、（イ）：0、（ウ）：1、（エ）：1。\n1-b 由於存在 $\\varphi=0$ 的情況，因此並非恆真命題。\n1-c 由於存在 $\\varphi=1$ 的情況，因此是可滿足的。\n2 考慮命題邏輯的自然演繹。$p_1, p_2, p_3$ 為命題記號，$\\wedge I$ 為連言導入規則，$\\wedge E_L$ 為連言除去規則（左），$\\wedge E_R$ 為連言除去規則（右），$\\to E$ 為蘊涵除去規則。\na）假設為 $(p_1 \\wedge p_2) \\wedge p_3$，結論為 $p_1 \\wedge (p_2 \\wedge p_3)$，欲完成下方的自然演繹導出（證明圖）。請回答填入（ア）～（オ）的命題。\n$$ \\cfrac{ \\cfrac{ \\cfrac{(p_1 \\wedge p_2)\\wedge p_3}{(ア)}\\wedge E_L }{p_1}\\wedge E_L \\quad \\cfrac{ \\cfrac{ \\cfrac{(p_1 \\wedge p_2) \\wedge p_3}{(イ)}\\wedge E_L }{(ウ)}\\wedge E_R \\quad \\cfrac{(p_1 \\wedge p_2) \\wedge p_3}{(エ)}\\wedge E_R }{(オ)}\\wedge I }{p_1 \\wedge (p_2 \\wedge p_3)}\\wedge I $$b）假設為 $p_1 \\wedge p_2$ 與 $p_1 \\to (p_2 \\to p_3)$，結論為 $p_3$，欲完成下方的自然演繹導出（證明圖）。請回答填入（ア）～（エ）的命題。\n$$ \\cfrac{ \\cfrac{(ア)}{p_2}\\wedge E_R \\quad \\cfrac{ \\cfrac{(イ)}{p_1}\\wedge E_L \\quad (ウ) }{(エ)}\\to E }{p_3}\\to E $$c）回答命題集合 $\\{ \\neg p_0 \\to \\neg p_1, \\neg p_1 \\to p_0 \\}$ 是矛盾還是無矛盾（一致），並說明理由。\n2-解答 如果能理解題目給出的幾個符號，前兩小題其實相當容易。\n$\\wedge I$ 是連言導入規則，即將 $A$ 和 $B$ 變為 $A \\wedge B$。\n$\\wedge E_L$ 是連言除去規則，保留左側，即將 $A \\wedge B$ 變為 $A$。\n$\\wedge E_R$ 是連言除去規則，保留右側，即將 $A \\wedge B$ 變為 $B$。\n$\\to E$ 是蘊涵除去規則，即將 $A$ 和 $A \\to B$ 變為 $B$。\n2-a ア: $p_1 \\wedge p_2$ イ: $p_1 \\wedge p_2$ ウ: $p_2$ エ: $p_3$ オ: $p_2 \\wedge p_3$ $$ \\cfrac{ \\cfrac{ \\cfrac{(p_1 \\wedge p_2)\\wedge p_3}{p_1 \\wedge p_2}\\wedge E_L }{p_1}\\wedge E_L \\quad \\cfrac{ \\cfrac{ \\cfrac{(p_1 \\wedge p_2) \\wedge p_3}{p_1 \\wedge p_2}\\wedge E_L }{p_2}\\wedge E_R \\quad \\cfrac{(p_1 \\wedge p_2) \\wedge p_3}{p_3}\\wedge E_R }{p_2 \\wedge p_3}\\wedge I }{p_1 \\wedge (p_2 \\wedge p_3)}\\wedge I $$2-b ア: $p_1 \\wedge p_2$ イ: $p_1 \\wedge p_2$ ウ: $p_1 \\to (p_2 \\to p_3)$ エ: $p_2 \\to p_3$ $$ \\cfrac{ \\cfrac{p_1 \\wedge p_2}{p_2}\\wedge E_R \\quad \\cfrac{ \\cfrac{p_1 \\wedge p_2}{p_1}\\wedge E_L \\quad p_1 \\to (p_2 \\to p_3) }{p_2 \\to p_3}\\to E }{p_3}\\to E $$2-c 是無矛盾的。整理命題：\n$$ \\neg p_0 \\to \\neg p_1 \\equiv p_0 \\vee \\neg p_1 \\\\ \\neg p_1 \\to p_0 \\equiv p_1 \\vee p_0 $$建立真值表：\n$p_0$ $p_1$ $\\neg p_0 \\to \\neg p_1$ $\\neg p_1 \\to p_0$ 0 0 1 0 0 1 0 1 1 0 1 1 1 1 1 1 當 $p_0=1, p_1=0$ 或 $p_0=1, p_1=1$ 時，兩個命題皆成立。\n由於至少存在一種真值分配使得命題集合成立，因此命題集合 $\\{ \\neg p_0 \\to \\neg p_1, \\neg p_1 \\to p_0 \\}$ 是無矛盾的。\n3 考慮一階述詞邏輯。\na）以下論理式的模型是否存在？若存在，請回答該模型宇集（Universe）基數的最小值。若不存在，請說明理由。\n$$ \\exists x \\exists y \\exists z \\space \\neg(x=y) \\wedge \\neg(y=z) \\wedge \\neg(z=x) $$b）以下論理式的模型是否存在？若存在，請列舉一個模型。若不存在，請說明理由。\n$$ \\exists x \\forall y(x=y) $$ 3-a 此論理式的模型存在。其模型宇集基數的最小值為 3。\n3-b 此論理式的模型存在。例如，設定宇集 $U=\\{a\\}$。在此情況下，由於 $U$ 的所有元素都與 $x$ 相等，因此論理式成立。\n4 考慮一階述詞邏輯的自然演繹。請回答以下式子是否成立，並說明理由。其中，$P$ 為二元述詞符號。\n$$ \\vdash (\\forall x \\exists y P(x,y)) \\to \\exists x \\forall y P(x,y) $$ 4-解答 此式不成立。反例如下：\n定義宇集為 $\\{ m,n,a,b \\}$。此時，給予述詞 $P(x,y)$ 的解釋如下：\n$$ P(m,a) = 真 \\quad P(a,m) = 偽 \\\\ P(n,b) = 真 \\quad P(b,n) = 偽 $$由此，$\\forall x \\exists y P(x,y)$ 成立。然而，$\\exists x \\forall y P(x,y)$ 並不成立。\n參考資料 自然演繹 命題論理 演繹定理 充足可能性問題 ","date":"2024-11-24T22:42:18+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/201/","title":"東京科學大學研究所情報理工學院 2020 題目二"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 問題一： https://blog.yexca.net/zh-tw/archives/198 問題二： https://blog.yexca.net/zh-tw/archives/201 問題三：這篇文章\n問題四： https://blog.yexca.net/zh-tw/archives/202 問題五： https://blog.yexca.net/zh-tw/archives/203 前言 這份考題是演算法題目，初次看到時，有種要放棄治療的感覺，但在做過一遍之後，會覺得難度沒有想像中大，但需要對既有演算法有較高的理解力。之所以說難度沒有想像中大，可能與我心中的預期有關吧，因為我以為可能要設計什麼演算法吧 (我想表達的意思是我並不覺得這份題目簡單)\n本考題版權為東京科學大學所有，僅為方便觀看而引用，無任何營利行為\n1 以兩種不同的演算法，使用 C 語言實作了將包含 n 個元素的整數陣列 a 依遞增順序排列的處理。請從選項中選出最適合填入程式 3.1、3.2 標題 A、B 的演算法名稱，並回答其符號。\n「選項」\n甲、選擇排序\n乙、氣泡排序\n丙、快速排序\n丁、插入排序\n程式 3.1：A 1 2 3 4 5 6 7 8 9 10 11 12 13 void sort_a(int a[], int n) { int i, j, tmp; for(i=0; i\u0026lt;n-1; ++i){ for(j=n-1; i\u0026lt;j; --j){ if(a[j]\u0026lt;a[j-1]){ tmp=a[j]; a[j]=a[j-1]; a[j-1]=tmp; } } } } 程式 3.2：B 1 2 3 4 5 6 7 8 9 10 11 12 13 void sort_b(int a[], int n) { int i, j, tmp; for(j=1; j\u0026lt;n; ++j){ tmp=a[j]; i=j-1; while(0\u0026lt;=i \u0026amp;\u0026amp; tmp\u0026lt;a[i]){ a[i+1]=a[i]; --i; } a[i+1]=tmp; } } 答案\n這份題目是針對兩種排序演算法的程式碼，判斷其使用了哪種排序方法。A 是氣泡排序 (乙、氣泡排序)，B 是插入排序 (丁、插入排序)\n2 關於堆積排序 (Heap Sort)，請回答下列問題。不過，n 為正整數。\na）請說明在二元堆積中，除了根節點以外的任何節點值應滿足的條件 (最大堆積條件或最小堆積條件皆可)。\nb）當二元堆積儲存 n 個元素時，請以 n 的算式表示其樹高。樹高定義為根節點與葉節點之間路徑長度的最大值。\nc）使用堆積排序法排列 n 個元素時，請從以下選項中分別選出其平均時間複雜度和最差時間複雜度的漸近評估最適合的答案。\n甲、$O(1)$\n乙、$O(\\log n)$\n丙、$O(n)$\n丁、$O(n\\log n)$\n戊、$O(n^2)$\n這份題目考堆積排序，第一小題要求寫出除了根節點以外的任何節點值應滿足的條件 (二元樹大頂堆或小頂堆擇一即可)；第二小題是寫出所構成的堆積二元樹的高度；第三小題則是選擇平均時間複雜度和最差情況複雜度。\n答案\na\n最大堆積條件：除了根節點以外的任何節點值，都必須小於或等於其父節點的值。 最小堆積條件：除了根節點以外的任何節點值，都必須大於或等於其父節點的值。 b\n$$ \\left \\lfloor \\log_2n \\right \\rfloor $$c\n平均時間複雜度和最差時間複雜度：丁、$O(n\\log n)$\n3 設 $A=\\{ A[0], A[1], \\cdots, A[n-1] \\}$ 為包含 n 個相異整數的陣列。對於小於 n 的非負整數 $i,j$，若 $i\\lt j$ 且 $A[i]\\gt A[j]$，則稱 $(i,j)$ 為 A 的反轉對，A 的反轉對數量則稱為 A 的反轉數。例如，陣列 $\\{ 5,7,4,6 \\}$ 的反轉對為 $(0,2),(1,2),(1,3)$，反轉數為 3。請回答下列問題。\na）請找出陣列 $\\{ 1,0,4,3,2, \\}$ 的反轉數。\nb）在將集合 $\\{ 1,2,\\cdots,n \\}$ 的所有元素排列而成的陣列 (元素數量為 n 個) 中，請指出反轉數最大的排列方式。此外，請以 n 的算式表示其反轉數。\nc）使用氣泡排序法將集合 $\\{ 1,2,\\cdots,n \\}$ 的所有元素排列而成的任意陣列 B (元素數量為 n 個) 依遞增順序排列。此時，「氣泡排序法中的 X 與陣列 B 的反轉數相等」的關係成立。請回答填入 X 的適當詞語，並簡潔地說明該關係成立的理由。\n這份題目首先引入了「逆序」的概念 ( 宋浩老師的線性代數課程 有提到)，第一小題要求找出逆序數；第二小題要求找出最大逆序數；第三小題則是寫出氣泡排序法中的什麼與逆序數相等，並說明理由。\n答案\na 反轉數為 4，分別為 (1,0), (4,3), (4,2), (3,2)\nb 最大的反轉數是當排列方式為\n$$ \\{ n, n-1, n-2, \\cdots, 2, 1 \\} $$對於 n 有 n-1 個，對於 n-1 有 n-2 個，以此類推。反轉數為其總和。\n$$ (n-1)+(n-2)+\\cdots+2+1+0=\\frac{n(n-1)}{2} $$ c X：交換次數\n理由：因為每次交換操作都消除一個反轉對。\n氣泡排序法是將每兩個元素進行比較，將順序不對的進行交換，一次操作就是消除一個反轉對。\n4 程式 3.3 是以合併排序 (Merge Sort) 演算法為基礎，使用 C 語言實作將整數陣列依遞增順序排列的處理。請回答下列問題。\n程式 3.3：合併排序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 int mergesort(int a[], int begin, int end, int w[]){ int mid = (begin+end)/2; int i = begin, j = mid+1, k, c=0; printf(\u0026#34;(%d, %d)\\n\u0026#34;, begin, end); if(begin\u0026lt;end){ mergesort(a, begin, mid, w); mergesort(a, mid+1, end, w); for(k=begin; k\u0026lt;=end; ++k){ if(mid\u0026lt;i){ A }else if(end\u0026lt;j){ B }else{ /* ++c */ if(a[i]\u0026lt;a[j]){ C }else{ D } } } for(k=begin; k\u0026lt;=end; ++k){ E } } return 0; } a）請從選項中選出適當的程式碼，填入空格 A、B、C、D、E，以完成程式。不過，假設欲排序的陣列為 a，排序時用於工作區的陣列為 w，並且 mergesort 函式將以下兩行程式碼呼叫。\n1 2 int a[5] = {3, 5, 1, 4, 2}, w[5]; mergesort(a, 0, 4, w); 選項 $$ \\begin{matrix} 甲. a[k]=w[i] \u0026 乙. a[k]=w[i++] \u0026 丙. a[k]=w[++i] \\\\ 丁. a[k]=w[j] \u0026 戊. a[k]=w[j++] \u0026 己. a[k]=w[++j] \\\\ 庚. a[k]=w[k] \u0026 辛. a[k]=w[k++] \u0026 壬. a[k]=w[++k] \\\\ 癸. w[k]=a[i] \u0026 子. w[k]=a[i++] \u0026 丑. w[k]=a[++i] \\\\ 寅. w[k]=a[j] \u0026 卯. w[k]=a[j++] \u0026 辰. w[k]=a[++j] \\\\ 巳. w[k]=a[k] \u0026 午. w[k]=a[k++] \u0026 未. w[k]=a[++k] \\end{matrix} $$b）當使用 a）中所示的程式碼呼叫 mergesort 函式時，標準輸出的第 1 行會印出 $(0,4)$。請分別回答第 3 行、第 5 行、第 7 行會印出的內容。\nc）我們希望找出 mergesort 函式在將引數指定的範圍內陣列元素排序前，執行程式 3.3 第 18 行的總次數 (元素比較次數)。因此，我們將第 17 行 (取消註解) 改為 ++c;，但這還不夠。若要將比較次數儲存到變數 count 中，且使用以下兩行程式碼呼叫，程式 3.3 應如何修改？\n1 2 int a[5] = {3, 5, 1, 4, 2}, w[5]; int count = mergesort(a, 0, 4, w); 不過，不允許使用全域變數或靜態變數。此外，除了第 17 行的修改外，對程式進行的變更僅限於 3 次行替換。行替換指的是將某行的程式碼替換為 60 個字元以內 (不計算空白字元) 的其他程式碼。作答時，請按照下方「答案寫法 (範例)」所示，標註修改的行號和替換後的程式碼。假設第 17 行的註解已取消，請說明其他必要的修改。\n「答案寫法 (範例)」 6行目：printf(\u0026quot;hello\\n\u0026quot;);\n30行目：c= end - begin + 1;\n答案\na\nA: w[k] = a[j++]; 即 卯 B: w[k] = a[i++]; 即 子 C: w[k] = a[i++]; 即 子 D: w[k] = a[j++]; 即 卯 E: a[k] = w[k]; 即 庚 b\n第 3 行: (0,1)\n第 5 行: (1,1)\n第 7 行: (3,4)\nc\n第 8 行: c += mergesort(a, begin, mid, w);\n第 9 行: c += mergesort(a, mid + 1, end, w);\n第 31 行: return c;\n這份題目乍看之下挺嚇人的，但仔細閱讀後會發現考的內容其實還好，理解合併排序後應該就能比較容易解出來。順帶一提，因為我快把演算法忘光了，而且以前都是看動畫來理解 (比較直觀)，解題時很慶幸發現了 不錯的動畫演算法網站 ","date":"2024-11-23T20:35:28+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/200/","title":"東京科學大學 大學院資訊理工學院 2020 問題三 / 科學大院理工學 2020 問題三"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 以前寫的小文章，系統建立時間 2023.12.01\n現在看著之前寫的小文章都不太想發佈，但也捨不得刪，想來想去還是發佈吧，也是自己寫的\nngrok 一鍵設定 前往 官網 註冊帳號並驗證電子郵件後會取得 Authtoken\n下載程式： ngrok - download 新增 Token\n1 ngrok config add-authtoken YourToken 執行 1 ngrok http [Port] 將 [Port] 替換成要監聽的本機埠號\n自行架設 ngrok 參考： ngrok內網穿透 學海無涯-回頭是岸 學海無涯，回頭是岸 frp 參考： frp 內網穿透 ","date":"2024-11-22T22:05:34+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/199/","title":"內網穿透"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 問題一：本文\n問題二： https://blog.yexca.net/zh-tw/archives/201 問題三： https://blog.yexca.net/zh-tw/archives/200 問題四： https://blog.yexca.net/zh-tw/archives/202 問題五： https://blog.yexca.net/zh-tw/archives/203 前言 本文是首次使用非母語寫的文章，又因為 比較懶 沒有參考其他文章，存在用詞出錯的可能性。\nこの文章は初めて母国語じゃない言語で書いて、他の文章を参考しないので、言葉遣いがてきせつではないかも。それで、参考の答えはなくて、文章の答えが自分でできたので、正しくないかも。\n科学大とは東京工業大学の新しい名前で、略称が何か知らなくてこれを使った。\n問題の著作権は東京科学大学に帰属します。閲覧の便宜のためにのみ引用されており、営利を目的とするものではありません。\n1 以下の極限を求めよ。\na) $\\lim_{x\\to\\infty}\\{ \\log_e(2x+3)-\\log_e(x) \\}$\nb) $\\lim_{x\\to 0}\\frac{1-\\cos x}{x\\sin x}$\nc) $\\lim_{x\\to 0}\\frac{e^{3x}-\\cos x}{x}$\n回答\na\n$$ a=\\lim_{x \\to \\infty}\\log_e\\frac{2x+3}{x}=\\lim_{x\\to \\infty}\\log_e(2+\\frac{3}{x})=\\log_e2 $$b\n$$ \\because \\text{when } x \\to 0, \\space 1-\\cos x \\sim \\frac{1}{2}x^2 \\space \\text{and} \\space \\sin x \\sim x \\\\ \\therefore \\lim_{x\\to 0}\\frac{1-\\cos x}{x\\sin x}=\\lim_{x\\to 0}\\frac{\\frac{1}{2}x^2}{x^2}=\\frac{1}{2} $$c 使用羅必達法則 (L\u0026rsquo;Hôpital\u0026rsquo;s rule)\n$$ \\lim_{x\\to 0}\\frac{e^{3x}-\\cos x}{x}=\\lim_{x\\to 0}\\frac{3e^{3x}+\\sin x}{1}=3 $$2 以下の実行列の積の行列式を計算せよ。\n$$ \\begin{pmatrix} 1 \u0026 0 \u0026 0 \\\\ x \u0026 2 \u0026 1 \\\\ x^2 \u0026 3 \u0026 2 \\end{pmatrix} \\begin{pmatrix} 31 \u0026 23 \u0026 17 \\\\ 0 \u0026 11 \u0026 11 \\\\ 0 \u0026 4 \u0026 5 \\end{pmatrix} $$ The determinant of the product of two matrices is the product of their determinants\nFor A\n$$ A=\\begin{pmatrix} 1 \u0026 0 \u0026 0 \\\\ x \u0026 2 \u0026 1 \\\\ x^2 \u0026 3 \u0026 2 \\end{pmatrix} $$The determinant of A\n$$ \\det(A)=(-1)^{1+1} \\times 1 \\times \\begin{vmatrix} 2 \u0026 1 \\\\ 3 \u0026 2 \\end{vmatrix} -0+0 =1 $$For B\n$$ B=\\begin{pmatrix} 31 \u0026 23 \u0026 17 \\\\ 0 \u0026 11 \u0026 11 \\\\ 0 \u0026 4 \u0026 5 \\end{pmatrix} $$The determinant of B\n$$ \\det(B)=(-1)^{1+1} \\times 31 \\times \\begin{vmatrix} 11 \u0026 11 \\\\ 4 \u0026 5 \\end{vmatrix} -0+0 = 341 $$so\n$$ \\det=\\det(A) \\times \\det(B)=1 \\times 341 = 341 $$3 以下の確率密度関数 $f_X(x)$ に従う連続型確率変数 $X$ の分散 $V(X)$ 、累積分布関数 $F_X(x)$ を各々求めよ。ただし、$\\lim_{x \\to +0}x^n\\log_e(x)=0$ ($n$ は 1 以上の整数) とする。\n$$ f_X(x)=\\left \\{ \\begin{matrix} -4x\\log_e(x) \u0026 0 \\lt x \\le 1 \\\\ 0 \u0026 x \\le 0 \\space \\text{または} \\space x \\gt 1 \\end{matrix} \\right . $$ 首先，考慮累積分布函數\n$x \\le 0$ $$ F_X(x) = 0 $$ $x\\gt 1$ $$ F_X(x) = 1 $$ $0 \\lt x \\le 1$ $$ \\begin{align} F_X(x) \u0026= \\int_0^x(-4t\\log_e(t))dt \\\\ \\end{align} $$使用分部積分法\n$$ \\begin{matrix} u = \\ln t \u0026 dv=4tdt \\\\ du = \\frac{1}{t}dt \u0026 v=2t^2 \\end{matrix} $$因此\n$$ \\begin{align} F_X(x) \u0026=-( [2t^2\\ln t]_0^x - \\int_0^x 2t^2\\frac{1}{t}dt ) \\\\ \u0026=-( 2x^2\\ln x - \\int_0^x 2t dt ) \\\\ \u0026=-( 2x^2\\ln x - t^2\\mid_0^x ) \\\\ \u0026=x^2 - 2x^2\\ln x \\end{align} $$由此可知\n$$ F_X(x)= \\left \\{ \\begin{matrix} 0 \u0026 x \\le 0 \\\\ x^2-2x^2\\ln x \u0026 0 \\lt x \\le 1 \\\\ 1 \u0026 x \\gt 1 \\end{matrix} \\right . $$接下來，求變異數。變異數的定義為\n$$ V(X)=E[X^2] - (E[X])^2 $$計算期望值 $E[X]$\n$$ \\begin{align} E[X] \u0026= \\int_{-\\infty}^{\\infty}xf_X(x)dx \\\\ \u0026= \\int_0^1x(-4x\\ln x)dx \\\\ \u0026= -\\int_0^1 4x^2\\ln xdx \\end{align} $$使用分部積分法\n$$ \\begin{matrix} u=\\ln x \u0026 dv=4x^2dx \\\\ du=\\frac{1}{x} \u0026 v=\\frac{4}{3}x^3 \\end{matrix} $$因此\n$$ \\begin{align} E[X] \u0026= -([\\frac{4}{3}x^3\\ln x]_0^1-\\int_0^1\\frac{4}{3}x^3\\frac{1}{x}dx) \\\\ \u0026= -(-\\frac{4}{9}x^3\\mid_0^1) \\\\ \u0026= \\frac{4}{9} \\end{align} $$計算 $E[X^2]$\n$$ \\begin{align} E[X^2] \u0026= \\int_{-\\infty}^{\\infty}x^2f_X(x)dx \\\\ \u0026= \\int_0^1x^2(-4x\\ln x)dx \\\\ \u0026= -4\\int_0^1x^3\\ln xdx \\end{align} $$使用分部積分法\n$$ \\begin{matrix} u=\\ln x \u0026 dv=x^3dx \\\\ du=\\frac{1}{x} \u0026 v=\\frac{1}{4}x^4 \\end{matrix} $$因此\n$$ \\begin{align} E[X^2] \u0026= -4 \\times ([\\frac{1}{4}x^4\\ln x]_0^1-\\int_0^1\\frac{1}{4}x^3dx) \\\\ \u0026= -4 \\times (-\\frac{1}{16}x^4\\mid_0^1) \\\\ \u0026= \\frac{1}{4} \\end{align} $$所以\n$$ \\begin{align} V(X) \u0026= E[X^2] - (E[X])^2 \\\\ \u0026= \\frac{1}{4} - (\\frac{4}{9})^2 \\\\ \u0026= \\frac{17}{324} \\end{align} $$4 ある製造ラインで生産された製品は1/1000の確率で不良品である。不良品を99/100の確率で正しく不良品と判定し、かつ、不良品でないものを4/5の確率で正しく不良品ではないと判定する検査手法がある。この製造ラインにおいて、この手法が不良品と判定した製品が、不良品である確率を求めよ。\n為不良品的機率：$P(A)=\\frac{1}{1000}$，判定為不良品的機率：$P(B)$\n由此可知\n$$ \\begin{matrix} P(\\bar{A})=\\frac{999}{1000} \u0026 P(B\\mid A)=\\frac{99}{100} \u0026 P(B\\mid \\bar{A})=\\frac{1}{5} \\end{matrix} $$因此\n$$ P(B)=P(A)P(B\\mid A)+P(\\bar{A})P(B\\mid \\bar{A})=\\frac{20079}{100000} $$使用貝氏定理\n$$ P(A\\mid B)=\\frac{P(AB)}{P(B)}=\\frac{P(A)P(B\\mid A)}{P(B)}=\\frac{99}{20079} $$以上可知，為不良品的機率為 $\\frac{99}{20079}$\n5 あるカジノで、4個のパケットA,B,C,Dに区切られたルーレットがある。カジノの説明ではそれぞれのパケットにボールが入る確率は同じであるとされている。そのルーレットを5回試行したところ、ボールはパケットAに4回入った。カジノの説明とは異なる「このルーレットはボールがポケットAにより入りやすい」という仮設を、有意水準5％で検定せよ。解答には帰無仮説 $H_0$ 、対立仮説 $H_1$ を明記すること。\n$H_0$：球落入區域 A 的機率與其他區域相同。即\n$$ P(A)=\\frac{1}{4} $$$H_1$：球落入區域 A 的機率高於其他區域。即\n$$ P(A)\\gt \\frac{1}{4} $$球落入區域 A 恰好 4 次的機率為\n$$ P(X=4)=\\binom{5}{4} (\\frac{1}{4})^4 \\times \\frac{3}{4}=\\frac{15}{1024} $$球落入區域 A 恰好 5 次的機率為\n$$ P(X=5)=\\binom{5}{5} (\\frac{1}{4})^5=\\frac{1}{1024} $$由此可知\n$$ P(X\\ge 4)=\\frac{15}{1024}+\\frac{1}{1024}=\\frac{1}{64} $$由於此機率小於顯著水準（$1/64 \\approx 0.0156 \u003c 0.05$），故拒絕虛無假設。因此，「此輪盤的球較容易落入區域 A」的假設在統計上是顯著的。\n","date":"2024-11-21T15:42:18+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/198/","title":"東京科學大學大學院情報理工學院 2020 問題一"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 前言 Sometimes it\u0026rsquo;s the people who no one imagines anything of who do the things that no one can imagine\n最近從 畢導影片 彈幕中得知關於圖靈的紀錄片 The Imitation Game（模仿遊戲），順便看了一下，對於片中出現的這句話感觸良多，以此作為形式語言與自動機文章的開篇引言。\n當您開始有點憂鬱的時候，也請看看 Amy 關於此句的感悟 吧。\n基本概念 字母表：符號（字元）的非空有限集合\n$$ {\\textstyle \\sum_1} = \\{0, 1\\} $$字串：由某字母表中符號組成的有限序列\n$$ 若 \\space {\\textstyle \\sum_1} = \\{0, 1\\}，那麼 \\space 0，1，00，101011 \\space 為 \\space {\\textstyle \\sum_1} \\space 上的字串 $$空字串：記為 $\\varepsilon$ ，有 0 個字元的字串。對任意字母表 $\\sum$ 都有 $\\varepsilon \\notin \\sum$\n符號的使用約定\n字母表：$\\sum, \\Gamma, \\cdots$\n字元：$a, b, c, \\cdots$\n字串：$\\cdots,w,x,y,z$\n集合：$A,B,C,\\cdots$\n字串的長度：字串中符號所佔位置的數量\n$$ 對於 \\space {\\textstyle \\sum_1} = \\{0, 1\\}，|0010|=4 $$字串 $x$ 和 $y$ 的串接：將首尾相接得到新字串的運算，記為 $x \\cdot y$ 或 $xy$\n$$ x=01, y=ab, 則 \\space xy=01ab $$字串 $x$ 的 $n$ 次冪 ($n \\ge 0$) ，遞迴定義為\n$$ x^n= \\left \\{ \\begin{matrix} \\varepsilon \u0026 n=0 \\\\ x^{n-1}x \u0026 n \\gt 0 \\end{matrix} \\right . $$$對於 \\space {\\textstyle \\sum_1} = \\{a, b\\} (ba)^2=baba, ba^2=baa$\n集合 $A$ 和 $B$ 的串接，記為 $A\\cdot B$ 或 $AB$ ，定義為\n$$ A \\cdot B = \\{ w |w=x \\cdot y, x \\in A \\space and \\space y \\in B \\} $$若 $\\space A = \\{0, 11\\} \\space B = \\{ab, ba\\} $\n$AB = \\{ 0ab, 0ba, 11ab, 11ba \\}, BA= \\{ ab0, ab11, ba0, ab11 \\}$\n集合 $A$ 的 $n$ 次冪 ($n \\ge 0$) ，遞迴定義為\n$$ A^n= \\left \\{ \\begin{matrix} \\{ \\varepsilon \\} \u0026 n=0\\\\ A^{n-1}A \u0026 n \\ge 1 \\end{matrix} \\right . $$$對於 \\space {\\textstyle \\sum_1} = \\{0, 1\\} $，有 ${\\textstyle \\sum^0}=\\{\\varepsilon\\}, {\\textstyle \\sum^1}=\\{0,1\\}, {\\textstyle \\sum^2}=\\{00,01,10,11\\}, \\cdots$\n克林閉包 (Kleene Closure) : 將某字母表的所有冪（包含零次）取聯集得到\n$$ {\\textstyle \\sum^*} = \\bigcup_{i=0}^{\\infty}{\\textstyle \\sum^i} $$正閉包 (Positive Closure) : 將某字母表的所有冪（不包含零次）取聯集得到\n$$ {\\textstyle \\sum^+} = \\bigcup_{i=1}^{\\infty}{\\textstyle \\sum^i} $$顯然\n$$ {\\textstyle \\sum^*} = {\\textstyle \\sum^+} \\cup \\{ \\varepsilon \\} $$語言 定義：若 $\\sum$ 為字母表且 $\\forall L \\subseteq \\sum^*$ ，則 $L$ 稱為字母表 $\\sum$ 上的語言\n自然語言、程式設計語言等 $ \\\\{ 0^n 1^n \\mid n \\ge 0 \\\\} $ The set of strings of 0\u0026rsquo;s and 1\u0026rsquo;s with an equal number of each $\\emptyset$ ，$\\{ \\varepsilon \\}$ 和 $\\sum^*$ 分別都是任意字母表 $\\sum$ 上的語言，但 $\\emptyset \\ne \\{ \\varepsilon \\}$ 語言唯一的限制就是所有字母表都是有限的\n","date":"2024-11-19T22:18:42+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/197/","title":"形式語言與自動機 - 基本概念"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 Vue 指令 Vue 會根據不同的指令，針對標籤實現不同的功能，指令為帶有 v- 前綴的特殊標籤屬性\nv-html 用於設定元素的 innerHTML\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;v-html\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;div v-html=\u0026#34;link\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const app = new Vue({ el: \u0026#39;#app\u0026#39;, data: { link:\u0026#39;\u0026lt;a href=\u0026#34;https://yexca.net/\u0026#34;\u0026gt;yexca\u0026lt;/a\u0026gt;\u0026#39; } }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; v-show 與 v-if \\ v-show v-if 作用 控制元素顯示隱藏 控制元素顯示隱藏 (條件渲染) 語法 v-show=\u0026ldquo;表達式\u0026rdquo; v-if=\u0026ldquo;表達式\u0026rdquo; 表達式值 ture 顯示，false 隱藏 ture 顯示，false 隱藏 隱藏說明 透過控制屬性 style=\u0026quot;display:none;\u0026quot; 直接刪除或建立元素 情境 頻繁切換 不頻繁切換 v-else 與 v-else-if 用於輔助 v-if 進行渲染，需要緊挨著 v-if 一起使用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;v-else and v-else-if\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;p v-if=\u0026#34;gender === 1\u0026#34;\u0026gt;性別：男\u0026lt;/p\u0026gt; \u0026lt;p v-else\u0026gt;性別：女\u0026lt;/p\u0026gt; \u0026lt;hr /\u0026gt; \u0026lt;p v-if=\u0026#34;score \u0026gt;= 90\u0026#34;\u0026gt;成績判定 A\u0026lt;/p\u0026gt; \u0026lt;p v-else-if=\u0026#34;score \u0026gt;= 70\u0026#34;\u0026gt;成績判定 B\u0026lt;/p\u0026gt; \u0026lt;p v-else-if=\u0026#34;score \u0026gt;= 60\u0026#34;\u0026gt;成績判定 C\u0026lt;/p\u0026gt; \u0026lt;p v-else\u0026gt;成績判定 D\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const app = new Vue({ el: \u0026#39;#app\u0026#39;, data: { gender: 1, score: 89 } }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; v-on 用於註冊事件 = 加入監聽 + 提供處理邏輯\n語法一 v-on:事件名=\u0026ldquo;內聯語句\u0026rdquo;\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;v-on 1\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;button v-on:click=\u0026#34;count1--\u0026#34;\u0026gt;-\u0026lt;/button\u0026gt; \u0026lt;span\u0026gt;{{count1}} \u0026lt;/span\u0026gt; \u0026lt;!-- v-on: 可以替換為 @ --\u0026gt; \u0026lt;button @click=\u0026#34;count1++\u0026#34;\u0026gt;+\u0026lt;/button\u0026gt; \u0026lt;hr /\u0026gt; \u0026lt;button v-on:mouseenter=\u0026#34;count2--\u0026#34;\u0026gt;-\u0026lt;/button\u0026gt; \u0026lt;span\u0026gt;{{count2}}\u0026lt;/span\u0026gt; \u0026lt;button v-on:mouseenter=\u0026#34;count2++\u0026#34;\u0026gt;+\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const app = new Vue({ el: \u0026#39;#app\u0026#39;, data: { count1: 1, count2: 2 } }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 語法二 v-on:事件名=\u0026ldquo;methods中的函數名\u0026rdquo;\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;v-on 2\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;button @click=\u0026#34;fun\u0026#34;\u0026gt;切換顯示隱藏\u0026lt;/button\u0026gt; \u0026lt;p v-show=\u0026#34;isShow\u0026#34;\u0026gt;hello yexca\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const app = new Vue({ el: \u0026#34;#app\u0026#34;, data: { isShow: true }, methods: { fun(){ // this 始終指向當前實例 this.isShow = !this.isShow } } }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 呼叫傳參 直接看範例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;v-on 3\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; .box{ border-style: solid; border-color: aqua; padding: 10px; margin: 10px; width: 200px; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;自動販賣機\u0026lt;/h3\u0026gt; \u0026lt;button @click=\u0026#34;fun(5)\u0026#34;\u0026gt;可樂5元\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;fun(10)\u0026#34;\u0026gt;咖啡10元\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div style=\u0026#34;padding-left: 20px;\u0026#34;\u0026gt;餘額：{{balance}}\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;../js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const app = new Vue({ el: \u0026#34;#app\u0026#34;, data: { balance: 900 }, methods: { fun(a){ this.balance -= a } } }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; v-bind 用於動態設定 HTML 的標籤屬性，例如 src、url、title 等\n語法：v-bind:屬性名=\u0026ldquo;表達式\u0026rdquo;\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;v-bind\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; img{ width: 400px; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;!-- v-bind 可以省略 --\u0026gt; \u0026lt;img v-bind:src=\u0026#34;imgURL\u0026#34; :title=\u0026#34;imgTitle\u0026#34; :alt=\u0026#34;imgAlt\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;../js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const app = new Vue({ el: \u0026#39;#app\u0026#39;, data: { imgURL: \u0026#39;../img/01.jpg\u0026#39;, imgTitle: \u0026#39;warma\u0026#39;, imgAlt: \u0026#39;warma\u0026#39; } }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; v-for 基於資料循環，多次渲染整個元素\n語法：v-for=\u0026quot;(item, index) in 陣列\u0026quot;\nitem：每一個項目，index：索引\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;v-for\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;fruit shop\u0026lt;/h3\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;!-- 當 index 不需要時可以省略 --\u0026gt; \u0026lt;li v-for=\u0026#34;item in list\u0026#34;\u0026gt;{{ item }}\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;(item,index) in list\u0026#34;\u0026gt;{{ index }}\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;../js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const app = new Vue({ el: \u0026#39;#app\u0026#39;, data: { list: [\u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;watermelon\u0026#39;] } }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 為便於 Vue 進行列表項目的正確排序與重複利用，需要給元素加入唯一識別，即 key 屬性\nkey 的值只能是字串或數字型別，且必須具有唯一性\n1 \u0026lt;li v-for=\u0026#34;(item, index) in list\u0026#34; :key=\u0026#34;item.id\u0026#34;\u0026gt;\u0026lt;/li\u0026gt; 建議使用 id 作為 key，不建議使用 index 作為 key (會變化，不對應)\nv-model 給表單元素使用，實現雙向資料綁定，以便快速取得或設定表單元素內容\n雙向資料綁定即視圖變化，資料自動更新\n語法：v-model=\u0026lsquo;變數\u0026rsquo;\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;v-model\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; username: \u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;username\u0026#34;/\u0026gt;\u0026lt;br /\u0026gt;\u0026lt;br /\u0026gt; password: \u0026lt;input type=\u0026#34;password\u0026#34; v-model=\u0026#34;password\u0026#34; /\u0026gt;\u0026lt;br /\u0026gt;\u0026lt;br /\u0026gt; \u0026lt;button @click=\u0026#34;login\u0026#34;\u0026gt;登入\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;reset\u0026#34;\u0026gt;重設\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;../js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const app = new Vue({ el: \u0026#39;#app\u0026#39;, data: { username: \u0026#39;\u0026#39;, password: \u0026#39;\u0026#39; }, methods: { login(){ console.log(this.username, this.password) }, reset(){ this.username = \u0026#39;\u0026#39; this.password = \u0026#39;\u0026#39; } } }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 指令修飾符 透過 . 指明一些指令後綴，不同後綴封裝了不同的處理操作\n按鍵修飾符\n@keyup.enter 鍵盤 Enter 鍵監聽\nv-model 修飾符\nv-model.trim 去除首尾空白\nv-model.number 轉為數字\n事件修飾符\n@事件名.stop 阻止事件冒泡\n@事件名.prevent 阻止預設行為\n計算屬性 基於現有的資料，計算出來的新屬性。依賴的資料變化，會自動重新計算\n1 2 3 4 5 6 7 8 9 10 11 new Vue(){ el: \u0026#34;#app\u0026#34;, data: { count: 0, }, computed: { doubleCount() { return this.count * 2; }, }, } Vue 生命週期 生命週期指一個物件從建立到銷毀的整個過程\nVue 生命週期有 8 個階段，每觸發一個生命週期事件，會自動執行一個生命週期方法 (鉤子)\n狀態 階段週期 beforeCreate 建立前 created 建立後 beforeMount 載入前 mounted 掛載完成 beforeUpdate 更新前 updated 更新後 beforeDestroy 銷毀前 destroyed 銷毀後 其中 mounted 較為常用，指 Vue 初始化成功，HTML 渲染成功。(發送請求到伺服器，載入資料)\n1 2 3 4 5 6 7 8 9 10 11 12 new Vue(){ el: \u0026#34;#app\u0026#34;, data: { }, mounted(){ console.log(\u0026#34;Vue 掛載完成，發送請求取得資料\u0026#34;); }, methods: { } } ","date":"2024-11-15T20:48:29+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/196/","title":"Vue 學習"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 引言 HTML 學習一 - 基礎: https://blog.yexca.net/zh-tw/archives/146 HTML 學習二 - 列表、表格與表單: https://blog.yexca.net/zh-tw/archives/150 HTML 學習三 - 網頁佈局: https://blog.yexca.net/zh-tw/archives/195 標準流也稱為文件流，指的是標籤在頁面中預設的排列規則，例如：區塊元素獨佔一行，行內元素可以一行顯示多個\n若不依標準流佈局可使用浮動或 Flex 佈局\n浮動 作用：使區塊元素水平排列，屬性名稱 float，屬性值有兩個：left 和 right\n加上浮動的盒子將脫離標準流\n清除浮動影響 因為浮動元素會脫離標準流，如果父層沒有高度，自己將無法撐開父層高度，可能導致頁面佈局錯亂\n清除浮動常用四種方法\n額外標籤法 在父層元素的最後添加一個區塊級元素，設定 CSS 屬性 clear:both\n1 2 3 4 5 6 7 8 9 10 \u0026lt;style\u0026gt; .clearfix { clear: both; } \u0026lt;/style\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;clearfix\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 單偽元素法 原理同上\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;style\u0026gt; .clearfix::after { content: \u0026#34;\u0026#34;; display: block; clear: both; } \u0026lt;/style\u0026gt; \u0026lt;div class=\u0026#34;clearfix\u0026#34;\u0026gt; \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 雙偽元素法 此方法可同時解決塌陷問題與浮動影響\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;style\u0026gt; .clearfix::before, /* 解決塌陷問題 */ .clearfix::after { content: \u0026#34;\u0026#34;; display: table; } .clearfix::after { /* 解決浮動問題 */ clear: both; } \u0026lt;/style\u0026gt; \u0026lt;div class=\u0026#34;clearfix\u0026#34;\u0026gt; \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; overflow 在父層元素添加 CSS 屬性 overflow: hidden;\nFlex Flex 佈局也稱為彈性佈局，是瀏覽器提倡的佈局模型，非常適合結構化佈局，提供了強大的空間分佈與對齊能力\n而且 Flex 模型不會產生浮動佈局中的脫離標準流現象，佈局網頁更簡單、更靈活\n組成 Flex 有四個組成部分\n彈性容器 彈性盒子 主軸：預設在水平方向 側軸/交叉軸：預設在垂直方向 給父層元素設定 display: flex; 將變成彈性容器，子元素變為彈性盒子，可以自動擠壓或拉伸\nFlex 佈局 描述 屬性名稱 主軸對齊方式 justify-content 側軸對齊方式 align-items 某個彈性盒子\n側軸對齊方式 align-self 修改主軸方向 flex-direction 彈性伸縮 flex 彈性盒子換行 flex-wrap 行對齊方式 align-content 主軸對齊方式 屬性名稱：justify-content\n屬性值 效果 flex-start 預設值，彈性盒子從起點開始依序排列 flex-end 彈性盒子從終點開始依序排列 center 彈性盒子沿主軸置中排列 space-between 彈性盒子沿主軸均勻排列，空白間距均分在彈性盒子之間 space-around 彈性盒子沿主軸均勻排列，空白間距均分在彈性盒子兩側 space-evenly 彈性盒子沿主軸均勻排列，彈性盒子與容器之間間距相等 側軸對齊方式 屬性名稱\nalign-items: 當前彈性容器內所有彈性盒子的側軸對齊方式 (設定給彈性容器) align-self: 單獨控制某個彈性盒子的側軸對齊方式 (設定給彈性盒子) 屬性值 效果 stretch 彈性盒子沿著側軸線被拉伸至鋪滿容器 (彈性盒子沒有設定側軸方向尺寸則預設拉伸) center 彈性盒子沿側軸置中排列 flex-start 彈性盒子從起點開始依序排列 flex-end 彈性盒子從終點開始依序排列 修改主軸方向 主軸預設在水平方向，側軸預設在垂直方向\n屬性名稱：flex-direction\n屬性值 效果 row 水平方向，由左向右 (預設) column 垂直方向，由上向下 row-reverse 水平方向，由右向左 column-reverse 垂直方向，由下向上 彈性伸縮比 作用：控制彈性盒子在主軸方向的尺寸。屬性名稱：flex，在子層 (彈性盒子) 添加\n屬性值：整數數字，表示佔用父層剩餘尺寸的份數\n彈性盒子換行 彈性盒子可以自動擠壓或拉伸，預設情況下，所有彈性盒子都在一行顯示。屬性名稱：flex-wrap，在父層 (彈性容器) 添加\n屬性值有 wrap (換行) 和 nowrap (不換行，預設)\n行對齊方式 屬性名稱：align-content\n屬性值與主軸對齊方式相同，只對多行彈性盒子生效\n","date":"2024-11-10T21:36:51+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/195/","title":"HTML 學習三 - 網頁佈局"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 引言 2022 SA am2\n01-08: http://127.0.0.1:4000/zh-tw/archives/191 09-15: http://127.0.0.1:4000/zh-tw/archives/192 16-20: http://127.0.0.1:4000/zh-tw/archives/193 21-25: http://127.0.0.1:4000/zh-tw/archives/194 這五題的難度還可以，原本解完充滿自信的，不小心看了下下午論述題，我瞬間沒自信了 :cry:\n碎碎念 思考人生這種事情也確實是空閒的人會思考的，忙起來後也就沒時間去胡思亂想了 但忙過頭了說不定也會想呢\n我現在應該是意識到自己之前的兩點不足了。首先是總覺得隨時都能複習；其次是「學無止境」這個觀念的誤用。\n應該先從學無止境開始吧。「學無止境」本身是正確的，但我對這個概念的理解有些偏頗。我一直認為知識是無限的，總覺得自己不可能完全掌握任何東西，也因此產生了「什麼都不會」的心態。實際上，雖然知識的確無窮無盡，但並不代表每個領域都必須完全精通才能實際應用。有時，掌握其中一部分內容已經足以應對工作和任務了\n例如我常常在通過一門考試之後，依然會覺得自己一無所知，仍然無法勝任相關工作。然而，客觀來說，只要掌握了必要的部分內容，就已經具備了完成相關任務的能力。這種心態可能和我過去受到的教育有關，常常聽到類似「世界很大」、「所學遠遠不夠」、「真正的高手有多厲害」等話語。這種觀念在一定程度上鼓勵了學習，卻也讓我過於關注自身的不足，逐漸失去了原本的信心\n就像現在我聽到的多數學生也會說「我什麼都做不到」之類的話語，可能有一部分原因是這種觀念帶來的副作用\n然後就是隨時都能複習的想法。倒也不是複習，更像是一種「隨時可以查閱」的依賴心理。我之前備考日文 N2 時讀到一篇文章，講述了沒有文字的人如何學習之類的，因為沒有文字的記載，對於知識的獲取如上課可能是此生只有一次機會聽到該內容，所以必須全部努力記下來才行；文章還提到了我們因為網路很便利而不去記憶一些東西，並且認為網路能檢索到的東西都是自己的知識，但假如網路不能用的話事實上是不知道那些內容的，所以真正屬於自己的知識是那些已經內化到記憶中的東西。\n回到我的情況，我也是因為覺得可以隨時看，比如某條 Linux 指令啦或某段演算法程式碼之類的而不去記憶，造成一種我以為我會，但用的時候並不能寫出來，實際上應該屬於不會的範疇。這樣反覆的經歷也加深了前面提到的「什麼都不會」感覺。\n總結一下，首先應當意識到未被記憶的東西應該屬於不會，並且勝任某件作業或者可以成為某種角色所需掌握的知識是有邊界的，不用去嘗試完全精通\n感覺寫出來和想表達的意思還是有點偏差，文筆不好還使用了 ChatGPT，就這樣吧\n21 容量が a M バイトでアクセス時間がｘナノ秒の命令カッシュと、容量が b M バイトでアクセス時間がｙナノ秒の主記憶をもつシステムにおいて、CPUからみた、主記憶と命令キャッシュとを合わせた平均アクセス時間を表す式はどれか。ここで、読み込みたい命令コードが命令キャッシュに存在しない確率をｒし、キャッシュ管理に関するオーバヘッドは無視できるものとする。\n$$ \\begin{align} ア　\u0026\\frac{(1-r)\\cdot a}{a+b} \\cdot x +\\frac{r \\cdot b}{a+b} \\cdot y \\\\ イ　\u0026(1-r) \\cdot x + r \\cdot y \\\\ ウ　\u0026\\frac{r \\cdot a}{a+b} \\cdot x + \\frac{(1-r) \\cdot b}{a+b} \\cdot y \\\\ エ　\u0026r \\cdot x + (1-r) \\cdot y \\end{align} $$題目翻譯：容量為 a MB、存取時間為 x 奈秒的指令快取和容量為 b MB、存取時間為 y 奈秒的主記憶體構成的系統中，從 CPU 的角度來看，主記憶體和指令快取的平均存取時間的表達式是哪一個？其中，所需的指令代碼不存在於指令快取中的機率為 r，可以忽略與快取管理相關的開銷\n命中快取時間是 $(1-r) \\times x$ 未命中快取，讀取主記憶體時間為 $r \\times y$ 所以答案選 イ\n22 データベースサーバのクラスタリング技術の特徴のうち、シェアードエブリシングはどれか。\nア　クラスタリング構成にして可用性を高めることによって、故障発生時に担当していた範囲のデータを待機系のサーバに引き継ぐことができる。\nイ　サーバごとに管理する対象データが決まっているので、1台のサーバに故障が発生すると故障したサーバが管理する対象データを処理できなくなり、システム全体の可用性が低下する。\nウ　データを複数の磁気ディスクに分割配置し、更にサーバと磁気ディスクが1対1に対応しているので、複数サーバを用いた並列処理ができる。\nエ　負荷を分散し、全てのサーバのリソースを有効活用できることに加えて、データを共有することによって1台のサーバに故障が発生したときでも処理を継続することができる。\n題目翻譯：在資料庫伺服器的叢集技術 (clustering) 特性中，以下哪一項描述了 Shared Everything 的特點\nア　透過叢集配置提高可用性，故障發生時可以將負責的範圍內數據轉交給備用伺服器\nイ　每個伺服器負責管理特定數據，因此如果某個伺服器發生故障，則無法處理該伺服器負責的數據，系統的整體可用性會下降\nウ　數據被分割並放置在多個磁碟上，伺服器和磁碟之間是一對一的對應關係，因此可以利用多個伺服器進行平行處理\nエ　在負載分散的同時可以有效利用所有伺服器資源，並且透過共享數據，即使某一台伺服器發生故障，也能繼續處理\nShared Everything 是一種資料庫叢集架構，在該架構中，所有伺服器共享相同的數據儲存。這樣一來，任何一台伺服器的資源都可以存取和處理資料庫中的所有數據，從而提高系統的備援性和容錯能力。如果一台伺服器出現故障，其他伺服器可以接管該伺服器的任務，不會導致系統整體不可用。所以答案選 エ\n選項 ア 描述的是主備架構；選項 イ 描述的是 Shared Nothing 架構；選項 エ 描述的是 Shared Disk 架構 (最後兩個架構看看就好 doge)\n23 幾つかのサブシステムから成るシステムの信頼性に関する記述のうち、適切なものはどれか。\nア　あるサブシステムで発生したフォールトの影響が他のサブシステムに波及することを防ぐフォールトマスグは、システムのMTBFは変化させないが、MTTRの短縮につながる。\nイ　サブシステムにフォールトが検出されたとき、再試行すると正しい結果が得られる場合もあるので、再試行はシステムのMTBFの向上とMTTRの短縮につながる。\nウ　サブシステムの稼働中に行われるフォールトの検出は、システムを停止せず行われるので、システムのMTTRは変化させないが、MTBFの向上につながる。\nエ　フォールトが発生したあるサブシステムを切り離して、待機系のサブシステムに自動で切り替えるフェールオーバーは、システムのMTBFは変化させないが、MTTRの短縮につながる。\n題目翻譯：以下關於由多個子系統組成的系統的可靠性的描述中，哪一項是正確的\nア　故障隔離 (Fault Masking) 防止某個子系統中發生的故障影響到其他子系統，雖然不改變系統的平均無故障時間 (MTBF)，但可以縮短平均修復時間 (MTTR)\nイ　當檢測到子系統中有故障時，重試可能會得到正確的結果，因此重試會提升系統的 MTBF，並縮短 MTTR\nウ　在子系統運作過程中進行的故障檢測不會停止系統，因此不會改變系統的 MTTR，但可以提升 MTBF\nエ　發生故障的子系統會被隔離，並自動切換到備用子系統的故障轉移 (Failover) 機制不會改變系統的 MTBF，但可以縮短 MTTR\n對於多子系統組成的系統來說，可靠性通常取決於 MTBF 和 MTTR。MTBF 是 Mean Time Between Failures。MTTR 是 Mean Time To Repair (Recovery)。\nFault Masking (故障隔離) 確保故障不會蔓延至其他子系統。故障隔離的確減少了受故障影響的子系統數量，幫助快速修復，但不會直接影響系統的 MTBF，因為它只是隔離了故障，而不是防止故障的發生\n重試在系統中可以用於處理偶發的錯誤。但它屬於容錯機制，並不能提高系統整體的 MTBF。因為系統的根本故障沒有減少，這一機制只是避免了某些操作失敗\n故障檢測能在運作過程中提升系統的 MTBF，但與 MTTR 無關\nFailover (故障轉移) 將故障系統切換至備用系統，提升系統恢復能力。這種方式透過快速替換故障系統，確實有效地縮短了 MTTR，但不會影響 MTBF，因為它只是縮短了恢復時間\n總之 ア 和 エ 我是沒明白，答案選 エ。可能故障隔離不是直接恢復被故障影響的功能或組件，而故障切換在縮短恢復時間方面更加直接有效吧\n24 $t_{1} \\sim t_{10}$ の時刻でスケジュールされたトランザクション $T_1 \\sim T_4$ がある。時刻 $t_{10}$ で $T_1$ が commit を発行する直前の、トランザクションの待ちグラフを作成した。a に当てはまるトランザクションはどれか。ここで、select(X) は共有ロックを掛けて資源 X を参照することを表し、update(X) は専有ロックを掛けて資源 X を更新することを表す。これらのロックは、commit された時にアンロックされるものとする。また、トランザクションの待ちグラフの矢印は、$T_i \\rightarrow T_j$ としたとき、$T_j$ がロックしている資源のアンロックを、$T_i$ を待つことを表す。\n（トランザクションのスケジュール$t_1$）\n時刻 $T_1$ $T_2$ $T_3$ $T_4$ $t_1$ select(A) $t_2$ select(B) $t_3$ select(B) $t_4$ select(A) $t_5$ update(B) $t_6$ select(C) $t_7$ select(C) $t_8$ update(C) $t_9$ update(A) $t_{10}$ commit （トランザクションの待ちグラフ）\nア　$T_1$\nイ　$T_2$\nウ　$T_3$\nエ　$T_4$\n題目翻譯：在時刻 $t_{1} \\sim t_{10}$ 之間，排程了交易 $T_1 \\sim T_4$。在時刻 $t_{10}$ 時，交易 $T_1$ 在 commit 前，構建了交易的等待圖。請問在圖中位置 a 所指的交易是哪一個？這裡，select(X) 表示對資源加共享鎖並讀取，update(X) 表示對資源加排他鎖並修改。所有的鎖會在交易提交時解鎖。並且在等待圖中，箭頭 $T_i \\rightarrow T_j$ 表示交易 $T_i$ 正在等待交易 $T_j$ 解鎖其持有的資源\n關於資料庫的並行控制 (X 鎖和 S 鎖) 可以參見： https://blog.yexca.net/zh-tw/archives/92 這裡首先共享鎖 (S 鎖) 是可以被其他交易讀取的，所以並不會發生阻塞，也就是一直到 $t_5$ 時刻 $T_4$ 的 update(B) 想對資源 B 加排他鎖 (X 鎖)，但資源 B 此時被 $T_2$ 和 $T_3$ 加共享鎖而阻塞，圖中受到兩個阻塞的有 b 和 c。也就是 $T_4$ 可能是 b 或者 c\n然後 $t_8$ 時刻 $T_2$ 想對 C 加排他鎖，此時資源 C 被 $T_1$ 阻塞 (因為 $T_1$ 持有 S 鎖)，所以 $T_1$ 阻塞 $T_2$。圖中只有一個阻塞的是 a。基本可以斷定其就是 $T_2$\n最後 $t_9$ 想對 A 施加排他鎖，此時 A 被 $T_1$ 和 $T_4$ 施加共享鎖，所以被其阻塞，符合條件的有 b 和 c。\n之後就是提交釋放鎖了，未被阻塞的只有 $T_1$ 所以是 d，根據上述分析可以知道 a 是 $T_2$、b 是 $T_4$、c 是 $T_3$。所以答案選 イ\n25 図は、既存の電話機とPBXを使用した企業内の内線網を、IPネットワークに統合する場合の接続構成を示している。図中の $a \\sim c$ に該当する装置の適切な組合せはどれか。\n- a b c ア PBX VoIPゲートウェイ ルータ イ PBX ルータ VoIPゲートウェイ ウ VoIPゲートウェイ PBX ルータ エ VoIPゲートウェイ ルータ PBX 題目翻譯：圖中展示了一個企業內部的內線網路在整合到 IP 網路時的連接構成。請問圖中 $a \\sim c$ 所對應的設備正確組合是哪一項\n- a b c ア PBX VoIP 閘道器 路由器 イ PBX 路由器 VoIP 閘道器 ウ VoIP 閘道器 PBX 路由器 エ VoIP 閘道器 路由器 PBX 為了將傳統電話系統整合進 IP 網路結構，需要一些設備：\nPBX (Private Branch Exchange，專用分機交換機)：這是傳統電話系統的核心設備，負責管理和控制企業內部電話的交換與連接 VoIP 閘道器：充當傳統電話系統與 IP 網路之間的橋梁，將類比訊號轉換為 IP 封包，以便在 IP 網路上傳輸 路由器：負責在 IP 網路上管理和轉發封包，確保封包能夠到達目的地 所以答案選 ア\n","date":"2024-11-08T18:29:54+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/194/","title":"2022 SA am2 -21-25"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 引言 2022 SA am2\n01-08: http://127.0.0.1:4000/zh-tw/archives/191 09-15: http://127.0.0.1:4000/zh-tw/archives/192 16-20: http://127.0.0.1:4000/zh-tw/archives/193 21-25: http://127.0.0.1:4000/zh-tw/archives/194 漸漸不會起來了呢，不過還是可控的 (doge\n16 e シールの説明はどれか。\nア　インターネット上のゲーム内に限定されたキャラクターのイメージデータの作成者を証明する仕組みの一つである。\nイ　個人の意思表示をしている個人の本人確認が必要な電子文書データについて、その電子文書データの作成者の証明と改ざん防止のために、個人が行う電子署名である。\nウ　電子文書データの作成者の証明と改ざん防止のために、重要文書を扱う国や地方自治体などの公共機関だけに使用が許されている電子署名である。\nエ　法人が作成した電子文書データについて、その電子文書データの作成者が間違いなくその法人であり、かつその電子文書データは作成後に改ざんされていないことを証明するものである。\n題目翻譯：e シール（電子印章）的說明是哪一項\nア　這是在網際網路上證明遊戲角色形象資料的建立者的一種機制，限定於遊戲內使用。\nイ　這是個人對電子文件資料進行的電子簽章，用於證明該電子文件的建立者身分並防止竄改。\nウ　為了證明電子文件資料的建立者身分並防止竄改，僅限國家和地方政府等公共機構使用的電子簽章。\nエ　針對法人建立的電子文件資料，證明該文件的建立者確實是該法人，並確保該文件在建立後未被竄改。\ne シール 通常用於法人或機構對電子文件的認證，確保文件的建立者是法人並且沒有被竄改。因此正確答案為選項 エ\n17 マルチベクトル型 DDoS 攻撃に該当するものはどれか。\nア　攻撃対象のWebサーバ1台に対して、多数のPCから一斉にリクエストを送ってサーバのリソースを枯渇させる攻撃と、大量のDNS通信によってネットワークの帯域を消費する攻撃を同時に行う。\nイ　攻撃対象のWebサイトのログインパスワードを解読するために、ブルートフォースによるログイン試行を、多数のスマートフォン、IoT機器などから成るボットネットを踏み台にして一斉に行う。\nウ　攻撃対象のサーバに大量のレスポンスが同時に送り付けられるようにするために、多数のオープンリゾルバに対して、送信元IPアドレスを攻撃対象のサーバのIPアドレスに偽装した名前解決のリクエストを一斉に送信する。\nエ　攻撃対象の組織内の多数の端末をマルウェアに感染させ、当該マルウェアを遠隔操作することによってデータの改ざんやファイルの消去を一斉に行う。\n題目翻譯：以下哪項屬於多向量型 DDoS 攻擊\nア　對目標的 1 台 Web 伺服器，從大量 PC 同時發送請求使伺服器資源枯竭，同時進行大量的 DNS 通訊消耗網路頻寬。\nイ　為了破解目標網站的登入密碼，使用暴力破解嘗試登入，同時利用大量智慧型手機和 IoT 設備構成的殭屍網路進行一齊攻擊。\nウ　為了向目標伺服器發送大量回應資料，透過多個開放的 DNS 解析器，將請求的發送源偽裝成目標伺服器 IP 位址，批量發送網域名稱解析請求。\nエ　透過感染目標組織內部的大量終端設備，使這些設備感染惡意軟體，透過遠端操作進行資料竄改或檔案刪除的攻擊。\n多向量型 DDoS 攻擊通常會同時使用不同的攻擊手法。選項 ア 使用了消耗伺服器資源和消耗網路頻寬的兩種方式，因此是一個多向量攻擊；而選項 ウ 僅使用 DNS 放大攻擊 (Amplification Attack)，不屬於多向量攻擊。 イ 主要攻擊目標是登入密碼破解，而非多種資源的消耗或網路頻寬的多重佔用；エ 透過惡意軟體感染的入侵攻擊，不是 DDoS 類型的網路頻寬或資源消耗攻擊。所以答案為選項 ア\n18 暗号方式に関する記述のうち、適切なものはどれか。\nア　AESは公開鍵暗号方式、RSAは共通鍵暗号方式の一種である。\nイ　共通鍵暗号方式では、暗号化及び複合に同一の鍵を使用する。\nウ　公開鍵暗号方式を通信内容の秘匿に使用する場合は、暗号化に使用する鍵を秘密にして、複合に使用する鍵を公開する。\nエ　デジタル署名に公開鍵暗号方式が使用されることはなく、共通鍵暗号方式が使用される。\n題目翻譯：關於加密方式的描述，以下哪項是正確的\nア　AES 是一種公鑰加密方式，RSA 是一種對稱金鑰加密方式\nイ　在對稱金鑰加密方式中，加密和解密使用相同的金鑰\nウ　在公鑰加密方式用於通訊內容保密時，加密所用的金鑰應保密，解密所用的金鑰應公開\nエ　數位簽章不會使用公鑰加密方式，而是使用對稱金鑰加密方式\n這題屬於加密領域，答案是選擇 イ。AES 是對稱加密演算法，其他選項可以參考我不知道啥時收藏的一篇文章： 一文詳解 RSA 非對稱加密演算法 19 CRYPTREC の役割として、適切なものはどれか。\nア　外国為替及び外国貿易法で規制されている暗号装置の輸出許可申請を審査、承認する。\nイ　政府調達においてIT関連製品のセキュリティ機能の適切性を評価、認証する。\nウ　電子政府での利用を推奨する暗号技術の安全性を評価、監視する。\nエ　民間企業のサーバに対するセキュリティ攻撃を監視、検知する。\n題目翻譯：關於 CRYPTREC 的作用，以下哪項描述是正確的\nア　根據《外匯及外國貿易法》審查和批准受限制的加密設備的出口許可申請\nイ　在政府採購中，對 IT 相關產品的安全功能進行適當性評價和認證\nウ　對電子政府中推薦使用的加密技術的安全性進行評估和監控\nエ　監控並檢測針對私營企業伺服器的安全攻擊\nCRYPTREC (Cryptography Research and Evaluation Committees，密碼技術研究和評估委員會) 是日本一個專注於密碼技術的政府專案。其主要職責包括對密碼演算法的研究、評估、推薦和監視，以確保這些演算法的安全性和可靠性，特別是在政府和公共部門的應用中。其核心功能有推薦加密技術、監控和評估安全性以及支持政策制定。其主要目標是確保密碼技術在公共領域的安全應用，防止資訊洩漏和資料竄改等安全事件的發生。所以答案選 ウ\n20 インターネットとの接続において、ファイアウォールのNAPT機能によるセキュリティ上の効果はどれか。\nア　DMZ上にある公開Webサイトの脆弱性を悪用する攻撃を防御できる。\nイ　インターネットから内部ネットワークへの侵入を検知し、検知後の通信を遮断できる。\nウ　インターネット上の特定のWebサービスを利用するHTTP通信を検知し、遮断できる。\nエ　内部ネットワークからインターネットにアクセスする利用者PCについて、インターネットからの不正アクセスを困難にすることができる。\n題目翻譯：在連接到網際網路時，使用防火牆的 NAPT 功能的安全效果是什麼\nア　能夠防禦利用位於 DMZ 上的公開網站漏洞的攻擊\nイ　能夠檢測從網際網路到內部網路的入侵，並在檢測到後阻斷通訊\nウ　能夠檢測並阻止利用特定 Web 服務的 HTTP 通訊\nエ　可以使從內部網路存取網際網路的使用者 PC 更難受到來自網際網路的不正當存取\nNAPT (Network Address Port Translation，網路位址連接埠轉換) 是一種動態地將內部 IP 位址和連接埠映射到外部 IP 位址和連接埠的技術。其主要作用是在共享一個公網 IP 位址時隱藏內部網路的 IP 位址，防止外部設備直接存取內部網路設備，從而提升安全性。所以答案選 エ\n","date":"2024-11-06T22:05:18+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/193/","title":"2022 SA am2 -16-20"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 引言 2022 SA am2\n01-08: http://127.0.0.1:4000/zh-tw/archives/191 09-15: http://127.0.0.1:4000/zh-tw/archives/192 16-20: http://127.0.0.1:4000/zh-tw/archives/193 21-25: http://127.0.0.1:4000/zh-tw/archives/194 從中間的題目開始，難度開始上來了，幾乎都是沒有學過的了，可以收回之前說的我覺得可以過的言論了，不過要是真不學什麼東西直接過倒不如不去考呢，就算考不過，但學到的知識可以影響自己 (怎麼又有要開始的跡象了)\n碎碎念 因為寫得太多了，不用引言了，改成碎碎念得了 (本來是放前面的，但覺得還是文章相關放前面比較好，所以銜接可能有點怪)\n最近每個文章是不是都得來個感悟啊 doge (不知道人的腦洞是有極限的嗎)\n事實上這些感悟或者思考的出現是從去年，我的眼睛開始非常地疼痛，然後我經常就只是躺在床上聽音樂 (不僅是螢幕，就算是看自然的景色也會疼痛)，就是在躺著的時間裡我可能是夢也可能是胡思亂想 (我已經不知道躺著時候我是在夢境還是現實了，眼睛疼痛，同時有時候身體還會難受) 使我想到了可以說對我影響比較深的兩個理論，我將其命名為「狀態行為理論」與「圈理論」，從我將它們大體想出來後，我常常在夢或者對某件事情進行思考的時候想到這兩個理論，對其進行細節的修正，然後再度思考，當然還有一些其他的思考啦，就像最近文章出現的那樣。本來那時候想著把兩個理論寫出來的，但一拖再拖，那股勁沒了就會覺得有點害羞去發表，因為並沒有經過任何的查重驗證之類的發布一個自以為是的理論什麼的，還是有點不大好。當然還有著我平常覺得部落格只是討論技術吧，但現在倒是想開了，學技術第一想法是去尋找相關課程，我寫的東西也沒啥人看，想怎麼造就怎麼造。(莫名想到 warma 介紹爆炸電台的樣子)\n寫到這我去找了下 warma 影片，簡略看了下並沒有找到，可能在消失的第二期吧。但第九期開頭有提到「大家有沒有這種感覺，就是當你去完成一件事，然後你寫好了一個精妙的計劃，這個計劃非常完美，但是你實行起來之後，從第一步開始，就不想照著計劃走了，就感覺我憑什麼要照著計劃來」。這讓我想到了之前我的矛盾，在人生沒有計劃或者被安排時候覺得沒有目標，不知如何行動之類的；但是有計劃或者按照安排來又會覺得自己的人生不自由。然後就導致著自己在這種製作計劃、推翻計劃、再次製作、再次推翻的循環中，最終一事無成。事實上我倒是處於這個狀態，想要什麼但不會去接近它，害怕失去，一次小小的接近失敗都有可能放棄去接近，當然，這在我昨天晚上想到的信任想法中有所體現，太長了不贅述。但是聽到 warma 說出來我當時會瞬間有將此種狀態打破的感覺 (這也與之前想法有所關聯) ，特定的人說出的話總是會對人生有所影響，這使得我暫時性的擁有可能對部分事情的顧慮。\n不知不覺打了挺多字，雖然還有一些想說的，還是打住比較好吧。說到這突然就理解之前看到的部落格可能會出一些自己的個人總結之類的了 (最近看的也就是 翠翠 的了)\n預覽看了下怎麼快比本文長了\n9 ソフトウェアのテスト工程において、バグ管理図を用いて、テストの進捗状況とソフトウェアの品質を判断したい。このときの考え方のうち、最も適切なものはどれか。\nア　テスト工程の前半で予想以上にバグが摘出され、スケジュールが遅れたので、スケジュールの見直しを行い、五日遅れでテストが終了すると判断した。\nイ　テスト項目がスケジュールどおりに消化され、かつ、バグ摘出の累積件数が増加しなければ、ソフトウェアの品質は高いと判断できる。\nウ　テスト項目消化の累積件数、バグ摘出の累積件数及び未解決バグの件数の全てが変化しなくなった場合は、解決困難なバグに直面しているかどうかを確認する必要がある。\nエ　バグ摘出の累積件数の推移とテスト項目の未消化件数の推移から、テスト終了の時期をほぼ正確に予測できる。\n題目翻譯：在軟體的測試階段，想透過使用缺陷管理圖來判斷測試進度和軟體品質。下列關於這種方法的描述中，最合適的是哪一個\nア　由於測試階段的前半部分發現的缺陷超過預期，導致進度延遲，因此重新審視了進度計劃，判斷測試將延遲五天完成。\nイ　如果測試項目按計劃完成，且缺陷的累計發現數量沒有增加，可以認為軟體品質較高。\nウ　當測試項目的累計完成數量、缺陷累計發現數量和未解決缺陷數量都不再變化時，有必要確認是否遇到難以解決的缺陷。\nエ　透過缺陷累計發現數量的變化趨勢和測試項目未完成數量的變化趨勢，可以較準確地預測測試結束時間。\n在測試進度和品質管理中，缺陷管理圖用於視覺化缺陷的累積趨勢和測試的完成情況，透過分析這些趨勢，開發團隊可以更好地了解測試的進展和品質狀況。這題 ア 與缺陷管理圖無關，イ 本身錯誤。剩下的兩個選項描述都是正確的，參考答案是 ウ。可能題目是想判斷軟體的進展與品質，這個選項比較符合吧 (我也不是很理解)\n10 故障の予防を目的とした解析手法であるFMEAの説明はどれか。\nア　個々のシステム構成要素に起こり得る潜在的な故障モードを特定し、それらの影響度を評価する。\nイ　故障を、発生した工程や箇所などで分類して分析し、改善すべき工程や箇所を特定する。\nウ　発生した故障について、故障の原因に関係するデータ、事象などを収集し、”なぜ”を繰り返して原因を掘り下げ、根本的な原因を追究する。\nエ　発生した故障について、その引き金となる原因を列挙し、それらの関係を木構造で表現する。\n題目翻譯：以下哪項是為了預防故障而進行的 FMEA (失效模式與影響分析) 方法的說明\nア　識別系統各個組成要素中可能發生的潛在故障模式，並評估它們的影響程度。\nイ　對故障按照發生的程序或位置等進行分類分析，並確定需要改進的程序或位置。\nウ　針對發生的故障，收集與故障原因相關的資料和事件，並不斷追問「為什麼」，以深入探討根本原因。\nエ　針對發生的故障，列舉其誘發原因，並將這些關係以樹狀結構表示出來。\nFMEA (Failure Mode and Effects Analysis，失效模式與影響分析) 是一種系統化的方法，旨在識別系統或元件中的潛在故障模式、評估其影響，並採取措施預防潛在故障的發生。它主要應用於預防性維護和設計改進。因此答案是 ア\nイ 是故障分類分析方法；ウ 是 RCA (根本原因分析)；エ 是 FTA (故障樹分析)\n11 JIS X 0160:2021 (ソフトウェアライフサイクルプロセス) によれば、廃棄プロセスのタスクのうち、アクティビティ“廃棄を確実化する”において実施すべきタスクはどれか。\nア　選定されたソフトウェアシステム要素を再利用、再生利用、再調整、分解修理、保管又は破壊する。\nイ　ソフトウェアシステムの廃棄戦略を定義する。\nウ　ソフトウェアシステム又は要素を不活化して取り除くための準備する。\nエ　廃棄後の、人の健康、安全性、セキュリティ及び環境への有害な状況が識別されて対処されていることを確認する。\n題目翻譯：根據 JIS X 0160:2021 (軟體生命週期程序) ，在廢棄程序的任務中，應執行「確保廢棄」的活動中的哪項任務\nア　對選定的軟體系統元素進行再利用、回收、重新調整、拆解修復、保管或銷毀。\nイ　定義軟體系統的廢棄策略。\nウ　為停用並移除軟體系統或其組件做好準備。\nエ　確認廢棄後不會對人類健康、安全、資訊安全及環境造成有害影響。\nア 在描述的是具體的廢棄操作方式，屬於廢棄程序的具體任務；イ 是制定廢棄策略的程序，屬於廢棄活動的計劃和策略制定階段；ウ 是在廢棄前的工作；エ 確保了不會產生負面影響，符合題意。因此答案是 エ\n12 JIS X 0160:2021 (ソフトウェアライフサイクルプロセス) によれば、ライフサイクルモデルの目的及び成果を達成するために、ライフサイクルプロセスを修正するか、又は新しいライフサイクルプロセスを定義することを何というか。\nア　シミュレーション\nイ　修整（Tailoring）\nウ　統治（Governance）\nエ　ベンチマーキング\n題目翻譯：根據 JIS X 0160:2021 (軟體生命週期程序) ，為了實現生命週期模型的目的和成果，對生命週期程序進行修改或定義新的生命週期程序的行為稱為什麼\nア　Simulation (模擬)\nイ　Tailoring (修整/裁剪)\nウ　Governance (治理)\nエ　Benchmarking (基準測試/標竿管理)\nSimulation (模擬) 指透過模型來模擬系統的行為；Tailoring (修整) 指根據特定需求對現有的生命週期程序進行調整或定義新的程序，以適應專案的目標和成果；Governance (治理) 指對組織、專案的管理和監督；Benchmarking (基準測試) 指對比最佳實踐或行業標準，以改進效能。因此答案是 イ\n13 IT 投資に対する評価指標の設定に際し、バランススコアカードの手法を用いてKPIを設定する場合に、内部ビジネスプロセスの視点に立ったKPIの例はどれか。\nア　ITリテラシ向上のための研修会の受講率を100％とする。\nイ　売上高営業利益率を前年同期比5％アップとする。\nウ　顧客クレーム件数を1か月当たり20件以内とする。\nエ　注文受付から製品出荷までの日数を3日短縮とする。\n題目翻譯：在設定 IT 投資的評估指標時，如果使用平衡計分卡的方法設定 KPI，那麼從內部業務流程的視角來看，以下哪項是 KPI 的示例\nア　將 IT 素養提高的培訓出席率設為 100%\nイ　將營業利潤率比去年同期提高 5%\nウ　將客戶投訴數量控制在每月 20 件以內\nエ　將從訂單接受到產品出貨的天數縮短 3 天\n平衡計分卡 (Balanced Scorecard，簡稱 BSC) 是一種策略管理和績效衡量工具，用於幫助組織從多維度評估和提升其整體績效。它透過將傳統的財務指標與非財務指標相結合，提供了一種平衡的管理方式，使企業能夠從更全面的角度來設定和評估策略目標，確保長期策略與日常營運的有機結合。主要從四個方面設定：\n財務觀點：關注財務表現和目標，比如收入增長、成本控制、利潤率等。傳統財務指標如 ROI (投資報酬率) 也屬於這一觀點 客戶觀點：關注客戶的滿意度和市場佔有率，指標可能包括客戶滿意度、投訴數量、客戶保持率等，用以衡量客戶的體驗和忠誠度 內部業務流程觀點：關注組織內部的營運流程效率，指標可能包括生產週期、訂單處理時間、品質控制等，這個觀點旨在優化企業內部的關鍵流程和效率 學習與成長觀點：關注員工發展和組織創新，指標可能包括培訓參加率、員工技能提升、員工滿意度等，確保企業擁有持久發展的動力和創新能力 因此答案是 エ\n14 組込みシステム開発において、製品に搭載するLSIを新規に開発する。LSI設計を自社で行い、LSI製造を外部に委託する場合の委託先として、適切なものはどれか。\nア　IPプロバイダ\nイ　デザインハウス\nウ　ファウンドリ\nエ　ファブレスメータ\n題目翻譯：在嵌入式系統開發中，計劃新開發搭載在產品上的 LSI (大型積體電路) 。若 LSI 的設計由本公司負責，而 LSI 的製造委外，作為承接方適當的是哪個\nア　IP Provider\nイ　Design House\nウ　Foundry (晶圓代工)\nエ　Fabless Manufacturer (無廠半導體商)\nIP Provider 指提供 LSI 設計中所需的智慧財產權 (IP) 模組的公司，主要提供各種半導體設計所用的預製 IP 模組，但不負責實際的晶片生產製造；Design House 指幫助其他公司完成 LSI 設計的公司；Foundry 指專門負責生產 LSI 等半導體晶片的公司，為沒有生產能力的設計公司提供製造服務；Fabless Manufacturer 指無工廠的半導體公司，通常負責晶片設計，而把生產委外給 Foundry 公司進行。因此答案選 ウ\n15 ラボ契約の特徴はどれか。\nア　依頼元がベンダ企業側の作業担当者を指名して直接指揮命令を行う契約であり、ベンダ企業はこれを前提に要員を割り当てる。\nイ　依頼元は、契約に基づきスキルや人数などの準備を満たすように要員を確保することをベンダ企業に求めるかわりに一定以上の発注を約束する。\nウ　開発したシステムによって依頼元が将来獲得する売上や利益をベンダ企業にも分配することを条件に、開発時のベンダ企業への発注金額を抑える。\nエ　ベンダ企業が契約で定めた最低発注工数を下回って作業を完了した場合には、実稼働工数に基づいて請求することが求められる。\n題目翻譯：實驗室合約 (Lab Contract) 的特點是什麼\nア　委託方指名供應商企業的工作人員並直接指揮命令的合約，供應商企業根據此要求分配人員。\nイ　委託方根據合約要求供應商企業確保符合技能、人數等準備條件，委託方則承諾至少達到一定數量的訂單。\nウ　以將來由所開發的系統獲得的銷售額或利潤分配給供應商企業為條件，從而壓低開發時對供應商企業的發包金額。\nエ　如果供應商企業完成的實際工作工時低於合約中規定的最低發包工時，則要求根據實際工作工時進行結算。\nLab Contract 指的是一種常見於 IT 行業的長期人力資源委外形式。在該合約下，供應商根據委託方的需求 (例如技能或人數) ，分配專門的人員團隊並派駐在委託方處，委託方直接指揮這些人員。此類合約通常不針對具體專案，而是將供應商的人員資源作為長期委外資源。因此答案選 イ。另外 ウ 是收益共享型合約\n","date":"2024-11-04T23:29:15+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/192/","title":"2022 SA am2 -09-15"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 引言 2022 SA am2\n01-08: http://127.0.0.1:4000/zh-tw/archives/191 09-15: http://127.0.0.1:4000/zh-tw/archives/192 16-20: http://127.0.0.1:4000/zh-tw/archives/193 21-25: http://127.0.0.1:4000/zh-tw/archives/194 這份專門試卷難度倒是還好，不過還是有我學過的內容，想必經過一定的學習後我應該可以通過選擇題，希望能早點做完後看看下午題，這才是我合格的關鍵。\n說到這裡，我覺得共通一我的做法很有問題，完全看不懂的情況下做題完全沒有意義，還是慢慢一題一題做比較好。之前我做完後在寫文章解析時，倒是想著快點完成，導致那張試卷幾乎相當於白做，畢竟剛開始一題一題慢慢做也沒關係。\n碎碎念 最近突然覺得學習彷彿是一種連結，靈感來源於語言的學習就是一種將事物與語言的連結，而學習的東西是一種抽象的連結，針對於某種輸入，產生某種輸出，通過不斷地重複加深這種連結。比較直觀的就是知識點的關聯，從某一點推出另一點，彷彿就是兩個知識之間的連結，在看過或者自己推出這個連結後將這種連結加深，這就類似事物與語言詞彙的連結，從而讓人掌握了這個事物，或者說這種連結後，也就掌握了此知識。（當然只是隨便一想而已，無相應證明。事實上我聽到的多數觀點或論據也可能是基於不夠嚴謹的證明，從自己的一段經歷推導出來的。人基於自己的經歷來形成自己的觀點，沒有見過的事物是無法想像的。不過有一個例外，可能就是夢吧，夢確實可能是自己到了某個世界遊歷，當然並不嚴謹，這還是最近我看到一個小說是進入某世界隨機出現在那個世界的某處，然後經歷一番後若有完成特殊條件可以保留那個世界的部分記憶有所收穫，對於自己做的夢倒也是如此從而讓我有了這個推斷。但事後仔細回想後，倒是可能因為睡著後大腦可以專注於想像，此時想像力達到巔峰，從而完成自己醒著時候無法想像到的。比如 DNA 雙螺旋結構的發現人也是從夢中得到的靈感）\n1 アジャイル開発の初期段階において、プロジェクトの目的、スコープなどに対する共通認識を得るために、あらかじめ設定されている設問と課題について関係者が集まって確認し合い、その成果を共有する手法はどれか。\nア　アジャイルモデリング\nイ　インセプションデッキ\nウ　プランニングポーカ\nエ　ユーザストーリマッピング\n題目翻譯：在敏捷開發的初期階段，為了在專案的目的、範圍等方面達成共識，相關人員會聚集在一起確認預先設定的問題與課題，並共享成果。這種方法是哪一種？\nア agile modeling (敏捷建模)\nイ Inception Deck (創始手冊)\nウ planning poker (規劃撲克)\nエ user story mapping (使用者故事對照)\nInception Deck 是一種重要的方法，尤其在專案的初始階段使用，以確保團隊對專案的目的和範圍形成共識。團隊會事先確定並探討一些關鍵性的問題（如專案的目標、潛在風險、成功標準等），這能夠幫助所有團隊成員對專案的整體方向和邊界有清晰的理解並達成一致。因此，正確答案是 イ。\n2 ソフトウェアパターンのうち、GoFのデザインパターンの説明はどれか。\nア　Javaのパターンとして、引数オブジェクト、オブジェクトの可変性などで構成される。\nイ　オブジェクト指向開発のためのパターンであって、生成、構造、振る舞いの三つのカテゴリに分類される。\nウ　構造、分散システム、対話型システム及び適合型システムの四つのカテゴリに分類される。\nエ　抽象度が異なる要素を分割して階層化するためのLayers、コンポーネント分割のためのBrokerなどで構成される。\n題目翻譯：在軟體模式中，GoF (Gang of Four) 設計模式的描述是哪一個？\nア Java 模式，由參數物件和物件的可變性等構成。\nイ 物件導向開發的模式，分為生成 (Creational)、結構 (Structural) 和行為 (Behavioral) 三類。\nウ 分為結構、分散式系統、互動式系統及適應性系統四類。\nエ 為了將不同抽象層次的元素分離並階層化，包含 Layers、Broker 等。\nGoF 的設計模式是由四位軟體工程師提出的經典設計模式，專門用於物件導向程式設計。它將設計模式分為三大類：生成（創建）、結構、行為，用於解決常見的物件導向設計問題。因此，正確答案是 イ。\n我去搜了下 相關介紹 ，貌似就是 我之前寫的設計模式 的由來吧。\n3 Pattern-Oriented Software Architecture (POSA) のアーキテクチャパターンのうち、ソフトウェアをメタレベルとベースレベルの二つのレベルに分割し、ソフトウェアの構造と振る舞いとを動的に変更できる仕組みを提供しているものはどれか。\nア　Broker\nイ　Microkernel\nウ　Model-View-Controller\nエ　Reflection\n題目翻譯：在模式導向軟體架構 (POSA) 的架構模式中，將軟體分為元層 (meta level) 和基礎層 (base level) 兩個層級，並提供一種能夠動態改變軟體結構和行為的機制的是哪一種？\nア Broker (經紀人/代理)\nイ Microkernel (微核心)\nウ Model-View-Controller (模型-視圖-控制器)\nエ Reflection (反射)\nBroker 模式是一種分散式系統架構模式，旨在將系統的不同組件（如用戶端和伺服器）解耦合，透過 Broker 進行通訊。Broker 充當媒介的角色，負責傳遞訊息並管理遠端服務的呼叫。\nMicrokernel 模式通常用於作業系統設計，將核心功能（如記憶體管理、行程管理）保留在微核心中，而將其他選用功能作為獨立模組來實現，能夠動態載入或解除載入。\nModel-View-Controller (MVC) 模式是一種常見的互動式系統架構模式，用於分離應用程式的商業邏輯 (Model)、使用者介面 (View) 和使用者輸入控制 (Controller)。MVC 主要目的是解耦顯示邏輯和商業邏輯，並沒有提供動態改變軟體結構和行為的機制。\nReflection 模式是一種將軟體分為「元層」和「基礎層」兩層的架構模式，元層包含描述系統結構和行為的元資料，而基礎層負責執行實際的商業邏輯。透過反射模式，軟體可以動態修改其結構和行為，以適應不同的需求和場景。這種模式常用於需要高擴充性和靈活性的系統。因此，正確答案是 エ。\n4 組込みシステムでDBMSを用いるときには、通信のオーバヘッド、通信負荷の発生を防ぐこと、必要なメモリ容量をリソース制限内に抑えることなどを目的として、インプロセスデータベースを用いることがある。このインプロセスデータベースの説明として、適切なものはどれか。\nア　クライアントサーバ形式のクライアントとなるアプリケーションプログラムとソケットを介して通信し、SQLを用いて処理を記述する。\nイ　データベースエンジンはライブラリ形式で提供され、アプリケーションプログラムとリンクされて同一メモリ空間で動作する。\nウ　データベースの全体をメモリ上に配置して、データベース処理を高速化する。\nエ　一つのテーブルを一つのファイルで管理し、アプリケーションプログラムからはファイル入出力のAPIで操作する。\n題目翻譯：在嵌入式系統中使用 DBMS 時，常常為了防止通訊開銷 (Overhead)、通訊負荷的產生，並將必要的記憶體容量控制在資源限制範圍內，而使用程序內資料庫 (In-process database)。關於這種程序內資料庫的描述，正確的是哪一個？\nア 透過通訊端 (Socket) 與作為用戶端的應用程式進行通訊，並使用 SQL 進行處理。\nイ 資料庫引擎以函式庫 (Library) 的形式提供，與應用程式連結，在同一記憶體空間中執行。\nウ 將整個資料庫載入到記憶體中，以加快資料庫處理速度。\nエ 將一個資料表管理為一個檔案，並透過檔案 I/O API 從應用程式進行操作。\n程序內資料庫 (インプロセスデータベース) 是指資料庫引擎作為函式庫檔案與應用程式連結，共享同一記憶體空間。這種設計避免了用戶端-伺服器模式帶來的通訊開銷和負載，適合資源受限的嵌入式系統。\nア 選項描述了用戶端-伺服器架構的資料庫，通常透過網路通訊端通訊；ウ 選項描述了「記憶體資料庫」，即將資料庫全部載入至記憶體以提高效能；エ 選項描述了一種基於檔案的資料庫管理方法，通常用於檔案資料庫。因此，正確答案是 イ。\n5 デザインパターンのなかのストラテジパターンを用いて、帳票出力のクラス図のとおりに設計した。適切な説明はどれか。\nア　クライアントは、使用したいフォーマットに対応する、帳票出力ストラテジクラスのサブクラスを意識せずに利用できる。\nイ　新規フォーマット用のアルゴリズムの追加が容易である。\nウ　帳票出力ストラテジクラスの中で、どのフォーマットで帳票を出力するかの振り分けを行っている。\nエ　帳票出力のアルゴリズムは、コンテキストクラスの中に記述する。\n題目翻譯：使用策略模式 (Strategy Pattern) 設計了報表輸出的類別圖。下列哪項描述是正確的？\nア 用戶端可以在不關注具體策略子類別的情況下使用相應的報表輸出格式。\nイ 可以輕鬆添加用於新格式的演算法。\nウ 報表輸出策略類別負責選擇使用哪種格式輸出報表。\nエ 報表輸出的演算法應寫在 Context 類別（上下文類別）中。\n題目是使用策略模式實現了一個多格式報表的分發。策略模式的設計原則是將演算法的實現和使用分離，使得可以在不修改用戶端程式碼的情況下切換或增加不同的演算法。同時我也寫過策略模式的文章： https://blog.yexca.net/zh-tw/archives/137 策略模式的設計使得新演算法的增加非常方便，只需實作新的具體策略類別並與現有結構整合即可。因此，正確答案是 イ。\n6 モジュール間のデータの受渡し方法のうち、最も低いモジュール結合度となるものはどれか。\nア　単一のデータ項目を大域的データで受け渡す。\nイ　単一のデータ項目を引数で受け渡す。\nウ　データ構造を大域的データで受け渡す。\nエ　データ構造を引数で受け渡す。\n題目翻譯：以下關於模組之間的資料傳遞方法，哪一種方式的模組耦合度最低？\nア 使用全域資料傳遞單一資料項。\nイ 使用參數傳遞單一資料項。\nウ 使用全域資料傳遞資料結構。\nエ 使用參數傳遞資料結構。\n這題是考程式的耦合度的，我也寫過一篇文章： https://blog.yexca.net/zh-tw/archives/145#耦合 傳遞單一資料值為資料耦合 (Data Coupling)，傳遞資料結構為標記耦合 (Stamp Coupling)，全域參數應該屬於公共耦合 (Common Coupling)，其中資料耦合的耦合度最低。因此，正確答案是 イ。\n7 既存システムを基に、新システムのモデル化を行う場合のDFD作成の手順として、適切なものはどれか。\nア　現物理モデル -\u0026gt; 現論理モデル -\u0026gt; 新物理モデル -\u0026gt; 新論理モデル\nイ　現物理モデル -\u0026gt; 現論理モデル -\u0026gt; 新論理モデル -\u0026gt; 新物理モデル\nウ　現論理モデル -\u0026gt; 現物理モデル -\u0026gt; 新物理モデル -\u0026gt; 新論理モデル\nエ　現論理モデル -\u0026gt; 現物理モデル -\u0026gt; 新論理モデル -\u0026gt; 新物理モデル\n題目翻譯：基於現有系統進行新系統建模時，建立資料流圖 (DFD) 的步驟順序應為何？\nア 現實體模型 -\u0026gt; 現邏輯模型 -\u0026gt; 新實體模型 -\u0026gt; 新邏輯模型\nイ 現實體模型 -\u0026gt; 現邏輯模型 -\u0026gt; 新邏輯模型 -\u0026gt; 新實體模型\nウ 現邏輯模型 -\u0026gt; 現實體模型 -\u0026gt; 新實體模型 -\u0026gt; 新邏輯模型\nエ 現邏輯模型 -\u0026gt; 現實體模型 -\u0026gt; 新邏輯模型 -\u0026gt; 新實體模型\n這題盲猜選 イ。一般建立資料流圖需要從現有系統的具體實作抽象出業務需求（實體到邏輯），然後再基於現有業務需求改進出邏輯模型，最後實作新的邏輯需求（邏輯到實體）。\n8 ある購買システムの開発において、開発者が行った探索的テストの例として、適切なものはどれか。\nア　過去に購買システムを開発した経験に基づいて、入力項目間の関連チェックの不備を検出できそうなデータパターンを推測し、テストケースを事前に作成してテストした。\nイ　数量の範囲に応じて適用する商品価格が正しいかどうかを確認するために、各範囲の数量の中央の値を用いたテストケースを作成してテストした。\nウ　組織変更の前後で組織名が正しく印刷されるかどうかを確認するために、新組織の有効開始日とその前日とを発注日とするテストケースを事前に作成してテストした。\nエ　入力値の組合せが無効なときは伝票を作成しないことを確認するために、幾つかの代表的な入力値の組合せをテストし、その結果に基づいて次のテストケースを作成してテストしを繰り返した。\n題目翻譯：在一個採購系統的開發中，作為開發者進行的探索性測試的合適例子是哪一個？\nア 根據過去開發採購系統的經驗，推測出可能檢測到輸入項之間關係不完善的測試資料模式，預先建立測試案例並進行了測試。\nイ 為了確認根據數量範圍套用的商品價格是否正確，使用每個範圍中間值的測試案例並進行了測試。\nウ 為了確認組織變更前後的組織名稱是否正確列印，預先建立了使用新組織有效開始日和前一日作為下單日的測試案例並進行了測試。\nエ 為了確認當輸入值組合無效時不產生單據，測試了幾個具代表性的輸入值組合，並根據結果反覆建立新的測試案例進行測試。\n探索性測試是一種在測試過程中動態設計和執行測試的方式，不依賴事先確定的測試案例，而是基於對系統的理解和觀察結果即時調整測試方案。探索性測試的特點在於測試案例並非完全預設，而是根據測試結果不斷調整和補充。\nア、イ、ウ 選項中測試案例都是事先建立好的，符合傳統的事前設計測試，不符合探索性測試的特點。所以正確答案是 エ。\n","date":"2024-11-03T23:11:52+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/191/","title":"2022 SA am2 -01-08"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 引言 2022 SA am1\n01-02: https://blog.yexca.net/zh-tw/archives/184 03-05: https://blog.yexca.net/zh-tw/archives/185 06-10: https://blog.yexca.net/zh-tw/archives/186 11-15: https://blog.yexca.net/zh-tw/archives/189 16-30: https://blog.yexca.net/zh-tw/archives/190 整張試卷寫下來大部分是軟體設計師的感覺，估計有些共通的科目對軟體開發要求較低吧，專門的試卷估計會難一點。大部分題目專有名詞看不懂，但是翻譯過來後是可以會做的，專有名詞的記憶很重要呢。\n第 16 問 次の流れ図において、判定条件網羅（分岐網羅）を満たす最小のテストケースの組みはどれか。\nア　(1) A=0, B=0 (2) A=1, B=1\nイ　(1) A=1, B=0 (2) A=1, B=1\nウ　(1) A=0, B=0 (2) A=1, B=1 (3) A=1, B=0\nエ　(1) A=0, B=0 (2) A=0, B=1 (3) A=1, B=0\n這題是最少需要多少個測試案例才能將每個分支都測試到，就不解析了，答案是選項 イ。\n第 17 問 問題が発生していないが、プログラムの仕様書と現状のソースコードとの不整合を解消するために、リバースエンジニアリングの手法を使って仕様書を作成し直す。これはソフトウェア保守のどの分類に該当するか。\nア　完全化保守\nイ　是正保守\nウ　適応保守\nエ　予防保守\n題目翻譯：問題尚未發生，但為了消除程式的規格說明書與當前原始碼之間的不一致，使用逆向工程的方法重新編寫規格說明書。這屬於軟體維護的哪種分類？\nア　完善性維護\nイ　更正性維護\nウ　適應性維護\nエ　預防性維護\n死去的記憶開始攻擊我，學過但忘光了。完善性維護是指改進軟體功能、效能或其他品質屬性以符合新的標準或要求，即在原本功能的基礎上進行增強與完善；更正性維護是指修復軟體中的缺陷，糾正軟體異常或錯誤；適應性維護是指使軟體適應執行環境的變化，例如相容新的作業系統或硬體；預防性維護是指在未發生問題的情況下，進行維護以預防潛在問題的產生。所以答案為選項 エ。\n第 18 問 ある組織では、プロジェクトのスケジュールとコストの管理にアーンドバリューマネジメントを用いている。期間10日間のプロジェクトの、5日目の終了時点の状況は表のとおりである。この時点でのコスト効率が今後も続くとしたとき、完成時総コスト見積り（EAC）は何万円か。\n管理項目 金額（万円） 完成時総予算（BAC） 100 プランドバリュー（PV） 50 アーンドバリュー（EV） 40 実コスト（AC） 60 ア　110\nイ　120\nウ　135\nエ　150\n題目翻譯：某組織使用實獲值管理 (earned value management) 來管理專案的進度與成本。在一個為期 10 天的專案中，第 5 天結束時的情況如下表所示。如果此時的成本效率在今後繼續保持，那麼完成時的總成本估計 (EAC) 是多少萬日圓？\n管理項目 金額 (萬日圓) 完成時總預算 (BAC) 100 計畫價值 (PV) 50 實獲值 (EV) 40 實際成本 (AC) 60 這題是沒學過的東西呢。完成時的總成本估計 (EAC) 計算方法為：\n$$ EAC=\\frac{BAC}{CPI} $$其中 CPI (成本績效指數) 為：\n$$ CPI=\\frac{EV}{AC} $$帶入數值計算：\n$$ \\begin{align} CPI\u0026=\\frac{40}{60}=\\frac{2}{3} \\\\ EAC\u0026=\\frac{100}{\\frac{2}{3}}=150 \\end{align} $$所以答案為選項 エ。\n第 19 問 ソフトウェア開発プロジェクトにおいて、表の全ての作業を完了させるために必要な期間は最短で何日間か。\n作業 作業の開始条件 所要日数（日） 要件定義 なし 30 設計 要件定義の完了 20 製造 設計の完了 25 テスト 製造の完了 15 利用者マニュアル作成 設計の完了 20 利用者教育 テストの完了及び利用者マニュアル作成の完了 10 ア　80\nイ　95\nウ　100\nエ　120\n題目翻譯：在軟體開發專案中，完成表中所有工作所需的最短時間是多少天？\n工作 前提條件 所需天數 需求定義 無 30 設計 需求定義完成 20 製造 設計完成 25 測試 製造完成 15 使用者手冊編寫 設計完成 20 使用者教育訓練 測試與使用者手冊編寫完成 10 這題畫出那個圖就行了，挺簡單的一個圖。答案為選項 ウ。\n第 20 問 ITIL 2011 edition では、可用性管理における重要業績評価指標（KPI）の例として、”保守性を表す指標値”の短縮を挙げている。保守性を表す指標に該当するものはどれか。\nア　一定時間内での中断の数\nイ　平均故障間隔\nウ　平均サービス・インシデント間隔\nエ　平均サービス回復時間\n題目翻譯：在 ITIL 2011 版中，可用性管理的關鍵績效指標 (KPI) 中包括了「表示可維護性的指標值」的縮寫。下列選項中，屬於表示可維護性的指標是哪一個？\nア：一定時間內的中斷次數\nイ：平均故障間隔 (MTBF)\nウ：平均服務事件間隔 (MTBSI)\nエ：平均服務恢復時間 (MTTR)\n在 ITIL 可用性管理中，可維護性通常表示系統在發生故障後恢復或修復的能力，而非故障的頻率或間隔。而平均服務恢復時間 (MTTR, Mean Time to Restore Service) 用於描述故障後的恢復速度，表示一旦發生故障，系統平均需要花多少時間恢復。所以答案為選項 エ。\n第 21 問 基幹業務システムの構築及び運用において、データ管理者（DA）とデータベース管理者（DBA）を別々に任命した場合のDAの役割として、適切なものはどれか。\nア　業務データ量の増加傾向を把握し、ディスク装置の増設などの計画して実施する。\nイ　システム開発の設計工程では、主に論理データベース設計を行い、データ項目を管理して標準化する。\nウ　システム開発のテスト工程では、主にパフォーマンスチューニングを担当する。\nエ　システム障害が発生した場合には、データの復旧や整合性のチェックなどを行う。\n題目翻譯：在建置與營運核心業務系統時，如果分別指派了資料管理者 (DA) 與資料庫管理員 (DBA)，那麼 DA 的適當職責是什麼？\nア：掌握業務資料量的增長趨勢，計畫並實施增加磁碟設備等措施。\nイ：在系統開發的設計階段，主要進行邏輯資料庫設計，並管理與標準化資料項目。\nウ：在系統開發的測試階段，主要負責效能優化 (Tuning)。\nエ：在系統故障發生時，進行資料恢復與一致性檢查。\n資料管理者 (DA) 主要負責邏輯資料管理，包括制定資料標準、定義資料項目以及邏輯資料庫設計。DA 的職責是確保資料一致性與標準化，而資料庫管理員 (DBA) 則通常負責硬體資源管理、效能優化與資料復原等任務。所以答案為選項 イ。\n第 22 問 監査証拠の入手と評価に関する記述のうち、システム監査基準（平成30年）に照らして、適切でないものはどれか。\nア　アジャイル手法を用いたシステム開発プロジェクトにおいては、管理用ドキュメントとしての体裁が整っているものだけが監査証拠として利用できる。\nイ　外部委託業務実施拠点に対する監査において、システム監査人が委託先から入手した第三者の保証報告書に依拠できると判断すれば、現地調査を省略できる。\nウ　十分かつ適切な監査証拠を入手するための本調査の前に、監査対象の実態を把握するための予備調査を実施する。\nエ　一つの監査目的に対して、通常は、複数の監査手続きを組み合わせ監査を実施する。\n題目翻譯：在獲取與評估稽核證據的描述中，根據《系統稽核標準（平成 30 年）》的標準，以下哪一項是不適當的？\nア：在使用敏捷開發方法進行系統開發專案時，只有格式完善的管理文件才能用作稽核證據。\nイ：在對委外業務執行地點的稽核中，如果系統稽核員判斷可以依賴從受託方獲得的第三方保證報告，則可以省略現場調查。\nウ：為了獲取充分且適當的稽核證據，在正式調查之前，進行預備調查以瞭解稽核對象的實際情況。\nエ：針對一個稽核目的，通常結合多種稽核程序來進行稽核。\n這標準真的不知道了，系統稽核標準中並未規定敏捷專案的稽核證據必須為格式完善的管理文件。實際上，在敏捷專案中，非正式文件（如會議記錄、程式碼庫、看板等）也可以作為有效的稽核證據，以反映專案的實際情況。所以答案為選項 ア。\n第 23 問 BPOの説明はどれか。\nア　災害や事故で被害を受けても、重要事業を中断させない、又は可能な限り中断期間を短くする仕組みを構築すること\nイ　社内業務のうちコアビジネスでない事業に関わる業務の一部又は全部を、外部の専門的な企業に委託すること\nウ　製品の基準生産計画、部品表及び在庫情報を基に、資材の所要量と必要な時期を求め、これを基準に資材の手配、納入の管理を支援する生産管理手法のこと\nエ　プロジェクトを、戦略との適合性や費用対効果、リスクといった観点から評価を行い、情報化投資のバランスを管理し、最適化を図ること\n題目翻譯：以下哪項是對 BPO 的解釋？\nア：即使在災害或事故中受到損害，仍能確保重要業務不中斷，或盡可能縮短中斷時間的機制的建置。\nイ：將公司內部業務中非核心業務的一部分或全部委託給外部專業公司處理。\nウ：基於產品的基準生產計畫、零件表與庫存資訊，確定材料的需求量與所需時間，並以此為基準支援材料的採購與交付管理的生產管理方法。\nエ：從策略適配性、成本效益與風險等角度對專案進行評估，管理資訊化投資的平衡並進行優化。\nBPO (Business Process Outsourcing，業務流程委外) 是指將公司內部的非核心業務委託給外部專業公司處理，以集中資源在核心業務上。所以答案為選項 イ。\nア 選項為業務連續性計畫 (BCP, Business Continuity Plan)；ウ 選項中為物料需求計畫 (MRP, Material Requirements Planning)；エ 選項為專案組合管理 (PPM, Project Portfolio Management)。\n第 24 問 IT投資効果の評価方法において、キャッシュフローベースで初年度の投資によるキャッシュアウトを何年後に回収できるかという指標はどれか。\nア　IRR(Internal Rate of Return)\nイ　NPV(Net Present Value)\nウ　PBP(Pay Back Period)\nエ　ROI(Return On Investment)\n題目翻譯：在 IT 投資效益的評價方法中，基於現金流量來計算初始投資的現金流出在幾年後可以回收的指標是哪一個？\nア 是內部報酬率法，表示專案投資的收益率，使得淨現值為零的折現率，是衡量專案收益水準的常用指標；イ 是淨現值法，透過計算未來現金流的現值總和減去初始投資額，用以評估專案的整體價值；ウ 是回收期間法，題目答案；エ 是投資報酬率，透過投資收益與投資成本的比率，評估專案的獲利能力。所以選 ウ。\n第 25 問 UMLの図のうち、業務要件定義において、業務フローを記述する際に使用する、処理の分岐や並行処理、処理の同期などを表現できる図はどれか。\nア　アクティビティ図\nイ　クラス図\nウ　状態マシン図\nエ　ユースケース図\n題目翻譯：在 UML 的圖表中，用於業務需求定義並描述業務流程，可以表達處理的分支、並行處理以及處理同步的圖是哪一個？\nア：活動圖 (Activity Diagram)\nイ：類別圖 (Class Diagram)\nウ：狀態機圖 (State Machine Diagram)\nエ：使用案例圖 (Use Case Diagram)\n活動圖適用於描述業務流程，能夠表示處理過程中的分支、並行處理和同步處理，因此通常用於業務需求的定義階段；類別圖用於描述系統中的類別及其屬性、方法、類別之間的關係等，它主要用於顯示系統的靜態結構；狀態機圖用於描述物件在生命週期中的狀態變化與狀態間的轉移，它適合表示物件的行為，尤其是在狀態變化和事件響應方面；使用案例圖用於描述系統的功能需求，以及系統如何與外部使用者或其他系統進行互動，使用案例圖透過表示不同的使用案例來定義系統的功能。所以選 ア。\n第 26 問 PPMにおいて、投資用の資金源として位置付けられる事業はどれか。\nア　市場成長率が高く、相対的市場占有率が高い事業\nイ　市場成長率が高く、相対的市場占有率が低い事業\nウ　市場成長率が低く、相対的市場占有率が高い事業\nエ　市場成長率が低く、相対的市場占有率が低い事業\n題目翻譯：在 PPM (產品組合管理) 中，作為投資資金來源的業務是哪一種？\nア 市場成長率高、相對市場佔有率高的業務\nイ 市場成長率高、相對市場佔有率低的業務\nウ 市場成長率低、相對市場佔有率高的業務\nエ 市場成長率低、相對市場佔有率低的業務\nPPM 中，這類業務被稱為「金牛 (Cash Cow)」。由於其市場佔有率高，可以帶來穩定的現金流，同時其市場成長率較低，通常不需要額外投資，因此可以作為其他高成長業務的資金來源。正確答案是 ウ。\n第 27 問 半導体産業において、ファブレス企業と比較したファウンドリ企業のビジネスモデルの特徴として、適切なものはどれか。\nア　工場での生産をアウトソーシングして、生産設備への投資を抑える。\nイ　自社製品の設計、マーケティングに注力し、新市場を開拓する。\nウ　自社製品の販売に注力し、売上げを拡大する。\nエ　複数の企業から生産だけを専門に請け負い、多くの製品を低コストで生産する。\n題目翻譯：在半導體產業中，與無廠半導體 (Fabless) 企業相比，代工 (Foundry) 企業的商業模式特點是什麼？\nア 將工廠的生產委外，以減少在生產設備上的投資。\nイ 專注於自家產品的設計與行銷，開拓新市場。\nウ 專注於自家產品的銷售，擴大銷售額。\nエ 專門承接多家企業的生產業務，以低成本生產大量產品。\n在半導體產業中，代工企業主要負責製造，並不設計自己的產品，而是專門為其他企業提供生產服務。這種模式使其能夠以較低的成本批量生產多種產品。正確答案是 エ。\n第 28 問 XBRLで主要な取扱いの対象とされている情報はどれか。\nア　医療機関のカルテ情報\nイ　企業の顧客情報\nウ　企業の財務情報\nエ　自治体の住民情報\n題目翻譯：在 XBRL (eXtensible Business Reporting Language) 中，主要處理的對象資訊是哪一項？\nア 醫療機構的病歷資訊\nイ 企業的客戶資訊\nウ 企業的財務資訊\nエ 地方政府的住民資訊\nXBRL 是一種用於商業與財務報告的標準化語言，旨在處理與交換公司財務數據。正確答案是 ウ。\n第 29 問 リーダシップ論のうち、PM理論の特徴はどれか。\nア　優れたリーダシップを発揮する、リーダ個人がもつ性格、知性、外観などの個人的資質の分析に焦点を当てている。\nイ　リーダシップのスタイルについて、目標達成能力と集団維持能力の二つの次元に焦点を当てている。\nウ　リーダシップの有効性は、部下の成熟（自律性）の度合いという状況要因に依存するとしている。\nエ　リーダシップの有効性は、リーダがもつバーソナリティと、リーダがどれだけ統制力や影響力を行使できるかという状況要因に依存するとしている。\n題目翻譯：在領導理論中，PM 理論的特點是哪一個？\nア 聚焦於分析展現優秀領導力的領導者個人的特質，例如性格、智力、外表等個人資質。\nイ 關於領導風格，聚焦於目標達成能力 (P) 與團隊維持能力 (M) 兩個維度。\nウ 認為領導的有效性依賴於部下成熟度（自主性）的程度這一情境因素。\nエ 認為領導的有效性取決於領導者的個性，以及其行使控制力與影響力的程度這一情境因素。\nPM 理論 (Performance-Maintenance Theory) 認為，領導風格由「P (目標達成)」與「M (團隊維持)」兩個維度組成。因此，PM 理論的特點是關注領導者在任務達成與團隊維持方面的能力。正確答案是 イ。\n第 30 問 A社は、B社と著作物の権利に関する特段の取決めをせず、A社の要求仕様に基づいて、販売管理システムのプログラム作成をB社に委託した。この場合のプログラム著作権の原始的帰属に関する記述のうち、適切なものはどれか。\nア　A社とB社が話し合って帰属先を決定する。\nイ　A社とB社の共有帰属となる。\nウ　A社に帰属する。\nエ　B社に帰属する。\n題目翻譯：A 公司在沒有與 B 公司就著作權做出特別約定的情況下，基於 A 公司的需求規格將銷售管理系統的程式編寫委託給了 B 公司。在這種情況下，關於程式著作權原始歸屬的描述中，哪一項是正確的？\nア A 公司與 B 公司透過協商決定歸屬\nイ 歸屬於 A 公司與 B 公司共同擁有\nウ 歸屬於 A 公司\nエ 歸屬於 B 公司\n在沒有特別約定的情況下，按照著作權法，委託合約中產生的作品之著作權通常歸屬於實際創作者，即 B 公司。只有在合約中明確規定著作權歸委託方 (A 公司) 時，著作權才會歸屬給 A 公司。因此正確答案是 エ。\n","date":"2024-10-28T19:04:14+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/190/","title":"2022 SA am1 -16-30"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 引言 2022 SA am1\n01-02: https://blog.yexca.net/zh-tw/archives/184 03-05: https://blog.yexca.net/zh-tw/archives/185 06-10: https://blog.yexca.net/zh-tw/archives/186 11-15: https://blog.yexca.net/zh-tw/archives/189 16-30: https://blog.yexca.net/zh-tw/archives/190 碎碎念 最近眼睛越來越疼了，看螢幕可能一小時就開始了，而且看東西很模糊，感覺需要讓眼睛休息了，不然再近視看不見真的會很難受 (要是不疼的話我應該都能更新完這張試卷了)\n第 11 問 OpenFlow を使った SDN(Software-Defined Networking) に関する記述として、適切なものはどれか。\nア　インターネットのドメイン名を管理する世界規模の分散データベースを用いて、IPアドレスの代わりに名前を指定して通信できるようにする仕組む\nイ　携帯電話網において、回線交換方式ではなく、パケット交換方式で音声通話を実現する方式\nウ　ストレージ装置とサーバを接続し、WWN(World Wide Name) によってノードやポートを識別するストレージ用ネットワーク\nエ　データ転送機能とネットワーク制御機能を論理的に分離し、ネットワーク制御を集中的に行う可能にしたアーキテクチャ\n題目翻譯：以下關於使用 OpenFlow 的 SDN (軟體定義網路) 的描述，哪一項是正確的\nア：使用一個全球分散式的資料庫來管理網際網路的網域名稱，以便可以使用名稱而非 IP 位址進行通訊。\nイ：在行動通訊網路中，不透過電路交換方式，而是透過封包交換方式實現語音通話的方式。\nウ：連接儲存裝置和伺服器，並使用 WWN（全球唯一名稱）識別節點和埠號的儲存網路。\nエ：將資料轉發功能和網路控制功能在邏輯上分離，使集中化網路控制成為可能的架構。\n選項 ア 是 DNS 的描述；イ 是行動通訊中 VoIP (基於封包交換的語音傳輸方式) 的描述；ウ 是對 SAN (儲存區域網路) 的描述。所以答案為選項 エ\n第 12 問 メッセージの送受信における署名鍵の使用に関する記述のうち、適切なものはどれか。\nア　送信者が送信者の署名鍵を使ってメッセージに対する署名を作成し、メッセージに付加することによって、受信者が送信者による署名であることを確認できようになる。\nイ　送信者が送信者の署名鍵を使ってメッセージを暗号化することによって、受信者が受信者の署名鍵を使って、暗号文を元のメッセージに戻すことができるようになる。\nウ　送信者が送信者の署名鍵を使ってメッセージを暗号化することによって、メッセージの内容が関係者以外に分からないようになる。\nエ　送信者がメッセージに固定文字列を付加し、更に送信者の署名鍵を使って暗号化することによって、受信者がメッセージの改ざん部位を特定できるようになる。\n題目翻譯：關於訊息收發中的簽章金鑰使用，以下哪項描述是正確的\nア：傳送者使用傳送者的簽章金鑰對訊息進行簽章並附加到訊息上，這樣接收者可以確認該簽章是傳送者產生的。\nイ：傳送者使用傳送者的簽章金鑰加密訊息，這樣接收者可以使用接收者的簽章金鑰將密文還原為原始訊息。\nウ：傳送者使用傳送者的簽章金鑰加密訊息，使訊息內容對非相關方不可見。\nエ：傳送者在訊息上附加固定字串，再使用傳送者的簽章金鑰加密，這樣接收者可以確定訊息被竄改的部分。\n這裡討論簽章一般是 RSA 演算法。一般用其公鑰解密，私鑰是不會洩漏的，所以選項 イ 錯誤；簽章金鑰不用作加密訊息，因為公鑰公開，任何人都是可以看到的，只用於驗證屬於傳送者，所以選項 ウ 錯誤；金鑰無法確定被竄改的部分，所以選項 エ 錯誤。答案為選項 ア\n第 13 問 クライアント証明書で利用者を確認するリバースプロキシサーバを用いて、複数のWebサーバにシングルサインオンを行うシステムがある。このシステムに関する記述のうち、適切なものはどれか。\nア　クライアント証明書を利用者のPCに送信するのは、Webサーバではなく、リバースプロキシサーバである。\nイ　クライアント証明書を利用者のPCに送信するのは、リバースプロキシサーバではなく、Webサーバである。\nウ　利用者IDなどの情報をWebサーバに送信するのは、リバースプロキシサーバではなく、利用者のPCである。\nエ　利用者IDなどの情報をWebサーバに送信するのは、利用者のPCではなく、リバースプロキシサーバである。\n題目翻譯：使用反向代理伺服器，透過用戶端憑證驗證使用者並實現對多個 Web 伺服器的單一登入系統。關於該系統的描述，以下哪項是正確的\nア：將用戶端憑證傳送到使用者的 PC 的是反向代理伺服器，而不是 Web 伺服器。\nイ：將用戶端憑證傳送到使用者的 PC 的是 Web 伺服器，而不是反向代理伺服器。\nウ：將使用者 ID 等資訊傳送到 Web 伺服器的是使用者的 PC，而不是反向代理伺服器。\nエ：將使用者 ID 等資訊傳送到 Web 伺服器的是反向代理伺服器，而不是使用者的 PC。\n這題倒是挺貼近現實的，挺多大公司都會使用吧，就像微軟的那個每次登入會單獨到一個登入的請求。用戶端的憑證儲存在用戶端，反向代理伺服器負責處理用戶端憑證的驗證，前兩個選項錯誤；在反向代理伺服器驗證完成後，向伺服器傳送使用者資訊，所以答案為選項 エ\n第 14 問 内部ネットワークのPCからインターネット上のWebサイトを参照するときに、DMZに設置したVDI (Virtual Desktop Infrastructure) サーバ上のWebブラウザを利用すると、未知のマルウェアがPCにダウンロードされるのを防ぐというセキュリティ上の効果が期待できる。この効果を生み出すVDIサーバの動作の特徴はどれか。\nア　Webサイトからの受信データを受信処理した後、IPsecでカプセル化し、PCに送信する。\nイ　Webサイトからの受信データを受信処理した後、実行ファイルを削除し、その他のデータをPCに送信する。\nウ　Webサイトからの受信データを受信処理した後、生成したデスクトップ画面の画像データだけをPCに送信する。\nエ　Webサイトからの受信データを受信処理した後、不正なコード列が検知されない場合だけPCに送信する。\n題目翻譯：當內部網路的 PC 存取網際網路上的網站時，透過使用位於 DMZ（隔離區）中的 VDI（虛擬桌面基礎架構）伺服器上的瀏覽器，可以有效防止未知惡意軟體下載到 PC 上。這種安全效果是由 VDI 伺服器的哪個操作特性產生的？\nア：從網站接收資料後，將其用 IPsec 封裝，然後傳送到 PC。\nイ：從網站接收資料後，刪除執行檔，然後將其他資料傳送到 PC。\nウ：從網站接收資料後，僅將產生的桌面螢幕影像資料傳送到 PC。\nエ：從網站接收資料後，只有在未偵測到惡意程式碼時才傳送到 PC。\n答案為選項 ウ，看名字就知道虛擬桌面只傳輸畫面。\n第 15 問 ファジングに該当するものはどれか。\nア　サーバにFINバケットを送信し、サーバからの応答を観測して、稼働しているサービスを見つけ出す。\nイ　サーバのOSやアプリケーションソフトウェアが生成したログやコマンド履歴などの解析して、ファイルサーバに保存されているファイルの改ざんを検知する。\nウ　ソフトウェアに、問題を引き起こしそうな多様なデータを入力し、挙動を監視して、脆弱性を見つけ出す。\nエ　ネットワーク上を流れるバケットを収集し、そのプロトコルヘッダやペイロードを解析して、あらかじめ登録された攻撃パターンと一致するものを検出する。\n題目翻譯：以下哪個選項符合模糊測試（Fuzzing）的描述\nア：向伺服器傳送 FIN 封包，並觀察伺服器的回應，以發現正在運行的服務。\nイ：分析伺服器的作業系統或應用軟體產生的紀錄 (Log) 和指令歷史紀錄，以偵測儲存在檔案伺服器上的檔案是否被竄改。\nウ：向軟體輸入可能引發問題的多種資料，監視其行為，並查找漏洞。\nエ：收集網路中傳輸的封包，解析其協定標頭和負載 (Payload)，偵測與預先註冊的攻擊模式相匹配的內容。\n模糊測試是一種自動化的軟體測試技術，透過向程式輸入隨機或異常資料來觸發潛在漏洞，從而偵測軟體中的錯誤和安全漏洞。Fuzzing 特別適用於發現系統中可能被忽視或未考慮到的邊界條件和異常情況。它的目標在於測試軟體在意外輸入條件下的行為，並判斷程式是否具備足夠的強健性 (Robustness) 和安全性。所以答案為選項 ウ\n選項 ア 描述的是 FIN 掃描，用於偵測目標伺服器上有哪些服務在運行，有點像 nmap 指令。選項 イ 是入侵偵測系統 (IDS) 工作的一部分。選項 エ 屬於網路入侵偵測系統 (NIDS)，常用該技術來即時監控網路流量，發現並防禦已知攻擊，但封包擷取與偵測雖能識別常見攻擊模式，但難以偵測到未知或變種攻擊。\n","date":"2024-10-26T21:41:16+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/189/","title":"2022 SA am1 -11-15"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 前言 即便寫了日文標題，這篇文章的主體並非日文。有時間的話可能會補充\n題目一： https://blog.yexca.net/zh-tw/archives/183 題目二： https://blog.yexca.net/zh-tw/archives/187 題目三：本文\n全部寫下來的感覺是，可能因為是多個專業共用的數學試題吧，線性代數不清楚，但微積分與機率論幾乎都是在引導考生完成某項結論的證明或理解某個概念。其中微積分是關於弧長參數化，機率論則是 37% 法則。如果原本就知道這些結論會非常好解題，若事先沒學過就能當場做出來的人真的很厲害。至少讓我從零開始思考的話，肯定會掛掉。\n同時因為是已有的理論，解題答案應該是對的，至於過程嘛，就不確定了 XD\n題目 來源： https://www.i.u-tokyo.ac.jp/edu/entra/examarchive.shtml 題目版權屬於東京大學所有，僅為了方便閱讀而引用，無營利行為\n現有 $n$ 名打工候選人進行面試，希望能從中錄用最合適的人選。假設 $n \\ge 2$。候選人預先已定有排名 $1$、排名 $2$、$\\cdots$、直到排名 $n$ 的絕對排名，而對於已經面試過的候選人，可以得知他們之間的相對排名。面試依序逐一進行，但候選人出現的順序是隨機決定的，事前無法得知。在錄用過程中，將根據已面試候選人之間的相對排名來決定是否錄用，並須遵守以下條件：\n在每位候選人面試後，必須立即決定是否錄用。 一旦決定錄用某位候選人，錄用過程即告結束。 無法錄用過去已被拒絕的候選人。 若到第 $n-1$ 次面試都未錄用任何人，則無條件錄用第 $n$ 位候選人。 在錄用打工人員時採取如下策略。假設 $1 \u003c r \\le n$：\n到第 $r-1$ 次面試為止，無條件拒絕所有候選人。 之後的面試中，若候選人優於前 $r-1$ 人中的最佳候選人（相對排名 $1$），則予以錄用。 在此策略下，錄用絕對排名第 $1$ 之候選人的機率記為 $P_{n}(r)$。請回答以下問題：\n（１）求 $P_{4}(2)$。\n（２）證明 $P_{10}(3)=\\frac{2}{10}(\\frac{1}{2}+\\frac{1}{3}+\\cdots+\\frac{1}{9})$。\n（３）對於 $n$ 名候選人，求在第 $k$ 次面試錄用絕對排名第 $1$ 候選人的機率。其中 $r \\le k \\le n$。\n（４）在以下遞迴式中，求出填入 $A, B$ 的表達式。\n$$ P_{n}(r)=A+B\\times P_{n}(r+1) $$其中 $A, B$ 為由 $n, r$ 及常數構成的表達式。\n（５）設 $q=r/n$。說明當 $n$ 足夠大時，$P_{n}(r)$ 可以用 $-q\\ln(q)$ 來近似。進而求出使 $-q\\ln(q)$ 取得最大值的 $q\\in (0,1]$ 之值。其中 $\\ln$ 表示自然對數。\n中文解答 背景翻譯：現希望在面試 $n$ 個候選人後找到最佳人選。其中 $n \\ge 2$。每個候選人的能力等級是確定的（最好的、次好的、⋯、最差的）。已經面試過的候選人就可以知道這些人的相對能力等級。面試是一個人接一個人進行的，但面試順序是隨機的，事前不知道。招聘單位將根據已經面試過的人的相對能力等級來確定錄用誰，並滿足以下條件：\n每個候選人面試後立即確定是否錄用 一旦決定錄用某人，則所有面試結束 過去未錄用的人不會再錄用 如果只剩一人，前面的人都不合格，則直接錄用此人 招聘單位採用以下策略，其中 $1 \u003c r \\le n$：\n前 $r-1$ 人的面試直接拒絕 之後的面試中，若有人優於前 $r-1$ 人中的最優者，則錄用 在這個策略中，選中最好的候選人的機率表示為 $P_{n}(r)$，回答以下問題：\n這題讀完之後就想到了畢導（畢導THU）的 那個如何科學有效脫單影片 ，和影片中的方法一樣，也就是 $37\\%$ 法則。題目就是該法則的描述，最後一題就是其 求解過程 。\n第一小題 題目翻譯：求 $P_{4}(2)$\n$$ \\begin{align} P_{4}(2) \u0026=\\frac{1}{4}+\\frac{1}{4} \\times \\frac{1}{2} + \\frac{1}{4} \\times \\frac{1}{3} \\\\ \u0026=\\frac{1}{4}+\\frac{1}{8}+\\frac{1}{12} \\\\ \u0026=\\frac{11}{24} \\end{align} $$這裡的算式分別代表：最優秀的人在第二位時被選中的機率、在第三位時被選中的機率，以及在第四位時被選中的機率。為了選中最優秀的人，必須保證從第 $r$ 個人開始到最優秀的人之間，沒有人比前 $r-1$ 人更優秀。這句話有點繞，我們分情況討論：\n假設最優秀的人是第一人，則直接被淘汰，選中的機率為 $0$。\n假設最優秀的人是第二人，由於從第二人開始決定是否錄用，且前面的人不可能比最優秀的人更優秀，所以選中的機率是 $1$。\n假設最優秀的人是第三人，這時有兩種情況：\n如果第二個人比第一個人優秀，那麼最優秀的人（第三人）不會被錄用（因為第二人會先被錄用）。 如果第二個人沒有第一個人優秀，那麼最優秀的人將會被錄用。 所以該情況選中的機率是 $\\frac{1}{2}$。\n假設最優秀的人是第四人，這時只有在前三人中，最優秀的是出現在前 $r-1$ 位（即第一位）時，才能保證第四人被錄用。也就是說，前三個人中的相對第一名必須落在第一位，機率是 $\\frac{1}{3}$。\n綜合以上四種情況：$P=\\frac{1}{4} \\times 0+\\frac{1}{4} \\times 1 +\\frac{1}{4} \\times \\frac{1}{2} + \\frac{1}{4} \\times \\frac{1}{3}$。\n第二小題 題目翻譯：證明 $P_{10}(3)=\\frac{2}{10}(\\frac{1}{2}+\\frac{1}{3}+\\cdots+\\frac{1}{9})$\n假設最優秀的人在第 $m$ 位 ($3 \\le m \\le 10$)。為了保證選中最優秀的人，前 $m-1$ 個人中最優秀的那個人必須出現在前兩個人中（即前 $r-1$ 人中），其機率為 $\\frac{2}{m-1}$。因此，選中最優秀的人的總機率為：\n$$ \\begin{align} P =\u0026\\frac{1}{10} \\times \\frac{2}{2}+\\frac{1}{10} \\times \\frac{2}{3}+\\frac{1}{10} \\times \\frac{2}{4}+\\frac{1}{10} \\times \\frac{2}{5}+\\\\ \u0026\\frac{1}{10} \\times \\frac{2}{6}+\\frac{1}{10} \\times \\frac{2}{7}+\\frac{1}{10} \\times \\frac{2}{8}+\\frac{1}{10} \\times \\frac{2}{9} \\\\ =\u0026\\frac{1}{10}(\\frac{2}{2}+\\frac{2}{3}+\\frac{2}{4}+\\frac{2}{5}+\\frac{2}{6}+\\frac{2}{7}+\\frac{2}{8}+\\frac{2}{9}) \\\\ =\u0026\\frac{2}{10}(\\frac{1}{2}+\\frac{1}{3}+\\frac{1}{4}+\\frac{1}{5}+\\frac{1}{6}+\\frac{1}{7}+\\frac{1}{8}+\\frac{1}{9}) \\end{align} $$當最優秀的人在前兩位時，根據策略無法選中他，所以：\n$$ \\begin{align} P_{10}(3) \u0026=\\frac{1}{10} \\times 0 + \\frac{1}{10} \\times 0 + P \\\\ \u0026=P \\end{align} $$原命題得證。\n第三小題 題目翻譯：對於 $n$ 個候選人，求在第 $k$ 次面試中錄用最優候選人的機率，其中 $r \\le k \\le n$。\n若要在第 $k$ 次面試錄取最優秀的人，首先最優秀的人必須在第 $k$ 位（機率 $\\frac{1}{n}$）。其次，為了保證能進行到第 $k$ 次面試且選中他，前 $k-1$ 個人中的相對第一名必須出現在前 $r-1$ 人中，其機率為 $\\frac{r-1}{k-1}$。因此：\n$$ P=\\frac{1}{n} \\times \\frac{r-1}{k-1} $$第四小題 題目翻譯：對於以下的遞迴式（公式略），求 $A$ 和 $B$。其中 $A, B$ 是以 $n, r$ 和常數表示的算式。\n$$ \\begin{align} P_{n}(r) \u0026= \\frac{1}{n}(\\frac{r-1}{r-1}+\\frac{r-1}{r}+\\frac{r-1}{r+1}+\\cdots+\\frac{r-1}{n-1}) \\\\ \u0026=\\frac{1}{n} \\sum_{i=r-1}^{n-1} \\frac{r-1}{i} \\\\ \u0026= \\frac{r-1}{n}\\sum_{i=r-1}^{n-1}\\frac{1}{i} \\end{align} $$同理：\n$$ P_{n}(r+1)=\\frac{r}{n}\\sum_{i=r}^{n-1}\\frac{1}{i} $$首先計算 $B$：\n$$ \\frac{r}{n} \\times B = \\frac{r-1}{n} \\\\ B = \\frac{r-1}{r} $$接著計算 $A$，因為 $P_{n}(r)$ 比 $B \\times P_{n}(r+1)$ 多了 $i=r-1$ 這一項： $\\frac{r-1}{n} \\times \\frac{1}{r-1} = \\frac{1}{n}$\n所以 $A = \\frac{1}{n}$。\n第五小題 題目翻譯：設 $q=r/n$，當 $n$ 足夠大時，解釋 $P_{n}(r)$ 可以用 $-q\\ln(q)$ 近似。進而求出 $-q\\ln(q)$ 的極大值所對應的 $q\\in (0,1]$。其中 $\\ln$ 表示自然對數。\n上方已經給出了 $P_{n}(r)$ 的公式，當 $n$ 足夠大時：\n$$ \\sum_{i=r-1}^{n-1}\\frac{1}{i} \\approx \\int_{r}^{n} \\frac{1}{x} dx = \\ln(n)-\\ln(r)= \\ln(\\frac{n}{r}) $$所以：\n$$ P_{n}(r) \\approx \\frac{r}{n}\\ln(\\frac{n}{r}) = q\\ln(\\frac{1}{q}) = -q\\ln(q) $$令 $y=-q\\ln(q)$，則 $\\frac{\\mathrm{d} y}{\\mathrm{d} q} = -\\ln(q)-1$。令 $\\frac{\\mathrm{d} y}{\\mathrm{d} q}=0$，得 $q=\\frac{1}{e}$。\n也就是當 $q=\\frac{1}{e}$ 時，$-q\\ln(q)$ 取最大值。\n這題我也不完全理解其嚴密性，反正近似就對了，具體和 畢導影片中的公式 也有一點點出入，不想深究了。\nWrote with ChatGPT\n","date":"2024-10-25T19:24:36+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/188/","title":"東京大學大學院理工學 數學 2020 問題三 / 東大院理工學 數學 2020 問題三"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 引言 日本語のタイトルを書いても、この文章は主に日本語の内容ではありません。時間があれば追加かもしれません\n題目一： https://blog.yexca.net/zh-tw/archives/183 題目二：本文\n題目三： https://blog.yexca.net/zh-tw/archives/188 唉，幹勁總是會被現實所打敗，不過這次我傷心的時間倒是變短了，希望慢慢的可以好起來。\n關於這題的話，應該屬於一個單獨的向量課程吧，我是一點都沒看懂，後來想到 3b1b 的線性代數本質，才想到數學中向量的一般表示，然後慢慢思考。\n不過事實上題目幾乎也把這些東西的定義都給了出來，如果日本的教學沒學過的話，相當於是當場看定義，然後據此解題。只能說能解出來是真的很厲害，令人望而卻步。\n同時，因為全是證明題，無法確保過程是否正確。\n題目 Source: https://www.i.u-tokyo.ac.jp/edu/entra/examarchive.shtml 題目版權屬於東京大學所有，僅為了方便觀看而引用，無營利行為。\n$xy$ 平面内の滑らかな曲線 $\\boldsymbol{p}=(p(t),q(t))(t \\in [a,b])$ を考える。時刻 $t=a^{'} $ から $b^{'}$ までの $\\boldsymbol{p}$ の長さ $l_{a^{'},b^{'}}$ は\n$$ l_{a^{'},b^{'}} = \\int_{a^{'}}^{b^{'}} \\sqrt{(\\frac{\\mathrm{d} p}{\\mathrm{d} t})^2+(\\frac{\\mathrm{d} q}{\\mathrm{d} t})^2} \\mathrm{d} t $$と定義され、$\\boldsymbol{p}$ の全長 $l_{a,b}$ を $L$ で表す。曲線 $\\boldsymbol{p}$ は、$\\frac{\\mathrm{d} \\boldsymbol{p}}{\\mathrm{d} t}=(0,0)$ とはならないものとする。時刻 $a$ から $t$ までの $\\boldsymbol{p}$ の長さ $l_{a,t}$ を変数 $s=s(t)$ で表すと、$\\boldsymbol{p}$ を媒介変数 $s \\in [0,L]$ の曲線とみることができる。そして、$s$ も時刻と呼ぶ。以下の問いに答えよ。\n（１）以下の等式を示せ。\n$$ \\sqrt{(\\frac{\\mathrm{d} p}{\\mathrm{d} s})^2+(\\frac{\\mathrm{d} q}{\\mathrm{d} s})^2} = 1 $$（２）$\\theta = \\theta(s)$ を時刻 $s$ における $\\boldsymbol{p}$ の接線ベクトル $\\frac{\\mathrm{d} \\boldsymbol{p}}{\\mathrm{d} s} = (\\frac{\\mathrm{d} p}{\\mathrm{d} s},\\frac{\\mathrm{d} q}{\\mathrm{d} s})$ と $x$ 軸とのなす角とする。このとき、以下の等式を示せ。\n$$ \\frac{\\mathrm{d} p}{\\mathrm{d} s} \\frac{\\mathrm{d}^2 q}{\\mathrm{d} s^2}-\\frac{\\mathrm{d} q}{\\mathrm{d} s}\\frac{\\mathrm{d}^2 p}{\\mathrm{d} s^2} = \\frac{\\mathrm{d} \\theta}{\\mathrm{d} s} $$以下では、曲線 $\\boldsymbol{p}$ は、滑らかな閉曲線で、凸集合 $\\boldsymbol{K}$ の境界となっているもの。また、$\\boldsymbol{p}$ は、反時計方向に $\\boldsymbol{K}$ をまわるものとする。\n（３）任意の時刻 $s$ で $\\frac{\\mathrm{d} \\theta}{\\mathrm{d} s} \\ge 0$ となることを説明せよ。\n（４）$\\boldsymbol{K}$ に含まれない点 $\\boldsymbol{x}=(x,y)$ は、時刻 $s \\in [0,L]$ および $\\boldsymbol{x}$ と $\\boldsymbol{K}$ の距離 $r$ によって。\n$$ \\boldsymbol{x} = \\boldsymbol{p} (s) + r \\boldsymbol{u} (s) $$と一意に表すことができる。ここで、$\\boldsymbol{u} (s)$ は、時刻 $s$ における $\\boldsymbol{p}$ の単位法線ベクトルで、$\\boldsymbol{K}$ の外を向いているものとする。そのような $\\boldsymbol{x} = (x,y)$ に対して、以下の等式を示せ。\n$$ \\left | det \\begin{pmatrix} \\frac{\\partial x}{\\partial s} \u0026 \\frac{\\partial x}{\\partial r} \\\\ \\frac{\\partial y}{\\partial s} \u0026 \\frac{\\partial y}{\\partial r} \\end{pmatrix} \\right | =1 +r\\frac{\\mathrm{d} \\theta}{\\mathrm{d} s} $$（５）非負実数 $D$ に対し、$K_D$ を $K$ から距離 $D$ 以内にある点の集合とする。このとき、$K_D$ の面積 $A_D = \\iint_{K_D} \\mathrm{d}x\\mathrm{d}y$ は、$K$ の面積 $A$ と $\\boldsymbol{p}$ の全長 $\\boldsymbol{L}$ を用いて\n$$ A_D = A + LD + \\pi D^2 $$と表せることを示せ。\n中文解答 假設翻譯：考慮 $xy$ 平面上的光滑曲線 $\\boldsymbol{p}=(p(t),q(t))(t \\in [a,b])$ ，從時刻 $t=a^{'} $ 到 $t=b^{'}$ 的曲線 $\\boldsymbol{p}$ 的長度 $l_{a^{'},b^{'}}$ 定義為\n$$ l_{a^{'},b^{'}} = \\int_{a^{'}}^{b^{'}} \\sqrt{(\\frac{\\mathrm{d} p}{\\mathrm{d} t})^2+(\\frac{\\mathrm{d} q}{\\mathrm{d} t})^2} \\mathrm{d} t $$$\\boldsymbol{p}$ 的總長度 $l_{a,b}$ 記作 $L$ 。假設 $\\frac{\\mathrm{d} \\boldsymbol{p}}{\\mathrm{d} t}=(0,0)$ 不成立，用變數 $s=s(t)$ 表示從時刻 $a$ 到 $t$ 的曲線 $\\boldsymbol{p}$ 的長度 $l_{a,t}$ 。這樣可以將 $\\boldsymbol{p}$ 看作參數 $s \\in [0,L]$ 的曲線，並將 $s$ 稱為時刻。\n這個描述其實就是弧長參數化 (arc length parametrization)，是指使用曲線的弧長作為參數來表示曲線的一種特殊形式。具體來說，它將曲線上某一點到曲線起始點的距離（即弧長）作為新的參數，從而使得曲線的參數化不僅簡潔，還能反映曲線的幾何特性。\n第一題 題目翻譯：證明以下等式\n因為曲線的時刻 $t \\in [a,b]$ ，所以曲線的全長 $L$ 為\n$$ l_{a,b} = \\int_{a}^{b} \\sqrt{(\\frac{\\mathrm{d} p}{\\mathrm{d} t})^2+(\\frac{\\mathrm{d} q}{\\mathrm{d} t})^2} \\mathrm{d} t $$而 $s$ 是從 $a$ 到 $t$ 的弧長，即\n$$ s = \\int_{a}^{t} \\sqrt{(\\frac{\\mathrm{d} p}{\\mathrm{d} t})^2+(\\frac{\\mathrm{d} q}{\\mathrm{d} t})^2} \\mathrm{d} t $$所以 $s$ 代表了從弧線的初始點 $a$ 到當前點的弧長，故\n$$ \\frac{\\mathrm{d} s}{\\mathrm{d} t} = \\sqrt{(\\frac{\\mathrm{d} p}{\\mathrm{d} t})^2+(\\frac{\\mathrm{d} q}{\\mathrm{d} t})^2} $$因為 $\\boldsymbol{p}$ 可以看作參數 $s$ 的曲線，$s$ 是 $t$ 的函數，所以\n$$ \\frac{\\mathrm{d} p}{\\mathrm{d} t} = \\frac{\\mathrm{d} p}{\\mathrm{d} s} \\frac{\\mathrm{d} s}{\\mathrm{d} t} \\\\ \\frac{\\mathrm{d} q}{\\mathrm{d} t} = \\frac{\\mathrm{d} q}{\\mathrm{d} s} \\frac{\\mathrm{d} s}{\\mathrm{d} t} $$即\n$$ \\begin{align} \\frac{\\mathrm{d} s}{\\mathrm{d} t} \u0026=\\sqrt{(\\frac{\\mathrm{d} p}{\\mathrm{d} s} \\frac{\\mathrm{d} s}{\\mathrm{d} t})^2+(\\frac{\\mathrm{d} q}{\\mathrm{d} s} \\frac{\\mathrm{d} s}{\\mathrm{d} t})^2} \\\\ \u0026=\\sqrt{(\\frac{\\mathrm{d} p}{\\mathrm{d} s})^2+(\\frac{\\mathrm{d} q}{\\mathrm{d} s})^2} \\frac{\\mathrm{d} s}{\\mathrm{d} t} \\end{align} $$因為 $\\frac{\\mathrm{d} p}{\\mathrm{d} t} \\ne 0$，所以 $\\frac{\\mathrm{d} s}{\\mathrm{d} t} \\ne 0$，即\n$$ \\sqrt{(\\frac{\\mathrm{d} p}{\\mathrm{d} s})^2+(\\frac{\\mathrm{d} q}{\\mathrm{d} s})^2} = 1 $$這個證明表明在弧長參數化下，曲線的速度向量 $\\frac{\\mathrm{d} \\boldsymbol{p}}{\\mathrm{d} s}$ 的長度始終為 $1$。\n第二題 題目翻譯：$\\theta = \\theta(s)$ 為時刻 $s$ 時，曲線 $\\boldsymbol{p}$ 的切線向量 $\\frac{\\mathrm{d} \\boldsymbol{p}}{\\mathrm{d} s} = (\\frac{\\mathrm{d} p}{\\mathrm{d} s},\\frac{\\mathrm{d} q}{\\mathrm{d} s})$ 與 $x$ 軸的夾角。證明等式。\n一般情況下，向量是從原點開始到所表示的那一點，與 $x$ 軸的夾角為 $\\theta$，則向量分量為：\n$$ v_x = \\left | v \\right | \\cos(\\theta) \\\\ v_y = \\left | v \\right | \\sin(\\theta) $$由第一題知 $\\begin{vmatrix} \\frac{\\mathrm{d} \\boldsymbol{p}}{\\mathrm{d} s} \\end{vmatrix} = 1$，所以\n$$ \\begin{align} \\frac{\\mathrm{d} \\boldsymbol{p}}{\\mathrm{d} s} \u0026= (\\frac{\\mathrm{d} p}{\\mathrm{d} s},\\frac{\\mathrm{d} q}{\\mathrm{d} s}) \\\\ \u0026= (\\cos(\\theta(s)), \\sin(\\theta(s))) \\end{align} $$對分量對 $s$ 微分：\n$$ \\begin{align} \\frac{\\mathrm{d}^2 p}{\\mathrm{d} s^2} \u0026= -\\sin(\\theta(s)) \\cdot \\frac{\\mathrm{d} \\theta}{\\mathrm{d} s} \\\\ \\frac{\\mathrm{d}^2 q}{\\mathrm{d} s^2} \u0026= \\cos(\\theta(s)) \\cdot \\frac{\\mathrm{d} \\theta}{\\mathrm{d} s} \\end{align} $$所以\n$$ \\begin{align} \\frac{\\mathrm{d} p}{\\mathrm{d} s} \\frac{\\mathrm{d}^2 q}{\\mathrm{d} s^2}-\\frac{\\mathrm{d} q}{\\mathrm{d} s}\\frac{\\mathrm{d}^2 p}{\\mathrm{d} s^2} \u0026= \\cos(\\theta(s)) \\cdot \\cos(\\theta(s)) \\cdot \\frac{\\mathrm{d} \\theta}{\\mathrm{d} s} - \\sin(\\theta(s)) \\cdot (-\\sin(\\theta(s)) \\cdot \\frac{\\mathrm{d} \\theta}{\\mathrm{d} s}) \\\\ \u0026= (\\cos(\\theta(s)))^2 \\cdot \\frac{\\mathrm{d} \\theta}{\\mathrm{d} s} + (\\sin(\\theta(s)))^2 \\cdot \\frac{\\mathrm{d} \\theta}{\\mathrm{d} s} \\\\ \u0026= \\frac{\\mathrm{d} \\theta}{\\mathrm{d} s} \\end{align} $$第三題 假設條件：曲線 $\\boldsymbol{p}$ 是一個光滑的閉曲線，並且是凸集合的邊界 $\\boldsymbol{K}$。而且，曲線 $\\boldsymbol{p}$ 是以逆時針方向繞 $\\boldsymbol{K}$ 移動。\n題目翻譯：說明為什麼任意時刻 $s$，$\\frac{\\mathrm{d} \\theta}{\\mathrm{d} s} \\ge 0$ 恆成立。\n這題不好說明，因為曲線 $\\boldsymbol{p}$ 是光滑凸曲線，曲線的切線變化是連續的並且不會反向，即單調的。並且是逆時針移動的話，任意時刻與 $x$ 軸的夾角 $\\theta$ 都是一直在增長的，所以其導數就是非負的，故 $\\frac{\\mathrm{d} \\theta}{\\mathrm{d} s} \\ge 0$ 恆成立。\n第四題 題目翻譯：對於不包含在 $\\boldsymbol{K}$ 內的點 $\\boldsymbol{x}=(x,y)$ 可以唯一表示為 $s \\in [0,L]$ 和 $\\boldsymbol{x}$ 與 $\\boldsymbol{K}$ 的距離 $r$ 的函數：\n$$ \\boldsymbol{x} = \\boldsymbol{p} (s) + r \\boldsymbol{u} (s) $$其中，$\\boldsymbol{u} (s)$ 是時刻 $s$ 下的 $\\boldsymbol{p}$ 的單位法向量，且方向指向 $\\boldsymbol{K}$ 的外部。對於這樣的 $\\boldsymbol{x} = (x,y)$ 證明等式成立。\n因為 $\\frac{\\mathrm{d} \\boldsymbol{p}}{\\mathrm{d} s} $ 是單位切線向量，$\\boldsymbol{u} (s)$ 是當時的單位法向量且方向指向 $\\boldsymbol{K}$ 的外部，所以\n$$ \\boldsymbol{u} (s) = (\\frac{\\mathrm{d} q}{\\mathrm{d} s},-\\frac{\\mathrm{d} p}{\\mathrm{d} s}) $$對 $\\boldsymbol{x}$ 分別對 $s$ 和 $r$ 求偏微分：\n$$ \\begin{align} \\frac{\\partial \\boldsymbol{x}}{\\partial s} \u0026= \\frac{\\partial \\boldsymbol{p}}{\\partial s} + r\\frac{\\partial \\boldsymbol{u}}{\\partial s} \\\\ \\frac{\\partial \\boldsymbol{x}}{\\partial r} \u0026= \\boldsymbol{u} (s) \\end{align} $$求其分量的偏微分，對於 $x$：\n$$ \\begin{align} \\frac{\\partial x}{\\partial s} \u0026= \\frac{\\mathrm{d} p}{\\mathrm{d} s} + r\\frac{\\mathrm{d}^2 q}{\\mathrm{d} s^2} \\\\ \\frac{\\partial x}{\\partial r} \u0026= \\frac{\\mathrm{d} q}{\\mathrm{d} s} \\end{align} $$對於 $y$：\n$$ \\begin{align} \\frac{\\partial y}{\\partial s} \u0026= \\frac{\\mathrm{d} q}{\\mathrm{d} s} - r\\frac{\\mathrm{d}^2 p}{\\mathrm{d} s^2} \\\\ \\frac{\\partial y}{\\partial r} \u0026= -\\frac{\\mathrm{d} p}{\\mathrm{d} s} \\end{align} $$所以原矩陣可以變成：\n$$ \\begin{pmatrix} \\frac{\\partial x}{\\partial s} \u0026amp; \\frac{\\partial x}{\\partial r} \\ \\frac{\\partial y}{\\partial s} \u0026amp; \\frac{\\partial y}{\\partial r} \\end{pmatrix} \\begin{pmatrix} \\frac{\\mathrm{d} p}{\\mathrm{d} s} + r\\frac{\\mathrm{d}^2 q}{\\mathrm{d} s^2} \u0026amp; \\frac{\\mathrm{d} q}{\\mathrm{d} s} \\ \\frac{\\mathrm{d} q}{\\mathrm{d} s} - r\\frac{\\mathrm{d}^2 p}{\\mathrm{d} s^2} \u0026amp; -\\frac{\\mathrm{d} p}{\\mathrm{d} s} \\end{pmatrix} $$\n對其求行列式：\n$$ \\begin{align} \\det\\begin{pmatrix} \\frac{\\mathrm{d} p}{\\mathrm{d} s} + r\\frac{\\mathrm{d}^2 q}{\\mathrm{d} s^2} \u0026 \\frac{\\mathrm{d} q}{\\mathrm{d} s} \\\\ \\frac{\\mathrm{d} q}{\\mathrm{d} s} - r\\frac{\\mathrm{d}^2 p}{\\mathrm{d} s^2} \u0026 -\\frac{\\mathrm{d} p}{\\mathrm{d} s} \\end{pmatrix} \u0026= (\\frac{\\mathrm{d} p}{\\mathrm{d} s} + r\\frac{\\mathrm{d}^2 q}{\\mathrm{d} s^2})(-\\frac{\\mathrm{d} p}{\\mathrm{d} s})-(\\frac{\\mathrm{d} q}{\\mathrm{d} s} - r\\frac{\\mathrm{d}^2 p}{\\mathrm{d} s^2})(\\frac{\\mathrm{d} q}{\\mathrm{d} s}) \\\\ \u0026= -(\\frac{\\mathrm{d} p}{\\mathrm{d} s})^2 -r\\frac{\\mathrm{d}^2 q}{\\mathrm{d} s^2}\\frac{\\mathrm{d} p}{\\mathrm{d} s}-(\\frac{\\mathrm{d} q}{\\mathrm{d} s})^2+r\\frac{\\mathrm{d}^2 p}{\\mathrm{d} s^2}\\frac{\\mathrm{d} q}{\\mathrm{d} s} \\\\ \u0026= -[(\\frac{\\mathrm{d} p}{\\mathrm{d} s})^2+(\\frac{\\mathrm{d} q}{\\mathrm{d} s})^2]-r(\\frac{\\mathrm{d}^2 q}{\\mathrm{d} s^2}\\frac{\\mathrm{d} p}{\\mathrm{d} s}-\\frac{\\mathrm{d}^2 p}{\\mathrm{d} s^2}\\frac{\\mathrm{d} q}{\\mathrm{d} s}) \\end{align} $$由第一題和第二題的結論可以得到：\n$$ \\begin{align} \\left | \\det\\begin{pmatrix} \\frac{\\mathrm{d} p}{\\mathrm{d} s} + r\\frac{\\mathrm{d}^2 q}{\\mathrm{d} s^2} \u0026 \\frac{\\mathrm{d} q}{\\mathrm{d} s} \\\\ \\frac{\\mathrm{d} q}{\\mathrm{d} s} - r\\frac{\\mathrm{d}^2 p}{\\mathrm{d} s^2} \u0026 -\\frac{\\mathrm{d} p}{\\mathrm{d} s} \\end{pmatrix} \\right | \u0026= \\left | -1-r\\frac{\\mathrm{d} \\theta}{\\mathrm{d} s} \\right | \\\\ \u0026= 1+r\\frac{\\mathrm{d} \\theta}{\\mathrm{d} s} \\end{align} $$其實這裡出現的矩陣是 雅可比矩陣 (Jacobian matrix) 。\n第五題 題目翻譯：對於非負實數 $D$，定義 $K_D$ 為距離 $K$ 在 $D$ 以內的點的集合。證明 $K_D$ 的面積 $A_D$ 可以用 $K$ 的面積和 $\\boldsymbol{p}$ 的全長 $L$ 表示，公式略。\n這個證明我認為可以畫個圖比較好理解，但怎麼用文字表述我還沒想到，大概就是圖中的意思：\n其中藍色的是 $K$ 的面積，綠色的是把 $K$ 的各邊向外平移 $D$ 所形成區域的面積（近似為 $L \\times D$），然後圖中為了方便看把轉角（粉色）畫得很大，並且為了方便理解使用了長方形作為基礎。實際上因為凸性且光滑封閉，所有的轉角部分正好可以組成一個半徑為 $D$ 的圓，這部分的面積就是 $\\pi D^2$。這可以想像成轉角處無限小，無限逼近一個直角，那麼用 $LD$ 計算時會有一部分的面積沒算進去（因為轉角處是扇形），所有轉角處沒被算進去的面積加起來就是一個圓的面積。\n所以 $A_D = A + LD + \\pi D^2$。\nWrote with ChatGPT\n","date":"2024-10-24T22:46:25+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/187/","title":"東京大學大學院理工學 數學 2020 問題二 / 東大院理工學 數學 2020 問題二"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 引言 2022 SA am1\n01-02: https://blog.yexca.net/zh-tw/archives/184 03-05: https://blog.yexca.net/zh-tw/archives/185 06-10: https://blog.yexca.net/zh-tw/archives/186 11-15: https://blog.yexca.net/zh-tw/archives/189 16-30: https://blog.yexca.net/zh-tw/archives/190 可能因為是多場考試共用的試卷吧，問題還是挺基礎的，感覺像軟考中級軟體設計師的程度。不過一共有四場考試呢，也不知道什麼時候能把這第一個寫完呢\n第六問 一つの $I^2C$ バスに接続された二つのセンサがある。それぞれのセンサ値を読み込む二つのタスで排他的に制御したい。利用するリアルタイムOSの機能として、適切なものはどれか。\nア　キュー\nイ　セマフォ\nウ　マルチスレッド\nエ　ラウンドロビン\n題目翻譯：有兩個連接到同一個 I²C 匯流排的感測器。為了互斥地控制兩個任務讀取各自的感測器值，應使用哪種即時作業系統（RTOS）的功能？\nア：佇列 (queue)\nイ：信號量 (semaphore)\nウ：多執行緒 (Multithreading)\nエ：輪轉排程 (Round Robin)\n佇列是一種資料結構，遵循 FIFO 即先進先出原則，適用於多個任務之間的通訊或資料傳遞。\n信號量是一種同步機制，主要用於控制對共享資源的存取，確保多個任務在並行環境下不會同時存取同一個資源。信號量分為兩類：二元信號量 (用於互斥存取) 和計數信號量 (用於管理資源池)。\n多執行緒指在一個行程內同時執行多個執行緒的機制。其本身不用於互斥控制，但往往需要配合信號量、互斥鎖等機制來確保對共享資源的安全存取。\n輪轉排程是一種簡單的任務排程演算法，例如時間片輪轉。\n選項本身倒是還好，只是都是片假名，無疑增加了難度。綜上所述，本題選擇 イ。\n第七問 アクチュエータの説明として、適切なものはどれか。\nア　与えられた目標量と、センサから得られた制御量に比較し、制御量を目標量に一致させるように操作量を出力する。\nイ　位置、角度、速度、加速度、力、温度などを検出し、電気的な情報に変換する。\nウ　エネルギー源からのパワーを、回転、直進などの働きに変換する。\nエ　マイクロフォン、センサなどが出力する微小な電気信号を増幅する。\n題目翻譯：關於致動器（Actuator）的描述，哪項是正確的？\nア：將給定的目標值與從感測器獲得的控制值進行比較，並輸出一個操作量以使控制值與目標值一致。\nイ：偵測位置、角度、速度、加速度、力、溫度等，並將其轉換為電訊號。\nウ：將來自能源的動力轉換為旋轉、直線運動等工作形式。\nエ：放大由麥克風、感測器等設備輸出的微量電訊號。\nア 是控制器的功能，通常用於閉迴路控制系統中；イ 是感測器的功能，將物理量轉換為電訊號；ウ 是致動器的功能；エ 是放大器的功能。本題選 ウ。\n第八問 第1、第2、第3正規形とリレーションの特徴 a, b, c の組合のうち、適切なものはどれか。\na：どの非キー属性も、主キーの真部分集合に対して関数従属しない。\nb：どの非キー属性も、主キーに推移的に関数従属しない。\nc：繰り返し属性が存在しない。\n第1正規形 第2正規形 第3正規形 ア a b c イ a c b ウ c a b エ c b a 題目翻譯：以下關於 1NF、2NF 和 3NF 的定義，與特徵 a, b, c 的組合，哪一項是正確的？\na：任何非主鍵屬性不相依於主鍵的真子集（部分相依）。\nb：任何非主鍵屬性不透過其他非主鍵屬性相依於主鍵（遞移相依）。\nc：不存在重複的屬性。\n這個其實就是正規化啦，還 特意寫了一篇文章 （翻譯成正規形有點奇怪欸）。參考 總結部分 可以知道 1NF 對應 c；2NF 對應 a；3NF 對應 b。答案為選項 ウ。\n第九問 ビッグデータの利用におけるデータマイニングを説明したものはどれか。\nア　蓄積されたデータを分析し、単なる検索だけではわからない隠れた規則や相関関係を見つけ出すこと\nイ　データウェアハウスに格納されたデータの一部を、特定の用途や部門用に切り出して、データベースに格納すること\nウ　データ処理の対象となる情報を基に規定した、データの構造、意味及び操作の枠組みのこと\nエ　データを複数のサーバに複製し、性能と可用性を向上させること\n題目翻譯：以下哪項描述了大數據利用中的資料探勘（Data Mining）？\nア：分析累積的資料，發現透過簡單搜尋無法找到的隱藏規律和關聯。\nイ：從資料倉儲（Data Warehouse）中提取一部分資料，按特定用途或部門需求儲存到資料庫中。\nウ：根據要處理的資訊，定義資料的結構、意義和操作框架。\nエ：將資料複製到多台伺服器上，以提高效能和可用性。\nア 是資料探勘的正確描述；イ 是描述資料超市（Data Mart）的過程，即從資料倉儲中選取部分資料用於特定用途；ウ 是資料模型的定義；エ 則是資料備份。答案為選項 ア。\n第十問 UDPを使用しているものはどれか。\nア　FTP\nイ　NTP\nウ　POP３\nエ　TELNET\n題目翻譯：以下哪項使用了 UDP 協定？\nFTP 是檔案傳輸協定，使用 TCP 確保資料安全；NTP 是網路時間協定，使用 UDP 確保速度；POP3 是郵局協定第三版，使用 TCP 確保郵件傳輸可靠性；TELNET 是遠端終端協定，使用 TCP 建立可靠的遠端終端工作階段。所以答案為選項 イ。\n","date":"2024-10-22T15:37:34+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/186/","title":"2022 SA am1 -06-10"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 引言 2022 SA am1\n01-02: https://blog.yexca.net/zh-tw/archives/184 03-05: https://blog.yexca.net/zh-tw/archives/185 06-10: https://blog.yexca.net/zh-tw/archives/186 11-15: https://blog.yexca.net/zh-tw/archives/189 16-30: https://blog.yexca.net/zh-tw/archives/190 碎碎念 星期一總是很累，在經歷了週末的休息後總會在今天提不起精神。不過今天也不知道怎麼回事，我突然一改之前快要憂鬱的感覺，儘管什麼也沒有做，突然就變得極其樂觀。情感或者狀態確實很奇妙。\n所以呢，今天也摸了不少魚呢，差點就不寫了。不過這張試卷有 30 個試題，照目前的速度恐怕至少要半個月才能看完 :cry:\n第三題 プログラム言語のうち、ブロックの範囲を指定する方法として特定の記号や予約語を用いず、等しい文字数の字下げを用いるという特徴をもつものはどれか。\nア　C\nイ　Java\nウ　PHP\nエ　Python\n題目翻譯：在程式語言中，哪種語言的特點是不使用特定的符號或保留字來指定程式碼區塊的範圍，而是透過相同字元數的縮排來指定範圍？\n顯然是 Python，即選項 エ。\n第四題 キャッシュメモリのアクセス時間が主記憶のアクセス時間の1/30で、ヒット率が95％のとき、実効メモリアクセス時間は、主記憶のアクセス時間の約何倍になるか。\nア　0.03\nイ　0.08\nウ　0.37\nエ　0.95\n這題考的是有效記憶體存取時間 (EMAT)，可以透過以下公式計算：\n$$ EMAT = Cache Access Time \\times Hit Rate + Main Memory Access Time \\times Miss Rate $$設 Main Memory Access Time = T，則 Cache Access Time = $\\frac{T}{30}$。由題目知 Hit Rate = 95%，則 Miss Rate = 5%。\n所以 EMAT = $\\frac{T}{30} \\times 95\\% + T \\times 5\\% \\approx 0.08T$，因此答案為選項 イ。\n這題以前不太會做，計算機組織的話我也只聽了一半，說實話應該也算忘得差不多了。\n第五題 プロセッサ数と、計算処理におけるプロセスの並列化が可能な部分の割合とが、性能上へ及ぼす影響に関する記述のうち、アムダールの法則に基づいたものはどれか。\nア　全ての計算処理が並列化できる場合、速度向上比は、プロセッサ数を増やしてもある水準に漸近的に近づく。\nイ　並列化できない計算処理がある場合、速度向上比は、プロセッサ数に比例して増加する。\nウ　並列化できない計算処理がある場合、速度向上比は、プロセッサ数を増やしてもある水準に漸近的に近づく。\nエ　並列化できる計算処理の割合が増えると、速度向上比は、プロセッサ数に反比例して減少する。\n題目翻譯：關於處理器數量與計算處理過程中可平行化部分佔比對效能的影響，下列哪一項是基於阿姆達爾定律 (Amdahl\u0026rsquo;s Law) 的描述？\nア：如果所有的計算處理都可以平行化，則速度提升比即使增加處理器數量，也會逐漸趨近於某個水平。\nイ：如果存在無法平行化的計算處理，速度提升比會隨著處理器數量的增加而按比例增長。\nウ：如果存在無法平行化的計算處理，則速度提升比即使增加處理器數量，也會逐漸趨近於某個水平。\nエ：隨著可平行化的計算處理比例增加，速度提升比會隨著處理器數量的增加而呈反比減少。\n要解出這題需要先知道什麼是「アムダールの法則」。Amdahl\u0026rsquo;s Law 描述了計算處理過程中，程式的平行化程度對效能提升的影響。它指出即使增加處理器的數量，程式中不能平行化的部分仍然會限制效能的提升。其公式如下：\n$$ S(N)=\\frac{1}{(1-P)+\\frac{P}{N}} $$其中 S(N) 表示使用 N 個處理器時的速度提升比、P 是程式中能夠進行平行化的部分比例、N 是處理器的數量。\n綜上所述，本題選 ウ。\n","date":"2024-10-21T20:35:34+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/185/","title":"2022 SA am1 -03-05"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 引言 2022 SA am1\n01-02: https://blog.yexca.net/zh-tw/archives/184 03-05: https://blog.yexca.net/zh-tw/archives/185 06-10: https://blog.yexca.net/zh-tw/archives/186 11-15: https://blog.yexca.net/zh-tw/archives/189 16-30: https://blog.yexca.net/zh-tw/archives/190 這篇文章是我想要挑戰一下，也沒想過會成功，去參加系統架構師考試，也就是電腦專業技術與軟體專業技術資格的高級考試。這項考試取得的證照和學習到的知識，可能大多數在編寫程式時用不上（其實用得上只是想不到），但有總比沒有好。我會盡量把這張試卷做完，這應該也能慢慢將我從夢中拉回吧。\n碎碎念 自己最近兩年確實很渾渾噩噩了，以至於現在處理事情的方法也深受該狀態影響。一直這樣下去終究不是辦法，既然無法選擇，那就盡力做好吧。我想要至少嘗試一下，沒有嘗試的勇氣才是最可怕的，這已經讓我最近失去了一個機會。還是應該有些改變或變化，生活才能過得比較真實一點。我也確實有時候覺得我活在夢裡，倒不是活得好，而是不真實。文字的力量是有限的，實際的經歷更具有說服力，儘管可能是虛假被創造出的事實，我開始去相信一些看似很離譜的事情。\n嗯，感覺在寫日記似的，算了吧，就這樣吧。\n引言提到感覺在做夢，其實讓我想到一部有趣的修仙小說，那個魔宗的人覺得自己是仙人，所在的世界只是一個幻境，自己是過來歷練的。我有時候都覺得被這個設定影響了。所以不要再廢話了嘛\n第一問 ハミング符号とは、データに冗長ビットを付加して、1ビットの誤りを訂正できるようにしたものである。ここでは。$X_1, X_2, X_3, X_4$ の4ビットから成るデータに3ビットの冗長ビット $P_3, P_2, P_1$ を付加したハミング符号 $X_1X_2X_3P_3X_4P_2P_1$ を考える。付加したビット $P_1, P_2, P_3$ は、それぞれ\n$$ X_1 \\oplus X_3 \\oplus X_4 \\oplus P_1 = 0 \\\\ X_1 \\oplus X_2 \\oplus X_4 \\oplus P_2 = 0 \\\\ X_1 \\oplus X_2 \\oplus X_3 \\oplus P_3 = 0 $$となるように決める。ここで、$\\oplus$ は排他的論理和を表す。\nハミング符号1110011には1ビットの誤りが存在する。誤りビットを訂正したハミング符号はどれか。\nア　0110011\nイ　1010011\nウ　1100011\nエ　1110111\n海明碼（Hamming Code）題目，題目給出了公式，每個位置代入計算互斥或（XOR）得：\n$$ X_1 \\oplus X_3 \\oplus X_4 \\oplus P_1 = 1 \\\\ X_1 \\oplus X_2 \\oplus X_4 \\oplus P_2 = 1 \\\\ X_1 \\oplus X_2 \\oplus X_3 \\oplus P_3 = 1 $$可以得到出錯的位置為 $(111)_2$ 即第 7 位，所以正確的數據為 0110011，即選項 ア。\n看到海明碼時，我只覺得很熟悉，但具體是什麼我已經完全不記得了，唉，之前到底學了什麼呢。\n海明碼可用於校驗資料是否出錯，並且進行一位元的糾錯。以原始資料 1100 為例，轉換為海明碼的過程如下：\n首先計算校驗位（Parity bits）的個數，$2^k \\ge k + m + 1$，其中 m 為原始資料的個數，k 為校驗位的個數。本例的 k 應為 3，共有三個校驗位。校驗位只會出現在 $2^n$ 即 1、2、4、8 ···。所以本例校驗位在第 1、2、4 位。此處以及以後提到的位置一般為從右往左。\n因為有三位校驗位加上四位資料，共有七個數，列出其二進位（校驗位 3 位，列出二進位為 3 位）：\n7 6 5 4 3 2 1 111 110 101 100 011 010 001 校驗位的位置，即 1、2、4 的數字分別對應 001、010、100，即 1 的位置在第一位、第二位、第三位，接下來找出所有位置相同的：\n校驗碼位置 數字 1 位置 碼 1 第一位，**1 1、3、5、7 2 第二位，*1* 2、3、6、7 4 第三位，1** 4、5、6、7 然後根據每一組（上表一行同一個位置的碼為一組）計算確定校驗位的碼，需要藉助原資料，如下表：\n位置 7 6 5 4 3 2 1 數值 1 1 0 0 因為校驗位數值不確定，先空著。\n第一組資料，根據第 1、3、5、7 位的數字確定，共有 1 個 1，所以補 1 使 1 的個數為偶數。\n第二組資料，根據第 2、3、6、7 位的數字確定，共有 2 個 1，所以補 0。\n第三組資料，根據第 4、5、6、7 位的數字確定，共有 2 個 1，所以補 0。\n所以海明碼對應位置如下：\n位置 7 6 5 4 3 2 1 數值 1 1 0 0 0 0 1 即資料 1100 的海明碼為 1100001，校驗方式其實和題目一樣，畢竟題目範例也是七位數。\n校驗是怎麼確定的呢？把題目中三行公式對應的位置換成從右往左數，可以看到其實就是上面確定校驗碼時劃分的三個組。所以校驗方式也就是確定校驗碼個數後，再確定各組位置，然後進行互斥或操作。根據得到的結果（全是 0 說明資料未改變），從右往左排列，即：\n···第三組、第二組、第一組\n得到的二進位數即資料發生改變的位置，改變數值則得到原來的海明碼。\n參考文章\n海明码一篇文章彻底搞懂 海明码的编码和校验方法 排他的論理和（XOR） 第二問 リストには、配列で実現する場合とポインタで実現する場合とがある。リストを配列で実現した場合の特徴として、適切なものはどれか。ここで、配列を用いたリストは配列に要素を連続して格納することによってリストを構成し、ポインタを用いたリストは要素と次の要素へのポインタを用いることによってリストを構成するものとする。\nア　リストにある実際の要素数にかかわらず、リストに入れられる要素の最大個数に対応した領域を確保し、実際には使用されない領域が発生する可能性がある。\nイ　リストの中間要素を参照するには、リストの先頭から順番に要素をたどっていくことから、要素数に比例した時間が必要となる。\nウ　リストの要素を格納する領域の他に、次の要素を指し示すための領域が別途必要となる。\nエ　リストへの挿入位置が分かる場合には、リストにある実際の要素数にかかわらず、要素の挿入を一定時間で行うことができる。\n這道題目問陣列實現的串列（List）有什麼特徵，除了 ア 以外都是指標構成串列的特徵，答案為選項 ア。\n問題還是很明顯的，選錯了就是我看不懂 :cry:，題目翻譯如下（ChatGPT）：\n串列可以使用陣列或指標來實現。使用陣列實現串列的特點是什麼？在這裡，陣列實現的串列是透過將元素連續地儲存在陣列中來構成的，而使用指標的串列則是透過使用元素和指向下一個元素的指標來構成的。\nア：無論串列中實際的元素數是多少，都要為串列中可容納的最大元素個數分配記憶體空間，可能會出現未使用的空間。\nイ：要存取串列中的中間元素，需要從串列的開頭開始逐個元素進行走訪，因此需要的時間與元素數量成正比。\nウ：除了儲存串列元素的空間外，還需要單獨的空間來指向下一個元素。\nエ：如果知道插入位置，那麼無論串列中實際有多少元素，都可以在固定時間內插入元素。\n","date":"2024-10-20T20:19:11+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/184/","title":"2022 SA am1 -01-02"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 引言 即使寫了日文標題，這篇文章的主體也並非日文內容。有時間的話可能會補充\n題目一：本文\n題目二： https://blog.yexca.net/zh-tw/archives/187 題目三： https://blog.yexca.net/zh-tw/archives/188 最近幾年總是會覺得自己在學習上沒有任何收穫，儘管自己可能確實聽了課程。於是我便想著嘗試去做題目（是的，學習卻不練習題目這種可能不是特別正常的現象，會讓當時的我覺得很正常，應該是太懶了），結果這一做題目，怎麼說呢，自己解我不會，但搜尋怎麼解我倒是對相關課程有印象，於是我就像重新學了一遍似地解完了該題。\n同時，由於沒有參考答案，前三題我用 Python 可以計算出來，答案應該是正確的，但最後兩題是證明題，不保證證明是正確的。\n題目 來源： https://www.i.u-tokyo.ac.jp/edu/entra/examarchive.shtml 題目版權屬於東京大學所有，僅為了方便閱讀而引用，無營利行為。\n正方行列 $A,B$ を\n$$ A=\\begin{pmatrix} 1 \u0026 \\sqrt{2} \u0026 0 \\\\ \\sqrt{2} \u0026 1 \u0026 \\sqrt{2} \\\\ 0 \u0026 \\sqrt{2} \u0026 1 \\end{pmatrix}, B=\\begin{pmatrix} 0 \u0026 -\\frac{2}{3} \u0026 \\frac{1}{3} \\\\ \\frac{2}{3} \u0026 0 \u0026 -\\frac{2}{3} \\\\ -\\frac{1}{3} \u0026 \\frac{2}{3} \u0026 0 \\end{pmatrix} $$とする。また、行列 $I$ は単位行列とする。実正方行列 $X$ に対して、$\\exp(X)$ を\n$$ \\exp(X)=\\sum_{k=0}^{\\infty}(\\frac{1}{k!}X^{k})=I+X+\\frac{1}{2!}X^{2}+\\frac{1}{3!}X^{3}+\\cdots $$と定義するとき、以下の問いに答えよ。\n（1）$A$ の全ての固有値と、それらに対応する固有ベクトルを求めよ。ただし、固有ベクトルとして、ノルムは $1$ かつ第一要素は非負実数であるものを選べ。\n（2）非負整数 $n$ に対して、$A^{n}$ を求めよ。\n（3）$\\exp(A)$ を求めよ。\n（4）$\\alpha$ を実数とするとき、$\\exp(\\alpha B)$ が次式のように表せることを示せ。\n$$ \\exp(\\alpha B) = I + (\\sin\\alpha)B + (1-\\cos(\\alpha))B^{2} $$ただし、ケーリー・ハミルトンの定理を用いてもよい。\n（5）$3$ 次元実ベクトル $a$ が与えられたとき、$3$ 次元実ベクトル $x$ に関する関数 $f$ を\n$$ f(x) = \\sum_{k=1}^{n} \\left \\| \\exp(\\frac{2\\pi k}{n}B)a - x \\right \\|^{2} $$とおく。ただし、$n \\ge 2$ とする。このとき、$x=(I+B^{2})a$ において $f$ が最小になることを示せ。\n第一問 題目: 求出 $A$ 的特徵值與特徵向量 (特徵向量的模為 1 且第一個分量為非負)\n根據特徵方程 $\\det(A-\\lambda I) = 0$ 構造矩陣並計算其行列式。特徵方程式為\n$$ \\det(A-\\lambda I) =\\begin{vmatrix} 1-\\lambda \u0026 \\sqrt{2} \u0026 0 \\\\ \\sqrt{2} \u0026 1-\\lambda \u0026 \\sqrt{2} \\\\ 0 \u0026 \\sqrt{2} \u0026 1-\\lambda \\end{vmatrix} = 0 $$按第一列展開，得\n$$ (1-\\lambda)[(1-\\lambda)^{2}-2]-\\sqrt{2}[\\sqrt{2}(1-\\lambda)]=0 $$求解，得\n$$ \\lambda_{1}=1, \\lambda_{2}=-1, \\lambda_{3}=3 $$接下來求每個特徵值對應的特徵向量，對於 $\\lambda_{1}=1$\n$$ (A-\\lambda_{1}I) = \\begin{pmatrix} 0 \u0026 \\sqrt{2} \u0026 0 \\\\ \\sqrt{2} \u0026 0 \u0026 \\sqrt{2} \\\\ 0 \u0026 \\sqrt{2} \u0026 0 \\end{pmatrix} $$解方程式 $(A-\\lambda_{1}I)\\mathbf{v}_{1}=0$ ，得到特徵向量\n$$ \\mathbf{v}_{1}=\\begin{pmatrix} 1 \\\\ 0 \\\\ -1 \\end{pmatrix} $$對於 $\\lambda_{2}=-1$\n$$ (A-\\lambda_{2}I)=\\begin{pmatrix} 2 \u0026 \\sqrt{2} \u0026 0 \\\\ \\sqrt{2} \u0026 2 \u0026 \\sqrt{2} \\\\ 0 \u0026 \\sqrt{2} \u0026 2 \\end{pmatrix} $$解方程式 $(A-\\lambda_{2}I)\\mathbf{v}_{2}=0$ ，得到特徵向量\n$$ \\mathbf{v}_{2}=\\begin{pmatrix} 1 \\\\ -\\sqrt{2} \\\\ 1 \\end{pmatrix} $$對於 $\\lambda_{3}=3$\n$$ (A-\\lambda_{3}I)=\\begin{pmatrix} -2 \u0026 \\sqrt{2} \u0026 0 \\\\ \\sqrt{2} \u0026 -2 \u0026 \\sqrt{2} \\\\ 0 \u0026 \\sqrt{2} \u0026 -2 \\end{pmatrix} $$解方程式 $(A-\\lambda_{3}I)\\mathbf{v}_{3}=0$ ，得到特徵向量\n$$ \\mathbf{v}_{3}=\\begin{pmatrix} 1 \\\\ \\sqrt{2} \\\\ 1 \\end{pmatrix} $$對特徵值進行正規化，總結\n$$ \\begin{align*} 特徵值\u0026: \\lambda_{1}=1, \\lambda_{2}=-1, \\lambda_{3}=3 \\\\ 特徵向量\u0026: \\mathbf{v}_{1}=\\frac{1}{\\sqrt{2}} \\begin{pmatrix} 1 \\\\ 0 \\\\ -1 \\end{pmatrix}, \\mathbf{v}_{2}=\\frac{1}{2} \\begin{pmatrix} 1 \\\\ -\\sqrt{2} \\\\ 1 \\end{pmatrix}, \\mathbf{v}_{3}=\\frac{1}{2} \\begin{pmatrix} 1 \\\\ \\sqrt{2} \\\\ 1 \\end{pmatrix} \\end{align*} $$Python 程式碼 透過 sympy 驗算結果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import sympy as sp # 定義矩陣 A A = sp.Matrix([[1, sp.sqrt(2), 0], [sp.sqrt(2), 1, sp.sqrt(2)], [0, sp.sqrt(2), 1]]) # 計算特徵值和特徵向量 eigenvals = A.eigenvals() # 特徵值 eigenvects = A.eigenvects() # 特徵向量 print(f\u0026#34;A 的特徵值為\u0026#34;) sp.pprint(eigenvals) print(f\u0026#34;A 的特徵向量為\u0026#34;) sp.pprint(eigenvects) 輸出結果如下\n第二問 題目: 求 $A^{n}$ ($n$ 為非負整數)\n根據對角化理論，矩陣 $A$ 可以分解為 $A=S DS^{-1}$（修正順序）。由第一問可得\n$$ S=\\begin{pmatrix} 1 \u0026 1 \u0026 1 \\\\ 0 \u0026 -\\sqrt[]{2} \u0026 \\sqrt[]{2} \\\\ -1 \u0026 1 \u0026 1 \\end{pmatrix}, D=\\begin{pmatrix} 1 \u0026 0 \u0026 0 \\\\ 0 \u0026 -1 \u0026 0 \\\\ 0 \u0026 0 \u0026 3 \\end{pmatrix} $$計算 $S$ 的反矩陣，得\n$$ S^{-1}=\\begin{pmatrix} \\frac{1}{2} \u0026 0 \u0026 -\\frac{1}{2} \\\\ \\frac{1}{4} \u0026 -\\frac{\\sqrt{2}}{4} \u0026 \\frac{1}{4} \\\\ \\frac{1}{4} \u0026 \\frac{\\sqrt{2}}{4} \u0026 \\frac{1}{4} \\end{pmatrix} $$計算 $D^{n}$ 得\n$$ D^{n}=\\begin{pmatrix} 1^{n} \u0026 0 \u0026 0 \\\\ 0 \u0026 (-1)^{n} \u0026 0 \\\\ 0 \u0026 0 \u0026 3^{n} \\end{pmatrix} $$$A^{n}=S D^{n} S^{-1}$ ，解得\n$$ A^{n}=\\begin{pmatrix} \\frac{1}{2}+(-1)^{n}\\frac{1}{4}+\\frac{3^{n}}{4} \u0026 (-1)^{n+1}\\frac{\\sqrt{2}}{4}+\\frac{\\sqrt{2}}{4}3^{n} \u0026 -\\frac{1}{2}+(-1)^{n}\\frac{1}{4}+\\frac{3^{n}}{4} \\\\ (-1)^{n+1}\\frac{\\sqrt{2}}{4}+\\frac{\\sqrt{2}}{4}3^{n} \u0026 (-1)^{n}\\frac{1}{2}+\\frac{1}{2}3^{n} \u0026 (-1)^{n+1}\\frac{\\sqrt{2}}{4}+\\frac{\\sqrt{2}}{4}3^{n} \\\\ -\\frac{1}{2}+(-1)^{n}\\frac{1}{4}+\\frac{3^{n}}{4} \u0026 (-1)^{n+1}\\frac{\\sqrt{2}}{4}+\\frac{\\sqrt{2}}{4}3^{n} \u0026 \\frac{1}{2}+(-1)^{n}\\frac{1}{4}+\\frac{3^{n}}{4} \\end{pmatrix} $$Python 程式碼 透過 sympy 驗算結果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 import sympy as sp # 定義 sqrt(2) sqrt_2 = sp.sqrt(2) # 定義矩陣 S 和 S^{-1} S = sp.Matrix([[1, 1, 1], [0, -sqrt_2, sqrt_2], [-1, 1, 1]]) S_inv = sp.Matrix([ [sp.Rational(1, 2), 0, -sp.Rational(1, 2)], [sp.Rational(1, 4), -sqrt_2 / 4, sp.Rational(1, 4)], [sp.Rational(1, 4), sqrt_2 / 4, sp.Rational(1, 4)] ]) # 定義對角矩陣 D lambda_1 = 1 lambda_2 = -1 lambda_3 = 3 D = sp.diag(lambda_1, lambda_2, lambda_3) # 定義 n n = sp.symbols(\u0026#39;n\u0026#39;) # 計算 D^n D_n = D**n # 計算 A^n = S D^n S^{-1} A_n = S * D_n * S_inv # 列印結果 print(f\u0026#34;A^n = S D^n S^{-1} =\u0026#34;) sp.pprint(A_n) 輸出結果如下\n其他解法 第四問提到了 ケーリー・ハミルトンの定理 (凱萊-哈密頓定理)，此定理可以用於解矩陣的冪運算。\n第一問求出特徵值後，令\n$$ \\lambda^{n} = f(\\lambda)g(\\lambda) +a\\lambda^{2} +b\\lambda +c $$代入特徵值，又因為 $f(\\lambda_{1})=f(\\lambda_{2})=f(\\lambda_{3})=0$ 可得出方程組\n$$ \\left\\{\\begin{matrix} 1 =a+b+c \\\\ (-1)^{n} =a-b+c \\\\ 3^{n} =9a+3b+c \\end{matrix}\\right. $$解方程組得\n$$ \\left\\{\\begin{matrix} a=\\frac{(-1)^{n}+3^{n}-2}{8} \\\\ b=1-\\frac{1+(-1)^{n}}{2} \\\\ c=\\frac{1+(-1)^{n}}{2}-\\frac{(-1)^{n}+3^{n}-2}{8} \\end{matrix}\\right. $$代入公式 $A^{n}=f(A)g(A)+aA^{2}+bA+cI$ ，因為 $f(A)=0$ 所以 $A^{n}=aA^{2}+bA+cI$\n$$ A^{n}=\\begin{pmatrix} \\frac{1}{2}+(-1)^{n}\\frac{1}{4}+\\frac{3^{n}}{4} \u0026 (-1)^{n+1}\\frac{\\sqrt{2}}{4}+\\frac{\\sqrt{2}}{4}3^{n} \u0026 -\\frac{1}{2}+(-1)^{n}\\frac{1}{4}+\\frac{3^{n}}{4} \\\\ (-1)^{n+1}\\frac{\\sqrt{2}}{4}+\\frac{\\sqrt{2}}{4}3^{n} \u0026 (-1)^{n}\\frac{1}{2}+\\frac{1}{2}3^{n} \u0026 (-1)^{n+1}\\frac{\\sqrt{2}}{4}+\\frac{\\sqrt{2}}{4}3^{n} \\\\ -\\frac{1}{2}+(-1)^{n}\\frac{1}{4}+\\frac{3^{n}}{4} \u0026 (-1)^{n+1}\\frac{\\sqrt{2}}{4}+\\frac{\\sqrt{2}}{4}3^{n} \u0026 \\frac{1}{2}+(-1)^{n}\\frac{1}{4}+\\frac{3^{n}}{4} \\end{pmatrix} $$第三問 題目: 求 $\\exp(A)$\n由第二問可知 $A$ 可以對角化，所以\n$$ \\begin{align*} \\exp(A)\u0026=\\exp(SDS^{-1})\\\\ \u0026=I+SDS^{-1}+\\frac{1}{2!}(SDS^{-1})^{2}+\\frac{1}{3!} (SDS^{-1})^{3}+\\cdots \\\\ \u0026= I+SDS^{-1} +\\frac{1}{2!}SD^{2}S^{-1}+\\frac{1}{3!}SD^{3}S^{-1}+\\cdots \\end{align*} $$提取 $S$ 和 $S^{-1}$ 得\n$$ \\begin{align*} \\exp(SDS^{-1})\u0026=S(I+D+\\frac{1}{2!}D^{2}+\\frac{1}{3!}D^{3}+\\cdots)S^{-1} \\\\ \u0026=S\\exp(D)S^{-1} \\end{align*} $$而 $D$ 為對角矩陣，所以\n$$ \\exp(D)=\\begin{pmatrix} e \u0026 0 \u0026 0 \\\\ 0 \u0026 e^{-1} \u0026 0 \\\\ 0 \u0026 0 \u0026 e^{3} \\end{pmatrix} $$求 $\\exp(A)=S\\exp(D)S^{-1}$ 得\n$$ \\exp(A)=\\begin{pmatrix} \\frac{1}{2}e+\\frac{1}{4}e^{-1}+\\frac{1}{4}e^{3} \u0026 -\\frac{\\sqrt{2}}{4}e^{-1}+\\frac{\\sqrt{2}}{4}e^{3} \u0026 -\\frac{1}{2}e+\\frac{1}{4}e^{-1}+\\frac{1}{4}e^{3} \\\\ -\\frac{\\sqrt{2}}{4}e^{-1}+\\frac{\\sqrt{2}}{4}e^{3} \u0026 \\frac{1}{2}e^{-1}+\\frac{1}{2}e^{3} \u0026 -\\frac{\\sqrt{2}}{4}e^{-1}+\\frac{\\sqrt{2}}{4}e^{3} \\\\ -\\frac{1}{2}e+\\frac{1}{4}e^{-1}+\\frac{1}{4}e^{3} \u0026 -\\frac{\\sqrt{2}}{4}e^{-1}+\\frac{\\sqrt{2}}{4}e^{3} \u0026 \\frac{1}{2}e+\\frac{1}{4}e^{-1}+\\frac{1}{4}e^{3} \\end{pmatrix} $$Python 程式碼 透過 sympy 驗算結果\n1 2 3 4 5 6 7 8 9 10 11 12 13 import sympy as sp # 定義矩陣 A A = sp.Matrix([[1, sp.sqrt(2), 0], [sp.sqrt(2), 1, sp.sqrt(2)], [0, sp.sqrt(2), 1]]) # 計算 exp(A) exp_A = A.exp() # 列印結果 print(\u0026#34;exp(A) =\u0026#34;) sp.pprint(exp_A) 輸出結果如下\n第四問 題目: 當 $\\alpha$ 是實數的時候，證明等式。(允許使用凱萊-哈密頓定理進行證明)\n對矩陣 $B$ 求特徵方程\n$$ \\det(B-\\lambda I)=\\begin{pmatrix} -\\lambda \u0026 -\\frac{2}{3} \u0026 \\frac{1}{3} \\\\ \\frac{2}{3} \u0026 -\\lambda \u0026 -\\frac{2}{3} \\\\ -\\frac{1}{3} \u0026 \\frac{2}{3} \u0026 -\\lambda \\end{pmatrix} = -\\lambda^{3}-\\lambda $$由凱萊-哈密頓定理知\n$$ P(B)=-B^{3}-B=0 $$所以\n$$ B^{3}=-B $$從而可以求出\n$$ \\begin{align*} B^{4}\u0026=B^{3}B=-B^{2} \\\\ B^{5}\u0026=B^{4}B=-B^{3}=B \\end{align*} $$代入到 $\\exp(\\alpha B)$\n$$ \\begin{align*} \\exp(\\alpha B) \u0026=I+\\alpha B+\\frac{1}{2!}(\\alpha B)^{2}+\\frac{1}{3!}(\\alpha B)^{3}+\\frac{1}{4!}(\\alpha B)^{4}+\\frac{1}{5!}（\\alpha B）^{5}+\\cdots \\\\ \u0026=I+\\alpha B+\\frac{1}{2!}\\alpha^{2}B^{2}-\\frac{1}{3!}\\alpha^{3}B-\\frac{1}{4!}\\alpha^{4}B^{2}+\\frac{1}{5!}\\alpha^{5}B+\\cdots \\\\ \u0026=I+(\\alpha-\\frac{1}{3}\\alpha^{3}+\\frac{1}{5!}\\alpha^{5}-\\cdots)B+(\\frac{1}{2!}\\alpha^{2}-\\frac{1}{4!}\\alpha^{4}+\\cdots)B^{2} \\end{align*} $$觀察上式 $B$ 的係數為 $\\sin(\\alpha)$ 的泰勒展開，而 $B^{2}$ 的係數為 $1-\\cos(\\alpha)$ 的泰勒展開，所以\n$$ \\exp(\\alpha B) = I + (\\sin\\alpha)B + (1-\\cos(\\alpha))B^{2} $$第五問 題目: 給定三維實向量 $a$ ，定義三維實向量 $x$ 的函數 $f$ 如下 (公式略)。其中 $n \\ge 2 $ ，證明當 $x=(I+B^{2})a$ 時，函數 $f$ 取最小值。\n由第四問可知 $\\exp(\\alpha B)$ ，將 $\\alpha=\\frac{2\\pi k}{n}$ 代入得\n$$ \\exp(\\frac{2\\pi k}{n}B)=I+(\\sin(\\frac{2\\pi k}{n}))B+(1-\\cos(\\frac{2\\pi k}{n}))B^{2} $$將 $x=(I+B^{2})a$ 代入 $f$ 得\n$$ \\begin{align*} f(x)\u0026=\\sum_{k=1}^{n}\\left \\| [I+(\\sin(\\frac{2\\pi k}{n}))B+(1-\\cos(\\frac{2\\pi k}{n}))B^{2}]a - (I+B^{2})a \\right \\|^{2} \\\\ \u0026=\\sum_{k=1}^{n}\\left \\| [I+(\\sin(\\frac{2\\pi k}{n}))B+(1-\\cos(\\frac{2\\pi k}{n}))B^{2}-I-B^{2}]a \\right \\|^{2} \\\\ \u0026=\\sum_{k=1}^{n}\\left \\| [(\\sin(\\frac{2\\pi k}{n}))B-(\\cos(\\frac{2\\pi k}{n})B^{2}]a \\right \\|^{2} \\end{align*} $$因為 $f(x)$ 是歐幾里得範數的平方，即距離值，所以 $f(x)\\ge0$\n又因為 $\\sin x$ 和 $\\cos x$ 週期是 $2\\pi$ ，在 $k$ 從 $1$ 到 $n$ 的過程是對其週期進行等分，又因為週期內對稱數值相加和為 $0$，所以\n$$ \\sum_{k=1}^{n}(\\sin(\\frac{2\\pi k}{n}))=\\sum_{k=1}^{n}(\\cos(\\frac{2\\pi k}{n}))=0 $$從而當 $x=(I+B^{2})a$ 時，$f(x)=0$ ，又因為 $f(x)\\ge0$，所以原命題成立。\n參考資料 MIT - 線性代數 由媽咪說製作的 LaTeX 公式編輯器 《線性代數》教學影片 宋浩老師 WikiPedia - 凱萊-哈密頓定理 屠龍大法：利用哈密頓\u0026ndash;凱萊定理直接斬殺矩陣的高次冪，如有砍瓜切菜一般 Wrote with ChatGPT\n","date":"2024-10-14T21:37:58+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/183/","title":"東京大學大學院理工學 數學 2020 問題一 / 東大院理工學 數學 2020 問題一"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 引言 最近因為更換硬碟而重新安裝了電腦系統，當我拿出那多年未動的隨身碟時，裡面的軟體多少有點過時，有些已經無法在新系統上執行，還有好多我已經使用了相同功能的替代品，以及使用了一些新的軟體，遂寫下此文章記錄裝機用到的軟體。\n回頭發現這是 24.09.16 的文章，中間因為有事耽擱，加上狀態不是特別好，直到 24.10.02 才把文章寫完。\n系統 因為用了較長時間的 Win11，所以還是打算繼續使用 Win11。隨身碟裡的系統太舊了，於是去 MSDN itellyou 下載了新版映像檔。\n但是在安裝的時候卻發現這玩意居然必須要連網才能安裝了，就是在設定新系統的時候必須連網登入微軟帳戶，要是沒有網路的話最好使用舊版本 (記得應該是可以跳過的) 或者裝 Win10 (然後再升級 Win11 (doge))。\n2024.10.03\n今天刷到了 兩個跳過網路驗證的方法 ，沒嘗試過，先記錄下來\n第一個是按 Ctrl+Shift+F3 可以直接跳過，同時避免建立在地使用者 (下次重新啟動將重新進行設定)\n第二個是在連網介面按 Shift+F10 然後輸入 oobe\\bypassnro.cmd 之後系統會重新啟動，重啟後在網路頁面會出現沒有網路連接的選項\n軟體相關 我的安裝隨身碟已經好久沒有使用了，裡面的軟體有些我已經不再使用，並且也開始使用一些新的軟體，部分替代了原本的功能，所以還是有必要寫一下的。說不定下次裝機看這篇文章的時候我又會換一批軟體了 (雖然現在我不是很喜歡麻煩的事情)。\n辦公軟體 基礎的 Office 必不可少，採用 Office Tool 進行安裝方便快速。\n以下內容僅安裝 Word、Excel 和 PowerPoint。\n下載 Office Tool: https://otp.landian.vip/zh-cn/download.html 啟動 Office Tool，執行程式碼安裝：\n1 deploy /add O365ProPlusRetail_zh-cn /O365ProPlusRetail.exclapps Access,Bing,Groove,Lync,OneDrive,OneNote,Outlook,Publisher,Teams /channel Current /dlfirst 利用 kms 啟動 Office，執行程式碼啟動：\n1 2 3 ospp /inslicid MondoVolume /sethst:kms.loli.beer /setprt:1688 /act # or use kms.03k.org ospp /inslicid MondoVolume /sethst:kms.03k.org /setprt:1688 /act 參考文章\nhttps://www.coolhub.top/archives/11 https://www.coolhub.top/archives/14 下載工具與雲端硬碟 迅雷: 使用的是忘了從哪找的精簡版。雖然會吸血，但有些東西確實還是得用迅雷下載。\nBitComet: BT 下載工具，同樣使用了精簡版。類似的工具有 qBittorrent, µTorrent 等。\nResilio Sync : 基於 BT 技術的同步軟體，方便各端檔案同步。\nInternet Download Manager: 即 IDM，比較好用的多執行緒下載工具。\n115 : 用於下載一些下不動的 BT。類似的工具有 pikpak。\n百度網盤 : 開了會員很好用，但沒會員就是折磨。時間，加錢可得。與之類似的如阿里網盤、夸克網盤可以在需要時再下載。\n社群軟體 暫時使用的社群軟體也就那樣吧。\nTencent\nQQ : 最近出的 NT 版本確實還行吧。 WeChat: https://www.wechat.com/ Telegram: https://desktop.telegram.org/ 解壓縮工具 之前的電腦上倒是裝了不少的解壓縮工具，但實際上使用的也就兩個，於是這次就只裝兩個了。\nBandizip : 應該是較為流行的吧，之前當我剛聽說時學校電腦教室都用上了。\nWinRAR: 比較古老的軟體，但有些 rar 只有使用此軟體才能解壓縮。\n其他的:\n7-zip : 最為流行的解壓縮軟體。 NanaZip : 7z 的美化版，並且可以在 Win11 第一層右鍵選單顯示。 其他工具 Utools : 非常便捷的工具，官網有動畫介紹，透過外掛擴充使其非常方便，比如本文就是使用其 MarkDown 擴充寫的，雖然有些地方不如 Typora 但勝在方便。\nQuickLook : 快速預覽檔案的工具，用起來不是太理想，希望未來可以找到替代品。非安裝版需要解鎖後使用: https://github.com/QL-Win/QuickLook/issues/1 1Password : 密碼管理工具，可以使用開源替代品 bitwarden 。我已經徹底離不開密碼管理器啦。\nPDF 閱讀器: 感覺大部分都差不多，隨緣用用。\nFoxit PDF Wondershare PDFelement PDF XChange sandboxie : 沙盒工具，對於不想直接在電腦上執行而污染環境的程式很好用，非安裝版每次執行需要管理員權限。\nTickTick : To Do List 軟體，全平台同步，不過最近感覺同步不是太順暢。\nQuiteRSS : RSS 訂閱管理工具，但介面較為古老，不過由於我使用習慣了也無所謂。畢竟轉移只需壓縮解壓縮，RSS 訂閱也不會遺失。\nDuplicate Cleaner Pro: 之前用的清理軟體找不到了，就用八醬的這個啦。雖然有些時候不是太好用，但使用久了後還行吧。\nPixPin : 螢幕截圖工具。\nCode Tools VS Code : 只能說裝機必備了。\nTypora : Markdown 視覺化書寫工具。\nGit: https://git-scm.com/downloads/win Git 安裝後需要設定名稱和電子郵件。同時可以更新一下 Github 的 SSH 公鑰了。\n1 2 git config --global user.name \u0026#34;Your Name\u0026#34; git config --global user.email \u0026#34;email@example.com\u0026#34; 參考文章: https://blog.yexca.net/zh-tw/archives/95 JetBrains\nIntelliJ IDEA : Java 程式設計。 GoLand : Go 程式設計。 Dataflare : 連接資料庫的工具。\nDocker 我已經完全離不開 Docker 了。\n下載地址: https://docs.docker.com/desktop/install/windows-install/ 單獨分一個章節是因為安裝時出錯 WSL Update Failed。\n其實就是需要去 下載最新版本的 WSL ，然後重啟電腦就好了。\n參考文章\nhttps://forums.docker.com/t/wsl-update-failed/140473/3 https://github.com/docker/for-win/issues/13845 https://github.com/docker/for-win/issues/13580#issuecomment-1619667316 MySQL Docker : 因為使用其儲存一些資料，所以還是挺有必要使用的，但使用頻率不是太高，我覺得可以直接裝在 Docker 裡，這樣換系統之類的也方便 (也想過裝在伺服器上，但覺得有時候可能會沒有網路連線)。\n安裝\n1 docker pull mysql:5.7 執行時需要設定連接埠和 ROOT 密碼的環境變數 MYSQL_ROOT_PASSWORD。\n部落格 因為我部落格使用 Jekyll 框架，還需要重新安裝一下，希望不要出問題。\n執行環境\nRuby: https://www.ruby-lang.org/en/downloads/ RubyGems: https://rubygems.org/pages/download Node.js: https://nodejs.org/zh-tw 安裝 Jekyll\n1 gem install jekyll 初始化部落格\n1 bundle 好吧，有幾個外掛我重啟也裝不上，同時參考了 Installation Issues on MacOSX - Gem::Ext::BuildError: ERROR: Failed to build gem native extension 等文章也無法安裝。\n經朋友的提醒，確實還是得用 Docker 比較好，天天搞環境會煩死，明明專案都用 Docker 我部落格居然還在用在地安裝。\n參考我 主題安裝文章 安裝 VS Code 外掛 Dev Containers extension 用於查看容器內部檔案。\n打開 VS Code 按下 F1 輸入 Dev Containers: Clone Repository in Container Volume... 選擇後輸入一個 Git 連結 (即我的 blog 的原始碼)。\n等待一會後 (右下角可以看日誌) 選擇要使用的系統、軟體等配置，我選擇 Debian 系統，軟體我沒選。\n首先更新軟體：\n1 sudo apt-get update 參考 官方教學 安裝 Jekyll：\n1 2 3 sudo apt-get install ruby-full build-essential # 上方是依賴項目 sudo gem install jekyll bundler 安裝 NodeJS：\n1 sudo apt install nodejs 安裝依賴項目：\n1 sudo bundle 會提示不要用 root 權限執行，但這只是容器，隨便弄，無視。\n嘗試部署專案：\n1 bundle exec jekyll s 專案成功執行，但因為是容器的連接埠，需要映射到本機才能看，打開直接能看，VS Code nb (doge)。\n感覺比 Win 編譯的要快，非常 Nice。\n參考文章:\nhttps://jekyllcn.com/docs/installation/ https://jekyllrb.com/docs/installation/windows/#installation-via-bash-on-windows-10 https://code.visualstudio.com/docs/devcontainers/containers#_quick-start-open-a-git-repository-or-github-pr-in-an-isolated-container-volume 結尾 暫時需要用的就這些吧，有一些貌似自己用不到了或者使用頻率低就想不起來了，就這樣，掰掰。\n","date":"2024-10-02T21:35:24+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/182/","title":"2024 裝機紀錄"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 文章撰寫於 2022.11.30，因為早已不再使用此面板與 CuteOne，文章並未有最新適配，可能無法重現。\n同時，當時文章並未完成，我並無相關需求，僅作記錄。\n建置過程 兩篇文章\n寶塔面板 Python 專案管理器安裝 CuteOne – OneDrive 多網路硬碟掛載程式 - 大鳥博客 (daniao.org) CuteOne 建置個人雲端硬碟最完整教學！_將暮的博客-CSDN博客 第一篇文章我在 Python 專案管理器部署後一直無法成功執行，於是找到第二篇文章，內容非常詳細。\n影片持續轉圈無法播放、圖片無法顯示 您可能遇到安裝之後，圖片無法顯示，播放影片也持續在轉圈圈；\n這個問題是因為 SSL 憑證所導致的，假設您沒有使用 SSL，那麼您應該不會有這個問題；\n如果您是使用 SSL 的話，那麼您需要修改：\napp\\templates\\themes\\default\\public\\layout.html\n\u0026lt;!-- \u0026lt;meta http-equiv=\u0026quot;Content-Security-Policy\u0026quot; content=\u0026quot;upgrade-insecure-requests\u0026quot; /\u0026gt;--\u0026gt;\n修改為\n\u0026lt;meta http-equiv=\u0026quot;Content-Security-Policy\u0026quot; content=\u0026quot;upgrade-insecure-requests\u0026quot; /\u0026gt;\n請記得修改之後，在後台的上方會有一個重新啟動按鈕，您需要重新啟動才會生效；\n如果已經生效，您就不需要重新啟動了；\n或者您手動重新啟動也可以；\n所有 SSL 相關的問題都可以依照此方案解決；\n如果後台也遇到同樣狀況。\n後台的檔案路徑是：\napp\\templates\\admin\\public\\layout.html\n也是相同的程式碼。\n","date":"2024-09-10T23:06:59+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/181/","title":"寶塔面板建置 CuteOne"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 文章寫於 2022.05.09，文章並無最新適配，可能無法復現。另推薦使用較新的專案\n透過 OneDrive 可以建立網路硬碟網站，例如我的 VRChat 網路硬碟已經沒了，還可以直接建立網頁，或者圖床\noneindex 簡介 GitHub: https://github.com/avedu/oneindex OneDrive Directory Index，不佔用伺服器空間，不走伺服器流量，直接列出 OneDrive 目錄，檔案直鏈下載。\n環境 需要 PHP5.6+，需啟用 curl 支援，新手（比如我）建議直接使用 寶塔 直接部署，方便快捷\n另因寶塔隱私洩漏風波，有一些其他版本如 寶塔純淨版 ，請自行識別安裝\n安裝 從 GitHub 將儲存庫下載並上傳至網站根目錄並解壓縮\n然後訪問網站，進入安裝程式\n檢測 首先是同意條款，如果點擊同意會返回，請將網址列中最後的 \u0026amp;mdui-dialog 刪除後按回車\n如果環境正常點擊下一步\n程式安裝 點擊獲取應用ID和機密(分兩個頁面顯示，請注意保存)，然後登入微軟帳號\n保留出現的應用機密，然後點擊知道了，返回快速啟動\n注意：此機密僅會顯示一次，請妥善保存\n然後選擇一門語言，比如 Python，點擊 Get a client ID，複製獲得的 Client ID\n返回安裝程式介面，輸入應用機密和 Client ID，然後點擊下一步\n點擊綁定帳號，選擇接受即可\n如果出現錯誤\n請返回輸入應用機密和 Client ID 的介面，打開 Azure 的應用程式註冊 ，這裡應該有兩個應用程式\n找到名為 oneindex 的應用程式，複製它的應用程式 (用戶端) ID 填入 Client ID\n還有一個沒什麼用，可以直接刪除\n管理 安裝完成後會有管理後台和訪問網站選項\n可以進入管理後台修改網站名稱，主題，後台密碼等 (初始密碼: oneindex)\n後台網址為您的網域/?/admin\n偽靜態 設定 Apache 或者 Nginx 的 rewrite (使用 WordPress 的設定即可)\n以上為原作者的原話(部分內容有修改)，因我使用 寶塔 ，遂說明寶塔如何設定\n在寶塔面板的網站進入設定裡的偽靜態，選擇 wordpress 保存即可\n在網站管理後台將偽靜態勾選保存即可\n這樣連結中的 ? 會去除，訪問後台可直接您的網域/admin\n特殊檔案實現功能 Markdown 語法可參考我寫的文章： Markdown 筆記 在資料夾底部添加說明:\n在 OneDrive 的資料夾中添加 README.md 檔案，使用 Markdown 語法。\n在資料夾頭部添加說明:\n在 OneDrive 的資料夾中添加 HEAD.md 檔案，使用 Markdown 語法。\n加密資料夾:\n在 OneDrive 的資料夾中添加 .password 檔案，填入密碼，密碼不能為空。\n直接輸出網頁:\n在 OneDrive 的資料夾中添加 index.html 檔案，程式會直接輸出網頁而不列目錄。 配合 檔案展示設置-直接輸出 效果更佳。\n因為直接輸出網頁，可以直接搭網站\n訪問其他檔案正常，但訪問圖片出現 404 這是由於伺服器軟體 (Nginx/Apache) 接管了圖片處理，刪除相關設定即可\n以下為使用寶塔\n在網站-設定檔案將下述程式碼註解掉即可\n1 2 3 4 5 location ~ .*\\.(gif|jpg|jpeg|png|bmp|swf)$ { expires 30d; access_log on; } 改為\n1 2 3 4 5 #location ~ .*\\.(gif|jpg|jpeg|png|bmp|swf)$ #{ # expires 30d; # access_log on; #} 此問題參考 部署 OneDrive for business (PHP)客戶端程序 OneIndex 详细教程 - VirCloud\u0026rsquo;s Blog - Learning\u0026amp;Sharing 命令列功能 僅能在 PHP CLI 模式下執行\n清除快取:\n1 php one.php cache:clear 重新整理快取:\n1 php one.php cache:refresh 重新整理權杖:\n1 php one.php token:refresh 上傳檔案:\n1 php one.php upload:file 本地檔案 [OneDrive檔案] 上傳資料夾:\n1 php one.php upload:folder 本地資料夾 [OneDrive資料夾] 例如：\n1 2 3 4 5 6 7 8 9 10 11 //上傳 demo.zip 到 OneDrive 根目錄 php one.php upload:file demo.zip //上傳 demo.zip 到 OneDrive /test/ 目錄 php one.php upload:file demo.zip /test/ //上傳 demo.zip 到 OneDrive /test/ 目錄並將其命名為 d.zip php one.php upload:file demo.zip /test/d.zip //上傳 up/ 到 OneDrive /test/ 目錄 php one.php upload:file up/ /test/ 排程任務 [可選]推薦配置，非必需。後台定時重新整理快取，可增加前台訪問的速度。\n1 2 3 4 5 # 每小時重新整理一次權杖 0 * * * * /具體路徑/php /程式具體路徑/one.php token:refresh # 每十分鐘後台重新整理一遍快取 */10 * * * * /具體路徑/php /程式具體路徑/one.php cache:refresh Docker 安裝執行 請參考 TimeBye/oneindex ","date":"2024-08-27T11:00:24+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/180/","title":"基於 OneDrive 建站 (oneindex)"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 文章撰寫於 2022.06.09，因早已不再使用該面板與 OLAINDEX，文章並無最新適配，可能無法復現\n不建議使用寶塔面板\n環境需求 PHP 擴充需求\nPHP \u0026gt;= 7.4 PHP OpenSSL 擴充 PHP PDO 擴充 PHP Mbstring 擴充 PHP Tokenizer 擴充 PHP XML 擴充 PHP Ctype 擴充 PHP JSON 擴充 PHP BCMath 擴充 PHP Fileinfo 擴充 最低安裝標準 nginx+php\n環境安裝 PHP 寶塔的軟體商店搜尋安裝PHP7.4\n然後打開PHP7.4的設定，到停用函式\n將這三個 proc_open，proc_get_status 和 putenv 函式從中刪除\ncomposer 寶塔官方預設 composer 來源為阿里雲無需修改，其他版本可能需要\n1 2 3 curl -sS https://getcomposer.org/installer | php mv composer.phar /usr/local/bin/composer composer config -g repo.packagist composer https://mirrors.aliyun.com/composer # 更換來源為中國大陸鏡像，國外伺服器可忽略此步驟 部署 建立一個網站，PHP 版本記得選擇 PHP-74\n進入網站根目錄，點擊終端機，依序輸入以下指令\n1 2 3 4 5 6 7 8 git clone https://github.com/WangNingkai/OLAINDEX.git tmp mv tmp/.git . rm -rf tmp git reset --hard composer install -vvv # 這裡確保已成功安裝 composer ，如果報權限問題，建議給予使用者完整權限。 chmod -R 777 storage chown -R www:www * # 此處 www 根據伺服器具體使用者群組而定 composer run install-app (此為自動安裝，預設 sqlite 儲存資料) 第五步忽略 fileinfo\n1 2 3 composer install -vvv 改為 composer install -vvv --ignore-platform-req=ext-fileinfo --ignore-platform-req=ext-fileinfo --ignore-platform-req=ext-fileinfo --ignore-platform-req=ext-fileinfo 安裝完成後會出現管理員名稱和密碼\n設定 在網站，點擊網域，找到網站目錄，將執行目錄改為 /public 並儲存\n點擊虛擬靜態 (Rewrite)，選擇 laravel5 並儲存\n點擊設定檔\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 將 location ~ .*\\.(gif|jpg|jpeg|png|bmp|swf)$ { expires 30d; error_log /dev/null; access_log /dev/null; } location ~ .*\\.(js|css)?$ { expires 12h; error_log /dev/null; access_log /dev/null; } 改為 #location ~ .*\\.(gif|jpg|jpeg|png|bmp|swf)$ #{ # expires 30d; # error_log /dev/null; # access_log /dev/null; #} #location ~ .*\\.(js|css)?$ #{ # expires 12h; # error_log /dev/null; # access_log /dev/null; #} 後台 登入網址為 xxx.com/admin，將 xxx.com 替換為您的網域\n預設帳號為 admin，密碼為 123456\n參考文章 寶塔面板安裝OLAINDEX 6.0教程 - 如默星空 OLAINDEX ","date":"2024-08-23T17:14:26+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/179/","title":"寶塔面板架設 OLAINDEX"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 文章寫於 2022.06.12，本不想發布，但見文章寫得較為完整，想著發出來留念吧。因早已不使用該面板與 ZFile，文章並無最新適配，可能無法復現。\n不建議使用寶塔面板\n安裝相依性套件 查看系統版本 1、cat /etc/issue，此指令也適用於所有的 Linux 發行版。\n1 2 3 [root@S-CentOS home]# cat /etc/issue CentOS release 6.5 (Final) Kernel \\r on an \\m 2、cat /etc/redhat-release，這種方法只適合 Redhat 系的 Linux：\n1 2 [root@S-CentOS home]# cat /etc/redhat-release CentOS release 6.5 (Final) 3、lsb_release -a，即可列出所有版本資訊：\n1 2 3 [root@S-CentOS ~]# lsb_release -a LSB Version: :base-4.0-amd64:base-4.0-noarch:core-4.0-amd64:core-4.0-noarch:graphics-4.0-amd64:graphics-4.0-noarch:printing-4.0-amd64:printing-4.0-noarch Distributor ID: CentOS 對應系統輸入相應指令 1 2 3 4 5 # CentOS系統 yum install -y java-1.8.0-openjdk unzip # Debian/Ubuntu系統 apt update apt install -y openjdk-8-jre-headless unzip 建立網站 建立站點\n進入網站目錄，開啟終端機，輸入以下指令：\n1 2 3 wget https://c.jun6.net/ZFILE/zfile-release.war unzip zfile-release.war \u0026amp;\u0026amp; rm -rf zfile-release.war chmod +x ./bin/*.sh 常用指令 在網站目錄下的終端機執行：\n1 2 3 ./bin/start.sh # 啟動專案 ./bin/stop.sh # 停止專案 ./bin/restart.sh # 重啟專案 開放連接埠 在「安全性」中開放 8080 連接埠\n輸入指令啟動專案後，造訪 IP:8080 即可看到網站。\n自定義網域 如需開啟 https，請先申請憑證後開啟反向代理。\n在寶塔面板網站設定中找到「反向代理」。\n目標 URL 為 http://IP:8080，發送網域為 $host。\n如果部署不成功 因使用其他版本的寶塔導致我部署不成功，經自己探索得知設定檔有問題，可嘗試在 反向代理 的 設定檔 處，將以下程式碼替換原先程式碼：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #PROXY-START/ location ^~ / { proxy_pass http://127.0.0.1:8080; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header REMOTE-HOST $remote_addr; add_header X-Cache $upstream_cache_status; #Set Nginx Cache set $static_fileJA2B5K30 0; if ( $uri ~* \u0026#34;\\.(gif|png|jpg|css|js|woff|woff2)$\u0026#34; ) { set $static_fileJA2B5K30 1; expires 12h; } if ( $static_fileJA2B5K30 = 0 ) { add_header Cache-Control no-cache; } } #PROXY-END/ 自定義設定 設定檔目錄為 ./WEB-INF/classes/application.yml\n具體設定項可參考： 官方文件-參數配置 特殊檔案變更（展示檔案） ZFile 的展示檔案預設為 readme.md，但多數架站程式的展示檔案為 README.md。\nZFile 的加密檔案預設為 password.txt，但 oneindex 的為 .password，如果逐一更改檔案名稱顯然太過麻煩。\n開啟 application.yml（在寶塔內雙擊即可編輯），按 CTRL+F，輸入 readme，找到以下程式碼：\n1 2 3 constant: readme: readme.md password: password.txt 改為：\n1 2 3 constant: readme: README.md password: .password 按下 CTRL+S 儲存，然後執行重啟指令即可。\n參考文章 寶塔面板部署 ZFile 網盤系統（原創改良版） - 柚子蜜 linux 查看系統資訊指令 - konglingbin - 博客園 ","date":"2024-08-16T14:43:25+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/178/","title":"寶塔面板架設 ZFile"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 最近伺服器快過期了，便想著把 VRC Blog 遷移到 GitHub 上，於是便想著看看有沒有什麼好的主題，剛開始是想著現在用的 Typecho 主題是從 Jekyll 移植的，但 半年前 去搜尋找不到了，然後最近又有點想了解 Hexo，找了半天主題又想到之前挺喜歡的 Argon 好像有 Hexo 版，然後便有了這篇文章。\n環境 需要安裝 Node.js 10.13 以上版本，推薦 12.0 以上。\n需要安裝 Git。\n安裝 執行指令：\n1 npm install -g hexo-cli 檢查安裝是否成功：\n1 hexo -h 建立新部落格 切換到要安裝的資料夾：\n1 hexo init \u0026lt;folder_name\u0026gt; 進入資料夾：\n1 cd \u0026lt;folder_name\u0026gt; 安裝相依套件：\n1 npm i 建立完成後可以修改 ./_config 進行設定。\n安裝主題 到 主題站 挑選一個主題，不同主題可能有不同的安裝方法，具體請參考主題文件。\n以下為 Argon 主題的安裝範例：\n複製主題 首先在 ./themes 資料夾複製主題儲存庫：\n1 git clone https://github.com/solstice23/hexo-theme-argon.git 將複製下來的資料夾重新命名為 argon。\n安裝 ejs 渲染器：\n1 npm install hexo-renderer-ejs 在 ./_config.yml 檔案中將 theme 改為 argon。\n設定檔 修改檔案 ./themes/argon/_config.yml 以更改設定。\n設定搜尋 在根目錄執行：\n1 npm install hexo-generator-search --save 然後在 ./_config.yml 中加入選項：\n1 2 3 4 search: path: search.xml field: post content: true 寫作 建立新文章：\n1 hexo new [layout] \u0026lt;title\u0026gt; 其中 [layout] 是一個可選屬性，具體如下：\nLayout 描述 路徑 post 文章，預設 source/_posts page 頁面 source draft 草稿 source/_drafts 建立完成後即可開始編寫文章。\n預覽：\n1 hexo s 存取 localhost:4000 查看效果。\n產生靜態檔案 執行指令：\n1 hexo generate 執行指令後只會針對有變動的部分進行產出，建議先將原有的刪除再重新產生會比較好。\n參考文章 https://hexo.io/docs/ https://github.com/solstice23/hexo-theme-argon ","date":"2024-08-09T08:49:53+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/177/","title":"Hexo 安裝與使用"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 問題描述 n-皇后問題是在 n 列 n 行的棋盤上放置 n 個皇后，使得皇后彼此之間不受攻擊，其規則是任意兩個皇后不在同一列、同一行和相同的對角線上 (也就是國際象棋的皇后移動範圍)。\n問題分析 擬採用以下思路解決 n-皇后問題：\n第 i 個皇后放在第 i 列\n從第一個皇后開始，對於每個皇后，從其對應列 (第 i 個皇后對應第 i 列) 的第一行開始嘗試 若可以放置，確定位置，考慮下一個皇后 若與之前的皇后衝突，則考慮下一行 若超出最後一行，則重新確定上一個皇後的位置\n重複該過程，直到找到所有的放置方案\nC 程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;math.h\u0026gt; #define N 4 // 皇后個數 // 判斷第 k 個皇后目前放置位置是否與前面的皇后衝突 int isplace(int pos[], int k){ int i; for(i=1; i\u0026lt;k; i++){ if(pos[i]==pos[k] || fabs(i-k) == fabs(pos[i]-pos[k])) return 0; } return 1; } int main(){ int i,j; int count = 1; int pos[N+1]; // 初始化位置 for(i=1;i\u0026lt;=N;i++) pos[i]=0; j = 1; while(j\u0026gt;=1){ pos[j]=pos[j]+1; // 嘗試擺放第 i 個皇后 while(pos[j]\u0026lt;=N \u0026amp;\u0026amp; !isplace(pos,j)){ pos[j]=pos[j]+1; // 得到一個擺放方案 } if(pos[j]\u0026lt;=N \u0026amp;\u0026amp; j==N){ printf(\u0026#34;方案 %d：\u0026#34;, count++); for(i=1;i\u0026lt;=N;i++) printf(\u0026#34;%d\u0026#34;, pos[i]); printf(\u0026#34;\\n\u0026#34;); } // 考慮下一個皇后 if(pos[j]\u0026lt;=N \u0026amp;\u0026amp; j\u0026lt;N){ j+=1; }else{ // 返回考慮上一個皇后 pos[j]=0; j-=1; } } return 1; } ","date":"2024-07-28T14:26:26+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/176/","title":"演算法 n-皇后問題 (回溯法)"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 前言 先前在將 Typecho 遷移至 Docker 容器後，開啟 HTTPS 時登入後台會報錯，而將 HTTPS 關閉後則可以正常存取。由於先前在非 Docker 部署時可以正常存取，我原以為是 Docker 網路的問題，且當時的修改是一次性的，不會再進行更新，因此我在關閉 HTTPS 完成修改後便不再處理。如今再次使用 Typecho 又遇到相同問題，考量到需要更新文章，於是尋找解決方法。\n解決方法 解決方法非常簡單，在 data/config.inc.php 檔案最後加入以下程式碼：\n1 define(\u0026#39;__TYPECHO_SECURE__\u0026#39;, true); 接著重新啟動即可。\n成因分析 參考資料中推測是因為使用者與瀏覽器之間是透過 HTTPS 互動，但實際上 PHP 接收到的是來自 Cloudflare 的 HTTP 請求，因此 PHP 使用 HTTP 進行回應，進而導致了這個問題。\n參考文章 Typecho HTTPS 無法登入後台 ","date":"2024-07-26T22:22:22+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/175/","title":"Typecho HTTPS 無法登入存取後台"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 ElementUI 是餓了麼團隊開發的，一套為開發者、設計師和產品經理準備的基於 Vue2.0 的桌面端元件函式庫\n元件是組成網頁的部分，例如超連結、按鈕、圖片、表格、表單、分頁條等\nVue2.x 官方網站： 國際 中國大陸 Vue3.x 官方網站： https://element-plus.org/zh-CN/#/zh-CN ElementUI 安裝 安裝 ElementUI 函式庫 (在目前的專案目錄下)，指令\n1 npm install element-ui@2.15.3 導入 ElementUI 元件函式庫\n1 2 3 4 import ElementUI from \u0026#39;element-ui\u0026#39;; import \u0026#39;element-ui/lib/theme-chalk/index.css\u0026#39;; Vue.use(ElementUI); 入門使用 建立 src/views/element/elementView.vue 元件，從官方網站複製程式碼，如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;!-- 按鈕 --\u0026gt; \u0026lt;el-row\u0026gt; \u0026lt;el-button\u0026gt;預設按鈕\u0026lt;/el-button\u0026gt; \u0026lt;el-button type=\u0026#34;primary\u0026#34;\u0026gt;主要按鈕\u0026lt;/el-button\u0026gt; \u0026lt;el-button type=\u0026#34;success\u0026#34;\u0026gt;成功按鈕\u0026lt;/el-button\u0026gt; \u0026lt;el-button type=\u0026#34;info\u0026#34;\u0026gt;資訊按鈕\u0026lt;/el-button\u0026gt; \u0026lt;el-button type=\u0026#34;warning\u0026#34;\u0026gt;警告按鈕\u0026lt;/el-button\u0026gt; \u0026lt;el-button type=\u0026#34;danger\u0026#34;\u0026gt;危險按鈕\u0026lt;/el-button\u0026gt; \u0026lt;/el-row\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { } \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; \u0026lt;/style\u0026gt; 在 App.vue 導入元件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;template\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;element-view\u0026gt;\u0026lt;/element-view\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import elementView from \u0026#39;./views/element/elementView.vue\u0026#39; export default { components: { elementView }, } \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt;\u0026lt;/style\u0026gt; 對於其他元件也是如此\n導入 Axios 安裝\n1 npm install axios 導入\n1 import axios from \u0026#39;axios\u0026#39;; Vue 路由 Vue Router 是 Vue 的官方路由，組成：\nVueRouter：路由器類別，根據路由請求在路由檢視中動態渲染選定的元件 \u0026lt;router-link\u0026gt;：請求連結元件，瀏覽器會解析成連結標籤 \u0026lt;router-view\u0026gt;：動態檢視元件，用於渲染顯示與路由對應的元件 Axios 安裝 指令\n1 npm install vue-router@3.5.1 定義路由 在 src/router/index.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import HomeView from \u0026#39;../views/HomeView.vue\u0026#39; const routes = [ { path: \u0026#39;/\u0026#39;, name: \u0026#39;home\u0026#39;, component: HomeView // 上方導入方式 }, { path: \u0026#39;/emp\u0026#39;, name: \u0026#39;emp\u0026#39;, // 直接導入方式 component: () =\u0026gt; import(\u0026#39;../views/tlias/empView.vue\u0026#39;) }, { path: \u0026#39;/redirect\u0026#39;, // 重新導向 redirect: \u0026#39;/emp\u0026#39; } ] 使用 在需要使用的地方\n1 \u0026lt;router-link to=\u0026#34;/dept\u0026#34;\u0026gt;部門管理\u0026lt;/router-link\u0026gt; 在 App.vue\n1 2 3 4 5 \u0026lt;template\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;router-view\u0026gt;\u0026lt;/router-view\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 在 main.js\n1 2 3 4 5 6 import router from \u0026#39;./router\u0026#39; new Vue({ router, // 使用路由 render: h =\u0026gt; h(App) }).$mount(\u0026#39;#app\u0026#39;) 打包部署 指令\n1 npm run build 指令執行完成後會產生 dist 目錄，將該目錄的檔案部署即可\n","date":"2024-06-03T18:04:58+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/174/","title":"ElementUI"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 早期前後端混合開發，溝通成本高，分工不明確，不便管理，也不便維護與擴展。\n目前主流的開發模式為前後端分離，透過介面文件進行溝通。\n前後端分離開發 前端根據介面文件傳輸參數並解析回應資料，後端則根據介面文件接收參數並給予回應。\n開發流程：需求分析 -\u0026gt; 介面定義 (API 介面文件) -\u0026gt; 前後端平行開發 (遵守規範) -\u0026gt; 測試 -\u0026gt; 前後端聯調測試\n在介面開發完成前，可以使用 YApi 進行測試。\n前端工程化 指的是在企業級的前端專案開發中，將前端開發所需的工具、技術、流程、經驗等進行規範化、標準化。\n模組化：JS、CSS 元件化：UI 結構、樣式、行為 規範化：目錄結構、編碼、介面 自動化：建構、部署、測試 Vue 腳手架 Vue-cli 是 Vue 官方提供的一個腳手架，用於快速生成一個 Vue 專案模板，需要 NodeJS。\nVue-cli 提供了以下功能：\n統一的目錄結構 本機偵錯 熱部署：修改程式碼後無需重新執行，即可載入最新程式。 單元測試 整合打包上線 NodeJS 前往官方網站安裝，並配置 npm 套件位置。\n1 2 3 npm config set prefix \u0026#34;path\u0026#34; # 取得位置 npm config get prefix 切換 npm 的淘寶鏡像站\n1 npm config set registry https://registry.npm.taobao.org 安裝 Vue-cli\n1 npm install -g @vue/cli 確認是否安裝成功\n1 vue --version Vue 專案 有命令列和圖形化介面兩種方式。\n1 2 3 4 # 命令列 vue create project-name # 圖形化介面 vue ui 目錄結構 根目錄：\nnode_modules：存放整個專案的依賴套件 public：專案靜態檔案 src：專案原始碼 package.json：模組基本資訊、專案開發所需的模組、版本資訊 vue.config.js：儲存 Vue 配置的檔案，如代理、連接埠的配置等。 src 資料夾目錄\nassets：靜態資源 components：可重複使用的元件 router：路由配置 views：檢視元件 (頁面) App.vue：入口頁面 (根元件) main.js：入口 JS 檔案 執行專案 使用 VS Code 可以直接在下方執行。\n命令列執行\n1 npm run serve 更改連接埠 在 vue.config.js 檔案中：\n1 2 3 4 5 6 7 const { defineConfig } = require(\u0026#39;@vue/cli-service\u0026#39;) module.exports = defineConfig({ transpileDependencies: true, devServer: { port: 7589 // 連接埠號碼 } }) 開發流程 入口檔案為 src/main.js，以下為預設內容：\n1 2 3 4 5 6 7 8 9 10 import Vue from \u0026#39;vue\u0026#39; import App from \u0026#39;./App.vue\u0026#39; import router from \u0026#39;./router\u0026#39; Vue.config.productionTip = false new Vue({ router, render: h =\u0026gt; h(App) // 將匯入的 App 建立虛擬元素 }).$mount(\u0026#39;#app\u0026#39;) // 掛載到 #app 上述有 import 關鍵字代表匯入元件，與之相對的 export 代表匯出元件。\n上述 Vue 物件程式碼類似：\n1 2 3 4 5 6 new Vue({ el: \u0026#34;#app\u0026#34;, // router: router, router, // 當值與鍵相同可省略 render: h =\u0026gt; h(App) }) Vue 的元件檔案以 .vue 結尾，每個元件由三個部分組成：\u0026lt;template、script、\u0026lt;style\u0026gt;。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;!-- HTML 標籤 --\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; // JS export default{ data(){ return{ // 資料模型 } }, methods:{ // 方法 } } \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; /* CSS */ \u0026lt;/style\u0026gt; ","date":"2024-05-28T16:22:15+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/173/","title":"簡易 Vue 專案"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 引言 畢業論文真是折磨呢。這是什麼時候的文章呢，這個檔案建立時間 2023.11.30 而修改時間 2022.09.18，我看不懂，但我大受震撼\n程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 \u0026lt;script\u0026gt; function secondToDate(second) { if (!second) { return 0; } var time = new Array(0, 0, 0, 0, 0); if (second \u0026gt;= 365 * 24 * 3600) { time[0] = parseInt(second / (365 * 24 * 3600)); second %= 365 * 24 * 3600; } if (second \u0026gt;= 24 * 3600) { time[1] = parseInt(second / (24 * 3600)); second %= 24 * 3600; } if (second \u0026gt;= 3600) { time[2] = parseInt(second / 3600); second %= 3600; } if (second \u0026gt;= 60) { time[3] = parseInt(second / 60); second %= 60; } if (second \u0026gt; 0) { time[4] = second; } return time; }\u0026lt;/script\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; language=\u0026#34;javascript\u0026#34;\u0026gt; function setTime() { var create_time = Math.round(new Date(Date.UTC(2021, 11, 6, 14, 15, 19)).getTime() / 1000); var timestamp = Math.round((new Date().getTime() + 8 * 60 * 60 * 1000) / 1000); currentTime = secondToDate((timestamp - create_time)); currentTimeHtml = \u0026#39;This Blog has running: \u0026lt;br/\u0026gt;\u0026#39; + currentTime[0] + \u0026#39; y \u0026#39; + currentTime[1] + \u0026#39; d \u0026#39; + currentTime[2] + \u0026#39; h \u0026#39; + currentTime[3] + \u0026#39; m \u0026#39; + currentTime[4] + \u0026#39; s\u0026#39;; document.getElementById(\u0026#34;htmer_time\u0026#34;).innerHTML = currentTimeHtml; } setInterval(setTime, 1000); \u0026lt;/script\u0026gt; 引用 在想放入的地方加入\n1 \u0026lt;span id=\u0026#34;htmer_time\u0026#34; style=\u0026#34;color: pink;\u0026#34; /\u0026gt; 參考文章 個人部落格添加運作時間 - 騰訊雲開發者社群-騰訊雲 ","date":"2024-05-14T11:08:25+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/172/","title":"部落格運作時間"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 Gateway 是所有微服務的統一入口點，具有以下功能：\n身份驗證與權限檢查：閘道器作為微服務入口點，需要驗證使用者是否有請求資格，如果沒有則進行攔截。 請求路由、負載平衡：所有請求都必須先經過Gateway，但閘道器不處理商業邏輯，而是根據某種規則，將請求轉發到某個微服務，這個過程稱為路由。當然，當路由的目標服務有多個時，還需要進行負載平衡。 流量限制：當請求流量過高時，在閘道器中依照下游微服務能夠接受的速度來放行請求，避免服務壓力過大。 SpringCloud 的閘道器實作有兩種：\nZuul：基於 Servlet 實作，屬於阻塞式程式設計。 SpringCloudGateway：基於 Spring5 中提供的 WebFlux，屬於響應式程式設計的實作，具備更好的效能。 簡單入門 建立專案，引入依賴：\n1 2 3 4 5 6 7 8 9 10 \u0026lt;!--閘道器--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-gateway\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--nacos服務發現依賴--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-alibaba-nacos-discovery\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 編寫基本設定和路由規則：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 server: port: 10010 # 閘道器埠號 spring: application: name: gateway # 服務名稱 cloud: nacos: server-addr: localhost:8848 # nacos位址 gateway: routes: # 閘道器路由設定 - id: user-service # 路由ID，自訂，只要唯一即可 # uri: http://127.0.0.1:8081 # 路由的目標位址 http就是固定位址 uri: lb://userService # 路由的目標位址 lb就是負載平衡，後面接服務名稱 predicates: # 路由斷言，也就是判斷請求是否符合路由規則的條件 - Path=/user/** # 這個是依照路徑匹配，只要以/user/開頭就符合要求 然後存取 \u0026lt;localhost:10010/user/1\u0026gt; 進行測試。\n路由設定包含：\n路由ID：路由的唯一識別。 路由目標 (uri)：路由的目標位址，http 代表固定位址，lb 代表根據服務名稱負載平衡。 路由斷言 (predicates)：判斷路由的規則，符合則轉發到路由目的地。 路由過濾器 (filters)：對請求或回應進行處理。 斷言工廠 在設定檔中編寫的斷言規則僅是字串，這些字串會被 Predicate Factory 讀取並處理，轉換為路由判斷的條件。\n例如上述範例 Path=/user/** 是依照路徑匹配，這個規則是由 org.springframework.cloud.gateway.handler.predicate.PathRoutePredicateFactory 類別來處理的，類似的斷言工廠有：\n名稱 說明 範例 After 某個時間點之後的請求 - After=2037-01-20T17:42:47.789-07:00[America/Denver] Before 某個時間點之前的請求 - Before=2031-04-13T15:14:47.433+08:00[Asia/Shanghai] Between 某兩個時間點之間的請求 - Between=2037-01-20T17:42:47.789-07:00[America/Denver], 2037-01-21T17:42:47.789-07:00[America/Denver] Cookie 請求必須包含某些Cookie - Cookie=chocolate, ch.p Header 請求必須包含某些標頭 - Header=X-Request-Id, \\d+ Host 請求必須是存取某個主機 (網域) - Host=.somehost.org,.anotherhost.org Method 請求方式必須是指定方式 - Method=GET,POST Path 請求路徑必須符合指定規則 - Path=/red/{segment},/blue/** Query 請求參數必須包含指定參數 - Query=name, Jack或者- Query=name RemoteAddr 請求者的IP必須是指定範圍 - RemoteAddr=192.168.1.1/24 Weight 權重處理 過濾器工廠 GatewayFilter 是閘道器中提供的一種過濾器，可以對進入閘道器的請求和微服務回傳的回應進行處理。\nSpring 提供了 31 種不同的路由過濾器工廠，例如：\n名稱 說明 AddRequestHeader 給當前請求添加一個請求標頭 RemoveRequestHeader 移除請求中的一個請求標頭 AddResponseHeader 給回應結果中添加一個回應標頭 RemoveResponseHeader 從回應結果中移除一個回應標頭 RequestRateLimiter 限制請求的流量 更多參考： https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway/gatewayfilter-factories.html 請求標頭過濾器 以請求標頭過濾器為例，給所有進入 userService 的請求添加一個請求標頭：Hello=World。\n在 gateway 中修改 application.yml，添加路由過濾：\n1 2 3 4 5 6 7 8 9 10 spring: cloud: gateway: routes: - id: user-service uri: lb://userservice predicates: - Path=/user/** filters: # 過濾器 - AddRequestHeader=Hello, World # 添加請求標頭 然後可以修改 Controller 進行測試：\n1 2 3 4 5 @GetMapping(\u0026#34;/{id}\u0026#34;) public User queryById(@PathVariable(\u0026#34;id\u0026#34;) Long id, @RequestHeader(\u0026#34;Hello\u0026#34;) String hello) { System.out.println(hello); return userService.queryById(id); } 預設過濾器 如果想對所有的路由都生效，則可以將過濾器工廠寫在 default 下：\n1 2 3 4 5 6 7 8 9 10 spring: cloud: gateway: routes: - id: user-service uri: lb://userservice predicates: - Path=/user/** default-filters: # 預設過濾項 - AddRequestHeader=Hello, World 全域過濾器 閘道器提供了 31 種過濾器，但每一種過濾器的作用都是固定的。如果我們希望攔截請求，執行自己的商業邏輯，則無法實作。\n而全域過濾器的作用也是處理所有進入閘道器的請求和微服務回應，與 GatewayFilter 的作用一樣。區別在於 GatewayFilter 透過設定定義，處理邏輯是固定的；而 GlobalFilter 的邏輯需要自己編寫程式碼實作，定義方式是實作 GlobalFilter 介面：\n1 2 3 4 5 6 7 8 9 10 public interface GlobalFilter { /** * 處理當前請求，如有必要，透過{@link GatewayFilterChain}將請求交給下一個過濾器處理 * * @param exchange 請求上下文，其中可以取得Request、Response等資訊 * @param chain 用來將請求委託給下一個過濾器 * @return {@code Mono\u0026lt;Void\u0026gt;} 回傳表示當前過濾器業務結束 */ Mono\u0026lt;Void\u0026gt; filter(ServerWebExchange exchange, GatewayFilterChain chain); } 在 filter 中編寫自訂邏輯，可以實作下列功能：\n登入狀態判斷 權限驗證 請求流量限制等 簡單使用 目標：定義全域過濾器，攔截請求，判斷請求的參數是否符合以下條件：\n參數中是否有 authorization， authorization 參數值是否為 admin。 若同時符合則放行，否則攔截。\n首先在 gateway 中定義一個過濾器：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 @Order(-1) // 優先處理 @Component public class AuthorizeFilter implements GlobalFilter { @Override public Mono\u0026lt;Void\u0026gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) { // 取得請求參數 MultiValueMap\u0026lt;String, String\u0026gt; params = exchange.getRequest().getQueryParams(); // 取得AuthorizeFilter參數，此處約定第一個為認證參數 String authorize = params.getFirst(\u0026#34;AuthorizeFilter\u0026#34;); // 檢查 if(\u0026#34;admin\u0026#34;.equals(authorize)){ // 放行 return chain.filter(exchange); } // 攔截，禁止存取 exchange.getResponse().setStatusCode(HttpStatus.FORBIDDEN); // 結束處理 return exchange.getResponse().setComplete(); } } 過濾器執行順序 請求進入閘道器會遇到三種過濾器：當前路由的過濾器、DefaultFilter、GlobalFilter。\n請求路由後，會將當前路由過濾器和 DefaultFilter、GlobalFilter，合併到一個過濾器鏈（集合）中，排序後依序執行每個過濾器。\n每個過濾器都有 int 類型的 order 值，order 值越小，優先序越高，執行順序越靠前。\n路由過濾器和 defaultFilter 的 order 值由 Spring 指定，預設從 1 開始遞增。\nGlobalFilter 透過實作 Ordered 介面，或是添加 @Order 註解來指定 order 值，由我們自己指定。\n當過濾器的 order 值相同時，會依照 defaultFilter \u0026gt; 路由過濾器 \u0026gt; GlobalFilter 的順序執行。\n其中透過實作介面指定 order 值：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 //@Order(-1) // 優先處理 @Component public class AuthorizeFilter implements GlobalFilter, Ordered { @Override public Mono\u0026lt;Void\u0026gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) { // 取得請求參數 MultiValueMap\u0026lt;String, String\u0026gt; params = exchange.getRequest().getQueryParams(); // 取得AuthorizeFilter參數，此處約定第一個為認證參數 String authorize = params.getFirst(\u0026#34;AuthorizeFilter\u0026#34;); // 檢查 if(\u0026#34;admin\u0026#34;.equals(authorize)){ // 放行 return chain.filter(exchange); } // 攔截，禁止存取 exchange.getResponse().setStatusCode(HttpStatus.FORBIDDEN); // 結束處理 return exchange.getResponse().setComplete(); } @Override public int getOrder() { return -1; } } 跨網域問題 同網域表示協定相同、IP 或網域名稱相同、埠號相同。\n跨網域問題：瀏覽器禁止請求發起者與伺服端發生跨網域 AJAX 請求，請求被瀏覽器攔截的問題，解決方案便是 CORS。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 spring: cloud: gateway: globalcors: # 全域的跨網域處理 add-to-simple-url-handler-mapping: true # 解決options請求被攔截問題 corsConfigurations: \u0026#39;[/**]\u0026#39;: allowedOrigins: # 允許哪些網站的跨網域請求 - \u0026#34;http://localhost:8090\u0026#34; allowedMethods: # 允許的跨網域AJAX請求方式 - \u0026#34;GET\u0026#34; - \u0026#34;POST\u0026#34; - \u0026#34;DELETE\u0026#34; - \u0026#34;PUT\u0026#34; - \u0026#34;OPTIONS\u0026#34; allowedHeaders: \u0026#34;*\u0026#34; # 允許在請求中攜帶的標頭資訊 allowCredentials: true # 是否允許攜帶Cookie maxAge: 360000 # 這次跨網域偵測的有效期限 ","date":"2024-05-05T00:54:52+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/171/","title":"Gateway 服務閘道器"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 Feign 是一個宣告式的 HTTP 用戶端，Github： https://github.com/OpenFeign/feign 簡單用法 引用相依性\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-openfeign\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 在啟動類別加入註解以開啟 Feign 的功能\n1 2 @EnableFeignClients @SpringBootApplication 撰寫 Feign 用戶端\n1 2 3 4 5 @FeignClient(\u0026#34;userService\u0026#34;) public interface UserClient { @GetMapping(\u0026#34;/user/{id}\u0026#34;) User findById(@PathVariable(\u0026#34;id\u0026#34;) Long id); } 取代 RestTemplate\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 @Service public class OrderService { @Autowired private OrderMapper orderMapper; // @Autowired // private RestTemplate restTemplate; @Autowired private UserClient userClient; public Order queryOrderById(Long orderId) { // 1.查詢訂單 Order order = orderMapper.findById(orderId); // 2.查詢使用者 // String url = \u0026#34;http://localhost:8081/user/\u0026#34; + order.getUserId(); // String url = \u0026#34;http://userService/user/\u0026#34; + order.getUserId(); // User user = restTemplate.getForObject(url, User.class); // Feign User user = userClient.findById(order.getUserId()); // 3.封裝使用者資訊 order.setUser(user); // 4.回傳 return order; } } 自訂設定 Feign 支援自訂設定來覆寫預設設定，可修改的設定如下：\n類型 作用 說明 feign.Logger.Level 修改日誌等級 包含四種不同的等級：NONE、BASIC、HEADERS、FULL feign.codec.Decoder 回應結果的解析器 HTTP 遠端呼叫的結果解析，例如將 JSON 字串解析為 Java 物件 feign.codec.Encoder 請求參數編碼 將請求參數編碼，以便透過 HTTP 請求傳送 feign. Contract 支援的註解格式 預設是 SpringMVC 的註解 feign. Retryer 失敗重試機制 請求失敗的重試機制，預設沒有，但會使用 Ribbon 的重試 通常只需設定日誌等級，日誌等級有：\nNONE：不記錄任何日誌資訊，這是預設值 BASIC：僅記錄請求的方法、URL、回應狀態碼以及執行時間 HEADERS：在 BASIC 的基礎上，額外記錄了請求和回應的標頭資訊 FULL：記錄所有請求和回應的明細，包括標頭資訊、請求本體、中繼資料 設定方式有兩種，一種是設定檔，另一種是建立 Bean\n設定檔 設定檔針對單一服務\n1 2 3 4 5 feign: client: config: userservice: # 針對某個微服務的設定 loggerLevel: FULL # 日誌等級 針對所有服務\n1 2 3 4 5 feign: client: config: default: # 這裡使用 default 代表全域設定，如果寫服務名稱，則是針對某個微服務的設定 loggerLevel: FULL # 日誌等級 bean 先宣告一個類別，然後宣告一個 Logger.Level 的物件\n1 2 3 4 5 6 public class DefaultFeignConfiguration { @Bean public Logger.Level feignLogLevel(){ return Logger.Level.BASIC; // 日誌等級為 BASIC } } 如果要在全域生效，請放在啟動類別的 @EnableFeignClients 註解中\n1 @EnableFeignClients(defaultConfiguration = DefaultFeignConfiguration .class) 如果是區域生效，請放在 @FeignClient 註解中\n1 @FeignClient(value = \u0026#34;userService\u0026#34;, configuration = DefaultFeignConfiguration .class) Feign 使用優化 Feign 底層用戶端實作：\nURLConnection：預設實作，不支援連線池\nApache HttpClient ：支援連線池\nOKHttp：支援連線池\n使用連線池可以提升 Feign 的效能\n以下範例為取代為 HttpClient\n引用相依性 1 2 3 4 5 \u0026lt;!-- httpClient 的相依性 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.github.openfeign\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;feign-httpclient\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 設定連線池 1 2 3 4 5 6 7 8 9 feign: client: config: default: # default 全域設定 loggerLevel: BASIC # 日誌等級，BASIC 代表基本的請求和回應資訊 httpclient: enabled: true # 開啟 Feign 對 HttpClient 的支援 max-connections: 200 # 最大連線數 max-connections-per-route: 50 # 每個路徑的最大連線數 最佳實踐 所謂最佳實踐，就是在使用過程中歸納的經驗，是一種最佳的使用方式\nFeign 的用戶端與服務提供者的 Controller 程式碼非常相似\n1 2 3 4 5 6 7 8 9 10 11 12 // Feign 用戶端 @FeignClient(\u0026#34;userService\u0026#34;) public interface UserClient { @GetMapping(\u0026#34;/user/{id}\u0026#34;) User findById(@PathVariable(\u0026#34;id\u0026#34;) Long id); } // Controller @GetMapping(\u0026#34;/user/{id}\u0026#34;) public User queryById(@PathVariable(\u0026#34;id\u0026#34;) Long id) { return userService.queryById(id); } 對於重複的程式碼，有兩種簡化方法\n方式一：繼承 為消費者的 FeignClient 和提供者的 Controller 定義統一的父介面作為標準\n定義一個介面\n1 2 3 4 public interface UserAPI{ @GetMapping(\u0026#34;/user/{id}\u0026#34;) User findById(@PathVariable(\u0026#34;id\u0026#34;) Long id); } Feign 用戶端實作\n1 2 @FeignClient(value=\u0026#34;userService\u0026#34;) public interface UserClient extends UserAPI{} Controller 類別\n1 2 3 4 5 6 @RestController public class UserController implements UserAPI{ public User findById(@PathVariable(\u0026#34;id\u0026#34;) Long id){ // 程式碼 } } 優點：簡單，實作了程式碼共享\n缺點：\n服務提供者、消費者強耦合 參數列表中的註解映射並不會繼承，因此 Controller 中必須再次宣告方法、參數列表、註解 方式二：抽離方式 將 FeignClient 抽離為獨立模組，並且把介面相關的 POJO、預設的 Feign 設定都放到這個模組中，提供給所有消費者使用\n建立一個新專案，引用 Feign 起始相依性\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-openfeign\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 在消費者端引用 feign-api 的相依性\n當定義的 FeignClient 不在 SpringBootApplication 的掃描套件範圍時，這些 FeignClient 無法使用，有兩種方式解決\n指定 Feign 應該掃描的套件 1 @EnableFeignClients(basePackages = \u0026#34;net.yexca.feign.clients\u0026#34;) 指定要載入的 Client 介面 1 @EnableFeignClients(clients = {UserClient.class}) ","date":"2024-05-03T23:11:52+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/170/","title":"Feign 遠端呼叫"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 需先安裝軟體，官網： https://nacos.io/zh-cn/ 在 conf/application.properties 檔案中可以更改連接埠，預設為 8848\n註冊服務 父專案中新增管理相依性\n1 2 3 4 5 6 7 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-alibaba-dependencies\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.6.RELEASE\u0026lt;/version\u0026gt; \u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt; \u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; 註解掉 Eureka 的相依性，並新增 Nacos 用戶端的相依性\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-alibaba-nacos-discovery\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 修改 application.yml，新增 Nacos 位址，註解掉 Eureka 位址\n1 2 3 4 spring: cloud: nacos: server-addr: localhost:8848 啟動 Nacos\n1 2 startup.cmd -m standalone # 參數為單機啟動 存取 http://localhost:8848/nacos/ 登入帳號密碼皆為 nacos\n分級儲存模型 服務分為多個叢集，每個叢集有多個實例，叢集可以按地區分配，以提高存取速度\n相對的，Eureka 只有 服務-實例，沒有叢集\n服務呼叫應盡可能選擇本地叢集的服務，跨叢集呼叫延遲較高。當本地叢集不可存取時，再去存取其他叢集\n可以透過 application.yml 設定叢集\n1 2 3 4 5 6 spring: cloud: nacos: server-addr: localhost:8848 discovery: cluster-name: Shanghai # 叢集名稱 然後將 Ribbon 的策略設定為 Nacos 的策略\n1 2 3 4 5 # 為某個微服務設定負載平衡規則，這裡是以 userService 服務為例 userService: ribbon: NFLoadBalancerRuleClassName: com.alibaba.cloud.nacos.ribbon.NacosRule # NFLoadBalancerRuleClassName: com.netflix.loadbalancer.Nac # 負載平衡規則 接著可以在 Nacos 設定實例的權重 (0-1)，權重越大，存取頻率越高\n環境隔離 Nacos 中服務儲存和資料儲存的最外層都是一個名為 namespace 的東西，用來做最外層隔離\n可以在 Nacos 中新建一個命名空間，例如 dev，然後修改 application.yml\n1 2 3 4 5 6 7 spring: cloud: nacos: server-addr: localhost:8848 discovery: cluster-name: Shanghai # 叢集名稱 namespace: UUID # 此處為命名空間的 UUID 不同 namespace 下的服務互相不可見，無法存取\n臨時實例與非臨時實例 對於臨時實例，Nacos 的處理方式與 Eukera 一致\n對於非臨時實例，Nacos 會主動詢問是否存活，服務不可用時不會刪除，在服務不可用時，Nacos 會主動通知消費者\n設定非臨時實例：\n1 2 3 4 5 spring: cloud: nacos: discovery: ephemeral: false # 設定為非臨時實例 Nacos 設定管理 當微服務部署的實例變多時，逐個更改設定非常麻煩，可以使用 Nacos 將設定集中管理，並且支援熱更新\n簡單使用 在 Nacos 控制台的設定管理中新增設定，其中 Data ID 為設定檔的 ID，格式為 [服務名稱]-[profile].[副檔名]，例如 userService-dev.yaml\n然後在設定內容中撰寫設定即可，例如：\n1 2 pattern: dateformat: yyyy-MM-dd HH:mm:ss 引入 Nacos 的設定管理用戶端相依性\n1 2 3 4 5 \u0026lt;!--nacos 設定管理相依性--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-alibaba-nacos-config\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 取得設定的步驟\n專案啟動 -\u0026gt; bootstrap.yml -\u0026gt; Nacos 設定檔 -\u0026gt; 本地 application.yml -\u0026gt; 建立 Spring 容器 -\u0026gt; 載入 bean\n新增 bootstrap.yml\n1 2 3 4 5 6 7 8 9 10 spring: application: name: userService # 服務名稱 profiles: active: dev # 開發環境，這裡設定為 dev cloud: nacos: server-addr: localhost:8848 # Nacos 位址 config: file-extension: yaml # 檔案副檔名 測試\n1 2 3 4 5 6 7 8 9 10 11 12 @RestController @RequestMapping(\u0026#34;/user\u0026#34;) public class UserController{ @Value(\u0026#34;${pattern.dateformat}\u0026#34;) private String dateformat; @GetMapping(\u0026#34;/now\u0026#34;) public String now(){ return LocalDateTime.now().format(DateTimeFormatter.ofPattern(dateformat)) } } 存取頁面查看效果\n熱更新 可以透過兩種方式實現\n方式一：在 @Value 注入的變數所在類別上加上註解 @RefreshScope\n1 2 3 4 5 6 7 8 9 10 11 12 13 @RefreshScope // 設定自動刷新 @RestController @RequestMapping(\u0026#34;/user\u0026#34;) public class UserController{ @Value(\u0026#34;${pattern.dateformat}\u0026#34;) private String dateformat; @GetMapping(\u0026#34;/now\u0026#34;) public String now(){ return LocalDateTime.now().format(DateTimeFormatter.ofPattern(dateformat)) } } 方式二：使用 @ConfigurationProperties\n新建設定類別\n1 2 3 4 5 6 @Component @Data @ConfigurationProperties(prefix = \u0026#34;pattern\u0026#34;) public class PatternProperties { private String dateformat; } Controller 類別\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // @RefreshScope // 設定自動刷新 @RestController @RequestMapping(\u0026#34;/user\u0026#34;) public class UserController{ // @Value(\u0026#34;${pattern.dateformat}\u0026#34;) // private String dateformat; @Autowired private PatternProperties properties; @GetMapping(\u0026#34;/now\u0026#34;) public String now(){ return LocalDateTime.now().format(DateTimeFormatter.ofPattern(properties.getDateformat())) } } 設定共享 微服務啟動時，會從 Nacos 讀取多個設定檔\n[spring.application.name]-[spring.profiles.active].yaml，例如：userService-dev.yaml\n[spring.application.name].yaml，例如：userService.yaml\n而第二個 [spring.application.name].yaml 不包含環境資訊，可以被多個環境共享\n設定優先順序：[spring.application.name]-[spring.profiles.active].yaml \u0026gt; [spring.application.name].yaml \u0026gt; 本地設定\n","date":"2024-05-02T22:36:17+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/169/","title":"Nacos 註冊中心"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 消費者發送請求會被 Ribbon 攔截，Ribbon 從 Eureka 取得提供者列表，Eureka 回傳提供者列表，Ribbon 根據 IRule 選擇伺服器發送請求。\n詳細攔截：請求 -\u0026gt; DynamicServerListLoadBalancer (獲取 URL 中的服務 ID, userService) -\u0026gt; DynamicServerListLoadBalancer -\u0026gt; Eureka -\u0026gt; DynamicServerListLoadBalancer -\u0026gt; IRule -\u0026gt; DynamicServerListLoadBalancer -\u0026gt; 發送請求\n負載平衡策略 內建負載平衡規則類別 規則描述 ZoneAvoidanceRule (Eureka 預設) 以區域可用的伺服器為基礎進行伺服器的選擇。使用 Zone 對伺服器進行分類，這個 Zone 可以理解為一個機房、一個機架等。而後再對 Zone 內的多個服務做輪詢 RoundRobinRule 簡單輪詢服務列表來選擇伺服器。它是 Ribbon 預設的負載平衡規則 AvailabilityFilteringRule 對以下兩種伺服器進行忽略： （1）在預設情況下，這台伺服器如果 3 次連線失敗，這台伺服器就會被設置為「短路」狀態。短路狀態將持續 30 秒，如果再次連線失敗，短路的持續時間就會呈幾何級數增加（2）併發數過高的伺服器。如果一個伺服器的併發連線數過高，配置了 AvailabilityFilteringRule 規則的用戶端也會將其忽略。併發連線數的上限，可以由用戶端的 \u0026lt;clientName\u0026gt;.\u0026lt;clientConfigNameSpace\u0026gt;.ActiveConnectionsLimit 屬性進行配置 WeightedResponseTimeRule 為每一個伺服器賦予一個權重值。伺服器回應時間越長，這個伺服器的權重就越小。這個規則會隨機選擇伺服器，這個權重值會影響伺服器的選擇 BestAvailableRule 忽略那些短路的伺服器，並選擇併發數較低的伺服器 RandomRule 隨機選擇一個可用的伺服器 RetryRule 重試機制的選擇邏輯 使用隨機策略 透過定義 IRule 實作可以修改負載平衡規則，有兩種方式：\n程式碼方式：在配置類別中，定義一個新的 IRule (全域設定) 1 2 3 4 @Bean public IRule randomRule(){ return new RandomRule(); } 設定檔方式：在 orderServer application.yml 檔案中，新增設定以修改規則 1 2 3 userService: # 為某個微服務配置負載平衡規則，這裡是 userservice 服務 ribbon: NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule # 負載平衡規則 懶載入 Ribbon 預設是採用懶載入 (Lazy Load)，即第一次存取時才會去建立 LoadBalanceClient，請求時間會很長；而預先載入 (Eager Load) 則會在專案啟動時建立，降低第一次存取的耗時。配置開啟預先載入：\n1 2 3 4 ribbon: eager-load: enabled: true clients: userService # 指定對 userService 這個服務進行預先載入 ","date":"2024-04-28T15:50:15+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/168/","title":"Ribbon 負載平衡"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 顯示模式 顯示模式是指標籤的呈現方式，用於排版網頁時，根據標籤的顯示模式選擇合適的標籤來擺放內容。\n區塊級元素 (例如 div) 獨佔一行 寬度預設為父層的 100% 新增寬高屬性後生效 行內元素 (例如 span) 一行中可顯示多個 設定寬高屬性後不生效 寬高尺寸由內容撐開 行內區塊元素 (例如 img) 一行中可顯示多個 設定寬高屬性後生效 寬高尺寸也可以由內容撐開 可以透過 CSS 屬性 display 轉換顯示模式，其值為：\n效果 區塊級 行內 行內區塊 屬性值 block inline inline-block 盒子模型 作用：排版網頁，擺放盒子與內容\n盒子模型組成部分：\n內容區域：width \u0026amp; height 內邊距：padding (出現在內容與盒子邊緣之間) 邊框線：border 外邊距：margin (出現在盒子外面) 邊框線 屬性值：邊框線粗細 線條樣式 顏色 不區分順序\n常見線條樣式有：\n線條樣式 實線 虛線 點線 屬性值 solid dashed dotted 1 2 3 div { border: 1px solid aqua; } 當然，還有可以設定單獨方向的屬性，屬性值同上。\n1 2 3 4 5 6 div { border-top: 1px solid red; border-left: 1px dashed red; border-bottom: 1px dotted red; border-right: 1px solid blue; } 內邊距 設定內容與盒子邊緣之間的距離\n1 2 3 4 5 6 7 8 9 10 11 12 /* 四個方向內邊距相同 */ div { padding: 10px; } /* 分別設定四個方向 */ div { padding-top: 10px; padding-right: 20px; padding-bottom: 5px; padding-left: 10px; } padding 也有多值寫法，可以透過一個屬性控制四個內邊距\n取值個數 示例 含義 一個 padding: 10px; 四個方向皆為 10px 四個 padding: 10px 20px 30px 40px; 上 右 下 左 (順時針) 兩個 padding: 10px 30px 20px; 上 左右 下 三個 padding: 10px 20px; 上下 左右 尺寸內減模式 預設情況下，盒子尺寸 = 內容尺寸 + 內邊距尺寸 + 邊框尺寸，也就是說當給盒子加上 padding 和 border 屬性後，盒子會變大。\n1 2 3 4 5 6 div { height: 200px; width: 200px; /* 此盒子尺寸會變為 240*240 */ padding: 20px; } 如果想要盒子大小為 200*200，需要手動計算並將 heigh 和 width 值調整為 160px。\n而加上 box-sizing: border-box 後，盒子的大小將會恆定保持為 heigh 和 width 值。\n1 2 3 4 5 6 7 div { height: 200px; width: 200px; /* 此盒子尺寸為 200*200 */ padding: 20px; box-sizing: border-box; } 外邊距 作用：拉開兩個盒子之間的距離。屬性值與 padding 的寫法相同。\n外邊距不會使盒子變大\n如果將 margin 的左右屬性值設定為 auto，該盒子將會水平置中。\n1 2 3 4 5 6 div { height: 200px; width: 800px; /* 此盒子將會水平置中 */ margin: 0 auto; } 合併現象 垂直排列的同級元素，上下 margin 會合併，取值為較大的 margin。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;style\u0026gt; .box1 { width: 200px; height: 100px; background-color: aqua; margin-bottom: 10px; } /* 兩個盒子之間間隔 20px */ .box2 { width: 100px; height: 100px; background-color: aquamarine; margin-top: 20px; } \u0026lt;/style\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;box1\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box2\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; 塌陷問題 父子級標籤，子級新增上外邊距將會產生塌陷。會導致父級一起向下位移。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;style\u0026gt; .father{ width: 300px; height: 300px; background-color: pink; } .son{ width: 100px; height: 100px; background-color: aqua; /* 兩個盒子將一起向下塌陷 50px */ margin-top: 50px; } \u0026lt;/style\u0026gt; \u0026lt;div class=\u0026#34;father\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;son\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 解決方法：\n取消子級 margin，父級使用 padding 父級設定 overflow: hidden 父級設定 border-top 元素溢位 當盒子內容超過盒子大小時將產生溢位，可以用 overflow 屬性控制溢位元素的內容顯示方式。\n屬性值 效果 hidden 溢位隱藏 scroll 溢位捲動 (無論是否溢位，都顯示捲軸) auto 溢位捲動 (溢位才顯示捲軸) 行內元素垂直位置 行內元素 (如 span) 新增 margin 和 padding 無法改變垂直位置，此時可以透過行高來改變。\n1 2 3 4 5 6 span { margin: 50px; padding: 20px; line-height: 100px; } 圓角效果 使用屬性 border-radius 設定元素的外部邊框為圓角，屬性值為圓角半徑，可以使用數字+px 或百分比，多值與 padding 類似。\n取值個數 含義 一個 四個角均為設定值 四個 左上 右上 右下 左下 (順時針) 三個 左上 右上+左下 右下 兩個 左上+右下 右上+左下 正圓形狀 給正方形盒子設定圓角屬性值為寬高的一半或 50%\n1 2 3 4 5 6 7 8 div { width: 100px; height: 100px; background-color: aqua; border-radius: 50%; /* 或者 border-radius: 50px */ } 膠囊形狀 給長方形盒子設定圓角屬性值為盒子高度的一半\n1 2 3 4 5 6 7 div { width: 100px; height: 50px; background-color: aqua; border-radius: 25px; } 陰影效果 使用 box-shadow 設定，屬性值：x y 模糊半徑 擴散半徑 顏色 內外陰影\n其中 x 與 y 是必填項，預設為外陰影，若設定內陰影屬性值為 inset\n","date":"2024-04-13T22:06:58+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/167/","title":"CSS 盒子模型"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 背景屬性有以下這些\n描述 屬性 背景色 background-color 背景圖 background-image 背景圖平鋪方式 background-repeat 背景圖位置 background-position 背景圖縮放 background-size 背景圖固定 background-attachment 背景圖複合屬性 background 背景圖 網頁中使用背景圖實現裝飾性的圖片效果\n1 2 3 4 5 6 div { width: 500px; height: 300px; background-image: url(./img/00.jpg); } 背景圖平鋪方式 background-repeat 有四個值\n效果 不平鋪 平鋪 (預設) 水平方向平鋪 垂直方向平鋪 屬性值 no-repeat repeat repeat-x repeat-y 背景圖位置 background-position 的值為 水平方向位置 垂直方向位置 其中位置的值有關鍵字和座標\n關鍵字有 left、right、center、top、bottom\n座標使用 數字+px，正負皆可\n1 2 3 4 5 div { background-position: center top; /* 也可以數字和單字混用 */ /* background-position: -50px center; */ } 可以只寫一個關鍵字，另一個方向為置中；數字只寫一個為水平方向，垂直置中\n背景圖縮放 background-size 常用三種屬性值\n關鍵字 cover：等比例縮放背景圖片以完全覆蓋背景區，可能圖片部分看不見 contain：等比例縮放背景圖片以完全裝入背景區，可能部分空白 百分比：根據盒子尺寸計算圖片大小 數字+單位 (如 px) 百分比為 100% 時圖片寬度和盒子寬度一致，高度等比例縮放\n背景圖固定 background-attachment 使背景不會隨著元素的內容捲動，屬性值為 fixed\n背景圖複合屬性 background 屬性值為 背景色 背景圖 背景圖平鋪方式 背景圖位置/背景圖縮放 背景圖固定 不區分順序\n1 2 3 4 5 6 div { width: 500px; height: 500px; background: aqua url(./img/01.jpg) no-repeat center/cover; } ","date":"2024-04-10T16:21:51+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/166/","title":"CSS 背景屬性"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 文字控制屬性可控制的內容如下\n名稱 屬性 字體大小 font-size 字體粗細 font-weight 字體傾斜 font-style 行高 line-height 字體系列 font-family 字體複合屬性 font 文字縮排 text-indent 文字對齊 text-align 裝飾線 text-decoration 顏色 color 字體大小 屬性值為文字尺寸，單位一般為 px\n1 2 3 p { font-size: 30px; } 字體粗細 屬性值為數字或關鍵字\n1 2 3 4 5 6 7 8 p { font-weight: 400; /* 文字設為正常 */ /* font-weight: normal; */ } div { font-weight: 700; /* 文字設為加粗 */ /* font-weight: bold; */ } 字體傾斜 通常用於移除文字預設的斜體效果\n1 2 3 4 5 6 em { font-style: normal; /* 將 em 標籤的傾斜效果移除 */ } p { font-style: italic; /* 將 p 標籤內的文字傾斜 */ } 行高 設定多行文字的間距，屬性值有兩種\n1 2 3 4 5 6 P { line-height: 30px; /* 行高為 30px */ } div { line-height: 2; /* 行高為字體大小的兩倍 (font-size 預設為 16px) */ } 行高是指文字高度+上間距+下間距\n當行高屬性值等於區塊 (div) 高度屬性值時，可以達成垂直置中\n1 2 3 4 div { line-height: 100px; height: 100px; } 字體系列 用於控制文字的字型，屬性值為字型名稱\n1 2 3 p { font-family: 楷體; } 一般來說會設定多個\n1 2 3 p { font-family: Microsoft YaHei, Heiti SC, tahoma, arial, Hiragino Sans GB, \u0026#34;\\5B8B\\4F53\u0026#34;, sans-serif; } 執行順序為從左到右，即瀏覽器會偵測系統是否有目前字型，若沒有，會偵測是否有下一個，直到最後一個，上述最後一個為 無襯線字體 的字體系列名稱\nfont 複合屬性 開發時設定字型有以下情況\n1 2 3 4 5 6 7 div { font-style: italic; /* 文字傾斜 */ font-weight: 700; /* 文字加粗 */ font-size: 30px; /* 字體大小為 30px */ line-height: 2; /* 行高為字體大小的 2 倍 */ font-family: 楷體; /* 設定字型 */ } 可以簡寫為\n1 2 3 4 div { font: italic 700 30px/2 楷體; /* 是否傾斜 加粗 字體大小/行高 字型 */ } 這個屬性通常用於設定網頁文字的共用樣式，屬性值必須按照順序書寫，其中字體大小和字型值必須書寫，其他可以省略\n文字縮排 屬性值有兩種，px 或 em，em 為目前標籤的字體大小\n1 2 3 4 5 p { font-size: 20px; text-indent: 2em; /* 首行縮排兩個字元 */ /* text-indent: 40px; 與上一行程式碼效果一致 */ } 文字對齊方式 text-align 屬性有三個值：left、center、right\n1 2 3 div { text-align: center; /* 文字置中對齊 */ } 這個屬性不只可以應用於文字對齊，例如以下用法可以讓圖片置中\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; div { text-align: center; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div\u0026gt; \u0026lt;img src=\u0026#34;path\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; text-align 本質上是控制內容的對齊方式，屬性要設定給內容的父層，上例 img 的父層為 div\n文字裝飾線 效果 無 底線 刪除線 上劃線 屬性值 none underline line-through overline 1 2 3 4 5 6 a { text-decoration: none; /* 移除連結的底線 */ } del { text-decoration: none; /* 移除 del 標籤的底線，讓 del 標籤無效 */ } 文字顏色 顏色表示方式 屬性值 說明 關鍵字 英文單字 red、green、aqua 等 rgb 表示法 rgb(r, g, b) r, g, b 表示紅綠藍三原色，取值範圍 0-255 rgba 表示法 rgba(r, g, b, a) a 表示透明度，取值範圍 0-1 十六進位表示法 #RRGGBB 兩兩一組，若相同可縮寫。#ffcc00 -\u0026gt; #fc0 1 2 3 4 5 6 p { color: rgba(250, 200, 0, 0.5); } div { color: #acf; /* 等同於 #aaccff */ } ","date":"2024-03-14T21:07:15+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/165/","title":"CSS 文字控制屬性"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 CSS 三大特性：繼承性、層疊性、優先級\n繼承性 子層級預設繼承父層級的文字控制屬性，若子層級有自己的樣式則不繼承\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;style\u0026gt; body { font: 30px/0.5 楷體; color: aqua; } \u0026lt;/style\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div\u0026gt;div\u0026lt;/div\u0026gt; \u0026lt;p\u0026gt;p\u0026lt;/p\u0026gt; \u0026lt;span\u0026gt;span\u0026lt;/span\u0026gt; \u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt;不繼承顏色\u0026lt;/a\u0026gt; \u0026lt;/body\u0026gt; 層疊性 選擇器類型相同時：\n相同的屬性會覆蓋：後面的 CSS 屬性覆蓋前面的 CSS 屬性 不同的屬性會疊加：不同的 CSS 屬性都生效 1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;style\u0026gt; div { color: red; font-size: 30px; } div { color: aqua; font-weight: 700; } \u0026lt;/style\u0026gt; \u0026lt;div\u0026gt; 顏色為 aqua，字級 30px，粗體 \u0026lt;/div\u0026gt; 優先級 當一個標籤使用了多種選擇器時，優先級高的樣式生效，優先級：\n萬用字元選擇器 \u0026lt; 標籤選擇器 \u0026lt; 類別選擇器 \u0026lt; ID 選擇器 \u0026lt; 行內樣式 \u0026lt; !important\n一般不使用 !important ，下例不使用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;style\u0026gt; #app { color: orange; } .box { color: blue; } div { color: red; } * { color: purple; } \u0026lt;/style\u0026gt; \u0026lt;div\u0026gt;標籤選擇器 red\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;類別選擇器 blue\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34; id=\u0026#34;app\u0026#34;\u0026gt;ID 選擇器 orange\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34; id=\u0026#34;app\u0026#34; style=\u0026#34;color: aqua;\u0026#34;\u0026gt;行內樣式 aqua\u0026lt;/div\u0026gt; 使用 !important\n1 2 3 4 5 6 7 \u0026lt;style\u0026gt; div { color: aqua !important; } \u0026lt;/style\u0026gt; \u0026lt;div style=\u0026#34;color: blue\u0026#34;\u0026gt;aqua\u0026lt;/div\u0026gt; 複合選擇器疊加優先級 依照 (行內樣式，ID 選擇器個數。類別選擇器個數，標籤選擇器個數) 由左至右依序比較個數，同層級個數較多的優先級較高，若相同則比較下一個層級\n若有 !important 則優先級最高，繼承的優先級最低\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 \u0026lt;style\u0026gt; /* (0, 0, 2, 1) */ .c1 .c2 div { color: blue; } /* (0, 1, 0, 1) */ div #box3 { color: red; } /* (0, 1, 1, 0) */ #box1 .c3 { color: aqua; } \u0026lt;/style\u0026gt; \u0026lt;div class=\u0026#34;c1\u0026#34; id=\u0026#34;box1\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;c2\u0026#34; id=\u0026#34;box2\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;c3\u0026#34; id=\u0026#34;box3\u0026#34;\u0026gt; aqua \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 範例 2\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 \u0026lt;style\u0026gt; /* (0, 2, 0, 0) */ #father #son { color: aqua; } /* (0, 1, 1, 1) */ #father p.c2 { color: black; } /* (0, 0, 2, 2) */ div.c1 p.c2 { color: red; } /* 繼承 */ #father { color: blue !important; } /* 繼承 */ div#father.c1{ color: yellow; } \u0026lt;/style\u0026gt; \u0026lt;div class=\u0026#34;c1\u0026#34; id=\u0026#34;father\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;c2\u0026#34; id=\u0026#34;son\u0026#34;\u0026gt; aqua \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; Emmet 寫法 即程式碼的簡寫方式，輸入縮寫 VS Code 會自動產生對應的程式碼\n對於 HTML\n說明 Emmet 效果 類別選擇器 標籤名.類名 \u0026lt;div class=\u0026quot;box\u0026quot;\u0026gt;\u0026lt;/div\u0026gt; ID 選擇器 標籤名#id名 \u0026lt;div id=\u0026quot;app\u0026quot;\u0026gt;\u0026lt;/div\u0026gt; 同層級標籤 div+p \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt; 父子層級標籤 div\u0026gt;p \u0026lt;div\u0026gt;\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;/div\u0026gt; 多個相同標籤 span*3 \u0026lt;span\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt;\u0026lt;/span\u0026gt; 有內容的標籤 div{內容} \u0026lt;div\u0026gt;內容\u0026lt;/div\u0026gt; 對於 CSS 大多為單字首字母\nh500+w300+bgc 會變為\n1 2 3 4 5 div { width: 500px; height: 300px; background-color: #fff; } ","date":"2024-03-11T16:38:34+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/164/","title":"CSS 三大特性"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 CSS 導入方式 CSS 有三種導入方式，第一種為內部樣式表，此方式僅供學習使用\n1 2 3 4 5 6 7 8 9 10 \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; /* 此處寫 CSS */ \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 第二種為行內樣式，一般搭配 JavaScript 使用\n1 \u0026lt;div style=\u0026#34;此處寫 CSS\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; 最後一種為外部樣式表，將 CSS 程式碼寫在獨立檔案，透過 link 標籤導入，開發時常用\n1 2 3 4 \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;css path\u0026#34; /\u0026gt; \u0026lt;/head\u0026gt; CSS 選取器 選取器的作用是尋找標籤，設定樣式，總共有四種基礎選取器\n標籤選取器 直接使用標籤名稱作為選取器，即選取同名標籤設定相同的樣式\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; div{ /* 選取所有 div 標籤設定樣式 */ } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 可以使用的標籤有 p、h1、div、a、img 等\n類別選取器 用於尋找標籤，差異化設定標籤的顯示效果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; .first{ /* 選取 first div 設定樣式 */ } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;first\u0026#34;\u0026gt; first div \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; second div \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 類別名稱若是多個單字可使用 - 連接，一個類別選取器可供多個標籤使用，一個標籤可以使用多個類別名稱\n1 2 3 \u0026lt;div class=\u0026#34;first second\u0026#34;\u0026gt; 使用了兩個類別名稱 \u0026lt;/div\u0026gt; id 選取器 用於尋找標籤，差異化設定標籤的顯示效果，一般搭配 JavaScript 使用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; #app{ /* 選取 id 為 app 的標籤 */ } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 同一個 id 選取器在一個頁面只能使用一次\n萬用字元選取器 尋找頁面所有標籤，設定相同樣式，一般用於清除標籤的預設樣式\n1 2 3 4 5 \u0026lt;style\u0026gt; *{ /* 撰寫樣式會影響所有標籤 */ } \u0026lt;/style\u0026gt; 複合選取器 定義：由兩個或多個基礎選取器，透過不同的方式組合而成\n作用：更精確、更有效率地選取目標元素 (標籤)\n後代選取器 可以選取某元素的所有後代元素\n語法：父選取器 子選取器 { CSS 屬性 }\n父選取器與子選取器之間用空格隔開，可以為類別選取器或 id 選取器\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;style\u0026gt; div span{ color: aqua; } \u0026lt;/style\u0026gt; \u0026lt;span\u0026gt;顏色不會變\u0026lt;/span\u0026gt; \u0026lt;div\u0026gt; \u0026lt;span\u0026gt;顏色會變\u0026lt;/span\u0026gt; \u0026lt;p\u0026gt; \u0026lt;span\u0026gt;顏色會變\u0026lt;/span\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; 子代選取器 只選取某元素的子級元素\n語法：父選取器 \u0026gt; 子選取器 { CSS 屬性 }\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;style\u0026gt; div \u0026gt; span{ color: aqua; } \u0026lt;/style\u0026gt; \u0026lt;div\u0026gt; \u0026lt;span\u0026gt;顏色會變\u0026lt;/span\u0026gt; \u0026lt;p\u0026gt; \u0026lt;span\u0026gt;顏色不會變\u0026lt;/span\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; 聯集選取器 選取多組標籤設定相同的樣式\n語法：選取器1, 選取器2, ..., 選取器N { CSS 屬性 }\n1 2 3 4 5 6 7 8 9 \u0026lt;style\u0026gt; div, span, p { color: aqua; } \u0026lt;/style\u0026gt; \u0026lt;div\u0026gt;顏色會變\u0026lt;/div\u0026gt; \u0026lt;p\u0026gt;顏色會變\u0026lt;/p\u0026gt; \u0026lt;span\u0026gt;顏色會變\u0026lt;/span\u0026gt; 交集選取器 選取同時符合多個條件的元素\n語法：選取器1選取器2 { CSS 屬性 } 選取器之間連寫，沒有任何符號\n如果交集選取器中有標籤選取器，標籤選取器必須寫在最前面\n1 2 3 4 5 6 7 8 9 \u0026lt;style\u0026gt; p.box { color: aqua; } \u0026lt;/style\u0026gt; \u0026lt;p class=\u0026#34;box\u0026#34;\u0026gt;顏色會變\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;p 標籤，顏色不會變\u0026lt;/p\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;顏色不會變\u0026lt;/div\u0026gt; 偽類選取器 偽類表示元素狀態，選取元素的某個狀態設定樣式\n滑鼠懸停狀態 語法：選取器:hover { CSS 屬性 }\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;style\u0026gt; a:hover{ color: red; } .box:hover{ color: aqua; } \u0026lt;/style\u0026gt; \u0026lt;a href=\u0026#34;https://yexca.net\u0026#34;\u0026gt;yexca\u0026lt;/a\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt; div 標籤 \u0026lt;/div\u0026gt; 任何標籤都可以設定滑鼠懸停的狀態\n超連結的狀態 選取器 作用 :link 造訪前 :visited 造訪後 :hover 滑鼠懸停 :active 點擊時 (啟用) 若要給超連結設定四個狀態，需依序撰寫\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;style\u0026gt; a:link { color: green; } a:visited { color: red; } a: hover { color: aqua; } a: active { color: orange; } \u0026lt;/style\u0026gt; \u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt;a 標籤\u0026lt;/a\u0026gt; 結構偽類選取器 作用：根據元素的結構關係尋找元素\n選取器 說明 E:first-child 選取第一個 E 元素 E:last-child 選取最後一個 E 元素 E:nth-child(N) 選取第 N 個 E 元素 (從 1 開始) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;style\u0026gt; li:first-child { background-color: aqua; } li:last-child { background-color: green; } li:nth-child(3) { background-color: blue; } \u0026lt;/style\u0026gt; \u0026lt;ol\u0026gt; \u0026lt;li\u0026gt;aqua\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;2\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;blue\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;4\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;green\u0026lt;/li\u0026gt; \u0026lt;/ol\u0026gt; 其中第三個選取器可以使用公式選取多個元素\n功能 公式 偶數個標籤 2n 奇數個標籤 2n+1 或 2n-1 找到 5 的倍數的標籤 5n 找到第 5 個以後的標籤 (包含 5) n+5 找到第 5 個以前的標籤 (包含 5) -n+5 偽元素選取器 作用：建立虛擬元素 (偽元素)，用來擺放裝飾性的內容\n選取器 說明 E::before 在 E 元素裡面最前面新增一個偽元素 E::after 在 E 元素裡面最後面新增一個偽元素 注意：\n必須設定 content 屬性，用來設定偽元素的內容，如果沒有內容，則引號留空 偽元素預設為行內顯示模式 優先權與標籤選取器相同 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;style\u0026gt; div { width: 110px; height: 30px; background-color: aqua; font-size: 20px; } div::before { content: \u0026#39;yexca\u0026#39;; } div::after { content: \u0026#39;blog\u0026#39;; } \u0026lt;/style\u0026gt; \u0026lt;div\u0026gt;\u0026#39;\u0026lt;/div\u0026gt; \u0026lt;!-- 內容為 yexca\u0026#39;blog --\u0026gt; ","date":"2024-03-02T17:15:35+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/163/","title":"CSS 選取器"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 Golang 系列\nHello GoLang: https://blog.yexca.net/zh-tw/archives/154 GoLang (var and const) 變數與常數: https://blog.yexca.net/zh-tw/archives/155 GoLang (func) 函式: https://blog.yexca.net/zh-tw/archives/156 GoLang (slice and map) 切片: https://blog.yexca.net/zh-tw/archives/160 GoLang (OOP) 物件導向: 本文\nGoLang (reflect) 反射: https://blog.yexca.net/zh-tw/archives/204 GoLang (struct tag) 結構體標籤: https://blog.yexca.net/zh-tw/archives/205 GoLang (goroutine) Go 協程: https://blog.yexca.net/zh-tw/archives/206 GoLang (channel) 通道: https://blog.yexca.net/zh-tw/archives/207 透過使用結構體構建類別與物件的概念\n了解物件導向： 物件導向基礎 struct 首先是自訂型別，使用 type 關鍵字，類似於 C\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package main import \u0026#34;fmt\u0026#34; type myType int func main() { var a myType fmt.Println(\u0026#34;a =\u0026#34;, a) fmt.Printf(\u0026#34;type of a is %T\u0026#34;, a) } /* * 輸出 * a = 0 * type of a is main.myTye */ 定義型別使用 struct\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package main import \u0026#34;fmt\u0026#34; type Person struct { name string age int } fun main() { var zhang Person zhang.name = \u0026#34;zhangSan\u0026#34; zhang.age = 20 fmt.Print(zhang) } 函式傳遞相關，不使用指標是傳值 (Value Passing)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 package main import \u0026#34;fmt\u0026#34; type Person struct { name string age int } // 傳值，不會修改原始資料 func changeName(person Person) { person.name = \u0026#34;liSi\u0026#34; } // 傳址，會修改原始資料 func changeAge(person *Person) { person.age = 18 } func main() { var zhang Person zhang.name = \u0026#34;zhangSan\u0026#34; zhang.age = 20 fmt.Println(zhang) changeName(zhang) fmt.Println(zhang) changeAge(\u0026amp;zhang) fmt.Println(zhang) } 封裝 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 package main import \u0026#34;fmt\u0026#34; // 類別 type Person struct { // 屬性 name string age int } // 類別的方法 func (this *Person) SetName(name string) { this.name = name } func (this *Person) SetAge(age int) { this.age = age } func (this *Person) GetName() string { return this.name } func (this *Person) GetAge() int { return this.age } func main() { person := Person{name: \u0026#34;zhangSan\u0026#34;, age: 18} fmt.Println(person) } 注意到上述類別名稱、方法名稱首字母為大寫，代表該類別、方法可以被其他套件存取 (java public)，若首字母小寫則只能由此套件存取 (java private)，屬性名稱也是同理\n繼承 以下程式碼處於同一檔案，父類別\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 父類別 type Person struct { name string age int } // 父類別的方法 func (this *Person) Eat() { fmt.Println(\u0026#34;Person Eat...\u0026#34;) } func (this *Person) Walk() { fmt.Println(\u0026#34;Person Walk...\u0026#34;) } 子類別\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 子類別 type SuperMan struct { Person // 繼承父類別 level int // 子類別屬性 } // 子類別覆寫父類別方法 func (this *SuperMan) Walk() { fmt.Println(\u0026#34;SuperMan Walk\u0026#34;) } // 子類別特有方法 func (this *SuperMan) Fly() {} main 函式\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func main() { // 定義子類別屬性，方式一 superMan1 := SuperMan{Person{\u0026#34;zhangSan\u0026#34;, 18}, 4} // 定義子類別屬性，方式二 var superMan2 SuperMan superMan2.name = \u0026#34;liSi\u0026#34; // 因為同一個套件，可以存取父類別屬性 superMan2.age = 20 superMan2.level = 5 // 子類別呼叫父類別方法 superMan1.Eat() // 子類別覆寫方法 superMan1.Walk() // 子類別方法 superMan2.Fly() } 多型 以下程式碼處於同一檔案，定義介面\n1 2 3 4 5 6 // 介面，本質是一個指標 type Animal interface { Sleep() GetName() string GetType() string } 實作類別一\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 實作類別一 type Cat struct { name string kind string } // 實作介面所有方法 func (this *Cat) Sleep() { fmt.Println(\u0026#34;Cat Sleep()\u0026#34;) } func (this *Cat) GetName() string { return this.name } func (this *Cat) GetType() string { return this.kind } 實作類別二\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // 實作類別二 type Dog struct { name string kind string } // 實作介面所有方法 func (this *Dog) Sleep() { fmt.Println(\u0026#34;Cat Sleep()\u0026#34;) } func (this *Dog) GetName() string { return this.name } func (this *Dog) GetType() string { return this.kind } func ShowAnimal(animal Animal) { fmt.Println(animal) } main\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 func ShowAnimal(animal Animal) { fmt.Println(animal) } func main() { var animal Animal animal = \u0026amp;Cat{\u0026#34;cat1\u0026#34;, \u0026#34;cat\u0026#34;} animal.Sleep() animal = \u0026amp;Dog{\u0026#34;dog1\u0026#34;, \u0026#34;dog\u0026#34;} animal.Sleep() cat := Cat{\u0026#34;cat2\u0026#34;, \u0026#34;cat\u0026#34;} dog := Dog{\u0026#34;dog2\u0026#34;, \u0026#34;dog\u0026#34;} ShowAnimal(\u0026amp;cat) ShowAnimal(\u0026amp;dog) } 萬用型別與斷言 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package main import \u0026#34;fmt\u0026#34; // 使用空介面表示萬用資料型別 func f(arg interface{}) { // 型別斷言機制（即型別轉換） value, flag := arg.(string) if !flag { fmt.Println(\u0026#34;arg is not string type\u0026#34;) } else { fmt.Println(\u0026#34;arg is string type, arg =\u0026#34;, value) } } func main() { // 可以傳入任意資料型別，包括自訂 f(\u0026#34;abc\u0026#34;) f(123) f(3.14) } /* * 輸出 * arg is string type, arg = abc * arg is not string type * arg is not string type */ ","date":"2024-03-01T15:35:38+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/162/","title":"GoLang 物件導向"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 引入註冊中心之前先引入提供者與消費者概念\n提供者與消費者 服務提供者：一次業務中，被其他微服務呼叫的服務。（提供介面給其他微服務）\n服務消費者：一次業務中，呼叫其他微服務的服務。（呼叫其他微服務提供的介面）\n提供者與消費者是相對的，一個服務既可以是提供者也可以是消費者\nEureka 若提供者有多個，消費者如何獲取提供者資訊，如何得知提供者的健康狀態\n在啟動時，微服務向 Eureka 註冊服務資訊，消費者可透過 Eureka 抓取提供者資訊，然後進行遠端呼叫。微服務會每 30 秒向 Eureka 說明自己還活著，Eureka 會更新紀錄服務列表資訊，剔除不健康的伺服器\n如果有多個服務提供者，消費者利用負載平衡演算法，從服務列表中挑選一個\n建置 新建一個 Maven 模組，引入相依性\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-eureka-server\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 撰寫啟動類別\n1 2 3 4 5 6 7 @EnableEurekaServer @SpringBootApplication public class EurekaApplication { public static void main(String[] args) { SpringApplication.run(EurekaApplication.class,args); } } 設定檔\n1 2 3 4 5 6 7 8 9 server: port: 7995 spring: application: name: eureka-server eureka: client: service-url: defaultZone: http://127.0.0.1:7995/eureka 註冊服務 引入相依性\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-eureka-client\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 撰寫設定\n1 2 3 4 5 6 7 spring: application: name: userService eureka: client: service-url: defaultZone: http://127.0.0.1:7995/eureka 服務使用 承上例註冊\n1 2 3 4 5 @Bean @LoadBalanced public RestTemplate restTemplate(){ return new RestTemplate(); } 修改呼叫的網域名稱為服務名稱\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 @Service public class OrderService { @Autowired private OrderMapper orderMapper; @Autowired private RestTemplate restTemplate; public Order queryOrderById(Long orderId) { // 1. 查詢訂單 Order order = orderMapper.findById(orderId); // 2. 查詢使用者 // String url = \u0026#34;http://localhost:8081/user/\u0026#34; + order.getUserId(); String url = \u0026#34;http://userService/user/\u0026#34; + order.getUserId(); User user = restTemplate.getForObject(url, User.class); // 3. 封裝使用者資訊 order.setUser(user); // 4. 回傳 return order; } } ","date":"2024-02-29T16:53:15+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/161/","title":"註冊中心 - Eureka"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 Golang 系列\nHello GoLang: https://blog.yexca.net/zh-tw/archives/154 GoLang (var and const) 變數與常數: https://blog.yexca.net/zh-tw/archives/155 GoLang (func) 函式: https://blog.yexca.net/zh-tw/archives/156 GoLang (slice and map) 切片: 本文\nGoLang (OOP) 物件導向: https://blog.yexca.net/zh-tw/archives/162 GoLang (reflect) 反射: https://blog.yexca.net/zh-tw/archives/204 GoLang (struct tag) 結構體標籤: https://blog.yexca.net/zh-tw/archives/205 GoLang (goroutine) Go 協程: https://blog.yexca.net/zh-tw/archives/206 GoLang (channel) 通道: https://blog.yexca.net/zh-tw/archives/207 Go 的切片 (Slice) 是對陣列 (Array) 的抽象\n陣列 陣列的長度不可改變\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package main import \u0026#34;fmt\u0026#34; func main() { // 定義方式一 var arr1 [10]int // 遍歷 for i := 0; i \u0026lt; len(arr1); i++ { fmt.Println(\u0026#34;arr1[\u0026#34;, i, \u0026#34;]:\u0026#34;, arr1[i]) } // 定義方式二，賦值 arr2 := [10]int{0, 1, 2, 3} // range 遍歷 for index, value := range arr2 { fmt.Println(\u0026#34;index =\u0026#34;, index, \u0026#34;value =\u0026#34;, value) } // 定義不同長度 var arr3 [4]int fmt.Printf(\u0026#34;type of arr1 is %T\\n\u0026#34;, arr1) // [10]int fmt.Printf(\u0026#34;type of arr1 is %T\\n\u0026#34;, arr2) // [10]int fmt.Printf(\u0026#34;type of arr1 is %T\u0026#34;, arr3) // [4]int } 編譯執行後可以發現 arr3 與 arr1, arr2 型別不同，那麼在定義函式形式參數時也需要指定相應型別\n1 2 3 4 5 func test(arr [4]int) { for i := 0; i \u0026lt; len(arr); i++ { fmt.Println(\u0026#34;fmt_arr[\u0026#34;, i, \u0026#34;]:\u0026#34;, arr[i]) } } 上述函式只能傳遞 arr3，且為值傳遞 (Pass by Value)，修改值不會影響原始資料\n定義切片 與陣列相比，切片長度不固定，可以追加元素 (動態陣列)，在追加時可能會使切片的容量增大\n定義切片可以透過宣告一個未指定大小的陣列\n1 2 3 var name []type // 例如 var s []int 或者使用 make() 函式來建立切片\n1 2 3 var slice []type = make([]type, len) // len 為切片初始長度 // 也可以簡寫為 slice := make([]type, len) 可以使用選用參數 capacity 指定容量，省略時與 length 相同\n1 var slice []type = make([]type, length, capacity) 切片初始化 直接初始化\n1 s := []int {1, 2, 3} 將陣列區間初始化為切片，從 startIndex 到 endIndex-1，這兩個值都可以省略\n1 s := arr[startIndex:endIndex] 省略 startIndex 或 endIndex 表示從第一個元素開始索引或索引到最後一個元素\nlen() 和 cap() 切片是可以透過索引存取的，透過 len() 函式獲取長度\n而 cap() 為計算容量的方法，可以測量切片最長可以達到多少\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package main import \u0026#34;fmt\u0026#34; // 切片傳遞為參考傳遞 (引用傳遞)，函式內修改會影響原始資料 func printSlice(slice []int) { fmt.Printf(\u0026#34;len=%d, cap=%d, slice=%v\u0026#34;, len(slice), cap(slice), slice) } func main() { s := make([]int, 3, 5) printSlice(s) } /* * 輸出 * len=3, cap=5, slice=[0 0 0] */ 空切片 一個切片在未初始化之前預設為 nil (空切片)，長度為 0\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package main import \u0026#34;fmt\u0026#34; func printSlice(slice []int) { fmt.Printf(\u0026#34;len=%d, cap=%d, slice=%v\\n\u0026#34;, len(slice), cap(slice), slice) } func main() { var s []int printSlice(s) // 判斷是否為空 if s == nil { fmt.Println(\u0026#34;slice is empty\u0026#34;) } } 切片截取 透過設定上下限截取切片\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package main import \u0026#34;fmt\u0026#34; func printSlice(slice []int) { fmt.Printf(\u0026#34;len=%d, cap=%d, slice=%v\\n\u0026#34;, len(slice), cap(slice), slice) } func main() { s := []int{0, 1, 2, 3, 4, 5, 6, 7} // 打印原始切片 fmt.Println(s) // 從 2 (包含) 到 5 (不包含) printSlice(s[2:5]) // 從第一個到 5 (不包含) printSlice(s[:5]) // 從第二個到最後一個 printSlice(s[2:]) // 這樣賦值修改 subS 將會影響到 s subS := s[1:6] printSlice(subS) } append() 和 copy() 增加切片的容量與複製切片\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package main import \u0026#34;fmt\u0026#34; func printSlice(slice []int) { fmt.Printf(\u0026#34;len=%d, cap=%d, slice=%v\\n\u0026#34;, len(slice), cap(slice), slice) } func main() { var s []int printSlice(s) // 增加一個元素 s = append(s, 0) printSlice(s) // 增加多個元素 s = append(s, 1, 2, 3, 4) printSlice(s) // 建立一個容量為 s 兩倍的 s2 s2 := make([]int, len(s), cap(s)*2) // 複製 s 到 s2，此時修改 s2 不影響 s copy(s2, s) printSlice(s2) } 切片的擴充：如果追加的值超過容量，則容量通常會增加為原來的兩倍\nmap map 有兩種宣告方式\n1 2 3 4 5 6 7 8 9 10 11 package main import \u0026#34;fmt\u0026#34; func main() { var map1 = make(map[string]string) // 插入資料 map1[\u0026#34;one\u0026#34;] = \u0026#34;1\u0026#34; map1[\u0026#34;two\u0026#34;] = \u0026#34;2\u0026#34; fmt.Println(map1) // map[one:1 two:2] } 第二種\n1 2 3 4 5 6 7 8 9 10 11 package main import \u0026#34;fmt\u0026#34; func main() { map1 := map[string]string{ \u0026#34;one\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;two\u0026#34;: \u0026#34;2\u0026#34;, } fmt.Println(map1) } map 巢狀 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package main import \u0026#34;fmt\u0026#34; func main() { map1 := make(map[string]map[string]string) map1[\u0026#34;first\u0026#34;] = make(map[string]string, 2) map1[\u0026#34;first\u0026#34;][\u0026#34;one\u0026#34;] = \u0026#34;1\u0026#34; map1[\u0026#34;first\u0026#34;][\u0026#34;two\u0026#34;] = \u0026#34;2\u0026#34; fmt.Println(map1) } /* * 輸出 * map[first:map[one:1 two:2]] */ 修改、遍歷與刪除 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package main import \u0026#34;fmt\u0026#34; func main() { map1 := make(map[string]map[string]string) map1[\u0026#34;first\u0026#34;] = make(map[string]string, 2) map1[\u0026#34;first\u0026#34;][\u0026#34;one\u0026#34;] = \u0026#34;1\u0026#34; map1[\u0026#34;first\u0026#34;][\u0026#34;two\u0026#34;] = \u0026#34;2\u0026#34; // 修改 map1[\u0026#34;first\u0026#34;][\u0026#34;one\u0026#34;] = \u0026#34;one\u0026#34; fmt.Println(map1) // 遍歷 for key, value := range map1{ fmt.Println(\u0026#34;key =\u0026#34;, key, \u0026#34;value =\u0026#34;, value) } // 刪除 delete(map1, \u0026#34;first\u0026#34;) fmt.Println(map1) } 判斷是否有某值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 package main import \u0026#34;fmt\u0026#34; func main() { map1 := make(map[string]string) map1[\u0026#34;one\u0026#34;] = \u0026#34;1\u0026#34; val, ok := map1[\u0026#34;one\u0026#34;] if ok { fmt.Println(val) } else { fmt.Println(\u0026#34;empty\u0026#34;) } } ","date":"2024-02-27T20:00:00+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/160/","title":"GoLang 切片"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 這篇文章還是有點久遠的，書寫習慣和現在不同，甚至看著有點不習慣\n透過 crontab 指令，我們可以在固定的間隔時間執行指定的系統指令或 shell script 腳本。時間間隔的單位可以是分鐘、小時、日、月、週及以上的任意組合。\n指令格式 1 crontab [-u user] file crontab [-u user] [ -e | -l | -r ] 指令參數 -u user：用來設定某個使用者的 crontab 服務。 file：file 是指令檔案的名稱，表示將 file 作為 crontab 的任務列表檔案並載入 crontab。如果在命令列中沒有指定這個檔案，crontab 指令將接受標準輸入（鍵盤）上鍵入的指令，並將它們載入 crontab。 -e：編輯某個使用者的 crontab 檔案內容。如果不指定使用者，則表示編輯目前使用者的 crontab 檔案。 -l：顯示某個使用者的 crontab 檔案內容，如果不指定使用者，則表示顯示目前使用者的 crontab 檔案內容。 -r：從 /var/spool/cron 目錄中刪除某個使用者的 crontab 檔案，如果不指定使用者，則預設刪除目前使用者的 crontab 檔案。 -i：在刪除使用者的 crontab 檔案時給予確認提示。 檔案格式 執行 crontab -e 指令後，會開啟目前使用者的 crontab 檔案，在這個檔案中，以 # 開頭的語句是註解語句。\n在 crontab 檔案中，透過 m h dom mon dow command 這六個欄位來設定排程任務，每一行對應一個排程任務。這六個欄位的含義說明如下：\nm：對應分鐘 (minute) 指定要在一小時之中的第幾分鐘執行該任務。取值範圍是 0-59。\nh：對應小時 (hour) 指定要在一天之中的第幾個小時執行該任務。取值範圍是 0-23。\ndom：對應日期 (day of month) 指定要在一月之中的第幾天執行該任務。取值範圍是 0-31。\nmon：對應月份 (month) 指定要在一年之中的第幾月執行該任務。取值範圍是 1-12。 也可以透過月份英文名稱的前三個字母來指定，不區分大小寫。例如，一月的英文單字是 january，那麼這裡可以用 jan 來指定一月。\ndow：對應星期幾 (day of week) 指定要在一週之中的星期幾執行該任務。取值範圍是 0-7，0 和 7 都對應星期天。 也可以透過星期英文名稱的前三個字母來指定，不區分大小寫。例如，星期一的英文單字是 monday，那麼這裡可以用 mon 來指定星期一。\ncommand：對應具體的操作\n提供具體的指令來指定進行什麼操作，可以提供腳本檔案的路徑來執行該腳本檔案。\n這六個欄位要求用空格隔開。且每個欄位都必須提供值，不能省略某個欄位的值。從第五個欄位之後的所有內容都屬於第六個欄位，也就是要執行的操作。\n前五個欄位可以使用下面的特殊字元來指定一些特殊的時間：\n星號（*）：代表所有可能的值，例如 month 欄位如果是星號，則表示在滿足其它欄位的制約條件後每月都執行該指令操作。 逗號（,）：可以用逗號隔開的值指定一個列表範圍，例如，\u0026ldquo;1,2,5,7,8,9\u0026rdquo;。 減號（-）：可以用整數之間的減號表示一個整數範圍，例如 \u0026ldquo;2-6\u0026rdquo; 表示 \u0026ldquo;2,3,4,5,6\u0026rdquo;。 正斜線（/）：可以用正斜線指定時間的間隔頻率，例如 \u0026ldquo;0-23/2\u0026rdquo; 表示每兩小時執行一次。同時正斜線可以和星號一起使用，例如 */10，如果用在 minute 欄位，表示每十分鐘執行一次。 在 command 欄位中，可以使用換行符號、或者 % 字元來分隔指令內容。\n在第一個 % 之前的內容會傳遞給 shell 來執行，這個 % 自身會被替換成換行符號，在 % 之後、直到行末的內容都作為標準輸入傳遞。\n如果需要提供 % 字元自身，需要用 \\% 進行跳脫。\n常用方法 向 cron 程序提交一個 crontab 檔案之前，首先要設定環境變數 EDITOR。cron 程序根據它來確定使用哪個編輯器編輯 crontab 檔案。\n由於預設使用 nano 編輯器不是特別好用，可以改為 vi，透過編輯 $HOME 目錄下的 .profile 檔案，在其中加入這樣一行：\n1 EDITOR=vi; export EDITOR 然後儲存並退出。不妨建立一個名為 \u0026lt;user\u0026gt;cron 的檔案，其中 \u0026lt;user\u0026gt; 是使用者名稱，例如 yexcacron。在該檔案中加入要定時執行的內容，例如：\n1 2 3 # (put your own initials here)echo the date to the console every # 15minutes between 6pm and 6am 0,15,30,45 18-06 * * * /bin/echo \u0026#39;date\u0026#39; \u0026gt; /dev/console 在上面的例子中，系統將每隔 15 分鐘向主控台輸出一次目前時間。如果系統當機或停止回應，從最後所顯示的時間就可以一眼看出系統是什麼時間停止運作的。在有些系統中，用 tty1 來表示主控台，可以根據實際情況對上面的例子進行相應的修改。為了提交你剛剛建立的 crontab 檔案，可以把這個新建立的檔案作為 cron 指令的參數：\n1 crontab yexcacron 現在該檔案已經提交給 cron 程序，它將每隔 15 分鐘執行一次。同時，新建立檔案的一個複本已經被放在 /var/spool/cron 目錄中，檔名就是使用者名稱 (即 yexca)。\n執行腳本 如果執行腳本需要使用變數：\n1 30 6 * * * . /etc/profile;/bin/sh /root/zfile/bin/restart.sh 以上為每日 6:30 執行 zfile 的 restart.sh。\n參考文章 crontab 定時任務 — Linux Tools Quick Tutorial Linux技巧：介紹設置定時週期執行任務的方法 - SegmentFault 思否 Linux命令之Crontab——定時任務 - SegmentFault 思否 nano編輯器使用教程 - VPS偵探 Linux vi/vim - 菜鳥教程 ","date":"2024-02-26T21:34:15+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/159/","title":"Linux 排程任務 crontab"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 服務架構 單體架構 將業務的所有功能集中在一個專案中開發，並打包成一個檔案進行部署。\n優點：架構簡單、部署成本低，適合小型專案。\n缺點：耦合度高、擴充性差。\n分散式架構 根據業務功能對系統進行拆分，每個業務模組作為獨立專案開發，稱為一個服務。\n優點：降低服務耦合、有利於服務升級拓展。\n缺點：架構複雜、難度大，適合大型網際網路專案。\n微服務 微服務是一種經過良好架構設計的分散式架構方案，微服務架構特徵：\n單一職責 ：微服務拆分粒度更小，每一個服務都對應唯一的業務能力，做到單一職責，避免重複業務開發。 面向服務：微服務對外暴露業務介面。 自治：團隊獨立、技術獨立、數據獨立、部署獨立。 隔離性強：服務呼叫做好隔離、容錯、降級，避免出現連鎖問題。 微服務技術 微服務方案需要技術框架實作，常見的如下：\nDubbo SpringCloud SpringCloudAlibaba 註冊中心 zookeeper、 Redis Eureka、 Consul Nacos、 Eureka 服務遠端呼叫 Dubbo 協定 Feign (http 協定) Dubbo、Feign 配置中心 無 SpringCloudConfig SpringCloudConfig、 Nacos 服務網關 無 SpringCloudGateway、 Zuul SpringCloudGateway、 Zuul 服務監控與保護 dubbo-admin，功能弱 Hystix Sentinel 微服務需要根據業務模組拆分：\n單一職責：不同微服務，不要重複開發相同業務。 數據獨立：不要存取其他微服務的資料庫。 面向服務：將自己的業務暴露為介面，供其他微服務呼叫。 SpringCloud SpringCloud 是目前使用最廣泛的微服務框架。它整合了各種微服務功能組件，並基於 SpringBoot 實作了這些組件的自動裝配。\n官網： https://spring.io/projects/spring-cloud/ 服務註冊發現：Eureka、Nacos、Consul 統一配置管理：SpringCloudConfig、Nacos 服務遠端呼叫：OpenFeign、Dubbo 統一網關路由：SpringCloudGateway、Zuul 服務鏈路監控：Zipkin、Sleuth 流控、降級、保護：Hystix、Sentinel 微服務呼叫 需求：根據訂單 id 查詢訂單的同時，把訂單所屬的使用者資訊一起回傳。\n註冊 RestTemplate 1 2 3 4 @Bean public RestTemplate restTemplate(){ return new RestTemplate(); } 服務遠端呼叫 RestTemplate 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 @Service public class OrderService { @Autowired private OrderMapper orderMapper; @Autowired private RestTemplate restTemplate; public Order queryOrderById(Long orderId) { // 1. 查詢訂單 Order order = orderMapper.findById(orderId); // 2. 查詢使用者 String url = \u0026#34;http://localhost:8081/user/\u0026#34; + order.getUserId(); // RestTemplate 的 GET 方法 User user = restTemplate.getForObject(url, User.class); // 3. 封裝使用者資訊 order.setUser(user); // 4. 回傳 return order; } } ","date":"2024-02-25T17:56:54+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/158/","title":"Hi SpringCloud"},{"content":" 該文章使用 Google 翻譯處理。\nRedis 是一個基於記憶體的鍵值結構資料庫，是互聯網技術領域使用廣泛的儲存中間件\n官網： https://redis.io 簡體中文網： https://www.redis.net.cn/ Redis 基於記憶體存儲，讀寫效能高，適合儲存熱點資料 (商品、資訊、新聞) 。是用 C 語言開發的一個開源的高效能鍵值對資料庫，儲存 value 類型比較豐富，也被稱為結構化的 NoSql (Not Only SQL) 資料庫\nNoSql 泛指非關係型資料庫，不是要取代關係型資料庫，而是關係型資料庫的補充\n關係型資料庫 (RDBMS)：\nMySQL Oracle DB2 SQLServer 非關係型資料庫 (NoSQL)：\nRedis Mongo DB MemCached Redis 下載安裝與執行 下載地址：\nWindows: https://github.com/microsoftarchive/redis/releases Linux: https://download.redis.io/releases/ cn: http://www.redis.cn/download.html Windows 版直接解壓縮即可使用，Linux 版：\n解壓縮 tar -zxvf redis-4.0.0.tar.gz -C /usr/local 安裝依賴環境 yum install gcc-c++ 進入安裝目錄，編譯 make 進入 redis 的 src 目錄安裝 make install 相關文件說明：\n/usr/local/redis-4.0.0/src/redis-server：Redis 服務啟動腳本 /usr/local/redis-4.0.0/src/redis-cli：Redis 客戶端腳本 /usr/local/redis-4.0.0/redis.conf：Redis 設定檔 服務端啟動，以 Windows 版為例，啟動命令：\n1 redis-server.exe redis.windows.conf 默認端口號為 6379，默認無密碼，啟動完成後可以用客戶端連接\n命令行連接 通過 redis-cli.exe 進行連接\n1 redis-cli.exe -h ip -p port -a password 如果省略，則使用 127.0.0.1:6379\n可以通過修改配置文件 (redis.windows.conf) 設置密碼\n1 requirepass 123456 修改完成後重啟生效\n圖形化連接 Github： https://github.com/qishibo/AnotherRedisDesktopManager 下載安裝後新建連接，輸入相關信息後連接即可\nDocker 部署 拉取鏡像\n1 docker pull redis 獲取配置文件，下載對應版本，抽取配置文件即可，Linux 為 redis.conf\n創建 Redis 數據映射文件夾，例如\n1 2 mkdir /home/redis mkdir /home/redis/data 修改配置文件，傳送至部署機子，例如使用 scp 從 Win 傳至 Linux\n1 scp pathOfFile root@IP:/PathOfFile 啟動\n1 docker run -p 6379:6379 --name redis -v /home/redis/redis.conf:/etc/redis/redis.conf -v /home/redis/data:/data -d redis redis-server /etc/redis/redis.conf 參考資料： https://cloud.tencent.com/developer/article/1670205 Redis 數據類型 Redis 的 key 是字符串類型，value 有 5 種常用的數據類型\n字串 (string)：普通字串 哈希 (hash)：也叫散列 清單 (list)：依插入順序排序，可以有重複元素 集合 (set)：無序集合，不允許重複元素 有序集合 (sorted set/zset)：集合中每個元素關聯一個分數 (score)，根據分數升序排序 Redis 常用命令 Redis 大小寫不敏感\n字符串操作常用命令：\n1 2 3 4 5 6 7 8 # 設置指定 key 值 SET key value # 獲取指定 key 值 GET key # 設置指定 key 值，並將 key 的過期時間設為 seconds 秒 SETEX key seconds value # 只在 key 不存在時才設置 key 的值 SETNX key value hash 是一個 string 類型的 field 和 value 映射表，特別適合存儲對象，常用命令：\n1 2 3 4 5 6 7 8 9 10 # 將哈希表 key 中的 field 值設為 value HSET key field value # 取得儲存在哈希表中指定欄位的值 HGET key field # 刪除儲存在哈希表中的指定字段 HDEL key field # 獲取哈希表中所有字段 HKEYS key # 獲取哈希表中所有值 HVALS key 列表是簡單的字符串列表，按照插入順序排列，常用命令：\n1 2 3 4 5 6 7 8 9 10 11 # 將一個或多個值插入到清單頭部 LPUSH key value1 [value2] # 取得清單指定範圍內的元素 LRANGE key start stop # 移除並取得清單最後一個元素 RPOP key # 取得清單長度 LLEN key # 移出並取得清單的最後一個元素 # 如果清單沒有元素會阻塞清單直到等待逾時或發現可彈出元素為止 BRPOP key1 [key2] timeout 類似隊列，先進先出\n集合是字串型別的無序集合，集合成員唯一，常用指令：\n1 2 3 4 5 6 7 8 9 10 11 12 # 在集合中新增一個或多個成員 SADD key member1 [member2] # 傳回集合中的所有成員 SMEMBERS key # 取得集合的成員數 SCARD key # 傳回給定所有集合的交集 SINTER key2 [key2] # 傳回所有給定集合的並集 SUNION key1 [key2] # 移除集合中一個或多個成員 SREM key member1 [member2] 有序集合是字符串類型元素的集合，每個成員關聯一個 double 類型的分數，常用命令：\n1 2 3 4 5 6 7 8 # 在有序集合中新增一個或多個成員 ZADD key score1 member1 [score2 member2] # 透過索引區間傳回有序集合中指定區間內的成員 ZRANGE key start stop [WITHSCORES] # 有序集合中對指定成員的分數加上增量increment ZINCRBY key increment member # 移除有序集合中的一個或多個成員 ZREM key member1 [member2] 除了各數據類型專有，還有通用命令，即所有類型都可以使用的命令：\n1 2 3 4 5 6 7 8 # 尋找所有符合給定模式(pattern)的key KEYS pattern # pattern可以為* # 檢查指定key是否存在 EXISTS key # 傳回key所儲存的值的類型 TYPE key # 在key存在時刪除key DEL key 在 Java 中操作 Redis 如同使用 JDBC 操作 MySQL 資料庫一樣，需要使用 Redis 的 Java 用戶端進行操作 Redis\nRedis 的 Java 客戶端很多，常用的幾種：\nJedis Lettuce Spring Data Redis Jedis 封裝最好，與Redis 命令相同，是官方推薦；Lettuce 對線程呼叫更好，性能更好；Spring 對Redis 客戶端進行了整合，提供了Spring Data Redis，在Spring Boot 專案中還提供了對應的Starter，即spring-boot-starter-data-redis\nspring data Redis Spring Data Redis 是 Spring 的一部分，提供了在 Spring 應用中透過簡單的配置就可以存取 Redis 服務，對 Redis 底層開發包進行了高度封裝。在 Spring 專案中，可以使用Spring Data Redis來簡化 Redis 操作。網址： https://spring.io/projects/spring-data-redis Maven 座標：\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-data-redis\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; Spring Data Redis 中提供了一個高度封裝類 RedisTemplate 對相關 api 進行了歸類封裝，將同一類型的操作封裝為 operation 接口：\nValueOperations：string 資料操作 SetOperations：set 類型資料操作 ZSetOperations：zset 類型資料操作 HashOperations：hash 類型的資料操作 ListOperations：list 類型的資料操作 配置 Redis 資料來源，設定文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # application spring: profiles: active: dev redis: host: ${sky.redis.host} port: ${sky.redis.port} password: ${sky.redis.password} database: ${sky.redis.database} # -dev sky: redis: host: localhost port: 6379 password: 123456 # 使用哪個資料庫，不填預設為 0 database: 10 Redis 預設有 16 個資料庫 (0-15)，可以透過修改設定檔來指定資料庫的數量\n編寫配置類，建立 RedisTemplate 對象\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 @Configuration @Slf4j public class RedisConfiguration { @Bean public RedisTemplate redisTemplate(RedisConnectionFactory redisConnectionFactory){ log.info(\u0026#34;開始創建 Redis 對象\u0026#34;); RedisTemplate redisTemplate = new RedisTemplate(); // 設定 redis 的連接工廠對象 redisTemplate.setConnectionFactory(redisConnectionFactory); // 設定 redis key 的序列化器 redisTemplate.setKeySerializer(new StringRedisSerializer()); return redisTemplate; } } 此配置類別不是必須的，SpringBoot 框架會自動組裝 RedisTemplate 對象，不過預設的序列化器為 JdkSerializationRedisSerializer，儲存到 Redis 中的資料與原始資料有差別\n字串類型數據 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @SpringBootTest public class RedisTest { @Autowired private RedisTemplate redisTemplate; @Test public void testString(){ // set redisTemplate.opsForValue().set(\u0026#34;name\u0026#34;, \u0026#34;Tom\u0026#34;); // get String name =(String) redisTemplate.opsForValue().get(\u0026#34;name\u0026#34;); System.out.println(name); // setex redisTemplate.opsForValue().set(\u0026#34;code\u0026#34;, \u0026#34;1234\u0026#34;, 2, TimeUnit.MINUTES); // setnx redisTemplate.opsForValue().setIfAbsent(\u0026#34;lock\u0026#34;,\u0026#34;1\u0026#34;); redisTemplate.opsForValue().setIfAbsent(\u0026#34;lock\u0026#34;,\u0026#34;2\u0026#34;); } } 哈希類型數據 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @Test public void testHash(){ HashOperations hashOperations = redisTemplate.opsForHash(); // hset hashOperations.put(\u0026#34;100\u0026#34;, \u0026#34;name\u0026#34;, \u0026#34;Jerry\u0026#34;); hashOperations.put(\u0026#34;100\u0026#34;, \u0026#34;age\u0026#34;, \u0026#34;20\u0026#34;); // hget String name =(String) hashOperations.get(\u0026#34;100\u0026#34;, \u0026#34;name\u0026#34;); System.out.println(name); // hkeys Set keys = hashOperations.keys(\u0026#34;100\u0026#34;); System.out.println(keys); // hvals List values = hashOperations.values(\u0026#34;100\u0026#34;); System.out.println(values); // hdel hashOperations.delete(\u0026#34;100\u0026#34;, \u0026#34;name\u0026#34;); } 列表類型數據 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Test public void testList(){ ListOperations listOperations = redisTemplate.opsForList(); // lpush listOperations.leftPushAll(\u0026#34;mylist\u0026#34;, \u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;); listOperations.leftPush(\u0026#34;mylist\u0026#34;, \u0026#34;d\u0026#34;); // lrange List mylist = listOperations.range(\u0026#34;mylist\u0026#34;, 0, -1); System.out.println(mylist); // rpop listOperations.rightPop(\u0026#34;mylist\u0026#34;); // llen Long size = listOperations.size(\u0026#34;mylist\u0026#34;); System.out.println(size); } 集合類型數據 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 @Test public void testSet(){ SetOperations setOperations = redisTemplate.opsForSet(); // sadd setOperations.add(\u0026#34;set1\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;,\u0026#34;c\u0026#34;,\u0026#34;d\u0026#34;); setOperations.add(\u0026#34;set2\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;,\u0026#34;x\u0026#34;,\u0026#34;y\u0026#34;); // smembers Set members = setOperations.members(\u0026#34;set1\u0026#34;); System.out.println(members); // scard Long size = setOperations.size(\u0026#34;set1\u0026#34;); System.out.println(size); // sinter Set intersect = setOperations.intersect(\u0026#34;set1\u0026#34;, \u0026#34;set2\u0026#34;); System.out.println(intersect); // sunion Set union = setOperations.union(\u0026#34;set1\u0026#34;, \u0026#34;set2\u0026#34;); System.out.println(union); // srem setOperations.remove(\u0026#34;set1\u0026#34;, \u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;); } 有序集合類型數據 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Test public void testZset(){ ZSetOperations zSetOperations = redisTemplate.opsForZSet(); // zadd zSetOperations.add(\u0026#34;zset1\u0026#34;, \u0026#34;a\u0026#34;, 10); zSetOperations.add(\u0026#34;zset1\u0026#34;, \u0026#34;b\u0026#34;, 12); zSetOperations.add(\u0026#34;zset1\u0026#34;, \u0026#34;c\u0026#34;, 9); // zrange Set zset = zSetOperations.range(\u0026#34;zset1\u0026#34;, 0, -1); System.out.println(zset); // zincrby zSetOperations.incrementScore(\u0026#34;zset1\u0026#34;, \u0026#34;c\u0026#34;, 10); // zrem zSetOperations.remove(\u0026#34;zset1\u0026#34;, \u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;); } 通用命令操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @Test public void testCommon(){ // keys Set keys = redisTemplate.keys(\u0026#34;*\u0026#34;); System.out.println(keys); // exists Boolean name = redisTemplate.hasKey(\u0026#34;name\u0026#34;); System.out.println(name); // type for (Object key : keys) { DataType type = redisTemplate.type(key); System.out.println(type.name()); } // del redisTemplate.delete(\u0026#34;set2\u0026#34;); } ","date":"2024-02-23T16:40:34+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/157/","title":"Redis"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 Golang 系列\nHello GoLang: https://blog.yexca.net/zh-tw/archives/154 GoLang (var and const) 變數與常數: https://blog.yexca.net/zh-tw/archives/155 GoLang (func) 函式: 本文\nGoLang (slice and map) 切片: https://blog.yexca.net/zh-tw/archives/160 GoLang (OOP) 物件導向: https://blog.yexca.net/zh-tw/archives/162 GoLang (reflect) 反射: https://blog.yexca.net/zh-tw/archives/204 GoLang (struct tag) 結構體標籤: https://blog.yexca.net/zh-tw/archives/205 GoLang (goroutine) Goroutine: https://blog.yexca.net/zh-tw/archives/206 GoLang (channel) 通道: https://blog.yexca.net/zh-tw/archives/207 多個回傳值 Go 函式可以回傳多個值\n匿名回傳 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package main import \u0026#34;fmt\u0026#34; func swap(a, b int) (int, int) { return b, a } func main() { var x, y = swap(10, 20) fmt.Println(x, y) } /* 輸出 * 20 10 */ 具名回傳 1 2 3 4 5 6 7 8 9 10 11 12 13 14 package main import \u0026#34;fmt\u0026#34; func swap(a, b int) (x int, y int) { x = b y = a return } func main() { var x, y = swap(10, 20) fmt.Println(x, y) } 上述回傳值型別相同，可以合併\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package main import \u0026#34;fmt\u0026#34; func swap(a, b int) (x, y int) { x = b y = a // 如果不給 x,y 賦值，預設為 0 return } func main() { var x, y = swap(10, 20) fmt.Println(x, y) } init 與 main init 可以在任何套件中，也可以在同一個套件中出現多次，但建議只寫一個。\nmain 只能在 package main 中，且該套件必須有該函式。\n這兩個函式為保留函式，定義時不能有參數和回傳值。\nGo 程式會自動呼叫 init() 和 main()。\n程式執行 程式的初始化和執行都起始於 main 套件，同一個套件就算被多個套件 import 匯入也只會匯入一次，下圖為執行順序：\n例子\n假設結構如下：\n1 2 3 4 5 6 hello -- InitLib1 -- lib1.go -- InitLib2 -- lib2.go main.go 內容如下：\nlib1.go\n1 2 3 4 5 6 7 package InitLib1 import \u0026#34;fmt\u0026#34; func init() { fmt.Println(\u0026#34;lib1 init\u0026#34;) } lib2.go\n1 2 3 4 5 6 7 package InitLib2 import \u0026#34;fmt\u0026#34; func init() { fmt.Println(\u0026#34;lib2 init\u0026#34;) } main.go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package main import ( \u0026#34;fmt\u0026#34; // 此處底線為套件起別名，不給別名且匯入後不呼叫，編譯不會通過 _ \u0026#34;hello/InitLib1\u0026#34; _ \u0026#34;hello/InitLib2\u0026#34; ) func init() { fmt.Println(\u0026#34;main init\u0026#34;) } func main() { fmt.Println(\u0026#34;main\u0026#34;) } 執行結果：\n1 2 3 4 lib1 init lib2 init main init main 現在將 Lib1 套件匯入 Lib2，main 程式碼不變。\nlib1.go\n1 2 3 4 5 6 7 8 9 10 package InitLib1 import ( \u0026#34;fmt\u0026#34; _ \u0026#34;hello/InitLib2\u0026#34; ) func init() { fmt.Println(\u0026#34;lib1 init\u0026#34;) } 執行 main 結果：\n1 2 3 4 lib2 init lib1 init main init main lib2 只出現一次。\n呼叫其他套件函式 上例使用 _ 作為別名是匿名的，無法呼叫相應套件的方法。\n在 lib1 中增加函式：\nlib1.go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package InitLib1 import ( \u0026#34;fmt\u0026#34; //_ \u0026#34;hello/InitLib2\u0026#34; ) // 首字母大寫才可在其他套件呼叫 func Lib1Test() { fmt.Println(\u0026#34;lib1 test\u0026#34;) } func init() { fmt.Println(\u0026#34;lib1 init\u0026#34;) } main.go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package main import ( \u0026#34;fmt\u0026#34; // 給套件起別名 mylib1 \u0026#34;hello/InitLib1\u0026#34; _ \u0026#34;hello/InitLib2\u0026#34; ) func main() { // 透過 別名.方法 呼叫 mylib1.Lib1Test() fmt.Println(\u0026#34;main\u0026#34;) } /* * 輸出 * lib1 init * lib2 init * lib1 test * main */ 或者可以直接使用 .，檔案 main.go：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 package main import ( \u0026#34;fmt\u0026#34; // 別名改為 . . \u0026#34;hello/InitLib1\u0026#34; _ \u0026#34;hello/InitLib2\u0026#34; ) func main() { // 直接使用 Lib1Test() fmt.Println(\u0026#34;main\u0026#34;) } 不推薦使用，假設兩個套件有同名函式，將會產生歧義。\n指標 與 C 指標類似。\n呼叫函式可以使用兩種方式傳遞參數：值傳遞與指標（引用傳遞/傳址）。預設情況使用值傳遞，如本文第一段程式碼即為值傳遞。\n使用 \u0026amp; 可以獲取變數對應的記憶體位址。\n1 2 3 4 5 6 7 8 9 10 package main import ( \u0026#34;fmt\u0026#34; ) func main() { var a int fmt.Printf(\u0026#34;%x\u0026#34;, \u0026amp;a) } 傳址將記憶體位址傳遞給函式，函式修改將影響實際參數。同樣是交換函式，這次使用指標：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package main import \u0026#34;fmt\u0026#34; func swap(a, b *int) { var tmp = *a *a = *b *b = tmp } func main() { x, y := 10, 20 swap(\u0026amp;x, \u0026amp;y) fmt.Println(\u0026#34;x =\u0026#34;, x, \u0026#34;y =\u0026#34;, y) } defer defer 語句用於預定對一個函式的呼叫，可以稱為延遲函式，作用：\n釋放佔用的資源 捕捉處理異常 輸出日誌 類似於 try\u0026hellip;catch\u0026hellip;finally 的 finally。\n常用於處理成對的操作，如打開/關閉檔案、獲取/釋放鎖、連接/斷開連接等，確保資源被適當釋放，即使在發生錯誤或提前返回的情況下也能保證執行。\n如果一個函式中有多個 defer 語句，類似於堆疊（Stack），以 LIFO（後進先出）順序執行。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package main import \u0026#34;fmt\u0026#34; func deferDemo() { defer fmt.Println(\u0026#34;1\u0026#34;) defer fmt.Println(\u0026#34;2\u0026#34;) defer fmt.Println(\u0026#34;3\u0026#34;) defer fmt.Println(\u0026#34;4\u0026#34;) } func main() { deferDemo() } /* * 輸出 * 4 * 3 * 2 * 1 */ recover 執行時 panic 異常一旦被引發就會導致程式崩潰，recover 為用於「攔截」執行時 panic 的內建函式，類似 Java 的 try\u0026hellip;catch 的抓取異常。\nrecover 只有在 defer 呼叫的函式中有效。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 package main import \u0026#34;fmt\u0026#34; func deferDemo(i int) { var arr [10]int // 錯誤攔截在錯誤發生前設置 defer func() { // 設置 recover 攔截錯誤資訊 err := recover() if err != nil { fmt.Println(err) } }() arr[i] = 10 } func main() { deferDemo(10) fmt.Println(\u0026#34;main code\u0026#34;) } /* * 輸出 * runtime error: index out of range [10] with length 10 * main code */ ","date":"2024-02-22T04:47:28+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/156/","title":"GoLang 函式"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 Golang 系列\nHello GoLang: https://blog.yexca.net/zh-tw/archives/154 GoLang (var and const) 變數與常數: 本文\nGoLang (func) 函式: https://blog.yexca.net/zh-tw/archives/156 GoLang (slice and map) 切片: https://blog.yexca.net/zh-tw/archives/160 GoLang (OOP) 物件導向: https://blog.yexca.net/zh-tw/archives/162 GoLang (reflect) 反射: https://blog.yexca.net/zh-tw/archives/204 GoLang (struct tag) 結構體標籤: https://blog.yexca.net/zh-tw/archives/205 GoLang (goroutine) Goroutine: https://blog.yexca.net/zh-tw/archives/206 GoLang (channel) 通道: https://blog.yexca.net/zh-tw/archives/207 變數 宣告變數一般使用 var 關鍵字\n單一變數 定義型別 不指定初始值的宣告，預設為 0\n1 2 3 4 5 6 7 8 package main import \u0026#34;fmt\u0026#34; func main() { var a int fmt.Println(\u0026#34;a =\u0026#34;, a) } 指定初始值，a 為 100\n1 2 3 4 5 6 7 8 package main import \u0026#34;fmt\u0026#34; func main() { var a int = 100 fmt.Println(\u0026#34;a =\u0026#34;, a) } 省略型別 在宣告時不指定型別的話，Go 會自動推導變數型別\n1 2 3 4 5 6 7 8 9 10 11 12 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) func main() { var a = 100 fmt.Println(\u0026#34;a =\u0026#34;, a) fmt.Printf(\u0026#34;Type of a = %s\u0026#34;, reflect.TypeOf(a)) } := 基於省略型別會自動推導，可以使用 := 直接宣告變數\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) func main() { p := 3.14 fmt.Println(\u0026#34;p =\u0026#34;, p) fmt.Printf(\u0026#34;Type of p is %s\u0026#34;, reflect.TypeOf(p)) } /* * 輸出 * p = 3.14 * Type of p is float64 */ 多重變數 相同型別 1 2 3 4 5 6 7 8 9 package main import \u0026#34;fmt\u0026#34; func main() { var a, b int fmt.Println(\u0026#34;a =\u0026#34;, a) fmt.Println(\u0026#34;b =\u0026#34;, b) } 相同型別賦值 1 2 3 4 5 6 7 8 9 package main import \u0026#34;fmt\u0026#34; func main() { var a, b int = 100, 200 fmt.Println(\u0026#34;a =\u0026#34;, a) fmt.Println(\u0026#34;b =\u0026#34;, b) } 不同型別 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) func main() { var a, b = 100, 3.14 fmt.Println(\u0026#34;a =\u0026#34;, a) fmt.Printf(\u0026#34;Type of a is %s\\n\u0026#34;, reflect.TypeOf(a)) fmt.Println(\u0026#34;b =\u0026#34;, b) fmt.Printf(\u0026#34;Type of b is %s\u0026#34;, reflect.TypeOf(b)) } /* * 輸出 * a = 100 * Type of a is int * b = 3.14 * Type of b is float64 */ 不同型別 2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) func main() { a, b := 100, \u0026#34;Hello\u0026#34; fmt.Println(\u0026#34;a =\u0026#34;, a) fmt.Printf(\u0026#34;Type of a is %s\\n\u0026#34;, reflect.TypeOf(a)) fmt.Println(\u0026#34;b =\u0026#34;, b) fmt.Printf(\u0026#34;Type of b is %s\u0026#34;, reflect.TypeOf(b)) } 字串型別在 Go 裡面是一個結構，包含指向底層陣列的指標和長度，這兩部分各佔 8 個位元組，所以字串型別大小為 16 個位元組\n可以使用 unsafe.Sizeof() 函式查看型別佔用空間\n全局變數 全局變數的宣告不能使用 :=\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) var a, b int func main() { fmt.Println(\u0026#34;a =\u0026#34;, a) fmt.Printf(\u0026#34;Type of a is %s\\n\u0026#34;, reflect.TypeOf(a)) fmt.Println(\u0026#34;b =\u0026#34;, b) fmt.Printf(\u0026#34;Type of b is %s\u0026#34;, reflect.TypeOf(b)) } 或者使用分解的寫法，這種寫法一般用於全局變數\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) var ( a int = 1 b string = \u0026#34;Go\u0026#34; ) func main() { fmt.Println(\u0026#34;a =\u0026#34;, a) fmt.Printf(\u0026#34;Type of a is %s\\n\u0026#34;, reflect.TypeOf(a)) fmt.Println(\u0026#34;b =\u0026#34;, b) fmt.Printf(\u0026#34;Type of b is %s\u0026#34;, reflect.TypeOf(b)) } 常數 常數一般用 const 關鍵字定義\n定義 1 2 3 4 5 6 7 8 package main import \u0026#34;fmt\u0026#34; func main() { const c int = 9 fmt.Println(\u0026#34;c = \u0026#34;, c) } 也可以省略型別\n1 2 3 4 5 6 7 8 package main import \u0026#34;fmt\u0026#34; func main() { const c = 9 fmt.Println(\u0026#34;c = \u0026#34;, c) } 列舉 常數定義可用於列舉\n1 2 3 4 5 6 7 8 9 package main func main() { const ( BEIJING = 0 SHANGHAI = 1 SHENZHEN = 2 ) } iota 自增 上述列舉以 0 開始遞增，可以使用 iota 代替\n1 2 3 4 5 6 7 8 9 10 11 12 13 package main import \u0026#34;fmt\u0026#34; func main() { const ( BEIJING = iota // 0 SHANGHAI // 1 SHENZHEN // 2 ) fmt.Println(BEIJING, SHANGHAI, SHENZHEN) } iota 可以用於運算式，但一般用於自增\n","date":"2024-02-20T06:41:18+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/155/","title":"GoLang 變數與常數"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 Golang 系列\nHello GoLang: 本文\nGoLang (var and const) 變數與常數: https://blog.yexca.net/zh-tw/archives/155 GoLang (func) 函式: https://blog.yexca.net/zh-tw/archives/156 GoLang (slice and map) 切片: https://blog.yexca.net/zh-tw/archives/160 GoLang (OOP) 物件導向: https://blog.yexca.net/zh-tw/archives/162 GoLang (reflect) 反射: https://blog.yexca.net/zh-tw/archives/204 GoLang (struct tag) 結構體標籤: https://blog.yexca.net/zh-tw/archives/205 GoLang (goroutine) Go 協程: https://blog.yexca.net/zh-tw/archives/206 GoLang (channel) 通道: https://blog.yexca.net/zh-tw/archives/207 Go 下載： https://go.dev/dl/ JetBrains GoLand： https://www.jetbrains.com/go/ Go 簡介 Go 可以直接編譯，直接執行即可部署，靜態型別語言\n1 2 3 4 5 6 7 # 直接執行 go run hello.go # 編譯 go build hello.go # 編譯後執行 ./hello Go 的一些應用\n(1)、雲端運算基礎建設領域\n代表專案：docker、kubernetes、etcd、consul、cloudflare CDN、七牛雲儲存等\n(2)、基礎後端軟體\n代表專案：tidb、influxdb、cockroachdb 等\n(3)、微服務\n代表專案：go-kit、micro、monzo bank的typhon、bilibili 等\n(4)、網際網路基礎建設\n代表專案：以太坊、hyperledger 等\nHello Go 1 2 3 4 5 6 7 8 9 10 11 package main // 定義套件名稱 /* * 必須在原始碼檔案非註解的第一行指明檔案屬於哪個套件 * main 表示一個可獨立執行的程式，每個 Go 應用程式都包含一個名為 main 的套件 */ import \u0026#34;fmt\u0026#34; // 匯入 fmt 套件，實作了格式化 IO 的函式 func main(){ // 函式 fmt.println(\u0026#34;Hello Go\u0026#34;) } 一般 main 函式是啟動後第一個執行的函式，如果有 init 函式會先執行 init 函式\n定義函式時，{ 必須與函式名稱在同一行\n","date":"2024-02-19T07:58:37+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/154/","title":"Hello GoLang"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 這什麼時候寫的文章啊（\n檢查是否有 Xfce 群組 1 yum grouplist 如果沒有，需要安裝額外套件的 yum 來源\n1 yum install epel-release -y 安裝 X Window system 1 yum groupinstall \u0026#34;X Window system\u0026#34; 安裝 Xfce 1 yum groupinstall xfce 安裝中文字型 (楷體) 1 yum install cjkuni-ukai-fonts 進入 Xfce 桌面 1 systemctl isolate graphical.target 參考文章 CentOS 7安装Xfce桌面环境过程_qq_28641401的博客-CSDN博客 ","date":"2024-02-17T22:51:34+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/153/","title":"CentOS 7 安裝 Xfce"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 新年快樂！\n流程： https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/login.html 前端取得授權碼，向 https://api.weixin.qq.com/sns/jscode2session 發起請求，取得 session_key 與 openid\n微信請求介面： https://developers.weixin.qq.com/miniprogram/dev/OpenApiDoc/user-login/code2Session.html 分析設計 介面設計 請求路徑：/user/user/login\n請求方式：POST\n請求參數：code String (微信使用者授權碼)\n回傳資料：\nid integer (使用者 ID) openid (微信 openid) token (jwt 令牌) 資料庫表格設計 使用者第一次使用小程序會自動註冊，將相關資訊儲存到 user 表格\n欄位名稱 資料類型 說明 id bigint 主鍵，自動遞增 openid varchar(45) 微信使用者唯一識別碼 name varchar(32) 使用者姓名 phone varchar(11) 手機號碼 gender varchar(2) 性別 id_number varchar(18) 身分證字號 avatar varchar(500) 微信使用者頭像路徑 create_time datetime 註冊時間 以個人身分註冊的小程式沒有權限取得微信使用者的手機號碼\n程式配置 首先配置微信登入所需參數\napplication-dev.yml\n1 2 3 4 sky: wechat: appid: your_appid secret: your_secret application.yml\n1 2 3 4 sky: wechat: appid: ${sky.wechat.appid} secret: ${sky.wechat.secret} 配置為微信使用者產生 jwt 令牌時使用的配置項目\n1 2 3 4 5 6 sky: jwt: # 使用者相關 user-secret-key: key user-ttl: 7200000 user-token-name: authentication Java 業務程式碼 controller\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 @RestController @RequestMapping(\u0026#34;/user/user\u0026#34;) @Api(tags = \u0026#34;使用者相關介面\u0026#34;) @Slf4j public class UserController { @Autowired private UserService userService; @Autowired private JwtProperties jwtProperties; @PostMapping(\u0026#34;/login\u0026#34;) @ApiOperation(\u0026#34;微信登入\u0026#34;) public Result\u0026lt;UserLoginVO\u0026gt; login(@RequestBody UserLoginDTO userLoginDTO){ log.info(\u0026#34;微信使用者登入：{}\u0026#34;, userLoginDTO.getCode()); // 微信登入 User user = userService.wxlogin(userLoginDTO); // 為微信使用者產生jwt令牌 HashMap\u0026lt;String, Object\u0026gt; claims = new HashMap\u0026lt;\u0026gt;(); claims.put(JwtClaimsConstant.USER_ID, user.getId()); String token = JwtUtil.createJWT(jwtProperties.getUserSecretKey(), jwtProperties.getUserTtl(), claims); UserLoginVO userLoginVO = UserLoginVO.builder() .id(user.getId()) .openid(user.getOpenid()) .token(token) .build(); return Result.success(userLoginVO); } } service\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 @Service @Slf4j public class UserServiceImpl implements UserService { // 微信介面 public static final String WX_LOGIN = \u0026#34;https://api.weixin.qq.com/sns/jscode2session\u0026#34;; @Autowired private WeChatProperties weChatProperties; @Autowired private UserMapper userMapper; @Override public User wxlogin(UserLoginDTO userLoginDTO) { String openid = getOpenid(userLoginDTO.getCode()); // 判斷openid是否合法 if (openid == null){ throw new LoginFailedException(MessageConstant.LOGIN_FAILED); } // 判斷是否為新使用者 User user = userMapper.getByOpenid(openid); // 若為新使用者，自動註冊 if (user == null){ user = User.builder() .openid(openid) .createTime(LocalDateTime.now()) .build(); userMapper.insert(user); } return user; } // 呼叫微信介面，取得使用者openid private String getOpenid(String code){ Map\u0026lt;String,String\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(\u0026#34;appid\u0026#34;, weChatProperties.getAppid()); map.put(\u0026#34;secret\u0026#34;, weChatProperties.getSecret()); map.put(\u0026#34;js_code\u0026#34;, code); map.put(\u0026#34;grant_type\u0026#34;, \u0026#34;authorization_code\u0026#34;); String json = HttpClientUtil.doGet(WX_LOGIN, map); JSONObject jsonObject = JSON.parseObject(json); String openid = jsonObject.getString(\u0026#34;openid\u0026#34;); return openid; } } Mapper\n1 2 3 4 5 6 7 @Mapper public interface UserMapper { @Select(\u0026#34;select * from user where openid = #{openid}\u0026#34;) User getByOpenid(String openid); void insert(User user); } Mapper XML\n1 2 3 4 5 6 7 8 9 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34; \u0026gt; \u0026lt;mapper namespace=\u0026#34;com.sky.mapper.UserMapper\u0026#34;\u0026gt; \u0026lt;insert id=\u0026#34;insert\u0026#34;\u0026gt; insert into user(openid, name, phone, sex, id_number, avatar, create_time) VALUES (#{openid}, #{name}, #{phone}, #{sex}, #{idNumber}, #{avatar}, #{createTime}) \u0026lt;/insert\u0026gt; \u0026lt;/mapper\u0026gt; 攔截器 統一攔截使用者端發送的請求進行 JWT 驗證\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 @Component @Slf4j public class JwtTokenUserInterceptor implements HandlerInterceptor { @Autowired private JwtProperties jwtProperties; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { // 判斷攔截類型，是控制器 (Controller) 還是其他資源 if(!(handler instanceof HandlerMethod)){ // 目前攔截的不是動態方法，直接放行 return true; } // 從請求中取得令牌 String token = request.getHeader(jwtProperties.getUserTokenName()); // 驗證令牌 try { log.info(\u0026#34;jwt驗證：{}\u0026#34;, token); Claims claims = JwtUtil.parseJWT(jwtProperties.getUserSecretKey(), token); Long userId = Long.valueOf(claims.get(JwtClaimsConstant.USER_ID).toString()); log.info(\u0026#34;目前使用者ID：{}\u0026#34;, userId); BaseContext.setCurrentId(userId); // 驗證通過 return true; }catch (Exception ex){ // 驗證未通過 return false; } } } 在 WebMvcConfiguration 註冊攔截器\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Autowired private JwtTokenUserInterceptor jwtTokenUserInterceptor; /** * 註冊自訂攔截器 * @param registry */ protected void addInterceptors(InterceptorRegistry registry) { log.info(\u0026#34;開始註冊自訂攔截器...\u0026#34;); //......... registry.addInterceptor(jwtTokenUserInterceptor) .addPathPatterns(\u0026#34;/user/**\u0026#34;) .excludePathPatterns(\u0026#34;/user/user/login\u0026#34;) .excludePathPatterns(\u0026#34;/user/shop/status\u0026#34;); } ","date":"2024-02-10T18:09:17+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/152/","title":"微信登入後端"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 官網： https://mp.weixin.qq.com/cgi-bin/wx 開發小程式之前需要先註冊一個小程式，可以使用不同主體註冊小程式，相應的權限也不同。例如以個人的身份註冊小程式是無法獲得支付權限的 (也可以使用測試帳號體驗)\n註冊完成後設定相關資訊，獲取 AppID 與 AppSecret，下載 開發者工具 ，登入，建立專案\n首先右上角「詳情」-「本地設定」，勾選「不校驗合法網域名稱、web-view (業務網域)、TLS 版本以及 HTTPS 憑證」\n小程式的開發屬於前端開發，主要使用 JavaScript\n小程式目錄結構 小程式包含一個描述整體程式的 app 和多個描述各自頁面的 page\n主體部分 由三個檔案組成，必須放在專案的根目錄\n檔案 作用 app.js 小程式邏輯 app.json 小程式全域設定 app.wxss 小程式全域樣式表，非必須檔案，類似 CSS 頁面 一個小程式有多個頁面，存放在 pages 目錄\n每個頁面由四個檔案組成\n檔案類型 是否必須 作用 js 是 頁面邏輯，JavaScript wxml 是 頁面結構、佈局，HTML json 否 頁面設定 wxss 否 頁面樣式表，CSS 簡單入門 小程式的撰寫風格類似於 Vue\n插值 wxml\n1 \u0026lt;view\u0026gt;{{title}}\u0026lt;/view\u0026gt; js\n1 2 3 4 5 Page({ data: { title: \u0026#39;Hello\u0026#39; } }) 取得使用者資訊 wxml\n1 2 3 4 \u0026lt;view\u0026gt; \u0026lt;button type=\u0026#34;default\u0026#34; bindtap=\u0026#34;getUserInfo\u0026#34;\u0026gt;取得使用者資訊\u0026lt;/button\u0026gt; \u0026lt;image src=\u0026#34;{{avatarUrl}}\u0026#34; style=\u0026#34;width: 100px; height: 100px;\u0026#34;/\u0026gt;{{nickName}} \u0026lt;/view\u0026gt; js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 Page({ data: { title: \u0026#39;Hello\u0026#39;, avatarUrl: \u0026#39;\u0026#39;, nickName: \u0026#39;\u0026#39; }, getUserInfo: function(){ wx.getUserProfile({ desc: \u0026#39;取得使用者資訊\u0026#39;, success: (res) =\u0026gt; { console.log(res); this.setData({ avatarUrl: res.userInfo.avatarUrl, nickName: res.userInfo.nickName }) } }) } }) 微信登入 wxml\n1 2 3 4 \u0026lt;view\u0026gt; \u0026lt;button type=\u0026#34;primary\u0026#34; bind:tap=\u0026#34;wxlogin\u0026#34;\u0026gt;微信登入\u0026lt;/button\u0026gt; 授權碼：{{code}} \u0026lt;/view\u0026gt; js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 Page({ data: { code: \u0026#39;\u0026#39; }, wxlogin: function(){ wx.login({ success: (res) =\u0026gt; { console.log(\u0026#34;授權碼：\u0026#34; + res.code); this.setData({ code: res.code }) }, }) } }) 微信登入流程： https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/login.html 傳送 HTTP 請求 wxml\n1 2 3 4 \u0026lt;view\u0026gt; \u0026lt;button type=\u0026#34;warn\u0026#34; bind:tap=\u0026#34;sendRequest\u0026#34;\u0026gt;傳送請求\u0026lt;/button\u0026gt; 回應結果：{{result}} \u0026lt;/view\u0026gt; js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 Page({ data: { result: \u0026#39;\u0026#39; }, sendRequest: function(){ wx.request({ url: \u0026#39;url\u0026#39;, // 請求路徑 method: \u0026#39;GET\u0026#39;, // 請求方式 success: (res) =\u0026gt; { console.log(\u0026#34;回應結果：\u0026#34; + res.data); this.setData({ result: res.data // 回應數據 }) } }) } }) 編譯與發佈 上方編譯按鈕，編譯完成後在左方預覽\n程式碼開發完畢後，上傳，指定版本號。上傳成功後在微信公眾平台提交審核後可以發佈為線上版本\n","date":"2024-01-31T16:50:34+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/151/","title":"了解微信小程式"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 前言 HTML 學習一 - 基礎: https://blog.yexca.net/zh-tw/archives/146 HTML 學習二 - 清單、表格與表單: https://blog.yexca.net/zh-tw/archives/150 HTML 學習三 - 網頁版面配置: https://blog.yexca.net/zh-tw/archives/195 清單 清單分為無序、有序清單和定義清單\n無序清單 unordered list -\u0026gt; list\n1 2 3 4 5 \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;第一項\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;第二項\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;第三項\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; 效果如下\n第一項 第二項 第三項 有序清單 ordered list -\u0026gt; list\n1 2 3 4 5 \u0026lt;ol\u0026gt; \u0026lt;li\u0026gt;第一項\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;第二項\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;第三項\u0026lt;/li\u0026gt; \u0026lt;/ol\u0026gt; 效果如下\n第一項 第二項 第三項 定義清單 個人記憶: define list -\u0026gt; define title -\u0026gt; define describe\n1 2 3 4 5 6 7 8 \u0026lt;dl\u0026gt; \u0026lt;dt\u0026gt;第一標題\u0026lt;/dt\u0026gt; \u0026lt;dd\u0026gt;1.1 描述\u0026lt;/dd\u0026gt; \u0026lt;dd\u0026gt;1.2 描述\u0026lt;/dd\u0026gt; \u0026lt;dt\u0026gt;第二標題\u0026lt;/dt\u0026gt; \u0026lt;dd\u0026gt;2.1 描述\u0026lt;/dd\u0026gt; \u0026lt;dd\u0026gt;2.2 描述\u0026lt;/dd\u0026gt; \u0026lt;/dl\u0026gt; 效果如下\n第一標題 1.1 描述 1.2 描述 第二標題 2.1 描述 2.2 描述 dl 標籤裡只能包含 dt 和 dd 標籤，而 dt 和 dd 標籤裡可以包含任何內容\n表格 標籤 說明 個人記憶 table 定義表格 tr 表格的列 table row th 表頭儲存格 table head td 內容儲存格 table data 以下結構標籤可以省略，主要用於瀏覽器\n標籤 說明 thead 定義標頭內容 tbody 定義表格主體 tfoot 定義表格底部，彙總資訊 表格範例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 \u0026lt;table\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;\\\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;x\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;y\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;total\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tbody\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;a\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;50\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;50\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;100\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;b\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;50\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;50\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;100\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/tbody\u0026gt; \u0026lt;tfoot\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;total\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;100\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;100\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;100\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/tfoot\u0026gt; \u0026lt;/table\u0026gt; 效果如下\n\\ x y total a 50 50 100 b 50 50 100 total 100 100 100 儲存格合併 表格合併分為跨行合併與跨列合併，合併後應刪除被合併的儲存格\n屬性 說明 rowspan 跨行合併，值為合併的行數 colspan 跨列合併，值為合併的列數 例如將以上表格第二列的第二個儲存格與第三列的第二個儲存格進行跨行合併，最後一列的最後三個儲存格跨列合併\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 \u0026lt;table\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;\\\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;x\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;y\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;total\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tbody\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;a\u0026lt;/td\u0026gt; \u0026lt;!-- 此處增加跨行合併屬性 --\u0026gt; \u0026lt;td rowspan=\u0026#34;2\u0026#34;\u0026gt;50\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;50\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;100\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;b\u0026lt;/td\u0026gt; \u0026lt;!-- 此內容可以刪除，此處註解 --\u0026gt; \u0026lt;!--\u0026lt;td\u0026gt;50\u0026lt;/td\u0026gt;--\u0026gt; \u0026lt;td\u0026gt;50\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;100\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/tbody\u0026gt; \u0026lt;tfoot\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;total\u0026lt;/td\u0026gt; \u0026lt;!-- 此處增加跨列合併屬性 --\u0026gt; \u0026lt;td colspan=\u0026#34;3\u0026#34;\u0026gt;100\u0026lt;/td\u0026gt; \u0026lt;!-- 此內容可以刪除，此處註解 --\u0026gt; \u0026lt;!--\u0026lt;td\u0026gt;100\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;100\u0026lt;/td\u0026gt;--\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/tfoot\u0026gt; \u0026lt;/table\u0026gt; 效果如下\n\\ x y total a 50 50 100 b 50 100 total 100 如果使用了結構標籤 (thead, tbody, tfoot)，則不能跨結構合併，例如以上表格第三列不能和最後一列合併\n表單 form 標籤 一個表單需要使用 form 標籤來劃定表單的範圍，以下所述標籤需要放在 form 標籤內\ninput 標籤 大多數表單使用 input 標籤實作，根據 type 屬性值的不同，能實作不同功能\ntype 屬性值 說明 text 文字方塊 password 密碼方塊 radio 單選按鈕 checkbox 核取方塊 file 上傳檔案 佔位文字 佔位文字即提示資訊，文字方塊和密碼方塊可以使用\n1 \u0026lt;input type=\u0026#34;text\u0026#34; placeholder=\u0026#34;提示資訊\u0026#34; /\u0026gt; 效果如下\n單選按鈕 (radio) 屬性 作用 name 控制項名稱 checked 預設選取 以下程式碼實作性別選擇\n1 2 3 性別： \u0026lt;input type=\u0026#34;radio\u0026#34; name=\u0026#34;gender\u0026#34; checked /\u0026gt;男 \u0026lt;input type=\u0026#34;radio\u0026#34; name=\u0026#34;gender\u0026#34; /\u0026gt;女 效果如下\n性別： 男 女 檔案上傳 預設情況下，file 類型只能上傳一個檔案，若要上傳多個檔案，可以新增 multiple 屬性\n1 \u0026lt;input type=\u0026#34;file\u0026#34; multiple /\u0026gt; 核取方塊 (checkbox) 又稱複選方塊，預設選取可以使用屬性 checked\n1 2 3 4 \u0026lt;input type=\u0026#34;checkbox\u0026#34; checked /\u0026gt; a \u0026lt;input type=\u0026#34;checkbox\u0026#34; /\u0026gt; b \u0026lt;input type=\u0026#34;checkbox\u0026#34; /\u0026gt; c \u0026lt;input type=\u0026#34;checkbox\u0026#34; /\u0026gt; d 下拉式選單 1 2 3 4 5 6 7 \u0026lt;select\u0026gt; \u0026lt;option\u0026gt;CN\u0026lt;/option\u0026gt; \u0026lt;option\u0026gt;USA\u0026lt;/option\u0026gt; \u0026lt;option\u0026gt;UK\u0026lt;/option\u0026gt; \u0026lt;!-- selected 指定預設選取 --\u0026gt; \u0026lt;option selected\u0026gt;JP\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; 文字區域 實作多行輸入文字的表單控制項，一般為個人簡介\n1 \u0026lt;textarea\u0026gt;提示資訊\u0026lt;/textarea\u0026gt; label 標籤 用於網頁中某個標籤的說明文字，還可以將文字和表單控制項綁定，以增大表單控制項的點擊範圍\n例如上述性別單選按鈕只有選取圓圈才能選取，而使用此標籤後，選取文字也能選取單選按鈕\n方法一 input 標籤新增 id 屬性，label 標籤新增 for 屬性，兩個屬性值相同\n1 2 3 4 \u0026lt;input type=\u0026#34;radio\u0026#34; name=\u0026#34;gender\u0026#34; id=\u0026#34;male\u0026#34;/\u0026gt; \u0026lt;label for=\u0026#34;male\u0026#34;\u0026gt;男\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;radio\u0026#34; name=\u0026#34;gender\u0026#34; id=\u0026#34;female\u0026#34;/\u0026gt; \u0026lt;label for=\u0026#34;female\u0026#34;\u0026gt;女\u0026lt;/label\u0026gt; 方法二 直接使用 label 標籤包覆文字和表單控制項\n1 2 \u0026lt;label\u0026gt;\u0026lt;input type=\u0026#34;radio\u0026#34; name=\u0026#34;gender\u0026#34; /\u0026gt;男\u0026lt;/label\u0026gt; \u0026lt;label\u0026gt;\u0026lt;input type=\u0026#34;radio\u0026#34; name=\u0026#34;gender\u0026#34; /\u0026gt;女\u0026lt;/label\u0026gt; 支援 label 標籤以增大點擊範圍的控制項包括：文字方塊、密碼方塊、上傳檔案、單選按鈕、核取方塊、下拉式選單、文字區域等\n按鈕 button 標籤根據 type 屬性值的不同，功能也會不同\ntype 屬性值 說明 submit 預設功能，提交資料到後端 reset 重設按鈕，將表單控制項恢復預設值 button 一般按鈕，需搭配 JavaScript 使用 1 \u0026lt;button type=\u0026#34;\u0026#34;\u0026gt;按鈕\u0026lt;/button\u0026gt; ","date":"2024-01-29T13:24:25+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/150/","title":"HTML 學習二 - 清單、表格與表單"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 前言 千萬不要把無窮迴圈放進去啊！！！請使用 systemd 方式\n建立腳本 請在此檔案中寫入您的腳本\n1 vi /etc/rc.d/rc.local 賦予執行權限\n1 chmod +x /etc/rc.d/rc.local 編輯啟動狀態 編輯檔案\n1 vi /usr/lib/systemd/system/rc-local.service 請在最後一行加入 [Install]\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # This file is part of systemd. # # systemd is free software; you can redistribute it and/or modify it # under the terms of the GNU Lesser General Public License as published by # the Free Software Foundation; either version 2.1 of the License, or # (at your option) any later version. # This unit gets pulled automatically into multi-user.target by # systemd-rc-local-generator if /etc/rc.d/rc.local is executable. [Unit] Description=/etc/rc.d/rc.local Compatibility ConditionFileIsExecutable=/etc/rc.d/rc.local After=network.target [Service] Type=forking ExecStart=/etc/rc.d/rc.local start TimeoutSec=0 RemainAfterExit=yes SysVStartPriority=99 [Install] WantedBy=multi-user.target 然後使用 systemd 開機自動啟動\n1 systemctl enable rc-local.service 檢視啟動狀態 請使用以下指令\n1 systemctl status rc-local.service 參考文章 Fedora 22(15以上版本)開機自動啟動腳本 - 可酷可樂 - 博客園 ","date":"2024-01-28T14:25:58+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/149/","title":"Fedora 開機啟動執行腳本"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 JS 是一門跨平台、物件導向的腳本語言，是用來控制網頁行為的，使網頁具備互動性。\nJS 引入方式 分為內部腳本和外部腳本兩種。\n內部腳本 將 JS 程式碼定義在 HTML 頁面中。\nJS 程式碼必須位於 \u0026lt;script\u0026gt;\u0026lt;/script\u0026gt; 標籤之間。 在 HTML 文件中，可以在任何地方放置任意數量的 \u0026lt;script\u0026gt;。 一般會把腳本置於 \u0026lt;body\u0026gt; 元素的底部，可以改善顯示速度。 1 2 3 \u0026lt;script\u0026gt; alert(\u0026#34;Hello JavaScript\u0026#34;) \u0026lt;/script\u0026gt; 外部腳本 將 JS 程式碼定義在外部 JS 檔案中，然後引入到 HTML 頁面中。\n外部 JS 檔案中，只包含 JS 程式碼，不包含 \u0026lt;script\u0026gt; 標籤。 1 2 3 4 5 \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;script src=\u0026#34;./js/1.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;/html\u0026gt; JS 檔案內容：\n1 alert(\u0026#34;Hello JavaScript\u0026#34;) JS 基礎語法 區分大小寫，每行結尾的分號可有可無。註解有兩種：\n1 2 3 4 5 // 單行註解 /* 多行註解 */ 大括號表示程式碼區塊：\n1 2 3 4 // 判斷 if(count==3){ alert(count); } 輸出語句 可以輸出到警告框、HTML 或主控台（Console）。\n1 2 3 4 5 6 // 瀏覽器彈出警告框 window.alert(\u0026#34;Hello from alert\u0026#34;) // 寫入 HTML 在瀏覽器展示 document.write(\u0026#34;Hello from HTML\u0026#34;) // 寫入瀏覽器主控台 console.log(\u0026#34;Hello from console\u0026#34;) 變數 JS 是一門弱型別語言，變數可以存放不同型別的值，變數名稱需要遵循如下規則：\n組成字元可以是任意字母、數字、底線或者錢字號（$）。 數字不能開頭。 建議使用駝峰式命名（camelCase）。 定義變數有三個關鍵字：var、let 和 const。\nvar var 是 variable 的縮寫，宣告的變數為全域變數，可以重複定義。\n1 2 3 4 5 6 7 8 9 10 // 重複宣告 var a = 1; var a = \u0026#39;A\u0026#39;; alert(a); // 全域變數 { var b = \u0026#39;B\u0026#39;; } alert(b); let 在 ECMAScript 6 新增，所宣告的變數只在 let 所在的程式碼區塊內有效，且不允許重複宣告。\n1 2 3 4 5 6 7 8 let a = \u0026#39;A\u0026#39;; alert(a); // 區域變數 { let a=\u0026#39;A\u0026#39;; } alert(a); // 無輸出，且在主控台報錯 const 用來宣告一個唯讀的常數，一旦宣告，無法被改變。\n1 2 3 const a = \u0026#39;A\u0026#39;; a = 1; alert(a); // 無輸出，且在主控台報錯 資料型別 JS 中分為原始型別與引用型別，即基本資料型別與物件。\n原始型別有五種：\nnumber：數字（整數、小數、NaN (Not a Number)）。 string：字串，單雙引號皆可。 boolean：布林值。true 和 false。 null：物件為空。 undefined：當宣告的物件未初始化時，該變數預設值是 undefined。 使用 typeof 運算子可以獲取資料型別。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // number console.log(\u0026#34;number 型別\u0026#34;); console.log(typeof 3); console.log(typeof 3.14); // string console.log(\u0026#34;\\nstring 型別\u0026#34;); console.log(typeof \u0026#39;A\u0026#39;); console.log(typeof \u0026#34;string\u0026#34;); // boolean console.log(\u0026#34;\\nboolean 型別\u0026#34;); console.log(typeof true); console.log(typeof false); // null - object console.log(\u0026#34;\\nnull-object 型別\u0026#34;); console.log(typeof null); // undefined var a; console.log(\u0026#34;\\nundefined 型別\u0026#34;); console.log(typeof a); 您也許會問，為什麼 typeof 運算子對於 null 值會回傳 \u0026ldquo;Object\u0026rdquo;。這實際上是 JavaScript 最初實作中的一個錯誤，然後被 ECMAScript 沿用了。現在，null 被認為是物件的佔位符，從而解釋了這一矛盾，但從技術上來說，它仍然是原始值。\n參考來源: https://www.w3school.com.cn/js/pro_js_primitivetypes.asp 運算子 算術運算子：+、-、*、/、%、++、\u0026ndash; 賦值運算子：=、+=、-=、*=、/=、%= 比較運算子：\u0026gt;、\u0026lt;、\u0026gt;=、\u0026lt;=、!=、==、=== 邏輯運算子：\u0026amp;\u0026amp;、||、! 三元運算子：condition ? true : false == 與 ===\n== 會進行型別轉換，而 === 不會進行型別轉換，即型別與值都相等才為 true。\n1 2 3 4 5 6 7 var a = 20; var aStr = \u0026#34;20\u0026#34;; var aInt = 20; console.log(a==aStr); // true console.log(a===aStr);// false console.log(a===aInt);// true 型別轉換 字串轉換為數字使用 parseInt() 函式即可。\n轉換是從第一個字元開始，直到遇到非數值。若開頭就是非數值，則轉為 NaN。\n1 2 3 4 5 6 7 var a = \u0026#34;12\u0026#34;; var b = \u0026#34;12A34\u0026#34;; var c = \u0026#34;A34\u0026#34;; console.log(parseInt(a)); // 12 console.log(parseInt(b)); // 12 console.log(parseInt(c)); // NaN 其他型別轉為 Boolean：\nNumber：0 和 NaN 為 false，其他均為 true。 String：空字串為 false，其他均為 true。 Null 和 undefined：均為 false。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // number if (0) { console.log(\u0026#34;0\u0026#34;); } if (NaN) { console.log(\u0026#34;NaN\u0026#34;); } if (-1) { console.log(\u0026#34;-1\u0026#34;); } // 執行結果：-1 // String if (\u0026#34;\u0026#34;) { console.log(\u0026#34;空字元\u0026#34;); } if (\u0026#34; \u0026#34;) { console.log(\u0026#34;空格\u0026#34;); } // 執行結果：空格 // Null 和 undefined if (null) { console.log(\u0026#34;null\u0026#34;) } if (undefined) { console.log(\u0026#34;undefined\u0026#34;) } if (1) { console.log(\u0026#34;null 和 undefined 都是 false\u0026#34;) } // 執行結果：null 和 undefined 都是 false 流程控制 if\u0026hellip;else if\u0026hellip;else switch for while do\u0026hellip;while 參考來源: https://www.w3school.com.cn/jsref/jsref_statements.asp 函式 函式是被設計為執行特定任務的程式碼區塊。\n函式的定義有兩種形式，通常的語法為：\n1 2 3 function functionName(var1,var2,...){ // code } 其中：\n形式參數不需要型別。 回傳值也不需要定義型別，可以直接在函式內部使用 return 回傳。 1 2 3 4 5 6 function add1(a, b){ return a+b; } var result = add1(10, 20); console.log(result); // 30 定義函式的方式二：\n1 2 3 var functionName = function(var1, var2,...){ // code } 上例採用此方法：\n1 2 3 4 5 6 var add2 = function(a, b){ return a+b; } var result = add2(10, 20); console.log(result); // 30 JS 中，函式呼叫可以傳遞任意個數的參數，但只接收定義的形參個數。\n物件 基礎物件、瀏覽器物件模型 BOM、文件物件模型 DOM。\nArray 陣列 定義方式一：\n1 2 3 var name = new Array(element1,element2,...); // 例如 var arr = new Array(1,2,3,4); 定義方式二：\n1 2 3 var name = [element]; // 例如 var arr = [1,2,3,4]; 存取與賦值：\n1 2 3 4 // 存取，索引從 0 開始 arr[2]; // 賦值 arr[4]=5; 陣列長度可變，也可以儲存任意型別的資料。\n1 2 3 4 5 6 7 8 9 10 var arr = [1,2,3,4]; // console.log(arr); // 長度可變 arr[9] = 8; // console.log(arr); // 型別可變 arr[8] = \u0026#39;A\u0026#39;; console.log(arr); 屬性 length 屬性可以回傳陣列中元素的數量，可用此屬性遍歷陣列。\n1 2 3 4 var arr = [1,2,3,4]; for (let i = 0; i \u0026lt; arr.length; i++) { console.log(arr[i]); } 方法 方法 描述 forEach() 遍歷陣列中的每個有值的元素，並呼叫一次傳入的函式 push() 將新元素添加到陣列的末尾，並回傳新的長度 splice() 從陣列中刪除元素 forEach 遍歷：\n1 2 3 4 var arr = [1,2,3,4]; arr.forEach(function(e){ console.log(e); }) 上述程式碼可以用箭頭函式簡化：\n1 2 3 4 // 箭頭函式：(...) =\u0026gt; {...} 簡化函式定義 arr.forEach(e =\u0026gt; { console.log(e); }); push 函式添加數值：\n1 2 3 4 var arr = [1,2,3,4]; // 可以有多個值 arr.push(5,6,7,8); console.log(arr);// [1,2,3,4,5,6,7,8] splice 刪除元素：\n1 2 3 4 5 var arr = [1,2,3,4];// [1,2,3,4,5,6,7,8] arr.push(5,6,7,8); // 從第幾個元素開始，刪除幾個元素 arr.splice(2,4); // 從第 2 個元素開始，刪除 4 個元素 console.log(arr);// [1,2,7,8] 兩種遍歷的區別 for 遍歷會遍歷所有元素，包括 undefined。而 forEach 僅遍歷有值的元素。\n1 2 3 4 5 6 7 8 9 10 11 12 var arr = [1,2,3,4]; arr[9] = 10; for (let i = 0; i \u0026lt; arr.length; i++) { console.log(arr[i]); }// 1,2,3,4,undefined,,,,,10 console.log(\u0026#34;==============================\u0026#34;); arr.forEach(e =\u0026gt; { console.log(e); })// 1,2,3,4,10 String 字串 建立方式有兩種：\n1 2 3 4 // 方式一 var name = new String(\u0026#34;\u0026#34;); // 方式二 var name = \u0026#34;\u0026#34;; // 單雙引號皆可 屬性與方法 屬性或方法 描述 length 字串的長度 charAt() 回傳在指定位置的字元 indexOf() 檢索字串 trim() 去除字串兩邊的空格 substring() 提取字串中兩個指定的索引號之間的字元 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 var str = \u0026#34;Hello String\u0026#34;; console.log(str.length); // 12 // 從 0 開始 console.log(str.charAt(4)); // o console.log(str.indexOf(\u0026#34;lo\u0026#34;)); // 3 var s = \u0026#34; Hello String \u0026#34;; var s = s.trim(); console.log(s); // Hello String // 開始，結束，含頭不含尾 var s = s.substring(0,5); console.log(s); // Hello JS 自定義物件 定義格式：\n1 2 3 4 5 6 var 物件名 = { 屬性名: 屬性值, 函式名: function(形參){ } } 例如：\n1 2 3 4 5 6 7 8 9 10 11 var person = { name: \u0026#34;tom\u0026#34;, age: 18, gender: \u0026#34;male\u0026#34;, eat: function(){ console.log(\u0026#34;吃飯nya\u0026#34;); } } console.log(person.age); person.eat(); 其中方法有簡寫：\n1 2 3 4 5 6 7 8 9 10 11 var person = { name: \u0026#34;tom\u0026#34;, age: 18, gender: \u0026#34;male\u0026#34;, // eat: function(){ // console.log(\u0026#34;吃飯nya\u0026#34;); // } eat(){ console.log(\u0026#34;吃飯nya\u0026#34;); } } JSON JavaScript Object Notation，JavaScript 物件標記法。JSON 是透過 JavaScript 物件標記法書寫的文本，由於其語法簡單，層次結構鮮明，現在多用於作為資料載體，在網路中進行資料傳輸。\n定義與實例：\n1 2 3 4 // 定義 var 變數名 = \u0026#39;{\u0026#34;key1\u0026#34;:value1,\u0026#34;key2\u0026#34;:value2}\u0026#39;; // 示例 var userStr = \u0026#39;{\u0026#34;name\u0026#34;:\u0026#34;Tom\u0026#34;,\u0026#34;age\u0026#34;:18,\u0026#34;addr\u0026#34;:[\u0026#34;台北\u0026#34;,\u0026#34;台中\u0026#34;]}\u0026#39;; 其中 value 的資料型別為：\n數字 (整數或浮點數) 字串 (在雙引號中) 邏輯值 (true 或 false) 陣列 (在方括號中) 物件 (在花括號中) null 在 JS 中有把物件轉為 JSON 字串的方法：\n1 var jsonStr = JSON.stringify(jsObject) 也有把 JSON 字串轉為物件的方法：\n1 2 var userStr = \u0026#39;{\u0026#34;name\u0026#34;:\u0026#34;Tom\u0026#34;,\u0026#34;age\u0026#34;:18,\u0026#34;addr\u0026#34;:[\u0026#34;台北\u0026#34;,\u0026#34;台中\u0026#34;]}\u0026#39;; var jsObject = JSON.parse(userStr) BOM Browser Object Model，瀏覽器物件模型，允許 JavaScript 與瀏覽器對話，JavaScript 將瀏覽器的各個組成部分封裝成物件。\nWindow：瀏覽器視窗物件 Navigator：瀏覽器物件 Screen：螢幕物件 History：歷史紀錄物件 Location：網址列物件 Window 瀏覽器視窗物件可直接使用，其中 window. 可以省略。屬性有：\n屬性 描述 history 對 History 物件的唯讀引用 location 用於視窗或框架的 Location 物件 navigator 對 Navigator 物件的唯讀引用 方法有：\n方法 描述 alert() 顯示帶有一段訊息和一個確認按鈕的警告框 confirm() 顯示帶有一段訊息以及確認按鈕和取消按鈕的對話框 setInterval() 按照指定的週期 (以毫秒計) 來呼叫函式或計算表達式 setTimeout() 在指定的毫秒數後呼叫函式或計算表達式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // 獲取 window 物件 window.alert(\u0026#34;獲取 window 物件\u0026#34;); // 或者省略前面 alert(\u0026#34;省略了 window\u0026#34;); // confirm var flag = confirm(\u0026#34;是否確認\u0026#34;); console.log(flag); // 定時器 1 var i = 0; setInterval(function(){ i++; console.log(\u0026#34;定時器執行 \u0026#34;+i+\u0026#34; 次\u0026#34;); },2000); // 每兩秒執行一次 // 定時器 2 setTimeout(function(){ console.log(\u0026#34;只會執行一次\u0026#34;); },3000); // 三秒後執行一次 Location 網址列物件，使用 window.location 獲取，其中 window. 可以省略。\n屬性 href 可以設置或回傳完整的 URL。\n1 2 3 4 // 獲取目前網址列地址 console.log(location.href); // 設置網址列地址，會自動跳轉 location.href = \u0026#34;https://blog.yexca.net/\u0026#34; DOM Document Object Model，文件物件模型，將標記語言的各個組成部分封裝為對應的物件。\nDOM 是 W3C 的標準，定義了存取 HTML 和 XML 文件的標準，分為三部分：\nCore DOM - 所有文件類型的標準模型 Document：整個文件物件 Element：元素物件 Attribute：屬性物件 Text：文字物件 Comment：註解物件 XML DOM - XML 文件的標準模型 HTML DOM - HTML 文件的標準模型 Image: \u0026lt;img\u0026gt; Button: \u0026lt;input type='button'\u0026gt; JS 透過 DOM，就能夠對 HTML 進行操作，例如：\n改變 HTML 元素的內容 改變 HTML 元素的樣式 (CSS) 對 HTML DOM 事件做出反應 添加和刪除 HTML 元素 HTML 中的 Element 物件可以透過 Document 物件獲取，而 Document 物件是透過 window 物件獲取的。\nDocument 物件中提供了以下獲取 Element 元素物件的函式：\n根據 id 屬性值獲取，回傳單個 Element 物件： 1 var app = document.getElementById(\u0026#39;app\u0026#39;); 根據標籤名稱獲取，回傳 Element 物件陣列： 1 var links = document.getElementsByTagName(\u0026#34;a\u0026#34;); 根據 name 屬性值獲取，回傳 Element 物件陣列： 1 var hobbys = document.getElementsByName(\u0026#39;hobby\u0026#39;); 根據 class 屬性值獲取，回傳 Element 物件陣列： 1 var classes = document.getElementsByClassName(\u0026#39;cls\u0026#39;); 以上範例 HTML：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-Hant\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;DOM\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt;abc\u0026lt;/a\u0026gt;\u0026lt;br\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;hobby\u0026#34;\u0026gt;hobby1 \u0026lt;br\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;hobby\u0026#34;\u0026gt;hobby2 \u0026lt;br\u0026gt; \u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt;def\u0026lt;/a\u0026gt;\u0026lt;br\u0026gt; \u0026lt;div class=\u0026#34;cls\u0026#34;\u0026gt;class\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script src=\u0026#34;./js/10-DOM.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; 在獲取元素後，就可以修改了，修改參考可見 https://www.w3school.com.cn/jsref/index.asp 左側 HTML 物件。\n例如上例修改第一個 a 標籤文字：\n1 2 3 4 // 獲取 var links = document.getElementsByTagName(\u0026#34;a\u0026#34;); // 修改 links[0].innerHTML = \u0026#34;修改值\u0026#34;; 事件監聽 事件是發生在 HTML 元素上的事情，比如按鈕被點擊、滑鼠移動到元素上、按下鍵盤按鍵等。\n而事件監聽則指 JavaScript 可以在事件被偵測到時執行程式碼。\n事件綁定 事件綁定有兩種方式，方式一：透過 HTML 標籤中的事件屬性進行綁定。\n1 2 3 4 5 6 \u0026lt;button id=\u0026#34;btn\u0026#34; onclick=\u0026#34;on()\u0026#34;\u0026gt;按鈕\u0026lt;/button\u0026gt; \u0026lt;script\u0026gt; function on(){ alert(\u0026#34;按鈕被點擊 1\u0026#34;); } \u0026lt;/script\u0026gt; 方式二：透過 DOM 元素屬性綁定。\n1 2 3 document.getElementById(\u0026#34;btn\u0026#34;).onclick=function(){ alert(\u0026#34;按鈕被點擊 2\u0026#34;); } 常見事件 事件名 描述 onclick 滑鼠點擊事件 onblur 元素失去焦點 onfocus 元素獲得焦點 onload 某個頁面或圖像被完成載入 onsubmit 當表單提交時觸發該事件 onkeydown 某個鍵盤的鍵被按下 onmouseover 滑鼠被移到某元素之上 onmouseout 滑鼠從某元素移開 ","date":"2024-01-22T19:51:24+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/148/","title":"JavaScript 學習"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 範例引入 取得員工資料，回傳統一回應結果，並在頁面呈現顯示\n首先需要匯入 dom4j 依賴，用於解析 XML 檔案\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.dom4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;dom4j\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.1.3\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 匯入解析 XML 的工具類別 XMLParserUtils、對應的實體類別 Emp、XML 檔案 emp.xml\n匯入靜態網頁檔案，放在 resources/static\nSpringBoot 專案的靜態資源 (H5 + CSS + JS 等前端資源) 預設存放目錄為 clsspath:/static, classpath:/public, clsspath:/resources\n對應 Maven 來說 classpath 為 src/main/resources\n編寫 Controller 程式，處理請求，回應資料 (此範例程式碼省略，使用下列三層架構)\n三層架構 上例 Emp 程式將資料存取、處理邏輯和接收回應請求放在一個 Controller 裡，使得復用性差、難以維護，為此需要將其分開以滿足單一職責原則，三層架構使得程式碼復用性強、便於維護、有利於擴展\n三層架構分為 Controller、Service 與 Dao\nController：控制層，接收前端送出的請求，對請求進行處理，並回應資料 Service：業務邏輯層，處理具體的業務邏輯 Dao：資料存取層 (Data Access Object) 或持久層，負責資料存取操作，CRUD 瀏覽器發出請求 -\u0026gt; Controller 接收請求、回應資料 -\u0026gt; Service 邏輯處理 -\u0026gt; Dao 資料存取\n上例 Emp 程式碼可以優化成\nController 1 2 3 4 5 6 7 8 9 @RestController public class EmpController { @RequestMapping(\u0026#34;/listEmp\u0026#34;) public Result listEmp(){ EmpService empServiceA = new EmpServiceA(); List\u0026lt;Emp\u0026gt; empList = empServiceA.listEmp(); return Result.success(empList); } } Service 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // interface public interface EmpService { public List\u0026lt;Emp\u0026gt; listEmp(); } public class EmpServiceA implements EmpService { private EmpDao empDao = new EmpDaoA(); public List\u0026lt;Emp\u0026gt; listEmp(){ List\u0026lt;Emp\u0026gt; empList = empDao.listEmp(); empList.forEach(emp -\u0026gt; { String gender = emp.getGender(); if(\u0026#34;1\u0026#34;.equals(gender)){ emp.setGender(\u0026#34;男\u0026#34;); } else if (\u0026#34;2\u0026#34;.equals(gender)) { emp.setGender(\u0026#34;女\u0026#34;); } String job = emp.getJob(); if(\u0026#34;1\u0026#34;.equals(job)){ emp.setJob(\u0026#34;講師\u0026#34;); } else if (\u0026#34;2\u0026#34;.equals(job)) { emp.setJob(\u0026#34;班主任\u0026#34;); } else if (\u0026#34;3\u0026#34;.equals(job)) { emp.setJob(\u0026#34;就業指導\u0026#34;); } }); return empList; } } Dao 1 2 3 4 5 6 7 8 9 10 11 12 // interface public interface EmpDao { public List\u0026lt;Emp\u0026gt; listEmp(); } public class EmpDaoA implements EmpDao { public List\u0026lt;Emp\u0026gt; listEmp(){ String file = this.getClass().getClassLoader().getResource(\u0026#34;emp.xml\u0026#34;).getFile(); List\u0026lt;Emp\u0026gt; empList = XmlParserUtils.parse(file, Emp.class); return empList; } } 分層解耦 內聚：軟體中各個功能模組內部的功能聯繫\n耦合：衡量軟體中各個層/模組之間的依賴、關聯的程度\n軟體設計原則：高內聚低耦合\n具體請見 https://blog.yexca.net/zh-tw/archives/145 例如上例三層架構，Controller 與 Service 耦合，Service 與 Dao 耦合\n在 Controller 中直接建立 Service 物件 EmpService empServiceA = new EmpServiceA(); 使用 A，若變更為 B 則需要修改 Controller，為了更換 Service 而不修改 Controller，可以建立一個容器，使得 Controller 從容器取得物件 (依賴注入) ，Service 把服務注入容器 (控制反轉)\n控制反轉：Inverse Of Control，簡稱 IOC。物件的建立控制權由程式自身轉移到外部 (容器) 依賴注入：Dependency Injection，簡稱 DI。容器為應用程式提供執行時所需的資源 Bean 物件：IOC 容器中建立、管理的物件 IOC 要把某個物件交給 IOC 容器管理，需要在對應類別上加上下列其中一個註解\n註解 說明 位置 @Component 宣告 Bean 的基礎註解 不屬於下列三種類別時使用此註解 (工具類別) @Controller @Component 的衍生註解 標註在控制器類別上 @Service @Component 的衍生註解 標註在業務類別上 @Repository @Component 的衍生註解 標註在資料存取類別上 (MyBatis 整合時，較少用) 宣告 Bean 時，可以透過 value 屬性指定名稱，若無，預設類別名稱首字母小寫 在 SpringBoot 整合網頁開發中，宣告控制器 Bean 只能用 @Controller Bean 元件掃描 上面宣告 Bean 的四個註解，若要生效，還需被元件掃描註解 @ComponentScan 掃描\n此註解實際上已包含在啟動類別宣告註解 @SpringBootApplication 中，預設的掃描範圍是啟動類別所在的套件及其子套件\n透過 value 或 basePackage 屬性指定掃描範圍\n1 @ComponentScan({\u0026#34;dao\u0026#34;,\u0026#34;net.yexca\u0026#34;}) 範例 上例中\nController 由於 @RestController 註解已包含 @Controller，無須修改\nService 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 // interface public interface EmpService { public List\u0026lt;Emp\u0026gt; listEmp(); } // 在實作類別新增 @Service // 將當前類別交給IOC容器管理，成為IOC容器中的Bean public class EmpServiceA implements EmpService { private EmpDao empDao = new EmpDaoA(); public List\u0026lt;Emp\u0026gt; listEmp(){ List\u0026lt;Emp\u0026gt; empList = empDao.listEmp(); empList.forEach(emp -\u0026gt; { String gender = emp.getGender(); if(\u0026#34;1\u0026#34;.equals(gender)){ emp.setGender(\u0026#34;男\u0026#34;); } else if (\u0026#34;2\u0026#34;.equals(gender)) { emp.setGender(\u0026#34;女\u0026#34;); } String job = emp.getJob(); if(\u0026#34;1\u0026#34;.equals(job)){ emp.setJob(\u0026#34;講師\u0026#34;); } else if (\u0026#34;2\u0026#34;.equals(job)) { emp.setJob(\u0026#34;班主任\u0026#34;); } else if (\u0026#34;3\u0026#34;.equals(job)) { emp.setJob(\u0026#34;就業指導\u0026#34;); } }); return empList; } } Dao 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // interface public interface EmpDao { public List\u0026lt;Emp\u0026gt; listEmp(); } // 在實作類別新增 @Repository // 將當前類別交給IOC容器管理，成為IOC容器中的Bean public class EmpDaoA implements EmpDao { public List\u0026lt;Emp\u0026gt; listEmp(){ String file = this.getClass().getClassLoader().getResource(\u0026#34;emp.xml\u0026#34;).getFile(); List\u0026lt;Emp\u0026gt; empList = XmlParserUtils.parse(file, Emp.class); return empList; } } DI 使用 @Autowired 註解可以注入依賴，不過預設是按照型別進行，如果存在多個相同型別的 Bean 會報錯\n將以上範例加上 DI (修改的程式碼將被註解)\nController 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @RestController public class EmpController { @Autowired // 執行時，IOC容器會提供該型別的Bean物件，並指派給該變數 -- 依賴注入 private EmpService empService; @RequestMapping(\u0026#34;/listEmp\u0026#34;) public Result listEmp(){ //EmpService empServiceA = new EmpServiceA(); //List\u0026lt;Emp\u0026gt; empList = empServiceA.listEmp(); List\u0026lt;Emp\u0026gt; empList = empService.listEmp(); return Result.success(empList); } } Service 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 // interface public interface EmpService { public List\u0026lt;Emp\u0026gt; listEmp(); } // 在實作類別新增 @Service // 將當前類別交給IOC容器管理，成為IOC容器中的Bean public class EmpServiceA implements EmpService { @Autowired // 執行時，IOC容器會提供該型別的Bean物件，並指派給該變數 -- 依賴注入 private EmpDao empDao; // private EmpDao empDao = new EmpDaoA(); public List\u0026lt;Emp\u0026gt; listEmp(){ List\u0026lt;Emp\u0026gt; empList = empDao.listEmp(); empList.forEach(emp -\u0026gt; { String gender = emp.getGender(); if(\u0026#34;1\u0026#34;.equals(gender)){ emp.setGender(\u0026#34;男\u0026#34;); } else if (\u0026#34;2\u0026#34;.equals(gender)) { emp.setGender(\u0026#34;女\u0026#34;); } String job = emp.getJob(); if(\u0026#34;1\u0026#34;.equals(job)){ emp.setJob(\u0026#34;講師\u0026#34;); } else if (\u0026#34;2\u0026#34;.equals(job)) { emp.setJob(\u0026#34;班主任\u0026#34;); } else if (\u0026#34;3\u0026#34;.equals(job)) { emp.setJob(\u0026#34;就業指導\u0026#34;); } }); return empList; } } Dao 沒有資料注入，無須修改\n@Primary 若將 Service 新增一個實作類別 EmpServiceB 且也使用了 @Autowired，程式會報錯，可以透過 @Primary 註解指定使用哪一個\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 // interface public interface EmpService { public List\u0026lt;Emp\u0026gt; listEmp(); } // 在實作類別新增 @Service // 將當前類別交給IOC容器管理，成為IOC容器中的Bean public class EmpServiceA implements EmpService { @Autowired // 執行時，IOC容器會提供該型別的Bean物件，並指派給該變數 -- 依賴注入 private EmpDao empDao; // private EmpDao empDao = new EmpDaoA(); public List\u0026lt;Emp\u0026gt; listEmp(){ List\u0026lt;Emp\u0026gt; empList = empDao.listEmp(); empList.forEach(emp -\u0026gt; { String gender = emp.getGender(); if(\u0026#34;1\u0026#34;.equals(gender)){ emp.setGender(\u0026#34;男\u0026#34;); } else if (\u0026#34;2\u0026#34;.equals(gender)) { emp.setGender(\u0026#34;女\u0026#34;); } String job = emp.getJob(); if(\u0026#34;1\u0026#34;.equals(job)){ emp.setJob(\u0026#34;講師\u0026#34;); } else if (\u0026#34;2\u0026#34;.equals(job)) { emp.setJob(\u0026#34;班主任\u0026#34;); } else if (\u0026#34;3\u0026#34;.equals(job)) { emp.setJob(\u0026#34;就業指導\u0026#34;); } }); return empList; } } @Primary // 使用此 Bean @Service // 將當前類別交給IOC容器管理，成為IOC容器中的Bean public class EmpServiceB implements EmpService { @Autowired // 執行時，IOC容器會提供該型別的Bean物件，並指派給該變數 -- 依賴注入 private EmpDao empDao; // private EmpDao empDao = new EmpDaoA(); public List\u0026lt;Emp\u0026gt; listEmp(){ List\u0026lt;Emp\u0026gt; empList = empDao.listEmp(); empList.forEach(emp -\u0026gt; { String gender = emp.getGender(); if(\u0026#34;1\u0026#34;.equals(gender)){ emp.setGender(\u0026#34;男\u0026#34;); } else if (\u0026#34;2\u0026#34;.equals(gender)) { emp.setGender(\u0026#34;女\u0026#34;); } String job = emp.getJob(); if(\u0026#34;1\u0026#34;.equals(job)){ emp.setJob(\u0026#34;講師\u0026#34;); } else if (\u0026#34;2\u0026#34;.equals(job)) { emp.setJob(\u0026#34;班主任\u0026#34;); } else if (\u0026#34;3\u0026#34;.equals(job)) { emp.setJob(\u0026#34;就業指導\u0026#34;); } }); return empList; } } @Qualifier 指定使用哪個 Bean，在 Controller 使用，將上方 @Primary 註解取消\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @RestController public class EmpController { @Qualifier(\u0026#34;empServiceA\u0026#34;) // 使用 Bean empServiceA @Autowired // 執行時，IOC容器會提供該型別的Bean物件，並指派給該變數 -- 依賴注入 private EmpService empService; @RequestMapping(\u0026#34;/listEmp\u0026#34;) public Result listEmp(){ //EmpService empServiceA = new EmpServiceA(); //List\u0026lt;Emp\u0026gt; empList = empServiceA.listEmp(); List\u0026lt;Emp\u0026gt; empList = empService.listEmp(); return Result.success(empList); } } @Resource 與 @Qualifier 類似，不過不使用 @Autowired\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @RestController public class EmpController { // @Qualifier(\u0026#34;empServiceA\u0026#34;) // 使用 Bean empServiceA // @Autowired @Resource(name = \u0026#34;empServiceB\u0026#34;) // 使用 Bean empServiceB private EmpService empService; @RequestMapping(\u0026#34;/listEmp\u0026#34;) public Result listEmp(){ //EmpService empServiceA = new EmpServiceA(); //List\u0026lt;Emp\u0026gt; empList = empServiceA.listEmp(); List\u0026lt;Emp\u0026gt; empList = empService.listEmp(); return Result.success(empList); } } @Autowired 與 @Resource 差異\n@Autowired 是 Spring 框架提供的註解，而 @Resource 是 JDK 提供的註解\n@Autowired 預設是按照型別注入，而 @Resource 預設是按照名稱注入\n","date":"2024-01-19T10:37:15+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/147/","title":"三層架構與分層解耦"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 前言 HTML 學習一 - 基礎: https://blog.yexca.net/zh-tw/archives/146 HTML 學習二 - 清單、表格與表單: https://blog.yexca.net/zh-tw/archives/150 HTML 學習三 - 網頁版面配置: https://blog.yexca.net/zh-tw/archives/195 基本架構 1 2 3 4 5 6 7 8 \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;網頁標題\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; 網頁主體 \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 通常會由軟體生成，舉例來說，在 VS Code 裡可以新建 .html 檔案後輸入英文字元 !，再按 TAB 鍵自動生成。\nhead 標籤通常是給瀏覽器看的，body 標籤則是給使用者看的。\n註解 1 \u0026lt;!-- 註解內容 --\u0026gt; 在 VS Code 中，可以選取該行，使用快捷鍵 Ctrl + / 一鍵註解。\n瀏覽器不會顯示註解的內容。\n標題與段落 1 2 3 4 5 6 7 8 \u0026lt;h1\u0026gt;一級標題\u0026lt;/h1\u0026gt; \u0026lt;h2\u0026gt;二級標題\u0026lt;/h2\u0026gt; \u0026lt;h3\u0026gt;三級標題\u0026lt;/h3\u0026gt; \u0026lt;h4\u0026gt;四級標題\u0026lt;/h4\u0026gt; \u0026lt;h5\u0026gt;五級標題\u0026lt;/h5\u0026gt; \u0026lt;h6\u0026gt;六級標題\u0026lt;/h6\u0026gt; \u0026lt;p\u0026gt;段落內容\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;段落內容\u0026lt;/p\u0026gt; 標題標籤會顯示粗體文字，並獨佔一行。\n段落標籤內容會獨佔一行，段落之間會有空隙。\n換行與水平線 在段落標籤中的內容換行並不會顯示出來，如需換行需使用換行標籤。\n1 \u0026lt;br /\u0026gt; 水平線標籤的程式碼如下：\n1 \u0026lt;hr /\u0026gt; 效果如下：\n文字格式化標籤 結果 標籤名稱 縮寫 粗體 strong b 斜體 em i 底線 ins u 刪除線 del s 一般不建議使用縮寫，範例如下：\n1 2 3 4 \u0026lt;p\u0026gt; 您好，我是 \u0026lt;em\u0026gt;yexca\u0026lt;/em\u0026gt;，\u0026lt;strong\u0026gt;歡迎\u0026lt;/strong\u0026gt;造訪\u0026lt;ins\u0026gt;此部落格\u0026lt;/ins\u0026gt;\u0026lt;br /\u0026gt; \u0026lt;del\u0026gt;然後我該寫些什麼呢？\u0026lt;/del\u0026gt; \u0026lt;/p\u0026gt; 效果如下：\n您好，我是 yexca，歡迎造訪此部落格\n然後我該寫些什麼呢？ 圖片標籤 圖片標籤需要在 src 屬性中指定圖片的位置。\n1 \u0026lt;img src=\u0026#34;path\u0026#34; alt=\u0026#34;圖片無法載入時顯示的內容\u0026#34; /\u0026gt; 路徑分為絕對路徑和相對路徑，假設目前的目錄為 (Linux 系統)：\n1 2 3 /home/yexca/code index.html photo.jpg 程式碼寫在 index.html 檔案中，那麼相對路徑如下：\n1 \u0026lt;img src=\u0026#34;./photo.jpg\u0026#34; /\u0026gt; 絕對路徑如下：\n1 \u0026lt;img src=\u0026#34;/home/yexca/code/photo.jpg\u0026#34; /\u0026gt; 超連結標籤 1 \u0026lt;a href=\u0026#34;目標頁面\u0026#34; target=\u0026#34;方式\u0026#34;\u0026gt;連結文字\u0026lt;/a\u0026gt; 這個標籤用於跳轉網頁，也就是網頁中的連結。如果需要在新視窗開啟網頁，只需將 target 屬性值設為 _blank，例如以下程式碼：\n1 2 3 4 5 \u0026lt;p\u0026gt; 跳轉到 \u0026lt;a href=\u0026#34;https://yexca.net\u0026#34;\u0026gt;yexca\u0026lt;/a\u0026gt;\u0026lt;br /\u0026gt; 這是新的分頁：\u0026lt;a href=\u0026#34;https://yexca.net\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt;yexca\u0026lt;/a\u0026gt; \u0026lt;/p\u0026gt; 效果如下：\n跳轉到 yexca\n這是新的分頁：yexca 影音標籤 1 2 \u0026lt;audio src=\u0026#34;path\u0026#34;\u0026gt;音訊標籤\u0026lt;/audio\u0026gt; \u0026lt;video src=\u0026#34;path\u0026#34;\u0026gt;視訊標籤\u0026lt;/video\u0026gt; 音訊標籤屬性如下：\n屬性 作用 說明 src 音訊路徑 必要屬性，支援 mp3、ogg、wav controls 顯示音訊控制面板 loop 循環播放 autoplay 自動播放 瀏覽器通常會禁止自動播放 視訊標籤屬性如下：\n屬性 作用 說明 src 視訊路徑 必要屬性，支援 mp4、webm、ogg controls 顯示視訊控制面板 loop 循環播放 muted 靜音播放 autoplay 自動播放 瀏覽器支援在靜音狀態下自動播放 假設目前的目錄如下：\n1 2 3 4 /home/yexca/code index.html audio.mp3 video.mp4 例如以下程式碼：\n1 2 3 4 5 6 7 8 \u0026lt;audio src=\u0026#34;./audio.mp3\u0026#34; controls loop\u0026gt;\u0026lt;/audio\u0026gt; \u0026lt;!-- 顯示控制面板，播放完畢後會循環回到開頭播放 --\u0026gt; \u0026lt;video src=\u0026#34;./video.mp4\u0026#34; controls loop\u0026gt;\u0026lt;/video\u0026gt; \u0026lt;!-- 顯示控制面板，播放完畢後會循環回到開頭播放 --\u0026gt; \u0026lt;video src=\u0026#34;./video.mp4\u0026#34; controls muted autoplay\u0026gt;\u0026lt;/video\u0026gt; \u0026lt;!-- 這段程式碼會自動播放 --\u0026gt; \u0026lt;video src=\u0026#34;./video.mp4\u0026#34; controls autoplay\u0026gt;\u0026lt;/video\u0026gt; \u0026lt;!-- 這段程式碼不會自動播放 --\u0026gt; 版面配置標籤 沒有實質意義，用於網頁版面配置的標籤，用來劃分區域或擺放內容。\ndiv: 獨佔一行 span: 不換行 例如以下程式碼：\n1 2 3 4 5 6 7 8 \u0026lt;div\u0026gt; div1 \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; div2 \u0026lt;/div\u0026gt; \u0026lt;span\u0026gt;span1\u0026lt;/span\u0026gt; \u0026lt;span\u0026gt;span2\u0026lt;/span\u0026gt; 效果如下：\ndiv1 div2 span1 span2 字元轉換 用於在網頁中顯示預留字元。例如顯示空白、\u0026lt;、\u0026gt;。\n結果 描述 Entity Name Entity Number non-breaking space \u0026amp;nbsp; \u0026amp;#160; \u0026lt; less than \u0026amp;lt; \u0026amp;#60; \u0026gt; greater than \u0026amp;gt; \u0026amp;#62; \u0026amp; ampersand \u0026amp;amp; \u0026amp;#38; “ double quotation mark \u0026amp;quot; \u0026amp;#34; ‘ single quotation mark (apostrophe) \u0026amp;apos; \u0026amp;#39; ¢ cent \u0026amp;cent; \u0026amp;#162; £ pound \u0026amp;pound; \u0026amp;#163; ¥ yen \u0026amp;yen; \u0026amp;#165; € euro \u0026amp;euro; \u0026amp;#8364; © copyright \u0026amp;copy; \u0026amp;#169; ® registered trademark \u0026amp;reg; \u0026amp;#174; 例如顯示 \u0026lt;p\u0026gt;：\n1 2 3 \u0026lt;p\u0026gt; \u0026amp;lt;p\u0026amp;gt; \u0026lt;/p\u0026gt; 參考來源： HTML字元符號 \u0026amp;Nbsp; \u0026amp;Ensp; \u0026amp;Emsp; 的差異 ","date":"2024-01-18T14:43:34+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/146/","title":"HTML 學習一 - 基礎"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 系統設計的基本原理 抽象、模組化、資訊隱蔽、模組獨立\n模組化 在軟體的體系結構中，模組是可組合、分解和更換的單元\n模組化是指將一個待開發的軟體分解成若干個小而簡單的部分，即模組。每個模組可獨立地開發、測試，最後組裝成完整的程式。這是一種複雜問題「分而治之」的原則。模組化的目的是使程式的結構清晰，容易閱讀、理解、測試和修改\n模組獨立 模組獨立是指每個模組完成一個相對獨立的特定子功能，並且與其他模組之間的聯繫簡單。衡量模組獨立程度的標準有兩個：耦合性與內聚性\n耦合 耦合是模組之間的相對獨立性 (互相連接的緊密程度) 的度量。耦合取決於各個模組之間介面的複雜程度、呼叫模組的方式以及透過介面的資訊類型等。一般模組之間可能的耦合方式有 7 種類型\n無直接耦合。指兩個模組之間沒有直接關係，它們分別從屬於不同模組的控制與呼叫，它們之間不傳遞任何資訊 資料耦合。指兩個模組之間有呼叫關係，傳遞的是簡單的資料值，相當於高階語言中的值傳遞 標記耦合。指兩個模組之間傳遞的是資料結構 控制耦合。指一個模組呼叫另一個模組，傳遞的是控制變數，被呼叫模組透過控制該控制變數的值有選擇地執行模組內部的某一功能 外部耦合。模組之間透過軟體之外的環境連結 (如 I/O 將模組耦合到特定的裝置、格式、通訊協定上) 時稱為外部耦合 共同耦合。指透過一個共同資料環境相互作用的那些模組間的耦合 內容耦合。當一個模組直接使用另一個模組的內部資料，或透過非正常入口轉入另一個模組內部時，這種模組之間的耦合稱為內容耦合 內聚 內聚是對一個模組內部各個元素彼此結合的緊密程度的度量。一個內聚程度高的模組 (在理想情況下) 應當只做一件事。一般模組的內聚性分為 7 種類型\n偶然內聚 (巧合內聚) 。指一個模組內的各處理元素之間沒有任何聯繫 邏輯內聚。指模組內執行若干個邏輯上相似的功能，透過參數確定該模組完成哪一個功能 時間內聚。把需要同時執行的動作組合在一起形成的模組稱為時間內聚模組 程序內聚。指一個模組完成多個任務，這些任務必須按指定的程序執行 通訊內聚。指模組內的所有處理元素都在同一個資料結構上操作，或者各處理使用相同的輸入資料或者產生相同的輸出資料 順序內聚。指一個模組中的各個處理元素都密切相關於同一功能且必須順序執行，前一功能元素的輸出就是下一功能元素的輸入 功能內聚。這是最強的內聚，指模組內的所有元素共同作用完成一個功能，缺一不可 耦合性與內聚性是模組獨立性的兩個定性標準，在將軟體系統劃分模組時，應盡量做到高內聚、低耦合，提升模組的獨立性\n系統結構設計原則 為確保整體結構設計順利完成，應遵循以下幾條原則\n分解-協調原則。整個系統是一個整體，具有整體目的與功能，但這些目的與功能的實現又是由相互聯繫的各個組成部分共同工作的結果。解決複雜問題的一個很重要的原則就是將其分解成多個小問題分別處理，在處理過程中根據系統總體要求協調各部門的關係 由上而下的原則。首先抓住系統總體的功能目的，然後逐層分解，即先確定上層模組的功能，再確定下層模組的功能 資訊隱蔽、抽象的原則。上層模組只規定下層模組要做什麼和所屬模組之間的協調關係，但不規定如何做，以確保各模組的相對獨立性與內部結構的合理性，使得模組與模組之間層次分明，易於理解、實施和維護 一致性原則。要確保整個軟體設計過程中具有統一的規範、統一的標準和統一的文件模式等 明確性原則。每個模組必須功能明確、介面正確，消除多重功能和無用介面 模組之間的耦合盡可能小，模組的內聚度盡可能高 模組的扇入係數與扇出係數要合理。一個模組直接呼叫其他模組的個數稱為模組的扇出係數；反之，一個模組被其他模組呼叫時，直接呼叫它的模組個數稱為模組的扇入係數。模組的扇入、扇出係數必須適當。經驗表明，一個設計得好的系統的平均扇入、扇出係數通常是 3 或 4，一般不應超過 7，否則會導致錯誤機率的增大。但選單呼叫型模組的扇入與扇出係數可以大一些，共用模組的扇入係數可以大一些 模組的規模適當。過大的模組常常使系統分解得不充分，其內部可能包含了若干部分的功能，因此有必要進一步將原有的模組分解成若干功能盡可能單一的模組。但分解也必須適度，因為過小的模組有可能降低模組的獨立性，造成系統介面的複雜性 模組的作用範圍應該在其控制範圍之內 系統文件 資訊系統的文件是系統建置過程的「軌跡」，是系統維護人員的指南，是開發人員與使用者交流的工具。規範的文件意味著系統是按照工程化開發的，意味著資訊系統的品質有了形式上的保障。文件的欠缺、文件的隨意性與文件的不規範，極有可能導致原來的開發人員流動之後，系統無法維護、無法升級，變成一個沒有擴充性、沒有生命力的系統\n對於文件在系統開發人員、專案管理人員、系統維護人員、系統評估人員以及使用者之間的各種作用總結如下\n使用者與系統分析人員在系統規劃與系統分析階段透過文件進行溝通。這裡的文件主要包括可行性研究報告、總體規劃報告、系統開發合約與系統方案說明書 系統開發人員與專案管理人員透過文件在專案期內進行溝通。這裡的文件主要有系統開發計畫 (包括工作任務分解表、PERT 圖、甘特圖和預算分配表等) 、系統開發月報以及系統開發總結報告等專案管理文件 系統測試人員與系統開發人員透過文件進行溝通。系統測試人員可以根據系統方案說明書、系統開發合約、系統設計說明書和測試計畫等文件對系統開發人員所開發的系統進行測試。系統測試人員再將評估結果撰寫成系統測試報告 系統開發人員與使用者在系統運行期間進行溝通。使用者透過系統開發人員撰寫的文件運行系統。這裡的文件主要是使用者手冊與操作指南 系統開發人員與系統維護人員透過文件進行溝通。這裡的文件主要有系統設計說明書與系統開發總結報告 使用者與維修人員在運行維護期間進行溝通。使用者在使用資訊系統的過程中，將運行過程中的問題進行記載，形成系統運行報告與維護修改建議。系統維護人員根據維護修改建議以及系統開發人員留下的技術手冊等文件對系統進行維護與升級 ","date":"2024-01-16T08:10:10+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/145/","title":"結構化開發"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 瀏覽器發送請求會先經過 DispatcherServlet 轉交給各 *Controller 程式處理，處理完成後將結果返回給 DispatcherServlet，然後再回傳給瀏覽器。\nDispatcherServlet 被稱為核心控制器或前端控制器。\n對於瀏覽器請求的資料，會被封裝到 HttpServletRequest 物件中；回應資料則會被封裝到 HttpServletResponse 物件中。\n*Controller 接收請求，設定回應\n請求 簡單參數 首先是原始方式，透過 HttpServletRequest 物件手動取得請求參數。\n1 2 3 4 5 6 7 8 9 @RequestMapping(\u0026#34;/simpleParam\u0026#34;) public String simpleParam(HttpServletRequest request){ String name = request.getParameter(\u0026#34;name\u0026#34;); String ageStr = request.getParameter(\u0026#34;age\u0026#34;); int age = Integer.parseInt(ageStr); System.out.println(name + \u0026#34;;\u0026#34; + age); return \u0026#34;OK\u0026#34;; } 當瀏覽器存取 http://localhost:8080/simpleParam?name=tom\u0026age=18 網頁時會回傳字串 “OK”，程式則會回傳 “Tom;18”。\n顯然這種方式過於麻煩，在 SpringBoot 中可以透過參數名稱與方法參數名稱相同的方式，直接定義方法參數即可接收。\n1 2 3 4 5 @RequestMapping(\u0026#34;/simpleParam\u0026#34;) public String simpleParam(String name, Integer age){ System.out.println(name + \u0026#34;;\u0026#34; + age); return \u0026#34;OK\u0026#34;; } 效果相同。\n不過上述方法即使請求的參數名稱不同也會繼續執行，未提供的參數會是 null。\n可以使用 @RequestParam 完成映射，實現請求名稱與方法參數名稱不同時的對應。\n1 2 3 4 5 6 7 @RequestMapping(\u0026#34;/simpleParam\u0026#34;) public String simpleParam(@RequestParam(name = \u0026#34;name\u0026#34;) String username, Integer age){ // 當宣告 @RequestParam 後，代表該參數必須被傳遞，否則會報錯。 // 若更改為 @RequestParam(name = \u0026#34;name\u0026#34;, required = false) 代表該參數並非必要。 System.out.println(username + \u0026#34;;\u0026#34; + age); return \u0026#34;OK\u0026#34;; } 實體參數 如果只是少量參數，使用上述方法可行；但若是較多的資料，可以透過簡單實體物件來處理，只要請求參數名稱與方法參數物件的屬性名稱相同，定義 POJO 即可接收。\n1 2 3 4 5 6 7 8 9 10 11 12 @RequestMapping(\u0026#34;/simplePojo\u0026#34;) public String simplePojo(User user){ System.out.println(user); return \u0026#34;OK\u0026#34;; } // User類 public class User{ private String name; private Integer age; // set get toString 方法 } 存取 http://localhost:8080/simplePojo?name=tom\u0026age=18 網頁時會回傳字串 “OK”，程式則會回傳 “User{name=\u0026lsquo;tom\u0026rsquo;, age=18}”。\n複雜實體物件：請求參數名稱與方法參數屬性名稱相同，依照物件的階層結構關係即可接收巢狀 POJO 屬性參數。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 @RequestMapping(\u0026#34;/complexPojo\u0026#34;) public String complexPojo(UserComplex user){ System.out.println(user); return \u0026#34;OK\u0026#34;; } // User類 public class UserComplex{ private String name; private Integer age; private Address address; // set get toString } // Address類 public class Address{ private String province; private String city; // set get toString } 存取 http://localhost:8080/complexPojo?name=tom\u0026age=18\u0026address.province=beijing\u0026address.city=beijing 網頁時會回傳字串 “OK”，程式則會回傳 “UserComplex{name=\u0026lsquo;tom\u0026rsquo;, age=1000, address=Address{province=\u0026lsquo;ads,beijing\u0026rsquo;, city=\u0026lsquo;asda,beijing\u0026rsquo;}}”。\n陣列參數 請求參數名稱與方法參數陣列名稱相同且請求參數有多個時，定義陣列型別的方法參數即可接收。例如多選框。\n1 2 3 4 5 @RequestMapping(\u0026#34;/arrayParam\u0026#34;) public String arrayParam(String[] hobby){ System.out.println(Arrays.toString(hobby)); return \u0026#34;OK\u0026#34;; } 存取 http://localhost:8080/arrayParam?hobby=ads\u0026hobby=58s 網頁時會回傳字串 “OK”，程式則會回傳 “[ads, 58s]”。\n集合參數 請求參數名稱與方法參數陣列名稱相同且請求參數有多個時，使用 @RequestParam 繫結參數關係。\n1 2 3 4 5 @RequestMapping(\u0026#34;/listParam\u0026#34;) public String listParam(@RequestParam List\u0026lt;String\u0026gt; hobby){ System.out.println(hobby); return \u0026#34;OK\u0026#34;; } 存取 http://localhost:8080/listParam?hobby=ads\u0026hobby=58s 網頁時會回傳字串 “OK”，程式則會回傳 “[ads, 58s]”。\n日期參數 使用 @DateTimeFormat 註解來完成日期參數的格式轉換。\n需要注意的是傳遞參數有三種形式：\nyyyy-MM-dd HH:mm:ss yyyy/MM/dd HH:mm:ss yyyy年MM月dd日 HH時mm分ss秒 需要前後端統一格式才行。\n1 2 3 4 5 @RequestMapping(\u0026#34;/dateParam\u0026#34;) public String dateParam(@DateTimeFormat(pattern = \u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;) LocalDateTime localDateTime){ System.out.println(localDateTime); return \u0026#34;OK\u0026#34;; } 存取 http://localhost:8080/dateParam?localDateTime=2024-01-01%2001:01:01 網頁時會回傳字串 “OK”，程式則會回傳 \u0026ldquo;2024-01-01T01:01:01\u0026rdquo;。\nJSON 參數 JSON 資料的鍵名與方法參數物件的屬性名稱相同，定義 POJO 型別的方法參數即可接收參數，需要使用 @RequestBody 標示。\n若要傳輸 JSON 資料，必須使用 POST 請求。\n1 2 3 4 5 @RequestMapping(\u0026#34;/jsonParam\u0026#34;) public String jsonParam(@RequestBody UserComplex userComplex){ System.out.println(userComplex); return \u0026#34;OK\u0026#34;; } 請求資料\n1 2 3 4 5 6 7 8 { \u0026#34;name\u0026#34;: \u0026#34;jane\u0026#34;, \u0026#34;age\u0026#34;: \u0026#34;18\u0026#34;, \u0026#34;address\u0026#34;: { \u0026#34;province\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;上海\u0026#34; } } 使用 POST 方法請求 http://localhost:8080/jsonParam ，資料如上，網頁會回傳字串 “OK”，程式則會回傳 \u0026ldquo;UserComplex{name=\u0026lsquo;jane\u0026rsquo;, age=18, address=Address{province=\u0026lsquo;上海\u0026rsquo;, city=\u0026lsquo;上海\u0026rsquo;}}\u0026quot;。\n路徑參數 透過請求 URL 直接傳遞參數，使用 {...} 來標示該路徑參數，需要使用 @PathVariable 取得路徑參數。\n1 2 3 4 5 @RequestMapping(\u0026#34;/path/{id}\u0026#34;) public String pathParam(@PathVariable Integer id){ System.out.println(id); return \u0026#34;OK\u0026#34;; } 存取 http://localhost:8080/path/52 網頁時會回傳字串 “OK”，程式則會回傳 \u0026ldquo;52\u0026rdquo;。\n存取 http://localhost:8080/path/255 網頁時會回傳字串 “OK”，程式則會回傳 \u0026ldquo;255\u0026rdquo;。\n對於多個路徑參數：\n1 2 3 4 5 @RequestMapping(\u0026#34;/path/{id}/{name}\u0026#34;) public String pathParam(@PathVariable Integer id, @PathVariable String name){ System.out.println(id + \u0026#34;;\u0026#34; + name); return \u0026#34;OK\u0026#34;; } 存取 http://localhost:8080/path/255/Tom 網頁時會回傳字串 “OK”，程式則會回傳 \u0026ldquo;255;Tom\u0026rdquo;。\n總結 簡單參數 定義方法參數，請求參數名稱與方法參數變數名稱一致。 如果名稱不一致，透過 @RequestParam 手動映射。 實體參數 請求參數名稱與實體物件的屬性名稱一致，會自動接收並封裝。 陣列集合參數 陣列：請求參數名稱與陣列名稱一致，直接封裝。 集合：請求參數名稱與陣列名稱一致，使用 @RequestParam 繫結關係。 日期參數 @DateTimeFormat JSON 參數 @RequestBody 路徑參數 @PathVariable 回應 使用 @RequestBody 處理回應\n上述請求之所以能夠回應，是因為註解 @RestController 包含 @Controller 和 @ResponseBody。\n@RequestBody 型別：方法註解、類別註解\n位置：Controller 方法上或類別上\n作用：將方法的返回值直接回應，若返回值型別為 實體物件或集合，將會轉換為 JSON 格式回應。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 @RestController public class ResponseController { @RequestMapping(\u0026#34;/hello\u0026#34;) public String hello(){ System.out.println(\u0026#34;Hello SpringBoot\u0026#34;); return \u0026#34;Hello SpringBoot\u0026#34;; } @RequestMapping(\u0026#34;/getAddr\u0026#34;) public Address getAddr(){ Address address = new Address(); address.setProvince(\u0026#34;上海\u0026#34;); address.setCity(\u0026#34;上海\u0026#34;); return address; } @RequestMapping(\u0026#34;/listAddr\u0026#34;) public List\u0026lt;Address\u0026gt; listAddr(){ List\u0026lt;Address\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); Address address1 = new Address(); address1.setProvince(\u0026#34;北京\u0026#34;); address1.setCity(\u0026#34;北京\u0026#34;); Address address2 = new Address(); address2.setProvince(\u0026#34;上海\u0026#34;); address2.setCity(\u0026#34;上海\u0026#34;); list.add(address1); list.add(address2); return list; } } 存取相關網址進行測試。\n統一回應結果 以上三個方法的回傳型別都不一樣，使得前端開發較為困難，因此可以統一回應結果為一個類別。\n1 2 3 4 5 6 7 8 9 public class Result{ // 回應碼，1 代表成功，0 代表失敗 private Integer code; // 提示訊息 private String msg; // 回傳的資料 private Object data; // ... } 讓所有的回應方法都回傳一個 Result 物件，使專案管理與維護更為容易。\n例如以下類別：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 public class Result { private Integer code ;//1 成功 , 0 失敗 private String msg; //提示訊息 private Object data; //資料 data public Result() { } public Result(Integer code, String msg, Object data) { this.code = code; this.msg = msg; this.data = data; } public Integer getCode() { return code; } public void setCode(Integer code) { this.code = code; } public String getMsg() { return msg; } public void setMsg(String msg) { this.msg = msg; } public Object getData() { return data; } public void setData(Object data) { this.data = data; } public static Result success(Object data){ return new Result(1, \u0026#34;success\u0026#34;, data); } public static Result success(){ return new Result(1, \u0026#34;success\u0026#34;, null); } public static Result error(String msg){ return new Result(0, msg, null); } @Override public String toString() { return \u0026#34;Result{\u0026#34; + \u0026#34;code=\u0026#34; + code + \u0026#34;, msg=\u0026#39;\u0026#34; + msg + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, data=\u0026#34; + data + \u0026#39;}\u0026#39;; } } 那麼上面程式碼可以改為：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 @RequestMapping(\u0026#34;/hello\u0026#34;) public Result hello(){ System.out.println(\u0026#34;Hello SpringBoot\u0026#34;); return Result.success(\u0026#34;Hello SpringBoot\u0026#34;); } @RequestMapping(\u0026#34;/getAddr\u0026#34;) public Result getAddr(){ Address address = new Address(); address.setProvince(\u0026#34;上海\u0026#34;); address.setCity(\u0026#34;上海\u0026#34;); return Result.success(address); } @RequestMapping(\u0026#34;/listAddr\u0026#34;) public Result listAddr(){ List\u0026lt;Address\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); Address address1 = new Address(); address1.setProvince(\u0026#34;北京\u0026#34;); address1.setCity(\u0026#34;北京\u0026#34;); Address address2 = new Address(); address2.setProvince(\u0026#34;上海\u0026#34;); address2.setCity(\u0026#34;上海\u0026#34;); list.add(address1); list.add(address2); return Result.success(list); } 存取相關網址進行測試。\n","date":"2024-01-14T16:47:28+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/144/","title":"Spring 請求與回應"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 Maven 是一款用於管理和建置 Java 專案的工具\nMaven 可以方便快捷地管理專案相依的資源 (Jar 檔)，避免版本衝突問題；提供標準、統一的專案結構；標準跨平台的自動化專案建置方式\n安裝 在 官網 下載後解壓，然後設定本地存放庫，修改 conf/setting.xml 中的 \u0026lt;localRepository\u0026gt; 為一個指定目錄\n1 2 \u0026lt;!-- 例如本地庫在 D:\\develop\\maven_repo --\u0026gt; \u0026lt;localRepository\u0026gt;D:\\develop\\maven_repo\u0026lt;/localRepository\u0026gt; 設定阿里雲私服鏡像，修改 conf/setting.xml 中的 \u0026lt;mirror\u0026gt; 標籤，新增子標籤\n1 2 3 4 5 6 \u0026lt;mirror\u0026gt; \u0026lt;id\u0026gt;alimaven\u0026lt;/id\u0026gt; \u0026lt;name\u0026gt;aliyun maven\u0026lt;/name\u0026gt; \u0026lt;url\u0026gt;http://maven.aliyun.com/nexus/content/groups/public/\u0026lt;/url\u0026gt; \u0026lt;mirrorOf\u0026gt;central\u0026lt;/mirrorOf\u0026gt; \u0026lt;/mirror\u0026gt; 設定環境變數：MAVEN_HOME 為 Maven 解壓目錄，並將其 bin 目錄加入 PATH 環境變數\n測試安裝完成：在命令列輸入 mvn -v 查看輸出\n相依性配置 相依性 (Dependency)：指當前專案執行所需要的 Jar 檔，一個專案中可以引入多個相依性\n設定步驟：\n在 pom.xml 中編寫 \u0026lt;dependencies\u0026gt; 標籤 在 \u0026lt;dependencies\u0026gt; 標籤中使用 \u0026lt;dependency\u0026gt; 引入座標 定義座標的 groupId, artifactId, version 重新整理配置，引入新加入的座標 1 2 3 4 5 6 7 8 \u0026lt;!-- 例如引入 logback --\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;ch.qos.logback\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;logback-classic\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.3\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 可以到 https://mvnrepository.com/ 查找相依性座標資訊\n相依性傳遞 相依性具有傳遞性\n直接相依：在當前專案中透過相依性配置建立的相依關係 間接相依：被相依的資源如果相依於其他資源，則當前專案間接相依於其他資源 當新增相依性時，若此套件相依於其他套件，將自動新增相關套件\n當然，若某個套件的子套件並不需要，可以排除相依 (指主動斷開相依的資源，被排除的資源無需指定版本)\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;!-- 例如排除某專案的 junit --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.yexca\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-project\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;exclusions\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;groupId\u0026gt;junit\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit\u0026lt;/artifactId\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;/exclusions\u0026gt; \u0026lt;/dependency\u0026gt; 相依性範圍 相依的 Jar 檔，預設可以在任何地方使用，可以透過 \u0026lt;scope\u0026gt;...\u0026lt;/scope\u0026gt; 設定其作用範圍：\n主程式範圍有效 (main 資料夾範圍內) 測試程式範圍有效 (test 資料夾範圍內) 是否參與打包執行 (package 指令範圍內) scope 值 主程式 測試程式 打包 (執行) 範例 compile (預設) Y Y Y log4j test - Y - junit provided Y Y - servlet-api runtime - Y Y JDBC 驅動 1 2 3 4 5 6 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;junit\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.10\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; 生命周期 Maven 的生命週期是為了對所有的 Maven 專案建置過程進行抽象和統一\nMaven 中有 3 套相互獨立的生命週期：\nclean：清理工作 default：核心工作，如：編譯、測試、打包、安裝、部署等 site：生成報告、發布站台等 其中每套生命週期包含一些階段 (phase)，階段是有順序的，後面的階段相依於前面的階段\nclean pre-clean clean：移除上一次建置產生的檔案 (target 資料夾) post-clean default validate initialize generate-sources process-sources generate-resources process-resources compile：編譯專案原始碼 process-classes generate-test-sources process-test-sources generate-test-resources process-test-resources test-compile process-test-classes test：使用合適的單元測試框架執行測試 (JUnit) prepare-package package：將編譯後的檔案打包，如 Jar、War 等 verify install：安裝專案到本地存放庫 deploy site pre-site site post-site site-deploy 在同一套生命週期中，當執行後面的階段時，前面的階段都會執行\n分模組設計 分模組設計是在進行專案設計階段時，就可以將一個大型專案拆分成若干個模組，每一個模組都是獨立的，如果我們需要用到另外一個模組的功能，直接引用該模組的相依性即可\n可以把一些通用的實體類別或工具類別單獨作為一個模組，若某一模組需要使用，直接引入對應的相依性即可\n方便專案的管理維護、擴充，也方便模組間的相互呼叫與資源共享\n繼承 像 Lombok 相依性，可能專案中的每個模組都會使用，每個模組都宣告一次相當繁瑣，可以透過繼承解決這個問題\n繼承關係 建立一個父工程，將模組共有的相依性都提取到父工程進行配置，只要子類別繼承了父工程，相依性也會繼承下來，這樣就無需在各個子工程中進行配置了\n繼承描述的是兩個工程間的關係，與 Java 中的繼承相似，子工程可以繼承父工程中的配置資訊，常見於相依關係的繼承，可以簡化相依性配置、統一管理相依性\n1 2 3 4 5 6 7 \u0026lt;!--指定父工程--\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;...\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;...\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;...\u0026lt;/version\u0026gt; \u0026lt;relativePath\u0026gt;....\u0026lt;/relativePath\u0026gt; \u0026lt;/parent\u0026gt; 如果是 JavaWeb 開發，可以讓父工程繼承 spring-boot-starter-parent，其他模組繼承該父工程\n一般情況下，在檔案結構中，子工程為父工程的子目錄\n以下為例子\n父工程的打包方式為 pom 1 2 3 4 5 6 7 8 9 10 11 \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.7.5\u0026lt;/version\u0026gt; \u0026lt;relativePath/\u0026gt; \u0026lt;!-- lookup parent from repository --\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;groupId\u0026gt;net.yexca\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;tlias-parent\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;packaging\u0026gt;pom\u0026lt;/packaging\u0026gt; Maven 打包方式：\njar：普通模組打包，SpringBoot 專案基本都是 Jar 檔 (內建 Tomcat 執行) war：普通 Web 程式打包，需要部署在外部的 Tomcat 伺服器中執行 pom：父工程或聚合工程，該模組不寫程式碼，僅進行相依性管理 子工程指定父工程 1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;net.yexca\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;tlias-parent\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;!-- 指定父工程的 pom 檔案的相對位置 (如果不指定，將從本地存放庫/遠端存放庫查找該工程) --\u0026gt; \u0026lt;relativePath\u0026gt;../tlias-parent/pom.xml\u0026lt;/relativePath\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;!-- \u0026lt;groupId\u0026gt;net.yexca\u0026lt;/groupId\u0026gt; -\t因為自動繼承父工程，可以省略 --\u0026gt; \u0026lt;artifactId\u0026gt;tlias-utils\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; 父工程中配置共有相依性 1 2 3 4 5 6 7 \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.18.24\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 版本鎖定 某些相依性部分模組需要，部分模組不需要，可以在父級中管理相依性的 version，方便管理與修改\n可以透過 \u0026lt;dependencyManagement\u0026gt; 標籤管理相依性版本\n父工程\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;!--統一管理相依性版本--\u0026gt; \u0026lt;dependencyManagement\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!--JWT權杖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.jsonwebtoken\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jjwt\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.9.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/dependencyManagement\u0026gt; 子工程\n1 2 3 4 5 6 7 8 9 10 \u0026lt;dependencies\u0026gt; \u0026lt;!--JWT權杖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.jsonwebtoken\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jjwt\u0026lt;/artifactId\u0026gt; \u0026lt;!-- \u0026lt;version\u0026gt;0.9.1\u0026lt;/version\u0026gt; - 因為父工程指定了版本，不需要填寫 --\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 父工程的 \u0026lt;dependencyManagement\u0026gt; 配置只管理版本，不會將相依性引入子工程。只有在子工程引入後才會生效，只是引入時無需指定版本號\n而 \u0026lt;dependencies\u0026gt; 會把相依性直接引入所有子工程\n屬性設定 也可以透過自定義屬性及屬性引用的形式，在父工程中將相依性的版本號進行集中管理維護\n自定義屬性：\n1 2 3 \u0026lt;properties\u0026gt; \u0026lt;lombok.version\u0026gt;1.18.24\u0026lt;/lombok.version\u0026gt; \u0026lt;/properties\u0026gt; 引用屬性：\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${lombok.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 於是可以在父工程中將所有的版本號，集中管理維護\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 \u0026lt;properties\u0026gt; \u0026lt;maven.compiler.source\u0026gt;11\u0026lt;/maven.compiler.source\u0026gt; \u0026lt;maven.compiler.target\u0026gt;11\u0026lt;/maven.compiler.target\u0026gt; \u0026lt;lombok.version\u0026gt;1.18.24\u0026lt;/lombok.version\u0026gt; \u0026lt;jjwt.version\u0026gt;0.9.1\u0026lt;/jjwt.version\u0026gt; \u0026lt;aliyun.oss.version\u0026gt;3.15.1\u0026lt;/aliyun.oss.version\u0026gt; \u0026lt;jaxb.version\u0026gt;2.3.1\u0026lt;/jaxb.version\u0026gt; \u0026lt;activation.version\u0026gt;1.1.1\u0026lt;/activation.version\u0026gt; \u0026lt;jaxb.runtime.version\u0026gt;2.3.3\u0026lt;/jaxb.runtime.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${lombok.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;!--統一管理相依性版本--\u0026gt; \u0026lt;dependencyManagement\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!--JWT權杖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.jsonwebtoken\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jjwt\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${jjwt.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--阿里雲OSS--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.aliyun.oss\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;aliyun-sdk-oss\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${aliyun.oss.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.xml.bind\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jaxb-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${jaxb.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.activation\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;activation\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${activation.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- no more than 2.3.3--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.glassfish.jaxb\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jaxb-runtime\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${jaxb.runtime.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/dependencyManagement\u0026gt; 若想要修改相依性的版本，只需要在父工程的自定義屬性中，修改相應屬性值即可\n聚合 若一個模組相依於另一個模組，打包該模組前需要先將其他模組 install 到本地存放庫，然後再打包。如果相依的模組很多，那麼需要執行的操作會過於繁瑣\n透過 Maven 的聚合就可以輕鬆實現專案的一鍵建置 (清理、編譯、測試、打包、安裝等)\n**聚合：**將多個模組組織成一個整體，同時進行專案的建置 **聚合工程：**一個不具有業務功能的「空」工程 (有且僅有一個 pom 檔案。一般來說，繼承關係中的父工程與聚合關係中的聚合工程是同一個) **作用：**快速建置專案 (無需根據相依關係手動建置，直接在聚合工程上建置即可) 可以在聚合工程中透過 \u0026lt;modules\u0026gt; 設定當前聚合工程所包含的子模組名稱\n1 2 3 4 5 6 7 \u0026lt;!--聚合其他模組--\u0026gt; \u0026lt;modules\u0026gt; \u0026lt;!-- 工程路徑 --\u0026gt; \u0026lt;module\u0026gt;../tlias-pojo\u0026lt;/module\u0026gt; \u0026lt;module\u0026gt;../tlias-utils\u0026lt;/module\u0026gt; \u0026lt;module\u0026gt;../tlias-web-management\u0026lt;/module\u0026gt; \u0026lt;/modules\u0026gt; 之後進行編譯、打包、安裝操作只需在聚合工程上進行即可，其他工程會自動同步操作\n繼承 聚合 作用 繼承用於簡化相依性配置、統一管理相依性 聚合用於快速建置專案 相同點 打包方式均為 pom，通常製作在同一個 pom 均屬於設計型模組，無實際內容 不同點 繼承是在子模組中配置關係\n父模組無法感知哪些子模組繼承了自己 聚合是在聚合工程中配置關係\n聚合可以感知到參與聚合的模組有哪些 私服 私服是一種特殊的遠端存放庫，它是架設在區域網路內的存放庫服務，用來代理位於外部的中央存放庫，用於解決團隊內部的資源共享與資源同步問題\n如果在專案中需要使用其他第三方提供的相依性，如果本地存放庫沒有，會自動連接私服下載，如果私服也沒有，私服此時會自動連接中央存放庫，去中央存放庫中下載相依性，然後將下載的相依性儲存在私服存放庫及本地存放庫中\n私服一般一個公司一台，不用自己配置\n私服存放庫與專案版本 私服存放庫說明：\nRELEASE：儲存自己開發的 RELEASE 發布版本的資源 SNAPSHOT：儲存自己開發的 SNAPSHOT 發布版本的資源 Central：儲存的是從中央存放庫下載下來的相依性 專案版本說明：\nRELEASE (發布版本)：功能趨於穩定、當前更新停止，可以用於發行的版本，儲存在私服中的 RELEASE 存放庫中 SNAPSHOT (快照版本)：功能不穩定、尚處於開發中的版本，即快照版本，儲存在私服的 SNAPSHOT 存放庫中 設定 設定私服的存取使用者名稱與密碼，在 Maven 安裝目錄的 conf/settings.xml 的 servers 配置中設定\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;servers\u0026gt; \u0026lt;server\u0026gt; \u0026lt;id\u0026gt;maven-releases\u0026lt;/id\u0026gt; \u0026lt;username\u0026gt;admin\u0026lt;/username\u0026gt; \u0026lt;password\u0026gt;admin\u0026lt;/password\u0026gt; \u0026lt;/server\u0026gt; \u0026lt;server\u0026gt; \u0026lt;id\u0026gt;maven-snapshots\u0026lt;/id\u0026gt; \u0026lt;username\u0026gt;admin\u0026lt;/username\u0026gt; \u0026lt;password\u0026gt;admin\u0026lt;/password\u0026gt; \u0026lt;/server\u0026gt; \u0026lt;/servers\u0026gt; 設定私服相依性下載的存放庫群組地址，檔案同上，修改 mirrors 與 profiles 標籤\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 \u0026lt;mirrors\u0026gt; \u0026lt;mirror\u0026gt; \u0026lt;id\u0026gt;maven-public\u0026lt;/id\u0026gt; \u0026lt;mirrorOf\u0026gt;*\u0026lt;/mirrorOf\u0026gt; \u0026lt;url\u0026gt;http://127.0.0.1:8081/repository/maven-public/\u0026lt;/url\u0026gt; \u0026lt;/mirror\u0026gt; \u0026lt;/mirrors\u0026gt; \u0026lt;profiles\u0026gt; \u0026lt;profile\u0026gt; \u0026lt;id\u0026gt;allow-snapshots\u0026lt;/id\u0026gt; \u0026lt;activation\u0026gt; \u0026lt;activeByDefault\u0026gt;true\u0026lt;/activeByDefault\u0026gt; \u0026lt;/activation\u0026gt; \u0026lt;repositories\u0026gt; \u0026lt;repository\u0026gt; \u0026lt;id\u0026gt;maven-public\u0026lt;/id\u0026gt; \u0026lt;url\u0026gt;http://127.0.0.1:8081/repository/maven-public/\u0026lt;/url\u0026gt; \u0026lt;releases\u0026gt; \u0026lt;enabled\u0026gt;true\u0026lt;/enabled\u0026gt; \u0026lt;/releases\u0026gt; \u0026lt;snapshots\u0026gt; \u0026lt;enabled\u0026gt;true\u0026lt;/enabled\u0026gt; \u0026lt;/snapshots\u0026gt; \u0026lt;/repository\u0026gt; \u0026lt;/repositories\u0026gt; \u0026lt;/profile\u0026gt; \u0026lt;/profiles\u0026gt; pom 檔案設定上傳地址，在父工程中設定即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;distributionManagement\u0026gt; \u0026lt;!-- release 版本的發布地址 --\u0026gt; \u0026lt;repository\u0026gt; \u0026lt;id\u0026gt;maven-releases\u0026lt;/id\u0026gt; \u0026lt;url\u0026gt;http://127.0.0.1:8081/repository/maven-releases/\u0026lt;/url\u0026gt; \u0026lt;/repository\u0026gt; \u0026lt;!-- snapshot 版本的發布地址 --\u0026gt; \u0026lt;snapshotRepository\u0026gt; \u0026lt;id\u0026gt;maven-snapshots\u0026lt;/id\u0026gt; \u0026lt;url\u0026gt;http://127.0.0.1:8081/repository/maven-snapshots/\u0026lt;/url\u0026gt; \u0026lt;/snapshotRepository\u0026gt; \u0026lt;/distributionManagement\u0026gt; 設定完成後，執行父工程的 deploy 生命周期即可將專案發布到私服存放庫\n","date":"2024-01-13T23:58:42+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/143/","title":"Maven 學習"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 SpringBoot 入門範例 需求：使用 SpringBoot 開發一個 Web 應用程式，瀏覽器發起 /hello 後，回傳字串 “Hello Spring”\n首先需要建立 SpringBoot 專案，並勾選 Web 開發相關相依性\n接著建立控制器類別，在 *Application.java 同級目錄下建立檔案 Controller/HelloController.java\n1 2 3 4 5 6 7 8 9 @RestController public class HelloController{ @RequestMapping(\u0026#34;/hello\u0026#34;) public String hello(){ String s = \u0026#34;Hello Spring\u0026#34;; System.out.println(s); return s; } } 執行 *Application.java 類別，在瀏覽器存取 http://localhost:8080/hello HTTP 超文字傳輸協定基於 TCP 協定 (導向連接，安全)，基於請求-回應模型 (一次請求對應一次回應)\nHTTP 協定是無狀態的協定，對於交易處理沒有記憶能力。每次請求-回應都是獨立的，這使得它速度快，相對地多次請求間不能共享資料\n其他詳見： https://blog.yexca.net/zh-tw/archives/64 ","date":"2024-01-10T17:53:18+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/142/","title":"JavaWeb 入門"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 建立新目錄，將網頁檔案放入 ./dict\n根目錄建立檔案 dockerfile，內容如下：\n1 2 3 4 5 6 # 基於 nginx:1.20 映像檔 FROM nginx:1.20 # 將 dist 檔案中的內容複製到 /usr/share/nginx/html/ 這個目錄下方 COPY dist/ /usr/share/nginx/html/dist/ # 用本地的 nginx.conf 配置來取代 nginx 映像檔中的預設配置 COPY nginx.conf /etc/nginx/nginx.conf 建立新檔案 nginx.conf，內容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #user nobody; worker_processes 1; events { worker_connections 1024; } http { include mime.types; default_type application/octet-stream; sendfile on; #tcp_nopush on; keepalive_timeout 65; # HTTP server server { listen 80; server_name localhost; location / { root /usr/share/nginx/html/dist; index index.html index.htm; } error_page 500 502 503 504 /50x.html; location = /50x.html { root html; } } } 執行打包指令\n1 docker build -t username/imagename:v1.0 . tag 修改映像檔名稱 推送映像檔的命名規範\n1 docker push 註冊使用者名稱/映像檔名 修改 tag\n1 docker tag name username/imagename:v1.0 如果沒有加上 tag，推送時預設為 latest，推送\n1 docker push username/imagename:v1.0 參考文章 docker: 打包 H5 專案的映像檔 Docker 映像檔推送（push）到 Docker Hub ","date":"2024-01-09T21:50:25+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/141/","title":"Docker 建立與推送 H5 映像檔"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 簡單介紹設計模式\n設計模式 引 具體的設計模式\n建立型 結構型 行為型 類別 工廠方法模式 轉接器模式 (類別) 直譯器模式 樣板方法模式 物件 抽象工廠模式\n建造者模式 原型模式 單例模式 轉接器模式 (物件)\n橋接模式 組合模式 裝飾器模式 外觀模式 享元模式 代理模式 責任鏈模式 命令模式 疊代器模式 中介者模式 備忘錄模式 觀察者模式 狀態模式 策略模式 訪客模式 其中\n工廠方法模式 與 抽象工廠模式 在 工廠模式 轉接器模式 描述了類別與物件\n推薦閱讀 https://refactoringguru.cn/design-patterns ","date":"2023-12-27T16:14:15+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/140/","title":"設計模式索引"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 訪客模式 (Visitor Pattern) 物件行為模式\n目的 表示作用於某個物件結構中各個元素的操作。它允許在不改變各元素類別的前提下，定義作用於這些元素的新操作。\n結構 其中：\nVisitor (訪客) 為該物件結構中 ConcreteElement 的每一個類別宣告一個 Visit 操作。該操作的名稱和特殊識別碼標明了發送 Visit 請求給該訪客的那個類別，這使得訪客可以確定正在被拜訪元素的具體類別。如此訪客就能透過該元素的特定介面直接存取它。 ConcreteVisitor (具體訪客) 實作每個由 Visitor 宣告的操作，每個操作實作本演算法的一部分，而該演算法片段則是對應於結構中物件的類別。ConcreteVisitor 為該演算法提供了上下文並儲存其局部狀態。這個狀態通常在遍歷該結構的過程中累積。 Element (元素) 定義以一個訪客為參數的 Accept 操作。 ConcreteElement (具體元素) 實作以一個訪客為參數的 Accept 操作。 ObjectStructure (物件結構) 能枚舉其元素；可以提供一個高階介面以允許該訪客存取其元素；可以是一個組合 (Composite) 或一個集合 (Collection)，例如一個列表 (List) 或一個無序集合 (Set)。 適用性 訪客模式適用於：\n一個物件結構包含許多類別物件，它們有不同的介面，而使用者想要對這些物件執行一些依賴於其具體類別的操作。 需要對一個物件結構中的物件執行許多不同且不相關的操作，同時又希望避免這些操作「污染」這些物件的類別。訪客模式讓使用者能將相關操作集中定義在一個類別中。當該物件結構被許多應用程式共用時，使用訪客模式可讓每個應用程式只包含所需的操作。 定義物件結構的類別很少改變，但經常需要在此結構上定義新的操作。改變物件結構的類別需要重新定義對所有訪客的介面，這可能需要很大的代價。如果物件結構的類別經常改變，那麼或許還是在這些類別中定義這些操作會比較好。 範例 1 某圖書管理系統中管理著兩種文獻類型：圖書和論文。現在要求統計所有館藏文獻的總頁碼，採用訪客模式 (Visitor Pattern) 來實現此要求，類別圖如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 interface LibraryVisitor{ void visit(Book p_book); void visit(Article p_article); void printSum(); } class LibrarySumPrintVisitor implements LibraryVisitor{ // 列印總頁數 private int sum = 0; @Override public void visit(Book p_book) { sum = sum + p_book.getNumberOfPages(); } @Override public void visit(Article p_article) { sum = sum + p_article.getNumberOfPages(); } @Override public void printSum() { System.out.println(\u0026#34;SUM = \u0026#34; + sum); } } interface LibraryItemInterface{ void accept(LibraryVisitor visitor); } class Article implements LibraryItemInterface{ private String m_title; // 論文名稱 private String m_author; // 論文作者 private int m_start_page; private int m_end_page; public Article(String p_author, String p_title, int p_start_page, int p_end_page){ m_title = p_title; m_author = p_author; m_start_page = p_start_page; m_end_page = p_end_page; } public int getNumberOfPages(){ return m_end_page - m_start_page; } @Override public void accept(LibraryVisitor visitor) { visitor.visit(this); } } class Book implements LibraryItemInterface{ private String m_title; // 書名 private String m_author; // 書作者 private int m_pages; // 頁數 public Book(String p_author, String p_title, int p_pages){ m_title = p_title; m_author = p_author; m_pages = p_pages; } public int getNumberOfPages(){ return m_pages; } @Override public void accept(LibraryVisitor visitor) { visitor.visit(this); } } 範例 2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 import java.util.ArrayList; import java.util.List; public class VisitorPattern { public static void main(String[] args) { PersonStructure personStructure = new PersonStructure(); Visitor1 visitor1 = new Visitor1(); System.out.println(\u0026#34;For Visitor1\u0026#34;); personStructure.Accept(visitor1); System.out.println(\u0026#34;The sum of student age: \u0026#34; + visitor1.getStudentAgeSum()); System.out.println(\u0026#34;The sum of teacher age: \u0026#34; + visitor1.getTeacherAgeSum()); Visitor2 visitor2 = new Visitor2(); System.out.println(\u0026#34;For Visitor2\u0026#34;); personStructure.Accept(visitor2); System.out.println(\u0026#34;Max score: \u0026#34; + visitor2.getMaxScore()); System.out.println(\u0026#34;Max work year: \u0026#34; + visitor2.getMaxWorkYear()); } } interface Visitor{ public void VisitS(Student student); public void VisitT(Teacher teacher); } class Visitor1 implements Visitor{// 分別統計學生和老師的年齡總和 private int studentAgeSum = 0; private int teacherAgeSum = 0; public int getStudentAgeSum() { return studentAgeSum; } public int getTeacherAgeSum() { return teacherAgeSum; } @Override public void VisitS(Student student){ System.out.println(\u0026#34;Visitor1: \u0026#34; + student.getName() + \u0026#34; Age: \u0026#34; + student.getAge()); studentAgeSum += student.getAge(); } public void VisitT(Teacher teacher){ System.out.println(\u0026#34;Visitor1: \u0026#34; + teacher.getName() + \u0026#34; Age: \u0026#34; + teacher.getAge()); teacherAgeSum += teacher.getAge(); } } class Visitor2 implements Visitor{ // 分別找出學生最高成績以及老師最高資歷年資 private int maxScore = -1; private int maxWorkYear = -1; public int getMaxScore() { return maxScore; } public int getMaxWorkYear() { return maxWorkYear; } @Override public void VisitS(Student student){ System.out.println(\u0026#34;Visitor2: \u0026#34; + student.getName() + \u0026#34; Score: \u0026#34; + student.getScore()); if(student.getScore() \u0026gt; maxScore) maxScore = student.getScore(); // maxScore = Math.max(maxScore, student.getScore()); } public void VisitT(Teacher teacher){ System.out.println(\u0026#34;Visitor2: \u0026#34; + teacher.getName() + \u0026#34; WorkYear: \u0026#34; + teacher.getWorkYear()); if(teacher.getWorkYear() \u0026gt; maxWorkYear) maxWorkYear = teacher.getWorkYear(); // maxWorkYear = Math.max(maxWorkYear, teacher.getWorkYear()); } } class PersonStructure{ private List\u0026lt;Person\u0026gt; personList = new ArrayList\u0026lt;\u0026gt;(); public PersonStructure(){ personList.add(new Student(\u0026#34;Mike\u0026#34;, 16, 99)); personList.add(new Student(\u0026#34;Jane\u0026#34;, 15, 100)); personList.add(new Teacher(\u0026#34;Alice mana\u0026#34;, 20, 1)); } public void Accept(Visitor visitor){ for(Person p : personList){ p.Accept(visitor); } } } abstract class Person{ private String name; private int age; public abstract void Accept(Visitor visitor); public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } } class Student extends Person{ private int score; public int getScore() { return score; } public Student(String name, int age, int score){ this.setName(name); this.setAge(age); this.score = score; } @Override public void Accept(Visitor visitor){ visitor.VisitS(this); } } class Teacher extends Person{ private int workYear; public int getWorkYear() { return workYear; } public Teacher(String name, int age, int workYear){ this.setName(name); this.setAge(age); this.workYear = workYear; } @Override public void Accept(Visitor visitor){ visitor.VisitT(this); } } ","date":"2023-12-26T16:09:09+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/139/","title":"訪客模式"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 Template Method Pattern 類行為型模式\n意圖 定義一個操作中的演算法骨架，而將一些步驟延遲到子類別中。樣板方法（Template Method）使得子類別可以在不改變一個演算法的結構下，重新定義該演算法的某些特定步驟。\n結構 其中：\nAbstractClass (抽象類別) 定義抽象的原語操作，具體的子類別將重新定義它們以實現一個演算法的各步驟；實現樣板方法，定義一個演算法的骨架，該樣板方法不僅呼叫原語操作，也呼叫定義在 AbstractClass 或其他物件中的操作。 ConcreteClass (具體類別) 實現原語操作以完成演算法中與特定子類別相關的步驟。 適用性 樣板方法（Template Method）模式適用於：\n一次性實現一個演算法不變的部分，並將可變的行為留給子類別來實現。 各子類別中共通的行為應被提取出來並集中到一個共通父類別中，以避免程式碼重複。 控制子類別擴展。樣板方法旨在特定點呼叫「掛鉤（hook）」操作 (預設的行為，子類別可以在必要時進行重新定義擴展)，這就只允許在這些點進行擴展。 範例 去上課時，學生是上課、寫作業；老師則是授課、批改作業。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 public class TemplateMethodPattern { public static void main(String[] args) { Person stu = new Student(); Person tec = new Teacher(); stu.TemplateMethod(); System.out.println(\u0026#34;==========\u0026#34;); tec.TemplateMethod(); } } abstract class Person{ public void TemplateMethod(){ System.out.println(\u0026#34;go to class\u0026#34;); PrimitiveOperation1(); System.out.println(\u0026#34;End of class\u0026#34;); PrimitiveOperation2(); } public abstract void PrimitiveOperation1(); // 原語操作1：上課：學生：聽課；老師：講課 public abstract void PrimitiveOperation2(); // 原語操作2：作業：學生：做作業；老師：改作業 } class Student extends Person{ @Override public void PrimitiveOperation1(){ System.out.println(\u0026#34;Listen\u0026#34;); } public void PrimitiveOperation2(){ System.out.println(\u0026#34;Do assignments\u0026#34;); } } class Teacher extends Person{ @Override public void PrimitiveOperation1(){ System.out.println(\u0026#34;Teach\u0026#34;); } public void PrimitiveOperation2(){ System.out.println(\u0026#34;Grade assignments\u0026#34;); } } ","date":"2023-12-25T21:06:06+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/138/","title":"樣板方法模式"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 策略模式 物件行為模式\n目的 定義一系列演算法，將它們個別封裝起來，並使其可以互相替換。此模式讓演算法能夠獨立於使用它們的客戶而變化。\n結構 其中：\nStrategy (策略) 定義所有支援演算法的通用介面。Context 使用這個介面來呼叫某個 ConcreteStrategy 所定義的演算法。\nConcreteStrategy (具體策略) 以 Strategy 介面實作某個具體演算法。\nContext (上下文) 用一個 ConcreteStrategy 物件來配置；維護一個對 Strategy 物件的參照；可定義一個介面來讓 Strategy 存取它的資料。\n適用性 策略模式適用於：\n許多相關的類別僅僅是行為有所不同。「策略」提供了一種方法，用多個行為中的其中一個行為來配置一個類別。\n需要使用一個演算法的不同變體。例如，定義一些反映不同空間的空間/時間權衡演算法。當這些變體實作為一個演算法的類別層次時，可以使用策略模式。\n演算法使用客戶不應知道的資料。可使用策略模式，以避免揭露複雜且與演算法相關的資料結構。\n一個類別定義了多種行為，並且這些行為在這個類別的操作中以多個條件陳述式的形式出現，可將相關的條件分支移入它們各自的 Strategy 類別中，以代替這些條件陳述式。\n範例 1 某間大型購物中心欲開發一套收銀軟體，要求其能夠支援購物中心在不同時期推出的各種促銷活動，例如打折、回饋（例如，滿 300 回饋 100）等等。現採用策略模式實作該要求，所設計的類別圖如下所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 import java.util.*; enum TYPE { NORMAL, CASH_DISCOUNT, CASH_RETURN}; interface CashSuper { public double acceptCash(double money); } class CashNormal implements CashSuper { // 正常收費子類別 public double acceptCash(double money) { return money; } } class CashDiscount implements CashSuper { private double moneyDiscount; // 折扣率 public CashDiscount(double moneyDiscount) { this moneyDiscount = moneyDiscount; } public double acceptCash(double money) { return money* moneyDiscount; } } class CashReturn implements CashSuper { // 滿額回饋 private double moneyCondition; private double moneyReturn; public CashReturn(double moneyCondition, double moneyReturn) { this.moneyCondition = moneyCondition; // 滿額金額 this.moneyReturn = moneyReturn; // 回饋金額 } public double acceptCash(double money) { double result = money; if(money \u0026gt;= moneyCondition ) result = money - Math.floor(money / moneyCondition) * moneyReturn; return result; } } class CashContext { private CashSuper cs; private TYPE t; public CashContext(TYPE t) { switch(t) { case NORMAL: // 正常收費 cs = new CashNormal(); break; case CASH_DISCOUNT: // 打 8 折 cs = new CashDiscount(0.8); break; case CASH_RETURN: // 滿 300 回饋 100 cs = new CashReturn(300, 100); break; } } public double GetResult(double money) { return cs.acceptCash(money); } // 此處省略 main() 函式 } 範例 2 加減乘\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 public class StrategyPattern { public static void main(String[] args) { Strategy add = new AddStrategy(); Strategy subtraction = new SubtractionStrategy(); Strategy multiply = new MultiplyStrategy(); OperationContext context = new OperationContext(add); context.Operation(1, 2); context = new OperationContext(subtraction); context.Operation(1, 2); context = new OperationContext(multiply); context.Operation(1, 2); } } class OperationContext{ private Strategy strategy; public OperationContext(Strategy strategy){ this.strategy = strategy; } public void Operation(int a, int b){ strategy.operation(a, b); } } interface Strategy{ public void operation(int a, int b); } class AddStrategy implements Strategy{ @Override public void operation(int a, int b){ System.out.println(a + b); } } class SubtractionStrategy implements Strategy{ @Override public void operation(int a, int b){ System.out.println(a - b); } } class MultiplyStrategy implements Strategy{ @Override public void operation(int a, int b){ System.out.println(a * b); } } ","date":"2023-12-24T18:30:30+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/137/","title":"策略模式"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 State Pattern 物件行為型模式\n意圖 允許一個物件在其內部狀態改變時改變它的行為。物件看起來似乎修改了它的類別。\n結構 其中：\nContext (上下文) 定義用戶感興趣的介面：維護一個 ConcreteState 子類別的實例，這個實例定義當前狀態。\nState (狀態) 定義一個介面以封裝與 Context 的一個特定狀態相關的行為。\nConcreteState (具體狀態子類別) 每個子類別實作與 Context 的一個狀態相關的行為。\n適用性 一個物件的行為取決於它的狀態，並且它必須在執行時期根據狀態改變其行為。\n一個操作中含有龐大的多分支條件語句，且這些分支依賴於該物件的狀態。這個狀態常用一個或多個列舉常數表示。通常，有多個操作包含相同的條件結構，State 模式將每一個條件分支放入一個獨立的類別中。這使得開發者可以根據物件自身的情況將物件的狀態作為一個物件，該物件可以不依賴於其他物件獨立變化。\n範例 1 某大型商場內安裝了多台簡易的面紙販賣機，自動販售 2 元一包的面紙，且每次僅售出一包面紙。面紙販賣機的狀態圖如下圖所示：\n採用狀態 (State) 模式來實作該面紙販賣機，得到如下圖所示的類別圖。其中類別 State 為抽象類別，定義了投幣、退幣、出面紙等方法介面。類別 SoldState、SoldOutState、NoQuarterState 和 HasQuarterState 分別對應上圖中面紙販賣機的 4 種狀態：售出面紙、面紙售完、尚未投幣、已投 2 元。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 import java.util.*; interface State { public void insertQuarter(); // 投幣 public void ejectQuarter(); // 退幣 public void turnCrank(); // 按下「出面紙」按鈕 public void dispense(); // 出面紙 } class TissueMachine { State soldOutState, noQuarterState, hasQuarterState, soldState, state; state = soldOutState; int count = 0; // 面紙數量 public TissueMachine(int numbers) { /* 實作程式碼省略 */ } public State getHasQuarterState() { return hasQuarterState; } public State getNoQuarterState() { return noQuarterState; } public State getSoldState() { return soldState; } public State getSoldOutState() { return soldOutState; } public int getCount() { return count; } // 其餘程式碼省略 } class NoQuarterState implements State { TissueMachine tissueMachine; public void insertQuarter() { tissueMachine.setState(tissueMachine.getHasQuarterState()); } // 建構方法以及其餘程式碼省略 } class HasQuarterState implements State { TissueMachine tissueMachine; public void ejectQuarter() { tissueMachine.setState(tissueMachine.getNoQuarterState()); } // 建構方法以及其餘程式碼省略 } class SoldState implements State { TissueMachine tissueMachine; public void dispense() { if (tissueMachine.getCount() \u0026gt; 0) { tissueMachine.setState(tissueMachine.getNoQuarterState()); } else { tissueMachine.setState(tissueMachine.getSoldOutState()); } } } 範例 2 某航空公司的會員點數系統將其會員劃分為：普卡 (Basic)、銀卡 (Silver) 和金卡 (Gold) 三個等級。非會員 (NonMember) 可以申請成為普卡會員。會員的等級根據其一年內累積的哩程數進行調整。描述會員等級調整的狀態圖如下圖所示：\n現採用狀態 (State) 模式實作上述場景，得到如下圖所示的類別圖：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 import java.util.*; abstract class CState { public int flyMiles; // 哩程數 public abstract double travel(int miles, CFrequentFlyer context); // 根據累積哩程數調整會員等級 } class CNoCustomer extends CState { // 非會員 public double travel(int miles, CFrequentFlyer context) { System.out.println(\u0026#34;Your travel will not account for points\u0026#34;); return miles; // 不累積哩程數 } } class CBasic extends CState { // 普卡會員 public double travel(int miles, CFrequentFlyer context) { if (context.flyMiles \u0026gt;= 25000 \u0026amp;\u0026amp; context.flyMiles \u0026lt; 50000) context.setState(new CSilver()); if (context.flyMiles \u0026gt;= 50000) context.setState(new CGold()); return miles; } } class CGold extends CState { // 金卡會員 public double travel(int miles, CFrequentFlyer context) { if (context.flyMiles \u0026gt;= 25000 \u0026amp;\u0026amp; context.flyMiles \u0026lt; 50000) context.setState(new CSilver()); if (context.flyMiles \u0026lt; 25000); context.setState(new CBasic()); return miles + 0.5 * miles; // 累積哩程數 } } class CSilver extends CState { // 銀卡會員 public double travel(int miles, CFrequentFlyer context) { if (context.flyMiles \u0026lt;= 25000) context.setState(new CBasic()); if (context.flyMiles \u0026gt;= 50000) context.setState(new CGold()); return (miles + 0.25 * miles); // 累積哩程數 } } class CFrequentFlyer { CState state; double flyMiles; public CFrequentFlyer() { state = new CNoCustomer(); flyMiles = 0; setState(state); } public void setState(CState state) { this.state = state; } public void travel(int miles) { double bonusMiles = state.travel(miles, this); flyMiles = flyMiles + bonusMiles; } } 範例 3 自動販賣機，有貨與無貨。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 public class StatePattern { public static void main(String[] args) { Context context = new Context(); context.Request(); // count = 2 context.Request(); // count = 1 context.Request(); // count = 0 context.Request(); // switch to State A context.Request(); // count = 4 } } class Context{ // 販賣機 private int count; private State state; public Context(){ count = 3; state = new StateA(); } public int getCount() { return count; } public State getState() { return state; } public void setCount(int count) { this.count = count; } public void setState(State state) { this.state = state; } public void Request(){ // 購買飲料 state.Handle(this); } } interface State{ public void Handle(Context context); } class StateA implements State{ // 有貨 @Override public void Handle(Context context){ int count = context.getCount(); if(count \u0026gt;= 1){ context.setCount(count - 1); System.out.println(\u0026#34;Complete! あと\u0026#34; + context.getCount() + \u0026#34;個\u0026#34;); if(context.getCount() == 0){ context.setState(new StateB()); } }else{ System.out.println(\u0026#34;Refused!\u0026#34;); } } } class StateB implements State{ // 無貨 @Override public void Handle(Context context){ int count = context.getCount(); if(count == 0){ System.out.println(\u0026#34;Refused!\u0026#34;); context.setCount(5); System.out.println(\u0026#34;Please try again\u0026#34;); context.setState(new StateA()); }else { context.setState(new StateA()); context.Request(); } } } ","date":"2023-12-22T15:11:16+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/136/","title":"狀態模式"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 Asynchronous JavaScript And XML，非同步的 JS 與 XML。功能：\n資料交換：透過 Ajax 可以向伺服器送出請求，並取得伺服器回應的資料 非同步互動：可以在不重新載入整個頁面的情況下，與伺服器交換資料並更新部分網頁的技術 使用情境：搜尋聯想、使用者名稱是否可用等\n同步與非同步 同步指的是在造訪網頁時，執行某個操作需要向伺服器發出請求，在伺服器處理時網頁無法操作，直到伺服器回應客戶端時才能繼續操作。\n而非同步則是在向伺服器發出請求的同時，客戶端可以執行其他操作。\n原生 Ajax 首先建立 XMLHttpRequest 物件 (用於和伺服器交換資料)，然後向伺服器送出請求，最後取得伺服器回應資料。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Ajax\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;取得資料\u0026#34; onclick=\u0026#34;getDate()\u0026#34;\u0026gt; \u0026lt;div id=\u0026#34;div1\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; function getDate(){ // 建立 XMLHttpRequest var xmlHttpRequest = new XMLHttpRequest(); // 送出非同步請求 xmlHttpRequest.open(\u0026#39;GET\u0026#39;, \u0026#39;//127.0.0.1:8080/listEmp\u0026#39;); xmlHttpRequest.send(); // 取得服務回應資料 xmlHttpRequest.onreadystatechange=function(){ if(xmlHttpRequest.readyState==4 \u0026amp;\u0026amp; xmlHttpRequest.status==200){ document.getElementById(\u0026#34;div1\u0026#34;).innerHTML=xmlHttpRequest.responseText; } } } \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; 詳細參考： https://www.w3school.com.cn/js/js_ajax_intro.asp Axios Axios 對原生的 Ajax 進行了封裝，簡化撰寫，快速開發。官方網站： https://www.axios-http.cn/ 使用 Axios 需要先引入 Axios 檔案\n1 \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 使用 Axios 送出請求並回應結果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Axios\u0026lt;/title\u0026gt; \u0026lt;!-- 檔案已下載到本機 --\u0026gt; \u0026lt;script src=\u0026#34;./js/axios-0.18.0.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;取得資料\u0026#34; onclick=\u0026#34;getData()\u0026#34;\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; function getData(){ axios({ method: \u0026#34;get\u0026#34;, url: \u0026#34;//127.0.0.1:8080/listEmp\u0026#34; }).then(result =\u0026gt; { console.log(result.data); }) } \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; 上述是 GET 方法，POST 方法需要新增資料\n1 2 3 4 5 6 7 8 9 function deleteData(){ axios({ method: \u0026#34;POST\u0026#34;, url: \u0026#34;//127.0.0.1:8080/deleteEmpById\u0026#34;, data: \u0026#34;id=1\u0026#34; }).then(result =\u0026gt; { console.log(result.data); }) } 當然，這樣寫還是過於繁瑣，Axios 提供了別名\naxios.get(url[, config]) axios.delete(url[, config]) axios.post(url[, data[, config]]) axios.put(url[, data[, config]]) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 function getData(){ // axios({ // method: \u0026#34;get\u0026#34;, // url: \u0026#34;//127.0.0.1:8080/listEmp\u0026#34; // }).then(result =\u0026gt; { // console.log(result.data); // }) axios.get(\u0026#34;//127.0.0.1:8080/listEmp\u0026#34;).then(result =\u0026gt; { console.log(result.data); }) } function deleteData(){ // axios({ // method: \u0026#34;POST\u0026#34;, // url: \u0026#34;//127.0.0.1:8080/deleteEmpById\u0026#34;, // data: \u0026#34;id=1\u0026#34; // }).then(result =\u0026gt; { // console.log(result.data); // }) axios.post(\u0026#34;//127.0.0.1:8080/deleteEmpById\u0026#34;,\u0026#34;id=1\u0026#34;).then(result =\u0026gt; { console.log(result.data); }) } ","date":"2023-12-21T13:32:15+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/135/","title":"Ajax 與 Axios"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 Observer Pattern 物件行為型模式\n意圖 定義物件間的一對多的相依關係，當一個物件的狀態發生改變時，所有依賴於它的物件都會得到通知並被自動更新。\n結構 其中：\nSubject (目標) 知道它的觀察者，可以有任意多個觀察者觀察同一個目標；提供註冊和刪除觀察者物件的介面。 Observer (觀察者) 為那些在「目標發生改變時需獲得通知的物件」定義一個更新介面。 ConcreteSubject (具體目標) 將有關狀態存入各 ConcreteObserver 物件；當它的狀態發生改變時，向它的各個觀察者發出通知。 ConcreteObserver (具體觀察者) 維護一個指向 ConcreteSubject 物件的參照；儲存有關狀態，這些狀態應與目標的狀態保持一致；實作 Observer 的更新介面，以使自身狀態與目標的狀態保持一致。 適用性 Observer 模式適用於：\n當一個抽象模型有兩個面向，其中一個面向相依於另一個面向，將這兩者封裝在獨立的物件中以使它們可以各自獨立地改變和複用。 當對一個物件的改變需要同時改變其他物件，而不知道具體有多少物件有待改變時。 當一個物件必須通知其他物件，但它又不能假定其他物件是誰，即不希望這些物件是緊密耦合的。 例子 1 某檔案管理系統中定義了類別 OfficeDoc 和 DocExplorer。當類別 OfficeDoc 發生變化時，類別 DocExplorer 的所有物件都要更新其自身的狀態。現採用觀察者 (Observer) 設計模式來實作該需求，所設計的類別圖如下圖所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 import java.util.*; interface Observer { public void update(); } interface Subject { public void Attach(Observer obs); public void Detach(Observer obs); public void Notify(); public void setStatus(int status); public int getStatus(); } class OfficeDoc implements Subject { private List\u0026lt;Observer\u0026gt; myObs; private String mySubjectName; private int m_status; public OfficeDoc(String name) { mySubjectName = name; this.myObs = new ArrayList\u0026lt;Observer\u0026gt;(); m_status = 0; } public void Attach(Observer obs) { this.myObs.add(obs); } public void Detach(Observer obs) { this.myObs.remove(obs); } public void Notify() { for (Observer obs : this.myObs) {obs.update(); } } public void setStatus(int status) { m_status = status; System.out.println(\u0026#34;SetStatus subject[\u0026#34; + mySubjectName + \u0026#34;]status:\u0026#34; + status); } public int getStatus() { return m_status; } } class DocExplorer implements Observer { private String myObsName; public DocExplorer(String name,Subject sub) { myObsName = name; sub.Attach(this); } public void update() { System.out.println(\u0026#34;update observer[\u0026#34; + myObsName + \u0026#34;]\u0026#34;); } } class ObserverTest { public static void main(String[] args) { Subject subjectA = new OfficeDoc(\u0026#34;subject A\u0026#34;); Observer observerA = new DocExplorer(\u0026#34;observer A\u0026#34;, subjectA); subjectA.setStatus(1); subjectA.Notify(); } } 例子 2 Subject 為 Youtuber，Observer 為訂閱者。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 import java.util.ArrayList; import java.util.List; public class ObserverPattern { public static void main(String[] args) { Subject subjectA = new ConcerteSubject(); Observer observer1 = new ConcerteObserver(\u0026#34;Mike\u0026#34;, subjectA); Observer observer2 = new ConcerteObserver(\u0026#34;Jane\u0026#34;, subjectA); subjectA.Notify(); } } interface Subject{ // 目標 public void Attach(Observer observer); public void Detach(Observer observer); public void Notify(); public String getState(); public void setState(String state); } class ConcerteSubject implements Subject{ private String state; private List\u0026lt;Observer\u0026gt; observerList; public String getState() { return state; } @Override public void setState(String state) { this.state = state; this.Notify(); } public ConcerteSubject(){ state = \u0026#34;-1\u0026#34;; observerList = new ArrayList\u0026lt;\u0026gt;(); } public void Attach(Observer observer){ observerList.add(observer); } public void Detach(Observer observer){ observerList.remove(observer); } public void Notify(){ for(Observer o : observerList){ o.update(); } } } interface Observer{ // 觀察者 public void update(); } class ConcerteObserver implements Observer{ private String name; private Subject subject; private String state; public ConcerteObserver(String name, Subject subject){ this.name = name; this.state = subject.getState(); this.subject = subject; subject.Attach(this); } @Override public void update(){ System.out.println(this.name + \u0026#34; Received\u0026#34;); this.state = subject.getState(); } } ","date":"2023-12-21T01:18:25+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/134/","title":"觀察者模式"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 從 ???? 我記不清了 開始喜歡上 ASMR 後就接觸到了音聲，不過高昂的價格顯然會驅使我去廣袤的網路（Internet）上搜尋，於是便知道了這個網站，但此網站只有登入後才可以看到更多內容，而每年也幾乎是不定期開放註冊，這使我很好奇這個網站。\n於是我便想著讓伺服器執行程式偵測是否可以註冊，然後發出通知。\nGitHub: yexca/hvdb 目標 偵測是否可以註冊，如果可以便透過 Telegram 通知。\n偵測是否可以註冊 在靈夢廣場的一個貼文回覆中可以獲知，當開放註冊時 login 的下方會出現 register。\n那便可以用一種最簡樸的方法，爬取這個網頁，檢查是否有此單字。\nBot 配置 使用 Telegram 的 Bot 通知需要先註冊一個 Bot。\n對話 https://t.me/BotFather 輸入 /newbot 指令，按照步驟建立一個 Bot。\n和剛建立的 Bot 對話，發送 hello。\n然後訪問 (將 TOKEN 替換為自己的 token)\n1 https://api.telegram.org/botTOKEN/getUpdates 會得到一個 JSON 檔案，找到 id，此 id 即為 chat_id。\n參考： 使用Telegram Bot来实现推送通知 Python 透過 Python 是最簡單的 (我也懶得看其他語言了)。\n爬取使用 Requests 函式庫，通知的話使用 pyTelegramBotAPI 。\n多餘的就不解析了，直接放程式碼 (此檔名不要命名為 http.py 或 requests.py)：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 import telebot import requests import time # 替換自己的 token bot = telebot.TeleBot(\u0026#34;TOKEN\u0026#34;, parse_mode=\u0026#34;MARKDOWN\u0026#34;) # You can set parse_mode by default. HTML or MARKDOWN def inform(): web = requests.get(\u0026#34;https://hvdb.me/\u0026#34;) str = web.text a = str.find(\u0026#34;register\u0026#34;) if a != -1: # 替換自己的 chat_id bot.send_message(\u0026#34;chat_id\u0026#34;, \u0026#34;[hvdb](http://hvdb.me/) register start\u0026#34;) t = 0 while True: inform() # 每小時執行一次 time.sleep(3600) # 計時是否執行了 24 小時 t += 1 # 每天提醒一次程式在執行 if t == 24: t -= 24 local_time = time.ctime(time.time()) inform_str = \u0026#34;{} 已執行\u0026#34;.format(local_time) # 替換自己的 chat_id bot.send_message(\u0026#34;chat_id\u0026#34;, inform_str) 參考資料\n关于报错“AttributeError:partially initialized module‘requests‘has no attribute‘get‘的解决方法 requests - 廖雪峰的官方网站 Python time sleep()方法 - 菜鸟教程 Python 日期和时间 - 菜鸟教程 Docker 封裝 檔案結構\n1 2 3 D:\\DOCKER\\HVDB Dockerfile inform.py Dockerfile 檔案\n1 2 3 4 5 6 FROM python:3.11-alpine RUN pip install requests \\ \u0026amp;\u0026amp; pip install pyTelegramBotAPI COPY ./inform.py /app/inform.py CMD [ \u0026#34;python\u0026#34;, \u0026#34;/app/inform.py\u0026#34; ] 同目錄下執行命令打包映像檔（Image）\n1 docker build -t hvdb:v1.0 . 轉移到伺服器 Windows 下\n1 docker save -o hvdb.tar hvdb:v1.0 等待打包完成，複製到伺服器\n1 scp .\\hvdb.tar username@hostname:/path 複製完成後，伺服器執行\n1 docker load -i hvdb.tar 參考： docker load报错：Error processing tar file(exit status 1): archive/tar: invalid tar header ","date":"2023-12-02T21:23:01+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/133/","title":"hvdb 註冊偵測"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 Memento Pattern 物件行為型模式\n意圖 在不破壞封裝性的前提下擷取一個物件的內部狀態，並在物件之外儲存這個狀態。這樣以後就可以將物件恢復到原先儲存的狀態\n結構 其中：\nMemento (備忘錄) 儲存原發器物件的內部狀態，原發器根據需要決定備忘錄儲存原發器的哪些內部狀態；防止原發器以外的其他物件存取備忘錄 Originator (原發器) 建立一個備忘錄，用於記錄目前時刻它的內部狀態；使用備忘錄恢復內部狀態 Caretaker (管理者) 負責保存好備忘錄；不能對備忘錄的內容進行操作或檢查 適用性 Memento 模式適用於：\n必須儲存一個物件在某一個時刻的 (部分) 狀態，這樣以後需要時它才能恢復到先前的狀態 如果用介面來讓其他物件直接得到這些狀態，將會暴露物件的實作細節並破壞物件的封裝性 範例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 import java.util.ArrayList; import java.util.List; public class MementoPattern { public static void main(String[] args) { Caretaker caretaker = new Caretaker(); Originator originator = new Originator(); originator.setState(\u0026#34;first\u0026#34;); Memento memento1 = originator.createMemento(); caretaker.addMemento(memento1); originator.setState(\u0026#34;second\u0026#34;); Memento memento2 = originator.createMemento(); caretaker.addMemento(memento2); originator.setState(\u0026#34;third\u0026#34;); Memento memento3 = originator.createMemento(); caretaker.addMemento(memento3); caretaker.showMemento(); Memento backup = caretaker.getMemento(2); originator.setMemento(backup); System.out.println(\u0026#34;=========\u0026#34;); System.out.println(originator.getState()); } } class Originator{ // 原發器 private String state; public void setState(String state){ this.state = state; } public String getState(){ return state; } public Memento createMemento(){ return new Memento(state); } public void setMemento(Memento memento){ state = memento.getState(); } } class Memento{ // 備忘錄 private String state; public Memento(String state){ this.state = state; } public String getState(){ return state; } } class Caretaker{ // 管理者 private List\u0026lt;Memento\u0026gt; mementoList = new ArrayList\u0026lt;\u0026gt;(); public void addMemento(Memento memento){ mementoList.add(memento); } public Memento getMemento(int index){ return mementoList.get(index - 1); } public void showMemento(){ int i = 1; for(Memento m : mementoList){ System.out.println(\u0026#34;No.\u0026#34; + i + \u0026#34;: \u0026#34; + m.getState()); i++; } } } ","date":"2023-11-27T14:08:05+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/132/","title":"備忘錄模式"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 自從部落格轉移到 GitHub 上後，本打算就這樣不再購買新伺服器的，不過可能是這幾個月很平靜，使得我迫切想折騰一陣子，也可能是 我可以不用，但不能沒有 的心理使我衝動消費了一次。\n目前的網站 (yexca.net 網域) 個人介紹？： http://yexca.net (目前還是半成品) 這個部落格： http://blog.yexca.net VRChat 部落格： http://vrc.yexca.net VRChat 文件： http://vrchat.yexca.net Navidrome： http://music.yexca.net (自用) xlog(Web3)： http://xlog.yexca.net Docker 自從接觸了 Docker 以後，我幾乎什麼專案都會想著用 Docker 部署，畢竟是真好用啊。\n系統為 Debian 10，root 帳號登入，首先更新：\n1 apt update 安裝軟體：\n1 apt install curl gpg 更新 GPG：\n1 curl -fsSL https://download.docker.com/linux/debian/gpg | gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg 新增 Docker 來源庫：\n1 2 3 echo \\ \u0026#34;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/debian \\ buster stable\u0026#34; | tee /etc/apt/sources.list.d/docker.list \u0026gt; /dev/null 安裝 Docker：\n1 2 apt update apt install docker-ce docker-ce-cli containerd.io docker-compose 啟動 Docker：\n1 2 systemctl enable docker systemctl start docker 測試是否成功：\n1 docker run --rm hello-world 此部分參考： 伺服器用 Docker 部署紀錄 公鑰登入 參考： SSH 公鑰登入 Nginx 這次和之前一樣也是用 nginx-ui 專案，Docker 部署，設定檔如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 version: \u0026#39;3.1\u0026#39; services: nginx-ui: restart: always image: uozi/nginx-ui:latest container_name: nginx_UI volumes: - /home/nginx_ui/nginx:/etc/nginx - /home/nginx_ui/nginx-ui:/etc/nginx-ui - /home/nginx_ui/www:/www ports: - 80:80 - 443:443 如果是 DNS 處啟用 HTTPS 的話就不用配置憑證了，不然一直訪問異常。\n個人介紹 事實上在我將上一個伺服器的網站全部變成 Docker 部署之前就有想法，當時我特意將部落格網域從 yexca.xyz 改為 blog.yexca.xyz 就是為了空出網域，沒想到都到了下一個伺服器我才開始做。\n網域 yexca.xyz 已不屬於我\n我翻開之前準備的工程，建立時間是 2022.03.07，最後修改 2022.06.29，我這拖延症越來越嚴重了。\n言歸正傳，事實上產生這個想法是看到了一些部落客的個人介紹，例如 https://idealclover.top/ 、 https://the.moe/ 當然還有很多，只是時間有點太長了，實在找不到 (而且有的還更新了，變得更酷了)。\n有些會開源，只要填上自己資訊就可以自動生成介紹網頁 (時間太長找不到專案了)。\n不過最終我還是選擇模仿 http://lolicon.app 的網頁，至於為何我也忘了 (好像是我去年決定的)。\n參考文章\n用 CSS 實現自定義捲軸樣式 如何給網站設置 favicon.ico 圖示 Navidrome 衝動消費的一個主要原因還有想搞一個還行的音樂網站自用，之前有一個 基於 OneDrive 的 ，但在中國大陸訪問體驗不好，又恰逢 115 出活動，所以有了這篇文章。\n體驗後：什麼玩意，還沒 OneDrive 快，衝動是魔鬼，切不可衝動消費。\n唉，本來還想著要是效果好再部署一個 kikoeru-express 呢。\n首先需要支持掛載 115 雲端硬碟的 Rclone。\n專案網址： https://github.com/gaoyb7/rclone-release 該專案使用方式與原 Rclone 一致，只是加入了 115 支援。\n擷取 Cookie Chrome 擷取 Cookie 登入 115 後進入控制台的 Network，重新整理網頁，找到 cookie.js?_=[number]。\n在 Request Headers 可找到 Cookie。\nChrome 擴充功能擷取 Cookie 使用擴充功能可以很方便地查看 Cookie。\n安裝地址： Get cookies.txt LOCALLY App 的 Cookie 網頁版 Cookie 時效較短，建議擷取 App 請求獲取 Cookie，iOS 系統可使用 Stream 或者 Quantumult X 封包擷取，安卓系統使用「抓包精靈」，電腦端選擇很多，例如 Fiddler。\n這個 Cookie 隨便抓一下就出來了，不寫了。\n設定 Rclone 可以透過命令配置或編輯設定檔。\n使用命令配置 執行命令：\n1 rclone.exe config 根據需求選擇即可，Windows 下完成後設定檔生成在：\n1 C:\\Users\\%USERNAME%\\AppData\\Roaming\\rclone 編輯設定檔 在上述目錄建立檔案 rclone.conf 內容如下：\n1 2 3 4 5 [name] type = 115 uid = your_uid cid = your_cid seid = your_seid Windows 掛載測試 Windows 掛載需先安裝 winfsp (安裝完成後重啟一下)。\n1 .\\rclone.exe mount -v --read-only --vfs-read-chunk-size=4M --buffer-size=32M --network-mode 115: X: 按 Ctrl+C 結束掛載。\nLinux Docker 掛載 拉取映像檔：\n1 docker pull gaoyb7/rclone:latest 掛載：\n1 2 3 4 5 6 7 8 9 10 11 12 docker run --rm \\ --volume /home/rclone/config:/config/rclone \\ --volume /home/rclone/data:/data:shared \\ --volume /etc/passwd:/etc/passwd:ro --volume /etc/group:/etc/group:ro \\ --device /dev/fuse --cap-add SYS_ADMIN --security-opt apparmor:unconfined \\ gaoyb7/rclone:latest \\ mount 115:/music /data/music --allow-other --allow-non-empty --vfs-cache-mode writes \u0026amp; # 上述命令僅最後一行為 Rclone 的命令，根據實際情況修改，格式如下 rclone mount DriveName:Folder LocalFolder # DriveName Rclone 掛載的名稱 # Folder 雲端硬碟的路徑 # LocalFolder 掛載到在地端的資料夾 Navidrome 配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 version: \u0026#34;3.0\u0026#34; services: navidrome: image: deluan/navidrome:latest ports: - \u0026#34;8005:4533\u0026#34; restart: unless-stopped environment: # Optional: put your config options customization here. Examples: ND_SCANSCHEDULE: 1h ND_LOGLEVEL: info ND_SESSIONTIMEOUT: 24h ND_BASEURL: \u0026#34;\u0026#34; ND_LASTFM_ENABLED: \u0026#34;true\u0026#34; ND_LASTFM_APIKEY: your_LASTFM_APIKEY ND_LASTFM_SECRET: your_LASTFM_SECRET ND_LASTFM_LANGUAGE: zh ND_SPOTIFY_ID: your_SPOTIFY_ID ND_SPOTIFY_SECRET: your_SPOTIFY_SECRET ND_ENABLESHARING: \u0026#34;true\u0026#34; ND_UILOGINBACKGROUNDURL: \u0026#34;https://www.loliapi.com/acg\u0026#34; #隨機圖片介面 ND_UIWELCOMEMESSAGE: \u0026#34;主介面會看到的話\u0026#34; volumes: - \u0026#34;/home/navidrome/data:/data\u0026#34; - \u0026#34;/home/rclone/data/music:/music/115:ro\u0026#34; - \u0026#34;/home/navidrome/music:/music/server:ro\u0026#34; 部落格 兩個部落格，均參考之前文章部署，部署出來應該也不會更新了。\nWordPress WordPress 部落格之前用的圖片 CDN 不能訪問了，我嘗試使用一些替換外掛無果後懶得折騰了 (背景圖片能看就行)。\nTypecho VRChat 教學 我長時間不用忘了後台的密碼，還好之前做了雙重保險保留了備份檔案，於是搭建一個新的，再導入數據。圖片和上面那個一樣，有時間換個 CDN 就好了 (目前只換了封面的)。\nWarmaTap 把初音未來的聲音替換為 Warma 聲音的很好玩的網頁。\n偏電子音 GitHub: lwd-temp/warmatap 部署： http://yexca.net/warma_tap 偏人聲 GitHub: MonianHello/WarmaTap 部署： http://yexca.net/warmatap MikuTap GitHub: HFIProgramming/mikutap 部署： http://yexca.net/mikutap MikuTap 是以 patatap 為靈感製作。\n","date":"2023-11-03T15:34:01+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/131/","title":"2023 新伺服器部署紀錄"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 網站 手機瀏覽即可查看 (只試過 iOS)\n2020: https://st.music.163.com/c/year2020 2021: https://st.music.163.com/c/year2021 2022: https://st.music.163.com/c/year2022 過程 Google 搜尋 網易雲年度報告，發現 https://st.music.163.com/c/reportreview2020 (手機瀏覽的情況下會出現 2020 年度報告入口)，順著網址試著修改年份，發現 2020-2022 都可以查看\n","date":"2023-10-29T23:45:01+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/130/","title":"網易雲音樂 2020-2022 年度報告"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 此文章寫於 2022.12，由於多種原因未發佈\n該系列文章為我閱讀《Linux 系統管理、伺服器設定、安全、雲端數據中心》所撰寫的相關筆記\n第一部分：入門 這部分沒有記錄文章\n第 01 章 開始使用 Linux Linux 的歷史。總結：Linux NB\n第 02 章 建立完美的 Linux 桌面 然後有了 Fedora 桌面折騰 第二部分：成為一名 Linux 進階使用者 第 03 章 使用 shell shell 的一些用法與變數\n第 04 章 在檔案系統中移動 檔案相關 shell 指令、元字元、檔案權限\n第 05 章 使用文字檔 vi 編緝器、查找檔案 (locate 、find 、grep)\n第 06 章 管理執行中的程序 列出程序，終止程序，限制程序\n第 07 章 撰寫簡單的 shell 腳本 一些 shell 腳本的語法\n第三部分 成為一名 Linux 系統管理員 第 08 章 學習系統管理 /etc 下的設定檔\n第 09 章 安裝 Linux (なし) 沒有文章。圖形化或命令列個人安裝。企業中批次安裝\n第 10 章 獲取與管理軟體 RPM 與 DEB 套件，yum 、rpm 、dnf 、apt 指令\n第 11 章 取得使用者帳號 管理使用者帳號與群組帳號\n第 12 章 管理磁碟與檔案系統 建立檔案系統，LVM 邏輯磁碟區，掛載檔案系統\n之後還有伺服器管理員、Linux 安全技術、將 Linux 擴展到雲端。因各種原因，不進行筆記撰寫\n","date":"2023-10-21T14:18:15+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/129/","title":"Linux 學習 Index"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 Mediator Pattern 物件行為型模式\n意圖 用一個中介物件來封裝一系列的物件互動。中介者使各物件不需要顯式地相互參照，從而使其耦合鬆散，而且可以獨立地改變它們之間的互動。\n結構 其中：\nMediator (中介者) 定義一個介面用於各同事 (Colleague) 物件通訊。 ConcreteMediator (具體中介者) 透過協調各同事物件實現協作行為；了解並維護它的各個同事。 Colleague class (同事類別) 知道它的中介者物件；每一個同事類別物件在需要與其他同事通訊的時候與它的中介者通訊。 適用性 Mediator 模式適用於：\n一組物件以定義良好但複雜的方式進行通訊，產生的相互依賴關係結構混亂且難以理解。 一個物件參照其他很多物件並且直接與這些物件通訊，導致難以重複使用該物件。 想客製化一個分布在多個類別中的行為，而又不想產生過多的子類別。 範例 1 線上支付是電子商務的一個重要環節，不同的電子商務平台提供了不同的支付介面。現在需要整合不同電子商務平台的支付介面，使得客戶在不同平台上購物時，不需要關心具體的支付介面。擬採用中介者 (Mediator) 設計模式來實現該需求，類別圖如下所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 interface WebServiceMediator { public void buy(double money, WebService service); public void SetAmazon(WebService amazon); public void SetEbay(WebService ebay); } abstract class WebService { protected WebServiceMediator mediator; public abstract void SetMediator(WebServiceMediator mediator); public abstract void buyService(double money); public abstract void search(double money); } class ConcreteServiceMediator implements WebServiceMediator { private WebService amazon; private WebService ebay; public ConcreteServiceMediator() { amazon = null; ebay = null; } public void SetAmazon(WebService amazon) { this.amazon = amazon; } public void SetEbay(WebService ebay) { this.ebay = ebay; } public void buy(double money, WebService service) { if (service == amazon) amazon.search(money); else ebay.search(money); } } class Amazon extends WebService { public void SetMediator(WebServiceMediator mediator) { this.mediator = mediator; } public void buyService(double money) { mediator.buy(money, this); } public void search(double money) { System.out.println(\u0026#34;Amazon receive：\u0026#34; + money); } } class Ebay extends WebService { public void SetMediator(WebServiceMediator mediator) { this.mediator = mediator; } public void buyService(double money) { mediator.buy(money, this); } public void search(double money) { System.out.println(\u0026#34;Ebay receive：\u0026#34; + money); } } 範例 2 兩個同事之間通訊\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 public class MediatorPattern { public static void main(String[] args) { ConcreteMediator m = new ConcreteMediator(); Colleague1 c1 = new Colleague1(m); Colleague2 c2 = new Colleague2(m); m.setC1(c1); m.setC2(c2); c1.sendMessage(\u0026#34;hello\u0026#34;); c2.sendMessage(\u0026#34;hi\u0026#34;); } } abstract class Colleague{ protected Mediator mediator; } class Colleague1 extends Colleague{ public Colleague1(Mediator mediator){ this.mediator = mediator; } public void sendMessage(String message){ mediator.sendMessage(message, this); } public void Notify(String message){ System.out.println(\u0026#34;Colleague1 received: \u0026#34; + message); } } class Colleague2 extends Colleague{ public Colleague2(Mediator mediator){ this.mediator = mediator; } public void sendMessage(String message){ mediator.sendMessage(message, this); } public void Notify(String message){ System.out.println(\u0026#34;Colleague2 received: \u0026#34; + message); } } abstract class Mediator{ public abstract void sendMessage(String message, Colleague c); } class ConcreteMediator extends Mediator{ // 因為此範例物件很少，所以直接定義 private Colleague1 c1; private Colleague2 c2; // 如果同事很多 // List\u0026lt;Colleague\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); // public void Add(Colleague c){ // list.add(c); // } public void setC1(Colleague1 c1){ this.c1 = c1; } public void setC2(Colleague2 c2){ this.c2 = c2; } @Override public void sendMessage(String message, Colleague c){ if(c == c1){ // 讓同事 2 收到消息 c2.Notify(message); }else{ // 讓同事 1 收到消息 c1.Notify(message); } } } ","date":"2023-10-15T17:14:26+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/128/","title":"中介者模式"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 Iterator Pattern 物件行為型模式\n意圖 提供一種方法順序存取一個聚合物件中的各個元素，而不需要暴露該物件的內部表示。\n結構 其中：\nIterator (迭代器) 定義存取與走訪元素的介面。 ConcreteIterator (具體迭代器) 實作迭代器介面；對該聚合走訪時追蹤目前位置。 Aggregate (聚合) 定義建立對應迭代器物件的介面。 ConcreteAggregate (具體聚合) 實作建立對應迭代器的介面，該操作回傳 ConcreteIterator 的一個適當實例。 適用性 Iterator 模式適用於：\n存取一個聚合物件的內容而無需暴露它的內部表示。 支援對聚合物件的多種走訪。 為走訪不同的聚合結構提供一個統一的介面。 利用 Java 已實作的迭代器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 import java.util.ArrayList; import java.util.Iterator; import java.util.List; public class IteratorPattern { public static void main(String[] args) { List\u0026lt;Book\u0026gt; bookList = new ArrayList\u0026lt;\u0026gt;(); String[] books = {\u0026#34;Linear Algebra\u0026#34;, \u0026#34;Algorithm\u0026#34;}; double[] prices = {25.8, 29.8}; for(int i = 0; i \u0026lt; 2; i++){ bookList.add(new Book(books[i], prices[i])); } // 存取元素 1 for(int i = 0; i \u0026lt; bookList.size(); i++){ Book book = bookList.get(i); System.out.println(\u0026#34;name: \u0026#34; + book.getName() + \u0026#34; price: \u0026#34; + book.getPrice()); } // 存取元素 2 System.out.println(\u0026#34;=====222=====\u0026#34;); for(Book book : bookList){ System.out.println(\u0026#34;name: \u0026#34; + book.getName() + \u0026#34; price: \u0026#34; + book.getPrice()); } // 存取元素 3 迭代器 System.out.println(\u0026#34;=====333=====\u0026#34;); Iterator iterator = bookList.iterator(); while (iterator.hasNext()){ Book book = (Book) iterator.next(); System.out.println(\u0026#34;name: \u0026#34; + book.getName() + \u0026#34; price: \u0026#34; + book.getPrice()); } } } class Book{ private String name; private double price; public Book(String name, double price){ this.name = name; this.price = price; } public double getPrice() { return price; } public String getName() { return name; } } 範例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 import javax.sound.midi.Soundbank; import java.util.ArrayList; import java.util.List; public class IteratorPattern { public static void main(String[] args) { BookAggregate bookAggregate = new BookAggregate(); String[] books = {\u0026#34;Linear Algebra\u0026#34;, \u0026#34;Algorithm\u0026#34;}; double[] prices = {25.8, 29.8}; for(int i = 0; i \u0026lt; 2; i++){ bookAggregate.Add(new Book(books[i], prices[i])); } Iterator iterator = bookAggregate.CreateIterator(); while(iterator.hasNext()){ Book book = (Book)iterator.next(); System.out.println(\u0026#34;name: \u0026#34; + book.getName() + \u0026#34; price: \u0026#34; + book.getPrice()); } } } interface Iterator{ public boolean hasNext(); public Object next(); } class BookIterator implements Iterator{ private int index; private BookAggregate bookAggregate; public BookIterator(BookAggregate bookAggregate){ this.index = 0; this.bookAggregate = bookAggregate; } @Override public boolean hasNext(){ if (index \u0026lt; bookAggregate.getSize()) return true; return false; } @Override public Object next(){ Object obj = bookAggregate.get(index); index++; return obj; } } interface Aggregate{ public Iterator CreateIterator(); } class BookAggregate implements Aggregate{ private List\u0026lt;Book\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); public void Add(Book book){ list.add(book); } public Book get(int index){ return list.get(index); } public int getSize(){ return list.size(); } @Override public Iterator CreateIterator(){ return new BookIterator(this); } } class Book{ private String name; private double price; public Book(String name, double price){ this.name = name; this.price = price; } public double getPrice() { return price; } public String getName() { return name; } } ","date":"2023-10-12T09:09:24+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/127/","title":"迭代器模式"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 解譯器模式 (Interpreter Pattern) 類行為型模式\n意圖 給定一種語言，定義其文法的一種表示法，並定義一個解譯器，此解譯器會使用該表示法來解譯語言中的句子。\n結構 其中：\nAbstractExpression 宣告一個程式的解譯操作，此介面為抽象語法樹中所有節點所共享。 TerminalExpression 實作與文法中終端符號相關聯的解譯操作；一個句子中的每個終端符號需要該類別的一個實例。 NonterminalExpression 對文法中的每一條規則都需要一個 NonterminalExpression 類別；為每個符號都維護一個 AbstractExpression 類型的實例變數；為文法中的非終端符號實作解譯 (Interpret) 操作。 Context 包含解譯器之外的一些全域資訊。 Client 建構 (或被給定) 表示該文法所定義語言中一個特定句子的抽象語法樹，該抽象語法樹由 NonterminalExpression 和 TerminalExpression 的實例組裝而成；呼叫解譯操作。 適用性 解譯器模式適用於當有一種語言需要解譯執行，且可將該語言中的句子表示為一個抽象語法樹時，以下情況效果最佳：\n該文法簡單。 效率不是一個關鍵問題。 範例 檢查字串：某區域的某人員 (someone of ? region)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 import java.util.*; public class InterpreterPattern { public static void main(String[] args) { Context context = new Context(); context.check(\u0026#34;developer of A region\u0026#34;); } } class Context{ private String[] regions = {\u0026#34;A region\u0026#34;, \u0026#34;B region\u0026#34;, \u0026#34;C region\u0026#34;}; private String[] persons = {\u0026#34;developer\u0026#34;, \u0026#34;tester\u0026#34;}; private NonterminalExpression nte; public Context(){ TerminalExpression region = new TerminalExpression(regions); TerminalExpression person = new TerminalExpression(persons); nte = new NonterminalExpression(region, person); } public void check(String info){ boolean bool = nte.Interpret(info); if(bool){ System.out.println(\u0026#34;正確\u0026#34;); }else { System.out.println(\u0026#34;錯誤\u0026#34;); } } } interface Expression{ public boolean Interpret(String info); } class NonterminalExpression implements Expression{ TerminalExpression region; TerminalExpression person; public NonterminalExpression(TerminalExpression region, TerminalExpression person){ this.person = person; this.region = region; } @Override public boolean Interpret(String info){ String[] str = info.split(\u0026#34; of \u0026#34;); // \u0026#34;developer of A region\u0026#34; --\u0026gt; str = {\u0026#34;developer\u0026#34;, \u0026#34;A region\u0026#34;} return region.Interpret(str[1]) \u0026amp;\u0026amp; person.Interpret(str[0]); } } class TerminalExpression implements Expression{ private Set\u0026lt;String\u0026gt; set = new HashSet\u0026lt;\u0026gt;(); public TerminalExpression(String[] data){ for(String str : data){ set.add(str); } } @Override public boolean Interpret(String info){ return set.contains(info); } } ","date":"2023-10-09T17:31:58+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/126/","title":"解譯器模式"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 Command Pattern 物件行為模式\n目的 將一個請求封裝成一個物件，以便能用不同的請求對客戶端進行參數化；對請求排隊或記錄請求日誌，以及支援可撤銷的操作\n結構 其中：\nCommand 宣告執行操作的介面 ConcreteCommand 將一個接收者物件綁定到一個動作；呼叫接收者相對應的操作，以實作 Execute Client 建立一個具體命令物件並設定它的接收者 Invoker 要求該命令執行這個請求 Receiver 知道如何實施與執行一個請求相關的操作。任何類別都可能作為一個接收者 適用性 Command 模式適用於：\n抽象出待執行的動作以參數化某物件 在不同的時刻指定、排列和執行請求 支援取消操作 支援修改日誌 用建構在基本操作上的高階操作來建構一個系統 範例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 public class CommandPattern { public static void main(String[] args) { // 接收者 物件 電視機 Tv tv = new Tv(); // 命令物件 Command oncommand = new OnCommand(tv); Command offcommand = new OffCommand(tv); // 請求者 Invoker invoker = new Invoker(); // 開機 invoker.setCommand(oncommand); invoker.Execute(); // 關機 invoker.setCommand(offcommand); invoker.Execute(); } } class Invoker{ // 請求者 private Command command; // 命令 public void setCommand(Command command){ // 設定請求者 的 請求的命令 this.command = command; } public void Execute(){ // 執行命令 command.Execute(); } } interface Command{ // 命令介面 public void Execute(); // 執行命令 } class OnCommand implements Command{ // 開機命令 private Tv tv; public OnCommand(Tv tv){ this.tv = tv; } @Override public void Execute(){ tv.OnAction(); } } class OffCommand implements Command{ // 關機命令 private Tv tv; public OffCommand(Tv tv){ this.tv = tv; } @Override public void Execute(){ tv.OffAction(); } } class Tv{ // 接收者 電視機 public void OnAction(){ System.out.println(\u0026#34;Tv On\u0026#34;); } public void OffAction(){ System.out.println(\u0026#34;Tv Off\u0026#34;); } } ","date":"2023-09-10T15:26:55+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/125/","title":"命令模式"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 Chain of Responsibility Pattern 物件行為模式\n目的 使多個物件都有機會處理請求，以避免請求的發送者與接收者之間的耦合關係。將這些物件串聯成一條鏈，並沿著這條鏈傳遞該請求，直到有某個物件處理它為止。\n結構 其中：\nHandler 定義一個處理請求的介面；(可選) 實作後續鏈 ConcreteHandler 處理它所負責的請求；可存取它的後繼者；如果可以處理該請求，就處理它，否則將請求轉發給後繼者 Client 向鏈上的具體處理者 (ConcreteHandler) 物件提交請求 適用性 Chain of Responsibility 模式適用於：\n有多個物件可以處理一個請求，哪個物件處理該請求會於執行時自動確定 想在不明確指定接收者的情況下，向多個物件中的一個提交一個請求 可處理一個請求的物件集合應被動態指定 範例 學生請假，先找輔導員，輔導員處理不了就轉呈院長，院長處理不了就轉呈校長。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 public class ChainOfResponsibilityPattern { public static void main(String[] args) { // 實例化物件 Handler counsellor = new Counsellor(); Handler president = new President(); Handler schoolmaster = new Schoolmaster(); // 設定物件下一級 counsellor.next = president; president.next = schoolmaster; schoolmaster.next = null; // 向輔導員請求 7 天假期 counsellor.HandlerRequest(7); } } abstract class Handler{ protected Handler next; public void setNext(Handler next){ this.next = next; } // 學生請假請求 public abstract void HandlerRequest(int request); } class Counsellor extends Handler{ // 輔導員 審批小於等於 7 天的假 @Override public void HandlerRequest(int request){ if (request \u0026lt;= 7) { System.out.println(\u0026#34;Counsellor Agree!\u0026#34;); } else { if(next != null){ next.HandlerRequest(request); } else { System.out.println(\u0026#34;Counsellor Refuse!\u0026#34;); } } } } class President extends Handler{ // 院長 審批小於等於 15 天的假 @Override public void HandlerRequest(int request){ if (request \u0026lt;= 15) { System.out.println(\u0026#34;President Agree!\u0026#34;); } else { if(next != null){ next.HandlerRequest(request); } else { System.out.println(\u0026#34;President Refuse!\u0026#34;); } } } } class Schoolmaster extends Handler{ // 校長 審批小於等於 30 天的假 @Override public void HandlerRequest(int request){ if (request \u0026lt;= 30) { System.out.println(\u0026#34;Schoolmaster Agree!\u0026#34;); } else { if(next != null){ next.HandlerRequest(request); } else { System.out.println(\u0026#34;Schoolmaster Refuse!\u0026#34;); } } } } ","date":"2023-09-09T07:02:55+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/124/","title":"責任鏈模式"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 Proxy Pattern 物件結構型模式\n意圖 為其他物件提供一種代理以控制對這個物件的存取。\n結構 其中：\nProxy 保存一個參照使得代理可以存取實體；提供一個與 Subject 的介面相同的介面，使代理可以用來代替實體；控制對實體的存取，並可能負責建立和刪除它。 Subject 定義 RealSubject 和 Proxy 的共用介面，這樣就在任何使用 RealSubject 的地方都可以使用 Proxy。 RealSubject 定義 Proxy 所代表的實體。 適用性 Proxy 模式適用於在需要比較通用和複雜的物件指標代替簡單指標的時候，常見的情況有：\n遠端代理 (Remote Proxy) 為一個物件在不同位址空間提供區域代表。 虛擬代理 (Virtual Proxy) 根據需要對原始物件進行存取，用於物件應該有不同的存取權限時。 保護代理 (Protection Proxy) 控制對原始物件的存取，用於物件應該有不同的存取權限時。 智慧型參照 (Smart Reference) 取代了簡單的指標，它在存取物件時執行了一些附加操作。典型用途包括：對指向實際物件的參照計數，這樣當該物件沒有參照時，可以被自動釋放；當第一次參照一個永續物件時，將它裝入記憶體；在存取一個實際物件前，檢查是否已經鎖定了它，以確保其他物件不能改變它。 範例 仲介代理買東西\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 public class ProxyPattern { public static void main(String[] args) { RealSubject realSubject = new RealSubject(); Proxy proxy = new Proxy(realSubject); proxy.buy(); } } interface Subject{ public void buy(); } class Proxy implements Subject{ protected RealSubject realSubject; public Proxy(RealSubject realSubject){ this.realSubject = realSubject; } @Override public void buy() { System.out.println(\u0026#34;prepare\u0026#34;); realSubject.buy(); System.out.println(\u0026#34;complete\u0026#34;); } } class RealSubject implements Subject{ @Override public void buy() { System.out.println(\u0026#34;Money\u0026#34;); } } ","date":"2023-09-08T12:15:26+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/123/","title":"代理模式"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 Flyweight Pattern 物件結構型模式\n意圖 運用共享技術有效地支援大量細粒度的物件。\n結構 其中：\nFlyweight 描述一個介面，通過這個介面 Flyweight 可以接受並作用於外部狀態。\nConcreteFlyweight 實作 Flyweight 介面，並為內部狀態 (如果有) 增加儲存空間。ConcreteFlyweight 物件必須是可共享的。它所儲存的狀態必須是內部的，即它必須獨立於 ConcreteFlyweight 物件的場景。\n並非所有的 Flyweight 子類別都需要被共享。Flyweight 介面使共享成為可能，但它並不強制共享。在 Flyweight 物件結構的某些層次，UnsharedConcreteFlyweight 物件通常將 ConcreteFlyweight 物件作為子節點。\nFlyweightFactory 建立並管理 Flyweight 物件；確保合理地共享 Flyweight，當使用者請求一個 Flyweight 時，FlyweightFactory 物件提供一個已建立的執行個體，或者在不存在時建立一個執行個體。\nClient 維持一個對 Flyweight 的參照；計算或儲存一個或多個 Flyweight 的外部狀態。\n適用性 Flyweight 模式適用於：\n一個應用程式使用了大量的物件。 完全由於使用大量的物件，造成很大的儲存開銷。 物件的大多數狀態都可變為外部狀態。 如果刪除物件的外部狀態，那麼可以用相對較少的共享物件取代很多組物件。 應用程式不依賴於物件識別。由於 Flyweight 物件可以被共享，所以對於概念上明顯有別的物件，識別測試將傳回真值。 範例 1 現要開發一個網路圍棋程式，允許多個玩家連線下棋。由於只有一台伺服器，為節省記憶體空間，採用享元模式實作該程式，類別圖如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 import java.util.ArrayList; enum PieceColor {BLACK, WHITE} // 棋子顏色 class PiecePods{ // 棋子位置 private int x; private int y; public PiecePods(int a, int b){ x = a; y = b; } public int getX(){ return x; } public int getY() { return y; } } abstract class Piece{ // 棋子定義 protected PieceColor m_color; // 顏色 protected PiecePods m_pos; // 位置 public Piece(PieceColor color, PiecePods pos){ this.m_color = color; this.m_pos = pos; } public abstract void draw(); } class BlackPiece extends Piece{ public BlackPiece(PieceColor color, PiecePods pos){ super(color, pos); } @Override public void draw(){ System.out.println(\u0026#34;Draw a black piece\u0026#34;); } } class WhitePiece extends Piece{ public WhitePiece(PieceColor color, PiecePods pos){ super(color, pos); } @Override public void draw(){ System.out.println(\u0026#34;Draw a white piece\u0026#34;); } } class PieceBoard{ // 棋盤上已有的棋子 private static final ArrayList\u0026lt;Piece\u0026gt; m_arrayPiece = new ArrayList\u0026lt;\u0026gt;(); private String m_blackName; // 黑方名稱 private String m_whiteName; // 白方名稱 public PieceBoard(String black, String white){ m_blackName = black; m_whiteName = white; } // 一步棋，在棋盤上放一顆棋子 public void setPiece(PieceColor color, PiecePods pos){ Piece piece = null; if(color == PieceColor.BLACK){ // 放黑子 piece = new BlackPiece(color, pos); System.out.println(m_blackName + pos.getX() + pos.getY()); piece.draw(); }else{ // 放白子 piece = new WhitePiece(color, pos); System.out.println(m_whiteName + pos.getX() + pos.getY()); piece.draw(); } m_arrayPiece.add(piece); } } 範例 2 五子棋\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 public class FlyWeightPattern { public static void main(String[] args) { PieceFactory factory = new PieceFactory(); Piece wp1 = factory.getPiece(0); wp1.draw(2023, 0527); } } class PieceFactory{ private Piece[] pieces = {new WhitePiece(), new BlackPiece()}; public Piece getPiece(int key){ if(key == 0) return pieces[0]; else return pieces[1]; } } abstract class Piece{ protected String color; public abstract void draw(int x, int y); } class WhitePiece extends Piece{ public WhitePiece(){ this.color = \u0026#34;white\u0026#34;; } @Override public void draw(int x, int y){ System.out.println(\u0026#34;draw a \u0026#34; + this.color + \u0026#34; piece x: \u0026#34; + x + \u0026#34; y: \u0026#34; + y); } } class BlackPiece extends Piece{ public BlackPiece(){ this.color = \u0026#34;Black\u0026#34;; } @Override public void draw(int x, int y){ System.out.println(\u0026#34;draw a \u0026#34; + this.color + \u0026#34; piece x: \u0026#34; + x + \u0026#34; y: \u0026#34; + y); } } 範例 3 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 import java.util.HashMap; import java.util.Map; import java.util.Random; public class FlyWeightPattern { public static void main(String[] args) { ShapeFactory sf = new ShapeFactory(); Random r = new Random(); String[] colors = {\u0026#34;red\u0026#34;, \u0026#34;blue\u0026#34;, \u0026#34;green\u0026#34;, \u0026#34;white\u0026#34;, \u0026#34;black\u0026#34;}; for (int i = 0; i \u0026lt; 10; i++) { int x = r.nextInt(colors.length); Shape s = sf.getShape(colors[x]); s.draw(r.nextInt(2023), r.nextInt(527)); } } } class ShapeFactory{ private Map\u0026lt;String, Shape\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); public Shape getShape(String key){ if (!map.containsKey(key)) { map.put(key, new Circle(key)); System.out.println(\u0026#34;create new circle, color: \u0026#34; + key); } return map.get(key); } } abstract class Shape{ protected String color; public abstract void draw(int x, int y); } class Circle extends Shape{ public Circle(String color){ this.color = color; } @Override public void draw(int x, int y) { System.out.println(\u0026#34;draw a \u0026#34; + this.color + \u0026#34; circle x: \u0026#34; + x + \u0026#34; y: \u0026#34; + y); } } ","date":"2023-09-07T13:54:55+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/122/","title":"享元模式"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 Facade Pattern 物件結構型模式\n意圖 為子系統中的一組介面提供一個一致的界面，Facade 模式定義了一個高層介面，這個介面使得這一子系統更加容易使用。\n結構 其中：\nFacade 知道哪些子系統類別負責處理請求；將用戶的請求代理給適當的子系統物件。 Subsystem classes 實作子系統的功能；處理由 Facade 物件指派的任務；沒有 Facade 的任何相關資訊，即沒有指向 Facade 的指標。 適用性 Facade 模式適用於：\n要為一個複雜子系統提供一個簡單介面時，子系統往往因為不斷演化而變得越來越複雜。大多數模式使用時都會產生更多更小的類別，這使得子系統更具有可重用性，也更容易對子系統進行客製化，但也給那些不需要客製化子系統的用戶帶來一些使用上的困難。Facade 可以提供一個簡單的預設視圖，這一視圖對大多數用戶來說已經足夠，而那些需要更多客製化性的用戶可以越過 Facade 層。 用戶程式與抽象類別的實作部分之間存在著很大的相依性。引入 Facade 將這個子系統與用戶以及其他的子系統分離，可以提高子系統的獨立性和可移植性。 當需要構建一個階層結構的子系統時，使用 Facade 模式定義子系統中每層的進入點。如果子系統之間是相互相依的，則可以讓它們僅通過 Facade 進行通訊，從而簡化了它們之間的相依關係。 例子 1 以醫院為例，就醫時患者需要與醫院不同的職能部門互動，完成掛號、門診、取藥等操作。為簡化就醫流程，可以設置一個接待員的職位，代患者完成上述就醫步驟，患者只需要與接待員互動即可。\nJava 程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 import java.util.*; interface Patient { public String getName(); } interface Disposer { public void dispose(Patient patient); } class Registry implements Disposer { // 掛號 public void dispose(Patient patient) { System.out.println(\u0026#34;I am registering...\u0026#34; + patient.getName()); } } class Doctor implements Disposer { // 醫生門診 public void dispose(Patient patient) { System.out.println(\u0026#34;I am diagnosing...\u0026#34; + patient.getName()); } } class Pharmacy implements Disposer { // 取藥 public void dispose(Patient patient) { System.out.println(\u0026#34;I am medicine... \u0026#34; + patient.getName()); } } class Facade { private Patient patient; public Facade(Patient patient) { this.patient = patient; } void dispose() { Registry registry = new Registry(); Doctor doctor = new Doctor(); Pharmacy pharmacy = new Pharmacy(); registry.dispose(patient); doctor.dispose(patient); pharmacy.dispose(patient); } } class ConcretePatient implements Patient { private String name; public ConcretePatient(String name) { this.name = name; } public String getName() { return name; } } public class FacadeTest { public static void main(String[] args) { Patient patient = new ConcretePatient(\u0026#34;zst\u0026#34;); Facade f = new Facade(patient); f.dispose(); } } C++ 程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; class Patient { public: virtual string getName() = 0; }; class Disposer { public: virtual void dispose(Patient *patient) = 0; }; class Registry : public Disposer { // 掛號 public: void dispose(Patient *patient) { cout \u0026lt;\u0026lt; \u0026#34;I am registering....\u0026#34; \u0026lt;\u0026lt; patient-\u0026gt;getName() \u0026lt;\u0026lt; endl; } }; class Doctor : public Disposer { // 醫生門診 public: void dispose(Patient *patient) { cout \u0026lt;\u0026lt; \u0026#34;I am diagnosing....\u0026#34; \u0026lt;\u0026lt; patient-\u0026gt;getName() \u0026lt;\u0026lt; endl; } }; class Pharmacy : public Disposer { // 取藥 public: void dispose(Patient *patient) { cout \u0026lt;\u0026lt; \u0026#34;I am giving medicine....\u0026#34; \u0026lt;\u0026lt; patient-\u0026gt;getName() \u0026lt;\u0026lt; endl; } }; class Facade { private: Patient *patient; public: Facade(Patient *patient) { this-\u0026gt;patient = patient; } void dispose() { Registry *registry = new Registry(); Doctor *doctor = new Doctor(); Pharmacy *pharmacy = new Pharmacy(); registry-\u0026gt;dispose(patient); doctor-\u0026gt;dispose(patient); pharmacy-\u0026gt;dispose(patient); } }; class ConcretePatient : public Patient { private: string name; public: ConcretePatient(string name) { this-\u0026gt;name = name; } string getName() { return name; } }; int main() { Patient *patient = new ConcretePatient(\u0026#34;zst\u0026#34;); Facade *f = new Facade(patient); f-\u0026gt;dispose(); return 0; } 例子 2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 public class FacadePattern { public static void main(String[] args) { Facade f = new Facade(); f.methodA(); } } class Facade{ SubSystemOne s1; SubSystemTwo s2; SubSystemThree s3; public Facade(){ s1 = new SubSystemOne(); s2 = new SubSystemTwo(); s3 = new SubSystemThree(); } public void methodA(){ s1.Operation(); } public void methodB(){ s2.Operation(); } public void methodC(){ s3.Operation(); } } class SubSystemOne{ public void Operation(){ System.out.println(\u0026#34;SubSystemOne\u0026#34;); } } class SubSystemTwo{ public void Operation(){ System.out.println(\u0026#34;SubSystemTwo\u0026#34;); } } class SubSystemThree{ public void Operation(){ System.out.println(\u0026#34;SubSystemThree\u0026#34;); } } ","date":"2023-09-06T03:02:02+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/121/","title":"外觀模式"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 Decorator Pattern 物件結構型模式\n目的 動態地為一個物件新增一些額外的職責。就增加功能而言，Decorator 模式比產生子類別更具彈性。\n結構 其中：\nComponent 定義一個物件介面，可以動態地為這些物件新增職責。 ConcreteComponent 定義一個物件，可以為這個物件新增一些職責。 Decorator 維持一個指向 Component 物件的指標，並定義一個與 Component 介面一致的介面。 ConcreteDecorator 向元件新增職責。 適用性 Decorator 模式適用於：\n在不影響其他物件的情況下，以動態、透明的方式為單一物件新增職責。 處理那些可以撤銷的職責。 當無法採用產生子類別的方式進行擴充時，一種情況是，可能有大量獨立的擴展，為支援每一種組合將產生大量的子類別，使得子類別數目呈爆炸性增長。另一種情況可能是，由於類別定義被隱藏，或類別定義不能用於產生子類別。 範例 1 某間咖啡店在販售咖啡時，可以根據顧客的要求在其中加入各種配料，咖啡店會根據所加入的配料來計算費用。咖啡店所供應的咖啡及配料種類和價格如下表所示。\n現採用裝飾器模式來實現計算費用的功能，得到如下類別圖。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 import java.util.*; abstract class Beverage { // 飲料 String description = \u0026#34;Unknown Beverage\u0026#34;; public String getDescription() { return description; } public abstract int cost(); } abstract class CondimentDecorator extends Beverage { // 配料 Beverage beverage; } class Espresso extends Beverage { // 濃縮咖啡 private final int ESPRESSO_PRICE = 25; public Espresso() { description = \u0026#34;Espresso\u0026#34;; } public int cost() { return ESPRESSO_PRICE; } } class DarkRoast extends Beverage { // 深度烘焙咖啡 private final int DARKROAST_PRICE = 20; public DarkRoast() { description = \u0026#34;DarkRoast\u0026#34;; } public int cost() { rcturn DARKROAST PRICE; } } class Mocha extends CondimentDecorator { // 摩卡 private final int MOCHA_PRICE = 10; public Mocha (Beverage beverage) { this.beverage = beverage; } public String getDescription() { return beverage.getDescription() + \u0026#34;, Mocha\u0026#34;; } public int cost() { return MOCHA_PRICE + beverage.cost(); } } class Whip extends CondimentDecorator { // 奶泡 private final int WHIP_PRICE = 8; public Whip (Beverage beverage) { this.beverage = beverage; } public String getDescription() { return beverage.getDescription() + \u0026#34;, Whip\u0026#34;; } public int cost() { return WHIP_PRICE + beverage.cost(); } } public class Coffee { public static void main(String args[]) { Beverage beverage = new DarkRoast(); beverage = new Mocha(beverage); beverage = new Whip(beverage); System.out.println(beverage.getDescription() +\u0026#34; NT$ \u0026#34;+ beverage.cost()); } } 範例 2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 public class DecoratorPattern { public static void main(String[] args) { Person p = new Student(\u0026#34;Mike\u0026#34;); p.Operation(); System.out.println(\u0026#34;\\n--------------------\u0026#34;); p = new DecoratorA(p); p.Operation(); System.out.println(\u0026#34;\\n--------------------\u0026#34;); p = new DecoratorB(p); p.Operation(); // No.2 Person p2 = new DecoratorB(new Student(\u0026#34;Jane\u0026#34;)); } } abstract class Person{ protected String name; public abstract void Operation(); } class Student extends Person{ public Student(String name){ this.name = name; } @Override public void Operation(){ System.out.print(name + \u0026#34; 學習\u0026#34;); } } abstract class Decorator extends Person{ protected Person person; } class DecoratorA extends Decorator{ public DecoratorA(Person person){ this.person = person; } @Override public void Operation() { person.Operation(); System.out.print(\u0026#34; 玩樂\u0026#34;); } } class DecoratorB extends Decorator{ public DecoratorB(Person person){ this.person = person; } @Override public void Operation() { person.Operation(); System.out.print(\u0026#34; 考試\u0026#34;); } } ","date":"2023-09-05T21:45:45+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/120/","title":"裝飾器模式"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 Composite Pattern 物件結構型模式\n目的 將物件組合成樹狀結構，以表示「部分 - 整體」的層級結構。組合模式讓使用者對個別物件與組合物件的使用方式保持一致性。\n結構 其中：\nComponent 為組合中的物件宣告介面；在適當情況下實作所有類別共有介面的預設行為；宣告一個介面用於存取及管理 Component 的子元件；(可選) 在遞迴結構中定義一個介面，用於存取一個父元件，並在合適的情況下實作它。 Leaf 在組合中表示葉節點物件，葉節點沒有子節點；在組合中定義圖元物件的行為。 Composite 定義所有子元件的那些元件的行為；儲存子元件；在 Component 介面中實作與子元件相關的操作。 Client 透過 Component 介面操控組合元件的物件。 適用性 Composite 模式適用於：\n想表示物件的部分 - 整體層級結構。 希望使用者忽略組合物件與個別物件的不同，使用者將統一地使用組合結構中的所有物件。 範例 1 某公司的組織結構圖如下圖所示：\n現在採用組合（Composition）設計模式來建構該公司的組織結構，得到如下圖所示的類別圖：\n其中 Company 為抽象類別，定義了在組織結構圖上新增（Add）和刪除（Delete）分公司/辦事處或者部門的方法介面。類別 ConcreteCompany 表示具體的分公司或者辦事處，分公司或辦事處下可以設定不同的部門。類別 HRDepartment 和 FinanceDepartment 分別表示人力資源部和財務部。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 import java.util.*; abstract class Company { protected String name; public Company(String name) { this.name = name; } public abstract void Add(Company c); // 增加子公司、辦事處或部門 public abstract void Delete(Company c); // 刪除子公司、辦事處或部門 } class ConcreteCompany extends Company { private List\u0026lt;Company\u0026gt; children = new ArrayList\u0026lt;Company\u0026gt;(); // 儲存子公司、辦事處或部門 public ConcreteCompany(String name) { super(name); } public void Add(Company c) {children.add(c); } public void Delete(Company c) {children.remove(c); } } class HRDepartment extends Company { public HRDepartment(String name) { super(name); } // 其他程式碼省略 } class FinanceDepartment extends Company { public FinanceDepartment(String name) { super(name); } // 其他程式碼省略 } public class Test { public static void main(String[] args) { ConcreteCompany root = new ConcreteCompany(\u0026#34;北京總公司\u0026#34;); root.Add(new HRDepartment(\u0026#34;總公司人力資源部\u0026#34;)); root.Add(new FinanceDepartment(\u0026#34;總公司財務部\u0026#34;)); ConcreteCompany comp = new ConcreteCompany(\u0026#34;上海分公司\u0026#34;); comp.Add(new HRDepartment(\u0026#34;上海分公司人力資源部\u0026#34;)); comp.Add(new FinanceDepartment(\u0026#34;上海分公司財務部\u0026#34;)); root.Add(comp); ConcreteCompany comp1 = new ConcreteCompany(\u0026#34;南京辦事處\u0026#34;); comp1.Add(new HRDepartment(\u0026#34;南京辦事處人力資源部\u0026#34;)); comp1.Add(new FinanceDepartment(\u0026#34;南京辦事處財務部\u0026#34;)); comp.Add(comp1); // 其他程式碼省略 } } 範例 2 層疊選單是視窗風格的軟體系統中經常採用的一種系統功能組織方式。層疊選單中包含的可能是一個選單項目（直接對應某個功能），也可能是一個子選單，現在採用組合（composite）設計模式實作層疊選單，得到如下圖所示的類別圖：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 import java.util.*; abstract class MenuComponent { // 構成層疊選單的元素 protected String name; // 選單項目或子選單名稱 public void printName() { System.out.println(name); } public abstract boolean addMenuElement(MenuComponent element) ; public abstract boolean removeMenuElement(MenuComponent element); public abstract List\u0026lt;MenuComponent\u0026gt; getElement(); } class MenuItem extends MenuComponent { public MenuItem(String name) { this.name=name; } public boolean addMenuElement(MenuComponent element) { return false; } public boolean removeMenuElement(MenuComponent element) { return false; } public List\u0026lt;MenuComponent\u0026gt; getElement(){ return null; } } class Menu extends MenuComponent { // 修正 MemuComponent 為 MenuComponent private List\u0026lt;MenuComponent\u0026gt; elementsList; public Menu(String name) { this.name = name; this.elementsList = new ArrayList\u0026lt;MenuComponent\u0026gt;(); // 修正 elementList } public boolean addMenuElement(MenuComponent element) { return elementsList.add(element); // 修正 elementList } public boolean removeMenuElement(MenuComponent element) { return elementsList.remove(element); // 修正 elementList } public List\u0026lt;MenuComponent\u0026gt; getElement() { return elementsList; } // 修正 elementList } class CompositeTest { public static void main(String[] args) { MenuComponent mainMenu = new Menu(\u0026#34;Insert\u0026#34;); MenuComponent subMenu = new Menu(\u0026#34;Chart\u0026#34;); MenuComponent element = new MenuItem(\u0026#34;On This Sheet\u0026#34;); mainMenu.addMenuElement(subMenu); subMenu.addMenuElement(element); printMenus(mainMenu); } private static void printMenus(MenuComponent ifile) { ifile.printName(); List\u0026lt;MenuComponent\u0026gt; children = ifile.getElement(); if (children == null) return; for(MenuComponent element : children) { // 修正 for 迴圈語法 printMenus(element); } } } 範例 3 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 import java.util.*; public class CompositePattern { public static void main(String[] args) { AbstractFile root = new Folder(\u0026#34;root\u0026#34;); AbstractFile bin = new Folder(\u0026#34;bin\u0026#34;); AbstractFile tmp = new Folder(\u0026#34;tmp\u0026#34;); AbstractFile file = new File(\u0026#34;file\u0026#34;); root.Add(bin); bin.Add(tmp); root.Add(file); // root.Remove(tmp); print(root); } static void print(AbstractFile file){ List\u0026lt;AbstractFile\u0026gt; lf = file.GetChildren(); file.Operation(); // 更簡潔的方法 // if(lf == null) return; // for(AbstractFile i : lf) print(i); if (lf != null) { for (AbstractFile i : lf) { if (i != null) { print(i); } else return; } } else return; } } abstract class AbstractFile{ protected String name; public void Operation(){ System.out.println(name); } public abstract boolean Add(AbstractFile af); public abstract boolean Remove(AbstractFile af); public abstract List\u0026lt;AbstractFile\u0026gt; GetChildren(); } class Folder extends AbstractFile{ private List\u0026lt;AbstractFile\u0026gt; childrenList = new ArrayList\u0026lt;\u0026gt;(); public Folder(String name){ this.name = name; } @Override public boolean Add(AbstractFile af){ return childrenList.add(af); } @Override public boolean Remove(AbstractFile af){ return childrenList.remove(af); } @Override public List\u0026lt;AbstractFile\u0026gt; GetChildren(){ return this.childrenList; } } class File extends AbstractFile{ public File(String name){ this.name = name; } @Override public boolean Add(AbstractFile af){ System.out.println(\u0026#34;Forbidden\u0026#34;); return false; } @Override public boolean Remove(AbstractFile af){ System.out.println(\u0026#34;Forbidden\u0026#34;); return false; } @Override public List\u0026lt;AbstractFile\u0026gt; GetChildren(){ return null; } } ","date":"2023-09-03T15:44:45+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/119/","title":"組合模式"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 Bridge Pattern 物件結構型模式\n目的 將抽象部分與其實作部分分離，讓它們可以獨立地變化\n結構 其中：\nAbstraction 定義抽象類別的介面，維護一個指向 Implementor 類型物件的指標 RefinedAbstraction 擴充由 Abstraction 定義的介面 Implementor 定義實作類別的介面，該介面不一定要與 Abstraction 的介面完全一致；事實上這兩個介面可以完全不同 一般來說，Implementor 介面僅提供基本操作，而 Abstraction 定義了基於這些基本操作的較高層次的操作 ConcreteImplementor 實作 Implementor 介面並定義它的具體實作 適用性 Bridge 模式適用於：\n不希望在抽象和它的實作部分之間有一個固定的綁定關係。例如，這種情況可能是因為，在程式執行時實作部分應該可以被選擇或切換 類別的抽象以及它的實作都應該可以透過生成子類別的方法加以擴充。這是 Bridge 模式使得開發者可以對不同的抽象介面和實作部分進行組合，並分別對它們進行擴充 對一個抽象的實作部分的修改應該對客戶不產生影響，亦即客戶程式碼不必重新編譯 (C++) 想對客戶完全隱藏抽象的實作部分 有許多類別要生成的類別階層結構 想在多個物件間共享實作 (可能使用參考計數) ，但同時要求客戶並不知道這一點 範例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 public class main { public static void main(String[] args) { Product ProductA1 = new ProductA(); Product ProductA2 = new ProductA(); Color red = new Red(); ProductA1.setName(\u0026#34;P-A1\u0026#34;); ProductA1.setColor(red); ProductA1.Operation; Color blue = new Blue(); ProductA1.setName(\u0026#34;P-A2\u0026#34;); ProductA1.setColor(blue); ProductA1.Operation; } } abstract class Product{ private String name; protected Color color; public void setName(String name){ this.name = name; } public String getName(){ this.name = name; } public setColor(Color color){ this.color = color; } public abstract void Operation(); } class ProductA extends Product{ @Override public void Operation(){ color.OperationImp(this.getName()); } } class Color{ public void OperationImp(String name); } class Red extends Color{ @Override public void OperationImp(String name){ System.out.println(name + \u0026#34;: red\u0026#34;) } } class Blue extends Color{ @Override public void OperationImp(String name){ System.out.println(name + \u0026#34;: blue\u0026#34;) } } ","date":"2023-09-02T17:34:34+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/118/","title":"橋接模式"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 轉接器模式 (Adapter Pattern) 類別結構型模式 / 物件結構型模式\n意圖 將一個類別的介面轉換成客戶端期望的另一個介面。轉接器模式使得原本因介面不相容而無法協同運作的類別，能夠一起工作。\n結構 類別轉接器使用多重繼承來匹配一個介面與另一個介面。 物件轉接器仰賴於物件組合。 其中：\nTarget 定義客戶端 (Client) 使用的與特定領域相關的介面。 Client 與符合 Target 介面的物件協同運作。 Adaptee 定義一個已經存在的介面，此介面需要被轉接。 Adapter 將 Adaptee 的介面與 Target 介面進行轉接。 適用性 轉接器模式適用於：\n想使用一個已經存在的類別，但其介面不符合需求。 想建立一個可重複使用的類別，此類別能與其他不相關或無法預期的類別（亦即那些介面可能不一定相容的類別）協同運作。 （僅適用於物件轉接器）想使用一個已經存在的子類別，但不可能對每一個子類別都進行子類化來匹配其介面。物件轉接器可以轉接其父類別的介面。 範例 1 某軟體系統中，已設計並實作了用於顯示地址資訊的類別 Address，現要求提供基於荷蘭語的地址資訊顯示介面。為了實作此需求並考量到日後可能還會出現新的語言介面，決定採用轉接器模式來實作，類別圖如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 public class Adapter { public static void main(String[] args) { Address address = new Address(); DutchAddress dutchAddress = new DutchAddressAdapter(address); System.out.println(\u0026#34;The DutchAddress\u0026#34;); test(dutchAddress); } static void test(DutchAddress dutchAddress){ dutchAddress.plaats(); dutchAddress.postcode(); dutchAddress.straat(); } } class Address{ public void street(){/* 程式碼省略 */} public void zip(){/* 程式碼省略 */} public void city(){/* 程式碼省略 */} } class DutchAddress{ public void straat(){/* 程式碼省略 */} public void postcode(){/* 程式碼省略 */} public void plaats(){/* 程式碼省略 */} } class DutchAddressAdapter extends DutchAddress{ private Address address; public DutchAddressAdapter(Address address){ this.address=address; } @Override public void straat() { address.street(); } @Override public void postcode() { address.zip(); } @Override public void plaats() { address.city(); } } 範例 2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // 因 Java 不支援多重繼承，以下為物件轉接器 public class main{ public static void main(String[] args) { Target target = new Adapter(); target.Request(); } } class Target{ public void Request(){ System.out.println(\u0026#34;哈囉\u0026#34;); } } class Adapter extends Target{ private Adaptee a = new Adaptee(); @Override public void Request(){ a.SpecificRequest(); } } class Adaptee{ public void SpecificRequest(){ System.out.println(\u0026#34;嗨\u0026#34;); } } ","date":"2023-09-01T15:03:03+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/117/","title":"轉接器模式"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 以前擁有伺服器的時候雖然有過這個想法，但畢竟只要在伺服器再開一個站點就解決了，並沒有深入研究。如今伺服器到期，將 Blog 搬到 GitHub 上，想要繼續這樣做無疑是不可能的，於是便尋求解決方法。\n失敗的歷程 雖然失敗了，但還是要記錄下來，肯定是我不會用\n之前只是試著玩玩，僅從 DNS 的 CNAME 嘗試後發現不行便放棄了。這次使用網路搜尋「網域名稱定向到路徑 URL」，從第一條搜尋結果 https://cloud.tencent.com/developer/ask/sof/89340 得知工具網站： http://redirect.center/ 例子 從 https://acg.yexca.net 重導向至 https://blog.yexca.net/acg 無法存取\n按網站描述，CNAME 內容應為 blog.yexca.net.opts-slash.acg.opts-https.redirect.center.，但實際效果並未達成，且出現錯誤。\n嘗試了挺多都是報錯，不試了，另尋他法。\n註：網站最後一個介紹有自動生成。\n新工具 使用網路搜尋「redirect center」第三條搜尋結果 https://redirect.name/ 這個工具比那個好用很多，而且有效。\n新例子 從 https://twinkle.yexca.net 重導向至 https://yexca.github.io/MusicPlayer-Twinkle/ 可以存取\n兩條紀錄\n類型 名稱 內容 CNAME twinkle alias.redirect.name TXT _redirect.twinkle Redirects to https://yexca.github.io/MusicPlayer-Twinkle/ 程式碼形式\n1 2 twinkle IN CNAME alias.redirect.name _redirect.twinkle IN TXT \u0026#34;https://yexca.github.io/MusicPlayer-Twinkle/\u0026#34; ","date":"2023-08-28T15:31:01+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/116/","title":"使用 CNAME 將網域名稱重導向至含路徑的 URL"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 Singleton Pattern 物件建立型模式\n目的 確保一個類別僅有一個實例，並提供一個存取它的全域存取點\n結構 其中：\nSingleton 指定一個 Instance 操作，允許客戶端存取它的唯一實例 Instance 是一個類別操作；可能負責建立它自己的唯一實例 適用時機 Singleton 模式適用於：\n當類別只能有一個實例而且客戶端可以從一個眾所皆知的存取點存取它時 當這個唯一實例應該是透過子類別化可擴展的，而且客戶端無須變更程式碼就能使用一個擴展的實例時 範例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public class main{ // s1 和 s2 是同一個實例 (位址相同) Singleton s1 = Singleton.getInstance(); Singleton s2 = Singleton.getInstance(); } class Singleton{ private int num = 2023; public void setNum(int num){ this.num = num; } public int getNum(){ return this.num; } private Singleton(){} private static Singleton instance = new Singleton(); public static Singleton getInstance(){ return instance; } } ","date":"2023-07-05T13:58:25+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/115/","title":"單例模式"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 最近玩 ミリシタ 時連不上，於是尋找解決方法 (順便試試 Spotify 的嵌入效果，這個佈景主題不支援直接解析 H5，懶得改了)\n網域 1 theaterdays.appspot.com 這裡原先嵌入了 雨宿り 的 Spotify 的歌\n最近雨宿りの曲が大好きので、よく聞いていた。Last.fm で過去30日間雨宿りの「猫かぶり」は人気トラック一番になった。で、トップアーティストじゃない？トップアーティスト、もちろん湊あくあ！　草、ミリシタの文章で何を書いたか、どっちもミリシタと関係ないもん！\nclash 透過設定群組來進行更好的選擇\n首先設定 JP 群組\n1 2 3 4 5 6 proxy-groups: - name: JP type: select proxies: - your jp proxy name - your jp proxy name 然後新增規則\n1 2 rules: - DOMAIN-SUFFIX,theaterdays.appspot.com,JP ","date":"2023-06-09T23:32:09+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/114/","title":"アイドルマスター ミリオンライブ！的 IP 規則"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 Prototype Pattern 物件建立型模式\n意圖 用原型執行個體指定建立物件的種類，並且透過複製這些原型建立新的物件\n結構 其中：\nPrototype 宣告一個複製自身的介面 ConcretePrototype 實作一個複製自身的操作 Client 讓一個原型複製自身從而建立一個新的物件 適用性 Prototype 模式適用於：\n當一個系統應該獨立於它的產品建立、構成和表示時 當要實例化的類別是在執行期間指定時，例如，透過動態載入 為了避免建立一個與產品類別階層平行的工廠類別階層時 當一個類別的執行個體只能有幾個不同狀態組合中的一種時。建立對應數量的原型並複製它們，可能比每次用合適的狀態手動實例化該類別更方便一些 例子 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 public class main{ Product p1 = new Product(2023, 3.03); System.out.println(p1.getId() + \u0026#34; \u0026#34; + p1.getPrice()); // Product p2 = new Product(2023, 3.03); Product p2 = (Product) p1.Clone(); System.out.println(p2.getId() + \u0026#34; \u0026#34; + p2.getPrice()); } interface Prototype{ public Object Clone(); } class Product implements Prototype{ private int id; private double price; public Product(){} public Product(int id, double price){ this.id = id; this.price = price; } public int getId(){ return this.id; } public double getPrice(){ return this.price; } public void setId(int id){ this.id = id; } public void setPrice(double price){ this.price = price; } @Override public Object Clone(){ Product object = new Product(); object.id = this.id; object.price = this.price; return object; } } 例子 2 (使用官方介面) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 public class main{ Product p1 = new Product(2023, 3.03); System.out.println(p1.getId() + \u0026#34; \u0026#34; + p1.getPrice()); // Product p2 = new Product(2023, 3.03); Product p2 = (Product) p1.clone(); System.out.println(p2.getId() + \u0026#34; \u0026#34; + p2.getPrice()); } // 去除 // interface Prototype{ // public Object Clone(); // } // 實作介面 class Product implements Cloneable{ private int id; private double price; public Product(){} public Product(int id, double price){ this.id = id; this.price = price; } public int getId(){ return this.id; } public double getPrice(){ return this.price; } public void setId(int id){ this.id = id; } public void setPrice(double price){ this.price = price; } // 覆寫方法 @Override public Object clone(){ return super.clone(); } } ","date":"2023-06-02T19:31:44+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/113/","title":"原型模式"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 Builder Pattern 物件建立型模式\n意圖 將一個複雜物件的建構與它的表示分離，使得同樣的建構過程可以建立不同的表示。\n結構 其中：\nBuilder 為建立一個 Product 物件的各個部件指定抽象介面。 ConcreteBuilder 實作 Builder 的介面以建構和裝配該產品的各個部件，定義並明確它所建立的表示，提供一個取得產品的介面。 Director 建構一個使用 Builder 介面的物件。 Product 表示被建構的複雜物件。ConcreteBuilder 建立該產品的內部表示並定義它的裝配過程。包含定義組成元件的類別，包括將這些元件裝配成最終產品的介面。 適用性 Builder 模式適用於：\n當建立複雜物件的演算法應該獨立於該物件的組成部分以及它們的裝配方式。 當建構過程必須允許被建構的物件有不同的表示時。 範例 1 某速食店主要製作並出售兒童套餐，一般包括主餐（各類披薩）、飲料和玩具，其餐點種類可能不同，但其製作過程相同。前台服務員（Waiter）排程廚師製作套餐。現採用生成器模式實作製作過程。類別圖如下：\nJava 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class Pizza { private String parts; public void setParts(String parts) { this.parts = parts; } public String toString() { return this.parts; } } abstract class PizzaBuilder { protected Pizza pizza; public Pizza getPizza() { return pizza; } public void createNewPizza() { pizza = new Pizza(); } public abstract void buildParts(); } class HawaiianPizzaBuilder extends PizzaBuilder { public void buildParts(){ pizza.setParts(\u0026#34;cross + mild + ham\u0026amp;pineapp1e\u0026#34;); } } class SpicyPizzaBuilder extends PizzaBuilder { public void buildParts() { pizza.setParts(\u0026#34;panbaked + hot + pepperoni\u0026amp;salami\u0026#34;); } } class Waiter { private PizzaBuilder pizzaBuilder; public void setPizzaBuilder(PizzaBuilder pizzaBuilder) {/* 設定生成器 */ this.pizzaBuilder = pizzaBuilder; } public Pizza getPizza() { return pizzaBuilder.getPizza(); } public void construct() { /* 建構 */ pizzaBuilder.createNewPizza(); pizzaBuilder.buildParts(); } } class FastFoodOrdering { public static void main(String[] args) { Waiter waiter = new Waiter(); PizzaBuilder hawaiian_pizzabuilder = new HawaiianPizzaBuilder(); waiter.setPizzaBuilder(hawaiian_pizzabuilder); waiter.construct(); System.out.println(\u0026#34;披薩：\u0026#34; + waiter.getPizza()); // 輸出：披薩：cross + mild + ham\u0026amp;pineapp1e } } C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; class Pizza { private: string parts; public: void setParts(string parts) { this-\u0026gt;parts = parts; } string getParts() { return parts; } }; class PizzaBuilder { protected: Pizza *pizza; public: Pizza *getPizza() { return pizza; } void createNewPizza() { pizza = new Pizza(); } virtual void buildParts() = 0; }; class HawaiianPizzaBuilder : public PizzaBuilder { public: void buildParts() { pizza-\u0026gt;setParts(\u0026#34;cross + mild + ham\u0026amp;pineapple\u0026#34;); } }; class SpicyPizzaBuilder : public PizzaBuilder { public: void buildParts() { pizza-\u0026gt;setParts(\u0026#34;pan baked + hot + pepperoni\u0026amp;salami\u0026#34;); } }; class Waiter { private: PizzaBuilder *pizzaBuilder; public: void setPizzaBuilder(PizzaBuilder *pizzaBuilder) { /* 設定生成器 */ this-\u0026gt;pizzaBuilder = pizzaBuilder; } Pizza *getPizza() { return pizzaBuilder-\u0026gt;getPizza(); } void construct() { pizzaBuilder-\u0026gt;createNewPizza(); pizzaBuilder-\u0026gt;buildParts(); } }; int main() { Waiter *waiter = new Waiter(); PizzaBuilder *hawaiian_pizzabuilder = new HawaiianPizzaBuilder(); waiter-\u0026gt;setPizzaBuilder(hawaiian_pizzabuilder); waiter-\u0026gt;construct(); cout \u0026lt;\u0026lt; \u0026#34;pizza: \u0026#34; \u0026lt;\u0026lt; waiter-\u0026gt;getPizza()-\u0026gt;getParts() \u0026lt;\u0026lt; endl; } // 程式的輸出結果為： // pizza：cross + mild + ham*pineapple 範例 2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 import java.util.*; public class Main{ public static void main(String[] args) { Director d = new Director(); Builder b1 = new Builder1(); d.Construct(b1); Product p1 = b1.getResult(); p1.show(); } } class Product{ List\u0026lt;String\u0026gt; parts = new ArrayList\u0026lt;String\u0026gt;(); public void Add(String part){ parts.add(part); } public void show(){ System.out.println(\u0026#34;產品資訊：\u0026#34;); for(String s : parts) System.out.print(s + \u0026#34; \u0026#34;); System.out.println(); } } abstract class Builder{ public abstract void BuildPart(); public abstract Product getResult(); } class Builder1 extends Builder{ Product p = new Product(); @Override public void BuildPart(){ p.Add(\u0026#34;A1\u0026#34;); p.Add(\u0026#34;A2\u0026#34;); p.Add(\u0026#34;C\u0026#34;); } @Override public Product getResult(){ return p; } } class Builder2 extends Builder{ Product p = new Product(); @Override public void BuildPart(){ p.Add(\u0026#34;B1\u0026#34;); p.Add(\u0026#34;B2\u0026#34;); p.Add(\u0026#34;C\u0026#34;); } @Override public Product getResult(){ return p; } } class Director{ public void Construct(Builder builder){ builder.BuildPart(); } } ","date":"2023-06-01T23:33:17+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/112/","title":"生成器模式"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 簡單工廠模式 簡單工廠模式屬於建立型模式，但不屬於 23 種設計模式之一\n定義：定義一個工廠類別，它可以根據參數的不同傳回不同類別的實例，被建立的實例通常都具有共同的父類別\n在簡單工廠模式中用於建立實例的方法通常為靜態 (static) 方法，因此簡單工廠模式又稱為靜態工廠方法 (Static Factory Method)\n需要什麼產品就傳入產品對應的參數，就可以獲取所需要的產品物件，而無需知道其實作過程\n例如：有一家水餃店，當客戶需要某種水餃時，水餃店生成對應的水餃給客戶。這裡就可以把水餃店看成工廠 (Factory)，水餃看成產品 (Product)，水餃的名稱看成參數，水餃店根據不同的參數傳回不同的水餃\n比如：客戶想要韭菜水餃，這裡韭菜就是參數，水餃店會根據參數韭菜傳回韭菜水餃 (水餃店有韭菜水餃的前提下)\n三類角色：\n工廠 (核心) ​\t負責實作建立所有產品的內部邏輯，工廠類別可以被外界直接呼叫，建立所需物件\n抽象產品 ​\t工廠類別所建立的所有物件的父類別，封裝了產品物件的公用方法，所有的具體產品為其子類別物件\n具體產品 ​\t簡單工廠模式的建立目標，所有被建立的物件都是某個具體類別的實例\n例子 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 public class SimpleFactory{ public static void main(String[] args){ Product productA = Factory.createProduct(\u0026#34;A\u0026#34;); productA.info(); // ... } } abstract class Product{ public abstract void info(); } class ProductA extends Product{ @Override public void info(){ System.out.println(\u0026#34;A\u0026#34;); } } class ProductB extends Product{ @Override public void info(){ System.out.println(\u0026#34;B\u0026#34;); } } class Factory{ public static Product creatProduct(String type){ Product p = null; // 此處未考慮異常情況以及處理 switch(type){ case \u0026#34;A\u0026#34;: p = new ProductA(); break; case \u0026#34;B\u0026#34;: p = new ProductB(); break; default: System.out.println(\u0026#34;Please try again\u0026#34;); break; } return p; } } 當增加產品時，將更改工廠，違反了 開放 - 封閉原則\n工廠方法模式 Factory Method Pattern 類別建立型模式\n意圖 定義一個用於建立物件的介面，讓子類別決定實例化哪一個類別。Factory Method 使一個類別的實例化延遲到其子類別\n結構 其中：\nProduct 定義工廠方法所建立的物件的介面 ConcreteProduct 實作 Product 介面 Creator 宣告工廠方法，該方法傳回一個 Product 類型的物件，Creator 也可以定義一個工廠方法的預設實作，它傳回一個預設的 ConcreteProduct 物件，可以呼叫工廠方法以建立一個 Product 物件 ConcreteCreator 重新定義工廠方法以傳回一個 ConcreteProduct 實例 適用性 Factory Method 模式適用於：\n當一個類別不知道它所必須建立的物件的類別的時候 當一個類別希望由它的子類別來指定它所建立的物件的時候 當類別將建立物件的職責委託給多個幫助子類別中的某一個，並且你希望將哪一個幫助子類別是代理者這一資訊局部化的時候 例子 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 // 在上一個程式碼的基礎上修改 public class FactoryMethod{ public static void main(String[] args){ Factory factoryA = new FactoryA(); //Product productA = Factory.createProduct(\u0026#34;A\u0026#34;); Product productA = factoryA.createProduct(); productA.info(); // ... } } // 抽象類別改介面 // abstract class Product interface Product{ // public abstract void info(); public void info(); } // 繼承改實作 // class ProductA extends Product{ class ProductA implements Product{ @Override public void info(){ System.out.println(\u0026#34;A\u0026#34;); } } // 繼承改實作 // class ProductB extends Product{ class ProductB implements Product{ @Override public void info(){ System.out.println(\u0026#34;B\u0026#34;); } } // 實體類別改介面 // class Factory interface Factory{ public Product creatProduct(); } // 增加介面實作 class FactoryA implements Factory{ @Override public Product createProduct(){ return new ProductA(); } } class FactoryB implements Factory{ @Override public Product createProduct(){ return new ProductB(); } } 抽象工廠模式 Abstract Factory Pattern 物件建立型模式\n意圖 提供一個建立一系列相關或相互依賴物件的介面，而無需指定它們具體的類別\n結構 其中：\nAbstractFactory 宣告一個建立抽象產品物件的操作介面 ConcreteFactory 實作建立具體產品物件的操作 AbstractProduct 為一類產品物件宣告一個介面 ConcreteProduct 定義一個將被相應的具體工廠建立的產品物件，實作 AbstractProduct 介面 Client 僅使用由 AbstractFactory 和 AbstractProduct 類別宣告的介面 適用性 Abstract Factory 模式適用於：\n一個系統要獨立於它的產品的建立、組合和表示時 一個系統要由多個產品系列中的一個來配置時 當要強調一系列相關的產品物件的設計以便進行聯合使用時 當提供一個產品類別庫，只想顯示它們的介面而不是實作時 例子 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 public class AbstractFactory{ public static void main(String[] args){ Factory factory1 = new Factory1(); ProductA productA = factory1.createProductA(); productA.info(); // ... } } interface ProductA{ public void info(); } class ProductA1 implements ProductA{ @Override public void info(){ System.out.println(\u0026#34;A1\u0026#34;); } } class ProductA2 implements ProductA{ @Override public void info(){ System.out.println(\u0026#34;A2\u0026#34;); } } interface ProductB{ public void info(); } class ProductB1 implements ProductB{ @Override public void info(){ System.out.println(\u0026#34;B1\u0026#34;); } } class ProductB2 implements ProductB{ @Override public void info(){ System.out.println(\u0026#34;B2\u0026#34;); } } interface Factory{ public ProductA creatProductA(); public ProductB creatProductB(); } class Factory1 implements Factory{ @Override public ProductA createProductA(){ return new ProductA1(); } @Override public ProductB createProductB(){ return new ProductB1(); } } class Factory2 implements Factory{ @Override public ProductA createProductA(){ return new ProductA2(); } @Override public ProductB createProductB(){ return new ProductB2(); } } ","date":"2023-05-28T10:23:46+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/111/","title":"工廠模式"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 問題描述 某公司購買長鋼條，將其切割後進行出售。切割鋼條的成本可以忽略不計，鋼條的長度為英吋。已知價格表 $p$ ，其中 $p_{i}(i=1,2,\\cdots,m)$ 表示長度為 $i$ 英吋的鋼條的價格。現要求解使銷售收益最大的切割方案。\n問題分析 假設長鋼條的長度為 $n$ 英吋，最佳切割方案的最左邊切割段長度為 $i$ 英吋，則繼續求解剩餘長度為 $m-1$ 英吋鋼條的最佳切割方案。考慮所有可能的 $i$ ，得到的最大收益 $r_{n}$ 對應的切割方案即為最佳切割方案。$r_{n}$ 的遞迴定義如下：\n$$ r_{n}=max_{1\\le i \\le n}(p_{i}+r_{n-i}) $$C 程式碼 對此問題有兩種方案：\n(1) 分治法 (自頂向下) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int Top_Down_Cut_Rod(int p[], int n){ int r=0; // 最大價值 int i; if(n==0){ retrun 0; } for(i=1; i\u0026lt;=n; i++){ int tmp = p[i]+Top_Down_Cut_Rod(p, n-i); r = (r\u0026gt;=tmp) ? r : tmp; } return r; } 時間複雜度 $O(2^{n})$\n(2) 動態規劃 (自底向上) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int Bottom_Up_Cut_Rod(int p[], int n, int *s){ // *s:子問題最佳切割方法 int r[n+1]; // 子問題最佳價值 r[0]=0; for(int j=1; j\u0026lt;=n; j++){ int tmp=0; for(int i=1; i\u0026lt;=j; i++){ if(p[i]+r[j-1] \u0026gt; tmp){ tmp = p[i]+r[j-i]; s[j]=i; } } r[i]=tmp; } return r[n]; } 時間複雜度 $O(n^{2})$\n其他 在搜尋過程中發現已有的文章： 【基礎算法】动态规划详解——钢条切割 ","date":"2023-05-27T19:37:08+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/110/","title":"演算法 鋼條切割問題 (動態規劃 分治法)"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 問題描述 有 $n$ 枚硬幣，其中有一枚是偽幣，已知偽幣的重量較輕。現只有一個天平，要求用儘量少的比較次數找出這枚偽幣\n問題分析 將 $n$ 枚硬幣分成相等的兩部分：\n當 $n$ 為偶數時，將前後兩部分，即 $1\\cdots\\frac{n}{2}$ 和 $\\frac{n}{2}+1\\cdots n$ 放在天平的兩端，較輕的一端裡有偽幣，繼續在較輕的這部分硬幣中用同樣的方法找出偽幣 當 $n$ 為奇數時，將前後兩部分，即 $1\\cdots\\frac{n-1}{2}$ 和 $\\frac{n+1}{2}+1\\cdots n$ 放在天平的兩端，較輕的一端裡有偽幣，繼續在較輕的這部分硬幣中用同樣的方法找出偽幣；若兩端重量相等，則中間的硬幣，即第 $\\frac{n+1}{2}$ 枚硬幣是偽幣 C 程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 #include \u0026lt;stdio.h\u0026gt; // coins:重量陣列 first,last:陣列第一個與最後一個下標 int getCounterfeitCoin(int *coins, int first, int last); int main(void){ int coins[10] = {2,2,1,2,2,2,2,2,2,2}; int tmp = getCounterfeitCoin(coins, 0, 9); printf(\u0026#34;第 %d 個是偽幣\\n\u0026#34;,tmp+1); return 0; } int getCounterfeitCoin(int *coins, int first, int last){ int firstSum=0; int lastSum=0; int i; // 只剩兩枚硬幣 if(first == last -1){ if(coins[first] \u0026lt; coins[last]) return first; return last; } // 偶數枚硬幣 if ((last-first+1)%2 == 0){ for(i=first; i\u0026lt;first+(last-first)/2+1; i++){ firstSum += coins[i]; } for(i=first+(last-first)/2+1; i\u0026lt;last+1; i++){ lastSum += coins[i]; } if(firstSum \u0026lt; lastSum){ return getCounterfeitCoin(coins, first, first+(last-first)/2); }else{ return getCounterfeitCoin(coins, first+(last-first)/2+1, last); } }else{ // 奇數枚硬幣 for(i=first; i\u0026lt;first+(last-first)/2; i++){ firstSum += coins[i]; } for(i=first+(last-first)/2+1; i\u0026lt;last+1; i++){ lastSum += coins[i]; } if(firstSum \u0026lt; lastSum){ return getCounterfeitCoin(coins, first, first+(last-first)/2-1); }else if(firstSum \u0026gt; lastSum){ return getCounterfeitCoin(coins, first+(last-first)/2+1, last); }else{ return first+(last-first)/2; } } } ","date":"2023-05-18T20:17:35+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/109/","title":"演算法 偽幣問題 (分治法)"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 「每一個設計模式都描述了一個在我們周圍不斷重複發生的問題，以及該問題解決方案的核心。這樣一來，你就能一次又一次地使用該方案而不必做重複勞動」。設計模式的核心在於提供了相關問題的解決方案，使得人們可以簡單方便地複用成功的設計和體系結構。\n設計模式一般有以下 4 個基本要素：\n模式名稱 (Pattern Name)：一個助記名，它用一兩個詞來描述模式的問題、解決方案和效果。 問題 (Problem)：問題描述了應該在何時使用模式。 解決方案 (Solution)：解決方案描述了設計的組成成分、它們之間的相互關係及各自的職責和協作方式。 效果 (Consequences)：效果描述了模式應用的效果及使用模式應權衡的問題。 設計模式確定了所包含的類別（Class）和實例（Instance），它們的角色、協作方式以及職責分配。每一個設計模式都集中於一個特定的物件導向設計問題或設計要點，描述了什麼時候使用它，在另一些設計約束條件下是否還能使用，以及使用的效果和如何取捨。按照設計模式的目的可以分成三大類：\n建立型模式與物件的建立有關；結構型模式處理類別或物件的組合；行為型模式對類別或物件怎樣分配職責進行描述。\n建立型 結構型 行為型 類別 工廠方法模式 轉接器模式 (類別) 解釋器模式\n範本方法模式 物件 抽象工廠模式\n生成器模式\n原型模式\n單例模式 轉接器模式 (物件)\n橋接模式\n組合模式\n裝飾模式\n外觀模式\n享元模式\n代理模式 責任鏈模式\n命令模式\n迭代器模式\n中介者模式\n備忘錄模式\n觀察者模式\n狀態模式\n策略模式\n訪問者模式 建立型設計模式 建立型模式抽象化了實例化過程，它們幫助一個系統獨立於如何建立、組合和表示它的那些物件。一個類別建立型模式使用繼承改變被實例化的類別，而一個物件建立型模式將實例化委派給另一個物件。\n隨著系統演化得越來越依賴於物件組合（Composition）而不是類別繼承，建立型模式變得更為重要。當這種情況發生時，重心從對一組固定行為的硬編碼 (Hard-coding) 轉移為定義一個較小的基本行為集，這些行為可以被組合成任意數目的更複雜行為，這樣建立有特定行為的物件要求的不僅僅是實例化一個類別。\n在這些模式中有兩個不斷出現的主旋律：\n它們都將關於該系統使用哪些具體類別的資訊封裝起來。 它們隱藏了這些類別的實例是如何被建立和放在一起的。整個系統關於這些物件所知道的是由抽象類別所定義的介面（Interface）。 因此，建立型模式在「為什麼被建立」、「誰建立它」、「它是怎樣被建立的」以及「何時建立」這些方面給予了很大的靈活性。它們允許用結構和功能差別很大的「產品」物件配置一個系統。配置可以是靜態的 (即在編譯時指定)，也可以是動態的 (在執行時期)。\n結構型設計模式 結構型設計模式涉及如何組合類別和物件以獲得更大的結構。結構型類別模式採用繼承機制來組合介面或實作。一個簡單的例子是採用多重繼承方法將兩個以上的類別組合成分一個類別，結果這個類別包含了所有父類別的性質。這一模式尤其有助於多個獨立開發的類別庫協同工作。其中一個例子是類別形式的 Adapter (轉接器) 模式。一般來說，轉接器使得一個介面與其他介面相容，從而給出了多個不同介面的統一抽象。為此，類別轉接器對一個 adaptee 類別進行私有繼承。這樣，轉接器就可以用 adaptee 的介面表示它的介面。\n結構型物件模式不是對介面和實作進行組合，而是描述了如何對一些物件進行組合，從而實現新功能的一些方法。因為可以在執行時刻改變物件組合關係，所以物件組合方式具有更大的靈活性，而這種機制用靜態類別組合是不可能實現的。\n行為型設計模式 行為模式涉及演算法和物件間職責的分配。行為模式不僅描述物件或類別的模式，還描述它們之間的通訊模式。這些模式刻畫了在執行時期難以追蹤的、複雜的控制流。它們將使用者的注意力從控制流轉移到物件間的聯繫方式上來。\n行為類別模式使用繼承機制在類別間分派行為。其中 Template Method (範本方法) 較為簡單和常用。範本方法是一個演算法的抽象定義，它逐步地定義該演算法，每一步呼叫一個抽象操作或一個原語操作（Primitive operation），子類別定義抽象操作以具體實作該演算法。另一種行為類別模式是 Interpreter (解釋器)，它將一個文法表示為一個類別層次，並實作一個解釋器作為這些類別實例上的一個操作。\n行為物件模式使用物件組合而不是繼承。一些行為物件模式描述了一組對等的物件怎樣相互協作以完成其中任一個物件都無法單獨完成的任務。這裡一個重要的問題是對等的物件如何互相了解對方。對等物件可以保持顯式的對對方的參照，但那會增加它們的耦合度。在極端情況下，每一個物件都要了解所有其他的物件。Mediator (中介者) 在對等物件間引入一個 mediator 物件以避免這種情況的出現。mediator 提供了鬆耦合所需的間接性。\n推薦閱讀 https://refactoringguru.cn/design-patterns ","date":"2023-05-17T22:50:20+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/108/","title":"設計模式 引言"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 針對中國大陸無法進入遊戲的分流規則\n核心原理 在進入遊戲時需要 UDP 連線，而多數協定不支援 UDP，即遇到 UDP 會自動拒絕，所以將 UDP 連線的 IP 設定為直連即可，以下是我擷取到的兩個 IP\n1 2 3 8.209.196.179 # 第二個似乎直連不會連線，只需設定第一個即可 47.245.63.117 當然，為了安全起見（指 TCP 連線與 UDP 連線不一致可能造成的安全隱患），建議將相關網域都設定為直連，即以下這些\n1 2 3 *.starrails.com *.hoyoverse.com 8.209.196.179/8 OpenClash 在「全域設定 - 規則設定」，啟用「自定義規則」，在第一個框的 rules: 下方輸入\n1 2 3 4 #rules: - DOMAIN-SUFFIX, starrails.com, DIRECT - DOMAIN-SUFFIX, hoyoverse.com, DIRECT - IP-CIDR, 8.209.196.179/8, DIRECT Quantumult X 編輯設定檔，跳轉至 [filter_local] ，輸入以下內容\n1 2 3 4 #SR host-suffix, starrails.com, direct host-suffix, hoyoverse.com, direct ip-cidr, 8.209.196.179/8, direct ","date":"2023-05-16T23:13:21+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/107/","title":"《崩壞：星穹鐵道》國際服分流規則"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 問題描述 在一塊電路板的上下兩端分別有 n 個接線柱。根據電路設計，用 $(i, \\pi(i))$ 表示將上端接線柱 i 與下端接線柱 $\\pi(i)$ 相連，稱其為該電路板上的第 i 條連線\n下圖所示的 $\\pi(i)$ 排列為 $\\{8, 7, 4, 2, 5, 1, 9, 3, 10, 6\\}$。對於任何 $1 \\le i \u003c j \\le n $ ，第 i 條連線和第 j 條連線相交的充要條件是 $\\pi(i)\u003e\\pi(j)$\n在製作電路板時，要求將這 n 條連線分佈到若干絕緣層上，在同一層上的連線不相交，現在要確定將哪些連線安排在一層上，使得該層上有盡可能多的連線，即確定連線集 $Nets=\\{ (i,\\pi(i)),1\\le i\\le n \\}$ 的最大不相交子集\n問題分析 記 $N(i,j)=\\{ t\\|(t,\\pi(t))\\in Nets, t\\le i, \\pi(t) \\le j \\}$ 。$N(i,j)$ 的最大不相交子集為 $MNS(i,j)$ ，$size(i,j)=\\|MNS(i,j)\\|$\n經分析，該問題具有最佳子結構性質。對於規模為 n 的電路佈線問題，可以建構如下遞迴式\n$$ \\begin{align*} \u0026(1) \\ 當 \\ i=1\\ 時， size(1,j)= \\begin{cases} 0, \u0026 \\text{j\u003c$\\pi$(1)} \\\\ 1, \u0026 \\text{其他情況} \\end{cases} \\\\ \u0026(2) \\ 當 \\ i\u003e1\\ 時， size(i,j)= \\begin{cases} size(i-1,j), \u0026 \\text{j\u003c$\\pi$(i)} \\\\ max{size(i-1,j),size(i-1,\\pi(i)-1)+1}, \u0026 \\text{其他情況} \\end{cases} \\end{align*} $$C 程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #define N 10 // 問題規模 // 求最大不相交連接數 void maxNum(int pi[], int **size); // 建構最大不相交連接集合，net[i]表示最大不相交子集中第i條連線的上端接線柱的序號 int constructSet(int pi[], int **size, int *net); int main(void){ // 索引從1開始 int pi[N+1] = {0, 8, 7, 4, 2, 5, 1, 9, 3, 10, 6}; int net[N]; int **size; size = (int**)malloc(sizeof(int*)*(N+1)); for(int i=0;i\u0026lt;N+1;i++) size[i]=(int*)malloc(sizeof(int)*(N+1)); maxNum(pi, size); int m = constructSet(pi, size, net); printf(\u0026#34;最大不相交連接數為：%d\\n\u0026#34;,m); printf(\u0026#34;包含的連線為：\\n\u0026#34;); for(int i=0; i\u0026lt;m; i++){ printf(\u0026#34;(%d,%d)\\n\u0026#34;, net[i], pi[net[i]]); } } void maxNum(int pi[], int **size){ // size[i][j]: 上下端分別有i個和j個接線柱的電路板的第一層最大不相交連接數 int i,j; // when j\u0026lt;pi(1) for(j=0; j\u0026lt;pi[1]; j++) size[1][j]; // when j\u0026gt;=pi(1) for(j=pi[1]; j\u0026lt;=N; j++) size[1][j]; for(i=2; i\u0026lt;N; i++){ // when j\u0026lt;pi(i) for(j=0; j\u0026lt;pi[i]; j++) size[i][j] = size[i-1][j]; // when j\u0026gt;=c[i] for(j=pi[i]; j\u0026lt;=N; j++) size[i][j]=size[i-1][j]\u0026gt;=size[i-1][pi[i]-1]+1 ? size[i-1][j] : size[i-1][pi[i]-1]+1; } // 最大連接數 size[N][N] = size[N-1][N]\u0026gt;=size[N-1][pi[N]-1]+1 ? size[N-1][N] : size[N-1][pi[N]-1]+1; } // 建構最大不相交連接集合，net[i]表示最大不相交子集中第i條連線的上端接線柱的序號 int constructSet(int pi[], int **size, int *net){ int i; int j=N; int m=0; // 記錄最大連接集合中的接線柱 for(i=N; i\u0026gt;1; i--){ // 遞減 // (i,pi[i])是最大不相交子集的一條連線 if(size[i][j] != size[i-1][j]){ net[m++]=i; // 將i記錄到陣列net中，連線數自增1 j=pi[i]-1; // 更新擴充連線柱區間 } } // when i=1 if(j\u0026gt;=pi[1]) net[m++] = 1; return m; } 其他 在搜尋過程中發現已有的文章： 算法设计与分析——电路布线（动态规划） 參考文章 LaTeX公式手册 Typora中使用LaTeX：多行公式左对齐 用malloc动态申请一个二维数组的三种方法 ","date":"2023-05-16T17:53:31+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/106/","title":"演算法 電路佈線問題 (動態規劃)"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 使用 Rclone 掛載 Onedrive 歌曲檔案，Navidrome 搭建網站，採用 docker 部署\nRclone 首先需要在 Windows 系統上執行並取得設定，然後再在伺服器上安裝並掛載檔案\n取得 Token 在 Windows 電腦上下載 Rclone，下載地址： https://rclone.org/downloads/ 下載完成後解壓縮，解壓縮完成後透過 cmd 進入該資料夾，然後執行\n1 rclone.exe authorize \u0026#34;onedrive\u0026#34; 在彈出的瀏覽器中登入並授權，授權完成後會顯示 Token (大括號之間的，包括大括號)\n取得設定檔 執行指令\n1 rclone.exe config 根據需求選擇即可，完成後設定檔生成在：\n1 C:\\Users\\%USERNAME%\\AppData\\Roaming\\rclone 複製設定檔 首先需要在伺服器建立兩個資料夾\n1 2 3 4 # 該資料夾放設定檔 /home/docker/rclone/config # 該資料夾放資料，即 Onedrive 映射到的資料夾 /home/docker/rclone/data 然後將設定檔放到對應的資料夾\n掛載目錄 執行指令以拉取映像檔\n1 docker pull rclone/rclone:latest 掛載目錄\n1 2 3 4 5 6 7 8 9 10 11 12 docker run --rm \\ --volume /root/rclone/config:/config/rclone \\ --volume /root/rclone/data:/data:shared \\ --volume /etc/passwd:/etc/passwd:ro --volume /etc/group:/etc/group:ro \\ --device /dev/fuse --cap-add SYS_ADMIN --security-opt apparmor:unconfined \\ rclone/rclone \\ mount music:/ /data/music --allow-other --allow-non-empty --vfs-cache-mode writes \u0026amp; # 上述指令僅最後一行為 Rclone 的指令，根據實際情況修改，格式如下 rclone mount DriveName:Folder LocalFolder # DriveName Rclone 掛載的名稱 # Folder 雲端硬碟的路徑 # LocalFolder 掛載到本地的檔案 上述指令最後的 \u0026amp; 表示背景執行，指令執行後會顯示程序的 PID，如需關閉請使用指令\n1 kill PID 了解更多？請造訪： Linux 學習 第六章 管理執行中的程序 根據範例，此處示範將 Onedrive 中 music (不區分大小寫) 目錄掛載至 /home/docker/rclone/data/music\n參考資料：\nhttps://rclone.org/onedrive/ https://rclone.cn/install.html Linux上使用Rclone掛載OneDrive或GoogleDrive並設定開機自啟 部署 Navidrome 採用 docker-compose，首先建立資料夾，例如\n1 /home/docker/navidrome 建立檔案 docker-compose.yml 並填入內容\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 vim docker-compose.yml # 輸入內容 version: \u0026#34;3\u0026#34; services: navidrome: image: deluan/navidrome:latest ports: - \u0026#34;8001:4533\u0026#34; restart: unless-stopped environment: # Optional: put your config options customization here. Examples: ND_SCANSCHEDULE: 1h ND_LOGLEVEL: info ND_SESSIONTIMEOUT: 24h ND_BASEURL: \u0026#34;\u0026#34; volumes: - \u0026#34;/home/docker/navidrome/data:/data\u0026#34; - \u0026#34;/home/docker/rclone/data/music:/music:ro\u0026#34; 查看更多變數： Navidrome Configuration Options - Navidrome 然後執行指令\n1 docker-compose up -d 存取 IP:8001 即可\n參考資料：\nhttps://www.navidrome.org/docs/installation/docker/ Navidrome搭建一個屬於自己的音樂播放器 歌曲資訊 若要進行歌曲分類，需要將歌曲的資訊嵌入歌曲中，包括歌詞\n可以使用工具 MusicTag 進行修改\n作者網站： 音樂標籤pc版 當然還有其他的工具，或者這個 Web 版 xhongc/music-tag-web 使用用戶端 這個網頁端在 PC 上使用還行，但在手機上使用一言難盡，不過好在有一些用戶端可以使用\n詳情請造訪： https://www.navidrome.org/docs/overview/#apps ","date":"2023-05-02T02:27:39+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/105/","title":"搭建個人音樂網站"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 圖表 (Diagram) 是一組元素的圖形表示，大多數情況下將圖表畫成頂點 (代表事物) 和弧 (代表關係) 的連通圖。為了對系統進行視覺化，可以從不同的角度繪圖，這樣圖表就是對系統的投影。\nUML 2.0 提供了 13 種圖表，分別是類別圖、物件圖、使用案例圖、循序圖、通訊圖、狀態圖、活動圖、元件圖、複合結構圖、部署圖、套件圖、互動概覽圖和計時圖。循序圖、通訊圖、互動概覽圖和計時圖均被稱為互動圖。\n(一) 類別圖 類別圖 (Class Diagram) 展現了一組物件、介面、協同和它們之間的關係。在物件導向系統的塑模中所建立的最常見圖表就是類別圖。類別圖給出系統的靜態設計視圖。包含主動類別的類別圖給出了系統的靜態程序視圖。\n類別圖中通常包括下述內容：\n類別 介面 協同 相依、一般化和關聯關係 例如：\nStudent +id: int\n-name: String\n#age: int ~borrow(): bool +: public\n-: private\n#: protected\n~: package\n類別圖中也可以包含註解和限制。類別圖還可以含有套件或子系統，二者都用於把模型元素聚集成更大的區塊。\n類別圖用於對系統的靜態設計視圖塑模。這種視圖主要支援系統的功能需求，即系統要提供給最終使用者的服務。當對系統的靜態設計視圖塑模時，通常以下述 3 種方式之一使用類別圖：\n對系統的詞彙塑模 對簡單的協同塑模 對邏輯資料庫結構塑模 (二) 物件圖 物件圖 (Object Diagram) 展現了某一時刻一組物件以及它們之間的關係，描述了在類別圖中所建立的事物的實例的靜態快照。物件圖一般包括物件和鏈結。\n物件名：類別名 屬性 和類別圖一樣，物件圖給出系統的靜態設計視圖或靜態程序視圖。\n(三) 使用案例圖 使用案例圖 (Use Case Diagram) 展現了一組使用案例、參與者 (Actor) 以及它們之間的關係。\n使用案例圖通常包含以下內容：\n使用案例 參與者 使用案例之間的擴充關係 \u0026lt;\u0026lt;extend\u0026gt;\u0026gt; 和包含關係 \u0026lt;\u0026lt;include\u0026gt;\u0026gt; ，參與者和使用案例之間的關聯關係，使用案例與使用案例以及參與者與參與者之間的一般化關係。 包含關係 一個使用案例包含另一個使用案例。\n基本使用案例 \u0026ndash;\u0026lt;\u0026lt;include\u0026gt;\u0026gt;\u0026ndash;\u0026gt; 被包含使用案例\n擴充關係 一個使用案例執行的時候，可能會發生一些特殊的情況或可選的情況，這種情況就是這個使用案例的擴充使用案例。\n擴充使用案例 \u0026ndash;\u0026lt;\u0026lt;extend\u0026gt;\u0026gt;\u0026ndash;\u0026gt; 基本使用案例\n使用案例圖用於對系統的靜態使用案例視圖進行塑模。這個視圖主要支援系統的行為，即該系統在它的周邊環境的語境中所提供的外部可見服務。\n當對系統的靜態使用案例視圖塑模時，可以用下列兩種方式來使用使用案例圖：\n對系統的語境塑模 對系統的需求塑模 (四) 互動圖 互動圖用於對系統的動態方面進行塑模。一張互動圖表現的是一個互動，由一組物件和它們之間的關係組成，包含它們之間可能傳遞的訊息。互動圖表現為循序圖、通訊圖、互動概覽圖和計時圖，每種針對不同的目的，能適用於不同的情況。循序圖是強調訊息時間順序的互動圖；通訊圖是強調接受和發生訊息的物件的結構組織的互動圖；互動概覽圖強調控制流的互動圖。\n互動圖一般包含物件、鏈結和訊息。\n循序圖 循序圖 (Sequence Diagram) 是情境 (Scenario) 的圖形化表示，描述了以時間順序組織的物件之間的互動活動。形成循序圖時，首先把參加互動的物件放在圖的上方，沿水平方向排列。通常把發起互動的物件放在左邊，下級物件依此放在右邊。然後，把這些物件發生和接收的訊息沿著垂直方向按時間順序從上到下放置。這樣，就提供了控制流隨時間推移的清晰的視覺化軌跡。\n循序圖有兩個不同於通訊圖的特徵：\n循序圖有物件生命線。物件生命線是一條垂直的虛線，表示一個物件在一段時間內存在。 循序圖有控制焦點。控制焦點是一個瘦高的矩形，表示一個物件執行一個動作所經歷的時間段，既可以是直接執行，也可以是通過下級過程執行。矩形的頂部表示動作的開始，底部表示動作的結束。 通訊圖 通訊圖 (Communication Diagram) 強調收發訊息的物件的結構組織，在早期的版本中也被稱作協同圖。通訊圖強調參加互動的物件的組織。產生一張通訊圖，首先要將參加互動的物件作為圖的頂點，然後把連接這些物件的鏈結表示為圖的弧，最後用物件發送和接收的訊息來修飾這些鏈結。這就提供了在協同物件的結構組織的語境中觀察控制流的一個清晰的視覺化軌跡。\n通訊圖有兩個不同於循序圖的特性：\n通訊圖有路徑。為了指出一個物件如何與另一個物件連結，可以在鏈結的末端附上一個路徑構造型。 通訊圖有順序號。為表示一個訊息的時間順序，可以給訊息加一個數字前綴，在控制流中，每個新訊息的順序號單調增加。為了使用巢狀，可使用帶小數點的號碼。 循序圖和通訊圖是同構的，它們之間可以相互轉換。\n(五) 狀態圖 狀態圖 (State Diagram) 展現了一個狀態機，它由狀態、轉換、事件和活動組成。狀態圖關注系統的動態視圖，對於介面、類別和協同的行為塑模尤為重要，強調物件行為的事件順序。\n狀態圖通常包括簡單狀態和組合狀態、轉換 (事件和動作)。\n狀態 狀態是任何可以被觀察到的系統行為模式，一個狀態代表系統的一種行為模式。狀態規定了系統對事件的響應方式。系統對事件的響應，既可以是做一個 (或一系列) 動作，也可以是僅僅改變系統本身的狀態，還可以是既改變狀態，又做動作。\n在狀態圖中定義的狀態主要有：初態 (即初始狀態) 、終態 (即最終狀態) 和中間狀態。初態用一個黑圓點表示，終態用黑圓點外加一個圓表示，狀態圖中的狀態用一個圓角四邊形表示。\n狀態之間為狀態轉換，用一條帶箭頭的線表示。帶箭頭的線上的事件發生時，狀態轉換開始。一張狀態圖中只能有一個初態，而終態可以沒有，也可以有多個。\n三種標準事件：\nentry: 進入動作，進入狀態時立即執行 exit: 結束動作，退出狀態時立即執行 do: 內部活動，佔用有限時間，並可以中斷的工作 以上圖例：\nentry/turnON: 當轉入該狀態時，執行開燈動作 do/blinkFivetimes: 當處於該狀態時，燈閃爍 5 次 exit/turnOFF: 當轉出該狀態時，執行關燈動作 事件與轉換 事件是在某個特定時刻發生的事情，它是對引起系統做動作或 (和) 從一個狀態轉換到另一個狀態的外界事件的抽象。例如，觀眾使用電視遙控器，使用者移動滑鼠、點擊滑鼠等都是事件。簡而言之，事件就是引起系統做動作或 (和) 轉換狀態的控制資訊。\n狀態變遷通常是由事件觸發的，在這種情況下，應在表示狀態轉換的箭頭上標出觸發轉換的事件表達式。\n如果在箭頭線上未標明事件，則表示在源狀態的內部活動執行完之後自動觸發轉換，事件表達式的語法如下：\n事件說明[防護條件]動作表達式\n其中，事件說明的語法為：事件名(參數表)\n防護條件 (或者守護條件) 是一個布林表達式。如果同時使用事件說明和防護條件，則當且僅當事件發生且布林表達式為真時，狀態轉換才發生。如果只有防護條件沒有事件說明時，則只要守護條件為真，狀態轉換就發生。\n轉換包括兩個狀態 (原狀態，目標狀態)、事件、防護條件、動作。\n事件觸發轉換 (遷移)。\n活動 (動作) 可以在狀態內執行，也可以在狀態轉換 (遷移) 時執行。\n完整圖 可以用狀態圖對系統的動態方面塑模。這些動態方面可以包括出現在系統體系結構的任何視圖中的任何一種物件的按事件排序的行為，這些物件包括類別 (各主動類別) 、介面、元件和節點。\n當對系統、類別或使用案例的動態方面塑模時，通常是對反應型物件塑模。\n(六) 活動圖 活動圖 (Activity Diagram) 是一種特殊的狀態圖，它展現了在系統內從一個活動到另一個活動的流程。活動圖專注於系統的動態視圖，它對於系統的功能塑模特別重要，並強調物件間的控制流程。\n活動圖一般包括活動狀態和動作狀態、轉換和物件。\n活動圖可以表示分岔 (Branch)、合併 (Merge)、分叉 (Fork) 和匯合 (Join)。\n當對一個系統的動態方面塑模時，通常有兩種使用活動圖的方式：\n對工作流程塑模 對操作塑模 (七) 元件圖 元件圖 (Component Diagram) 展現了一組元件之間的組織和相依。元件圖專注於系統的靜態實作視圖。它與類別圖相關，通常把元件映射為一個或多個類別、介面或協同。\n(八) 部署圖 部署圖 (Deployment Diagram) 是用來對物件導向系統的物理方面塑模的方法，展現了執行時處理節點以及其中元件 (成品) 的配置。部署圖對系統的靜態部署視圖進行塑模，它與元件圖相關。通常，一個節點是一個在執行時存在並代表一項計算資源的物理元素，至少擁有一些內容，常常具有處理能力，包含一個或多個元件。其中 \u0026lt;\u0026lt;artifact\u0026gt;\u0026gt; 表示成品 (或成果物)。\n總結 靜態塑模：類別圖、物件圖、使用案例圖\n動態塑模：循序圖 (順序圖，時序圖)、通訊圖 (協同圖)、狀態圖、活動圖\n物理塑模：元件圖 (組件圖)、部署圖\n互動圖：循序圖 (順序圖，時序圖)、通訊圖 (協同圖)\n","date":"2023-04-13T20:02:00+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/104/","title":"UML 中的圖表"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 物件導向分析強調的是對一個系統中物件的特性和行為的定義。目前，國際上已經出現了多種物件導向的方法。業界普遍接受的為 UML (Unified Modeling Language, 統一塑模語言)\n統一塑模語言是物件導向軟體的標準化塑模語言。由於其簡單、統一，又能夠表達軟體設計中的動態和靜態資訊，目前已經成為視覺化塑模語言事實上的工業標準\nUML 由 3 個要素構成：UML 的基本建構區塊、支配這些建構區塊如何放置在一起的規則和運用於整個語言的一些共同機制\nUML 的詞彙表包含 3 種建構區塊：事物、關係和圖。事物是對模型中最具代表性的成分的抽象；關係把事物結合在一起；圖凝聚了相關的事物\n事物 UML 中有 4 種事物：結構事物、行為事物、分組事物和註釋事物\n(1) 結構事物 (Structural Thing) 結構事物是 UML 模型中的名詞。它們通常是模型的靜態部分，描述概念或實體元素\n結構事物包括：\n類別 (Class)\n介面 (Interface)\n協作 (Collaboration)\n使用案例 (Use Case)\n主動類別 (Active Class)\n元件 (Component)\n成品 (Artifact)\n節點 (Node)\n(2) 行為事物 (Behavior thing) 行為事物是 UML 模型的動態部分。它們是模型中的動詞，描述了跨越時間和空間的行為\n行為事物包括：\n互動 (Interaction) 狀態機 (State Machine) 活動 (Activity) (3) 分組事物 (Grouping Thing) 分組事物是 UML 模型的組織部分，是一些由模型分解成的「盒子」。在所有的分組事物中，最主要的分組事物是套件 (Package) 。套件是把元素組織成組的機制，這種機制具有多種用途。結構事物、行為事物甚至其他分組事物都可以放進套件內。套件與元件 (僅在執行時存在) 不同，它純粹是概念上的 (即它僅在開發時存在)\n(4) 註釋事物 (Annotational Thing) 註釋事物是 UML 模型的解釋部分。這些註釋事物用來描述、說明和標註模型的任何元素。註記 (Note) 是一種主要的註釋事物。註記是一個依附於一個元素或者一組元素之上，對它進行約束或解釋的簡單符號\n關係 UML 中有 4 種關係：依賴、關聯、泛化和實現\n依賴 (Dependency) 依賴是兩個事物間的語義關係，其中一個事物 (獨立事物) 發生變化會影響另一個事物 (依賴事物) 的語義。在圖形上，把一個依賴畫成一條可能有方向的虛線\n關聯 (Association) 關聯是一種結構關係，它描述了一組鏈，鏈是物件之間的連接。聚合 (Aggregation) 是一種特殊類型的關聯，它描述了整體和部分間的結構關係。在關聯上可以標註重複度 (Multiplicity) 和角色 (Role)\n關聯、聚合、組合 關聯：關聯是一種結構關係，它描述了一組鏈，鏈是物件之間的連接。在關聯上可以標註重複度 (多重度) 和角色 例：雇主與員工\n聚合：部分和整體的生命週期不一致，整體消失了，部分仍然存在，部分可以脫離整體存在 例：班級與學生，公司與員工\n組合：部分和整體的生命週期一致，整體消失了，部分也消失了，部分不可以脫離整體存在 例：人與大腦\n依賴與單向關聯 依賴較偶然，臨時。例如：人與食物，僅餓時依賴，飽了便不依賴\n單向關聯，比較強烈，用單向線表示。例如：人與氧氣，魚與水\n泛化 (Generalization) 泛化是一種特殊/一般關係，特殊元素 (子元素) 的物件可替代一般元素 (父元素) 的物件。用這種方法，子元素共享了父元素的結構和行為。圖形上指向父元素\n實現 (Realization) 實現是類元之間的語義關係，其中一個類元指定了由另一個類元保證執行的契約。在兩種情況下會使用實現關係：一種是在介面和實現它們的類別或元件之間；另一種是在使用案例和實現它們的協作之間\n","date":"2023-04-11T08:01:00+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/103/","title":"UML"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 從想法產生到徹底實現，一共耗時三個月 (主要是太懶了)\n安裝 Docker 使用了 APT 進行安裝 (系統為 Debian)\n新增 HTTPS 傳輸的套件以及 CA 憑證 1 2 3 4 5 6 7 8 9 10 # 先更新一下 sudo apt-get update # 然後安裝 sudo apt-get install \\ apt-transport-https \\ ca-certificates \\ curl \\ gnupg \\ lsb-release 為了確認所下載套件的合法性，需要新增軟體源的 GPG 金鑰 1 2 3 4 5 6 # 國內來源 curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/debian/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg # 官方來源 curl -fsSL https://download.docker.com/linux/debian/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg 向 sources.list 中新增 Docker 軟體源 首先需要確定 Debian 的版本號，然後替換下面命令的 $(lsb_release -cs)\n版本號需要在 https://mirrors.aliyun.com/docker-ce/linux/debian/dists/ 中\n1 2 3 4 5 6 7 8 9 10 # 國內來源 echo \\ \u0026#34;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://mirrors.aliyun.com/docker-ce/linux/debian \\ $(lsb_release -cs) stable\u0026#34; | sudo tee /etc/apt/sources.list.d/docker.list \u0026gt; /dev/null # 官方來源 echo \\ \u0026#34;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/debian \\ $(lsb_release -cs) stable\u0026#34; | sudo tee /etc/apt/sources.list.d/docker.list \u0026gt; /dev/null 如 Debian10 的是 buster ，Debian11 的為 bullseye\n1 2 3 4 # 此為 Debian11 的 echo \\ \u0026#34;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://mirrors.aliyun.com/docker-ce/linux/debian \\ bullseye stable\u0026#34; | sudo tee /etc/apt/sources.list.d/docker.list \u0026gt; /dev/null 以上命令會新增穩定版本的 Docker APT 來源，如果需要測試版本的 Docker 請將 stable 改為 test\n然後安裝 1 2 3 4 5 6 7 8 # 更新快取 sudo apt-get update # 安裝 docker sudo apt-get install docker-ce docker-ce-cli containerd.io # 安裝 docker-compose sudo apt-get install docker-compose 或者可以試試一鍵安裝腳本\n1 2 3 4 5 6 7 8 9 10 11 # 測試版 curl -fsSL test.docker.com -o get-docker.sh # 以下為穩定版 curl -fsSL get.docker.com -o get-docker.sh # 阿里雲來源 sudo sh get-docker.sh --mirror Aliyun # 微軟 AzureChina 來源 sudo sh get-docker.sh --mirror AzureChinaCloud 啟動 Docker 1 2 sudo systemctl enable docker sudo systemctl start docker 使用以下命令測試是否成功啟動\n1 docker run --rm hello-world 出現下述類似輸出即安裝啟動成功\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 Unable to find image \u0026#39;hello-world:latest\u0026#39; locally latest: Pulling from library/hello-world 2db29710123e: Pull complete Digest: sha256:c77be1d3a47d0caf71a82dd893ee61ce01f32fc758031a6ec4cf1389248bb833 Status: Downloaded newer image for hello-world:latest Hello from Docker! This message shows that your installation appears to be working correctly. To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the \u0026#34;hello-world\u0026#34; image from the Docker Hub. (amd64) 3. The Docker daemon created a new container from that image which runs the executable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent it to your terminal. To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bash Share images, automate workflows, and more with a free Docker ID: https://hub.docker.com/ For more examples and ideas, visit: https://docs.docker.com/get-started/ Blog1: WordPress 建立相應資料夾 (例如 /root/wordpress)，然後建立 docker-compose.yml 檔案\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 version: \u0026#39;3.3\u0026#39; services: db: image: mysql:5.7 volumes: - db_data:/var/lib/mysql restart: always environment: MYSQL_ROOT_PASSWORD: somewordpress MYSQL_DATABASE: wordpress MYSQL_USER: wordpress MYSQL_PASSWORD: wordpress wordpress: depends_on: - db image: wordpress:latest volumes: - /root/wordpress/uploads.ini:/usr/local/etc/php/conf.d/uploads.ini ports: - 8000:80 restart: always environment: WORDPRESS_DB_HOST: db:3306 WORDPRESS_DB_USER: wordpress WORDPRESS_DB_PASSWORD: wordpress WORDPRESS_DB_NAME: wordpress volumes: db_data: {} 建立 uploads.ini 檔案\n1 2 3 4 5 file_uploads = On memory_limit = 256M upload_max_filesize = 10M post_max_size = 10M max_execution_time = 600 docker 容器執行相關 1 2 3 4 5 6 7 8 # 背景執行 docker-compose up -d # 停止 docker-compose stop # 停止並刪除 docker-compose down Blog2: Typecho 使用映像檔： 80x86/typecho 建立資料夾與相應檔案\n1 2 3 4 5 6 7 8 9 10 11 12 13 version: \u0026#39;3.0\u0026#39; services: typecho: image: 80x86/typecho:latest container_name: Typecho_Blog volumes: - /root/typecho/data:/data ports: - 8001:80 restart: always environment: PHP_TZ: Asia/Shanghai PHP_MAX_EXECUTION_TIME: 600 網路硬碟網站 使用專案： https://github.com/px-org/PanIndex 官方教學： https://docs.noki.icu/ 1 2 3 4 5 6 7 8 9 10 version: \u0026#34;3.0\u0026#34; services: PanIndex: restart: always image: iicm/pan-index:latest container_name: VRC_Pan volumes: - /root/pan/data:/app/data ports: - 8002:5238 nginx 與 SSL 憑證 使用專案： https://github.com/0xJacky/nginx-ui 1 2 3 4 5 6 7 8 9 10 11 12 13 version: \u0026#39;3.1\u0026#39; services: nginx-ui: restart: always image: uozi/nginx-ui:latest container_name: nginx_UI volumes: - /root/nginx/nginx:/etc/nginx - /root/nginx/nginx-ui:/etc/nginx-ui - /root/nginx/www:/www ports: - 80:80 - 443:443 在配置時代理宿主機的話，可以將宿主機 IP 視為 172.17.0.1\n具體可透過一些命令查詢\n1 ip addr show docker0 GUI 沒什麼好說的\n進入容器內部 獲取容器 ID 1 docker container ls 進入 1 docker exec -i [ID] bash 然後使用 bash 命令即可 (沒有 bash 提示符號)\n以下僅記錄 耗時最長的就是調校 nginx 和 ssl 配置了，最後一直不成功，便使用 GUI\nSSL 憑證 使用了 neilpang/acme.sh ，使用了 DNS 驗證，其他方式請參考 Run acme.sh in docker · acmesh-official/acme.sh Wiki (github.com) 建立相應資料夾與檔案\n1 2 3 4 5 6 7 8 9 10 11 12 version: \u0026#39;3.1\u0026#39; services: acme.sh: image: neilpang/acme.sh container_name: acme.sh command: daemon volumes: - /root/acme/acme.sh:/acme.sh - /root/acme/conf:/.acme.sh environment: - CF_Key=\u0026#34;這是CF的API\u0026#34; - CF_Email=\u0026#34;這是CF的信箱\u0026#34; 對於其他 DNS 服務商，請參考： https://github.com/acmesh-official/acme.sh/wiki/dnsapi 註冊帳號：\n1 docker exec acme.sh --register-account -m mail@server.com 獲取憑證 (此處為 CF)\n1 docker exec acme.sh --issue --dns dns_cf -d example.com -d www.example.com 獲取後的憑證和儲存目錄會列印出來，將此目錄對應到 nginx 容器\n可以設置 cron 定時任務以自動更新憑證，參考： Linux Crontab 定時任務 - 菜鳥教程 參考資料\ndocker獲取Let\u0026rsquo;s Encrypt永久免費SSL憑證 - 騰訊雲開發者社區-騰訊雲 (tencent.com) ZeroSSL.com CA · acmesh-official/acme.sh Wiki (github.com) Nginx 建立相應資料夾 (例如 /root/nginx)，然後建立 docker-compose.yml\n1 2 3 4 5 6 7 8 9 10 11 12 13 version: \u0026#39;3.1\u0026#39; services: nginx: restart: always image: nginx container_name: nginx ports: - 80:80 volumes: - /root/docker/nginx/conf.d:/etc/nginx/conf.d - /root/docker/nginx/www:/user/share/nfinx/html - /root/docker/nginx/log:/var/log/nginx - /root/acme/acme.sh:/ssl 然後執行，啟動後當前目錄有 conf.d 資料夾，在該資料夾新建以 .conf 為副檔名的檔案，例如 default.conf\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 server { listen 80; listen [::]:80; server_name \u0026lt;your_server_name\u0026gt;; rewrite ^(.*)$ https://$host$1 permanent; } map $http_upgrade $connection_upgrade { default upgrade; \u0026#39;\u0026#39; close; } server { listen 443 ssl http2; listen [::]:443 ssl http2; server_name \u0026lt;your_server_name\u0026gt;; # ssl 憑證位置 ssl_certificate /path/to/ssl_cert; # ssl 金鑰位置 ssl_certificate_key /path/to/ssl_cert_key; location / { proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection $connection_upgrade; proxy_pass http://172.17.0.1:9000/; } } 參考資料\ndocker安裝nginx並配置ssl憑證，代理宿主機服務_Blueeyedboy521的博客-CSDN博客_bitwarden docker ssl Nginx 安裝 SSL 配置 HTTPS 超詳細完整全過程-阿里雲開發者社區 (aliyun.com) 快速部署 Docker 同時發布多個網站或服務_天道酬勤~的博客-CSDN博客_docker部署 一台服务器多个系统 Let\u0026rsquo;s Encrypt 使用教學，免費的SSL憑證，讓你的網站擁抱 HTTPS - Diamond-Blog (diamondfsd.com) Nginx反向代理的一次使用總結 - 簡書 (jianshu.com) Nginx配置反向代理隱藏服務埠 - \u0026amp;大飛 - 博客園 (cnblogs.com) 參考文章 Debian - Docker — 從入門到實踐 (gitbook.io) Docker 安裝 Wordpress 博客 - 騰訊雲開發者社區-騰訊雲 (tencent.com) Docker部署WordPress解決“上傳的檔案尺寸超過php.ini中定義的upload_max_filesize值”問題_neiro-DevPress官方社區 (csdn.net) let’s Encrypt 憑證之安裝故障 Could not bind to IPv4 or IPv6. - 料網 (liaosam.com) 基於Let\u0026rsquo;s Encrypt生成免費憑證-支援多網域泛網域憑證 - DevOps在路上 - 博客園 (cnblogs.com) Docker Compose-菜鳥教程 (runoob.com) Nginx配置文件詳解 - 程序員自由之路 - 博客園 (cnblogs.com) Docker使用acme.sh申請ssl憑證 – 萌精靈 (moeelf.com) docker安裝nginx並配置ssl憑證，代理宿主機服務 ","date":"2023-04-04T22:31:45+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/102/","title":"伺服器用 Docker 部署紀錄"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 軟體工程系列文章六\n軟體品質是指反映軟體系統或軟體產品滿足規定或隱含需求能力之特徵與特性的全體。\n軟體品質管理是指對軟體開發過程進行獨立的檢查活動，由品質保證、品質規劃與品質控制 3 個主要活動構成。\n軟體品質保證是指為了保證軟體系統或軟體產品充分滿足使用者要求的品質，而進行的有計劃、有組織的活動，其目的是生產高品質的軟體。\n軟體品質特性 討論軟體品質首先要瞭解軟體的品質特性。目前已有套多種軟體品質模型來描述軟體品質特性，例如 ISO/IEC 9126 軟體品質模型與 Mc Call 軟體品質模型。\nISO/IEC 9126 軟體品質模型 ISO/IEC 9126 軟體品質模型由 3 個層次組成：第一層是品質特性，第二層是品質子特性，第三層是度量指標。\n功能性 (Functionality) 與一組功能及其指定的性質之存在有關的一組屬性，功能是指滿足規定或隱含需求的那些功能。\n適應性 (Suitability)：與對規定任務能否提供一組功能，以及這組功能是否適合有關的軟體屬性。 準確性 (Accurateness)：與能夠得到正確或相符的結果或效果有關的軟體屬性。 互通性 (Interoperability)：與其他指定系統進行互動操作的能力相關的軟體屬性。 依從性 (Compliance)：使軟體服從有關的標準、約定、法規及類似規定的軟體屬性。 安全性 (Security)：與避免對程式及資料的非授權故意或意外存取的能力有關的軟體屬性。 可靠性 (Reliability) 與在規定的一段時間內和規定的條件下，軟體維持在其效能水準有關的能力。\n成熟性 (Maturity)：與由軟體故障引起失效的頻度有關的軟體屬性。 容錯性 (Fault tolerance)：與在軟體錯誤或違反指定介面的情況下，維持指定的效能水準的能力有關的軟體屬性。 易恢復性 (Recoverability)：與在故障發生後，重新建立其效能水準並恢復直接受影響資料的能力，以及為達到此目的所需的時間與努力有關的軟體屬性。 易用性 (Usability) 與為使用所需的努力，以及由一組規定或隱含的使用者對這樣使用所做的個別評價有關的一組屬性。\n易理解性 (Understandability)：與使用者為理解邏輯概念及其應用所付出的勞動有關的軟體屬性。 易學性 (Learnability)：與使用者為學習其應用（例如操作控制、輸入、輸出）所付出的努力相關的軟體屬性。 易操作性 (Operability)：與使用者為進行操作和操作控制所付出的努力有關的軟體屬性。 效率 (Efficiency) 在規定條件下，與軟體的效能水準與所用資源量之間的關係有關的軟體屬性。\n時間特性 (Time behavior)：與回應和處理時間，以及軟體執行其功能時的吞吐量有關的軟體屬性。 資源特性 (Resource behavior)：與軟體執行其功能時，所使用的資源量以及使用資源的持續時間有關的軟體屬性。 可維護性 (Maintainability) 與進行規定的修改所需要的努力有關的一組屬性。\n易分析性 (Analyzability) ：與為診斷缺陷或失效原因，或為判定待修改的部分所需努力有關的軟體屬性。 易變更性 (Changeability) ：與進行修改、除錯或適應環境變換所需努力有關的軟體屬性。 穩定性 (Stability) ：與修改造成未預期效果的風險有關的軟體屬性。 易測試性 (Testability) ：與確認經修改軟體所需努力有關的軟體屬性。 可攜性 (Portability) 與軟體可從某一環境轉移到另一環境的能力有關的一組屬性。\n適應性 (Adaptability) ：與軟體轉移到不同環境時的處理或手段有關的軟體屬性。 易安裝性 (Installability) ：與在指定環境下安裝軟體所需努力有關的軟體屬性。 符合性 (Conformance) ：使軟體服從與可攜性有關的標準或約定的軟體屬性。 易替換性 (Replaceability) ：與一軟體在該軟體環境中用來替代指定的其他軟體的可能和努力有關的軟體屬性。 Mc Call 軟體品質模型 Mc Call 軟體品質模型從軟體產品的執行、修正和轉移 3 個層面確定了 11 個品質特性。\nMc Call 也給出了一個三層模型框架。第一層是品質特性，第二層是評價準則，第三層是度量指標。\n軟體評審 通常將「品質」理解為「使用者滿意程度」。為了使使用者滿意，有以下兩個必要條件：\n設計的規格說明書符合使用者的要求，這稱為設計品質。 程式按照設計規格說明所規定的情況正確執行，這稱為程式品質。 設計品質的評審內容 設計品質評審的對象是在需求分析階段產生的軟體需求規格說明、資料需求規格說明，以及在軟體概要設計階段產生的軟體概要設計說明書等。通常從以下幾個方面進行評審：\n評價軟體的規格說明是否合乎使用者的要求，即總體設計思想和設計方針是否明確；需求規格說明是否得到了使用者或單位上級機關的批准；需求規格說明與軟體的概要設計規格說明是否一致等。 評審可靠性，即是否能避免輸入異常（錯誤或超載等）、硬體失效及軟體失效所產生的失效，一旦發生應能及時採取替代手段或恢復手段。 評審安全保密措施實施情況，即是否對系統使用資格進行檢查。 評審操作特性實施情況，即操作命令和操作資訊的恰當性；輸入資料與輸入控制語句的恰當性；輸出資料的恰當性；回應時間的恰當性等。 評審效能實現情況，即是否達到所規定效能的目標值。 評審軟體是否具有可修改性、可擴充性、可互換性和可攜性。 評審軟體是否具有可測試性。 評審軟體是否具有再用性。 程式品質的評審內容 程式品質評審通常是從開發者的角度進行評審，與開發技術直接相關。它是著眼於軟體本身的結構、與執行環境的介面以及變更帶來的影響而進行的評審活動。\n軟體的結構如下：\n功能結構。需要檢查的項目： 資料結構 功能結構 資料結構和功能結構之間的對應關係 功能的通用性 模組的層次 模組結構。模組層次結構是模組的靜態結構，現在要檢查模組的動態結構。模組分為處理模組和資料模組兩類，模組間的動態結構也與這些模組分類有關。對這樣的模組結構進行檢查的項目如下： 控制流結構 資料流結構 模組結構與功能結構之間的對應關係 處理過程的結構 與執行環境的介面 執行環境包括硬體、其他軟體和使用者，主要的檢查項目如下：\n與硬體的介面。包括與硬體的介面約定，即根據硬體的使用說明等所做出的規定；硬體故障時的處理和超載時的處理。 與使用者的介面。包括與使用者的介面約定，即輸入資料的結構；輸出資料的結構；異常輸入時的處理，超載輸入時的處理；使用者存取權限的檢查等。 軟體容錯技術 提高軟體品質和可靠性的技術大致可分為兩類：一類是避免錯誤，即在開發的過程中不讓差錯潛入軟體的技術；另一類是容錯技術，即對某些無法避免的差錯，使其影響減至最小的技術。\n容錯軟體的定義 規定功能的軟體，在一定程度上對自身錯誤的作用（軟體錯誤）具有屏蔽能力，則該軟體為容錯軟體。 規定功能的軟體，在一定程度上能從錯誤狀態自動恢復到正常狀態，則該軟體為容錯軟體。 規定功能的軟體，在因錯誤發生故障時仍然能在一定程度上完成預期的功能，則該軟體為容錯軟體。 規定功能的軟體，在一定程度上具有容錯能力，則該軟體為容錯軟體。 容錯的一般方法 實現容錯的主要手段是冗餘。冗餘是指對於實現系統規定功能是多餘的那部分資源，包括硬體、軟體、資訊和時間。由於加入了這些資源，有可能使系統的可靠性得到較大的提高。通常，冗餘技術分為 4 類：\n結構冗餘。結構冗餘是通常採用的冗餘技術，按其工作方法可以分為靜態、動態和混合冗餘 3 種。 靜態冗餘 動態冗餘 混合冗餘 資訊冗餘。為檢測或糾正資訊在運算或傳輸中的錯誤需外加一部分資訊。 時間冗餘。指以重複執行指令或程式來消除瞬時錯誤帶來的影響。 冗餘附加技術。指為實現上述冗餘技術所需的資源和技術，包括程式、指令、資料、存放和調動它們的空間和通道等。 在屏蔽硬體錯誤的容錯技術中，冗餘附加技術包括：\n關鍵程式和資料的冗餘儲存及調用。 檢測、表決、切換、重構、糾錯和複算的實現。 在屏蔽軟體錯誤的容錯系統中，冗餘附加技術的構成包括：\n冗餘備份程式的儲存及調用。 實現錯誤檢測和錯誤恢復的程式。 實現容錯軟體所需的固化程式。 軟體工具 用來輔助軟體開發、執行、維護、管理和支援等過程中的活動的軟體稱為軟體工具。\n軟體開發工具 對應於軟體開發過程的各種活動，軟體開發工具通常有需求分析工具、設計工具、編碼與除錯工具、測試工具等。\n軟體維護工具 輔助軟體維護過程中活動的軟體稱為軟體維護工具，它輔助維護人員對軟體程式碼及其文件進行各種維護活動。軟體維護工具主要有版本控制工具、文件分析工具、開發資訊庫工具、逆向工程工具和再造工程工具。\n","date":"2023-04-03T19:59:00+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/101/","title":"軟體工程-軟體品質與軟體工具"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 軟體工程系列文章五\n軟體專案的成功率非常低的原因，可能就是專案管理能力太弱。由於軟體本身的特殊性及複雜性，將專案管理思想引入軟體工程領域，就形成了軟體專案管理。\n軟體專案管理涉及的範圍 有效的軟體專案管理集中在 4 個 P 上，即人員 (Person)、產品 (Product)、過程 (Procedure) 和專案 (Project)。\n軟體專案估算 軟體專案估算涉及人、技術、環境等多種因素，因此，需要一些方法和技術來支持專案的估算，常用的估算方法有下列 3 種：\n基於已經完成的類似專案進行估算。 基於分解技術進行估算。 基於經驗估算模型的估算。典型的有 IBM 估算模型、CoCoMo 模型和 Putnam 模型。 上述方法可以組合使用，以提高估算的精度。\nCOCOMO 估算模型 COCOMO 模型是一種精確的、易於使用的成本估算模型。COCOMO 模型按其詳細程度分為基本 COCOMO 模型、中級 COCOMO 模型和詳細 COCOMO 模型。\n基本 COCOMO 模型 基本 COCOMO 模型是一個靜態單變量模型，用於對整個軟體系統進行估算。\n其公式如下：\nE=a(L)b D=cEd 其中，E 表示工作量，單位是人月；D 表示開發時間，單位是月；L 是專案的原始碼行估計值，不包括程式中的註解及文件，其單位是千行程式碼 (KLOC)；a、b、c、d 是常數。\n基本 COCOMO 模型可透過估算程式碼行的值 L，然後計算開發工作量和開發時間的估算值。\n中級 COCOMO 模型 中間 COCOMO 模型是一個靜態多變量模型，它將軟體系統模型分為系統和部件兩個層次，系統由部件構成，它把軟體開發所需的人力 (成本) 看作是程式大小和一系列「成本驅動屬性」的函數。\n中級 COCOMO 模型以基本 COCOMO 模型為基礎，並考慮了 15 種影響軟體工作量的因素，透過工作量調節因子 (EAF) 修正對工作量的估算，從而使估算更合理。\n其公式如下：\nE=a(L)bEAF 其中，L 是軟體產品的目標程式碼行數，單位是千行程式碼數；a、b 是常數。\n詳細 COCOMO 模型 它將軟體系統模型分為系統、子系統和模組 3 個層次，除包括中級模型所考慮的因素外，還考慮了在需求分析、軟體設計等進一步的成本驅動屬性的影響。\nCOCOMOII 模型 最初的 COCOMO 模型是得到產業界最廣泛應用和討論的軟體成本估算模型之一，現在它已經演化成更全面的估算模型，稱為 COCOMOII。和其前身一樣，COCOMOII 也是一種階層結構的估算模型，被分為 3 個階段性模型：\n應用組裝模型。在軟體工程的前期階段使用，這時使用者介面的原型開發、對軟體和系統互動的考慮、效能的評估以及技術成熟度的評價是最重要的。 早期設計階段模型。在需求已經穩定並且基本的軟體體系結構已經建立時使用。 體系結構階段模型。在軟體的構造過程中使用。 和所有的軟體估算模型一樣，COCOMOII 模型也需要使用規模估算資訊，在模型階層結構中有 3 種不同的規模估算選擇：物件點、功能點和程式碼行。應用組裝模型使用的是物件點；早期設計階段模型使用的是功能點，功能點可以轉換為程式碼行。\n進度管理 軟體專案進度管理的目的是確保軟體專案在規定的時間內按期完成。\n進度管理的基本原則 劃分 相互依賴性 時間分配 工作量確認 確定責任 明確輸出結果 確定里程碑 進度安排 進度安排的常用圖形描述方法有 Gantt 圖 (甘特圖) 和專案計畫評核術 (Program Evaluation \u0026amp; Review Technique, PERT) 圖。\nGantt 圖 Gantt 圖是一種簡單的水平條形圖，它以行事曆為基準描述專案任務。水平軸表示行事曆時間線 (如時、天、週、月和年等)，每個條形表示一個任務，任務名稱垂直地列在左邊的列中，圖中水平條的起點和終點對應水平軸上的時間，分別表示該任務的開始時間和結束時間，水平條的長度表示完成該任務所持續的時間。當行事曆中同一時段存在多個水平條時，表示任務之間的併發。\nGantt 圖能清晰地描述每個任務從何時開始，到何時結束，任務的進展情況以及各個任務之間的並行性。但是它不能清晰地反映出各任務之間的依賴關係，難以確定整個專案的關鍵所在，也不能反映計畫中有潛力的部分。\nPERT 圖 PERT 圖是一個有向圖，圖中的箭頭表示任務，它可以標上完成該任務所需的時間。圖中的節點表示流入節點的任務的結束，並開始流出節點的任務，這裡把節點稱為事件。只有當流入該節點的所有任務都結束時，節點所表示的事件才出現，流出節點的任務才可以開始。事件本身不消耗時間和資源，它僅表示某個時間點。\n一個事件有一個事件號和出現該事件的最早時刻和最遲時刻。最早時刻表示在此時刻之前從該事件出發的任務不可能開始；最遲時刻表示從該事件出發的任務必須在此時刻之前開始，否則整個工程就不能如期完成。每個任務還可以有一個寬裕時間 (Slack Time)，表示在不影響整個工期的前提下完成該任務有多少機動餘地。\nPERT 圖不僅給出了每個任務的開始時間、結束時間和完成該任務所需的時間，還給出了任務之間的關係，即哪些任務完成後才能開始另外一些任務，以及如期完成整個工程的關鍵路徑。圖中的寬裕時間 (最遲時刻 - 最早時刻) 則反映了完成某些任務時可以推遲其開始時間或延長其所需完成的時間。但是，PERT 圖不能反映任務之間的並行關係。\n軟體配置管理 軟體配置管理其主要目標包括：變更識別、變更控制、版本控制、確保變更正確的實現、變更報告。\n軟體配置管理其主要內容包括：版本管理、配置支援、變更支援、過程支援、團隊支援、變化報告、稽核支援。\n或者：軟體配置識別、變更管理、版本控制、系統建立、配置審核、配置狀態報告。\n配置資料庫可以分為以下三類：\n開發庫。專供開發人員使用，其中的資訊可能做頻繁修改，對其控制相對寬鬆。 受控庫。在生存期某一階段工作結束時發布的階段產品，這些是與軟體開發工作相關的電腦可讀資訊和人工可讀資訊。軟體配置管理正是對受控庫中的各個軟體項進行管理，受控庫也稱為軟體配置庫。 產品庫。在開發的軟體產品完成系統測試後，作為最終產品存入產品庫，等待交付用戶或現場安裝。 風險管理 一般認為軟體風險包含兩個特性：不確定性和損失。不確定性是指風險可能發生也可能不發生；損失是指如果風險發生，就會產生惡性後果。在進行風險分析時，重要的是量化每個風險的不確定程度和損失程度。為了實現這一點，必須考慮不同類型的風險。\n專案風險威脅到專案計畫。也就是說，如果專案風險發生，就有可能拖延專案的進度和增加專案成本。專案風險是指預算、進度、人員 (聘用職員及組織)、資源、利益相關者、需求等方面的潛在問題以及它們對軟體專案的影响。專案複雜度、規模及結構不確定性也屬於專案風險因素。\n技術風險威脅到要開發軟體的品質及交付時間。如果技術風險發生，開發工作就可能變得很困難或根本不可能，技術風險是指設計、實現、介面、驗證和維護等方面的潛在問題。此外，規格說明的歧義性、技術的不確定性、技術陳舊以及「前沿」技術也是技術風險因素。技術風險的發生是因為問題比我們所設想的更加難以解決。\n商業風險威脅到要開發軟體的生存能力，且常常會危害到專案或產品。5 個主要的商業風險如下：\n市場風險。開發了一個沒有人真正需要的優良產品。 策略風險。開發的產品不再符合公司的整體商業策略。 銷售風險。開發了一個銷售部門不知道如何去銷售的產品。 管理風險。由於重點的轉移或人員的變動而失去了高階管理層的支持。 預算風險。沒有得到預算或人員的保證。 (一) 風險識別 風險識別試圖系統化地指出對專案計畫 (估算、進度、資源分配等) 的威脅。識別出已知風險和可預測風險後，專案管理者首先要做的是在可能時迴避這些風險，在必要時控制這些風險。\n識別風險的一種方法是建立風險條目檢查表。該檢查表可用於風險識別，並且主要用來識別下列幾種類型中的一些已知風險和可預測風險：\n產品規模。與要開發或要修改的軟體的總體規模相關的風險。 商業影響。與管理者或市場所施加的約束相關的風險。 客戶特性。與客戶的素質以及開發者和客戶定期溝通的能力相關的風險。 過程定義。與軟體過程定義的程度以及該過程被開發組織遵守的程度相關的風險。 開發環境。與用來開發產品的工具的可得性及品質相關的風險。 開發技術。與待開發軟體的複雜性及系統所包含技術的「新奇性」相關的風險。 人員才幹及經驗。與軟體工程師的總體技術水平及專案經驗相關的風險。 風險條目檢查表可以採用不同的方式來組織。與上述每個主題相關的問題可以針對每一個軟體專案來回答。根據這些問題的答案，專案管理者就可以估計風險產生的影響。\n當然，也可以採用另一種風險條目檢查表格式，即僅僅列出與每一種類型有關的特性，最終給出一組風險因素和驅動因子以及它們發生的機率。風險因素包括效能、成本、支援和進度。風險因素是以如下方式定義的：\n效能風險。產品能夠滿足需求且符合其使用目的的不確定程度。 成本風險。能夠維持專案預算的不確定程度。 支援風險。開發出的軟體易於糾錯、修改及升級的不確定程度。 進度風險。能夠維持專案進度且按時交付產品的不確定程度。 (二) 風險預測 風險預測又稱風險估計，它試圖從兩個方面評估一個風險：風險發生的可能性或機率；如果風險發生了所產生的後果。\n(1) 風險預測活動 通常，專案計畫人員與管理人員、技術人員一起進行以下 4 步風險預測活動：\n建立一個尺度或標準，以反映風險發生的可能性。 描述風險產生的後果。 估算風險對專案和產品的影響。 標注風險預測的整體精確度，以免產生誤解。 一種簡單的風險預測技術是建立風險表。風險表的第 1 列列出所有的風險 (由風險識別活動得到)，第 2-4 列列出每個風險的種類、發生的機率以及所產生的影響。風險所產生的影響可用一個數字來表示：「1」表示災難性的；「2」表示嚴重的；「3」表示輕微的；「4」表示可忽略的。\n(2) 評估風險影響 如果風險真的發生，有 3 個因素可能會影響風險所產生的後果，即風險的本質、範圍和時間。風險的本質是指當風險發生時可能會帶來的問題。例如，一個定義很差的與客戶硬體的外部介面 (技術風險) 會妨礙早期的設計和測試，也有可能導致專案後期階段的系統整合問題。風險的範圍包括風險的嚴重性 (即風險有多嚴重) 及風險的整體分布情況 (即專案中有多少部分受到影響或有多少客戶受到損害)。風險的時間是指何時能夠感受到風險的影響及風險的影響會持續多長時間。在大多數情況下，專案管理者希望「壞消息」越早出現越好，但在某些情況下則是越遲越好。\n整體的風險顯露度 (Risk Exposure, RE) 可由下面的關係確定：\nRE=P×C 其中，P 是風險發生的機率，C 是風險發生時帶來的專案成本。\n(三) 風險評估 在進行風險評估時，建立了如下形式的三元組：\n(Ri, li, xi) 其中，ri 表示風險，li 表示風險發生的機率，xi 表示風險產生的影響。\n一種對風險評估很有用的技術就是定義風險參考水準。對於大多數軟體專案來說，成本、進度和效能就是 3 種典型的風險參照水準。也就是說，對於成本超支、進度延期、效能降低 (或它們的某種組合)，有一個表明導致專案終止的水準。\n在風險評估過程中，需要執行以下 4 個步驟：\n定義專案的風險參考水平值。 建立每一組 (Ri, li, xi) 與每一個參考水平值之間的關係。 預測一組臨界點以定義專案終止區域，該區域由一條曲線或不確定區域所界定。 預測什麼樣的風險組合會影響參考水平值。 (四) 風險控制 風險控制的目的是輔助專案組建立處理風險的策略。一個有效的策略必須考慮以下 3 個問題：\n(1) 風險避免 應對風險的最好方法是主動地避免風險，即在風險發生前分析引起風險的原因，然後採取措施，以避免風險的發生。\n例如專案風險 ri 表示「頻繁的人員流動」，根據歷史經驗可知，該風險發生的機率 li 大約為 70%，該風險產生的影響 xi 是第 2 級 (嚴重的)。為了避免該風險，可以採取以下策略：\n與現有人員一起探討人員流動原因 (如惡劣的工作條件、低報酬、競爭激烈的勞動力市場等)。 在專案開始之前採取行動，設法緩解那些能夠控制的起因。 專案啟動之後，假設會發生人員流動，當有人員離開時，找到能夠保證工作連續性的方法。 組織專案團隊，使得每一個開發活動的資訊都能被廣泛傳播和交流。 制定工作產品標準，並建立相應機制以確保能夠及時建立所有的模型和文件。 同等對待所有工作的評審。 給每一個關鍵的技術人員都指定一個備援人員。 (2) 風險監控 專案管理者應監控某些因素，這些因素可以提供風險是否正在變高或變低的指示。在頻繁的人員流動的例子中，應該監測團隊成員對專案壓力的普遍態度、團隊的凝聚力、團隊成員彼此之間的關係、與報酬和利益相關的潛在問題、在公司內及公司外工作的可能性。\n(3) RMMM 計畫 風險管理策略可以包含在軟體專案計畫中，或者風險管理步驟也可以組織成一個獨立的風險緩解、監控和管理計畫 (RMMM 計畫)。RMMM 計畫將所有風險分析工作文件化，並由專案管理者作為整個專案計畫中的一部分來使用。\n建立了 RMMM 計畫，而且專案已經啟動之後，風險緩解及檢測步驟也就開始了。風險緩解是一種問題規避活動，而風險檢測是一種專案追蹤活動，這種監測活動有 3 個主要目的：評估所預測的風險是否真的發生了；保證正確地實施了各風險的緩解步驟；收集能夠用於今後風險分析的資訊。在很多情況下，專案中發生的問題可以追溯到不止一個風險，所以風險監測的另一個任務就是試圖找到「起源」(在整個專案中是哪些風險引起了哪些問題)。\n","date":"2023-04-02T06:58:00+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/100/","title":"軟體工程-軟體專案管理"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 軟體工程系列文章四\n軟體維護是軟體生命週期的最後一個階段，處於系統投入生產性執行之後的時期，因此不屬於系統開發過程。軟體維護是在軟體已經交付使用之後，為了改正錯誤或滿足新的需求而修改軟體的過程，即軟體在交付使用後對軟體所做的一切改動。\n系統可維護性概念 系統的可維護性可以定義為維護人員理解、改正、改動和改進這個軟體的難易程度。提高可維護性是開發軟體系統所有步驟的關鍵目的，系統是否能被很好地維護，可以用系統的可維護性這一指標來衡量。\n系統可維護指標 可理解性：指別人能理解系統的結構、介面、功能和內部過程的難易程度。模組化、詳細設計文件、結構化設計和良好的高階程式設計語言等都有助於提高可理解性。 可測試性：診斷和測試的容易程度取決於易理解的程度。好的文件資料有利於診斷和測試，同時，程式的結構、高效能的測試工具以及周密計劃的測試程序也是至關重要的。為此，開發人員在系統設計和程式設計階段就應盡力把程式設計成易診斷和測試的。此外，在進行系統維護時，應該充分利用在系統測試階段保存下來的測試案例。 可修改性：診斷和測試的容易程度與系統設計所制定的設計原則有直接關係。模組的耦合、內聚、作用範圍與控制範圍的關係等都對可修改性有影響。 維護與軟體文件 文件是軟體可維護性的決定因素。由於長期使用的大型軟體系統在使用過程中必然會經過多次修改，所以文件顯得非常重要。\n軟體系統的文件可以分為使用者文件和系統文件兩類。使用者文件主要描述系統功能和使用方法，並不關心這些功能是如何實作的；系統文件描述系統設計、實作和測試等各方面的內容。\n可維護性是所有軟體都應具有的基本特點，必須在開發階段保證軟體具有可維護性的特點。在軟體工程的每一個階段都應考慮並提高軟體的可維護性，在每個階段結束前的技術審查和管理複查中，應該著重對可維護性進行複審。\n軟體文件 編寫高品質文件可以提高軟體開發的品質。\n文件也是軟體的一部分，沒有文件的軟體就不能稱之為軟體。\n軟體文件的編制在軟體開發工作中佔有突出的地位和相當大的工作量，高品質的文件對於軟體產品的效益有著重要的意義。\n系統維護的內容及類型 系統維護主要包括硬體維護、軟體維護和資料維護。\n硬體維護 硬體維護應由專職的硬體維護人員來負責。\n軟體維護 軟體維護主要是根據需求變化或硬體環境的變化對應用程式進行部分或全部修改。修改時充分利用原始程式，修改後要填寫程式修改登記表，並在程式變更通知書上寫明新舊程式的不同之處。\n軟體維護的內容一般有以下幾個方面：\n改正性維護：指改正性在系統開發階段已發現而系統測試階段尚未發現的錯誤。 適應性維護：指使應用軟體適應資訊技術變化和管理需求變化而進行的修改。 完善性維護：是為擴充功能和改善效能而進行的修改，主要是指對已有的軟體系統增加一些在系統分析和設計階段中沒有規定的功能與效能特徵。 預防性維護：為了改進應用軟體的可靠性和可維護性，為了適應未來的軟硬體環境變化，應主動增加預防性的新功能，以使應用系統適應各類變化而不被淘汰。 資料維護 資料維護工作主要是由資料庫管理員（DBA）來負責，主要負責資料庫的安全性和完整性以及進行並行控制。\n軟體的品質屬性 可靠性、可用性和可維護性是軟體的品質屬性，軟體工程中，用 0-1 之間的數來度量。\n可靠性是指一個系統對於給定的時間間隔內、在給定條件下無失效運作的機率。可以用 MTTF/(1+MTTF) 來度量，其中 MTTF 為平均故障前時間（Mean Time To Failure）。\n可用性是在給定的時間點上，一個系統能夠按照規格說明正確運作的機率。可以用 MTBF/(1+MTBF) 來度量，其中 MTBF 為平均失效間隔時間（Mean Time Between Failures）。\n可維護性是在給定的使用條件下，在規定的時間間隔內，使用規定的過程和資源完成維護活動的機率。可以用 1/(1+MTTR) 來度量，其中 MTTR 為平均修復時間（Mean Time To Repair）。\n","date":"2023-03-31T07:57:00+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/99/","title":"軟體工程 - 系統維護概述"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 軟體工程系列文章三\n系統測試的意義、目的及原則 系統測試是為了發現錯誤而執行程式的過程，成功的測試是發現了至今尚未發現的錯誤的測試。\n測試的目的就是希望能以最少的人力和時間發現潛在的各種錯誤和缺陷。用戶應根據開發各階段的需求、設計等文件或程式的內部結構精心設計測試案例（Test Case），並利用這些實例來執行程式，以便發現錯誤的過程。\n資訊系統測試應包括軟體測試、硬體測試和網路測試。硬體測試、網路測試可以根據具體的效能指標進行，此處所說的測試更多的是指軟體測試。\n系統測試是保證系統品質和可靠性的關鍵步驟，是對系統開發過程中的系統分析、系統設計和實作的最後複查。根據測試的概念和目的，在進行資訊系統測試時應遵循以下基本原則：\n應儘早並不斷地進行測試。測試不是在應用系統開發完之後才進行的。由於原始問題的複雜性、開發各階段的多樣性以及參加人員之間的協調等因素，使得在開發的各個階段都有可能出現錯誤。因此，測試應貫穿在開發的各個階段，應儘早糾正錯誤，消除隱患。 測試工作應該避免由原開發軟體的人或小組承擔。一方面，開發人員往往不願否定自己的工作，總認為自己開發的軟體沒有錯誤；另一方面，開發人員的錯誤很難由本人測試出來，很容易根據自己撰寫程式的思路來制定測試思路，具有侷限性。測試工作應由專門人員來進行，這樣會更客觀、更有效。 在設計測試方案時，不僅要確定輸入資料，而且要根據系統功能確定預期輸出結果。將實際輸出結果與預期結果相比較就能發現測試對象是否正確。 在設計測試案例時，不僅要設計有效、合理的輸入條件，也要包含不合理、失效的輸入條件。在測試的時候，人們往往習慣按照合理的、正確的情況進行測試，而忽略了對異常、不合理、意想不到的情況進行測試，而這可能就是隱患。 在測試程式時，不僅要檢驗程式是否做了該做的事，還要檢驗程式是否做了不該做的事。多餘的工作會帶來副作用，影響程式的效率，有時會帶來潛在的危害或錯誤。 嚴格按照測試計畫來進行，避免測試的隨意性。測試計畫應包括測試內容、進度安排、人員安排、測試環境、測試工具和測試資料等。嚴格地按照測試計畫可以保證進度，使各方面都得以協調進行。 妥善保存測試計畫、測試案例，作為軟體文件的組成部分，為維護提供方便。 測試例子都是精心設計出來的，可以為重新測試或追加測試提供方便。當糾正錯誤、系統功能擴充後，都需要重新開始測試，而這些工作的重複性很高，可以利用以前的測試案例或在其基礎上修改，然後進行測試。 系統測試階段的測試目標來自於需求分析階段。\n傳統軟體的測試策略 有效的軟體測試實際上分為 4 步進行，即單元測試、整合測試、確認測試和系統測試。\n(一) 單元測試 單元測試也稱為模組測試，在模組編寫完成且無編譯錯誤後就可以進行。單元測試側重於模組中的內部處理邏輯和資料結構。如果選用機器測試，一般用白箱測試法。這類測試可以對多個模組同時進行。\n(1) 單元測試的測試內容 單元測試主要檢查模組的以下 5 個特徵：\n模組介面。模組的介面保證了測試模組的資料流可以正確地流入、流出。在測試中應檢查以下要點： 測試模組的輸入參數和形式參數在個數、屬性、單位上是否一致。 呼叫其他模組時，所給出的實際參數和被呼叫模組的形式參數在個數、屬性、單位上是否一致。 呼叫標準函數時，所用的參數在屬性、數目和順序上是否正確。 全域變數在各模組中的定義和用法是否一致。 輸入是否僅改變了形式參數。 開/關的語句是否正確。 規定的 I/O 格式是否與輸入/輸出語句一致。 在使用檔案之前是否已經打開檔案，或使用檔案之後是否已經關閉檔案。 區域資料結構。在單元測試中，區域資料結構出錯是比較常見的錯誤，在測試時應重點考慮以下因素： 變數的說明是否合適。 是否使用了尚未賦值或尚未初始化的變數。 變數的初始值或預設值是否正確。 變數名稱是否有錯 (例如拼寫錯誤)。 重要的執行路徑。在單元測試中，對路徑的測試是最基本的任務。由於不能進行窮舉測試，需要精心設計測試例子來發現是否有計算、比較或控制流等方面的錯誤。 計算方面的錯誤。算術運算的優先次序不正確或理解錯誤；精度不夠；運算對象的類型彼此不相容；演算法錯誤；運算式的符號表示不正確。 比較和控制流的錯誤。本應相等的量由於精度造成不相等；不同類型進行比較；邏輯運算子不正確或優先次序錯誤；迴圈終止不正確 (如多迴圈一次或少迴圈一次)、無窮迴圈；不恰當地修改迴圈變數；當遇到分支迴圈時出口錯誤等。 出錯處理。好的設計應該能預測到出錯的條件並且有對出錯處理的路徑。雖然電腦可以顯示出錯訊息的內容，但仍需要程式設計師對出錯進行處理，保證其邏輯的正確性，以便於用戶維護。 邊界條件。邊界條件的測試是單元測試的最後工作，也是非常重要的工作。軟體容易在邊界出現錯誤。 (2) 單元測試過程 由於模組不是獨立運行的程式，各模組之間存在呼叫與被呼叫的關係。在對每個模組進行測試時，需要開發兩種模組：\n驅動模組 (Driver)。相當於一個主程式，接受測試例子的資料，將這些資料送到測試模組，輸出測試結果。 樁模組 (Stub，也稱為存根模組)。樁模組用來代替測試模組中所呼叫的子模組，其內部可進行少量的資料處理，目的是為了檢驗入口，輸出呼叫和返回的資訊。 提高模組的內聚度可以簡化單元測試。如果每個模組只完成一種功能，對於具體模組來講，所需的測試方案資料會顯著減少，而且更容易發現和預測模組中的錯誤。\n(二) 整合測試 整合測試（Integration Testing）就是把模組按系統設計說明書的要求組合起來進行測試。即使所有的模組都通過了測試，在整合之後，仍然可能出現問題。\n通常，整合測試有兩種方法：一種是非增量整合，分別測試各個模組，再把這些模組組合起來整體測試；另一種是增量整合，即以小增量的方式逐步進行構造和測試。\n下面是一些增量整合策略：\n(1) 由上而下整合測試 (Top-down Integration) 由上而下整合測試是一種構造軟體體系結構的增量方法。模型的整合順序為從主控模組 (主程式) 開始，沿著控制階層逐步向下，以深度優先或廣度優先的方式將從屬於 (或間接從屬於) 主控模組的模組整合到結構中。\n深度優先整合是首先整合位於程式結構中主控路徑上的所有構件，也可以根據特定應用系統的特徵進行選擇。\n主控模組用作測試驅動模組，用這些從屬於主控模組的所有模組代替樁模組。 依賴所選擇的整合方法 (即深度優先或廣度優先)，每次用實際模組替換一個從屬樁模組。 在整合每個模組後都進行測試。 在完成每個測試集之後，用實際模組替換另一個樁模組。 可以執行迴歸測試，以確保沒有引入新的錯誤。 回到第 2 步繼續執行此過程，直到完成了整個程式結構的構造。 不用編寫驅動模組，需要編寫樁模組。\n(2) 由下而上整合測試 (Bottom-up Integration) 由下而上整合測試就是從原子模組 (程式結構的最底層構件) 開始進行構造和測試。由於構件是由下而上整合的，在處理時所需要的從屬於給定階層的模組總是存在的，因此，沒有必要使用樁模組。由下而上整合策略可以利用以下步驟來實現：\n連接底層構件以構成完成特定子功能的簇 (Cluster)。 編寫驅動模組 (測試的控制程式) 以協調測試案例的輸入和輸出。 測試簇。 去掉驅動程式，沿著程式結構向上逐步連接簇。 不需要編寫樁模組，需要編寫驅動模組。\n(3) 迴歸測試 (Regression Testing) 每當加入一個新模組作為整合測試的一部分時，軟體發生變更，建立了新的資料流路徑，可能出現新的 I/O，以及呼叫新的控制邏輯。這些變更可能會使原來可以正常工作的功能產生問題。在整合測試策略的環境下，迴歸測試是重新執行已測試過的某些子集，以確保變更沒有傳播不期望的副作用。\n迴歸測試有助於保證變更不引入無意識行為或額外的錯誤。迴歸測試可以手工進行，方法是重新執行所有測試案例的子集，或者利用捕捉/回放工具自動執行。捕捉/回放工具使軟體工程師能夠為後續的回放與比較捕捉測試案例和測試結果。迴歸測試要執行的測試子集包含以下 3 種測試案例：\n能夠測試軟體所有功能的具有代表性的測試樣本。 額外測試，側重於可能會受變更影響的軟體功能。 側重於已發生變更的軟體構件測試。 隨著整合測試的進行，迴歸測試的數量可能變得相當龐大，因此，應將迴歸測試案例設計成只包括設計每個主要程式功能的一個或多個錯誤類別的測試。一旦發生變更，對每個軟體功能重新執行所有的測試是不切實際的，而且效率很低。\n(4) 冒煙測試 (Smoke Testing) 當開發軟體產品時，冒煙測試是一種常見的整合測試方法，是時間關鍵專案的決定性機制，它讓軟體團隊頻繁地對專案進行評估。\n測試方法 在軟體測試過程中，應該為定義軟體測試範本，即將特定的測試方法和測試案例設計放在一系列的測試步驟中。\n軟體測試方法分為靜態測試和動態測試。\n靜態測試。靜態測試是指被測試程式不在機器上運行，而是採用人工檢測和電腦輔助靜態分析的手段對程式進行檢測。 人工檢測。人工檢測不依靠電腦而是依靠人工審查程式或評審軟體，包括程式碼檢查、靜態結構分析和程式碼品質度量等。 電腦輔助靜態分析。利用靜態分析工具對被測試程式進行特性分析，從程式中提取一些資訊，以便檢查程式邏輯的各種缺陷和可疑的程式構造。 動態測試。動態測試是指通過執行程式發現錯誤。在對軟體產品進行動態測試時可以採用黑箱測試法和白箱測試法。 測試案例由測試輸入資料和與之對應的預期輸出結果組成。在設計測試案例時，應當包括合理的輸入條件和不合理的輸入條件。\n(一) 黑箱測試 (Black-box Testing) 黑箱測試也稱為功能測試，在完全不考慮軟體的內部結構和特性的情況下，測試軟體的外部特性。\n常見的黑箱測試技術有等價類別劃分、邊界值分析、錯誤推測和因果圖等。\n(1) 等價類別劃分 (Equivalence Partitioning) 等價類別劃分將程式的輸入域劃分為若干等價類別，然後從每個等價類別中選取一個代表性資料作為測試案例。每一類的代表性資料在測試中的作用等價於這一類中的其他值，這樣就可以用少量代表性的測試案例取得較好的測試效果。等價類型劃分有兩種不同的情況：有效等價類別和無效等價類別。在設計測試案例時，要同時考慮這兩種等價類別。\n(2) 邊界值分析 (Boundary Value Analysis) 輸入的邊界比中間更加容易發生錯誤，因此用邊界值分析來補充等價類別劃分的測試案例設計技術。邊界值劃分選擇等價類別邊界的測試案例，既注重於輸入條件邊界，又適用於輸出域測試案例。\n(3) 錯誤推測 (Error Guessing) 錯誤推測是基於經驗和直覺推測程式中所有可能存在的各種錯誤，從而有針對性地設計測試案例的方法。其基本思想是列舉出程式中所有可能有的錯誤和容易發生錯誤的特殊情況，根據它們選擇測試案例。\n(4) 因果圖 (Cause-Effect Graphing) 因果圖法是從自然語言描述的程式規格說明中找出因 (輸入條件) 和果 (輸出或程式狀態的改變)，通過因果圖轉換為判定表。\n(二) 白箱測試 (White-box Testing) 白箱測試也稱為結構測試，根據程式的內部結構和邏輯來設計測試案例，對程式的路徑和過程進行測試，檢查是否滿足設計的需要。\n白箱測試常用的技術是邏輯涵蓋、迴圈涵蓋和基本路徑測試。\n白箱測試的原則如下：\n程式模組中的所有獨立路徑至少執行一次。 在所有的邏輯判定中，取「真」和取「假」的兩種情況至少都能執行一次。 每個迴圈都應在邊界條件和一般條件下各執行一次。 測試程式內部資料結構的有效性等。 (1) 邏輯涵蓋 (Logic Coverage) 邏輯涵蓋考察用測試資料執行被測程式時對程式邏輯的涵蓋程度，主要的邏輯涵蓋標準有指令涵蓋、判定涵蓋、條件涵蓋、判定/條件涵蓋、條件組合涵蓋和路徑涵蓋 6 種。\n指令涵蓋 (Statement Coverage)。指令涵蓋是指選擇足夠的測試資料，使被測試程式中的每條指令至少執行一次。指令涵蓋對程式執行邏輯的涵蓋很低，因此一般認為它是很弱的邏輯涵蓋。 判定涵蓋 (Decision Coverage)。判定涵蓋是指設計足夠的測試案例，使得被測程式中的每個判定運算式至少獲得一次「真」值和「假」值，或者說是程式中的每一個取「真」分支和取「假」分支至少都通過一次，因此判定涵蓋也稱為分支涵蓋。判定涵蓋要比指令涵蓋更強一些。 條件涵蓋 (Condition Coverage)。條件涵蓋是指構造一組測試案例，使得每一判定語句中每個邏輯條件的各種可能的值至少滿足一次。 判定/條件涵蓋 (Decision/Condition Coverage)。判定/條件涵蓋是指設計足夠的測試案例，使得判定中每個條件的所有可能取值 (真/假) 至少出現一次，並使每個判定本身的判定結果 (真/假) 也至少出現一次。 條件組合涵蓋 (Condition Combination Coverage)。條件組合涵蓋是指設計足夠的測試案例，使得每個判定中條件的各種可能值的組合都至少出現一次。滿足條件組合涵蓋的測試案例是一定滿足判定涵蓋、條件涵蓋和判定/條件涵蓋的。 路徑涵蓋 (Path Coverage)。路徑涵蓋是指涵蓋被測試程式中所有可能的路徑。 (2) 迴圈涵蓋 執行足夠的測試案例，使得迴圈中的每個條件都得到驗證。\n(3) 基本路徑測試 基本路徑測試法是在程式控制流圖的基礎上通過分析控制流圖的環路複雜性，導出基本可執行路徑集合，從而設計測試案例。\n除錯 (Debugging) 除錯發生在測試之後，其任務是根據測試時所發現的錯誤找出原因和具體的位置，進行改正。\n常用的除錯方法有以下幾種：\n(1) 試探法 除錯人員分析錯誤的症狀，猜測問題所在的位置，利用在程式中設置輸出語句，分析暫存器、記憶體的內容等手段獲得錯誤的線索，一步步地試探和分析錯誤的所在。\n(2) 回溯法 除錯人員從發現錯誤症狀的位置開始，人工沿著程式的控制流程往回追蹤程式碼，直到找出錯誤根源為止。\n(3) 對分搜尋法 (Binary Search Method) 這種方法主要用來縮小錯誤的範圍，如果已經知道程式中的變數在若干位置的正確取值，可以在這些位置上給這些變數以正確值，觀察程式執行的輸出結果，如果沒有發現問題，則說明從賦予變數一個正確值開始到輸出結果之間的程式沒有錯誤，問題可能在除此之外的程式中。否則錯誤就在所考察的這部分程式中，對含有錯誤的程式段再使用這種方法，直到把故障範圍縮小到比較容易診斷為止。\n(4) 歸納法 歸納法就是從測試所暴露的問題出發，收集所有正確或不正確的資料，分析它們之間的關係，提出假想的錯誤原因，用這些資料來證明或反駁，從而查出錯誤所在。\n(5) 演繹法 演繹法根據測試結果，列出所有可能的錯誤原因；分析已有的資料，排除不可能和彼此矛盾的原因；對其餘的原因，選擇可能性最大的，利用已有的資料完善該假設，使假設更具體；用假設來解釋所有的原始測試結果，如果能解釋這一切，則假設得以證實，也就找出錯誤。\n","date":"2023-03-29T19:56:57+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/98/","title":"軟體工程-系統測試"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 軟體工程系列文章二\n軟體生命週期 可行性分析與專案開發計畫 需求分析 概要設計 詳細設計 編碼 測試 維護 軟體需求 在進行需求擷取之前，首先要明確需要擷取什麼，也就是需求包含哪些內容。軟體需求是指使用者對目標軟體系統在功能、行為、效能、設計限制等方面的期望\n功能需求。考量系統要做什麼，在何時做，在何時以及如何修改或升級。 效能需求。考量軟體開發的技術性指標。例如，儲存容量限制、執行速度、回應時間及吞吐量。 使用者或人的因素。考量使用者的類型。例如，各種使用者對使用電腦的熟練程度，需要接受的訓練，使用者理解、使用系統的難度，使用者錯誤操作系統的可能性等。 環境需求。考量未來軟體應用的環境，包括硬體和軟體。對硬體設備的需求包括機型、週邊設備、介面、地點、分佈、濕度、磁場干擾等；對軟體的需求包括作業系統、網路、資料庫等。 介面需求。考量來自其他系統的輸入，到其他系統的輸出，對資料格式的特殊規定，對資料儲存介質的規定。 文件需求。考量需要哪些文件，文件針對哪些讀者。 資料需求。考量輸入、輸出資料的格式，接收、傳送資料的頻率，資料的準確性和精度，資料流量，資料需保持的時間。 資源使用需求。考量軟體執行時所需要的資料、其他軟體、記憶體空間等資源；軟體開發、維護所需的人力、支援軟體、開發設備等。 安全保密要求。考量是否需要對存取系統或系統資訊加以控制，隔離使用者資料的方法，使用者程式如何與其他程式和作業系統隔離以及系統備份要求等。 可靠性要求。考量系統的可靠性要求，系統是否必須偵測和隔離錯誤；出錯後，重啟系統允許的時間。 軟體成本消耗與開發進度需求。考量開發是否有規定的時間表，軟/硬體投資有無限制等。 其他非功能性要求。如採用某種開發模式，確定品質控制標準、里程碑和審查、驗收標準、各種品質要求的優先順序等，以及可維護性方面的要求。 系統設計 系統設計的主要目的就是為系統指定藍圖，在各種技術和實施方法中權衡利弊，精心設計，合理地使用各種資源，最終勾勒出新系統的詳細設計方案。\n概要設計 開發人員把確定的各項功能需求轉換成所需的系統架構。\n1. 設計軟體系統整體結構 其基本任務是採用某種設計方法，將一個複雜的系統按功能劃分為模組；確定每個模組的功能；確定模組之間的呼叫關係；確定模組之間的介面，即模組之間傳遞的資訊；評估模組結構的品質。\n軟體系統整體結構的設計是概要設計關鍵的一步，直接影響到下一個階段詳細設計與編碼的工作。軟體系統的品質及一些整體特性都在軟體系統整體結構的設計中決定。\n2. 資料結構及資料庫設計 (1) 資料結構的設計 逐步細化的方法也適用於資料結構的設計。在需求分析階段，已經透過資料字典對資料的組成、操作限制和資料之間的關係等方面進行了描述，確定了資料的結構特性，在概要設計階段要加以細化，詳細設計階段則規定具體的實現細節。在概要設計階段，宜使用抽象的資料類型。\n(2) 資料庫的設計 資料庫的設計是指資料儲存文件的設計，主要進行以下幾方面設計：\n概念設計。在資料分析的基礎上，採用由下而上的方法從使用者角度進行視圖設計，一般用 E-R 模型來表述資料模型。E-R 模型既是設計資料庫的基礎，也是設計資料結構的基礎。 邏輯設計。E-R 模型是獨立於資料庫管理系統 (DBMS) 的，要結合具體的 DBMS 特徵來建立資料庫的邏輯結構。 實體設計。對於不同的 DBMS，實體環境不同，提供的儲存結構與存取方法各不相同。實體設計就是設計資料模式的一些實體細節，如資料項儲存要求、存取方法和索引的建立等。 3. 編寫概要設計文件 文件主要有概要設計說明書、資料庫設計說明書、使用者手冊以及修訂測試計畫。\n4. 審查 對設計部分是否完整地實現了需求中規定的功能、效能等要求，設計方法的可行性，關鍵的處理及內外部介面定義的正確性、有效性、各部分之間的一致性等都一一進行審查。\n詳細設計 對每個模組進行詳細的演算法設計，用某種圖形、表格和語言等工具將每個模組處理過程的詳細演算法描述出來。 對模組內的資料結構進行設計。 對資料庫進行實體設計，即確定資料庫的實體結構。 其他設計。根據軟體系統的類型，還可能要進行以下設計： 程式碼設計。為了提高資料的輸入、分類、儲存和檢索等操作，節省記憶體空間，對資料庫中某些資料項的值要進行程式碼設計。 輸入/輸出格式設計。 使用者介面設計。 編寫詳細設計說明書。 審查。對處理過程的演算法和資料庫的實體結構都要審查。 系統設計的結果是一系列的系統設計文件，這些文件是實體實現一個資訊系統 (包括硬體設備和編寫軟體程式) 的重要基礎。\n","date":"2023-03-29T17:04:45+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/97/","title":"軟體工程-需求分析與系統設計"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 軟體工程系列文章一\n軟體程序 軟體開發中所遵循的路線圖稱為「軟體程序」\n能力成熟度模型 (CMM) CMM 將軟體程序改進分為以下 5 個成熟度等級\n初始級 (Initial) ​\t軟體的特點是雜亂無章，有時甚至很混亂，幾乎沒有明確定義的步驟，專案的完成完全依賴個人的努力和英雄式核心人物的作用\n可重複級 (Repeatable) ​\t建立了基本的專案管理程序和實踐來追蹤專案的費用、進度與功能特性，有必要的程序準則來重複以前在同類專案中的成功\n已定義級 (Defined) ​\t管理和工程兩方面的軟體程序已經文件化、標準化，並整合為整個軟體開發組織的標準軟體程序。所有專案都採用根據實際情況修改後得到的標準軟體程序來開發和維護軟體\n已管理級 (Managed) ​\t制定了軟體程序和產品品質的詳細衡量標準。軟體程序的產品品質都被開發組織的成員所理解和控制\n優化級 (Optimized) ​\t加強了定量分析，透過來自程序品質回饋和來自新觀念、新技術的回饋使程序能不斷持續地改進\nCMM 模型提供了一個框架，將軟體程序改進的演進步驟組織成 5 個成熟度等級，為程序不斷改進奠定了循序漸進的基礎。這 5 個成熟度等級定義了一個有序的尺度，用來衡量一個組織的軟體程序成熟度與評估其軟體程序能力\n能力成熟度模型整合 (CMMI) CMM 的成功導致了適用不同學科領域的模型衍生，但一個工程常常涉及多個交叉學科，因此有必要將各種程序改進的工作整合起來。CMMI 是若干程序模型的綜合與改進\nCMMI 提供了兩種表示方法：階段式模型與連續式模型\n1. 階段式模型 階段式模型的結構類似於 CMM，它關注組織的成熟度。CMMI-SE/SW/IPPD 1.1 版中有 5 個成熟度等級\n初始的：程序不可預測且缺乏控制 已管理的：程序為專案服務 已定義的：程序為組織服務 定量管理的：程序已衡量與控制 最佳化的：集中於程序改進 2. 連續式模型 連續式模型關注每個程序領域的能力，一個組織對不同的程序可以達到不同的程序領域能力等級 (Capability Level, CL)。CMMI 中包括 6 個程序領域能力等級，等級號為 0~5。能力等級包括共性目標及相關的共性實踐，這些實踐在程序領域內被新增到特定目標和實踐中。當組織滿足程序領域的特定目標和共性目標時，就說該組織達到了那個程序領域的能力等級\nCL0 (未完成的) ：程序領域未執行或未達到 CL1 中定義的所有目標 CL1 (已執行的) ：其共性目標是程序將可識別的輸入工作產品轉換成可識別的輸出工作產品，以實現支援程序領域的特定目標 CL2 (已管理的) ：其共性目標集中於已管理的程序的制度化。根據組織級政策規定程序的運作將使用哪個程序，專案遵循已文件化的計畫和程序描述，所有正在工作的人都有權使用足夠的資源，所有工作任務和工作產品都被監控、控制和審查 CL3 (已定義級的) ：其共性目標集中於已定義的程序的制度化。程序是按照組織的客製化指南從組織的標準程序集中客製化得到的，還必須收集程序資產和程序的衡量，並用於將來對程序的改進 CL4 (定量管理的) ：其共性目標集中於可定量管理的程序的制度化。使用衡量與品質保證來控制和改進程序領域，建立和使用關於品質與程序執行的定量目標作為管理準則 CL5 (最佳化的) ：使用量化 (統計學) 手段改變和最佳化程序領域，以滿足客戶要求的改變和持續改進計畫中的程序領域的功效 軟體程序模型 軟體程序模型習慣上也稱為軟體開發模型，它是軟體開發全部程序、活動與任務的結構框架。典型的軟體程序模型有瀑布模型、增量模型、演化模型 (原型模型、螺旋模型) 、噴泉模型、基於元件的開發模型與形式化方法模型等\n瀑布模型 瀑布模型是將軟體生命週期中的各個活動規定為依線性順序連接的若干階段的模型，包括需求分析、設計、編碼、測試、運行與維護。它規定了由前至後、相互銜接的固定次序，如同瀑布流水逐級下落\n瀑布模型為軟體的開發與維護提供了一種有效的管理模式，根據這一模式制定開發計畫，進行成本預算，組織開發力量，以專案的階段審查與文件控制為手段有效地對整個開發程序進行指導，所以它是以文件作為驅動、適合於軟體需求很明確的軟體專案的模型\n瀑布模型假設，一個待開發的系統需求是完整的、簡潔的、一致的，而且可以先於設計和實現完成之前產生\n瀑布模型的優點是，容易理解，管理成本低；強調開發的階段性早期計畫及需求調查與產品測試 不足之處是，客戶必須能夠完整、正確與清晰地表達他們的需求；在開始的兩個或三個階段中，很難評估真正的進度狀態；當接近專案結束時，出現了大量的整合與測試工作；直到專案結束之前，都不能展示系統的能力 在瀑布模型中，需求或設計中的錯誤往往只有到了專案後期才能夠被發現，對於專案風險的控制能力較弱，因而導致專案常常延期完成，開發費用超出預算\nV 模型 瀑布模型的一個變體是 V 模型\nV 模型描述了品質保證活動與溝通、建模相關活動以及早期建構相關活動之間的關係。隨著軟體團隊工作沿著 V 模型左側步驟向下推進，基本問題需求逐步細化，形成問題及解決方案的技術描述。一旦編碼結束，團隊沿著 V 模型右側的步驟向上推進工作，其實際上是執行了一系列測試 (品質保證活動) ，這些測試驗證了團隊沿著 V 模型左側步驟向下推進過程中所生成的每個模型。V 模型提供了一種將驗證確認活動應用於早期軟體工程工作中的方法\n增量模型 增量模型融合了瀑布模型的基本成分與原型實現的迭代特徵，它假設可以將需求分段為一系列增量產品，每一增量可以分別開發。該模型採用隨著時程進展而交錯的線性序列，每一個線性序列產生軟體的一個可發布的「增量」\n當使用增量模型時，第一個增量往往是核心產品。客戶對每個增量的使用與評估都作為下一個增量發布的新特徵與功能，這個程序在每一個增量發布後不斷重複，直到產生了最終的完善產品。增量模型強調每一個增量均發布一個可操作的產品\n增量模型作為瀑布模型的一個變體，具有瀑布模型的所有優點。此外，它還有以下優點：第一個可交付版本所需要的成本與時間很少；開發由增量表示的小系統所承擔的風險不大；由於很快發布了第一個版本，因此可以減少使用者需求的變更；運行增量投資，即在專案開始時，可以僅對一個或兩個增量投資\n增量模型有以下不足之處：如果沒有對使用者的變更要求進行規劃，那麼產生的初始增量可能會造成後來增量的不穩定；如果需求不像早期思考的那樣穩定與完整，那麼一些增量就可能需要重新開發、重新發布；管理發生的成本、進度與配置的複雜性可能會超出組織的能力\n演化模型 軟體類似於其他複雜的系統，會隨著時間的推移而演化。在開發程序中，常常會面臨以下情形：商業與產品需求經常變化，直接導致最終產品難以實現；嚴格的交付時間使得開發團隊不可能圓滿地完成軟體產品，但是必須交付功能有限的版本以應對競爭或商業壓力；很好地理解了核心產品與系統需求，但是產品或系統拓展的細節問題卻沒有定義。在上述情況和類似情況下，軟體開發人員需要一種專門應對不斷演變的軟體產品的程序模型\n演化模型是迭代的程序模型，使得軟體開發人員能夠逐步開發出更完整的軟體版本。演化模型特別適用於對軟體需求缺乏準確認識的情況。典型的演化模型有原型模型與螺旋模型等\n原型模型 (Prototype Model) 並非所有的需求都可預先定義，大量的實踐表明，在開發初期很難得到一個完整的、準確的需求規格說明。這主要是由於客戶往往不能準確地表達對未來系統地全面要求，開發者對要解決的應用問題模糊不清，以至於形成的需求規格說明常常是不完整的、不準確的，有時甚至是有歧義的。此外，在整個開發程序中，使用者可能會產生新的要求，導致需求的變更。而瀑布模型難以適應這種需求的不確定性與變化，於是出現了快速原型 (Rapid Prototype) 這種新的開發方法。原型方法比較適合於使用者需求不清、需求經常變化的情況。當系統規模不是很大也不太複雜時，採用該方法比較好\n原型是預期系統的一個可執行版本，反映了系統性質的一個選定子集。一個原型不必滿足目標軟體的所有限制，其目的是能快速、低成本地建構原型。當然，能夠採用原型方法是因為開發工具的快速發展，使得能夠迅速地開發出一個讓使用者看得見、摸得著的系統框架。這樣，對於電腦不是很熟悉的使用者就可以根據這個框架提出自己的需求。開發原型系統首先確定使用者需求，開發初始原型，然後徵求使用者對初始原型的改進意見，並根據意見修改原型\n原型模型開始於溝通，其目的是定義軟體的總體目標，識別需求，然後快速制定原型開發的計畫，確定原型的目標與範圍，採用快速設計的方式對其進行建模，並建構原型。被開發的原型應交付給客戶使用，並收集客戶的回饋意見，這些回饋意見可在下一輪中對原型進行改進。在前一個原型需要改進，或者需要擴展其範圍的時候，進入下一輪原型的迭代開發\n螺旋模型 對於複雜的大型軟體，開發一個原型往往達不到要求。螺旋模型將瀑布模型與演化模型結合起來，加入了兩種模型均忽略的風險分析，彌補了這兩種模型的不足\n螺旋模型將開發程序分為幾個螺旋週期，每個螺旋週期大致與瀑布模型相符合，每個螺旋週期分為如下 4 個工作步驟\n制定計畫。確定軟體的目標，選定實施方案，明確專案開發的限制條件 風險分析。分析所選的方案，識別風險，消除風險 實施工程。實施軟體開發，驗證階段性產品 使用者評估。評估開發工作，提出修正建議，建立下一個週期的開發計畫 螺旋模型強調風險分析，使得開發人員與使用者對每個演化層出現的風險有所了解，因而做出應有的反應。因此，該模型特別適用於龐大、複雜並且具有高風險的系統\n與瀑布模型相比，螺旋模型支援使用者需求的動態變化，為使用者參與軟體開發的所有關鍵決策提供了方便，有助於提高軟體的適應能力，並且為專案管理人員及時調整管理決策提供了便利，因而降低了軟體開發的風險。在使用螺旋模型進行軟體開發時，需要開發人員具有相當豐富的風險評估經驗與專業知識。另外，過多的迭代次數會增加開發成本，延遲提交時間\n噴泉模型 噴泉模型是一種以使用者需求為動力，以物件作為驅動的模型，適合於物件導向的開發方法。它克服了瀑布模型不支援軟體重用和多項開發活動整合的局限性。噴泉模型使開發程序具有迭代性與無間隙性\n迭代意味著模型中的開發活動常常需要重複多次，在迭代程序中不斷地完善軟體系統，無間隙是指在開發活動 (如分析、設計、編碼) 之間不存在明顯地邊界，也就是說，它不像瀑布模型那樣，在需求分析活動結束後才開始設計活動，在設計活動結束後才開始編碼活動，而是允許各開發活動交叉、迭代地進行\n噴泉模型的各個階段沒有明顯的界限，開發人員可以同步進行。其優點是可以提高軟體專案的開發效率，節省開發時間。由於噴泉模型在各個開發階段是重疊的，在開發程序中需要大量的開發人員，不利於專案的管理。此外，這種模型要求嚴格管理文件，使得審核的難度加大\n統一程序 (UP) 模型 統一程序模型是一種「用例和風險驅動，以架構為中心，迭代並且增量」的開發程序，由 UML 方法與工具支援。迭代的意思是將整個軟體開發專案劃分為許多個小的「袖珍專案」，每個「袖珍專案」都包含正常軟體專案的所有元素：計畫、分析與設計、建構、整合與測試，以及內部與外部發布\n統一程序定義了 4 個技術階段及其產物\n起始階段 (Inception Phase)\n初始階段專注於專案的初創活動，產生的主要工作產品有構想文件 (Vision Document) 、初始用例模型、初始專案術語表、初始業務用例、初始風險評估、專案計畫 (階段及迭代) 、業務模型以及一個或多個原型 (需要時)\n精化階段 (Elaboration Phase)\n精化階段在理解了最初的領域範圍之後進行需求分析與架構演進，產生的主要工作產品有用例模型、補充需求、分析模型、軟體架構描述等\n建構階段 (Construction Phase)\n建構階段關注系統的建構，產生實現模型，產生的主要工作產品有設計模型、軟體元件、整合的軟體增量、測試計畫及步驟、測試用例以及支援文件\n移交階段 (Transition Phase)\n移交階段關注於軟體提交方面的工作，產生軟體增量，產生的主要工作產品有提交的軟體增量、β 測試報告與綜合使用者回饋\n每次迭代產生包括最終系統的部分完成的版本與任何相關的專案文件的基準，透過逐步迭代基準之間相互建構，直到完成最終系統。在每個迭代中有 5 個核心工作流程：\n捕捉系統應該做什麼的需求工作流程 精化與結構化需求的分析工作流程 在系統架構內實現需求D的設計工作流程 建構軟體的實現工作流程 驗證實現是否如期望那樣運作的測試工作流程 隨著 UP 的階段進展，每個核心工作流程的工作量發生了變化。4 個技術階段由主要里程碑所終止\n初始階段：生命週期目標 精化階段：生命週期架構 建構階段：初始運作功能 移交階段：產品發布 統一程序的典型代表是 RUP (Rational Unified Process)。RUP 是 UP 的商業擴展，完全相容 UP，但比 UP 更完整、更詳細\n敏捷方法 敏捷開發的總體目標是透過「盡可能早地、持續對有價值的軟體的交付」使客戶滿意。透過在軟體開發程序中加入靈活性，敏捷方法 (Agile Development) 使用者能夠在開發週期的後期新增或改變需求\n敏捷程序的典型方法有很多，每一種方法基於一套原則，這些原則實現了敏捷方法所宣稱的理念 (敏捷宣言)\n1. 極限編程 (XP) XP 是一種輕量級 (敏捷) 、高效、低成本、彈性、可預測的、科學的軟體開發方式。它由價值觀、原則、實踐與行為 4 個部分組成，彼此相互依賴、關聯，並透過行為貫穿於整個生命週期\n4 大價值觀：溝通、簡單性、回饋與勇氣 5 大原則：快速回饋、簡單性假設、逐步修改、提倡修改與優質工作 12 個最佳實踐 計畫遊戲 (快速制定計畫、隨著細節的不斷變化而完善) 小型發布 (系統的設計要能夠盡可能早地交付) 隱喻 (找到合適的譬喻傳達訊息) 簡單設計 (只處理目前的需求，使設計保持簡單) 測試先行 (先寫測試程式碼，然後再編寫程式) 重構 (重新審視需求與設計，重新明確地描述它們以符合新的與現有的需求) 結對編程 集體程式碼所有制 持續整合 (可以按日甚至按小時為客戶提供可運行的版本) 每週工作 40 個小時 現場客戶 (系統最終使用者代表應該全程配合 XP 團隊) 編碼標準 2. 水晶法 (Crystal) 水晶法認為每一個不同的專案都需要一套不同的策略、約定與方法論\n認為人對軟體品質有重要的影響，因此隨著專案品質與開發人員素質的提高，專案與程序的品質也隨之提高。透過更好地交流與經常性的交付，軟體生產力得到提高\n3. 並列爭球法 (Scrum) 並列爭球法使用迭代的方法，其中，把每 30 天一次的迭代稱為一個「衝刺」，並按需求的優先級別來實現產品。多個自組織與自治的小組平行地遞增實現產品，協調是透過簡短的日常情況會議來進行，就像橄欖球中的「並列爭球」。步驟如下：\n4. 自適應軟體開發 (ASD) ASD 有 6 個基本的原則\n有一個使命作為指導 特徵被視為客戶價值的關鍵點 程序中的等待是很重要的，因此「重做」與「做」同樣關鍵 變化不被視為改正，而是被視為對軟體開發實際情況的調整 確定的交付時間迫使開發人員認真考慮每一個生產的版本的關鍵需求 風險也包含其中 5. 敏捷統一程序 (AUP) 敏捷統一程序 (Agile Unified Process, AUP) 採用「在大型上連續」以及「在小型上迭代」的原理來建構軟體系統。採用經典的 UP 階段性活動 (初始、精化、建構與轉換) ，提供了一系列活動，能夠使團隊為軟體專案構想出一個全面的程序流程。在每個活動裡，一個團隊迭代使用敏捷，並將有意義的軟體增量盡可能快地交付給最終使用者。每個 AUP 迭代執行以下活動\n建模。建立對商業與問題領域的模型表述，這些模型「夠好」即可，以便團隊繼續前進 實現。將模型翻譯為原始程式碼 測試。像 XP 一樣，團隊設計與執行一系列的測試來發現錯誤以確保原始程式碼滿足需求 部署。對軟體增量的交付以及取得最終使用者的回饋 組態與專案管理。著眼於變更管理、風險管理以及對團隊的任一產物的控制。專案管理追蹤與控制開發團隊的工作進展並協調團隊活動 環境管理。協調標準、工具以及適用於開發團隊的支援技術等程序基礎設施 ","date":"2023-03-28T15:45:47+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/96/","title":"軟體工程 - 軟體程序與軟體程序模型"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 整理一下自己學的 Git 相關內容吧\n一、安裝 在 Windows 上安裝 Git 從 Git 官網下載安裝： https://git-scm.com/download/win 安裝完成後執行一次 Git Bash\n在 Linux 上安裝 Git Debian：sudo apt-get install git\nFedora：dnf install git\nCentOS：yum install git\n其他參考： https://git-scm.com/download/linux 在 Mac OS X 上安裝 Git 一是安裝 Homebrew，然後透過 Homebrew 安裝 Git，具體方法請參考 Homebrew 的文件： http://brew.sh/ 二是直接從 AppStore 安裝 Xcode，Xcode 整合了 Git，不過預設沒有安裝，你需要執行 Xcode，選擇選單 Xcode - Preferences，在彈出式視窗中找到 Downloads，選擇 Command Line Tools，點擊 Install 就可以完成安裝了\nXcode 是 Apple 官方 IDE，功能非常強大，是開發 Mac 和 iOS App 的必選裝備，而且是免費的\n二、設定 安裝完成後需要設定自己的身分資訊\n1 2 git config --global user.name \u0026#34;Your Name\u0026#34; git config --global user.email \u0026#34;email@example.com\u0026#34; 其中 Your Name 替換為您的姓名，email@example 替換為您的信箱\n三、建立版本庫 (儲存庫) 選擇一個資料夾，然後執行指令\n1 git init 這樣該資料夾就成為可以被 Git 管理的儲存庫，請勿隨意修改 ./.git 目錄下的檔案 (通常這是隱藏檔)，該目錄內容是 Git 用來追蹤管理版本庫的\n或者也可以從 GitHub 上 Clone 儲存庫到本地\nClone 別人的儲存庫 如果不修改然後提交，使用 HTTPS 即可，例如\n1 git clone https://github.com/yexca/typecho-theme-book.git 儲存庫連結可訪問 儲存庫所在網頁 ，點擊 Code 獲得\n如果 Clone 下來後需要提交更改，需要儲存庫的擁有者將您的金鑰添加到儲存庫的 Deploy keys，此時可以使用 SSH Clone\n1 git clone git@github.com:yexca/typecho-theme-book.git 不過一般修改提交的話還是先 Fork 一份修改，然後再透過 Pull requests 提交比較好\n參考： 如何使用 GitHub 給大佬遞茶 - idealclover 如何在 GitHub 提交第一個 Pull Request Clone 自己的儲存庫 先在個人的設定處添加 SSH 公鑰： SSH and GPG keys (github.com) 然後以上兩種方法皆可\n四、檔案提交到本地儲存庫 經過一番操作後，多了幾個檔案，該提交到儲存庫了\n將檔案添加到本地儲存庫\n1 2 3 git add filename # 或者下面是提交所有修改過的檔案 git add . 添加完成後該提交了\n1 git commit -m \u0026#34;some details\u0026#34; 在 some details 處描述本次提交了什麼\n那如果有些檔案我不想提交到儲存庫呢，也就是有些檔案可能不需要 Git 進行追蹤是否被修改\n建立 .gitignore 檔案，然後把不想被 Git 管理的檔案名稱填入，一行一個即可\n1 2 3 4 5 # .gitignore 檔案 test/ # 忽略 test 資料夾 test # 忽略 test 檔案 *.py[cod] # 忽略 *.pyc *.pyo *.pyd 檔案 !app.pyc # 不忽略 app.pyc 檔案 忽略了也可以強制提交：git add -f test.pyc\n也有一些現成的檔案可以參考： https://github.com/github/gitignore 如果在使用過程中需要再次修改檔案，需要先清除快取\n1 2 3 4 5 6 # 清除快取 git rm -r --cached . # 重新遍歷檔案 git add . # 提交檔案 git commit -m \u0026#34;update .gitignore\u0026#34; 五、日誌與復原 使用 git status 可以查看儲存庫的狀態\n使用 git diff 查看上次提交修改的內容\n使用 git log 查看歷史記錄，即日誌，如果資訊太多可以加上 --pretty=oneline 參數，此時可以看到 commit ID\n在 commit ID 後如果有 HEAD -\u0026gt; master 則說明此為最新提交，也就是當前版本。Git 使用 HEAD 表示當前版本，上一個版本就是 HEAD^，上上個版本是 HEAD^^，往上 60 個版本可以寫成 HEAD~60\n退回到上一個版本 git reset --hard HEAD^\n退回到指定版本：\n1 2 3 4 git reset --hard commitID # 例如 commit ID 為 eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0，可以寫如下： git reset --hard eaadf4 # 只要寫前幾位並可以識別就行，沒必要寫全 如果您操作錯誤退回了，請不要關閉指令提示字元視窗，查看指令日誌：git reflog 找到剛才的版本號退回即可\n六、本地儲存庫連結 GitHub 本地建立了一個儲存庫，想要上傳到 GitHub 的話，可以在 GitHub 上新建一個 repo，然後將本地儲存庫連結遠端儲存庫以上傳\n1 git remote add origin git@github.com:[your repo] 如果是從遠端儲存庫 Clone 的則不需要連結\n接著是在本地做了一些修改並提交，需要推送至遠端儲存庫\n推送指令：git push origin master\n指令為推送到遠端儲存庫的 master 分支\n這裡需要注意的是使用 VS Code 建立的儲存庫預設分支為 master 而 GitHub 預設分支為 main，直接推送 git push origin main 會失敗，可以先修改本地分支名稱再推送\n1 git branch -m master main 不過也可以修改預設建立的分支名稱為 main\n1 git config --global init.defaultBranch main 另外，可以設定預設推送儲存庫為 origin 的 main 分支\n1 git push --set-upstream origin main 這樣之後推送的時候直接使用\n1 git push origin 即可\n如果連結儲存庫時輸入錯了\n首先查看遠端儲存庫資訊：git remote -v\n然後刪除：git remote rm RepoName\n一般遠端儲存庫名稱為 origin，所以刪除指令為 git remote rm origin\n七、分支管理 Git 分支是 Git 中用來獨立開發不同功能、修復問題或實驗新想法的機制。透過分支，可以在不影響主分支的情況下自由地進行更改\n列出所有分支：git branch\n建立分支：git branch new_branch\n切換到分支 1：git checkout new_branch\n切換到分支 1：git switch new_branch\n推送到分支：git push origin cheny\n比如添加一個搜尋功能，首先將主分支提交完成後建立新分支\n1 git switch -c search 上述指令表示建立並切換到分支 search\n在新分支 search 修改並測試完成後提交\n1 2 git add . git commit -m \u0026#34;添加搜尋功能\u0026#34; 然後切換回主分支 main\n1 git switch main 合併分支 search\n1 git merge search (可選) 刪除 search 分支\n1 git branch -d search 八、建立伺服端 參考： 搭建 Git 伺服端及同步到指定目錄 九、其他 同時使用 GitLab 和 GitHub： document-library/Git-study.md at master · LiangJunrong/document-library (github.com) 參考文章 document-library/Git-study.md at master · LiangJunrong/document-library · GitHub Git 教程 - 廖雪峰的官方網站 (liaoxuefeng.com) 如何連接本地倉庫與 GitHub 倉庫_joy_we1 的博客-CSDN 博客 如何使用 GitHub 給大佬遞茶 - idealclover 如何在 GitHub 提交第一個 Pull Request 將本地 master 分支代碼提交到遠端 main 分支 git 修改 .gitignore 後生效 ","date":"2023-03-05T15:03:43+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/95/","title":"Git 學習"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 秉持著「不在自己硬碟裡的東西就不是自己的」的原則，以及個人手機中日益增多的圖片迫切需要整理放入硬碟中保存，以緩解手機儲存空間危機，於是決定採取按畫師分類下載儲存。因此便需要一個方便紀錄、快速查詢修改的方法，原本使用 Markdown 的清單，但隨著畫師增多，查詢免不了變得很慢。\n時隔兩天再次回想，「紀錄」這種東西，最好用的不就是資料庫嗎！\n下載與安裝 經過思考，決定使用 MySQL，下載可參考： MySQL下載與安裝 - 知乎 ，部分內容變了，但也大同小異。\n安裝我直接使用預設值，一直按下一步直到完成 (太麻煩了)。\n啟動服務，win+R 輸入 services.msc 找到服務並開啟。\n資料庫設計 說實話這也沒什麼好設計的吧，暫時主要下載 Pixiv 上的畫師，部分是 Twitter 上的，所以只用一張資料表應該就可以了。\nID name downloadDate lastDownloadID platform url 畫師唯一識別碼 姓名 下載日期 最後下載作品 ID 平台 連結 這設計是第幾正規化呢？ 程式碼如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 -- 建立資料庫 create database hello; -- 選擇資料庫 use hello; -- 建立資料表 create table pic ( ID varchar(99), name varchar(255), downloadedDate datetime, lastDownloadID varchar(255), platform varchar(50), url varchar(255), primary key(ID) ); 作品下載 Pixiv 使用 Powerful Pixiv Downloader 擴充功能， Chrome 線上應用程式商店連結 Github 連結： xuejianxianzun/PixivBatchDownloader 記得開啟慢速抓取，不然下載太快或一次下載過多會暫時被封鎖 IP。\nTwitter 使用 Twitter Media Downloader 擴充功能， Chrome 線上應用程式商店連結 官網連結： Twitter メディアダウンローダ：ユーザータイムラインの原寸画像や動画をまとめてダウンロードするユーザースクリプト(PC用Google Chrome・Firefox等対応) - 風柳メモ 資料插入 1 2 3 4 5 6 -- 選擇資料庫 use hello; -- 插入資料 insert into pic values (\u0026#39;6049901\u0026#39;, \u0026#39;鬼针草\u0026#39;, \u0026#39;2023-02-09\u0026#39;, \u0026#39;105176620\u0026#39;, \u0026#39;pixiv\u0026#39;, \u0026#39;https://www.pixiv.net/users/6049901\u0026#39;) 多列資料的話，資料直接用 , 分隔。\n資料更新 1 2 3 update pic set downloadedDate = \u0026#39;2023-03-02\u0026#39;, lastDownloadID = \u0026#39;105716156\u0026#39; where ID = \u0026#39;6049901\u0026#39; 了解更多： 資料庫學習（三）：SQL 語言 – yexca\u0026rsquo;Blog MySQL 服務不見了 這裡插入一個我遇到的問題，寫在其他文章不太合適就放在這了。\n在要打開資料庫匯入資料時，發現我的服務清單裡沒有 MySQL，解決方法：\n以管理員權限開啟 CMD，進入 MySQL/bin 目錄。\n1 2 3 4 # 註冊服務 mysqld --install # 啟動服務 net start mysql 等待一會即可使用，資料並無遺失。\n了解資料庫？ 我撰寫的： 資料庫學習（一）：資料庫導論 – yexca\u0026rsquo;Blog 菜鳥教程： SQL 教程-菜鳥教程 參考文章 MySQL常見建表選項及約束 - GeaoZhang - 博客園 ","date":"2023-03-02T10:16:38+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/94/","title":"資料庫紀錄已下載畫師作品"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 物件導向 (Object-Oriented, OO) 是一種非常實用的系統化軟體開發方法\n程序導向與物件導向 以一個問題引入：把大象裝進冰箱，需要幾步？\n一般先打開冰箱，然後把大象裝進冰箱，最後關上冰箱\n程序導向 關心我該怎麼做？一步步去實現這個功能\n對於上述問題：\n我打開冰箱 我把大象裝進冰箱裡 我關上冰箱門 物件導向 關心我該讓誰去做？去呼叫物件的操作來實現這個功能\n對於上述問題\n建立物件：大象，冰箱\n冰箱打開門 大象鑽進冰箱 冰箱關上門 物件導向基礎 物件導向 = 物件 + 分類 + 繼承 + 透過訊息的通訊\n可以說，採用這四個概念開發的軟體系統是物件導向的\n物件 客觀世界由許多具體的事物、事件、概念和規則組成，這些均可被看成物件\n在物件導向的系統中，物件是基本的執行時實體，它既包括資料 (屬性)，也包括作用於資料的操作 (行為)。一個物件通常可由物件名稱、屬性及方法 3 個部分組成\n訊息 物件之間進行通訊的一種構造叫做訊息。當一個訊息發送給某個物件時，包含要求接收物件去執行某些活動的資訊。接收到資訊的物件經過解釋，然後予以回應\n類似於方法呼叫的傳遞參數\n類別 一個類別定義了一組大體上相似的物件。一個類別所包含的方法和資料描述一組物件的共同行為與屬性。把一組物件的共同特徵加以抽象並儲存在一個類別中是物件導向技術最重要的一點。是否建立了一個豐富的類別庫，是衡量一個物件導向程式設計語言成熟與否的重要指標\n類別是在物件之上的抽象，物件是類別的具體化，是類別的實例。在分析與設計時，通常把注意力集中在類別上，而不是具體的物件。也不必逐個定義每個物件，只需對類別做出定義，而對類別的屬性進行不同賦值即可得到該類別的物件實例\n類別可以分為三種：實體類別、介面類別 (邊界類別) 和控制類別。控制類別的物件用來控制活動流，充當協調者\n有些類別之間存在一般和特殊關係，即一些類別是某個類別的特殊情況，某個類別是一些類別的一般情況。特殊類別是一般類別的子類別，一般類別是特殊類別的父類別\n通常，把一個類別和這個類別的所有物件稱為「類別及物件」或物件類別\n方法多載 方法多載 (Method Overloading) 方式\n方法名稱相同，參數個數不同 方法名稱相同，參數型別不同 方法名稱相同，參數型別順序不同 以 Java 為例，Java 的函式 (方法) 格式如下\n1 2 3 4 5 6 /* 存取修飾詞 回傳值型別 方法名(參數型別1 參數名1, 參數型別2 參數名2,···) { 方法體 } */ 以下為範例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public class Test { // 原方法 public void sum(int a, double b) { System.out.println(a + b); } // 1. 方法名稱相同，參數個數不同 public void sum(int a, double b, int c) { System.out.println(a + b + c); } // 2. 方法名稱相同，參數型別不同 public void sum(int a, int b) { System.out.println(a + b); } // 3. 方法名稱相同，參數型別順序不同 public void sum(double a, int b) { System.out.println(a + b); } } 物件導向三大特徵 物件導向的三個基本特徵是：封裝、繼承、多型\n封裝 封裝 (Encapsulation) 是一種資訊隱蔽技術，它的目的是使物件的使用者和生產者分離，使物件的定義和實現分開。從程式設計者來看，物件是一個程式模組；從使用者來看，物件為他們提供了所希望的行為\n也就是把客觀事物封裝成抽象的類別，並且類別可以把自己的資料和方法只讓可信的類別或者物件操作，對不可信的進行資訊隱藏\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public class Person{ private String name;\t// 使用 private 限制權限 private int age; public void setName(String name){ // 透過 public 方法提供修改物件屬性的途徑 this.name = name; } public String getName(){ // 透過 public 方法提供獲取物件屬性的途徑 return name; } public void setAge(int age){ if (age \u0026gt;= 0 \u0026amp;\u0026amp; age \u0026lt;= 150) this.age = age; } public int getAge(){ return age; } public void run(){ System.out.println(\u0026#34;跑路！\u0026#34;); } } 繼承 繼承 (Inheritance) 是父類別和子類別之間共享資料和方法的機制。這是類別之間的一種關係，在定義和實現一個類別的時候，可以在一個已經存在的父類別的基礎上進行，把這個已經存在的類別所定義的內容作為自己的內容，並加入若干新的內容\n一個父類別可以有多個子類別，這些子類別都是父類別的特例，父類別描述了這些子類別的公共屬性和方法。一個子類別可以繼承它的父類別 (或祖先類別) 中的屬性和方法，這些屬性和操作在子類別中不必定義，子類別中還可以定義自己的屬性和方法\n如果子類別只從一個父類別得到繼承，稱為「單一繼承」。如果一個子類別有兩個或更多個父類別，則稱為「多重繼承」\n註：Java 中一個子類別只能有一個父類別\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // 接上一段程式碼看 public class Student extends Person{ // 使用關鍵字 extends 指明要繼承的父類別 private int id; public void setId(int id){ this.id = id; } public int getId(){ return id; } public void study(){ System.out.println(getName() + \u0026#34;正在學習\u0026#34;); } // 覆寫父類別方法 public void run(){ System.out.println(getName() + \u0026#34;想跑路\u0026#34;); } } 多型 在收到訊息時，物件要予以回應。不同物件收到同一訊息可以產生完全不同的結果，這一現象稱為多型 (Polymorphism)。在使用多型的時候，使用者可以發送一個通用的訊息，而實現的細節則由接收物件自行決定。這樣，同一訊息就可以呼叫不同的方法\n多型的實現受到繼承的支持，利用類別的繼承層次關係，把具有通用功能的訊息存放在高層次，而不同的實現這一功能的行為放在較低層次，在這些低層次上生成的物件能夠給通用訊息以不同的回應\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 // 父類別 public class Person{ public void work(){ System.out.println(\u0026#34;工作\u0026#34;); } } // 子類別 1 public class Student extends Person{ // 覆寫父類別方法 public void work(){ System.out.println(\u0026#34;上學\u0026#34;); } public void run(){ System.out.println(\u0026#34;Only the young CAN RUN!\u0026#34;); } } // 子類別 2 public class Worker extends Person{ // 覆寫父類別方法 public void work(){ System.out.println(\u0026#34;上班\u0026#34;); } public void sleep(){ System.out.println(\u0026#34;睡覺\u0026#34;); } } // main public class main{ public static void main(String[] args){ // 編譯看左邊，執行看右邊 Person stu = new Student(); stu.work(); // 不可呼叫 stu.run(); 方法 Person wok = new Worker(); wok.work(); // 不可呼叫 wok.sleep(); 方法 } } // 執行輸出： // 上學 // 上班 多型 hedge 形式 多型有不同的形式，Cardelli 和 Wegner 把它分為 4 類\n參數多型 (Parametric Polymorphism)：應用比較廣泛的多型，被稱為最純的多型\n包含多型 (Inclusion Polymorphism)：在許多語言中都存在，最常見的例子就是子類型化 (Subtyping)，即一個型別是另一個型別的子型別\n過載多型 (Overloading Polymorphism)：同一個名字在不同的上下文 (Context) 中所代表的含義不同\n動態繫結和靜態繫結 繫結 (Binding) 是一個把程序呼叫和回應呼叫所執行的程式碼加以結合的過程。在一般的程式設計語言中，繫結是在編譯時進行的，叫做靜態繫結。動態繫結則是在執行時進行的。因此，一個給定的程序呼叫和程式碼的結合直到呼叫發生時才進行\n動態繫結是和類別的繼承以及多型相聯繫的。在繼承關係中，子類別是父類別的一個特例，所以父類別可以出現的地方，子類別物件也可以出現。因此在執行過程中，當一個物件發送訊息請求服務時，要根據接收物件具體情況將請求的操作與實現的方法進行連接，即動態連接\n物件導向分析 物件導向分析 (Object-Oriented Analysis, OOA) 的目的是為了獲得對應用問題的理解。理解的目的是確定系統的功能、效能要求\n物件導向分析包含 5 個活動：認定物件、組織物件、描述物件間的相互作用、確定物件的操作、定義物件的內部資訊\n物件導向設計 物件導向設計 (Object-Oriented Design, OOD) 是將 OOA 所建立的分析模型轉化為設計模型，其目標是定義系統構造藍圖。通常的情況是，由概念模型生成的分析模型被裝入到相應的執行環境中時，需要考慮實現問題加以調整和增補，如根據所用程式設計語言是否支援多重繼承或繼承，而調整類別結構。OOA 與 OOD 之間不存在鴻溝，採用一致的概念和一致的表示法，OOD 同樣應遵循抽象、資訊隱蔽、功能獨立、模組化等設計準則\n物件導向設計的活動 OOD 在複用 OOA 的模型之基礎上，包含與 OOA 對應如下五個活動\n識別類別及物件 定義屬性 定義服務 識別關係 識別套件 (Package) 物件導向設計原則 單一職責原則 (Single Responsibility Principle) ​\t就一個類別而言，應該僅有一個引起它變化的原因。即，當需要修改某個類別的時候原因有且只有一個，讓一個類別只做一種型別職責\n開放-封閉原則 (Open-Closed Principle) ​\t軟體實體 (類別、模組、函式等) 應該是可以擴展的，即開放的；但是不可修改的，即封閉的\n里氏替換原則 (Liskov Substitution Principle) ​\t子型別必須能夠替換掉他們的基 (父) 型別。即，在任何父類別可以出現的地方，都可以用子類別的實例來賦值給父型別的參照。當一個子型別的實例應該能夠替換任何其超類別的實例時，它們之間才具有是一個 (is-a) 關係\n依賴反置原則 (Dependency Inversion Principle) ​\t抽象不應該依賴於細節，細節應該依賴於抽象。即，高層不應該依賴於底層模組，二者都應該依賴於抽象\n介面隔離原則 (Interface Segregation Principle) ​\t不應該強迫客戶依賴於它們不用的方法。介面屬於客戶，不屬於它所在的類別層次結構。即：依賴於抽象，不要依賴於具體，同時在抽象級別不應該有對於細節的依賴。這樣做的的好處就在於可以最大限度地應對可能的變化\n以上為物件導向方法中的五大原則。除了這五大原則之外，Robert C. Martin 提出的物件導向設計原則還包括以下幾個\n再用發佈等價原則 (Release-Reuse Equivalency Principle) ​\t再用的顆粒就是發佈的粒度\n共同封閉原則 (Common Closure Principle) ​\t套件中的所有類別對於同一類性質的變化應該是共同封閉的。一個變化若對一個套件產生影響，則將對該套件中的所有類別產生影響，而對於其他的套件不造成任何影響\n共同再用原則 (Common Reuse Principle) ​\t一個套件中的所有類別應該是共同再用的。如果再用了套件中的一個類別，那麼就要再用套件中的所有類別\n無環依賴原則 (Acyclic Dependencies Principle) ​\t在套件的依賴關係圖中不允許存在環，即套件之間的結構必須是一個直接的無環圖形\n穩定依賴原則 (Stable Dependencies Principle) ​\t朝著穩定的方向進行依賴\n穩定抽象原則 (Stable Abstractions Principle) ​\t套件的抽象程度應該和其穩定程度一致\n物件導向測試 就測試而言，用物件導向方法開發的系統測試與其他方法開發的系統測試沒有什麼不同\n一般來說，對物件導向軟體的測試可分為下列 4 個層次進行\n演算法層 類別層 範本層 系統層 物件導向程式設計 程式設計範式 (Programming Paradigm) 是人們在程式設計時所採用的基本方式模型，決定了程式設計時採用的思維方式、使用的工具，同時又有一定的應用範疇。其發展經歷了程序程式設計、模組化程式設計、函式程式設計、邏輯程式設計，發展到現在的物件導向程式設計範式\n物件導向程式設計 (Object-Oriented Programming, OOP) 的實質是選用一種物件導向程式設計語言 (Object-Oriented Programming Language, OOPL)，採用物件、類別及其相關概念所進行的程式設計。它的關鍵在於加入了類別和繼承性，從而進一步提高了抽象程度。特定的 OOP 概念一般是透過 OOPL 中特定的語言機制來體現的\nOOP 現在已經擴展到系統分析和軟體設計的範疇，出現了物件導向分析和物件導向設計的概念，這部分在前面已經有所體現\n","date":"2023-02-25T19:34:30+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/93/","title":"物件導向基礎"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 SQL 系列\n資料庫學習一 資料庫導論: https://blog.yexca.net/zh-tw/archives/86 資料庫學習二 關聯模型: https://blog.yexca.net/zh-tw/archives/87 資料庫學習三 SQL 語言: https://blog.yexca.net/zh-tw/archives/88 資料庫學習四 關聯式資料庫理論: https://blog.yexca.net/zh-tw/archives/89 資料庫學習五 範式: https://blog.yexca.net/zh-tw/archives/90 資料庫學習六 資料庫設計: https://blog.yexca.net/zh-tw/archives/91 資料庫學習七 資料庫的控制功能: 本文\n交易管理 交易是一個操作序列，這些操作「要麼全部執行，要麼全部不執行」。\n交易和程式是兩個不同的概念，通常一個程式可包含多個交易。\n在 SQL 語言中，定義交易的敘述有以下三條：\n1 2 3 4 5 6 -- 交易開始 BEGIN TRANSACTION -- 交易提交 COMMIT -- 交易復原 ROLLBACK 交易具有 ACID 特性：原子性 (Atomicity)、一致性 (Consistency)、隔離性 (Isolation) 和持久性 (Durability)。\n1 原子性 交易是原子的，要麼全部執行，要麼全部不執行。\n2 一致性 交易執行的結果必須保證資料庫從一個一致性狀態轉換到另一個一致性狀態。\n因此，當資料庫只包含成功提交交易的結果時，稱資料庫處於一致性狀態。\n3 隔離性 交易相互隔離。\n當多個交易並行執行時，任一交易的更新操作，直到其成功提交的整個過程，對其他交易都是不可見的。\n4 持久性 一旦交易成功提交，即使資料庫崩潰，其對資料庫的更新操作也將永久有效。\n資料庫的備份與復原 在資料庫的運行過程中，難免會出現電腦系統的軟硬體故障。這些故障會影響資料庫中資料的正確性，甚至破壞資料庫，導致資料庫中的全部或部分資料遺失。因此，資料庫的關鍵技術在於建立冗餘資料，也就是備份資料。如何在系統出現故障後，能夠及時地使資料庫回復到故障前的正確狀態，就是資料庫復原技術。\n錯誤類型 資料庫中的四類錯誤：\n1 交易內部錯誤 採取 REDO 重做與 UNDO 復原技術。\n2 系統錯誤 DBMS 系統突然停止運作，系統需重新啟動。\n3 媒體錯誤 硬體損壞\n4 電腦病毒 備份方法 復原的基本原理是「建立資料冗餘」（重複儲存）。建立冗餘資料的方法是進行資料傾印（Data Dump）和登錄日誌檔。資料的傾印分為靜態傾印和動態傾印、大量傾印和增量傾印，以及日誌檔。\n1 靜態傾印和動態傾印 靜態傾印是指在傾印期間不允許對資料庫進行任何存取、修改操作。\n動態傾印是在傾印期間允許對資料庫進行存取、修改操作。\n因此，傾印和使用者交易可並行執行。\n2 大量傾印和增量傾印 大量傾印是指每次傾印全部資料。\n增量傾印是指每次只傾印上次傾印後更新過的資料。\n3 日誌檔 在交易處理的過程中，DBMS (資料庫管理系統) 會將交易開始、交易結束以及對資料庫的插入、刪除和修改的每一次操作寫入日誌檔。一旦發生錯誤，DBMS 的復原子系統會利用日誌檔撤銷交易對資料庫的改變，回復到交易的初始狀態。因此，DBMS 會利用日誌檔來進行交易錯誤復原和系統錯誤復原，並可協助備份副本進行媒體錯誤復原。\n復原 交易復原有以下三個步驟： 反向掃描日誌檔（即從最後往前掃描日誌檔），查找該交易的更新操作。 對交易的更新操作執行逆向操作。 繼續反向掃描日誌檔，查找該交易的其他更新操作，並做同樣的處理，直到交易的開始標誌。 亦即，若交易異常終止，則撤銷之前的所有操作。\n系統錯誤的復原 尚未執行完畢的交易執行 UNDO (復原)，遺失的交易執行 REDO (重做)。\n媒體錯誤的復原 重新載入資料庫，重做已經完成的交易。\n並行控制 並行操作帶來的問題 1 遺失修改 我修改的東西沒有生效。例如我把網站的 logo 改了，結果顯示的還是原本的。\n2 不可重複讀取 我在一個交易中，連續兩次讀取的資料不同。 例如我剛開始讀取到的銀行餘額為 10 元。此時公司突然發薪 100 元，那麼第二次讀取就會變成 110 元。\n3 讀取髒資料 我要讀取欄位 A、B，但讀取時其他使用者正在更新這兩個欄位。 如果他更新到一半我就讀取（更新了 A，正在更新 B），此時讀取的資料就是髒資料。\n並行控制技術 並行控制的主要技術是鎖定。基本鎖定的類型有互斥鎖（簡稱 X 鎖或寫入鎖）和共用鎖（簡稱 S 鎖或讀取鎖）。\n1 互斥鎖 若交易 T 對資料物件 A 加上 X 鎖，則只允許 T 讀取和修改 A，其他交易都不能再對 A 加任何類型的鎖，直到 T 釋放 A 上的鎖。\n2 共用鎖 若交易 T 對資料物件 A 加上 S 鎖，則只允許 T 讀取 A，但不能修改 A，其他交易只能再對 A 加 S 鎖，直到 T 釋放 A 上的 S 鎖。這就保證了其他交易可以讀取 A，但在 T 釋放 A 上的 S 鎖之前不能對 A 進行任何修改。\n鎖定協定 第一級鎖定協定（解決遺失修改） 修改時，必須加上 X 鎖，直到結束。\n第二級鎖定協定（解決讀取髒資料） 讀取時，加上 S 鎖，用完就釋放。\n第三級鎖定協定（解決不可重複讀取） 讀取時，加上 S 鎖，直到結束。\n可序列化性 假設多種情況皆可，然後獲得結果。 如果並行執行的結果與上述結果中任一個相同即可。\n交易 T1：讀取 B，A = B + 1，寫回 A。 交易 T2：讀取 A，B = A + 1，寫回 B。\n那麼結果假設先執行 T1，再執行 T2，則 A = 4，B = 3； 假設先執行 T2，再執行 T1，則 A = 3，B = 4。 這個並行執行滿足可序列化性。\n分散式資料庫 分區透明 使用者或應用程式不需要知道邏輯上存取的表格具體是如何分塊儲存的。\n複製透明 採用複製技術的分散式方法，使用者不需要知道資料是複製到哪些節點，以及如何複製的。\n位置透明 使用者無需知道資料存放的實體位置。\n邏輯透明 使用者或應用程式無需知道局部場地使用的是哪種資料模型。\n共享性 資料儲存在不同的節點，資料共享。\n自治性 每個節點都能對本地資料進行獨立管理。\n可用性 當某一場地發生錯誤時，系統可以使用其他場地上的副本，而不至於使整個系統癱瘓。\n分散性 資料在不同場地上的儲存。\n","date":"2023-02-12T08:15:00+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/92/","title":"資料庫學習七 資料庫的控制功能"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 SQL 系列\n資料庫學習一 資料庫導論: https://blog.yexca.net/zh-tw/archives/86 資料庫學習二 關聯模型: https://blog.yexca.net/zh-tw/archives/87 資料庫學習三 SQL 語言: https://blog.yexca.net/zh-tw/archives/88 資料庫學習四 關聯式資料庫理論: https://blog.yexca.net/zh-tw/archives/89 資料庫學習五 範式: https://blog.yexca.net/zh-tw/archives/90 資料庫學習六 資料庫設計: 本文\n資料庫學習七 資料庫的控制功能: https://blog.yexca.net/zh-tw/archives/92 資料庫設計的策略 自頂向下與自底向上，通常會綜合使用這兩種方法。\n資料庫設計的步驟 新奧爾良法（New Orleans Method）是目前得到公認且較完整、較權威的資料庫設計方法，它將資料庫設計分為四個主要階段：\n用戶需求分析：收集用戶需求，確定系統邊界。 概念設計：描述概念模型，較理想的是採用 E-R 方法。 邏輯設計：將 E-R 圖轉換為關聯模式，並進行正規化。 實體設計：邏輯模型在電腦中的具體實現方案。 接著進行資料庫實施階段與資料庫運行、維護階段。\n需求分析階段 需求分析是在專案確定之後，用戶和設計人員對資料庫系統所要涉及的內容（資料）和功能（行為）進行整理與描述，是以用戶的角度來認識系統。\n這一過程是後續開發的基礎，之後的邏輯設計、實體設計以及應用程式的設計都會以此為依據。\n需求分析階段的工作： 調查機構情況 → 熟悉業務活動 → 明確用戶需求 → 確定系統邊界 → 分析系統功能 → 分析系統資料 → 編寫分析報告。\n需求分析階段的文檔： 需求調查所得到的資料可能是零碎的、局部的，分析師和設計人員必須進一步分析並表達用戶需求，建立需求說明書、資料字典和資料流程圖。\nE-R 模型 E-R（實體-關係）模型是概念模型，用來描述現實世界的概念模型。\n實體 用矩形表示，矩形框內寫明實體名稱。\n關係 用菱形表示，菱形框內寫明關係名稱，並用無向邊分別與有關實體連接起來，同時在無向邊旁邊標註上關係的類型（1 : 1、1 : n、m : n）。\n\u0026lt;1\u0026gt; 兩個不同實體之間的關係\n一對一 (1 : 1)：指實體集 E1 中的一個實體最多只與實體集 E2 中的一個實體相關係。 一對多 (1 : n)：表明實體集 E1 中的一個實體可與實體集 E2 中的多個實體相關係。 多對多 (m : n)：表明實體集 E1 中的多個實體可與實體集 E2 中的多個實體相關係。 \u0026lt;2\u0026gt; 兩個以上不同實體集之間的關係\n兩個以上不同實體集之間存在 1 : 1 : 1、1 : 1 : n、1 : m : n 和 r : n : m 的關係。\n\u0026lt;3\u0026gt; 同一實體集內的二元關係\n同一實體集內的各實體之間也存在 1 : 1、1 : n 和 m : n 的關係。\n屬性 屬性是實體某方面的特性，用橢圓表示，橢圓框內寫明屬性名稱（主屬性的屬性名稱用底線標記），並用無向邊與有關實體連接起來。\n每個屬性都有其取值範圍。在同一實體集中，每個實體的屬性及其域（Domain）是相同的，但可能取不同的值。\nE-R 模型中的屬性有以下分類：\n簡單屬性和複合屬性 簡單屬性是原子的、不可再分的。複合屬性可以細分為更小的部分（即劃分為別的屬性）。\n若無特別聲明，通常指的是簡單屬性。\n單值屬性和多值屬性 單值屬性是定義的屬性對於一個特定的實體都只有單獨的一個值。\n多值屬性是定義的屬性對於一個特定的實體有多個值。\nNULL 屬性 當實體在某個屬性上沒有值或者屬性值未知時，使用 NULL 值，表示無意義或不知道。\n衍生屬性 衍生屬性可以從其他屬性計算或推導而來。\n例如員工有 入職時間 與 工作時長 屬性，則 工作時長 可以由當前時間與 入職時間 之差獲得，這裡 工作時長 就是一個衍生屬性。\n弱實體 在現實世界中有一種特殊的關係，這種關係代表實體間的所有依賴。例如，員工與眷屬的關係，眷屬總是屬於某員工的。這種實體對於另一些實體具有很強的依賴關係，即一個實體的存在必須以另一個實體為前提，將這類實體稱為弱實體。\n在 E-R 圖中，弱實體使用雙線矩形框表示。\n超類別與子類別實體 例如職員實體是飛行員、機修工和管理員實體的超類別（父類別），超類別和子類別之間具有繼承關係。\n子類別實體矩形兩邊有豎線，超類別與子類別的連線中有圓圈。\n概念結構設計階段 用 E-R 方法建立概念模型。\n對需求分析階段所得到的資料進行分類、聚集和概括，確定實體、屬性和關係。概念結構的具體工作步驟包括選擇局部應用、逐一設計分 E-R 圖和 E-R 圖合併。\n需求分析階段 → 抽象資料 → 設計局部視圖 → 合併取消衝突 → 修改重構消除冗餘 → 邏輯結構設計階段。\n選擇局部應用 選擇適當層次的資料流程圖，讓這一層的每一部分對應一個局部應用，實現某一項功能。\n逐一設計分 E-R 圖 劃分好各個局部應用之後，就要對每一個局部應用逐一設計分 E-R 圖，又稱為局部 E-R 圖。\nE-R 圖合併 根據局部應用設計好各局部 E-R 圖之後，就可以對各分 E-R 圖進行合併。合併的目的在於解決分 E-R 圖中相互間存在的衝突，最終構成一張全域 E-R 圖。\n分 E-R 圖之間的衝突主要有以下三類：\n屬性衝突 同一屬性可能會存在於不同的分 E-R 圖中，由於設計人員不同或出發點不同，對屬性的類型、取值範圍和資料單位等可能會不一致。這些屬性對應的資料將來只能以一種形式在電腦中儲存，這就需要設計階段進行統一。\n命名衝突 相同的意義在不同分 E-R 圖上有著不同的命名，或是名稱相同的屬性在不同的分 E-R 圖中代表著不同的意義，這些也要進行統一。\n結構衝突 同一實體在不同的分 E-R 圖中有不同的屬性，或是同一對象在某一分 E-R 圖中被抽象為實體，而在另一分 E-R 圖中又被抽象為屬性，需要統一。\n邏輯結構設計階段 邏輯結構設計是在概念結構設計的基礎上進行資料模型設計，可以是階層模型、網狀模型和關聯模型。本節介紹如何在全域 E-R 圖基礎上進行關聯模型的邏輯結構設計。邏輯結構設計階段的主要工作步驟包括確定資料模型、將 E-R 圖轉換成為指定的資料模型、確定完整性約束（實體完整性、參照完整性和用戶自定義完整性）和確定用戶視圖。\n概念設計階段 → 轉換為資料模型 → 關聯正規化 → 模式優化 → 設計用戶子模式 → 實體設計階段。\nE-R 圖關聯模式的轉換 E-R 方法所得到的全域概念模型是對資訊世界的描述，並不適用於電腦處理。為了適合關聯式資料庫系統的處理，必須將 E-R 圖轉換成關聯模式。E-R 圖是由實體、屬性與關係三要素構成，而關聯模式中只有唯一的結構——關聯模式，通常採用以下方法加以轉換：\n一、實體向關聯模式的轉換 將 E-R 圖中的實體逐一轉換成為一個關聯模式，實體名稱對應關聯模式的名稱，實體的屬性轉換成關聯模式的屬性，實體識別符（Identifier）就是關聯的鍵（Key）。\n二、關係向關聯模式的轉換 一對一關係的轉換 一種方式是將關係歸併到相關聯的兩個實體的任一方，在待歸併的一方實體屬性集中增加另一方實體的鍵和該關係的屬性即可，歸併後的實體，鍵保持不變。\n另一種方式（一般不用）是將關係轉換成一個獨立的關聯模式，關聯模式的名稱取關係的名稱，關聯模式的屬性包括該關係所關聯的兩個實體的鍵及關係的屬性，關聯的鍵取自任一方實體的鍵。\n一對多關係的轉換 一種方式是將關係歸併到關聯的兩個實體中的「多」方，在待歸併的多方實體屬性集中增加「一」方實體的鍵和該關係的屬性即可，歸併後的多方實體鍵保持不變。\n另一種方式（一般不用）是將關係轉換成一個獨立的關聯模式，關聯模式的名稱取關係的名稱，關聯模式的屬性取該關係所關聯的兩個實體的鍵及關係的屬性，關聯的鍵是多方實體的鍵。\n多對多關係的轉換 多對多關係只能轉換成一個獨立的關聯模式，關聯模式的名稱取關係的名稱，關聯模式的屬性取該關係所關聯的兩個多方實體的鍵及關係的屬性，關聯的鍵是由多方實體的鍵構成的屬性組。\n多對多對多關係的轉換 與第三種情況大致相同。\n超類別和子類別的轉換 超類別、子類別實體都可轉換為一個關聯，並將超類別實體的主鍵加入子類別實體中。\n關聯模式的正規化 根據語義確定各關聯模式的資料相依性。 根據資料相依性確定關聯模式的範式（正規形式）。 如果關聯模式不符合要求，要根據關聯模式的分解演算法對其進行分解，達到 3NF、BCNF 或 4NF。 關聯模式的評價及修正。 實體設計階段 邏輯設計階段 → 確定資料庫的實體模式 → 評價資料庫的實體模式 → 資料庫實施階段。\n資料庫的實施與維護 實體結構設計階段 → 定義資料庫 → 資料裝入與編寫應用程式 → 資料庫試運行 → 資料庫運行維護階段。\n","date":"2023-02-11T08:15:00+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/91/","title":"資料庫學習六 資料庫設計"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 SQL Series\n資料庫學習一 資料庫導論: https://blog.yexca.net/zh-tw/archives/86 資料庫學習二 關聯式模型: https://blog.yexca.net/zh-tw/archives/87 資料庫學習三 SQL 語言: https://blog.yexca.net/zh-tw/archives/88 資料庫學習四 關聯式資料庫理論: https://blog.yexca.net/zh-tw/archives/89 資料庫學習五 範式: 本文\n資料庫學習六 資料庫設計: https://blog.yexca.net/zh-tw/archives/91 資料庫學習七 資料庫的控制功能: https://blog.yexca.net/zh-tw/archives/92 關聯式資料庫中的關聯必須滿足一定的正規化要求，對於不同的正規化程度可以使用範式來衡量。目前主要有 6 種範式：1NF、2NF、3NF、BCNF、4NF 和 5NF\n滿足最低要求的稱為 1NF，在 1NF 基礎上進一步滿足一些要求的為 2NF，以此類推。在這些範式中，最重要的是 3NF 和 BCNF，它們是進行正規化的主要目標\n一個低階範式的關聯式模式，透過模式分解可以轉換為若干個高階範式的關聯式模式的集合，這個過程稱為正規化\n第一正規化範式 (1NF) 定義：假設 R 是一個關聯式模式，R 屬於第一正規化範式，若且唯若 R 中每一個屬性 A 的值域只包含原子項，即不可分割的資料項\n1NF 無法排除資料冗餘、更新 (插入、刪除) 異常和修改複雜等問題，因為其中可能存在部分函數依賴\n第二正規化範式 (2NF) 定義：假設 R 是一個關聯式模式，R 屬於第二正規化範式，若且唯若 R 是 1NF，且每個非主屬性都完全依賴於候選鍵\n屬於 2NF 的關聯式模式 R 也可能存在資料冗餘和更新異常等問題，因為其中可能存在遞移函數依賴\n第三正規化範式 (3NF) 定義：假設 R 是一個關聯式模式，R 屬於第三正規化範式，若且唯若 R 是 2NF，且每個非主屬性都非遞移依賴於候選鍵\n屬於 3NF 的關聯式模式 R 可能存在主屬性對鍵的部分依賴和遞移依賴\nBC 正規化範式 (BCNF) 定義：假設 R 是一個關聯式模式，F 是它的依賴集，R 屬於 BCNF，若且唯若 R 是 3NF，且 F 中每個依賴的決定因素必定包含 R 的某個候選鍵\n由 BCNF 的定義可以得到結論，一個滿足 BCNF 的關聯式模式有：\n所有非主屬性對每一個鍵都是完全函數依賴 所有的主屬性對每一個不包含它的鍵，也是完全函數依賴 沒有任何屬性完全函數依賴於非鍵的任何一組屬性 一個滿足 BCNF 的關聯式模式 R 已消除了插入和刪除異常\n只有兩個屬性的關聯式模式一定是 BCNF\n第四正規化範式 (4NF) 定義：假設有一個關聯式模式 R\u0026lt;U, F\u0026gt; 是 1NF，如果對於 R 的每個非平凡多值依賴 X →→ Y (Y ⊈ X)，X 都包含了 R 的一個候選鍵，則稱 R 是第四正規化範式\n多值依賴 給定的關聯式模式 R\u0026lt;U, F\u0026gt;，有 X、Y、Z 是 U 的子集，並且 Z = U - X - Y，關聯式模式 R 中的多值依賴 X →→ Y 成立，若且唯若對 R 的任一關聯 r，給定一對 (x, z) 值，有一組 Y 的值，這組值僅僅決定於 x 值而與 z 值無關\n平凡的多值依賴 若以上多值依賴的定義中有 X →→ Y 成立，而且 Z 為空集，則稱 X →→ Y 為平凡的多值依賴\n範式總結 1NF（第一正規化範式） 所有欄位值都是不可分解的原子值\n2NF（第二正規化範式） 不包含非主屬性對鍵的部分函數依賴，一個資料表只能儲存一種資料，不可以把多種資料儲存在同一張資料庫表中\n3NF（第三正規化範式） 不包含非主屬性對鍵的遞移函數依賴，確保資料表中每一欄資料都和主鍵直接相關，而不能間接相關\nBCNF（BC 正規化範式） 消除每一屬性對候選鍵的遞移依賴，BCNF 是修正的 3NF\n1NF → 2NF：消除非主屬性對鍵的部分函數依賴\n2NF → 3NF：消除非主屬性對鍵的遞移函數依賴\n3NF → BCNF：消除主屬性對鍵的部分和遞移函數依賴\nBCNF → 4NF：消除非平凡且非函數依賴的多值依賴\n候選鍵都是單個屬性至少是 2NF\n關聯式模式的分解 對於存在資料冗餘、插入異常、刪除異常問題的關聯式模式，應採取一個關聯式模式分解為多個關聯式模式的方法進行處理，相對地，原來儲存在一個二維表內的資料就要分散到多個二維表中，要使這個分解有意義，最基本的要求是後者不能遺失前者的資訊\n在分解處理中會涉及一些新問題，為使分解後的模式保持原模式所滿足的特性，其基本要求是模式分解具有無損連接性和保持函數依賴性\n無損連接 無損連接指的是對關聯式模式分解時，原關聯式模式下任一合法的關聯實例在分解之後應能透過自然連接運算恢復起來\n即分解後的關聯透過自然連接可以恢復為原關聯\n保持函數依賴 做模式分解後的 F\u0026rsquo; (各個子模式函數依賴的聯集) 是否與 F (原有的函數依賴集) 等價，F\u0026rsquo; 包含所有的 F 中的函數依賴則可以得出保持函數的依賴性 (充分條件)\n即分解後依賴不變\n參考： 模式分解保持函數依賴判斷——資料庫考試複習_guoyp2126的博客-CSDN博客 已知 R (ABCDEGH), F={A-\u0026gt;D, E-\u0026gt;D, D-\u0026gt;B, BC-\u0026gt;D,DC-\u0026gt;A}, 求保存函數依賴的 3NF 分解\n1）求出最小函數依賴集\n2）把不在 F 裡面的屬性都找出來，單獨分一類\n3）把每一個依賴左邊相同的分成一類，沒有一樣的，那麼就把 A-\u0026gt;D 改為{AD}, 如果一樣{A-\u0026gt;B,A-\u0026gt;C}那麼就改為{ABC}\n4）如果候選鍵沒出現在分離裡面，把任意一個候選鍵作為一類\n最小函數依賴集 Fmin={A-\u0026gt;D, E-\u0026gt;D, D-\u0026gt;B, BC-\u0026gt;D, DC-\u0026gt;A}\nGH 沒在 F 裡面，單獨一類{GH}\n候選鍵：CE\nAE\n{AD}{ED}{DB}{BCD}{DCA}{CE}{GH}\n","date":"2023-02-10T08:13:00+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/90/","title":"資料庫學習五 範式"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 SQL 系列\n資料庫學習（一）：資料庫導論: https://blog.yexca.net/zh-tw/archives/86 資料庫學習（二）：關聯模型: https://blog.yexca.net/zh-tw/archives/87 資料庫學習（三）：SQL 語言: https://blog.yexca.net/zh-tw/archives/88 資料庫學習（四）：關聯式資料庫理論: 本文\n資料庫學習（五）：正規化: https://blog.yexca.net/zh-tw/archives/90 資料庫學習（六）：資料庫設計: https://blog.yexca.net/zh-tw/archives/91 資料庫學習（七）：資料庫的控制功能: https://blog.yexca.net/zh-tw/archives/92 關聯模式 一個關聯模式應為一個五元組（含關聯名稱）\nR\u0026lt;U, D, dom, F\u0026gt;\nR 為關聯名稱，它是符號化的值組語義 U 為一組屬性 屬性組 U 中的屬性來自值域 D dom 為屬性列表到值域的映射 F 為屬性組 U 上的一組資料相依（函數相依） 由於第三點與第四點對模式設計影響不大，因此通常把關聯模式看作是一個三元組：R\u0026lt;U, F\u0026gt;，當且僅當 U 上的一個關聯 r 滿足 f 時，r 稱為關聯模式 R\u0026lt;U, F\u0026gt; 的一個關聯\n例如：R 為成績表，U 為 (學號，姓名，課程號，成績)，F 為 {學號 → 姓名，課程號 → 課程名，(學號，課程號) → 成績}\n函數相依 函數相依是一種最重要、最基本的資料相依\n設 R(U) 是屬性集 U 上的關聯模式，X、Y 是 U 的子集。若對於 R(U) 的任何一個可能的關聯 r，r 中不可能存在兩個值組在 X 上的屬性值相等，而在 Y 上的屬性值不等，則稱 X 函數決定 Y 或 Y 函數相依於 X。記作 X → Y\n非平凡的函數相依 如果 X → Y，但 Y ⊈ X，則稱 X → Y 是非平凡的函數相依。一般情況下，總是討論非平凡的函數相依\n平凡的函數相依 如果 X → Y，但 Y ⊆ X，則稱 X → Y 是平凡的函數相依\n完全函數相依 在 R(U) 中，如果 X → Y，並且對於 X 的任何一個真子集 X\u0026rsquo; 都有 X\u0026rsquo; 不能決定 Y，則稱 Y 對 X 完全函數相依，記作 X -F-\u0026gt; Y\n部分函數相依 如果 X → Y，但 Y 不完全函數相依於 X，則稱 Y 對 X 部分函數相依，記作 X -P-\u0026gt; Y。部分函數相依也稱為局部函數相依\n傳遞相依 在 R(U, F) 中，如果 X → Y，Y ⊈ X，Y → Z，則稱 Z 對 X 傳遞相依\n參考： Untitled Document (pop0726.github.io) 鍵 (Key) 設 K 為 R(U, F) 中屬性的組合，若 K → U，且對於 K 的任何一個真子集 K\u0026rsquo; 都有 K\u0026rsquo; 不能決定 U，則 K 為 R 的候選鍵 (Candidate Key)。若有多個候選鍵，則選一個作為主鍵 (Primary Key)。候選鍵通常也稱為候選關鍵字\n主屬性與非主屬性 包含在任意一個候選鍵中的屬性稱為主屬性，否則稱為非主屬性\n外鍵 (Foreign Key) 若 R(U) 中的屬性或屬性組 X 非 R 的鍵，但 X 是另一個關聯的鍵，則稱 X 為外鍵\n超鍵 (Super Key) 能表示出所有屬性的集合，候選鍵是最小的超鍵\n全鍵 (All-Key) 所有的屬性都是主鍵\n函數相依的公理系統 (Armstrong 公理系統) 設關聯模式 R(U, F)，其中 U 為屬性集，F 是 U 上的一組函數相依，那麼有以下推理規則：\n自反律 (Reflexivity)：若 Y ⊆ X ⊆ U，則 X → Y 為 F 所蘊涵 增廣律 (Augmentation)：若 X → Y 為 F 所蘊涵，且 Z ⊆ U，則 XZ → YZ 為 F 所蘊涵 傳遞律 (Transitivity)：若 X → Y，Y → Z 為 F 所蘊涵，則 X → Z 為 F 所蘊涵 根據上述三條推理規則又可推出下述三條推理規則：\n合併規則 (Union)：若 X → Y，X → Z，則 X → YZ 為 F 所蘊涵 偽傳遞律 (Pseudo-transitivity)：若 X → Y，WY → Z 為 F 所蘊涵，則 XW → Z 為 F 所蘊涵 分解規則 (Decomposition)：若 X → Y，Z ⊆ Y，則 X → Z 為 F 所蘊涵 屬性閉包計算 閉包計算即找出候選鍵，如何選出候選鍵？\n只出現在左邊的一定是候選鍵的一部分 只出現在右邊的一定不是候選鍵 左右都出現的不一定 左右都不出現的一定是候選鍵的一部分 再求確定的候選鍵部分的閉包，如果可以推出全部屬性，那麼當前確定的就是候選鍵；否則，需要將每一個可能的值加入當前確定的集合中繼續求閉包 例如：\nR\u0026lt;U, F\u0026gt;，U(A, B, C, D, E, G) F = {AB → C, CD → E, E → A, A → G}, 求候選鍵\n只出現在左邊：B, D 一定是候選鍵的一部分 只出現在右邊：G 一定不是候選鍵 左右都出現的：A，C，E 不一定是候選鍵 求閉包 BD → 什麼也推不出來，所以要把每一個可能的屬性加入求閉包\n(BDA)+ ：可推出 C，E，A，G，所以可以推出 ABCDEG\n(BDC)+ ：可推出 E，A，G，所以可以推出 ABCDEG\n(BDE)+ ：可推出 A，G，C，所以可以推出 ABCDEG\n所以，它的候選鍵最終是 {(BDA), (BDC), (BDE)}\n求最小函數相依集合 如何求最小相依集？\n1）將右側拆分為多個元素（例如 A-\u0026gt;BC 拆分為 A-\u0026gt;B 和 A-\u0026gt;C）\n2）去除當前元素，求其餘元素的閉包，檢查是否能推出該元素，遍歷集合中所有元素\n3）左側最小化（透過遮住左側屬性來看能否由剩下的屬性推出右側屬性）\n例如 BCD-\u0026gt;A，遮住 B 看 CD 能推出 A 嗎，遮住 C 看 BD 能推出 A 嗎，遮住 D 看 BC 能推出 A 嗎\n例：\n已知關聯 R\u0026lt;U, F\u0026gt; U{A, B, C, D, E, F, G}\nF = {BCD-\u0026gt;A, BC-\u0026gt;E, A-\u0026gt;F, F-\u0026gt;G, C-\u0026gt;D, A-\u0026gt;G} 求 F 的最小相依集\n解：\n// (1)\n(BCD)+ = BCDED\n(BC)+ = BCD\n(A)+ = AG\n(F)+ = F\n(C)+ = C\n(A)+ = AFG（刪除，因為已有 G）\n// (2)\nBCD-\u0026gt;A \u0026mdash;\u0026gt; BC-\u0026gt;A\nBC-\u0026gt;E\nA-\u0026gt;F\nF-\u0026gt;G\nC-\u0026gt;D\n","date":"2023-02-09T08:10:00+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/89/","title":"資料庫學習（四）：關聯式資料庫理論"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 SQL Series\n資料庫學習一 資料庫導論: https://blog.yexca.net/zh-tw/archives/86 資料庫學習二 關聯模型: https://blog.yexca.net/zh-tw/archives/87 資料庫學習三 SQL 語言: 本文\n資料庫學習四 關聯資料庫理論: https://blog.yexca.net/zh-tw/archives/89 資料庫學習五 範式: https://blog.yexca.net/zh-tw/archives/90 資料庫學習六 資料庫設計: https://blog.yexca.net/zh-tw/archives/91 資料庫學習七 資料庫的控制功能: https://blog.yexca.net/zh-tw/archives/92 SQL 語言的分類 DDL (Data Definition Language, 資料定義語言) 在資料庫系統中，每一個資料庫、資料庫中的資料表、檢視表和索引等都是資料庫的物件，要建立和刪除一個資料庫物件，都可以透過 SQL 語言來完成。DDL 包括 CREATE、ALTER 和 DROP 等。\nDML (Data Manipulation Language, 資料操作語言) DML 是指用來新增、修改和刪除資料庫中資料的語句，包括 INSERT、DELETE 和 UPDATE 等。\nDQL (Data Query Language, 資料查詢語言) 查詢是資料庫的基本功能，查詢操作透過 SQL 資料查詢語言來實現。例如，用 SELECT 查詢資料表中的內容。\nDCL (Data Control Language, 資料控制語言) DCL 包括資料庫物件的權限管理和交易管理等。\n(一)、DDL 資料定義語言 1. 建立資料庫 1 create database \u0026lt;資料庫名\u0026gt; 2. 建立基本資料表 1 2 3 4 5 6 7 create table \u0026lt;資料表名\u0026gt; ( \u0026lt;欄位名\u0026gt; \u0026lt;資料類型\u0026gt; [欄位級完整性條件約束], [···,] [資料表級完整性條件約束,] [···] ) \u0026lt;1\u0026gt; 資料類型 INT / INTEGER : 整數 FLOAT(n) : 浮點數，精度至少為 n 位數字 NUMERIC(p, d) / DECIMAL(p, d) / DEC(p, d) : 定點數，由 p 位數字 (不包括正負號、小數點) 組成，小數點後面有 d 位數字 CHAR(n) : 長度為 n 的定長字串 DATETIME : 日期時間型 1 2 3 4 5 6 -- 例如 create table test ( f1 char(10), f2 int ) \u0026lt;2\u0026gt; 欄位級完整性條件約束 not null: 不可為空值\nunique: 唯一\nnot null unique: 不可為空值且唯一\ndefault: 定義一個預設值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 -- 例如 create table test ( f1 int not null, -- 該欄位不可為空 f2 int unique, -- 該欄位值可以為空，但每列應不一樣 f3 int not null unique, -- 該欄位不可為空且每列不一樣 f4 char(5) default \u0026#39;nashi\u0026#39; -- 若新增列未賦值，此欄位預設賦值 \u0026#39;nashi\u0026#39; ) \u0026lt;3\u0026gt; 資料表級完整性條件約束 名稱 子句 對應關聯完整性 主鍵子句 PRIMARY KEY 實體完整性 檢查子句 CHECK 使用者自定義完整性 外鍵子句 FOREIGN KEY 參照完整性 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 -- 例如 create table student ( sid int, primary key(sid) -- not null unique ) -- 或者 create table student ( sid int primary key ) create table course ( cid int, sid int, score int, check(score \u0026gt;= 0 and score \u0026lt;= 100), foreign key(sid) references student(sid) ) 對於完整性的檢查 斷言 (Assertion，一般不主張使用) 1 2 3 4 CREATE ASSERTION \u0026lt;斷言名\u0026gt; \u0026lt;check子句\u0026gt; -- 其中check子句與where子句的運算式類似 -- 刪除斷言名稱 DROP ASSERTION \u0026lt;斷言名\u0026gt;; 觸發器 (Trigger) 當對一個資料表進行增、刪、改的時候，對觸發器裡面的條件進行檢查，如果成立，則執行觸發器裡面的動作，否則不執行裡面的動作。\n1 2 3 4 5 6 7 8 9 10 11 12 13 CREATE TRIGGER \u0026lt;觸發器名\u0026gt; -- 每當觸發事件發生時，該觸發器被啟動 {BEFORE|AFTER} \u0026lt;觸發事件\u0026gt; ON \u0026lt;資料表名\u0026gt; -- 指明觸發器啟動的時間是在執行觸發事件前或後 REFERERCING NEW|OLD ROW AS \u0026lt;變數\u0026gt; -- REFERENCING指出參照的變數 FOR EACH{ROW|STATEMENT} -- 定義觸發器的類型，指明動作主體執行的頻率 [WHEN \u0026lt;觸發事件\u0026gt;] \u0026lt;觸發動作主體\u0026gt; -- 僅當觸發條件為真時才執行觸發動作主體 -- 刪除觸發器 DROP TRIGGER \u0026lt;觸發器名\u0026gt; ON \u0026lt;資料表名\u0026gt; 3. 修改基本資料表結構 增加一個新欄位 1 2 3 4 alter table \u0026lt;資料表名\u0026gt; add \u0026lt;欄位名\u0026gt; \u0026lt;類型\u0026gt; -- 例如 alter table test add f3 datetime 修改一個欄位 1 2 3 4 5 6 7 alter table \u0026lt;資料表名\u0026gt; alter column \u0026lt;欄位名\u0026gt; \u0026lt;新類型\u0026gt; -- MySQL -- alter table \u0026lt;資料表名\u0026gt; modify \u0026lt;欄位名\u0026gt; \u0026lt;新類型\u0026gt; -- 例如 alter table test alter column f3 float -- alter table test modify f3 float 刪除一個欄位 1 2 3 4 5 6 7 alter table \u0026lt;資料表名\u0026gt; drop column \u0026lt;欄位名\u0026gt; -- MySQL -- alter table \u0026lt;資料表名\u0026gt; drop \u0026lt;欄位名\u0026gt; -- 例如 alter table test drop column f3 -- alter table test drop f3 4. 刪除基本資料表 1 2 3 4 drop table \u0026lt;資料表名\u0026gt; -- 例如 drop table test (二)、DML 資料操作語言 以下內容的範例基於這幾張資料表：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 -- 註：為方便理解使用中文，在實際開發中，請儘量不要使用中文 -- 學生表 create table student ( 學號 char(5) not null unique, 姓名 char(8), 性別 char(2), 出生日期 datetime, 班號 char(5) ) -- 成績表 create table score ( 學號 char(5), 課程號 char(5), 分數 int ) -- 教師表 create table teacher ( 教師編號 char(5) not null unique, 姓名 char(8), 性別 char(2), 出生日期 datetime, 職稱 char(6), 系別 char(10) ) -- 課程表 create table course ( 課程號 char(5) not null unique, 課程名 char(20), 任課教師編號 char(5) ) 1. INSERT 插入語句 向 SQL 的基本資料表中插入資料有兩種方式：直接插入值組 (Tuple) 或插入一個查詢的結果值。\n直接插入值組 1 2 3 4 5 6 7 8 9 10 11 12 13 insert into 表名[(欄位序列)] values (值組)[, ···] -- 或者 insert into 表名[(欄位序列)] (table (值組)[, (值組), ···]) -- 例如 insert into student values (\u0026#39;108\u0026#39;, \u0026#39;張三\u0026#39;, \u0026#39;男\u0026#39;, \u0026#39;2000-01-01\u0026#39;, \u0026#39;09033\u0026#39;), (\u0026#39;109\u0026#39;, \u0026#39;李四\u0026#39;, \u0026#39;男\u0026#39;, \u0026#39;2000-05-05\u0026#39;, \u0026#39;09034\u0026#39;) -- 插入指定欄位 insert into student(學號，姓名，性別，出生日期) values (110, \u0026#39;王五\u0026#39;, \u0026#39;男\u0026#39;, \u0026#39;2000-04-18\u0026#39;) 插入一個查詢的結果值 1 2 3 4 5 insert into 表名[(欄位序列)] select \u0026lt;查詢語句\u0026gt; -- 例如 insert into student select 111, \u0026#39;趙六\u0026#39;, \u0026#39;男\u0026#39;, \u0026#39;2000-03-19\u0026#39;, \u0026#39;09035\u0026#39; 2. DELETE 刪除語句 1 2 3 4 5 6 7 delete from \u0026lt;資料表名\u0026gt; [where \u0026lt;條件運算式\u0026gt;] -- 例如 delete from student -- 刪除整個資料表的所有內容 -- 刪除學號為 111 的資料列 delete from student where 學號 = 111 3. UPDATE 修改語句 1 2 3 4 5 6 7 8 9 10 11 12 update \u0026lt;資料表名\u0026gt; set \u0026lt;欄位名\u0026gt; = \u0026lt;值運算式\u0026gt;[, ···] [where \u0026lt;條件運算式\u0026gt;] -- 例如 update student set 班號 = \u0026#39;09058\u0026#39; where 學號 = 110 -- 或者 update student set 班號 = \u0026#39;09057\u0026#39;, 性別 = \u0026#39;女\u0026#39; where 學號 = 110 and 班號 = \u0026#39;09058\u0026#39; (三)、DQL 資料查詢語言 SQL 資料查詢功能是透過 SELECT 語句實現，完整語法如下：\n1 2 3 4 5 6 select \u0026lt;目標表的欄位名或列表達式序列\u0026gt; from \u0026lt;關聯表序列\u0026gt; [where \u0026lt;列條件運算式\u0026gt;] [group by \u0026lt;欄位序列\u0026gt;] [having \u0026lt;群組條件運算式\u0026gt;] [order by \u0026lt;欄位名\u0026gt; [asc|desc]] 1. 投影查詢 使用 SELECT 命令可以選擇查詢資料表中的任意欄位，當為多個欄位時，中間使用逗號 , 分隔。當 FROM 子句中的關聯表不止一個時，每個資料表的名稱都要寫出。\n1 2 3 4 5 6 7 8 9 -- 例如 select 1 + 1 select 學號 * 100 from student -- 查詢學生學號與分數 select student.學號, score.分數 from student, score -- 查詢所有欄位 select * from student 使用 DISTINCT 可以去除重複列。\n1 2 3 -- 去除重複列，查詢被選修的課程 select distinct 課程號 from score 使用 AS 可為查詢結果自定義欄位名稱。\n1 2 3 -- 例如 select 學號 as \u0026#39;sno\u0026#39; from student 2. 選擇查詢 選擇查詢就是指定查詢條件，只從來源表提取或顯示滿足該查詢條件的記錄。\n選擇查詢通常使用下列幾類運算子：\n運算子 代碼 描述 集合成員運算子 IN\nNOT IN 在集合中\n不在集合中 字串比對運算子 LIKE 與 _ 和 % 進行單個或多個字元比對 空值比較運算子 IS NULL\nIS NOT NULL 為空值\n不為空值 算術運算子 \u0026gt;\n\u0026gt;=\n\u0026laquo;br /\u0026gt;\u0026lt;=\n=\n\u0026lt;\u0026gt; 大於\n大於等於\n小於\n小於等於\n等於\n不等於 邏輯運算子 AND\nOR\nNOT 與 (And)\n或 (Or)\n非 (Not) \u0026lt;1\u0026gt; 條件運算式的比較運算 1 2 3 4 5 6 --- 查詢分數在 60-80 之間的記錄 select * from score where 分數 between 60 and 80 -- 使用 between 指包含 60 與 80，即 [60, 80] -- 等價於 where 分數 \u0026gt;= 60 and 分數 \u0026lt;= 80 \u0026lt;2\u0026gt; 字串的比對運算 1 where [not] like \u0026#39;比對字串\u0026#39; [escape \u0026#39;逸出字元\u0026#39;] 其中 '比對字串' 可以是完整字串，也可以包含萬用字元 % 和 _。\n% : 代表任意長度的字元 _ : 代表任意單個字元 \u0026lt;3\u0026gt; 集合的比較運算 1 2 3 4 -- 查詢成績為 85、86 或 88 的記錄 select * from score where 分數 in (85, 86, 88) \u0026lt;4\u0026gt; 邏輯組合運算 1 2 3 4 -- 查詢 09031 班的所有女學生 select * from student where 班號 = \u0026#39;09031\u0026#39; and 性別 = \u0026#39;女\u0026#39; 3. 排序查詢 透過使用 ORDER BY 子句可以對查詢結果進行排序。\n1 2 3 4 5 6 7 8 -- 升序 asc (預設，可省略) select 學號, 姓名 from student order by 學號 -- 降序 desc select 學號, 姓名 from student order by 學號 desc 也可以指定多個欄位排序，將會先排序第一個，然後再排序第二個。\n1 2 3 4 -- 以課程號升序，分數降序檢索結果 select * from score order by 課程號 asc, 分數 desc ORDER BY 子句必須放在查詢的最後！\n4. 聚合函數 聚合函數實現資料統計等功能，用於對一組值進行計算並返回單一的值。\n通常與 group by 子句一起使用，常用的聚合函數有：\n函數名 描述 AVG 平均值 COUNT 計算指定運算式中選擇的項數\nCOUNT(*) 統計查詢輸出的列數 MIN 最小值 MAX 最大值 SUM 數值總和 STDWV 計算指定運算式中所有資料的標準差 STDEVP 總體標準差 聚合函數參數的一般格式為：\n1 [all|distinct] expr 其中 ALL 表示對所有值進行聚合函數運算，為預設值。而 DISTINCT 指定每個唯一值都被考慮。expr 為運算式。\n1 2 3 4 -- 查詢 \u0026#39;09031\u0026#39; 班學生人數 select count(*) as \u0026#39;人數\u0026#39; from student where 班號 = \u0026#39;09031\u0026#39; 5. 資料分組 因為聚合函數只會輸出一個結果，查詢某個欄位和聚合函數放在一起時會報錯。\n可以透過資料分組計算某一個類別的聚合函數結果，即聚合函數作用範圍變成了每組的所有記錄。\n如果想使用聚合函數作為篩選條件，必須放在 HAVING 子句後。\n1 2 3 4 5 6 -- 查詢最低分大於 70，最高分小於 90 的學生學號 select 學號 from score where 分數 is not null group by 學號 having min(分數) \u0026gt; 70 and max(分數) \u0026lt; 90 當 WHERE 子句、GROUP BY 子句、HAVING 子句和聚合函數同時出現在一個查詢中時，SELECT 命令的執行順序如下：\n執行 WHERE 子句，從資料表中選取列 由 GROUP BY 對選取的列進行分組 執行聚合函數 執行 HAVING 子句選取滿足條件的分組 1 2 3 4 -- 查詢每個課程的平均分 select 課程號, avg(分數) from score group by 課程號 聚合函數作為條件只能放在 HAVING 子句後，不能放在 WHERE 子句後。\n當 SELECT 子句中包含 欄位名稱 與 聚合函數 時，所有的 欄位名稱 都應該被分組。\n6. 資料表連接查詢 (Join) 在 FROM 子句中指定要連接的資料表，在 WHERE 子句中給出連接條件。\n1 2 3 select \u0026lt;欄位名1\u0026gt;[, ···] from \u0026lt;資料表1\u0026gt;[, ···] where 連接條件 對於兩個資料表的公共欄位，需要提供前綴，例如 student.學號。\n在 SQL Server 中，連接分為內連接和外連接。\n\u0026lt;1\u0026gt; 內連接 INNER JOIN Θ 連接、等值連接、自然連接。\n內連接是最基本的連接方式，使用 INNER JOIN 關鍵字，不使用該關鍵字時預設均為內連接。\n等值連接 即兩個資料表之間的連接關係為「等於」。\n1 2 3 4 5 6 7 8 9 -- 查詢所有學生的姓名、課程號和分數量 select student.姓名, score.課程號, score.分數 from student, score where student.學號 = score.學號 -- 即 select student.姓名, score.課程號, score.分數 from student inner join score on student.學號 = score.學號 為簡化輸入，可以使用資料表的別名。\n1 2 3 4 -- 上一個範例的簡化 select x.姓名, y.課程號, y.分數 from student x, score y where x.學號 = y.學號 非等值連接 即兩個資料表之間的連接關係不是「等於」。\n自連接 將同一個資料表進行連接，這種連接稱之為自連接。\n1 2 3 4 5 6 -- 查詢選修了 \u0026#39;3-105\u0026#39; 並且成績高於 \u0026#39;109\u0026#39; 號同學成績的學生記錄 select x.課程號, x.學號, x.分數 from score x, score y where x.課程號 = \u0026#39;3-105\u0026#39; and x.分數 \u0026gt; y.分數 and y.學號 = \u0026#39;109\u0026#39; and y.課程號 = \u0026#39;3-105\u0026#39; order by x.分數 desc \u0026lt;2\u0026gt; 外連接 OUTER JOIN 左外連接 : LEFT OUTER JOIN 或 LEFT JOIN\n右外連接 : RIGHT OUTER JOIN 或 RIGHT JOIN\n全外連接 : FULL OUTER JOIN 或 FULL JOIN\n1 2 3 4 5 -- 左外連接範例 -- 查詢所有課程的任課教師的姓名 select course.課程名, teacher.姓名 from course left join teacher on (course.任課教師編號 = teacher.教師編號) 7. 子查詢 \u0026lt;1\u0026gt; 一般子查詢 當一個查詢是另一個查詢的條件時，換言之，當從資料表中選取資料列的條件依賴於該表本身或其他資料表的聯合資訊時，需要使用子查詢來實現。\n子查詢最常用於 SELECT 語句中的 WHERE 子句中。\n1 2 3 4 5 6 7 8 -- 查詢與學號為 \u0026#39;105\u0026#39; 的同學同年出生的學生 select 學號, 姓名, year(出生日期) as \u0026#39;出生年份\u0026#39; from student where year(出生日期) = ( select year(出生日期) from student where 学号 = \u0026#39;105\u0026#39; ) \u0026lt;2\u0026gt; 相互關聯子查詢 (Correlated Subquery) 在一般子查詢中，每個子查詢僅執行一次，返回的值為主查詢的 WHERE 子句所用。\n當主查詢在判斷每個待選列時，必須「喚醒」子查詢，然後反饋給主查詢。即內層的條件涉及到外層屬性的子查詢稱為相互關聯子查詢。\n1 2 3 4 5 6 7 8 9 -- 查詢成績比該課程平均成績低的學生 select 學號, 課程號, 分數 from score a where 分數 \u0026lt; ( select avg(分數) from score b where a.課程號 = b.課程號 and 分數 is not null ) \u0026lt;3\u0026gt; 帶 EXISTS 測試的子查詢 EXISTS 代表存在量詞 ∃，只返回邏輯真值或邏輯假值。\n1 2 3 4 5 6 7 8 -- 查詢所有任課教師的姓名和系別 select 姓名, 系別 from teacher a where exists ( select * from course b where a.教師編號 = b.任課教師編號 ) 或者還有 NOT EXISTS ，將結果取反。\n8. 查詢結果的聯集、交集、差集運算 可以使用以下運算子將兩個 SELECT 查詢語句的結果進行相應運算：\nUNION : 聯集 (並) INSTERSECT : 交集 EXCEPT : 差集 1 2 3 4 5 6 7 8 -- 聯集的範例 -- 查詢所有教師和學生的姓名、性別和出生年份 select 姓名, 性別, year(出生日期) as \u0026#39;出生年份\u0026#39; from teacher union select 姓名, 性別, year(出生日期) as \u0026#39;出生年份\u0026#39; from student -- order by 出生年份 (四)、DCL 資料控制語言 資料控制控制的是使用者對資料的存取權限，是由 DBA (資料庫管理員) 決定的。\n資料庫的安全性 不安全的因素：\n非授權對資料庫的惡意存取和破壞。 資料庫中重要資料的洩露。 安全環境的脆弱性。 安全性控制：\n使用者身分鑑別：靜態密碼鑑別、動態密碼鑑別、生物特徵鑑別、智慧卡鑑別。 存取控制。 自主存取控制方法 (使用者可以自定義和分配其他使用者的操作權限)。 自主存取控制 DBMS (資料庫管理系統) 資料控制應具有以下功能：\n透過 GRANT 和 REVOKE 將授權通知系統，並存入資料字典。 當使用者提出請求時，根據授權情況檢查是否執行操作請求。 SQL 標準包括 DELETE 、INSERT 、SELECT 和 UPDATE 權限。SELECT 權限對應於 READ 權限，SQL 還包括了 REFERENCES 權限，用來限制使用者在建立關聯時定義外鍵的能力。\n1. 授權的語句格式 1 2 3 4 grant \u0026lt;權限\u0026gt;[, ···] on \u0026lt;物件類型\u0026gt; \u0026lt;物件名\u0026gt;[, ···] to \u0026lt;使用者\u0026gt;[, ···] [with grant option] 不同類型的操作物件有不同的權限，常見的權限如下：\n物件 物件類型 操作權限 屬性欄 TABLE SELECT、INSERT、UPDATE、DELETE、\nALL PRIVILEGES (4 種權限的總和) 檢視表 TABLE SELECT、INSERT、UPDATE、DELETE、\nALL PRIVILEGES (4 種權限的總和) 資料表 TABLE SELECT、INSERT、UPDATE、DELETE、ALTER、INDEX\nALL PRIVILEGES (6 種權限的總和) 資料庫 DATABASE CREATETAB 建立資料表的權限，可由 DBA 授予一般使用者 PUBLIC : 接受權限的使用者可以是單個或多個具體的使用者，PUBLIC 參數可將權限賦予全體使用者。 WITH GRANT OPTION : 若指定了此子句，那麼獲得權限的使用者還可以將權限賦予其他使用者。 2. 收回權限語句格式 1 2 3 revoke \u0026lt;權限\u0026gt;[, ···] on \u0026lt;物件類型\u0026gt; \u0026lt;物件名\u0026gt;[, ···] from \u0026lt;使用者\u0026gt;[, ···] 資料庫的角色 角色指的是一類人，比如 CEO、總監、一般職員，可以給一類人授權。\n角色的建立 1 create role \u0026lt;角色名\u0026gt; 角色授權 1 grant \u0026lt;權限\u0026gt; on \u0026lt;物件類型\u0026gt; \u0026lt;物件名\u0026gt; to \u0026lt;角色1\u0026gt;[, ···] 把角色授權給其他使用者或角色 1 2 grant \u0026lt;角色\u0026gt; to \u0026lt;角色\u0026gt;或\u0026lt;使用者名字\u0026gt; [with admin option] with admin option 意味著這個使用者可以把這權限授予其他角色或使用者。\n角色權限的收回 1 revoke \u0026lt;權限\u0026gt; on \u0026lt;物件名\u0026gt; from \u0026lt;角色名字\u0026gt; 檢視表 (View) 機制 檢視表是從一個或者多個基本資料表或檢視表中導出的表，是一個虛擬表。\n為不同的使用者定義不同的檢視表，把不需要的資料隱藏起來，這樣使用者就不會進行誤操作。\n檢視表的建立 1 2 3 create view \u0026lt;檢視表名(欄位列表)\u0026gt; as select \u0026lt;查詢子句\u0026gt; [with check option] 子查詢的 SELECT 語句通常不允許含有 ORDER BY 子句和 DISTINCT 語句。 WITH CHECK OPTION 表示對 UPDATE 、INSERT 、DELETE 操作時，保證被操作的列滿足檢視表定義中的謂語條件 (即子查詢中的條件運算式)。 組成檢視表的屬性欄位名稱或者全部省略，或者全部指定。如果省略，則隱含該檢視表由 SELECT 子查詢目標欄位的主屬性組成。 1 2 3 4 5 6 7 8 -- 關聯模式：student(sno, sname, sex, SD, email) -- 建立 \u0026#39;計算機系 (CS)\u0026#39; 學生的檢視表，並且進行修改操作時 -- 保證檢視表中只有計算機系的孩子會受到影響 create view cs-student as select sno, sname, sex from student where SD = \u0026#39;CS\u0026#39; with check option 檢視表的刪除 1 2 3 4 drop view \u0026lt;檢視表名\u0026gt; --例如 drop view cs-student 稽核 (Audit) 把對資料庫的所有操作都記錄到稽核記錄 (Audit Log) 中，然後就可以透過記錄審查裡面是否有一些非法的行為。\n1 2 3 4 -- 對修改“SC”資料的操作進行稽核 AUDIT UPDATE ON SC; -- 取消對“SC”表的一切稽核 NOAUDIT UPDATE ON SC; 資料加密 透過一些加密演算法，把明文變成密文，這樣別人就無法查看。\n索引 (Index) 利用索引可以使資料庫程式無需對整個資料表進行掃描，就可以在其中找到所需資料。\n資料庫中的索引是某個資料表中一欄或者若干欄位值的集合，以及相應指向資料表中實體標識這些值的資料頁的邏輯指標清單。\n由內層模式 (Internal Schema) 定義 (內層模式定義所有的內部記錄類型、索引和檔案的組織方式)。\n建立索引 1 2 create [unique] [cluster] index \u0026lt;索引名\u0026gt; on \u0026lt;資料表名\u0026gt;(欄位名[次序], ···) 次序：可選 ASC (預設) 或 DESC。\nUNIQUE ：表明此索引的每一個索引值只對應唯一的資料記錄。\nCLUSTER ：表明要建立的索引是叢集索引 (Clustered Index)，意指索引項的順序是與資料表中記錄的實體順序一致的索引組織。\n刪除索引 1 drop index \u0026lt;索引名\u0026gt; ","date":"2023-02-08T08:00:00+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/88/","title":"資料庫學習三 SQL 語言"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 SQL 系列\n資料庫學習一 資料庫導論: https://blog.yexca.net/zh-tw/archives/86 資料庫學習二 關聯式模型: 本文\n資料庫學習三 SQL 語言: https://blog.yexca.net/zh-tw/archives/88 資料庫學習四 關聯式資料庫理論: https://blog.yexca.net/zh-tw/archives/89 資料庫學習五 範式: https://blog.yexca.net/zh-tw/archives/90 資料庫學習六 資料庫設計: https://blog.yexca.net/zh-tw/archives/91 資料庫學習七 資料庫的控制功能: https://blog.yexca.net/zh-tw/archives/92 關聯式模型中的基本術語 關聯式資料庫系統是支援關聯式模型的資料庫系統。有關關聯式模型的一些基本術語如下：\n關聯 (Relation)：一個關聯就是一張二維表，每個關聯有一個關聯名稱 元組 (Tuple)：表中的一行即為一個元組，對應儲存檔案中的一個記錄值 屬性 (Attribute)：表中的列稱為屬性，每一列有一個屬性名稱，屬性值相當於記錄中的資料項或者欄位值 域 (Domain)：屬性的取值範圍，即不同元組對同一個屬性的值所限定的範圍 關聯式模式 (Relation Schema)：對關聯的描述稱為關聯式模式，由關聯名稱和其屬性集合構成，關聯式模式的格式為：關聯名(屬性名 1，···，屬性名 n) 通常一個關聯式模式對應一個關聯檔案的結果\n候選鍵 (Candidate Key)：屬性或屬性組合，其值能夠唯一地識別一個元組 主鍵 (Primary Key)：在一個關聯中可能有多個候選鍵，從中選擇一個作為主鍵 主屬性：包含在任何候選鍵中的屬性稱為主屬性，不包含在任何候選鍵中的屬性稱為非主屬性 外鍵 (Foreign Key)：如果一個關聯中的屬性或屬性組並非該關聯的鍵，但它們是另外一個關聯的鍵，則稱其為該關聯的外鍵 全鍵 (All-key)：關聯式模式的所有屬性組是這個關聯式模式的候選鍵，稱為全鍵 超鍵 (Super Key)：一個包含鍵的屬性集稱為超鍵 關聯式模型的定義 關聯的描述稱為關聯式模式，它可以形式化地表示為：R(U, D, dom, F)\n其中 R 為關聯名，U 為組成該關聯的屬性名集合，D 為屬性組 U 中屬性所來自的域，dom 為屬性向域的映射集合，F 為屬性間資料的相依關係集合\n通常簡記為 R(U) 或 R($A_1$, $A_2$, ···)，其中 R 為關聯名，U 為屬性名集合，$A_1$、··· 為各屬性名\n關聯式模型由關聯資料結構、關聯操作集合和關聯完整性限制三部分組成\n關聯資料結構 關聯式模型中資料的邏輯關係是一張二維表格\n關聯操作集合 關聯式模型給出了關聯操作的能力\n常見的關聯操作有：選擇、投影、連接、除法、聯集、交集、差集等查詢操作和增加、刪除操作等\n關聯完整性限制 關聯式模型中的三個完整性規則如下：\n實體完整性 (Entity Integrity)：關聯中主鍵的值不能為空或部分為空，也就是說，主鍵中屬性即主屬性不能取空值 參照完整性 (Referential Integrity)：如果關聯 $R_2$ 的外鍵 X 與關聯 $R_1$ 的主鍵相對應 (基本關聯 $R_1$ 和 $R_2$ 不一定是不同的關聯，即它們可以是同一個關聯)，則外鍵 X 的每一個值必須在關聯 $R_1$ 中主鍵的值中找到，或者為空值 使用者定義完整性 (User-defined Integrity)：指使用者對某一具體資料指定的約束條件進行檢驗 關聯代數運算子 運算子 符號 含義 集合運算子 ∪\n–\n∩\n× 聯集 (Union)\n差集 (Difference)\n交集 (Intersection)\n笛卡兒積 (Cartesian Product) 專門的關聯運算子 σ\nπ\n⋈\n÷ 選擇 (Selection)\n投影 (Projection)\n連接 (Join)\n除法 (Division) 比較運算子 ＞\n≥\n＜\n≤\n＝\n≠ 大於\n大於等於\n小於\n小於等於\n等於\n不等於 邏輯運算子 ¬\n∧\n∨ 非 (NOT)\n與 (AND)\n或 (OR) 傳統的集合運算 專門的關聯運算子 連接 (Join) 連接有 θ 連接、等值連接與自然連接\nθ 連接：連接條件不為等於 等值連接：連接條件為等於 自然連接：除去重複屬性的等值連接。最常用的連接運算 投影 (Projection) 投影運算是從關聯的垂直方向進行運算，在關聯 R 中選出若干屬性列 A 組成新的關聯，記作 $π_A(R)$\n選擇 (Selection) 選擇運算是從關聯的水平方向進行運算，是從關聯 R 中選擇滿足給定條件的元組，記作 $σ_F(R)$\n外連接 (Outer Join) 外連接運算是連接運算的擴展，可以處理由於連接運算而缺失的資訊\n左外連接 (Left Outer Join)：取出左側關聯中所有與右側關聯中任一元組都不匹配的元組，用空值 null 填充所有來自右側關聯的屬性 右外連接 (Right Outer Join)：取出右側關聯中所有與左側關聯中任一元組都不匹配的元組，用空值 null 填充所有來自左側關聯的屬性 全外連接 (Full Outer Join)：完成左外連接和右外連接的操作 除法 (Division) 符號轉 SQL 語言 關聯 R:\nA B C 1 2 3 4 5 6 7 8 9 投影轉 SQL 語言 $π_?(?)$\n1 select ? from ? $π_{A, B, C}(R)$ 或者 $π_{1, 2, 3}(R)$\n1 select A, B, C from R 註：SQL 語言不支援列 (屬性) 的序號\n選擇轉 SQL 語言 $π_?(σ_?(?))$\n1 select ? from ? where ? $π_{A, B, C}(σ_{B \u003e= '5'}(R))$ 或者 $π_{1, 2, 3}(σ_{2 \u003e= '5'}(R))$\n1 2 3 select A, B, C from R where B \u0026gt;= \u0026#39;5\u0026#39; # 或者 select A, B, C from R where B \u0026gt;= 5 笛卡兒積轉 SQL 語言 $π_{R.A, R.B, R.C, S.A, S.B, S.D}(R×S)$\n1 2 3 4 select R.A, R.B, R.C, S.A, S.B, S.D from R, S # 遞增排序 order by R.A asc 自然連接轉 SQL 語言 關聯 R(A, B, C) 與 S(B, C, D)\n$π_{R.A, R.B, R.C, S.D}(σ_{R.B = S.B ∩ R.C = S.C}(R×S))$\n1 2 3 select R.A, R.B, R.C, S.D from R, S where R.B = S.B and R.C = S.C ","date":"2023-02-07T06:00:00+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/87/","title":"資料庫學習二 關聯式模型"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 引言 之前資料庫筆記寫得不太好看，重新複習編寫一下 (雖然這個也挺亂的就是了)\nSQL Series\n資料庫學習（一）：資料庫導論: 本文\n資料庫學習（二）：關聯模型: https://blog.yexca.net/zh-tw/archives/87 資料庫學習（三）：SQL 語言: https://blog.yexca.net/zh-tw/archives/88 資料庫學習（四）：關聯資料庫理論: https://blog.yexca.net/zh-tw/archives/89 資料庫學習（五）：範式: https://blog.yexca.net/zh-tw/archives/90 資料庫學習（六）：資料庫設計: https://blog.yexca.net/zh-tw/archives/91 資料庫學習（七）：資料庫的控制功能: https://blog.yexca.net/zh-tw/archives/92 資料庫的四個基本概念 資料 (Data) 描述事物的符號記錄。\n資料庫 (Database) 概括地講，資料庫資料具有永久儲存、有組織和可共享的三個基本特點。\n嚴格地講，資料庫是長期儲存在電腦內、有組織的、可共享的大量資料的集合。資料庫中的資料按一定的資料模型組織、描述和儲存，具有較小的冗餘度、較高的資料獨立性和易拓展性，並可為各種使用者共享。\n資料庫管理系統 (DBMS) 是位於使用者和作業系統之間的一層資料管理軟體。和作業系統一樣是電腦的基礎軟體。\n主要功能：\n資料定義功能\n資料組織、儲存和管理\n資料操作功能\n資料庫的交易管理和執行管理\n資料庫的建立和維護功能\n其他功能（通訊功能，資料轉換功能，互訪和互操作功能等）\n資料庫系統 (DBS) 是由資料庫、資料庫管理系統（及其應用開發工具）、應用程式和資料庫管理員（DBA）組成的儲存、管理、處理和維護資料的系統。\n電腦資料管理的發展 人工管理階段 (20 世紀 50 年代中期以前) 資料不保存、不共享，不具有獨立性。\n檔案系統階段 (20 世紀 50 年代後期至 60 年代中後期) 可保存，但共享性差，冗餘度大，獨立性差。\n資料庫系統階段 (20 世紀 60 年代 後期開始) 資料庫系統的出現使資訊系統從以「加工資料的程式為中心」轉向圍繞「共享的資料庫為中心」的新階段，實現整體資料的結構化。\n資料的共享性高、冗餘度低且易擴充：資料可以大大減少資料冗餘，節約儲存空間，資料獨立性高。\n資料模型的分類 根據模型應用的不同目的，可將模型分成兩類或者兩個層次：從資訊世界中抽象出的資料模型稱為概念資料模型；從電腦世界中抽象出的 DBMS (資料庫管理系統) 支援的資料模型稱為結構資料模型 (或者邏輯模型)。\n概念資料模型 (概念模型) 概念資料模型是獨立於電腦系統的模型，完全不涉及資訊在系統中的表示，只是用來描述某個特定組織所關心的資訊結構，即按照使用者的觀點來對資料和資訊建模，用於資訊世界建模，一般採用實體-關聯方法 (E-R 方法) 表示。主要用於資料庫設計。\n概念資料模型中的幾個常用術語如下：\n實體：客觀存在並可以相互區別的事物稱為實體。\n屬性：描述實體的特性稱為屬性。\n鍵 (Key)：唯一識別實體的屬性集稱為鍵。\n實體型態：用實體名及其屬性集合來抽象和刻畫同類實體。\n實體集：同一類型實體的集合。\n值域 (Domain)：屬性的取值範圍稱為該屬性的值域。\n關聯 (Relationship)：實體之間的對應關係稱為關聯。\n兩個實體之間的關聯有三種類型：\n一對一關聯 一對多關聯 多對多關聯 實體-關聯方法表示的概念資料模型稱為 E-R 圖。實體用矩形，屬性用橢圓，並用無向邊將其與有關實體連接。\n結構資料模型 (邏輯模型) 結構資料模型是直接面向資料庫的邏輯結構，任何一個 DBMS 都以某個結構資料模型為基礎。主要用於資料庫管理系統的實現。\n結構資料模型主要包括：階層、網狀、關聯和物件導向模型。\n階層模型 (Hierarchical Model) 階層模型是用「樹狀結構」來表示資料之間的關聯，它的資料結構是一棵「有向樹」。\n網狀模型 (Network Model) 網狀模型是用「圖形結構」來表示資料之間的關聯。\n關聯模型 (Relational Model) 關聯模型是一種用二維表格結構來表示實體以及實體之間關聯的資料模型。每個二維表由列 (Row)、欄 (Column) 組成，又可稱為關聯 (Relation)，關聯綱要是對關聯的描述。因此可以說，關聯模型是由關聯綱要組成的集合。\n實體模型 (Physical Model) 是對資料最底層的抽象，它描述資料在系統內部的表示方法和存取方法，或在硬碟或磁帶上的儲存方式和存取方法，是面向電腦系統的。\n資料庫系統的結構 資料庫產品很多，儲存結構也各不相同，但體系結構基本上都具有相同的特徵，採用「三級綱要和兩級映射」。\n三級綱要 (Three-level Schema) 概念綱要 (基本表) 也稱為綱要或邏輯綱要，是資料庫中全部資料的邏輯結構和特徵的描述，是所有使用者的公共資料視圖。\n外綱要 (視圖) 也稱為使用者綱要或子綱要，是使用者與資料庫系統的介面，是使用者用到那部分資料的描述。\n內綱要 (儲存檔案) 也稱儲存綱要，一個資料庫只有一個內綱要。它是資料實體結構和儲存方式的描述，是資料在資料庫內部的組織方式。\n兩級映射 資料庫系統在三級綱要之間提供了兩級映射：綱要/內綱要映射、外綱要/綱要映射。\n正因為這兩級映射保證了資料庫中的資料具有較高的邏輯獨立性和物理獨立性。\n綱要/內綱要映射 (儲存) 存在於概念級和內部級之間，實現了概念綱要和內綱要之間的相互轉換。\n當資料庫的儲存結構改變時，由資料庫管理員對綱要 / 內綱要映射作相應改變，可以使綱要保持不變，從而應用程式也不用改變。保證了資料與程式的物理獨立性。\n外綱要/綱要映射 (視圖) 存在於外部級和概念級之間，實現了外綱要和概念綱要之間的相互轉換。\n當綱要改變時，由資料庫管理員對各個外綱要 / 綱要映射作相應改變，可以使外綱要保持不變。應用程式不必修改。保證了資料與程式的邏輯獨立性。\n資料的獨立性是指資料與程式獨立，將資料的定義從程式中分離出去。資料的獨立性是由 DBMS 的二級映射功能來保證的。資料的獨立性包括資料的物理獨立性和資料的邏輯獨立性。\n資料的物理獨立性：指使用者的應用程式與資料庫中資料的實體儲存是相互獨立的。\n資料的邏輯獨立性：指使用者的應用程式與資料庫中的邏輯結構是相互獨立的。\n資料與程式之間的獨立性使得資料的定義和描述可以從應用程式中分離出去。另外，由於資料的存取由資料庫管理系統管理，從而簡化了應用程式的編寫，大大減少了應用程式的維護和修改。\n資料庫系統的組成 硬體平台及資料庫 足夠大的記憶體、硬碟或磁碟陣列等設備，較高的通道能力以提高資料的傳送率。\n軟體 資料庫管理系統，支持資料庫管理系統運行的作業系統，具有與資料庫介面的高階語言及其編譯系統，以資料庫管理系統為核心的應用開發工具，為特定應用環境開發的資料庫應用系統。\n人員 開發、管理和使用資料庫的人員主要包括資料庫管理員、系統分析師和資料庫設計人員、應用程式設計師和最終使用者。\n資料庫管理員職責：決定資料庫中資訊內容和結構、決定資料庫的儲存結構和存取策略、定義資料的安全性要求和完整性約束條件、監控資料庫的使用和運行、資料庫的改進和重組、重構。\n","date":"2023-02-06T19:57:35+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/86/","title":"資料庫學習（一）：資料庫導論"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 第十二章 管理磁碟和檔案系統 12.1 了解磁碟儲存體 在大多數現代作業系統中，資料儲存體的基本運作原理都是相同的。磁碟用作永久儲存體，而 RAM (Random Access Memory，隨機存取記憶體) 和交換空間則用作臨時儲存體。例如，當執行一條指令時，該指令將從硬碟複製到 RAM，以便電腦處理器 (CPU) 可以更快地存取該指令。\n相對於從硬碟存取資料，CPU 可以更快地從 RAM 存取資料。但因為 RAM 造價過高，且斷電即清除資料，硬碟容量遠大於 RAM。\n當執行太多程序或執行了一個帶有記憶體洩漏的程序而將 RAM 填滿時，如果系統沒有提供一種擴展系統記憶體的方法，則會導致新程序失敗，於是便有了交換空間。採用一些演算法將一些資料從 RAM 中換到磁碟中，在需要時再換回去。\n當需要在不同類型的作業系統之間交換檔案時，通常採用 VFAT 檔案系統。\n12.2 對硬碟進行分割 變更分割區可能導致系統無法啟動，建議先拿空硬碟熟練掌握後再實際應用。\n12.2.1 理解分割區表 從傳統上來說，PC 架構的電腦使用 MBR (Master Boot Record，主引導紀錄) 分割區表來儲存關於硬碟分割區大小和佈局資訊。然而，近年來，一種被稱為 GUID (Global Unique Identifier) 分割區表的新標準在部分 UEFI 電腦架構的電腦上得到了應用，從而取代了較老的 BIOS 系統啟動方法。\nMBR 規範所固有的限制帶來了對 GUID 分割的需求。MBR 分割區的大小被限制在 2TB，而 GUID 分割區可以建立最大 9.4ZB 的分割區。\nfdisk 指令不支援 GPT 分割，可以使用 parted 指令。\n12.2.2 查看磁碟分割區 fdisk -l /dev/sda 或 parted -l /dev/sdb\n由 sd? 裝置 (如 sda、sdb 等) 所表示的 SCSI 或 USB 儲存裝置最多可以有 16 個次要裝置 (比如主 /dev/sdc 裝置以及 /dev/sdc1 到 /dev/sdc15)，所以共有 15 個分割區。\n由 nvme 裝置 (如 nvme0、nvme1 等) 所表示的 NVMe SSD 儲存裝置可以劃分一個或多個命名空間 (大多數裝置只使用第一個) 和分割區，例如 /dev/nvme0n1p1 表示第一個 NVMe 裝置上第一個命名空間的第一個分割區。\n對於 x86 電腦，磁碟最多可以有 4 個主要分割區。所以如果想要 4 個以上的分割區，至少有一個分割區是延伸分割區。四個主要分割區外的任何分割區都是邏輯分割區，使用了來自延伸分割區的空間。\n12.2.3 建立單一分割區硬碟 一般添加一個儲存媒介的過程：\n安裝新的硬碟或插入新的 USB 隨身碟。 對新硬碟進行分割。 在新硬碟上建立檔案系統。 掛載檔案系統。 如果使用 parted 指令進行修改，請謹慎執行每一步，因為 parted 指令的變更會立即生效。 而 fdisk 指令是可撤銷的，只有在確定應用變更時才會實際變更。\n資料無價，謹慎操作。\n確認新增加的裝置名稱。\n方法有許多，例如查看系統日誌：\njournalctl -f\n例如分配的名稱為 /dev/sdb。\n如果裝置自動掛載需要先卸載。\n查看是否掛載 /dev/sdb：mount | grep sdb\n卸載分割區：umount /dev/sdb1\n使用 parted 指令建立分割區。\nparted /dev/sdb\n執行後將處於 parted 指令模式，可以使用 parted 單一字母指令設定來使用分割區。\n4.刪除分割區。\n單一指令 `p` 列出所有分割區。 使用 `rm` 指令，按下 Enter 後輸入相對應 `Number` 即可刪除某個分割區。 建立 GPT 分割區表。\n使用指令 mklabel gpt。\n建立新分割區。\n輸入 mkpart 指令，系統會提示輸入分割區名稱、檔案系統類型，然後是分割區的開始和結束。\n例如命名 yexca-UDisk，檔案類型為 xfs，分割區從 1MB 開始，到 123GB 結束：\n1 2 3 4 5 (parted) mkpart Partition name? []? yexca-UDisk File system type? [ext2]? xfs Start? 1 End? 123GB 檢查分割區是否正確建立。\n單一指令 p 列出所有分割區。\n分割區建立完成後需要在分割區上建立檔案系統。\n例如建立 XFS 檔案系統：mkfs -t xfs /dev/sdb1\n若沒有 -t 選項，預設建立 EXT2 檔案系統。\n掛載檔案系統。\n1 2 3 4 # 建立掛載資料夾 mkdir /mnt/tmp # 掛載 /dev/sdb1 到 /mnt/tmp mount /dev/sdb1 /mnt/tmp 卸載檔案系統。\n使用指令 umount /dev/sdb1\n一般來說，插入 USB 裝置會自動掛載。\n如果需要手動掛載，可在 /etc/fstab 添加一行：\n1 /dev/sdb1 /mnt/tmp xfs defaults 0 1 共六段：\n分割區 掛載的資料夾 檔案系統 分割區啟動時掛載 是否使用 dump 指令備份分割區檔案 (0 為不備份) 在一定的掛載數量之後對分割區進行錯誤檢查 12.2.4 建立多重分割區磁碟 使用 fdisk 指令介紹。\n進入 fdisk 指令模式。\nfdisk /dev/sdb\n建立分割區。\n單一指令 n，然後選擇主要分割區 p 或延伸分割區 e，選擇分割區位置 (預設即可)。\n然後是分配的空間，起始空間可以預設，按下 Enter 後輸入結束空間：例如分配 5 GB 空間則輸入 +5G，若直接輸數字則會被認為是磁區。\n第四個分割區，即延伸分割區，分配空間可以兩次都是預設。\n檢查分割區。\n單一指令 p。\n預設的分割區類型是 Linux，如果想要轉換分割區類型。\n使用指令 t，選擇分割區數，然後輸入 L 查看分割區類型列表，找到十六進位碼，然後輸入以變更。\n檢查變更並儲存變更。\n單一指令 p 以檢查，單一指令 w 以儲存變更。\n變更完畢後，檢查核心是否知道對分割區表的變更。\n1 2 3 4 5 grep sdb /proc/partitions # 如果沒有輸出預期的結果，執行以下指令 partprobe /dev/sdb # 再次檢查 grep sdb /proc/partitions 建立檔案系統。 1 2 3 4 5 6 7 8 9 10 # 建立 EXT4 檔案系統 mkfs -t ext4 /dev/sdb1 # 建立交換空間 mkswap /dev/sdb2 # 建立 EXT2 檔案系統 (預設值) mkfs /dev/sdb3 # 建立 VFAT 檔案系統 mkfs -t vfat /dev/sdb4 # 使該分割區成為 LVM 實體卷宗 pvcreate /dev/sdb5 12.3 使用邏輯卷宗管理分割區 如果磁碟空間不足，恐怕只能將資料複製到另一個更大的磁碟中，但該過程需要停機且效率低下。\nLVM (Logical Volume Management，邏輯卷宗管理) 可採用靈活且高效的方式處理變更儲存體的需求。透過使用 LVM，可將實體磁碟分割區添加到被稱為 卷宗群組 的空間池。邏輯卷宗根據需要從卷宗群組分配空間。\n12.3.1 檢查現有的 LVM 使用指令 fdisk -l /dev/sda 查看是否存在 Linux LVM 分割區，假設 /dev/sda2 為 LVM 分割區。\n查看該 LVM 分割區是否在 LVM 群組中使用。\npvdisplay /dev/sda2\n假設卷宗群組 (VG Name) 是 vg_abc，查看卷宗群組的資訊。\nvgdisplay vg_abc\n可以從實體卷宗使用的最小儲存單位是 PE (Physical Extent) 大小。\n查看卷宗群組的 PE 分配位置。\nlvdisplay vg_abc\n輸出將展示多個邏輯卷宗名稱，這些邏輯卷宗可以和實體卷宗一樣直接使用名稱進行掛載。\n12.3.2 建立 LVM 邏輯卷宗 LVM 邏輯卷宗的使用是由上而下進行的，而建立 LVM 邏輯卷宗的過程則是由下而上進行。首先建立一個或多個實體卷宗 (PV)，然後使用實體卷宗建立卷宗群組 (VG)，最後從卷宗群組建立邏輯卷宗 (LV)。\n準備一個有 LVM 分割區的儲存裝置。\n建立過程 12.2.4 有提及。\n將該實體卷宗加入卷宗群組。\nvgcreate myvg0 /dev/sdb5\n查看卷宗群組。\nvgdisplay myvg0\n若分割區為 400M，可以使用 396M 空間 (以 4M 為單位)。\n1 2 3 4 5 6 # 從卷宗群組部分空間建立一個邏輯卷宗，例如建立 1G 邏輯卷宗 lvcreate -n name -L 1G myvg0 # 查看該邏輯卷宗是否存在 ls /dev/mapper/myvg0* # 若輸出以下內容則建立成功 /dev/mapper/myvg0-name 放入檔案系統並掛載。 1 2 3 4 5 6 7 8 # 建立 EXT4 檔案系統 mkfs -t ext4 /dev/mapper/myvg0-name # 建立掛載資料夾 mkdir /mnt/tmp # 掛載 mount /dev/mapper/myvg0-name /mnt/tmp # 檢查是否掛載成功 df -h /mnt/tmp 或者也可以寫入 /etc/fstab 以自動掛載。 12.3.3 擴展 LVM 邏輯卷宗 如果用完邏輯卷宗的空間，可添加空間而不必卸載該邏輯卷宗。為此，卷宗群組中必須有可用的空間，然後擴展邏輯卷宗。\n檢查剩餘空間。 1 2 3 4 # 檢查卷宗群組可用空間 vgdisplay myvg0 # 檢查邏輯卷宗可用空間 df -h /mnt/tmp 擴展邏輯卷宗。\nlvextend -L +1G /dev/mapper/myvg0-name\n調整檔案系統大小。\nresize2fs -p /dev/mapper/myvg0-name\n檢查是否調整成功。\ndf -h /mnt/tmp\n12.4 掛載檔案系統 事實上在上兩節中已經涉及了掛載檔案系統指令 mount 以及自動掛載設定 (檔案 /etc/fstab)。\n12.4.1 支援的檔案系統 輸入指令 cat /proc/filesystems 以查看支援的檔案系統類型，以下僅部分。\n檔案系統 描述 ext4 流行 EXT3 檔案系統的繼承者。支援最大 1EB 的卷宗以及最大 16 TB 的檔案 iso9660 從 High Sierra 檔案系統 (CD-ROM 的原始標準) 演變而來。資料 CD-ROM 通常使用該檔案系統 Minix 最初用於 UNIX 的 Minix 版本。支援最多只有 30 個字元的檔案名稱 msdos MS-DOS 檔案系統類型，可用於掛載來自 Windows 作業系統的軟碟 vfat Microsoft 擴展的 FAT 檔案類型 exfat 為 SD 卡、USB 隨身碟和其他快閃記憶體優化的擴展 FAT 檔案系統 proc 並非真正的檔案系統。是 Linux 核心的檔案系統介面。/proc 的掛載點應該是一個 proc 檔案系統。許多公用程式依賴 /proc 才能存取 Linux 核心資訊 ReiserFS 日誌檔案系統。曾經多個 Linux 發行版本的預設檔案系統類型，但如今是 EXT 和 XFS swap 用於交換空間 squashfs 壓縮且唯讀的檔案系統類型 NFS Network Filesystem，用於在其他 Linux 或 UNIX 電腦上掛載檔案系統 ntfs Windows NT 檔案系統 xfs 最早由 Silicon Graphics 開發的高效能檔案系統，可很好地使用大型檔案 gfs2 一種共享磁碟檔案系統，允許多台電腦使用相互溝通的共享磁碟，而不必透過網路檔案系統層，如 CIFS、NFS 等 輸入 man fs 了解更多 Linux 檔案系統相關資訊。\n12.4.2 啟動交換空間 1 2 3 4 5 6 # 查看交換空間數量 free -m # 建立交換空間 mkswap /var/opt/myswap # 啟用交換空間 swapon /var/opt/myswap 如果在 /etc/fstab 添加了交換空間相關條目，如：\n/var/opt/myswap swap swap defaults 0 0\n可以使用 swapon -a 啟用。\n12.4.3 停用交換空間 swapoff /var/opt/myswap\n12.4.4 使用 fstab 檔案定義可掛載的檔案系統 12.2.3 已介紹，不過欄位二可以使用 UUID 而非裝置名稱，因為裝置名稱是可變的。\n查看 UUID：blkid\n12.4.5 使用 mount 指令掛載檔案系統 同樣在 12.2.3 已介紹。\n12.4.6 以迴送方式掛載磁碟映像檔 也就是將 ISO 映像檔掛載。\n1 2 3 4 # 建立掛載資料夾 mkdir /mnt/tmp # 掛載 mount -o loop name.iso /mnt/tmp 12.4.7 使用 umount 指令 可以輸入裝置分割區名稱或目錄名稱。\n裝置分割區名稱：umount /dev/sdb1\n目錄名稱：umount /mnt/tmp\n通常，最好使用目錄名稱。\n如果一個目錄正忙碌而無法被卸載，可以：\n延遲卸載：umount -l\n強制卸載：umount -f\n12.5 使用 Cockpit 管理儲存體 圖形使用者介面，啟用請參考第八章。\n","date":"2023-01-03T13:37:48+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/85/","title":"Linux 學習 第十二章 管理磁碟和檔案系統"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 第十一章 取得使用者帳號 使用者帳號維持了使用系統的人與系統中執行的程序（Process）之間的邊界，而群組是一種將系統的權限一次性分配給多個使用者的方法。\n11.1 建立使用者帳號 每一個使用 Linux 系統的人都應該有一個單獨的使用者帳號。透過擁有一個使用者帳號，可以提供用來完整儲存檔案的區域，以及調整使用者介面 (GUI、路徑、環境變數等)，從而符合使用者使用電腦的習慣。\n可以透過 Cockpit 使用 GUI 建立帳號，若尚未安裝：\n1 2 yum install cockpit -y systemctl enable --now cockpit.socket 然後瀏覽器打開 localhost:9090 以進行操作。\n11.1.1 使用 useradd 指令新增使用者 多數情況下使用 GUI 是比較麻煩的，所以可以使用 useradd 指令以新增使用者 (root 權限)，唯一必要的參數是使用者的登入名稱，可用選項包括：\n可用選項 描述 -c \u0026ldquo;comment\u0026rdquo; 提供對新使用者帳號的描述。一般為使用者的全名 -d home_dir 設定帳號所使用的家目錄。預設使用登入名稱命名並放入 /home 目錄 -D 並不建立新帳號，而是將所提供的資訊儲存作為建立新使用者的預設設定 -e expire_date 以 YYYY-MM-DD 格式分配帳號的有效期限。例如：-e 2024-08-01 -f -1 設定密碼過期後多少天，便永久封鎖該帳號。預設值 -1 表示停用此選項 -g group 設定使用者所在的主群組 (必須已存在於 /etc/group 檔案中)。若沒有該選項，將建立一個新群組 (使用使用者名稱作為群組名稱)，並將其作為使用者的主群組 -G grouplist 將新使用者新增到以逗號分隔的次要群組清單中。例如：-G wheel, sales, tech -k skel_dir 設定使用者家目錄的檔案，複製自 skel_dir，預設為 /etc/skel -m 自動建立使用者的家目錄。對於 Fedora 和 RHEL 該選項是預設的，但對於 Ubuntu 來說則不是 -M 不建立使用者家目錄，儘管有 -m 選項也不建立 -n 停用建立一個與新使用者名稱和使用者 ID 相符合之新群組的預設行為 -o 使用 -u uid 建立一個與另一個使用者帳號具有相同 UID 的使用者帳號 -p passwd 設定密碼 (使用 MD5 加密過的)。如果此時未設定，可以使用 passwd user 指令。使用 openssl passwd 以輸出透過 MD5 加密後的密碼 -s shell 設定預設 shell。例如：-s /bin/csh -u user_id 為帳號指定使用者 ID 號碼，若沒有則自動分配。自動分配給一般使用者的 ID 從 1000 開始 一般情況使用：\n1 2 3 # root 權限下 useradd yexca passwd yexca 在建立 yexca 這個帳號的過程中，useradd 指令完成了以下活動：\n讀取 /etc/login.defs 和 /etc/default/useradd 檔案，取得建立帳號所使用的預設值。\n檢查命令列參數，找出哪些預設值被覆寫。\n根據預設值和命令列參數，在 /etc/passwd 和 /etc/shadow 檔案中建立新使用者條目。\n在 /etc/group 檔案中建立新的群組條目。\n在 /home 目錄中根據使用者名稱建立一個家目錄。\n將 /etc/skel 目錄中的所有檔案複製到新的家目錄中。其中通常包括登入和應用程式啟動指令碼（Script）。\n在 /etc/passwd 檔案中的使用者行：\nyexca:x:1001:1001::/home/yexca:/bin/bash\n欄位之間以冒號分隔，分別為登入名稱、密碼、使用者 ID、主群組 ID、註釋欄位、家目錄、預設登入終端機。\n密碼欄位為 x 是被加密儲存在 /etc/shadow。\n在 /etc/group 檔案中的群組行：\nyexca:x:1001:\n同樣以冒號分隔，分別為群組名稱、群組密碼、群組 ID 以及群組中使用者清單。\n11.1.2 設定使用者預設值 useradd 指令透過讀取 /etc/login.defs 和 /etc/default/useradd 檔案確定預設值，所以可以修改檔案以修改預設值。\n在不同 Linux 系統中 login.defs 不同，以下僅列出部分：\n1 2 3 4 5 6 7 8 9 10 11 12 13 PASS_MAX_DAYS 99999 PASS_MIN_DAYS 0 PASS_MIN_LEN 5 PASS_WARN_AGE 7 UID_MIN 1000 UID_MAX 60000 SYS_UID_MIN 200 SYS_UID_MAX 999 GID_MIN 1000 GID_MAX 60000 SYS_GID_MIN 201 SYS_GID_MAX 999 CREATE_HOME yes 修改其他預設選項可以參閱 /etc/default/useradd 檔案，可以透過 useradd -D 查看目前預設設定。\n也可以將 -D 與一些其他選項搭配使用以修改 /etc/default/useradd 檔案：\n-b default_home \u0026mdash; 設定所建立家目錄所在的目錄。通常為 /home。\n-e default_expire_date \u0026mdash; 設定停用使用者帳號的預設截止日期。應當使用 YYYY-MM-DD 的日期格式。\n-f default_inactive \u0026mdash; 設定密碼過期後多少天帳號被停用。\n-g default_group \u0026mdash; 新使用者預設所在的群組。通常會建立與使用者具有相同名稱和 ID 號碼的新群組。\n-s default_shell \u0026mdash; 預設 shell。\n11.1.3 使用 usermod 修改使用者 usermod 指令提供了一種簡單明瞭的方法來更改帳號參數。\n選項 描述 -c \u0026ldquo;username\u0026rdquo; 更改描述 -d home_dir 更改家目錄 -e expire_date 分配一個 YYYY-MM-DD 格式的新過期時間 -f -1 更改密碼過期之後多少天永久停用帳號。預設值 -1 表示停用該選項 -g group 更改使用者所在主群組 (需存在該群組) -G grouplist 將使用者的附屬群組設定為以逗號分隔的群組清單。如果想保留原本群組，請使用 -Ga -l login_name 更改登入名稱 -L 鎖定帳號 (在 /etc/shadow 檔案的加密密碼前新增一個驚嘆號) -m 將原家目錄內容複製到新家目錄。僅當 -d 選項被使用時該選項才有效 -o 只能與 -u 一起使用以取消 UID 必須唯一的限制 -s shell 更改 shell -u user_id 更改使用者 ID -U 解除鎖定 (將 /etc/shadow 檔案的加密密碼前的驚嘆號刪除) 11.1.4 使用 userdel 刪除使用者 例如指令 userdel -r yexca 將使用者 yexca 從 /etc/passwd 檔案刪除，-r 表示將家目錄 /home/yexca 也一併刪除。\n在刪除使用者前可以先使用 find 指令尋找使用者遺留的檔案，例如：find / -user yexca -ls 或 find / -uid 1001 -ls。\n因為沒有分配給使用者的檔案可能會是一個安全隱憂，比較好的作法是分配給一個真實的帳號，可以使用 find / -nouser -ls 指令找到不與任何使用者關聯的檔案。\n11.2 瞭解群組帳號 如果要處理在多個使用者中共享一組檔案，那麼群組帳號是非常有用的。\n透過 chgrp grpName fileOrDir 指令以更改檔案或目錄所屬群組。\n11.2.1 使用群組帳號 每一個使用者都分配給一個主群組，主群組由 /etc/passwd 檔案中每一條目的第四個欄位的數字來表示。\n一個使用者可以屬於多個次要群組，也可以不屬於任何次要群組。如果使用者 yexca 是群組 yexca 和群組 hi 的一名成員，那麼在 /etc/group 檔案中的條目將如下所示：\nyexca:x:1001:yexca\nhi:x:1002:yexca\n只有 root 權限的人才能改變分組，也就是一般使用者無法更改自己的分組，也不能將其他使用者新增到自己的群組。\n如果想要以某群組身分建立檔案，可以使用 newgrp 指令以暫時成為某一群組成員。\n擁有 root 權限的使用者可以使用 gpasswd 指令設定某群組的群組密碼。\n11.2.2 建立群組帳號 建立：groupadd groupName\n分配群組編號：groupadd -g gid groupName\n或者更改某使用者的群組，可以使用群組名稱或群組編號：\ngroupmod -g gid userName\ngroupmod -n groupName userName\n而如果改變次要群組，參考 usermod 指令。\n11.3 在企業中管理使用者 透過使用 ACL (Access Control Lists) 技術，使任何使用者可將檔案或目錄的特定權限分配給任何使用者和群組。\n11.3.1 使用 ACL 設定權限 兩個指令：設定 setfacl 和取得 getfacl 某目錄權限。\n設定時，透過 -m 修改或 -x 刪除權限，例如：\nsetfacl -m u:userName:rwx filename\n11.3.2 為使用者新增目錄以便進行協作 當使用 chmod 指令更改權限時，一般會忽略一組特殊的三權限位元，這些權限位元可以在指令和目錄上設定特殊權限。\n例如：chmod 775 /home/yexca/tmp.txt ，實際上權限為 0775。\n名稱 數值 字母值 設定使用者 ID 位 4 u+s 設定群組 ID 位 2 g+s 粘滯位 1 o+t 建立群組協作目錄 (設定 GID 位) 1 2 3 4 5 6 7 8 9 10 11 # 建立一個用於協作的群組 groupadd -g 301 cooperation # 新增一些使用者 usermod -aG cooperation yexca # 建立協作目錄 mkdir /mnt/co-tmp # 將群組 cooperation 分配給該目錄 chgrp cooperation /mnt/co-tmp # 更改目錄權限 chmod 2775 /mnt/co-tmp # 此時如果查看該目錄權限應該為 rwxrwsr-x 現在，若使用者 yexca 在目錄 /mnt/co-tmp 建立一個檔案，該檔案所屬群組為 cooperation，而不是 yexca。\n建立受限制的刪除目錄 (粘滯位) 指令：chmod 1775 /mnt/tmp\n在受限制的刪除目錄中，除非是 root 使用者或者是目錄的擁有者，否則不能刪除其他使用者的檔案，即使擁有寫入權限。\n例如 /tmp 目錄就是一個受限制的刪除目錄 (權限為 rwxrwxrwt)。\n設定使用者位元 Set UID\n擁有設定使用者位元的可執行檔 (rwsr-xr-x) 代表其他使用者可執行，但執行指令的程序為擁有該檔案的使用者。\n例如 su 指令，所有使用者皆可執行，但執行的程序屬於 root 使用者。\n11.4 集中式使用者帳號 Linux 預設驗證使用者的方法是根據 /etc/passwd 檔案和 /etc/shadow 檔案的密碼，但也可以使用其他方式。\n例如 LDAP (Lightweight Directory Access Protocol)、NIS (Network Information Service)、Winbind 等。\n","date":"2023-01-02T12:29:03+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/84/","title":"Linux 學習 第十一章 取得使用者帳號"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 第十章 取得與管理軟體 10.1 在桌面管理軟體 透過軟體與 GUI 管理\n10.2 超越 Software 視窗 Software 中能搜尋到的軟體有限\n10.3 了解 Linux RPM 與 DEB 軟體套件 軟體套件稱為 tarball (壓縮檔)，包含執行檔 (指令)、文件、設定檔以及函式庫\nDEB (.deb) 套件 Debian GNU/Linux 專案建立了 .deb 套件，這種套件被 Debian 以及其他基於 Debian 的發行版本 (Ubuntu、Linux Mint、KNOPPIX 等) 所使用。透過 apt 或 dpkg 指令以安裝、管理、更新和刪除軟體\nRPM (.rpm) 套件 最初為 Red Hat Package Manager，後被命名為 RPM Package Manager。RPM 是 SUSE、Red Hat 發行版本 (RHEL、Fedora) 以及其他發行版本 (需基於 Red Hat 發行版本，如 CentOS、Oracle Linux 等) 的首選軟體套件格式。透過原先的 rpm 或增強的 yum 以及現在的 dnf 指令管理軟體\nyum 終將被 dnf 指令所取代\n10.3.1 理解 DEB 套件 Debian 軟體套件以封存檔案格式儲存了許多檔案以及與一些軟體相關的中繼資料。這些檔案可以是執行檔 (指令)、設定檔以及其他軟體項目。而中繼資料包括相依性、授權、套件大小、描述以及其他資訊\n透過 apt* 指令以取得 (apt-get)、搜尋 (apt-cache search)、查看詳情 (apt-cache show)、安裝 (apt-get install)、升級 (apt-get upgrade)、列出已安裝軟體 (apt-cache pkgnames) 等\n透過 aptitude 指令以在 shell 中使用面向螢幕的選單從而安裝軟體\n10.3.2 理解 RPM 套件 RPM 套件是不同檔案的合併，而每個檔案提供了一項功能。RPM 內部可以是構成軟體功能的指令、設定檔以及文件或者中繼資料 (關於軟體套件的內容、軟體套件的來源、執行所需的條件以及其他資訊)\n使用 rpm -q -i packageName 指令查看某軟體資訊\n10.4 使用 yum 管理 RPM 軟體套件 10.4.1 從 yum 到 dnf 的轉換 DNF 自稱為 Dandified yum https://github.com/rpm-software-management/dnf/ 雖然 dnf 與 yum 保持了基本的命令列相容性，但主要區別之一是它遵循嚴格的 API，並鼓勵開發 dnf 的擴充和外掛程式\n以下 yum 指令均可作為 dnf 指令使用\n有關 dnf 更多資訊，可參考 https://dnf.readthedocs.io/ 10.4.2 了解 yum 的運作原理 基本語法 yum [options] command\n例如安裝 Firefox：yum install firefox\n檢查 /etc/yum.conf 檔案中\ngpgcheck 表明是否對軟體套件驗證\ninstallonly_limit=3 表明允許在系統中保存同一套件的最多三個版本 (請不要將其設置為小於 2，以確保始終擁有至少兩個核心套件)\nclean_requirements_on_remove=True 表示在解安裝某軟體將一起解安裝相依項 (如果該相依項不被其他軟體使用)\nbest=True 表示升級軟體時優先嘗試最新版本\ncachedir 表示快取位置\nkeepcache 是否保留快取\ndebuglevel 寫入日誌的詳細層級，越高越詳細\nmetadata_expire 中繼資料逾時時間\n詳細了解，使用 man yum.conf 指令\n檢查 /etc/yum.repos.d/*.repo 檔案 若想啟用某軟體庫，將 .repo 檔案放到此目錄。檔案內容大致如下\n1 2 3 4 5 6 7 [myrepo] # 開頭，`[]` 內為軟體庫名稱 name=My repo # 詳細描述 baseurl=https://rpmrepo.yexca.net/ # 虛擬網址，不存在 # 包含 RPM 檔案的 url 可以是 http://, ftp://, file:// enabled=1 # 是否啟用該軟體庫，若沒有預設啟用 gpgcheck=1 # 是否檢查軟體套件簽章 gpgkey=file:///etc/MYKEY # 用於檢查軟體套件的密鑰位置 可以啟用任意數量的軟體庫，但每次執行 yum 指令時將檢查每一個軟體庫，將軟體套件相關中繼資料下載到本機系統，所以不要啟用過多的軟體庫\n從 YUM 軟體庫中下載 RPM 軟體套件和中繼資料 在 rpm 目錄有一個 repodata 目錄，為所有啟用軟體庫的 repodata 目錄彙整\n中繼資料資訊儲存在 /var/cache/yum，在達到逾時時間後將取得最新中繼資料，yum 預設為 6h，dnf 預設為 48h\n將 RPM 軟體套件安裝到 Linux 檔案系統 相關軟體下載到快取中後，yum 指令透過執行 rpm 指令安裝。如果軟體套件有指令碼，先執行指令碼。然後將軟體套件內容 (指令、設定檔、文件等) 複製到 RPM 中繼資料指定位置。最後執行安裝後執行的指令碼\n將 YUM 軟體庫的中繼資料儲存到本機 RPM 資料庫 包含在每個 RPM 軟體庫中的中繼資料最終被複製到本機的 RPM 資料庫中，而 RPM 資料庫儲存在 /var/lib/rpm 目錄的多個檔案中\n10.4.3 藉助第三方軟體庫使用 yum 為了穩定性，建議僅使用官方內建，但自己使用以舒適度優先，可以啟用 RPM Fusion 第三方庫，參考 https://rpmfusion.org/ 10.4.4 使用 yum 指令管理軟體 搜尋軟體套件 yum search keyword\n取得某軟體詳細資訊 yum info firefox\n若知道指令、設定檔或函式庫名稱，但不知道軟體套件名稱 yum provides keyword\n使用 list 子指令以不同方式列出軟體套件名稱 yum list firefox\nyum list available\nyum list installed\nyum list all\n查看某軟體套件的相依性、提供者等 yum deplist firefox | less\n安裝和刪除軟體套件 install 子指令用於安裝一個或多個軟體套件，以及相應相依套件 yum install firefox 或 yum -y install firefox 以不需要同意直接安裝\nreinstall 子指令可以重新安裝某軟體 yum reinstall firefox\nremove 子指令刪除軟體及其他套件不需要的相依項 yum remove firefox\n或者透過歷史紀錄撤銷\n使用 yum history 查看安裝歷史紀錄，yum history info 12 查看 id 為 12 的安裝歷史紀錄詳情，yum history undo 12 撤銷 id 為 12 的安裝事務\n更新軟體套件 yum check-update 檢查更新，yum update 更新全部軟體，yum update firefox 更新 Firefox\n更新軟體套件群組 為更方便地管理一套完整的軟體套件，yum 支援軟體套件群組\nyum grouplist | less 查看軟體套件群組\nyum groupinfo LXDE 查看 LXDE 桌面相關軟體套件群組\nyum groupinstall LXDE 安裝 LXDE 軟體套件群組\nyum groupremove LXDE 刪除整個 LXDE 群組\n維護 RPM 軟體套件資料庫和快取 yum clean packages 清除軟體安裝套件\nyum clean metadata 清除中繼資料\nyum clean all\n雖然可能不大，但 RPM 資料庫有受損的可能\nyum check 檢查快取和資料庫情況\nrpm --rebuilddb 重建資料庫\n註：一般使用本機 RPM 資料庫的最適合指令為 rpm\n從 YUM 庫下載 RPM 只是下載，但不安裝，下載到目前目錄\nyumdownloader firefox\ndnf download firefox\n10.5 使用 rpm 指令安裝、查詢和驗證軟體 大部分情況下使用 rpm 指令對本機的安裝包檔案使用\n10.5.1 使用 rpm 安裝和刪除軟體套件 安裝 rpm -i packageName\n需要使用 rpm 套件的完整名稱，即包括基名、版本、核心等\n升級 rpm -Uhv packageName\n-h 為列印 # 標識 (安裝進度)，-v 為更詳細的輸出\n更新 若目前目錄有數以千計的 rpm 套件，僅想對以此電腦已經安裝過的升級\nrpm -Fhv *.rpm\n重新安裝 rpm -Uhv --replacepkgs packageName\n降級 rpm -Uhv --oldpackage packageName\n刪除 刪除時僅需要基名，如刪除 Firefox\nrpm -e firefox\n但並不會刪除該軟體的相依性\n10.5.2 查詢 rpm 資訊 安裝完軟體後，使用 -q 選項以查詢關於該軟體套件的資訊，如相關描述 -qi、檔案列表 -ql、設定檔 -qc\n查詢使用基名即可，如：rpm -qi firefox\n還可以查詢相依性 -q --requires、軟體套件所提供的軟體版本 -q --provides、刪除之前和之後執行的指令碼 -q --scripts、變更紀錄 -q --changelog\n透過 --queryformat 查詢資訊的不同標記，--querytags 以查看所有可用標記\n以上為本機 RPM 資料庫查詢，若添加 -p 選項可查詢目前目錄的軟體套件，此時需要輸入全名，如 rpm -qip zsh-5.7.1-1.fc30.x86_64.rpm\n10.5.3 驗證 rpm 軟體套件 註：該選項查閱其他資料並未發現，但本人 Linux 已刪除，無法驗證 (之前用的時候看到這沒複現)，但既然看到了，還是記錄一下比較好\n透過使用 -V 選項對已安裝的軟體套件檢查，了解自首次安裝以來是否被更改。若執行檔 (/bin 目錄下) 被更改，可能表明系統被破解。設定檔更改很常見\n查詢已安裝的 Firefox 的情況 rpm -V firefox\n如果輸出以下字元，代表相應地方被修改；沒有輸出表示每個檔案為原始狀態\n字元 描述 S 檔案大小不一致 M 模式不一致 (包括權限和檔案類型) 5 MD5 校驗不一致 D 裝置主要 / 次要編號不匹配 L readLink (2) 路徑不匹配 U 使用者所有權不一致 G 群組所有權不一致 T mTime 不一致 P caPabilities 不一致 這些指示符來自 rpm 手冊的 Verify 部分\n可以使用 --replacepkgs 以恢復至原始狀態\n如果對安全性要求過高，可以備份 RPM 資料庫，即 /var/lib/rpm 目錄，然後存入唯讀媒介，畢竟如果資料庫也被破解，那校驗將毫無意義\n10.6 在企業中管理軟體 如 Kickstart 檔案、PXE 啟動、Satellite 伺服器 (Spacewalk)、容器映像檔\n可以自動化大量安裝軟體\n","date":"2022-12-08T16:35:57+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/83/","title":"Linux 學習 第十章 取得與管理軟體"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 第八章 學習系統管理 8.1 理解系統管理 su 命令 \u0026mdash; 以 root 使用者身分開啟一個 shell\nsudo 命令 \u0026mdash; 一般使用者透過此命令執行其他命令時，該指令才會被賦予 root 權限\n8.2 使用圖形化管理工具 Cockpit 是基於瀏覽器的系統管理工具\n安裝 Cockpit 1 sudo dnf install cockpit 以 root 身分登入，啟用 Cockpit 通訊端 (Socket) 1 sudo systemctl enable --now cockpit.socket 在瀏覽器打開介面： localhost:9090 8.2.1 使用 system-config-* 工具 工具 命令 描述 網域名稱系統 (DNS) system-config-bind 如果電腦充當 DNS 伺服器，應建立和設定區域 (Zone) HTTP system-config-httpd Apache Web 伺服器 NFS system-config-nfs 設定與其他使用了 NFS 服務的電腦共用的目錄 Root Password system-config-rootpassword 變更 root 密碼 Samba NFS system-config-samba 設定 Windows 共用資料夾 Services system-config-services 顯示和變更 Fedora 中在不同執行等級 (Runlevel) 的服務 Authentication authconfig-gtk 變更系統中對使用者進行身分驗證的方式 Date \u0026amp; Time system-config-date 設定日期和時間或與 NTP 伺服器保持同步 Firewall system-config-firewall 設定防火牆 Language system-config-language 選擇語言 Printing system-config-printer 設定本機和網路印表機 SELinux Management policycoreutils-gui 設定 SELinux 的強制模式與預設原則 Users \u0026amp; Groups system-config-users 使用者帳號相關 8.3 使用 root 使用者帳號 8.3.1 透過 shell 成為 root 使用者 使用命令 su 即可轉為 root 使用者，但此時環境變數還是原來的帳號\n使用 su - 以將環境變數也轉變為 root 使用者的\n此外，透過 su - username 可切換到指定使用者\n8.3.2 使用 sudo 獲取管理存取權限 使用 sudo 執行的命令擁有 root 權限，而且不需要 root 密碼，只需要賦予相應使用者權限即可\n以下為賦予 sudo 權限\n以 root 身分執行 visudo 命令\n添加如下所示行\n1 2 3 4 5 yexca ALL=(ALL) ALL # 或下面為使用 sudo 時不需要密碼 # (該使用者的密碼，不是 root 使用者的密碼) yexca ALL=(ALL) NOPASSWD:ALL 這樣將賦予使用者 yexca 以 sudo 權限\n儲存變更後的檔案 8.4.2 管理設定檔 大部分設定檔以純文字的形式存在 /etc 目錄下，以下為部分檔案\n目錄 描述 /etc/cron* 定義了 crond 排程執行的程式，如 cron.daily、cron.hourly /etc/cups 設定 CUPS 列印服務的檔案 /etc/default 為各種公用程式設定預設值的檔案 /etc/httpd 設定 Apache Web 伺服器行為 /etc/rc?.d 針對每一種有效的系統狀態，都有一個單獨的 rc?.d 目錄：rc0.d (關閉狀態)、rc1.d (單一使用者狀態)、rc2.d (多使用者狀態)、rc3.d (多使用者加網路狀態)、rc4.d (使用者定義的狀態)、rc5.d (多使用者、網路與 GUI 登入狀態) 和 rc6.d (重新啟動狀態) /etc/skel 建立新使用者時，該目錄檔案被複製到新使用者的家目錄 /etc/sysconfig 包含各種服務所建立和維護的重要系統設定檔 /etc/systemd 包含與 systemd 公用程式 (用來管理啟動程序和系統服務) 相關聯的檔案 /etc/xinetd.d 包含一組檔案，每一個檔案定義了一個 xinetd 守護行程 (Daemon) 監聽某一個特定埠號 (Port) 所需的隨選網路服務 8.4.3 管理紀錄檔和 Systemd.Journal rsyslogd 和 systemd 的 journalctl 命令\nrsyslogd 及前身 syslogd 將檔案放到 /var/log 目錄\n8.5 使用其他管理帳號 例如 lp、apache、bin 等使用者，預設不允許登入\n如果要登入需要將預設 shell 從 /sbin/nologin 或 /bin/false 改為真實 shell，例如 /bin/bash\n8.6 檢查和設定硬體 8.6.1 檢查硬體 透過 dmesg 或 journalctl 命令查看 Linux 啟動時硬體檢測資訊以及驅動程式載入資訊\n透過 lspci 命令查看電腦上 PCI 匯流排 (Bus) 及連接到這些匯流排上的裝置，lsusb 命令列出 USB 裝置資訊，lscpu 列出處理器資訊\n8.6.2 使用可載入模組 如果想添加未被正確識別的硬體，可能需要手動載入\n列出可載入模組 透過 lsmod 命令，如要獲取某一模組詳情，透過 modinfo -d 模組 命令\n載入模組 使用 modprobe 命令載入任何被編譯並安裝到執行核心 (Kernel) 的模組\n刪除模組 使用 rmmod 命令，或使用 modprobe -r 以將相依模組一起刪除\n8.7 小結 在 Linux 中應該把各項服務 (http、git 等) 單獨建立使用者並限制登入權限以確保系統安全\n第九章 安裝 Linux 無\n圖形化安裝不必多說，其他安裝可參考 Arch 參考手冊 我也寫了一篇比 Arch 手冊更入門的文章： 虛擬機器中 Arch Linux 安裝記錄 – yexca\u0026rsquo;Blog 另有遠端安裝例如 PXE 啟動之類因無法重現，無法理解\n","date":"2022-12-07T16:29:05+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/82/","title":"Linux 學習 第八、九章 學習系統管理與安裝 Linux"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 第七章 撰寫簡單的 Shell 腳本 如果需要反覆執行某一任務，而該任務又需要輸入大量的命令列，那麼可以透過寫入 Shell 腳本以實現一條指令完成所有任務。\n7.1 理解 Shell 腳本 Shell 腳本是一組包含指令、函式、變數或其他可以透過 Shell 使用的功能。這些項目被輸入進一個純文字檔案中，而該檔案可以作為一條指令來執行。\n類似於 Windows 中的批次檔 (.bat)\n7.1.1 執行與除錯 Shell 腳本 Shell 腳本的主要優點是可以在任何文字編輯器中打開以查看腳本的內容，最大的缺點是大型或複雜的 Shell 腳本的執行通常比編譯後的程式要慢。可以透過兩種基本的方法執行 Shell 腳本：\n將腳本名稱作為 Shell 的一個參數，例如：bash myscript\n在 Shell 腳本第一行添加解釋器名稱 (#!/bin/bash)，給該檔案添加執行權限後 (chmod +x myscript)，透過在命令列輸入腳本的路徑運行，例如 (./myscript.sh)\n在執行時跟在腳本名稱後面的為命令列參數。\n註釋為 #\n可以在腳本開頭添加 set -x 以使用 $ bash -x myscript 顯示正在執行的指令。\n7.1.2 理解 Shell 變數 Shell 變數中的變數名稱是大小寫敏感的，注意定義時等號 (=) 左右無空格，例如：\nNAME=value\n可以為變數分配常數，例如文字、數字及下劃線。\n也可為變數賦值一個指令，例如：MYDATE=$(date) 以將 date 指令的輸出分配給變數 MYDATE。\n這樣每次使用變數 MYDATE 將執行一次 date 指令並將結果賦值給 MYDATE。可以將指令放在引號 ' 中以獲得賦值時指令的執行結果。\n特殊的 Shell 字元：錢字號 ($)、引號 (')、星號 (*)、驚嘆號 (!) 等。\n如果想在命令列輸出顯示 $HOME 需要跳脫 $，可使用 echo '$HOME' 或 echo \\$HOME ，即：\n如果想要 Shell 從字面上解釋單個字元，使用反斜線 \\。\n如果想從字面上解釋一組字元，則使用單引號 (') 包圍這些字元。\n如果想從字面上解釋一部分字元，使用雙引號 (\u0026quot;) 包圍一組文字，其中錢字號 ($)、引號 (') 和驚嘆號 (!) 將被解釋，而其他字元 (例如星號 *) 則不會被解釋。\n為變數賦值直接使用變數名，而引用變數，即需要獲取變數值時需要在變數名前加錢字號 ($)。\n例如將某變數的值賦值給新變數：newVar=\u0026quot;$oldVar\u0026quot;\n特殊的 Shell 位置參數 位置參數，或 命令列參數，名為 $0、$1、$2\u0026hellip;$n。\n其中 $0 為被呼叫腳本的名稱，而其他的則被賦予從命令列傳遞而來的參數值，例如：\n1 2 3 4 5 6 #!/bin/bash echo \u0026#34;第一個參數是 $1 ，第二個參數是 $2 \u0026#34; echo \u0026#34;該腳本名稱為 $0 \u0026#34; echo \u0026#34;一共傳入了 $# 個參數\u0026#34; echo \u0026#34;所有的參數為：$@ \u0026#34; 執行指令：./myscript hello bye ，執行結果如下：\n1 2 3 4 第一個參數是 hello ，第二個參數是 bye 該腳本名稱為 /home/yexca/tmp/myscript 一共傳入了 2 個參數 所有的參數為：hello bye 還有一個有意思的參數 $? 接受最後一條被執行的指令的結束狀態，一般正常結束會返回 0。\n讀取參數 透過使用 read 指令讀取使用者輸入。\n1 2 3 4 #!/bin/bash read -p \u0026#34;請輸入兩個名詞：\u0026#34; var1 var2 echo \u0026#34;剛剛輸入了 $var1 和 $var2\u0026#34; 在 Bash 中進行參數展開 (Parameter Expansion) 想獲取一個變數的值，需要在變數名前加錢字號 ($) ，例如 $var ，這其實是 ${var} 的簡寫。\nBash 有一些規則可以以不同方式展開參數值，以下為比較常用的，以 ${var} 為例：\n範例 描述 ${var:-value} 如果變數未設置或為空，則將其展開為 value ${var#pattern} 從 var 的值的 前面 開始刪除與 pattern 最 短 的比對項 ${var##pattern} 從 var 的值的 前面 開始刪除與 pattern 最 長 的比對項 ${var%pattern} 從 var 的值的 末尾 開始刪除與 pattern 最 短 的比對項 ${var%%pattern} 從 var 的值的 末尾 開始刪除與 pattern 最 長 的比對項 基於這些特性，可以有一些有用的應用，例如：\n1 2 3 4 5 6 7 8 9 myFileName=/home/yexca/myfile.txt # file 變為 myfile.txt file=${myFileName##*/} # dir 變為 /home/yexca dir=${myFileName%/*} # name 變為 myfile name=${file%.*} # extension 變為 txt extension=${file##*.} 7.1.3 在 Shell 腳本中執行算術運算 Bash 使用了無類型變數，除非使用 declare 告訴 Bash，否則變數被視為字串。在進行運算時會自動轉為整數，不需要在賦值時指定類型。\n可以使用內建 let 指令或外部 expr 指令或 bc 指令完成整數運算。\n如：let result=$num/16 ，或 let num=$RANDOM\n同時也有遞增運算子，i++ 和 ++i\nlet 指令要求每個運算元與數學運算子之間不能存在空格。\nexpr 指令則要求每個運算元和數學運算子之間存在空格。\n而 bc 指令對空格沒有要求，可以完成浮點運算。\n7.1.4 在 Shell 腳本中使用程式結構 \u0026ldquo;if\u0026hellip;then\u0026rdquo; 語句 1 2 3 if [ $var -eq 1 ]; then echo \u0026#34;The var is 1\u0026#34; fi 如果比較數字，-eq 比較好，但若比較字串值，等號 (=) 不失為一個更好的選擇。\n1 2 3 if [ $str = \u0026#34;hello\u0026#34; ]; then echo \u0026#34;hello\u0026#34; fi 此外還有不等號 !=\n透過使用 elif 語句，以提供更多的選擇。使用 else 以代表其他情況。\n1 2 3 4 5 6 7 8 str=\u0026#34;$HOME\u0026#34; if [ -f \u0026#34;$str\u0026#34; ]; then echo \u0026#34;$str 是一個一般檔案\u0026#34; elif [ -d \u0026#34;$str\u0026#34; ]; then echo \u0026#34;$str 是一個目錄\u0026#34; else echo \u0026#34;???\u0026#34; fi 以下是一些可使用的測試條件：\n運算子 測試的內容 -a file 檔案是否存在，與 -e 相同 -b file 檔案是否為一個區塊裝置 (block device) -c file 檔案是否為字元裝置 (character device)。用來識別序列埠和終端設備 -d file 檔案是否是一個目錄 -e file 檔案是否存在，與 -a 相同 -f file 檔案是否存在，是否為一般檔案 (不是目錄、Socket、管線、連結或裝置檔案) -g file 檔案是否設置了 SGID 位元 -h file 檔案是否為一個符號連結，與 -L 相同 -k file 檔案是否設置了黏滯位元 (sticky bit) -L file 檔案是否為一個符號連結，與 -h 相同 -n string 字串的長度是否大於 0 位元組 -O file 是否擁有該檔案 -p file 檔案是否為具名管線 (named pipe) -r file 檔案是否可讀 -s file 檔案是否存在，並且大於 0 位元組 -S file 檔案是否存在，並且為 Socket -t file 檔案是否為連接到終端的描述符 -u file 檔案是否設置了 SUID 位元 -w file 檔案是否可寫 -x file 檔案是否可執行 -z string 字串的長度是否為 0 位元組 以下為兩個變數之間的比較：\n運算子 測試的內容 expr1 -a expr2 兩個運算式是否都為真 (AND) expr1 -o expr2 其中一個為真 (OR) file1 -nt file2 第一個檔案是否比第二個檔案新 (使用修改時間戳記) file1 -ot file2 第一個檔案是否比第二個檔案舊 (使用修改時間戳記) file1 -ef file2 兩個檔案是否透過一個連結相關聯 (硬連結或符號連結) var1 = var2 第一個變數是否等於第二個變數 var1 -eq var2 第一個變數是否等於第二個變數 var1 -ge var2 第一個變數是否大於等於第二個變數 var1 -gt var2 第一個變數是否大於第二個變數 var1 -le var2 第一個變數是否小於等於第二個變數 var1 -lt var2 第一個變數是否小於第二個變數 var1 != var2 第一個變數是否不等於第二個變數 var1 -ne var2 第一個變數是否不等於第二個變數 此外還可以把測試運算子與 \u0026amp;\u0026amp; 和 || 組合成長得像 C 語言中的三元運算子。\nC：a\u0026gt;b ? a : b\nShell：[ $a -gt $b ] \u0026amp;\u0026amp; echo $a || echo $b\n也可單獨使用。例如： [ $a -eq $b ] \u0026amp;\u0026amp; echo $a 為若 a 等於 b，則輸出 a 的值。\n[ -d \u0026quot;$dirName\u0026quot; ] || mkdir \u0026quot;$dirName\u0026quot; 為若 $dirName 路徑不存在，則執行指令 mkdir \u0026quot;$dirName\u0026quot;。\ncase 指令 與 C 語言中的 switch 語句類似，用於選擇。一般形式為：\n1 2 3 4 5 6 7 8 9 10 11 case \u0026#34;VAR\u0026#34; in Result1) body ;; Result2 | Result3) body ;; *) body ;; esac for\u0026hellip;do 迴圈 for 迴圈一般用於遍歷一個列表。\n1 2 3 4 5 6 7 8 9 10 for VAR in LIST do body done # 或者這樣 for VAR in LIST ; do body done 例如：\n1 2 3 4 5 6 7 8 9 10 for num in 0 1 2 3 4 do echo \u0026#34;The number is $num\u0026#34; done # 或者將指令輸出作為列表 for file in $(ls /bin) ; do echo $file done while\u0026hellip;do 和 until\u0026hellip;do 迴圈 結構如下：\n1 2 3 4 5 6 7 8 9 10 11 # while...do while condition do body done # until...do until condition do body done 7.1.5 使用一些有用的文字處理程式 最常用的程式包括 grep、cut、tr、awk、sed。大部分程式都設計為使用標準輸入和輸出。\n一般正規表示式分析器 也就是 grep ，是一種尋找檔案或文字模式的方法。可以當成一個有用的搜尋工具。\n格式：grep 要尋找的內容 輸入\n透過查看 man grep 以了解更多。\n刪除文字的行段 cut 指令可以從文字或檔案中提取欄位。例如：\ngrep /home /etc/passwd | cut -d':' -f6 -\n首先 grep 指令從 /etc/passwd 檔案獲取包含 /home 的行，然後傳入 cut 指令，cut 指令將這些行以 : 分割，然後取第六段 (-f6)。\n轉換或者刪除字元 tr 指令是一個基於字元的轉換器，可用於替換一個或一組字元，或者從文字行中刪除一個字元。\n1 2 3 4 5 6 7 8 9 # 轉換大寫為小寫 FOO=\u0026#34;AbcDEF\u0026#34; echo $FOO | tr [A-Z] [a-z] # 將該列表中檔名中空格轉換為下劃線 for file in *; do f=$(echo \u0026#34;$file\u0026#34; | tr [:blank:] [_]) [ \u0026#34;$file\u0026#34; = \u0026#34;$f\u0026#34; ] || mv -i -- \u0026#34;$file\u0026#34; \u0026#34;$f\u0026#34; done 串流編輯器 (Stream Editor) sed 指令是一個簡單的腳本編輯器，只能執行一些簡單的編輯，比如刪除文字符合特定模式的行，使用一種模式的字元替換另一種模式的字元等。\n過於複雜，請透過線上文件了解。\n7.1.6 使用簡單的 Shell 腳本 電話列表的例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #!/bin/bash # (@)/ph # A very simple telephone list # Type \u0026#34;ph new name number\u0026#34; to add to the list, or # just type \u0026#34;ph name\u0026#34; to get a phone number PHONELIST=~/.phonelist.txt # If no command line parameters ($#), there # is a problem, so ask what they\u0026#39;re talking about. if [ $# -lt 1 ]; then echo \u0026#34;Whose phone number did you want? \u0026#34; exit 1 fi # Did you want to add a new phone number? if [ \u0026#34;$1\u0026#34; = \u0026#34;new\u0026#34; ]; then shift echo $* \u0026gt;\u0026gt; $PHONELIST echo $* added to database exit 0 fi # Nope. But does the file have anything in it yet? # This might be our first time using it, after all. if [ ! -s $PHONELIST ]; then echo \u0026#34;No names in the phone list yet!\u0026#34; exit 1 else grep -i -q \u0026#34;$*\u0026#34; $PHONELIST # Quietly search the file if [ $? -ne 0 ]; then # Did we find anything? echo \u0026#34;Sorry, that name was not found in the phone list\u0026#34; exit 1 else grep -i \u0026#34;$*\u0026#34; $PHONELIST fi fi exit 0 7.2 小結 透過撰寫 Shell 腳本，可以自動完成許多最常見的系統管理任務。\n","date":"2022-12-05T20:47:43+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/81/","title":"Linux 學習 第七章 撰寫簡單的 Shell 腳本"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 前言 最近？拜讀了《漫畫數位電路》一書，在此簡要記錄。\n書中許多內容並未收錄於此。\n前情提要 數位電路分為 組合電路 與 時序電路。\n組合電路：由目前輸入資訊的組合決定輸出的電路。\n時序電路：帶有「記憶」的電路。\nMIL 符號 邏輯電路的 及閘 與 或閘 符號引申為多個輸入一個輸出。\n符號含義 及閘 (ALL)：多個輸入全為 1，輸出為 1。\n或閘 (EXIST)：若有一個輸入為 1，輸出為 1。\n電路線 有 圓圈 的為 低電位 (0、L)。\n無 圓圈 的為 高電位 (1、H)。\n組合電路的製作 多數決投票電路 多位投票人從兩個結果中選出一個。\n列出真值表，即所有可能發生的情況。\n在真值表 H 輸出處加上底線。\n「輸入線」與「將輸入取反的線」架設框架。\n兩條向下的電路線，第二條為反相線，即從第一條連接 反閘 到第二條。\n連接到 AND (及閘)\n輸入為 L 時，從將輸入取反處開始 (第二列)。\n輸入為 H 時，從最開始的地方畫線 (第一列)。\n然後，接入 AND。\n重複此過程，完成第二步所畫的所有線。\n將 AND 的所有輸出連接到 OR。\n電路的化簡 數位電路設計流程：釐清問題 - 真值表 - 化簡 - 繪製電路。\n透過 卡諾圖 進行化簡。\n真值表轉換為卡諾圖。\n製作真值表時，欄位從最高位元開始，例如 [C、B、A]，結果為 Z。\n卡諾圖是二維的真值表，通常用 0 與 1 表示電位。\n如果三個輸入，可以將行設為 B、A，列設為 C，然後將結果填入二維表。\n化簡前須知\n卡諾圖的 左右 與 上下 都是相連的，因為卡諾圖的橫向與縱向都是按 位元 (1 位) 變化的。\n化簡\n將相鄰的 1 劃分為一個集合。\n尋找行與列的共同點。\n若共同點為某值為 0，則使用 負運算 (或反運算)，即字母上方加一橫槓。\n範例\nC\\BA 00 01 11 10 0 1 1 1 上表中 共同點為 C 為 0，A 為 1，則運算式為 !C * A。 化簡的規則 集合的形狀只能是長、寬為 1、2、4 的矩形 (或正方形)。\n集合可以相互重疊。\n集合的個數越少，面積越大越好。\n註：左右和上下可以構成一個集合；如果無法進一步「形成集合」，則表示電路已無法再化簡。\n化簡後繪製電路圖，只需將所有運算式依照上一步驟的繪圖步驟 (從第三步開始) 進行即可。\n電路的忽略 在剛開始確定輸入時，因為二進位數的特性，可能會有一些不需考慮的輸入。\n例如輸入為月份，需要使用四位二進位數，總共有 16 個輸入，其中 0、13、14、15 均為不需考慮的輸入。\n這類輸入在卡諾圖中可以使用 - 代替，可以納入集合進行化簡。\n時序電路的製作 時序電路需要 組合電路 與 觸發器。\n關於 時序電路 的「記憶」，例如自動販賣機在投幣時會記錄目前投幣總數，若無記憶，則僅有最後一個硬幣的面額。\n引入一個觸發器，例如 時脈 (CLK)，僅在 CLK 觸發時，輸入才會對輸出有影響，否則輸出保持不變。\n以繪製電子骰子為例。\n繪製狀態轉移圖\n隨著時間的變化，電子骰子如何變化？\n若停止為低電位，從 1 開始到 6 再到 1。\n如果為高電位，則在某點一直保持停止。\n用二進位數來表示狀態\n將每種情況或者說狀態使用二進位表示，然後繪製出 狀態轉移表。\n透過狀態轉移表繪製電路，可以使用 D 觸發器儲存狀態。\n設計組合電路\n從 目前的狀態 決定 下一個狀態，實際上就是 組合電路。\n","date":"2022-12-04T16:54:29+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/80/","title":"歐姆社漫畫數位電路讀後"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 第六章 管理執行中的處理程序 Linux 是一種多使用者的作業系統，也是一種多工系統。多工意味著可以同時執行多個程式，執行程式的實例通常被稱為處理程序 (process)。\n可透過 shell 啟動、暫停、停止或刪除處理程序，還可將處理程序放到背景以及帶到前景。\n6.1 理解處理程序 處理程序是指令的執行實例。系統中的處理程序透過一個處理程序 ID (PID) 進行識別，PID 相對於當前系統是唯一的。除了 PID 號之外，處理程序還與一個特定的使用者帳號和群組帳號相關聯，有助於確定該處理程序可以存取哪些系統資源。\n用來顯示處理程序相關資訊的指令主要從 /proc 檔案系統中儲存的原始數據獲取資訊。每個處理程序都在 /proc 的一個子目錄 (以該處理程序的 PID 命名) 中儲存了自己的資訊。\n6.2 列出處理程序 使用 ps 指令或者 top 指令，其中 top 指令提供了一種更面向螢幕的方式列出處理程序。\n6.2.1 使用 ps 指令列出處理程序 使用 ps u 可顯示使用者名稱以及其他資訊。\nVSZ：虛擬記憶體大小 (Virtual Set Size) 顯示了映像處理程序的大小 (單位：KB)。\nRSS：(Resident Set Size) 顯示了記憶體中程式的大小。\nVSZ 是分配給處理程序的記憶體數量，RSS 是處理程序實際使用的記憶體數量 (表明了不能被交換的實體記憶體)。\nSTAT 欄：S 表示一個當前執行的處理程序，R 表示一個睡眠處理程序，+ 表示處理程序與前景操作相關聯。\n查看當前使用者所有處理程序：ps ux | less\n查看所有使用者處理程序：ps aux | less\n也可以自訂輸出欄位，並且根據某一欄排序，例如：\n1 ps -eo pid,user,uid,group,gid,vsz,rss,comm --sort=-vsz | less -e 為顯示每一個執行中的處理程序，-o 後為顯示的欄位，其中 comm 為指令，然後 --sort=-vsz 以 vsz 欄位從大到小排序。\n6.2.2 使用 top 指令列出和更改處理程序 使用 top 指令，預設按處理程序當前所使用的 CPU 百分比排序來顯示處理程序。\ntop 指令可以完成的操作：\n指令 描述 h 說明 M 按記憶體使用情況排序 1 切換顯示所有 CPU 使用情況 (系統有多個 CPU) R 反向排序 u 然後輸入使用者名稱可以顯示某使用者的處理程序 r 改變處理程序優先權 (nice 值) k 刪除處理程序 (kill 指令) 6.2.3 使用 System Monitor 列出處理程序 GNOME 桌面的 GUI 工具。\n6.3 管理背景和前景處理程序 對於沒有 GUI 的系統，只能使用 shell 完成所有操作。雖然 Bash shell 沒有包含一個 GUI 來管理多個程式，但可以在背景和前景直接移動活動程式，這樣就可以執行很多程式並選擇目前想要處理的程式。\n6.3.1 啟動背景處理程序 將指令放入背景：\n在指令後添加一個 \u0026amp;\n使用 at 指令執行其他指令\n對於執行中的處理程序使用 Ctrl+Z 停止，再輸入 fg 帶回前景或 bg 開始在背景執行\n為避免背景輸出干擾前景操作，可將其導向到空裝置 2\u0026gt;/dev/null\n可透過 jobs 指令查看背景執行的指令 (使用 -l 可查看 PID)。在工作序號前 + 表示最近放到背景的工作，- 表示在最近放的背景工作之前放到背景的工作。\n6.3.2 使用前景和背景指令 如果想引用一個背景工作，透過 % 和工作編號 (jobs 指令的輸出)，此外還有如下方式：\n% \u0026mdash; 引用最近放入背景的 (即編號後帶有 + 的)\n%string \u0026mdash; 以 string 開頭的工作 (必須明確，即比對結果唯一)\n%?string \u0026mdash; 指令列任意位置包含 string (同樣必須明確，即比對結果唯一)\n%-- \u0026mdash; 引用在最近放的背景工作之前放到背景的工作 (即編號後帶有 - 的)\n使用 fg %1 以將編號為 1 的工作帶到前景，使用 bg %5 以將停止的編號為 5 的指令在背景繼續執行。\n對於 vi 指令放到背景前會自動停止，記得先儲存檔案再放入背景以防忘記。\n6.4 終止和改變處理程序 可以向處理程序發送不同的訊號來更改其行為，也可以更改處理程序的處理器優先權。\n6.4.1 使用 kill 和 killall 指令終止處理程序 雖然這兩個指令常用於終止一個執行中的處理程序，但實際上是向處理程序發送一些有效訊號。訊號透過數字或名稱來表示。\n訊號 數字 描述 SIGHUP 1 重新讀取設定檔 SIGINT 2 透過鍵盤中斷 SIGQUIT 3 透過鍵盤結束 SIGABRT 6 呼叫 abort(3) 產生的中止訊號 SIGKILL 9 強制刪除訊號 SIGTERM 15 終止訊號 SIGCONT 19，18，25 繼續被停止的處理程序 SIGSTOP 17，19，23 停止處理程序 對於最後兩個訊號，第一個值適用於 Alpha 和 SPARC，中間的值適用於 x86，最後一個值適用於 MIPS 體系結構。\n預設為 SIGTERM (15) 訊號。雖然不同處理程序可以對不同訊號予以回應，然而任何處理程序都不能阻止 SIGKILL (9) 和 SIGSTOP 訊號。\n使用 kill 指令並根據 PID 向處理程序發送資訊 1 kill [訊號] [PID] 例如刪除處理程序 ID 為 2333 的處理程序：kill -9 2333 或者 kill -SIGKILL 2333\n使用 killall 指令並根據名稱向處理程序發送訊號 與 kill 指令類似，當要刪除許多同名指令時很有用，但要防止改變有用的同名處理程序。\n例如重啟 gnome-shell：killall -1 gnome-shell\n6.4.2 使用 nice 和 renice 指令設置處理器優先權 當 Linux 核心嘗試決定哪些執行中的處理程序可以存取 CPU 時，其中一個需要考慮的因素就是處理程序上的 nice 值，範圍 -20~19，預設為 0。\nnice 值越低，優先權越高，只有 root 使用者可以設置負值並將優先權調高 (值調低)，一般使用者只能調低優先權 (值調高)。\n可以使用 nice 指令執行一個帶有特定 nice 值的指令，也可以使用 renice 指令和 PID 更改已執行處理程序的 nice 值，例如：\nnice -n +5 updatedb \u0026amp; 在背景以 5 的優先權執行 updatedb 指令\nrenice -n 3 2333 將 PID 為 2333 的處理程序的 nice 值改為 3\n6.5 使用 cgroups 限制處理程序 為一個處理程序所設置的 nice 值不能套用於子處理程序，也就是說，nice 無法對特定使用者或應用程式可以使用的 Linux 系統資源總量進行限制。\n可以使用 cgroups 指令將一個處理程序確定為一個任務 (task)，並從屬於一個特定的控制群組。可以在一個層次結構中設置任務，其中包含一個被稱為守護行程 (daemon) 的任務 (為所有背景伺服器處理程序設置了預設限制) 以及子任務，子任務設置像 httpd 或 vsftpd 上的特定限制。\n當一個任務啟動一個處理程序時，其子處理程序將繼承父處理程序限制設置，限制內容包括儲存、處理器排程、處理程序報告、CPU 分配、裝置存取、記憶體使用情況等。\n設置 cgroups 可能非常棘手，包括編輯設定檔建立 cgroups (/etc/cgconfig.conf) 或限制特定使用者或群組 (/etc/cgrules.conf)。可以使用 cgcreate 指令建立 cgroups，從而將這些群組添加到 /sys/fs/cgroup 層次結構中。如果設置不正確，系統可能無法啟動。\n","date":"2022-12-03T15:07:03+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/79/","title":"Linux 學習 第六章 管理執行中的處理程序"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 第五章 使用文字檔案 Linux 的大多數設定透過編輯純文字檔完成。無論是修改 /etc 目錄的檔案設定在地服務，還是編輯 Ansible 目錄檔案設定主機的集合，純文字檔仍然在這些任務中普遍使用。\n5.1 使用 vim 和 vi 編輯檔案 vim 是 vi 的改良版本，兩者使用方式差不多，但 vim 會有引導和語法突顯（程式碼高亮）等功能，建議使用 vim。\n事實上，在部分 Linux 發行版中，vi 是使用別名 vim 來執行的，即輸入 alias vi 輸出為 alias vi = 'vim' ，但 root 使用者一般不設定別名。\n不過在 Linux 還有其他文字編輯器，例如 nano、gedit、jed、joe、kate、kedit、mcedit、nedit 等，其中純文字的有 jed 和 joe。\n5.1.1 開始使用 vi vi 有三個模式，主要兩種為 指令模式 和 輸入模式 ，還有 ex 模式。預設進入檔案為指令模式 (使用 vi file 指令進入後)。\n指令模式意味著在更改文字前需要先輸入一條指令 (一兩個字母，有時還需要選用的數字參數) ，告訴 vi 您想做什麼。\n注意：指令的大小寫敏感。\n新增文字 如果要進入 輸入模式 ，可以輸入一個 輸入 指令字母。\n指令 描述 a 新增指令。在游標右側輸入文字 A 在行尾新增。從目前行末尾開始輸入文字 i 插入指令。在游標左側輸入文字 I 在行首插入。從目前行開頭開始輸入文字 o 在下方開啟。在目前行之下開啟一個新行，並進入插入模式 O 在上方開啟。在目前行之上插入一個新行，並進入插入模式 進入插入模式後，在螢幕底部會出現 --INSERT--。\n完成文字輸入後，按 Esc 鍵返回指令模式 (有時需要按兩次 (反正按 Esc 就對了)。\n在文字中移動 僅移動一個字元使用以下按鍵：\n按鍵 描述 方向鍵 上下左右 h, j, k, l 左，下，上，右 Backspace, Space 左，右 移動多個字元的指令：\n指令 描述 w 將游標移動到下一個單字的開頭 (用空白、Tab 或標點符號分隔) W 將游標移動到下一個單字的開頭 (用空白或 Tab 分隔) b 將游標移動到前一個單字的開頭 (用空白、Tab 或標點符號分隔) B 將游標移動到前一個單字的開頭 (用空白或 Tab 分隔) 0 (零) 將游標移到目前行的開頭 $ 將游標移到目前行的末尾 H 將游標移到螢幕左上角 (螢幕上第一行) M 將游標移到螢幕中間行的第一個字元 L 將游標移到螢幕的左下角 (螢幕上的最後一行) 刪除、複製和更改文字 這些指令可以配合移動鍵 (方向鍵、PgUp、PgDn、字母和特殊鍵) 和數字來確切指出刪除、複製或更改什麼。\n指令 描述 x 刪除游標下的字元 X 直接刪除游標之前的字元 d\u003c?\u003e 刪除一些文字 c\u003c?\u003e 更改一些文字 y\u003c?\u003e 複製一些文字 上表每個指令後的 \u0026lt;?\u0026gt; 代表了可使用移動指令的位置，例如：\ndw \u0026mdash; 刪除目前游標之後的一個單字 db \u0026mdash; 刪除目前游標之前的一個單字 dd \u0026mdash; 刪除整個目前行 c$ \u0026mdash; 更改目前字元開始到目前行末尾的字元並進入輸入模式 (事實上就是刪除後輸入) c0 \u0026mdash; 更改從前一字元開始到目前行開頭的字元並進入輸入模式 (事實上就是刪除後輸入) cl \u0026mdash; 刪除目前字元並進入輸入模式 cc \u0026mdash; 刪除目前行並進入輸入模式 yy \u0026mdash; 將目前行複製到緩衝區 y) \u0026mdash; 將游標右邊的句子複製到緩衝區 y} \u0026mdash; 將游標右邊的段落複製到緩衝區 也可以使用數字對上述指令進行修改，例如：\n3dd \u0026mdash; 從目前行開始，刪除 3 行 3dw \u0026mdash; 刪除接下來的 3 個單字 5cl \u0026mdash; 更改接下來 5 個字元 (也就是刪除後進入輸入模式) 12j \u0026mdash; 向下移動 12 行 5cw \u0026mdash; 刪除接下來 5 個單字並進入輸入模式 4y) \u0026mdash; 複製接下來的 4 個句子 貼上 (放置) 文字 將最新儲存到緩衝區的文字放到檔案中。\n指令 描述 P 放到游標左邊，若為一行，則放到上一行 p 放到游標右邊，若為一行，則放到下一行 重複指令 在刪除、更改或貼上文字後，透過 . 以重複行為。例如替換文字 Joe 為 Jim (cw) 後查找下一處按 . 以重複更改。\n退出 vi 在指令模式下直接使用 ZZ 儲存後退出，也可按 : 進入 ex 模式。\n指令 描述 :w 儲存目前檔案，不退出 :wq 儲存並退出，與 ZZ 相同 :q 退出，但僅在未更改時生效 :q! 強制退出，不儲存更改 其他指令 u \u0026mdash; 復原更改 Ctrl+R \u0026mdash; 重做 (Redo) ，也就是復原先前的復原操作 :!command \u0026ndash; 在 :! 後跟一個 shell 指令，可直接執行，例如 :!date 查看目前日期。甚至可以透過 :!bash 以啟動一個新 shell，但建議進入前先儲存，以防忘記返回 vi Ctrl+g \u0026mdash; 顯示正在編輯的檔名，底部還有目前所在行、檔案總行數、內容百分比以及游標所在列號 5.1.2 在檔案中跳轉 如果檔案較長，用此方法移動更好：\n指令 描述 Ctrl+f 向前翻頁，一次一頁 Ctrl+b 向後翻頁，一次一頁 Ctrl+d 向前翻半頁 Ctrl+u 向後翻半頁 G 轉到檔案最後一行 nG 轉到檔案第 n 行 (用數字替換 n) 5.1.3 搜尋文字 透過 / 與 ? 向前或向後搜尋文字，還可以使用元字元，例如：\n/hello* \u0026mdash; 向前搜尋 hello 開頭的行 ?[pP]rint \u0026mdash; 向後搜尋單字 print 或 Print 在輸入搜尋後透過 n 或 N 可以在相同或相反方向繼續搜尋。\n5.1.4 使用 ex 模式 vi 編輯器最初基於 ex 編輯器，因此無法在全螢幕模式下工作，但可以在 ex 模式下使用指令找到並更改一行或多行的文字，例如：\n在指令模式下使用 : 進入 ex 模式：\n:g/Local \u0026mdash; 搜尋單字 Local，並列印相關行，如果輸出結果滿屏將發送到 more 指令 :s/Local/Remote \u0026mdash; 將目前行首次出現的單字 Local 替換為 Remote :g/Local/s//Remote \u0026mdash; 檔案每一行首次出現的 Local 替換為 Remote :g/Local/s//Remote/g \u0026mdash; 檔案所有 Local 替換為 Remote :g/Local/s//Remote/gp \u0026mdash; 檔案所有 Local 替換為 Remote，並列印每一行 5.1.5 了解更多 使用 vimtutor 將在 vim 編輯器中開啟一個教學課程。\n5.2 查找檔案 為幫助找到系統中的檔案，可使用一些指令：\nlocate \u0026mdash; 根據名稱查找檔案 find \u0026mdash; 根據不同的屬性查找檔案 grep \u0026mdash; 在文字檔案內部搜尋包含所搜尋文字的行 5.2.1 使用 locate 指令根據名稱查找檔案 大多數 Linux 系統每天會執行一次 updatedb 指令，收集 Linux 系統中的檔名並存入資料庫，使用 locate 指令可從該資料庫中搜尋檔案位置。可透過 sudo updatedb 指令更新資料庫。僅可透過 locate 指令查看允許使用者存取的檔案。\nlocate [str] ，或者使用 locate -i [str] 以忽略大小寫。例如搜尋包含 yexca 的目錄並忽略 yexca 的大小寫：locate -i yexca\n註：並不是所有的檔案都在資料庫中，/etc/updated.conf 檔案內容限制了被收集的檔案。\n5.2.2 使用 find 指令搜尋檔案 find 指令是在檔案系統中搜尋檔案的最佳指令，可以基於不同屬性 (元資料) 查找，並且可以在找到檔案後進行處理。\n註：檔案元資料包括擁有者、群組、時間戳記、檔案大小、權限以及儲存在檔案 inode 中的其他資訊。\nfind 與 locate 的區別\n使用 find 查找將搜尋整個檔案系統，所以速度會比 locate 慢許多，但可以即時查看系統中的檔案 (對於 locate 指令，如果檔案太新未收錄到資料庫將無法被找到)。當然，使用 find 時要設定搜尋起始點以限制搜尋範圍，從而提高速度。\nfind 指令有一個特殊的選項 -ls ，可以列出搜尋到檔案的詳細資訊，類似 ls -l 指令的輸出。\n註：對於一般使用者搜尋檔案因權限問題會有許多錯誤，可將錯誤輸出定向到 /dev/null 以忽略，即在指令末尾添加 2\u0026gt;/dev/null。\n根據檔名查找檔案 使用 -name 和 -iname (忽略大小寫) 以輸入想要搜尋的檔名，也可使用萬用字元 (* 和 ?)，例如：\n1 find /etc -iname \u0026#39;*passwd*\u0026#39; 在 /etc 目錄下搜尋包含 passwd 單字並忽略大小寫的檔案 (如不指定目錄 (/etc) 將搜尋目前資料夾)。\n可使用 -type 選項以指定輸出僅檔案 (-type f) 或僅目錄 (-type d)。\n根據檔案大小查找檔案 透過 -size 選項和以 + 或 - 開頭的數字查找相應範圍，例如 find /etc -size +10M 查找 /etc 目錄下大於 10MB 的檔案。\n1 find /bigdata -size +500M -size -5G -exec du -sh {} \\ 查找 /bigdata 目錄下 500MB ~ 5GB 之間的檔案，並針對每個檔案執行 du 指令以查看檔案大小。\n根據使用者查找檔案 透過 -user 或 -group 以針對特定使用者或群組查找，還可使用 -not 和 -or。\n1 find /home \\( -user yexca -or -user lemon \\) -ls 查找 /home 目錄下 yexca 和 lemon 所擁有的檔案。\n根據權限查找檔案 使用 -perm 選項，根據數字或字母找到檔案。如果數字前使用 - ，則三位都要匹配；如果使用 + ，任一數字匹配即可；若不加符號，那麼所有數字必須完整、精確匹配。\n如果 find -perm /002 則將找到對 \u0026ldquo;其他人\u0026rdquo; 啟用了寫入權限的檔案，而不用管其他權限位元如何設定。\n根據日期和時間查找檔案 time 選項 (-atime、-ctime 和 -mtime) 能基於自檔案被存取、更改或者檔案的元資料被更改以來所經歷的天數進行搜尋。而 min 選項 (-amin、-cmin 和 -mmin) 則是基於所經歷的分鐘數。\n在上述兩個選項的參數前加 - 表示從目前時間到所查詢的時間單位前的時間，+ 表示所查詢時間單位之前以及更久的時間，如果省略，則完全匹配。\n查看 10 分鐘內被更改的內容： 1 find /etc -mmin -10 查看三天內權限更改： 1 find /bin /usr/bin -ctime -3 查看 300 多天未被存取的檔案： 1 find /var/www -atime +300 在查找檔案時使用 \u0026rsquo;not\u0026rsquo; 和 \u0026lsquo;or\u0026rsquo; 透過使用 -not 或 -or 選項可以更精確地搜尋。\n查找被 yexca 所有但不屬於 yexca 群組的檔案： 1 find /home -user yexca -not -group yexca -ls 被 yexca 所有且大於 1GB 的檔案： 1 find /home -user yexca -and -size +1G -ls 查找檔案和執行指令 透過使用 -exec 選項，可以在每一個找到的檔案執行指令而不必確認，或使用 -ok 以確認是否執行該指令。兩者語法相同：\n1 2 find [options] -exec command {} \\; find [options] -ok command {} \\; 其中 {} 表示被找到的檔名，可多次使用。在指令末尾需要使用 \\; 。例如：\n1 find /etc -iname passwd -exec echo \u0026#34;I found {}\u0026#34; \\; 查找名為 passwd 的檔案並在 echo 的輸出中包含該名稱。\n註：若想了解更多，請使用 man find 指令。\n5.2.3 使用 grep 指令在檔案中搜尋 使用 grep 指令可以搜尋包含某一文字 (搜尋內容) 的檔案。搜尋時，可以把包含文字的所有行印出，或只列印相關檔案。grep 還可以搜尋標準輸出。\n選項 描述 -i 忽略大小寫 -v 搜尋不包含指定文字的行 -r 遞迴搜尋某目錄的檔案 -l 僅顯示檔名 \u0026ndash;color 醒目提示搜尋文字 (預設為紅色) 在 /etc/sysconfig 目錄遞迴搜尋文字 root： 1 grep -ri --color root /etc/sysconfig/ 從標準輸出中搜尋包含 inet 的行： 1 ip addr show | grep inet ","date":"2022-11-19T21:07:03+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/78/","title":"Linux 學習 第五章 使用文字檔案"},{"content":" 📢 本文由 gemini-2.5-flash-lite 翻譯 使用 Windows11 部署，其他系統 (如 Linux ) 請參考： AUTOMATIC1111/stable-diffusion-webui: Stable Diffusion web UI 空間佔用 程式：5.3GiB (不含模型)\n運行：5.5GiB 以上\n請確保 C 碟空間至少 6GiB 再運行，否則電腦可能黑屏卡死\n環境 首先是網路環境，請確保連接上網際網路\nGit\n官網： https://git-scm.com/ Python 3.10.6 以上 (最新版本可能不穩定)\n建議 3.10.8： https://www.python.org/downloads/release/python-3108/ 勾選 Add python.exe to PATH\n模型下載\n官方模型 (偏寫實)\n透過磁力下載（請使用正規種子客戶端）\n1 magnet:?xt=urn:btih:3a4a612d75ed088ea542acac52f9f45987488d1c\u0026amp;dn=sd-v1-4.ckpt\u0026amp;tr=udp%3a%2f%2ftracker.openbittorrent.com%3a6969%2fannounce\u0026amp;tr=udp%3a%2f%2ftracker.opentrackr.org%3a1337 其他下載方式\n訪問 AUTOMATIC1111/stable-diffusion-webui Wiki Waifu 模型(二次元啦)\n訪問 hakurei/waifu-diffusion-v1-3 at main 選擇下載\n其他\nStable Diffusion Models (cyberes.github.io) 克隆倉庫 選擇一個合適的位置，右鍵選擇 在終端機中開啟 ，然後輸入以下指令\n1 git clone https://github.com/AUTOMATIC1111/stable-diffusion-webui.git 更新時可以進入該目錄 (stable-diffusion-webui) 後使用 git pull 指令\n設定 將下載的模型放入 /models/Stable-diffusion 目錄\n設定 /webui-user.bat 檔案 在set VENV_DIR= 後任意輸入字串，然後儲存退出\n運行 /webui-user.bat 檔案\n下載檔案過大 (6GiB 左右) ，可能會運行較長時間，期間無進度條提示（若感覺程式終止之類的，可透過網路頻寬使用情況以判斷是否正在下載）\n如果您的顯示卡是 GTX1660 或者算出來的圖是黑色的\n編輯 webui.bat ，在開頭加入以下文字\n1 set COMMANDLINE_ARGS=--precision full --no-half 其他 詳細了解： hua1995116/awesome-ai-painting: AI绘画资料合集（包含国内外可使用平台、使用教程、参数教程、部署教程、业界新闻等等） stable diffusion tutorial、disco diffusion tutorial、 AI Platform 訓練模型： NovelAI hypernetwork 自訓練教程 - 知乎 NovelAI軟體獲取 - novelai 資源站 咩小咩壁紙|NovelAI資源站 關鍵字例子\n1 2 NSFW, Prhololive, uruha_rushia, 1girl, bangs, bare shoulders, red eyes, blue dress, blue green hair, blue sleeves, blush, bow, breasts, chick, collarbone, detached collar, detached sleeves, double bun, eyebrows visible through hair, frills, hair orhament, medium hair, off-shoulder dress 參考文章 最火的AI绘画教程！免费开源，包教会 - 零度解说 【心得】(NSFW) AI 色圖製作體驗 + 關鍵字 @場外休憩區 哈啦板 - 巴哈姆特 ","date":"2022-10-30T16:23:07+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/77/","title":"NovelAI 繪圖 (WebUI)"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 引言 使用虛擬機安裝，軟體為 Fedora 的 盒子\n安裝前準備 下載映像檔 從 官方下載頁面 下載，推薦使用 BT 下載 (請使用正規 torrent 客戶端，例如 qBittorrent )\n然後放到虛擬機裡\n驗證開機模式 列出 efivars 目錄\n1 ls /sys/firmware/efi/efivars 如果正確顯示目錄並且沒有回報錯誤，則系統以 UEFI 模式開機，如果目錄不存在，則可能以 BIOS 模式開機 (或 CSM 模式)\n這個虛擬機中使用 BIOS 模式\n連接到網際網路 預設開啟網路介面與 DHCP 服務，無需設定\n更新系統時間 開啟與網路時間伺服器 (NTP) 同步\n1 timedatectl set-ntp true 可使用 timedatectl status 檢查服務狀態\n建立硬碟分割 使用了傳統的 fdisk 指令分割 (MBR 分割)，因為開機模式是 BIOS，採用官方的分割範例，只做了兩個分割區 (swap 交換分割區與其他)\n使用 fdisk -l 列出所有磁碟 (以 rom、loop 或 airoot 結尾的裝置可以忽略)\n使用 fdisk /dev/裝置名 開始分割\n指令 描述 n 建立分割區 p 檢查分割區 t 變更分割區類型 w 儲存變更 指定分割區大小使用 ++num+K/M/G/T/P ，若無後綴 (K/M/G/T/P) 則分配磁區\n格式化分割區 建立交換分割區 1 mkswap /dev/交換空間分割區 建立檔案系統 根據檔案系統不同指令不同，例如 ext4 檔案系統\n1 mkfs -t ext4 /dev/分割區 掛載分割區 將根分割區掛載到 /mnt，若有多個分割區，請務必先掛載根分割區\n1 mount /dev/分割區 /mnt 啟用交換空間\n1 swapon /dev/交換空間分割區 安裝 選擇映像檔 檔案 /etc/pacman.d/mirrorlist 定義了套件從何處下載，在連接到網際網路後會自動更新，也可手動更改，我就不更改了\n安裝套件 使用 pacstrap 腳本，安裝 base 套件和 Linux 核心以及 vim，如果安裝其他套件，在下方指令後加上名稱即可，當然也可以之後使用 pacman 安裝\n1 pacstrap /mnt base linux vim 設定系統 Fstab /etc/fstab 檔案描述系統啟動時如何自動掛載分割區，可以使用以下指令自動產生 (使用 -U 或 -L 選項設定 UUID 或磁碟區標籤，使用 UUID 以確保系統開機不會出錯)\n1 genfstab -U /mnt \u0026gt;\u0026gt; /mnt/etc/fstab 檢查自動設定是否正確\n1 cat /mnt/etc/fstab Chroot Chroot 至新安裝的系統\n1 arch-chroot /mnt 時區 以上海時間為例\n1 ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime 產生 /etc/adjtime\n1 hwclock --systohc 此時可使用指令 date 查看時間是否正確\n本土化 編輯 /etc/locale.gen ，取消 en_GB.UTF-8 的註解\n然後產生 locale 資訊\n1 locale-gen 建立 /etc/locale.conf 檔案，編輯 LANG 變數，例如 LANG=en_GB.UTF-8\n網路設定 建立 /etc/hostname 檔案並輸入主機名稱\n因為虛擬機使用 DHCP，就不 設定網路 了\nRoot 密碼 1 passwd 安裝開機載入程式 一般安裝 GRUB，我使用的虛擬機是 BIOS+MBR，安裝 grub 套件\n1 pacman -S grub 安裝 grub (下方指令 /dev/裝置，請注意不是分割區)\n1 grub-install --target=i386-pc /dev/裝置 產生設定檔\n1 grub-mkconfig -o /boot/grub/grub.cfg 重新啟動 使用 exit 或 Ctrl+D 離開 chroot 環境\n使用 umount -R /mnt 卸載被掛載的分割區\n重新啟動 reboot\n參考資料 Installation guide (繁體中文) - ArchWiki ","date":"2022-10-02T13:39:26+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/76/","title":"虛擬機中 Arch Linux 安裝紀錄"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 第四章 在檔案系統中移動 Linux 檔案系統儲存了電腦上所有的資訊\n目錄 描述 /bin 包含常見的 Linux 使用者指令，例如 ls、sort、date 和 chmod /boot 包含可開機的 Linux 核心、初始 RAM 磁碟和開機載入程式的設定檔 (GRUB) /dev 包含用來表示系統中裝置存取點的檔案。這些裝置包括終端裝置 (tty*) 、硬碟驅動器 (hd* 或 sd*) 、RAM (ram*) 以及 CD-ROM (cd*) 。使用者可以直接透過這些裝置檔案存取相應的裝置；然而，應用程式通常會對終端使用者隱藏實際的裝置名稱 /etc 包含管理設定檔。其中大多數檔案都是純文字檔案，只要使用者擁有適當權限，就可以使用任何文字編輯器編輯這些設定檔 /home 包含分配給每個帶有登入帳號的一般使用者的目錄 (root 使用者是一個例外，使用 /root 作為家目錄) /media 為自動掛載裝置 (特別是行動媒體) 提供了一個標準位置。如果媒體有一個磁碟標籤，那麼通常會使用該標籤名稱作為掛載點 /lib 包含 /bin 和 /sbin 目錄中的應用程式啟動系統所需的共享函式庫 /mnt 在該目錄被標準的 /media 目錄取代之前，/mnt 目錄是許多裝置常見的掛載點。一些可開機的 Linux 系統仍使用該目錄來掛載硬碟分割區和遠端檔案系統。此外很多人也在使用該目錄臨時掛載那些不需要永久掛載的本機或遠端檔案系統 /misc 該目錄有時用來根據請求自動掛載檔案系統 /opt 用來儲存附加應用程式軟體的目錄結構 /proc 包含關於系統資源的資訊 /root 表示 root 使用者的家目錄。因安全原因，沒有位於 /home /sbin 包含管理指令和守護行程 (daemons) /sys 包含用於調校區塊儲存和管理 cgroups 的參數 /tmp 包含應用程式使用的暫存檔案 /usr 包含使用者文件、遊戲、圖形檔案 (X11) 、函式庫 (lib) 以及其他不需要在啟動過程中使用的指令和檔案。/usr 目錄中的檔案在安裝完畢後不可更改。理論上來說，/usr 可以採用唯讀方式掛載 /var 包含不同應用程式所使用的資料目錄。特別可以在該目錄中放置作為 FTP 伺服器 (/var/ftp) 或 Web 伺服器 (/var/www) 共享的檔案。還包含所有的系統日誌檔案 (/var/log) 以及緩衝檔案 (/var/spool，如 mail、cups 和 news) 。/var 目錄所包含的目錄和檔案經常被修改。在伺服器電腦上，通常會建立一個 /var 目錄作為一個單獨的檔案系統，使用一個易於擴充的檔案系統 4.1 使用基本的檔案系統指令 cd 、pwd 、mkdir 、rmdir 、ls 、touch\n4.2 使用元字元和運算子 某些特殊字元被稱為元字元 (metacharacters) 或運算子 (operators)\n4.2.1 使用檔案比對元字元 元字元 描述 * 比對任何數量的字元 ? 比對任何一個字元 [\u0026hellip;] 比對括號之間的任一字元，可以包括一個連字號分隔的字母或數字範圍 例如 ls [a-g]* 列出以字母 a 到字母 g 開頭的檔案或目錄\n4.2.2 使用檔案重新導向元字元 元字元 描述 \u0026lt; 將檔案的內容導向到指令。指令的預設行為，可省略，例如使用 less bigfile 等同於 less \u0026lt; bigfile \u0026gt; 將指令的標準輸出導向到一個檔案。如果檔案存在將被覆寫 (覆蓋) 2\u0026gt; 將標準錯誤 (錯誤訊息) 導向到檔案 \u0026amp;\u0026gt; 將標準輸出和標準錯誤都導向到檔案 \u0026raquo; 將指令的輸出導向到一個檔案，並將該輸出添加到現有檔案的末尾 例如以下指令\n1 man chmod | col -b \u0026gt; /tmp/chmod 設定了手冊頁的格式 (使用 man 指令)，刪除了額外的退格鍵 (col -b) 並將輸出傳送到檔案 /tmp/chmod (如果檔案存在，則刪除之前的 /tmp/chmod 檔案)\n1 echo \u0026#34;Hello World!\u0026#34; \u0026gt;\u0026gt; ~/hello 將文字 Hello World! 添加到 ~/hello\n重新導向的另一種類型被稱為 here text (或者 here document) ，例如\n1 2 3 4 5 6 7 ed /etc/resolv.conf \u0026lt;\u0026lt; resendit a nameserver 100.100.100.100 . w q resendit 透過 ed 文字編輯器向 /etc/resolv.conf 檔案 (以 root 使用者執行的指令碼) 執行兩個 resendit 之間的內容 (範例為新增 DNS 伺服器的 IP 地址)\n4.2.3 使用括號擴充字元 透過使用大括號 {} 可以跨檔案名稱、目錄名稱或者指令中的其他參數擴充一組字元，例如\n1 touch memo{1,2,3,4,5} 將建立 memo1~memo5 共 5 個檔案\n1 touch {John,Bill,Sally}-{Breakfast,Lunch,Dinner} 將建立 9 個檔案\n1 touch {a..f}{1..5} 將建立 a1~f5 共 30 個檔案\n4.3 列出檔案和目錄 一般 ls 指令被設定別名為 ls --color=auto ，可透過下面指令查看別名\n1 alias ls 使用 ls -la 指令可以查看詳細資訊 (-l) 和所有檔案 (-a)\n欄位 檔案 目錄 1 權限 權限 2 連結到該項目的數量 連結到該項目的數量 3 檔案擁有者 目錄擁有者 4 檔案所屬群組 目錄所屬群組 5 檔案的位元組大小 包含該目錄資訊的檔案大小，非目錄包含檔案大小 6 最近一次修改的日期和時間 最近一次修改的日期和時間 7 檔案名稱 目錄名稱 註：\n時間和日期欄位的格式可以更改，根據 LANG 變數而定\n有時可執行檔權限為 s (-rwsr-sr-x) ，表示應用程式可被任何使用者存取，但執行行程的所有權為應用程式的使用者/群組，而不是啟動該指令的使用者\n如果目錄權限末尾是 t (drwxrwxr-t) ，則表示為該目錄設定了一個黏滯位 (sticky bit)。表明目錄的擁有者允許其他使用者添加檔案，但阻止刪除其他人添加的檔案\n透過為某一目錄分配一個 Set GID，該目錄中所建立的任何檔案都會被分配到與目錄群組相同的群組。如果在一個目錄上看到的是一個大寫 S 或 T 而不是執行位元，則意味著分別設定了 Set GID 或黏滯位，而由於某些原因執行位元沒有開啟\n如果權限末尾是加號 (-rw-rw-r-+) ，則說明在檔案上設定了擴充屬性，如 ACL 或 SELinux。末尾的點表示在檔案中設定了 SELinux\n透過 cd ~yexca 可存取 yexca 的家目錄，cd - 以返回之前的工作目錄 ($OLDPWD 指向的目錄) ，而 `cd .` 指向目前工作目錄 ($PWD)\nls 指令：-t 以最新修改時間順序顯示檔案；-F 在目錄後添加 / ，可執行檔後添加 * ，符號連結旁顯示 @；--hide=yexca 隱藏顯示 yexca 這個檔案或目錄；-S 按檔案大小列出檔案；-d 顯示該目錄的資訊而非目錄所包含的檔案和目錄\n4.4 了解檔案權限和所有權 對於 ls -l 指令第一欄\n第一位為檔案類型\n字母 類型 - 檔案 d 目錄 l 符號連結 b 區塊裝置 c 字元裝置 s Socket 套接字 p 具名管道 (Named pipe) 後九位為權限，前三位為使用者 (u) 的，中三位為所在群組 (g) 的，後三位為其他人 (o) 的\n對於檔案和目錄，權限位元含義略有不同\n權限 檔案 目錄 Read 檢視檔案內容 檢視目錄所包含的檔案和子目錄 Write 更改檔案內容，重新命名或刪除檔案 向目錄添加檔案或子目錄。刪除目錄中的檔案或子目錄 Execute 將檔案作為一個程式執行 將目錄更改為目前目錄，搜尋目錄或執行該目錄中一個程式，存取目錄中檔案的檔案中繼資料 (檔案大小、時間戳記等) 可透過 ls -ld 指令查看任何檔案或目錄的權限\n在 Fedora 和 Red Hat Enterprise Linux 中，當添加了一個新使用者時，預設情況下該使用者被分配到一個同名的群組中，這種分配群組的方法被稱為使用者專用群組方案\n4.4.1 使用指令 chmod (數字) 更改權限 r = 4；w = 2；x = 1\n1 chmod -R 755 ~/myfile 更改 ~/myfile 下所有檔案和目錄 (-R) 和該目錄的權限為 755 (rwxr-xr-x)\n4.4.2 使用 chmod (字母) 更改權限 1 chmod ug+rx files 1 chmod -R o-x ~/myfile 4.4.3 使用 umask 設定預設的檔案權限 一般使用者建立檔案預設權限為 rw-rw-r\u0026ndash;，目錄為 rwxrwxr-x。對於 root 使用者分別為 rw-r\u0026ndash;r\u0026ndash; 和 rwxr-xr-x。這些預設值由 umask 值確定，輸入該指令即可查看值，例如 0002\n若暫時忽略第一個 0 (前導零) ，那麼 umask 值被視為對檔案完全開放權限 (666) 或者對目錄完全開放權限 (777) 。umask 值 002 生成對目錄權限 775，檔案為 644。預設情況下一般檔案的執行權限被關閉\n如果臨時更改 umask 值，直接 umask [權限] ，將權限值替換 [權限] ，例如 umask 000 然後建立的檔案和目錄權限分別為 -rw-rw-rw- 和 drwxrwxrwx\n如果永久更改需要向家目錄 .bashrc 檔案結尾處添加一條 umask 指令\n4.4.4 更改檔案所有權 僅 root 使用者可更改檔案所有權\n1 chown user:group /etc/file 將 /etc/file 改為 user 所有和 group 群組，可使用 -R 遞迴更改\n或者只更改所屬使用者 chown yexca /etc/file\n4.5 移動、複製和刪除檔案 mv、cp、rm、rmdir\nmv 指令透過添加 -i 或設定別名防止移動時覆寫已有檔案，或使用 -b 則若有同名檔案會先備份舊檔案後移動新檔案\ncp 指令使用 -a 將保持原本的日期/時間戳記\n使用 -f 以強制套用更改 (例如 rm -rf /*)\n","date":"2022-09-25T20:35:02+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/75/","title":"Linux 學習 第四章 在檔案系統中移動"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 前言 這應該是最近最後一次的玩物了，不過在啟用許多外掛後，開機需要很久才會顯示桌面，之後我會停用一些不常用的。\n主題 透過 閱讀書籍 得知 GNOME 的主題網站 ，然後去逛了一下，打開第一個主題就深深地吸引了我。\n連結 主題： Fluent round gtk theme Github： vinceliuice/Fluent-gtk-theme: Fluent design gtk theme for linux desktops 安裝 透過 GitHub 的 README 得知透明版需要外掛 Blur Me ，但我當時看的時候，該外掛不適用我的 GNOME 版本 (寫文章時查看也沒適用了)。當時我沒有安裝透明版本，但我忘了怎麼就找到了一個支援的： Blur my Shell (這透明效果真的超美！！！)\n透過 Git 複製儲存庫 1 git clone https://github.com/vinceliuice/Fluent-gtk-theme.git 執行腳本 1 ./install.sh 可以新增選項來自訂，具體效果預覽還是參考 README 吧。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 -d, --dest DIR 指定目的目錄 (預設值: /usr/share/themes) -n, --name NAME 指定主題名稱 (預設值: Fluent) -t, --theme VARIANT 指定主題顏色變體 [default|purple|pink|red|orange|yellow|green|grey|all] (預設值: blue) -c, --color VARIANT 指定顏色變體 [standard|light|dark] (預設值: 所有變體) -s, --size VARIANT 指定尺寸變體 [standard|compact] (預設值: 所有變體) -i, --icon VARIANT 為 shell 面板指定圖示變體 [default|apple|simple|gnome|ubuntu|arch|manjaro|fedora|debian|void|opensuse|popos|mxlinux|zorin] (預設值: Windows 圖示) --tweaks 為調整指定版本 [solid|float|round|blur|noborder|square] solid: 無透明版本 float: 浮動面板 round: 圓角視窗 blur: 模糊效果版本，適用於 \u0026#39;Blur-Me\u0026#39; noborder: 無邊框視窗與選單 square: 方形視窗按鈕 -h, --help 顯示說明 圖示 主題有一個配套的圖示，這當然要裝上。\n連結 Github： vinceliuice/Fluent-icon-theme: Fluent icon theme for linux desktops 安裝 和主題差不多，先複製儲存庫。\n1 git clone https://github.com/vinceliuice/Fluent-icon-theme.git 然後執行腳本。\n1 ./install.sh 當然也可以透過選項來自訂，具體還是參考 README 吧。\nDock 欄 使用外掛： Dash to Dock for COSMIC 安裝主題時預覽的 Dock 欄不知道怎麼裝，但我找到了這個外掛，在設定裡調整一下也有透明效果。\n音樂播放器 Rhythmbox 內建的音樂播放器用起來還行，但是沒有單曲循環功能就有一點不方便。\nGithub： fossfreedom/alternative-toolbar: Modern, minimal and music-focused interface for Rhythmbox 安裝 安裝也挺簡單，以下是 Fedora 的安裝步驟。\n先到 Releases 下載壓縮檔，然後設定環境。\n1 sudo dnf install intltool git gnome-pkg-tools gobject-introspection glib2-devel pkg-config python3-gobject python3 然後解壓縮並進入目錄，依序執行以下指令。\n1 ./configure --prefix=/usr 1 make 1 sudo make install 解除安裝 到安裝資料夾執行指令。\n1 sudo make uninstall 桌面背景 想著能不能把 Wallpaper Engine 的影片作為桌面背景，於是就去搜尋了相關資料。\n影片桌面 這東西似乎不能在雙螢幕情況下自動調整螢幕，而且每次循環都會閃爍一下，所以棄用了。\n安裝環境 mplayer 首先啟用 rpmfusion 函式庫\n1 sudo dnf install https://download1.rpmfusion.org/free/fedora/rpmfusion-free-release-32.noarch.rpm 然後使用 dnf 安裝。\n1 sudo dnf install mplayer xwinwrap 這軟體只有 Ubuntu 的安裝檔，不過實際上直接解壓縮也可以執行這個程式。\n原始碼位置： Github deb 下載： xwinwrap_0.3.2git20171223_amd64.deb 提取檔案後複製到 /usr/local/bin，然後賦予執行權限即可。\n指令 如果是單螢幕\n1 xwinwrap -ni -o 1 -fdt -fs -s -st -sp -b -nf -- mplayer -framedrop -nosound -loop 0 -wid WID -quiet ~/Pictures/bg.mp4 如果是雙螢幕，以下指令會顯示在右邊的螢幕上。\n1 xwinwrap -g 1920x1080+1920+0 -fdt -ni -b -nf -- mplayer -framedrop -nosound -loop 0 -wid WID -quiet ~/Pictures/bg.mp4 具體指令選項可以 xwinwrap --help，或者參考 參考文章第二篇 的相關部分。\n定時自動更換桌布 雖然可以更換了，不過不僅要格式符合，還要手動命名，新增時還得修改檔案，有點麻煩，所以棄用了。\n建立桌布輪播範圍 例如建立 ~/.backgrounds/pic.xml，內容如下，請根據情況替換。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 \u0026lt;background\u0026gt; \u0026lt;starttime\u0026gt; \u0026lt;year\u0026gt;2022\u0026lt;/year\u0026gt; \u0026lt;month\u0026gt;9\u0026lt;/month\u0026gt; \u0026lt;day\u0026gt;17\u0026lt;/day\u0026gt; \u0026lt;hour\u0026gt;1\u0026lt;/hour\u0026gt; \u0026lt;minute\u0026gt;00\u0026lt;/minute\u0026gt; \u0026lt;second\u0026gt;00\u0026lt;/second\u0026gt; \u0026lt;/starttime\u0026gt; \u0026lt;static\u0026gt; \u0026lt;duration\u0026gt;4000.0\u0026lt;/duration\u0026gt; \u0026lt;file\u0026gt;~/.backgrounds/pic/00001.jpg\u0026lt;/file\u0026gt; \u0026lt;/static\u0026gt; \u0026lt;transition type=\u0026#34;overlay\u0026#34;\u0026gt; \u0026lt;duration\u0026gt;847.0\u0026lt;/duration\u0026gt; \u0026lt;from\u0026gt;~/.backgrounds/pic/00001.jpg\u0026lt;/from\u0026gt; \u0026lt;to\u0026gt;~/.backgrounds/pic/00050.jpg\u0026lt;/to\u0026gt; \u0026lt;/transition\u0026gt; \u0026lt;static\u0026gt; \u0026lt;duration\u0026gt;4000.0\u0026lt;/duration\u0026gt; \u0026lt;file\u0026gt;~/.backgrounds/pic/00050.jpg\u0026lt;/file\u0026gt; \u0026lt;/static\u0026gt; \u0026lt;/background\u0026gt; static 指定某一張桌布顯示的時間 (秒) 和檔案位置。\ntransition 指定輪播範圍以及過渡時間。\n建立設定檔 例如建立 ~/.backgrounds/pic-timed.xml\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE wallpapers SYSTEM \u0026#34;gnome-wp-list.dtd\u0026#34;\u0026gt; \u0026lt;!-- /usr/share/gnome-background-properties --\u0026gt;\u0026lt;wallpapers\u0026gt; \u0026lt;wallpaper deleted=\u0026#34;false\u0026#34;\u0026gt; \u0026lt;name\u0026gt;Default Background\u0026lt;/name\u0026gt; \u0026lt;filename\u0026gt;~/.backgrounds/pic.xml\u0026lt;/filename\u0026gt; \u0026lt;options\u0026gt;zoom\u0026lt;/options\u0026gt; \u0026lt;shade_type\u0026gt;solid\u0026lt;/shade_type\u0026gt; \u0026lt;pcolor\u0026gt;#3465a4\u0026lt;/pcolor\u0026gt; \u0026lt;scolor\u0026gt;#000000\u0026lt;/scolor\u0026gt; \u0026lt;/wallpaper\u0026gt; \u0026lt;/wallpapers\u0026gt; 然後將該檔案複製或連結到 /usr/share/gnome-background-properties/，就可以在 設定 - 背景 中看到了。\n或者嘗試重新啟動 GNOME ( alt+F2 後輸入 r )。\n轉換圖片格式 安裝 ImageMagick 後使用指令。\n1 convert before.jpg after.png 隨機更換桌布 很方便實用，除了每次都得手動執行 (不過或許可以建立成應用程式然後開機啟動吧)。\n建立腳本檔案 1 vi ran_wallpaper.sh 輸入以下內容，請注意修改相關路徑。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #!/bin/bash wallpaper_path=\u0026#34;~/wallpaper\u0026#34; # 桌布路徑 sleep_time=1 # 更換間隔 單位秒 find $wallpaper_path -name \u0026#39;*.*\u0026#39; | cat \u0026gt; /tmp/list # 取得圖片清單 img_range_max=`cat /tmp/list | wc -l` # 取得圖片數量，用於設定隨機範圍 while true do n=$((RANDOM%$img_range_max+1)) # 取得亂數 img_path=`awk NR==$n /tmp/list` # 取得該桌布的完整路徑 gsettings set org.gnome.desktop.background picture-uri file://$img_path # 更換桌布指令 sleep $sleep_time done 執行 賦予執行權限\n1 chmod +x ran_wallpaper.sh 在背景執行\n1 setsid ./ran_wallpaper.sh 警告 千萬不要把這個腳本放進初始化守護行程服務！！！\n關閉 尋找行程\n1 ps -ef |grep ran_wallpaper 第一欄：使用者名稱，第二欄：PID，第三欄：父行程 PID，最後一欄：指令名稱或路徑\n關閉行程\n1 sudo kill -9 PID 桌面圖示 其實我個人而言不是那麼需要，用 Windows 時桌面也幾乎乾乾淨淨的。\n顯示圖示 使用外掛： Gtk4 Desktop Icons NG (DING) 儘管這個外掛不支援在多螢幕上顯示圖示，但透明的背景我真的很喜歡。\n如果需要多螢幕支援，還是用這個外掛吧： Desktop Icons NG (DING) 不使用外掛的參考： Remove desktop support (#158) · Issues · GNOME / Files · GitLab 建立圖示 新建並寫入 .desktop 檔案，例如：\n1 2 3 4 5 6 7 8 [Desktop Entry] Name=Grey Hack # 顯示名稱 Comment=Play this game on Steam # 滑鼠指向的提示文字 (似乎沒什麼用) Exec=steam steam://rungameid/605230 # 可執行程式路徑 (在 Bash 下的啟動方式) Icon=steam_icon_605230 # 圖示的路徑/定義 Terminal=false # 是否在終端機執行 Type=Application # 應用程式類型 Categories=Game; # 分類 其他外掛 左上角 活動 變成圖示 Activities Icons 左上角顯示任務圖示 App Icons Taskbar 音量處顯示應用程式音量 Application Volume Mixer 剪貼簿紀錄 Clipman 左上角檔案系統 Files Menu 左上角應用程式清單 Frippery Applications Menu 自訂 GNOME Shell Just Perfection 右上角切換代理 Proxy Switcher 下拉應用程式 quake-mode 顯示桌面 Show Desktop Applet 切換音效卡 Sound Input \u0026amp; Output Device Chooser 托盤圖示 (Tray Icons) 放在右上角 Tray Icons: Reloaded 參考文章 Fedora 影片桌面 - 一個曾經的小碼農\u0026hellip; Video Livestream Wallpaper For Your GNOME, Xfce Or bspwm Desktop - Linux Uprising Blog 常用的 GNOME Shell 擴充功能 - pipci - 博客園 Linux 命令列處理圖片（圖片格式轉換、縮放、旋轉等）_打工人小飛的博客-CSDN博客 Linux 切換桌布, Linux 隨機更換桌布_毛社長的博客-CSDN博客 在 Linux 背景執行腳本指令和程式的方法大全_豆豆技術派的博客-CSDN博客 「GNOME 3」- 桌面圖示（顯示、Ubuntu 20.10、隱藏） - K4NZ BLOG Fedora: GNOME 建立桌面圖示，以 Eclipse 和 IDEA 為例 ","date":"2022-09-18T11:10:58+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/74/","title":"Fedora 桌面玩物"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 引言 人嘛，有了比較好的就會追求更好的，慾望無窮無盡。本想弄台 NAS，奈何經濟實力不夠，於是透過四個專案在自己電腦弄了入口、動畫、漫畫以及音聲庫，那麼\n承接 上回 ，繼續折騰\n成品展示 全部使用 Docker 部署，理論上應該只要 Docker 支援的平台就能復現\n調整了網域為 link.start.icu，本來沒有 .icu，但瀏覽器無法解析，只能加上 (不過莫名變更好了吧)\n手機訪問圖片顯示中間的 (有一點不太理想)\n有時間把這東西部署到伺服器上搞個導航吧 (不過標題不能直接改有點麻煩，不想弄 JS)\n註：使用 Docker Desktop 部署，所以就沒有寫部署過程了，可看 上回 的部署，過程差不多\n登入 Docker Hub 貌似安裝 Docker 後使用 docker pull 要先登入\n首先到官網註冊帳號： Docker Hub 然後需要先進行初始化，執行命令\n1 gpg --generate-key 輸入相關資訊後注意輸出的 pub 下一行的一串字串，複製並替換為下述命令的 [pub]\n1 pass init [pub] 然後在 Docker Desktop 登入\n動畫 - Jellyfin Docker Hub： jellyfin/jellyfin 官網： Jellyfin: The Free Software Media System 1 docker pull jellyfin/jellyfin 不過封面圖片方面不太理想，個人不是用 NAS，懶得弄了\n可參考： 利用 Jellyfin + Bangumi 打造更舒適的動畫媒體庫 - 初之音 漫畫 - Komga Docker Hub： gotson/komga 官網： Komga 1 docker pull gotson/komga 註：漫畫過多掃描時可能會導致電腦很卡\n音聲 - kikoeru-express Docker Hub： muveex/kikoeru-express Github： kikoeru-project/kikoeru-express 我下載的是 0.6.2 版本 (話說這東西和某網站很像嘛)\n1 docker pull muveex/kikoeru-express:v0.6.2 本來看到文章想用 PLEX 的，但必須登入使用搞得有點不想用了，但介面看起來很好看，忍了。裝完後發現要加自己的媒體庫居然還要安裝它的閉源軟體，這東西可以存取檔案系統幾乎所有檔案 (但存取不了我掛載的) ，解除安裝了，可能我弄 NAS 才會再次使用吧\n引導 - Heimdall Docker Hub： linuxserver/heimdall/ 官網： Heimdall Application Dashboard 1 docker pull linuxserver/heimdall 另在 參考文章第二篇 有提到統一認證，不過我個人不太需要就沒弄了 (主要是看著就很複雜)\n後話 從這次折騰來看，可能並不需要為 NAS 的系統買單，硬體買電腦配件組個主機，軟體裝個 Linux 系統，透過各種開源專案想必應該也可以有不錯的體驗\n指令列操作不來可以裝一些輕量的 GUI，例如 Xface、JWM 之類的\n參考文章 談談如何使用 docker，搭建一台「群暉」_NAS 儲存_什麼值得買 NAS也能用上【統一認證】_NAS 儲存_什麼值得買 使用 Plex \u0026amp; Docker 搭建自己的媒體伺服器 - RIN\u0026rsquo;S HOME 利用 Jellyfin + Bangumi 打造更舒適的動畫媒體庫 - 初之音 ","date":"2022-09-16T15:00:01+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/73/","title":"個人內網折騰"},{"content":" 📢 本文由 gemini-2.5-flash-lite 翻譯 前言 啟用某外掛後台出現 502 錯誤。\n進入資料庫 選擇進入 wp_options 資料表。\n找到 active_plugins 項目，一般在第二頁。\n編輯此項目的 option_value 行。\n刪除不需要的外掛 注意：刪除前請務必備份！！！\n找到不需要的外掛名稱。\n刪除從 i: 開始到 ; 為止的字串，例如 i:1;s:23:\u0026quot;elementor/elementor.php\u0026quot;;\n更改序號，也就是 i: 後面的數字。\n更改總數，也就是最開頭 a: 後面的數字。\n參考文章 從資料庫停用單一 WordPress 外掛 - WordPress - GoDaddy 說明 SG ","date":"2022-09-15T22:17:02+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/72/","title":"WordPress 停用資料庫外掛"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 前言 為了在區域網路內更方便地看漫畫。\nIP 設定 路由器為 OpenWRT 系統。\n路由器設定 在 網路 - IP/MAC 綁定 將電腦綁定一個固定的 IP。\nFedora 設定 因為我設定的 IP 與自動分配的不一致（有線連接），故需要手動修改。\n在 網路 - 設定 的 身分 加上 MAC 位址，IPv4 改為 手動，位址依序為 IP、255.255.255.255、路由器 IP，DNS 加上 路由器 IP，未取消勾選自動。\n網域劫持 儘管可以透過 IP 直接存取，但是有一個網域名稱會更加好記吧。\n在路由器 網路 - 主機名稱 的 主機名稱 處填入網域名稱，IP 位址 處填入電腦的 IP。\n安裝 Docker 安裝了有 GUI 的 Docker Desktop。\n設定儲存庫 1 dnf -y install dnf-plugins-core 1 2 3 sudo dnf config-manager \\ --add-repo \\ https://download.docker.com/linux/fedora/docker-ce.repo 下載 RPM 套件 在 官網 Download 處 下載。\n下載完成後直接雙擊安裝。\n安裝 Komga Docker 設定 檔案共享設定 在 Docker Desktop 的 設定 - Resources - File sharing 加入漫畫路徑。\n註：如果共享的目錄在下次啟動時不存在 (未掛載)，Docker 將無法正常啟動。\n網路設定 不清楚是否非必須，在 設定 - Resources - Network 設定為自己的網段。\n命令列安裝 直接在 Shell 執行：\n1 2 3 4 5 6 7 8 docker run \\ --name=komga \\ --user 1000:1000 \\ -p 2333:8080 \\ -v /home/yexca/komga/config:/config \\ -v /home/yexca/komga/data:/data \\ --restart unless-stopped \\ gotson/komga:latest -p 前一個為本機映射埠號，後一個為容器埠號。\n-v 檔案映射，將本機的目錄 (/home/yexca/komga/config) 映射到容器的 (/config)。\n註：無法映射本機的隱藏檔案（以 . 開頭的檔案）。\nGUI 安裝 在上一步完成後，Docker Desktop 的 Images 會多出一個 gotson/komga，點擊 run，然後進行配置：\n第一行：名稱\nPorts：映射到本機的埠號，比如 80，這樣就可以直接以網域名稱存取了。\nVolumes：路徑映射。\nEnvironment variables：環境變數，此處用不到。\n檢查是否執行 使用指令查看：\n1 docker ps -a 防火牆配置 開啟埠號：\n1 firewall-cmd --zone=public --add-port=80/tcp 載入設定：\n1 firewall-cmd --reload 查看埠號開啟狀態：\n1 firewall-cmd --zone=public --query-port=80/tcp 可能需要新增服務：\n1 firewall-cmd --add-service=http 如果真的無法開啟就用 GUI 吧 (一開始就用會更快吧)：\n1 sudo yum install firewall-config 參考文章 Install Docker Desktop on Fedora - Docker Documentation 【Docker】Error response from daemon: invalid mount config for type \u0026ldquo;bind\u0026rdquo;: bind source path does not exist - Qiita Run with Docker - Komga 簡約但絕不簡單的 Komga - 老蘇的 blog fedora 28 , firewalld 防火牆控制，firewall-cmd 管理防火牆規則 - xuyaowen - 博客園 Fedora 防火牆配置 - 上官飛鴻 - 博客園 原神自動簽到 (Linux 伺服器 Docker) - yexca\u0026rsquo;Blog Fedora 打開 8080 端口_chunqi zhi 的博客 - CSDN 博客 ","date":"2022-09-14T18:47:16+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/71/","title":"Fedora 安裝 Komga 折騰紀錄"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 前言 每次連線到主機都要輸入密碼實在有點麻煩 (因為我忘了\nOneClick 如果自己的電腦沒有公鑰需要先產生，通常在 ~/.ssh/id_rsa.pub\n1 ssh-keygen 接著在自己的電腦上執行下列命令\n1 ssh-copy-id username@RemoteIP 其中 username 替換為要登入的帳號，RemoteIP 替換為要登入的 IP 位址\n等待提示輸入密碼\n接著直接 SSH 連線就可以登入囉！\n1 ssh username@RemoteIP 非常方便！\n寫入檔案 如果需要將別人的公鑰寫入或忘記密碼，可以使用這個方法\n編輯設定檔 (可能需要提前更改檔案權限) ~/.ssh/authorized_keys 加入公鑰，一行一個，編輯完儲存即可 (如果更改了檔案權限別忘了改回 600)\n其實這時候已經可以免密碼登入了，不過可能還需要修改設定檔\n編輯檔案 /etc/ssh/sshd_config\n1 2 3 PasswordAuthentication yes　# 密碼登入 RSAAuthentication yes　# RSA 認證 PubkeyAuthentication yes　# 公鑰登入 如果需要同時使用公鑰與密碼驗證登入\n修改上述設定檔\n1 AuthenticationMethods publickey,password 重啟 SSHD 服務\n1 sudo service sshd restart 參考文章 SSH 公钥登录 - starnight_cyber - 博客园 ","date":"2022-09-12T19:24:25+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/70/","title":"SSH 公鑰登入"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 第三章 使用 shell 本章介紹的 Linux shell 稱為 Bash shell，其全稱為 Bourne Again shell。還有其他的 shell，例如在 BSD UNIX 使用者中流行的 C shell (csh)，以及在 UNIX System V 使用者中非常流行的 Korn shell (ksh)，Ubuntu 預設啟動 Dash shell (速度比 Bash 快)，還有 Tcsh shell (一種改進的 C shell) 和 Ash shell (與 Bourne shell 非常相似)。\n3.1 shell 和 終端機視窗 使用 終端機視窗 (Terminal 窗口) 透過執行的 GUI，可以打開一個終端機模擬程式 (有時也稱為 終端機視窗)，從而啟動一個 shell。\n大部分系統透過 Ctrl+Shift+T 快速鍵打開，Fedora 可在程式中尋找，或者按 alt+F2 後輸入 gnome-terminal。\n使用虛擬主控台 大多數有 GUI 的 Linux 系統在啟動時通常會執行多個虛擬主控台，虛擬主控台除了可以打開 GUI 之外，還可以打開多個 shell 工作階段。\n透過 Ctrl+Shift+F1~F6 可切換虛擬主控台。以 Fedora 為例，tty1 為 gdm (登入螢幕)，tty2 為第一個桌面，tty3 為第二個桌面 (純文字)，以此類推。\n命令提示字元 對於一般使用者來說，預設的提示字元是一個簡單的錢字號。\n$\n對於 root 使用者來說，預設的提示字元是一個井字號 (有時也稱為 number sign 或 hash tag)。\n#\n生動形象地說明了美國本源在英國\n3.2 選擇 shell 使用 who 命令即可顯示當前登入的使用者名稱，登入的虛擬主控台以及登入的時間。\n使用 grep username /etc/passwd 命令，在輸出的最後可看到預設使用的 shell。\n可以透過輸入命令以切換 shell，例如 ksh、tcsh、csh、sh、dash 或其他 shell (假設已經安裝了這些 shell)。\n學習 Bash shell 不僅是因為它是大多數安裝中預設的 shell，也是因為它是大多數 Linux 認證考試中所使用的 shell。\n3.3 執行命令 雖然只需要透過輸入命令名稱就可以執行許多命令，但更常見的做法是在命令之後輸入更多內容，從而改變其行為。在命令之後輸入的字元和單字稱為選項和參數。\n3.3.1 了解命令語法 大多數命令都有一個或多個用來改變命令行為的選項。 一般選項由單個字母構成，並在前面添加一個連字號 -，然而為了每次使用多個選項，也可以將多個單字母選項組合在一起，或者在每個選項前面都使用一個連字號。\n一些命令的選項由一個完整的單字組成，一般需要在單字前使用雙連字號 --。例如，為了使用 help 這個選項，需要輸入 --help，如果是 -help 將被解釋為 -h、-e、-l、-p 這四個選項。儘管有些命令不遵守雙連字號約定，但大多數命令還是要在單字選項前使用雙連字號。\n此外，大多數命令還可在輸入某些選項後或者整個命令列結尾處接受參數。 參數是一個額外的資訊區塊，比如檔名、目錄、使用者名稱、裝置或其他用來告訴命令如何執行的資訊。通常，在命令列中可以使用任意數量的參數，只要數量不超過單個命令列所允許的總字母數即可。\n有時，一個參數與一個選項相關聯，此時參數必須跟在選項之後。如果使用的是單字母選項，那麼參數通常在一個空白之後。而對於全單字選項，參數跟在一個等號 = 之後。\n例如：\n1 tar -cvf backup.tar /home/yexca 選項的含義是建立 (c) 一個名為 backup.tar 的檔案 (f)，其中包含 /home/yexca 目錄的全部檔案，並且在備份檔案建立完畢 (v) 後顯示詳細資訊。因為 backup.tar 是 f 選項的一個參數，所以 backup.tar 必須跟在選項之後。\n1 ls --hide=Desktop \u0026ndash;hide 選項告訴 ls 命令不要顯示名為 Desktop 的檔案或目錄，注意選項與參數之間沒有空白。\n還可以嘗試其他的命令： uname 命令顯示正在執行的系統類型，添加了 -a 選項後還可以查看主機名稱及核心版本。\n當登入到一個 Linux 系統時，Linux 會認定您具有特定的身份，其中包括使用者名稱、群組名稱、使用者 ID 和群組 ID。此外，Linux 還會追蹤登入工作階段，從而了解登入的時間、閒置的時間以及登入的地點等。可透過 id 命令查看身份相關資訊。\n啟用了 SELinux (Security Enhanced Linux) 的 Linux 發行版本都在 id 輸出的末尾顯示了額外資訊，例如：\ncontext=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023\nSELinux 提供了一種可以緊緊鎖定 Linux 系統安全性的方法。\n透過 who -uH 可添加關於閒置時間和程序 ID 資訊 (u)，以及要求列印標頭 (H)。\n閒置 (IDLE) 表示在沒有任何命令輸入的情況下 shell 保持打開狀態的時間長度。程序號碼 (PID) 表示使用者登入 shell 的程序 ID。而備註 (COMMENT) 則表示使用者用來進行登入操作的遠端電腦名稱 (前提是使用者使用了網路上的另一台電腦進行登入)，或者本地 X Display 的名稱 (前提是使用者正在使用一個終端機視窗)，比如 :0.0。\n3.3.2 查找命令 為了找到所輸入的命令，shell 在所謂的路徑中進行查找，對於不在路徑中的命令，可透過輸入命令位置的完整識別進行執行。\n透過 echo $PATH 以查看 shell 的環境變數 PATH。\n參考： Linux 下 bin 目錄 - yexca\u0026rsquo;Blog 與其他一些作業系統不同的是，預設情況下，在搜尋路徑之前，Linux 並不會為了查找執行檔而檢查目前目錄，而是馬上開始搜尋路徑，只有在執行檔位於 PATH 環境變數或者給定了執行檔的絕對路徑或相對路徑時，才會執行目前目錄的執行檔。\n並不是所有的命令都位於 PATH 變數的目錄中，一些命令內建於 shell，透過建立用來定義任何命令的別名以及選項，可以改寫另外一些命令。下面是 shell 檢查輸入命令的順序：\n別名 (Alias)。由 alias 命令設置的名稱，可輸入此命令以查看建立的別名。\nshell 保留字。shell 保留了一些單字用作特殊用途。\n函式。一組能夠在目前 shell 中共同執行的命令。\n內建命令。內建於 shell 中的命令，在檔案系統中沒有命令的表現形式，例如 cd、echo、exit、pwd、history (查看以前執行的命令列表)、fg (將一個背景執行的命令帶入前景)、set (設置 shell 選項) 和 type (顯示命令的位置)。\n檔案系統命令。儲存在電腦檔案系統中的命令 (這些命令由 PATH 變數值表示)。\n為了知道命令的出處，可以使用 type 或者 which 命令，透過使用 type -a 可顯示命令的所有已知位置。\n如果一些命令不在 PATH 變數中，可使用 locate 命令嘗試查找該命令，透過使用 locate 命令可以訪問系統中任何可訪問的部分。\nlocate 命令會對整個檔案系統進行查找，而不僅僅是在包含了命令的目錄中查找，如果沒有找到最近添加的檔案，可以 root 使用者身份執行 updatedb 以更新 locate 資料庫。\n3.4 使用命令歷史記錄重複執行命令 重複執行那些冗長、複雜且易於輸錯的命令將可以避免很多問題的出現。\n3.4.1 命令列編輯 預設情況下，Bash shell 使用基於 Emacs 文字編輯器的命令列編輯。如果更喜歡使用 vi，可以將 set -o vi 添加到家目錄的 .bashrc 檔案中。\n用來導覽命令列的按鍵： 按鍵 全稱 含義 Ctrl+F 向前一個字元 前進一個字元 Ctrl+B 向後一個字元 後退一個字元 Alt+F 向前一個單字 前進一個單字 Alt+B 向後一個單字 後退一個單字 Ctrl+A 命令列開頭 轉到目前命令列的開頭 Ctrl+E 命令列結尾 轉到目前命令列的結尾 Ctrl+L 清除螢幕 清除螢幕，並使游標停留在螢幕頂部 用來編輯命令列的按鍵： 按鍵 全稱 含義 Ctrl+D 刪除目前字元 刪除目前字元 Backspace 刪除前一個字元 刪除前一個字元 Ctrl+T 調換字元 交換目前字元和前一個字元的位置 Alt+T 調換單字 交換目前單字和前一個單字的位置 Alt+U 大寫單字 將目前單字改為大寫 Alt+L 小寫單字 將目前單字改為小寫 Alt+C 首字母大寫單字 把游標目前位置單字的頭一個字母變為大寫 Ctrl+V 插入特殊字元 添加一個特殊字元，例如添加 Tab 用來剪下和貼上命令列中文字的按鍵： 按鍵 全稱 含義 Ctrl+K 剪下到行末 剪下游標後面的所有字元 Ctrl+U 剪下到行首 剪下游標前面的所有字元 Ctrl+W 剪下前一個單字 剪下位於目前游標之前的一個單字 Alt+D 剪下後一個單字 剪下位於目前游標之後的一個單字 Ctrl+Y 貼上目前文字 貼上最近剪下的文字 Alt+Y 貼上早期文字 轉回到早期剪下的文字並貼上 Ctrl+C 刪除整行 刪除整個命令列 3.4.2 命令列補全 為了減少按鍵，Bash shell 提供了多種不同的方法來補全部分輸入值。為了嘗試補全一個值，需要輸入前幾個字元並按 Tab 鍵。下面是可以透過 Bash shell 部分輸入的值：\n命令、別名或函式。如果所輸入的文字以常規字元開頭，shell 將嘗試使用命令、別名或者函式名稱來補全該文字。\n變數。如果所輸入的文字以錢字號 $ 開頭，那麼 shell 將使用來自目前 shell 的一個變數來補全文字。\n使用者名稱。如果所輸入的文字以波浪號 ~ 開頭，shell 將使用一個使用者名稱補全文字。因此，~username 表示指定使用者的家目錄。\n主機名稱。如果所輸入的文字以 at 符號 @ 開頭，shell 將使用來自 /etc/hosts 檔案中的一個主機名稱補全文字。\n如果想要添加來自其他檔案的主機名稱，只需要將 HOSTFILE 變數設置為該檔名，但該檔案必須與 /etc/hosts 相同的格式。\n如果所輸入的字串可以產生多種補全結果，此時可以透過雙擊 TAB 鍵列出所有可能的結果。\n3.4.3 命令列重複執行 在輸入完一行命令後，該命令列會儲存到 shell 的歷史命令列表中。\n透過 history 命令查看歷史命令列表，或者添加數字參數以顯示指定數量的最新命令。\n透過使用驚嘆號 ! 以重複執行這些命令，此種方法將直接執行，沒有再次確認的機會。\n!n \u0026mdash; 執行命令編號。例如 !255 將執行第 255 個命令。\n!! \u0026mdash; 執行前一個命令。\n!?string? \u0026mdash; 執行包含字串的命令。\n除了直接執行 history 外，還可重複執行特定命令並進行編輯：\n按鍵 功能 描述 方向鍵或Ctrl+P 與 Ctrl+N 步驟 遍歷歷史命令列表的每一個命令列，直到找到所需的命令列 Ctrl+R 反向增量搜尋 按下後可輸入一個搜尋字串，完成反向搜尋。當輸入字串時，會出現可以執行或編輯的相匹配的命令列 Ctrl+S 向前增量搜尋 與上一個類似，不過是向前搜尋。並不是所有情況都可用 Alt+P 反向搜尋 按下後可輸入一個搜尋字串，完成反向搜尋。輸入字串並按 Enter 鍵後可看到該字串的最新命令列 Alt+N 向前搜尋 與上一個類似，不過是向前搜尋。並不是所有情況都可用 還可使用 fc 命令以使用歷史命令列表。輸入 fc 後跟著一個歷史命令列編號或一個範圍 (例如 fc 233 255)，將在文字編輯器中打開這些命令 (預設為 vi)，關閉編輯器後命令將 (逐個) 執行。\n關閉 shell 後，歷史命令列表將儲存到家目錄的 .bash_history 檔案中，預設最多儲存 1000 條。\n如果不想儲存歷史命令列表，就不要正常退出 shell，可透過 kill -9 PID 關閉 shell 工作階段以不儲存歷史命令。\n將變數 HISTFILE 設置為 /dev/null 或保持 HISTSIZE 為空都是沒用的，只要 shell 正常退出，就會永久儲存 shell 歷史。\n3.5 連接和擴充命令 shell 真正強大的功能在於能將命令的輸入和輸出重導向到其他命令或檔案中，反之亦然。\n為了將命令串在一起，shell 使用了中繼字元 (metacharacter)。中繼字元是對 shell 有特殊含義的輸入字元，用於連接請求或擴充請求。\n中繼字元包括管線字元 |、與號 \u0026amp;、分號 ;、右括號 )、左括號 (、小於號 \u0026lt; 和大於號 \u0026gt;。\n3.5.1 命令之間的管線 管線字元 | 將一個命令的輸出連接到另一個命令的輸入，例如：\n1 cat /etc/passwd | sort | less 該命令列出 /etc/passwd 檔案內容。輸出到 sort 命令以對內容排序，最後發送到 less 以顯示輸出。\n3.5.2 連續命令 使用分號 ; 將多個命令隔開可在同一命令列輸入多條命令以執行連續的命令，例如：\n1 date ; troff -me VertLargeDocument | lpr ; date 對一個很大的文件格式化，並顯示格式化所需的時間。\n3.5.3 背景命令 一些命令可能需要花費很長時間才能完成，可使用與號 \u0026amp; 讓命令在背景執行，例如：\n1 troff -me VertLargeDocument | lpr \u0026amp; 在程序結束之前不要關閉 shell 或刪除 (kill) 該程序，否則程序將終止。\n3.5.4 擴充命令 透過命令替換，可以使一條命令的標準輸出變為另一條命令的一個參數。\n命令替換的兩種形式是 $(command) 和 command (注意是反引號)。\n兩種形式中的命令可以包括選項、中繼字元和參數，例如：\n1 vi $(find /home | grep xyzzy) 在 vi 命令執行之前完成了命令替換。首先 find 命令從 /home 目錄尋找所有檔案與目錄，然後將輸出連接到 grep 命令，將檔名中不包含 xyzzy 的過濾掉，最後使用 vi 打開所有檔案進行編輯 (每次打開一個檔案)。\n注意：不要從根檔案系統開始使用 grep，否則將匹配並嘗試編輯幾千個檔案。\n3.5.5 擴充算術運算式 有時可能需要將算術結果傳遞給一條命令。透過 $[expression] 或者 $((expression))，例如：\n1 echo \u0026#34;I am $[2022-1957] years old\u0026#34; 輸出為 I am 65 years old。\n1 echo \u0026#34;There are $(ls | wc -w) files in this directory\u0026#34; 該命令列出目前目錄內容 (ls) 並執行了單字計數命令，計算出找到的檔案數量 (wc -w)，然後輸出。\n3.5.6 擴充變數 使用錢字號 $ 對 shell 中用來儲存資訊的變數進行擴充。當在命令列中擴充一個環境變數時，所列印的是變數的值，而不是變數名稱，例如：\n1 ls -l $BASH 列印 bash 命令的詳細列表 -rwxr-xr-x. 1 root root 1390064 1月 20 2022 /usr/bin/bash\n3.6 使用 shell 變數 shell 本身使用變數儲存了對使用者的 shell 工作階段非常有用的資訊。如果想要查看目前 shell 設置的所有變數，可以使用 set 命令。\n其中，本地變數的一個子集被稱為環境變數，對任何透過目前 shell 打開的新 shell 都是可用的。可以使用 env 命令查看環境變數。\n除了所設置的變數之外，系統檔案也會設置一些用來儲存相關資訊的變數，比如設定檔、信箱以及路徑目錄的位置。此外，這些變數還可以儲存關於 shell 提示字元、歷史命令列表的大小以及作業系統類型的相關值。如果想引用這些變數的值，需要在變數之前添加一個錢字號 $。\n當啟動一個 shell 時，許多環境變數已經被設置了，下表為一些既可以在使用 Bash shell 時設置，又可以為了使用不同功能而設置的變數：\n變數 描述 BASH 包含了 Bash 命令的完整路徑。其值通常為 /bin/bash BASH_VERSION 表示目前 Bash 命令版本的一個數字 EUID 表示目前使用者有效的使用者 ID 號碼。當啟動 shell 時，根據 /etc/passwd 檔案中的使用者項進行賦值 FCEDIT fc 命令用來編輯 history 命令的文字編輯器，預設為 vi HISTFILE 歷史命令檔案的位置，通常位於 $HOME/.bash_history HISTFILESIZE 可以儲存的歷史命令條目的數量。當達到該數量時，最早的命令將被丟棄，預設為 1000 HISTCMD 返回歷史命令列表中目前命令的數量 HOME 家目錄 HOSTTYPE 描述了 Linux 系統正在執行的電腦系統結構。對於 Intel 相容的個人電腦，其值為 i386、i486 或 i386-Linux 類似的值。而對於 AMD 64 位元電腦，其值為 x86_64 MAIL 信箱檔案的位置，通常為 /var/spool/mail/$USER OLDPWD 修改目前工作目錄之前的工作目錄 OSTYPE 用來識別目前作業系統。對於 Fedora，值為 Linux 或 Linux-gnu PATH 值為冒號 : 分隔的目錄列表，主要用來查找需要輸入的命令 PPID 目前 shell 的命令的程序 ID PROMPT_COMMAND 可以將該變數設置為一個命令名稱，以便在每次 shell 提示字元顯示之前執行該命令 PS1 設置 shell 提示字元的值。有時命令需要額外的提示字元，可以使用變數 PS2、PS3 等進行設置 PWD 表示目前目錄 RANDOM 生成一個 0~32767 的隨機數 SECONDS 自 shell 啟動後的秒數 SHLVL 與目前 shell 工作階段相關聯的 shell 層級數。當登入到 shell 時，值為 1，每執行一次 Bash 命令後該層級數將遞增 (例如使用 su 命令或輸入 bash) TMOUT 可以為該變數設置一個數字，表示 shell 可以閒置的秒數。在秒數到達後，shell 將會退出 (登出使用者) 3.6.1 建立和使用別名 (Alias) 使用 alias 命令可以列出所有別名以及建立別名。\n1 alias p=\u0026#39;pwd ; ls -CF\u0026#39; 執行 p 命令，將執行 pwd 命令後執行 ls -CF 以列表的形式列出該目錄的內容。\n如果想刪除，可使用 unalias 命令。\n3.6.2 退出 shell 輸入 exit 或者按 Ctrl+D。\n3.7 建立自己的 shell 環境 可以透過調整 shell 以幫助更有效地工作。\n3.7.1 設定 shell shell 的行為方式由多個設定檔所支援：\n檔案 描述 /etc/profile 為每個使用者設置了使用者環境資訊，當首次登入時執行該檔案。該檔案還從 /etc/profile.d 目錄的設定檔中收集相關的 shell 設置。除了為諸如使用者信箱位置以及歷史檔案大小的資訊設置環境變數，還提供了路徑值 /etc/bashrc 每次打開一個 Bash shell 時都會執行該檔案，可透過每個使用者的 ~/.bashrc 檔案中的資訊改寫該檔案。設置了預設的提示字元，同時還可添加一個或多個別名 ~/.bash_profile 用來被每個使用者輸入 shell 具體用法資訊的檔案，只有當使用者登入才會執行該檔案。預設情況下，它設置一些環境變數並執行使用者的 .bashrc 檔案。該檔案是添加環境變數的絕佳位置 ~/.bashrc 包含了特定於 Bash shell 的資訊，當進行登入以及每次打開一個新 Bash shell 都會讀取該檔案。該檔案是添加別名的好地方 ~/.bash_logout 每次登出時執行該檔案，預設會清除螢幕 如果想更改 /etc/profile 或 /etc/bashrc 檔案，則必須是 root 使用者。一般建立 /etc/profile.d/custom.sh 檔案來添加系統全域的設置，而不是直接編輯這些檔案。\nnano 編輯器 較為簡單的文字編輯器，Ctrl+O 儲存檔案，Ctrl+X 退出檔案。\n3.7.2 設置提示字元 提示字元由一組字元組成，每當 shell 準備接收命令時都會顯示這組字元。PS1 環境變數設置了提示字元所包含的內容，如果需要額外的輸入，可以使用 PS2、PS3 以及 PS4 的值。\n特殊字元 描述 \\! 顯示目前命令歷史記錄編號，包括為使用者名稱儲存的所有以前的命令 \\# 顯示目前命令的命令編號，僅包括用於獲取 shell 的命令 \\$ 根據使用者類型的不同，顯示使用者提示字元 $ 或 root 提示字元 # \\W 僅顯示目前工作的基底名稱 (basename) \\[ 出現在非列印字元序列之前。可用來向提示字元添加終端機控制序列，比如改變顏色、添加閃爍效果或使字元變粗 (所使用的終端機決定了最終可用的序列) \\] 緊跟在非列印字元序列之後 \\\\ 顯示一個反斜線 \\d 顯示目前日期的星期幾、月份以及日期 \\h 顯示正在執行 shell 的電腦的主機名稱 \\n 換行符號 \\nnn 顯示替換 nnn 的八進位數所表示的字元 \\s 顯示目前 shell 的名稱 \\t 以小時、分鐘、秒的格式列印目前時間 \\u 列印目前使用者名稱 \\w 顯示目前工作目錄的完整路徑 如果僅臨時修改，例如 export PS1=\u0026quot;[\\t\\w]\\$\u0026quot;。\n如果永久修改，需要向 ~/.bashrc 添加 PS1 值。\n閱讀更多： Bash Prompt HOWTO 3.7.3 添加環境變數 有時可能需要向 .bashrc 檔案添加一些環境變數：\nTMOUT \u0026mdash; 設置在 Bash 自動退出之前 shell 可以處於非活動狀態多長時間。\nPATH \u0026mdash; 設置了對所使用命令進行搜尋的目錄。例如為了添加目錄 /home/yexca/bin，可添加以下程式碼：\nPATH=$PATH:/home/yexca/bin ; export PATH\n該範例首先將所有目前的路徑目錄 ($PATH) 讀取到新 PATH 變數中，然後添加 ~/bin 目錄，最後匯出新的 PATH 變數。\n切勿將 . 添加到 PATH 變數，可能存在安全風險。\nWHATEVER \u0026mdash; 可以建立自己的環境變數，為工作提供捷徑。為這些變數選擇一個未被使用的任何名稱，並賦予一個有用的值。例如：\nMYWORKDIR=/home/yexca/work ; export MYWORKDIR\n可透過輸入 cd $MYWORKDIR 使設置的目錄成為目前目錄。\n3.8 獲取關於命令的資訊 一些命令內建於 shell 中，例如 help | less 以瀏覽幫助資訊，或者 help command 以查看某命令的幫助資訊。\n在命令中使用 --help 選項或 -h 選項以查看命令提供的幫助資訊。\n還有 info 和 man command 命令學習某一特定命令。\n說明頁 (man page) 是獲取命令以及 Linux 系統中其他基本組件相關資訊的最常用方法。\n說明頁有 8 個章節：\n節數 節名稱 描述 1 使用者命令 可以由一般使用者透過 shell 執行的命令 2 系統呼叫 某一應用程式中用來呼叫系統核心的程式設計函式 3 C 函式庫函式 為特定程式設計函式庫提供介面的程式設計函式 4 裝置和特殊檔案 表示硬體裝置或軟體裝置的檔案系統節點 5 檔案格式和約定 檔案類型或特定的設定檔 6 遊戲 系統中可玩的遊戲 7 雜項 對相關主題 (如協定、檔案系統) 的概述 8 系統管理工具和守護行程 需要 root 或其他管理特權的命令 透過 man -k 可搜尋說明頁資料庫。若無搜尋結果可能是未初始化，使用 root 身份執行 mandb 以初始化資料庫。\n透過例如 man 5 passwd 以顯示第 5 節內容。\n瀏覽時透過 Page Down 和 Page Up 以翻頁，或使用 Enter 與方向鍵以移動一行。如果想要搜尋，使用正斜線 / 然後輸入要搜尋的內容，透過 n 重複向前搜尋，N 以重複向後搜尋。輸入 q 以退出。\n","date":"2022-09-12T15:04:10+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/69/","title":"Linux 學習 第三章 使用 shell"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 前言 既然都有 Win 命令列了，那怎麼能沒有 Linux 呢？\nWindows 的文章： 命令列下載 YouTube 影片 下載 yt-dlp 建議配置好 Python 環境，然後到 Releases · yt-dlp/yt-dlp · GitHub 下載 yt-dlp，如果不想配置 Python 就下載 yt-dlp_linux。\n下載完成後賦予執行權限並放在 /usr/local/bin/ 下。\n下載 FFmpeg 參考官網 Download FFmpeg Fedora 下使用以下命令：\n1 sudo dnf install ffmpeg 設定檔 切換設定目錄：\n1 cd ~/.config 建立資料夾並進入：\n1 2 mkdir yt-dlp cd yt-dlp 建立設定檔：\n1 vi config 我的設定檔如下：\n1 -f bv+ba/b -o ~/Videos/%(uploader)s/%(upload_date)s%(title)s%(id)s.%(ext)s --continue --merge-output-format mp4 說明一下：\n1 2 3 4 5 6 7 8 9 10 11 12 -f bv+ba/b # 最高畫質與音訊 -o # 輸出資料夾設定 /%(uploader)s/ # 依頻道名稱建立資料夾 %(upload_date)s # 上傳時間 %(title)s # 影片標題 %(id)s # 影片 ID .%(ext)s # 影片副檔名 --continue # 斷點續傳 --merge-output-format mp4 # 合併為 mp4 影片 參考文章 FFmpeg 批次轉換影片格式 話說自己的文章有必要放連結嗎\n","date":"2022-09-10T19:29:58+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/68/","title":"Linux 下載 YouTube 影片"},{"content":" 📢 本文由 Gemini-3-flash 翻譯 引言 這個黑幕很好玩啊，非常好玩啊，可惜首頁無法渲染出來，而且 Markdown 編寫渲染也難\n使用方式 撰寫文章時選擇作為 HTML 編輯，插入以下語句\n1 \u0026lt;span class=\u0026#34;heimu\u0026#34; title=\u0026#34;黑幕彈框裡的字\u0026#34;\u0026gt;需要隱藏的文字\u0026lt;/span\u0026gt; 插入 CSS 本來是想著實作首頁也有黑幕，但實際測試發現首頁不會渲染 (為什麼不渲染啊啊啊啊啊啊啊！！！！！！！試著想像 Warma 的聲音)\n進入後台設定，找到頁尾設定，輸入以下程式碼，或者在 WP 的自訂 CSS 處插入，不過需要去掉標籤\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 \u0026lt;style\u0026gt; .heimu, .heimu a, a .heimu, .heimu a.new { background-color: #252525; color: #252525; text-shadow: none; } .heimu:hover, .heimu:active, .heimu:hover .heimu, .heimu:active .heimu { color: white !important; } .heimu:hover a, a:hover .heimu, .heimu:active a, a:active .heimu { color: lightblue !important; } .heimu:hover .new, .heimu .new:hover, .new:hover .heimu, .heimu:active .new, .heimu .new:active, .new:active .heimu { color: #BA0000 !important; } \u0026lt;/style\u0026gt; 註：因 Argon 不會渲染註釋，所以我並不把以下內容放入程式碼中：\n/*閱讀更多：https://zh.moegirl.org/MediaWiki:Mobile.css 本文引自萌娘百科(https://zh.moegirl.org)，文字內容預設使用《創用 CC 姓名標示-非商業性-相同方式分享 3.0》協議。*/\n參考文章 Re：萌娘百科上的黑幕實現 – Vanilla_chan – 博客園 萌百黑幕CSS代码-Hiyoung’blog ","date":"2022-09-05T21:51:23+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/67/","title":"萌娘百科黑幕在 Argon 主題 WordPress 實作"},{"content":" 📢 本文由 gemini-2.5-flash-lite 翻譯 引言 記錄我使用 OpenWRT 路由器連接學校網路的折騰過程，雖然最後的結果挺 emm？但在这个過程中還是了解到不少東西\n起始 通過在瀏覽器搜尋 openwrt通過深瀾認證 得到 恩山無線論壇 帖子回覆下的一個開源專案： coffeehat/BIT-srun-login-script ，通過專案知道了有支援多平台 (包括 openwrt) 的 golang 版本，於是開始折騰\n這是專案作者的文章： 深瀾校園網登錄的分析與 python 實現-北京理工大學版 折騰前 對於 OpenWRT 版本未提供編譯後的版本，即 IPK 文件，又因為我水平不行看不懂 README 便請教同學得知為 Linux 的指令，但在實際操作後得知此命令為編譯 Linux 核心，便放棄在實體機做開始使用虛擬機搞\n參考： Building a custom kernel/zh-cn - Fedora Project Wiki 開始折騰 另朋友發了 configuration - How to fix make error \u0026ldquo;No rule to make target \u0026lsquo;menuconfig\u0026rsquo;\u0026rdquo; when building a kernel for Beagleboard? - Unix \u0026amp; Linux Stack Exchange ，於是我便照著此帖子回答嘗試\n創建虛擬機 因為我使用的 Fedora 自帶虛擬機軟體 盒子，首先嘗試裝 CentOS8，因為我的鏡像文件放到了移動硬碟中，便直接掛載，選擇。結果提示創建失敗，然後我嘗試了 CentOS7，失敗，然後 Ubuntun，失敗\n接連失敗，要不是我之前用這軟體創建過Win10我都快懷疑是不是軟體不行了，打開錯誤日誌，果然看不懂，不過我注意到路徑有中文，於是把路徑改為英文，再次嘗試，失敗\n然後第二天我在想既然是編輯核心，要不使用 kali 吧，於是把 U 盤中 kali 鏡像複製到電腦，雖然最後安裝失敗但成功運行了，難道要把系統放本地才行嗎\n於是我把 CentOS7 的鏡像拷貝到 ~/Documents/ 下，安裝成功。因想著只是編譯 IPK 便只有 root 用戶\n連接網路 本以為在 Linux 下創建 Linux 虛擬機可以直接共享網路的，於是我就直接輸入命令 wget https://cdn.kernel.org/pub/linux/kernel/v5.x/linux-5.19.6.tar.xz，結果就是無法找到 IP 地址，使用命令 ifconfig 發現無 IP\n參考文章 在虛擬機中設置靜態 IP (centos 為例) 使虛擬機連上網路，不過在最後文件修改只需要將 ONBOOT 後的值改為 yes 然後加倆 DNS 就可以了\n安裝git 連上網路後我先裝了個 git，使用 yum install git 即可，然後配置姓名與郵箱\n1 git config --global user.name \u0026#34;Name\u0026#34; 1 git config --global user.email \u0026#34;email@example.com\u0026#34; 傳輸文件 繼續使用 wget 下載 Linux 核心，嘗試了三四次，幾乎都是在 50% 左右下載失敗而且速度很慢\n注：使用 wget -c URL 可實現斷點續傳\n然後就是 盒子 這個軟體貌似支援直接拖拽傳輸，於是我在我的電腦下載好後直接拖過去，失敗，文件沒有被傳輸過去，考慮到傳輸後的文件在 ~/Downloads/ 下，我使用的是 root 帳戶，於是我參考 Linux 添加用戶和管理員用戶 創建了一個用戶 (差點把最後一步刪除用戶也執行了)\n使用命令 su username 切換用戶，創建文件夾 ~/Downloads/，再次拖入還是失敗\n嘗試使用 盒子 的共享功能將電腦的 ~/Public 共享，但我怎麼操作也不能在虛擬機裡看到 (想必這軟體只適配了 RHEL 和 Fedora 吧)\nSSH 傳輸 然後我想到了通過 SSH 傳輸 (因為我輸入 ftp 發現沒這個命令，懶得裝了)\n本地開啟 SSH 連接，然後通過 scp 命令以使用 SSH 傳輸文件\n1 scp username@servername:/path/filename ~/Downloads/ 首先是確定 IP，在虛擬機中輸入命令 ip route 得到 IP 為 10.0.2.2\n然後使用 scp 命令傳輸\n解壓文件 使用 tar 命令解壓文件\n1 tar -xzvf filename.tar.xz emm，非 gzip 壓縮文件，那我不知道怎麼解壓啊\nSSH 傳輸 還是使用 SSH 傳輸吧，在 scp 命令加上 -r 即可傳輸文件夾\n開始嘗試 按照步驟將解壓後的文件放到 /usr/src/ 下，把 /boot 下的 config 放到 /usr/src/linux-5.19.6/.config，結果無論是把配置文件放到 .config/ 下還是放到 .config 都無法運行 make menuconfig 命令\n總結 折騰失敗，下次再來\n不過在我編寫此文章時注意到原帖嘗試直接在 OpenWRT 運行 Python，有時間嘗試一下\n再次嘗試 然後我諮詢了一位過了認證校園網的朋友 (雖然他是普通路由器)，他將路由器的 MAC 地址改為自己電腦的，結果插上網線認證頁面會自動轉發到電腦，然後認證後就有網了，不過是銳捷網頁認證\n然後考慮到深瀾使用的是 Portal 認證也就是 Web 頁面認證，既然是 Web 那想必就是使用 HTTP 了，我是否可以通過編輯 HTTP 報文的方式通過認證呢？那麼 Linux 有命令可以發送 HTTP 報文嗎，我搜了一下，發現 curl 與 wget 命令可以模擬 get 和 post 請求 (於是我打開 Fiddler 開始抓包，企圖還原驗證過程)\n才怪，我用路由器連接上學校網，電腦插上網線連上路由器，輸入認證頁面 IP，認證完成，路由器有網了\nLinux 命令模擬 Http 的 get 或 post 請求 雖然沒用到，不過既然看到了那就記錄一下吧\nGET 請求 curl 1 2 3 4 5 6 7 8 ## 如果這裡的 URL 指向的是一個文件可以直接下載到本地 curl URL ## 顯示全部信息 curl -i URL ## 只顯示頭部信息 curl -I URL ## 顯示 get 請求全過程解析 curl -v URL wget 1 wget URL POST 請求 curl 1 2 3 4 5 6 ## 通過 -d 參數，把訪問的參數放在裡面 curl -d \u0026#34;param1=value1\u0026amp;param2=value2\u0026#34; \u0026#34;URL\u0026#34; curl -d\u0026#39;param1=value1\u0026amp;param2=value2\u0026#39; -X POST URL curl -d \u0026#39;param1=value1\u0026#39; -d \u0026#39;param2=value2\u0026#39; -X POST URL wget 1 2 ## 通過 --post-data 參數實現 wget --post-data \u0026#39;user=name\u0026amp;passwd=passwd\u0026#39; URL 再次總結 有時候不能把某件事想的太複雜，往往很簡單的事只思考而沒實踐就否認這種可能性是錯誤的，這次就是我一開始就把最後再次嘗試部分否決才鬧了這麼一大圈 (要不是流量卡的不行我才不會去試)\n寫到這時我想到了兩句名言\n學而不思則罔，思而不學則殆\n實踐得真知\n所以有些時候還是應該大膽去嘗試，不要因為過多的思考而限制了自己！\n參考文章 求助深瀾校園網 Portal 認證應該怎麼刷固件？-小米無線路由器以及小米無線相關的設備-恩山無線論壇 configuration - How to fix make error \u0026ldquo;No rule to make target \u0026lsquo;menuconfig\u0026rsquo;\u0026rdquo; when building a kernel for Beagleboard? - Unix \u0026amp; Linux Stack Exchange 在虛擬機中設置靜態 IP (centos 為例) - yexca\u0026rsquo;Blog 安裝 Git - 廖雪峰的官方網站 Linux 添加用戶和管理員用戶 - yexca\u0026rsquo;Blog linux 系統下如何進行用戶之間的切換_M李麗的博客-CSDN博客_linux切換系統 使用 ssh 傳輸文件 - 思否 Linux tar 命令-菜鳥教程 Portal 認證原理-曹世宏的博客 Linux 命令發送 Http 的 get 或 post 請求 (curl 和 wget 兩種方法)_cyl937的博客-CSDN博客 ","date":"2022-09-05T21:24:23+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/66/","title":"記錄 OpenWRT 通過深瀾網路認證的折騰過程"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 前言 因為接觸了 YouTube-dl ，下載頻道的所有內容非常好用，但是下載下來是 webm 格式，相容性不是很好，於是查詢了使用 ffmpeg 轉換格式的指令。\n設定檔 後來發現改一下設定檔就行了，在檔案後面加上\n1 --merge-output-format mp4 這是我的設定檔\n1 -o \u0026#39;C:/Users/yexca/Downloads/Video/%(uploader)s/%(upload_date)s%(title)s%(id)s.%(ext)s\u0026#39; --merge-output-format mp4 單一指令 使用以下指令即可快速轉碼\n1 ffmpeg -i before.webm after.mp4 但一個一個轉碼實在是太慢了，於是就想到使用批次處理。\n批次處理 新增記事本，輸入以下程式碼\n1 for %%a in (*.webm) do ffmpeg -i \u0026#34;%%~a\u0026#34; -vcodec copy -f mp4 \u0026#34;%%~na.mp4\u0026#34; 其中 (*.webm) 為原始檔案類型，「%%~na.mp4」為想要產生的檔案類型。\n然後儲存並命名為run.bat 後，放到對應的資料夾執行即可。\n但這樣每次想轉換不同的檔案，還得修改一下，這樣不大實用啊（\ndos 然後我就看了一些 bat 檔案的資料，簡單寫了下面的程式 (需要使用 GB2312 編碼才能在命令列正常輸出中文)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 echo off :0 echo 請輸入數字選擇操作 echo 1.轉碼 echo 2.刪除 echo 3.退出 set /p choice=請選擇 goto %choice% :1 set /p before=請輸入轉碼前檔案格式 set /p after=請輸入轉碼後檔案格式 echo 開始轉碼%before%到%after% for %%a in (*.%before%) do ffmpeg -i \u0026#34;%%~a\u0026#34; -vcodec copy -f %after% \u0026#34;%%~na.%after%\u0026#34; echo 轉碼完成 goto 0 :2 set /p delet=請輸入需要刪除的檔案格式 echo 開始刪除%delet% del *.%delet% del %delet% echo 刪除完成 goto 0 :3 exit 放到對應的資料夾下使用就好了。\n參考文章 youtube-dl 的一些實用技巧 · eisen 部落格 給新手的 20 多個 FFmpeg 指令範例 - 知乎 FDM 當掉了，youtube-dl 慢得要死，烤肉man 的末日到了！ 中 AnnMilne 的評論\n用bat指令執行ffmpeg進行批次轉碼-五仁的紀錄 Bat指令學習 - 陽光雨露\u0026amp; - 部落格園 bat set指令詳解_python資深小白的部落格-CSDN部落格 ","date":"2022-09-05T16:41:38+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/65/","title":"ffmpeg 批次轉換影片格式"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 引言 這是在我閱讀了肖佳老師的書《HTTP 封包擷取實戰》後對 HTTP 相關內容的總結，主要還是訊息相關 (記錄：閱讀此書與寫出此文章耗時 5 天)\nHTTP 協定訊息的結構 HTTP 訊息分為 2 個：一個是 HTTP 請求訊息 (Request)，一個是 HTTP 回應訊息 (Response)\nHTTP 請求訊息 (Request) HTTP 請求訊息分為 3 個部分，第一部分叫起始行 (Request line)，第二部分叫標頭 (Request Header)，第三部分叫主體 (Body)\n第一行中有 Method (請求方法)、URI 和協定版本。例如 GET https://blog.yexca.net/ HTTP/2\n第二部分是 Header (標頭)\n第三部分是 Body (主體)\n注意：Header 標頭和 Body 主體之間有一個空行\nHTTP 回應訊息 (Response) HTTP 回應訊息與請求訊息的結構基本一樣，也分為 3 個部分，第一部分叫回應行 (Response line)，第二部分叫回應標頭 (Response Header)，第三部分是主體 (Body)\n第一行有協定版本、狀態碼和狀態碼訊息。例如 HTTP/2 200\n第二部分是 Header (標頭)\n第三部分是 Body (主體)\n注意：Header 標頭和 Body 主體之間有一個空行\nHTTP 協定請求方法和狀態碼 URL 格式 URL 的全稱為 Uniform Resource Locator，中文譯名為統一資源定位符，用於完整地描述 Internet 上某一處資源的位址\nURL 的基本格式如下：\nschema://host[:port#]/path/.../[?query-string][#anchor]\n屬性 描述 schema (協定) 指定底層使用的協定 (例如：http，https，ftp) host (網域) HTTP 伺服器的 IP 位址或者網域名稱 port# (連接埠) HTTP 伺服器的預設連接埠是 80，這種情況下連接埠號可以省略。如果使用了別的連接埠，則必須指明 path (資源的路徑) 存取資源的路徑 query-string (參數) 發送給 HTTP 伺服器的資料 anchor (錨點) 錨點，頁面內部超連結 HTTP 請求方法 編號 方法 描述 1 GET 請求指定的頁面資訊並傳回實體主體 2 HEAD 類似於 GET 請求，只不過傳回的回應中沒有具體的內容，用於獲取標頭 3 POST 向指定資源提交資料進行處理請求 (例如提交表單或者上傳檔案)，資料被包含在請求體中。POST 請求可能會導致新的資源建立和/或對現有資源的修改 4 PUT 從用戶端向伺服器傳送的資料取代指定文件的內容 5 DELETE 請求伺服器刪除指定的頁面 GET 與 POST 的區別 GET 提交的資料會放在 URL 之後，以 ? 分隔 URL 和傳輸資料 (即 query-string，鍵值對方式)，參數之間以 \u0026amp; 相連\n而 POST 方法是把提交的資料放在 HTTP 封包的 Body 中\nGET 提交的資料大小有限制 (因為瀏覽器對 URL 的長度有限制)\n而 POST 方法提交的資料大小沒有限制\nGET 方式需要使用 Request.QueryString 來取得變數的值\n而 POST 方法透過 Request.Form 來獲取變數的值\nHTTP 狀態碼 HTTP 狀態碼存在於 HTTP 的回應訊息中，其作用是 Web 伺服器用來告訴用戶端發生了什麼事\nHTTP 狀態碼被分為 5 大類，隨著協定的發展，HTTP 規範中會定義更多的狀態碼吧\n狀態碼 已定義範圍 分類 1XX 100～101 資訊提示，表示請求已被成功接收，繼續處理 2XX 200～206 成功，表示請求已被成功接收、理解、接受 3XX 300～305 重新導向，要完成請求，必須進行進一步處理 4XX 400～415 用戶端錯誤，請求有語法錯誤或請求無法實現 5XX 500～505 伺服器錯誤，伺服器未能實現合法的請求 常見狀態碼 名稱 釋義 200 OK：伺服器成功處理了請求 301/302 Moved Permanently (重新導向)：請求的 URL 已移走。Response 中應該包含一個 Location URL，說明資源現在所處的位置 304 Not Modified (未修改)：用戶端的快取資源是最新的，需要用戶端使用快取 404 Not Found：未找到資源 401 禁止存取 501 Internal Server Error：伺服器遇到一個錯誤，使其無法對請求提供服務 206 (Partial Content，部分內容) 206 狀態碼代表伺服器已經成功處理了部分 GET 請求 (只有發送 GET 方法的 HTTP 請求，Web 伺服器才可能傳回 206)\n應用比如說使用下載工具實現斷點續傳或者線上影片播放都是使用 206 狀態碼來實現\n例如現在打開影片網站的一個影片，對於影片所在的 URL\n瀏覽器會發送一個 GET 請求，Header 中包含 Range: bytes=5303296-5336063，意思就是請求得到 5303296-5336063 之間的資料\nWeb 伺服器傳回一個 206 的 HTTP 回應。Header 中包含 Content-Range: bytes 5303296-5336063/12129376，表明這次傳回的內容範圍\n301 與 302 (Moved Permanently，重新導向) 在得到 301 或 302 回應後，瀏覽器會再次請求位於 Location 中傳回的新 URL\n狀態碼 301 和 302 在語法上是一模一樣的，都是在 HTTP 回應的 Location 中傳回新的 URL\n區別在於：\n301 表示舊位址已經被永久移除了，這個資源不可存取了，搜尋引擎會把權重算到新位址\n例如：防止使用者輸錯網域或更換網域\n302 表示舊位址的資源還在，仍然可以存取，這個重新導向只是臨時地從舊位址跳轉到新位址，搜尋引擎會把權重算到新位址\n例如：未登入狀態下存取需要登入才能存取的頁面\n304 (Not Modified，未修改) 狀態碼 304 表示上次的文件已經被快取了，還可以繼續使用\n400 (Bad Request) 狀態碼 400 表示用戶端請求有語法錯誤，發送的 HTTP 請求中的資料有錯誤，例如表單有錯誤或者 Cookie 有錯誤，不能被伺服器所理解\n401 (Unauthorized) 狀態碼 401 是指未授權錯誤。有些網頁採用的是 HTTP 基本認證 (Basic Authentication) ，需要在 HTTP 請求 Header 中帶上 Authentication，否則伺服器會傳回狀態碼 401\n404 (Not Found) 該狀態碼表明伺服器上無法找到請求的資源。除此之外，也可以在伺服器端拒絕請求但不想說明理由時使用\n例如 BV1AB4y1D7Ft 這個影片僅在登入並且收藏的情況下才可見，否則將傳回 404\n403 (Forbidden) 狀態碼 403 表示 Web 用戶端發送的請求被 Web 伺服器拒絕了。如果伺服器想說明為什麼拒絕請求，可以在 Body 中描述原因。但這個狀態碼通常表示伺服器不想說明拒絕原因\n500 (Internal Server Error) 狀態碼 500 代表伺服器內部錯誤。出現錯誤的原因有很多，比如程式碼的錯誤、資料庫連接語句出錯、程式內部拋出異常、空指標錯誤等\n503 (Server Unavailable) 狀態碼 503 表示伺服器暫時不可用。由於伺服器維護或者過載，伺服器目前無法處理請求\n這個狀況是臨時的，並且將在一段時間以後恢復\n了解全部狀態碼 存取： HTTP 狀態碼 - 菜鳥教程 HTTP 協定 Header Header 的語法格式是「key: value」，一行一個。每一個 Header 都有特殊的作用\n快取相關的 Header HTTP 請求與 HTTP 回應都有很多用於快取的 Header。HTTP 快取是指當 Web 請求抵達快取時，如果本地有「已快取的」複本，就可以從本地儲存設備而不是原始伺服器中獲取該檔案\nCookie Cookie 是一種 HTTP 快取，是 HTTP 中非常重要的內容。它由 key=value 的形式組成，比如 ip_country=CN\n瀏覽器把 Cookie 透過 HTTP 請求中的「Cookie: header」發送給 Web 伺服器，Web 伺服器透過 HTTP 回應中的「Set-Cookie: header」把 Cookie 發送給瀏覽器\nAccept Accept 表示瀏覽器用戶端可以接受的媒體類型。例如 Accept: text/html 代表可以接受伺服器傳回 html\n萬用字元 * 代表任意類型，例如 Accept: text/html,*/*;q=0.8 代表瀏覽器可以處理所有的類型。一般瀏覽器用戶端給 Web 伺服器發送的都是類似這個\nAccept-Encoding Accept-Encoding 跟壓縮有關，瀏覽器發送 HTTP 請求告訴 Web 伺服器瀏覽器支援的壓縮形式，例如 Accept-Encoding: gzip, deflate\nAccept-Language Accept-Language 作用是聲明自己接受的語言。注意語言與字元集的區別，中文是語言，中文有多種字元集，例如 GB2312、GBK 等。例如 Accept-Language: en-US,en;q=0.8,zh-CN;q=0.6,zh;q=0.4,zh-TW;q=0.2\nUser-Agent User-Agent 的作用是瀏覽器用來告訴伺服器，用戶端使用的作業系統及版本、CPU 類型、瀏覽器及版本、瀏覽器轉譯引擎、瀏覽器語言、瀏覽器外掛程式等\n例如 User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:103.0) Gecko/20100101 Firefox/103.0 代表 64 位元 Linux 系統，Firefox 是 103.0 版本\n如果想要模擬各種不同的用戶端，只要修改 User-Agent，就可以偽裝成各種用戶端\nReferer Referer 主要用來讓伺服器判斷來源頁面，即使用者是從哪個頁面來的，網站通常用其統計使用者來源，也可以用作防盜連等\nConnection 從 HTTP/1.1 起，系統預設都開啟了 Connection: Keep-Alive，保持連線特性。Keep-Alive 不會永久保持連線，它有一個保持時間，可以在不同的伺服器軟體 (如 Apache) 中設定這個時間\nHost Host 的作用是指定被請求的主機和連接埠號，如果是 80 連接埠號會被自動隱藏\nHTTP 協定中的快取 快取無處不在，有瀏覽器端的快取、伺服器端的快取、代理伺服器的快取，還有 ASP.NET 頁面的快取、物件快取、資料庫快取等等\nHTTP 中具有快取功能的是瀏覽器快取和代理伺服器快取\nHTTP 快取是指當 Web 請求抵達快取時，如果本地有「已快取的」複本，就可以從本地儲存設備而不是從原始伺服器中提取這個文件\n快取的優點：減少了冗餘的資料傳輸，節省了傳輸時間；減少了伺服器的負擔，大大提高了網站的效能；加快了用戶端載入網頁的速度等\n如何判斷快取新鮮度 Web 伺服器透過以下兩種方式來判斷瀏覽器快取是否最新\n瀏覽器把快取檔案的最後修改時間透過 Header 的 If-Modified-Since 告訴 Web 伺服器。瀏覽器收到 HTTP 請求後，在 Header 中將檔案最後修改時間 Last-Modified 與請求訊息的 If-Modified-Since 相比較。若相同則說明檔案是最新的，則發送狀態碼 304 (Not Modified) 給瀏覽器用戶端；若不同則發送狀態碼 200 把最新檔案發送給瀏覽器用戶端\n瀏覽器把快取檔案的 ETag 透過 Header 的 If-None-Match 告訴 Web 伺服器\n與快取有關的 Header HTTP 請求訊息 Header 名稱 釋義 Cache-Control: max-age=0 以秒為單位 If-Modified-Since: Tue, 28 Jun 2022 00:50:56 GMT 快取檔案的最後修改時間 If-None-Match: \u0026ldquo;1771e0c387823da5329c20a76bece83c\u0026rdquo; 快取檔案的 ETag 值 Cache-Control: no-cache 不使用快取 Pragma: no-cache 不使用快取 HTTP 回應訊息 Header 名稱 釋義 Cache-Control: public 回應被快取，並且可以被多用戶存取使用 Cache-Control: private 回應只能作為私有快取，特定使用者使用 Cache-Control: no-cache 提醒瀏覽器要從伺服器提取文件進行驗證 Cache-Control: no-store 絕對禁止快取 (用於機密、敏感檔案) Cache-Control: max-age=60 60s 後快取過期 (相對時間) Date: Thu, 01 Sep 2022 21:56:36 GMT 目前回應發送的時間 Expires: Thu, 01 Sep 2022 21:57:37 GMT 快取過期的時間 (絕對時間) Last-Modified: Tue, 28 Jun 2022 00:50:56 GMT 伺服端檔案的最後修改時間 Etag: \u0026ldquo;1771e0c387823da5329c20a76bece83c\u0026rdquo; 伺服器檔案的 ETag 值 註：瀏覽器總是優先使用 cache-control，如果沒有時才考慮 Expires\nETag ETag 是 Entity Tag (實體標籤) 的縮寫，是根據實體內容生成的一段雜湊 (hash) 字串 (類似於 MD5 或者 SHA1 之後的結果)，可以表示檔案的狀態。當資源發生改變時，ETag 也隨之發生改變\n使用 ETag 主要是為了解決一些 Last-Modified 無法解決的問題，比如說某些伺服器不能精確得到檔案的最後修改時間、一些檔案最後修改時間改變了但是內容不變、某些檔案修改特別頻繁甚至達到了以秒為單位以下等\n註：Last-Modified 只能精確到秒\n瀏覽器不使用快取 使用 Ctrl+Shift+R 快捷鍵強制重新整理瀏覽器，可以讓瀏覽器不使用快取，即瀏覽器的 HTTP 請求訊息的 Header 中帶有 Cache-Control: no-cache，明確告訴 Web 伺服器不使用快取\n註：Pragma: no-cache 與 Cache-Control: no-cache 作用相同，只是 Pragma: no-cache 是 HTTP/1.0 定義的，保留為了相容性\n直接使用快取，不經過伺服器驗證 使用 Ctrl+R 快捷鍵重新整理瀏覽器，瀏覽器會去 Web 伺服器驗證快取\n如果在網址列直接輸入位址並存取，瀏覽器會「直接使用有效的快取」，不會發送 HTTP 請求去伺服器驗證快取，這種情況稱為快取命中 (cache hit)\n公有快取與私有快取 公有快取 Cache-Control: public 可以由多個使用者共享存取，而私有快取 Cache-Control: private 只能單個使用者存取使用\nHTTP 協定壓縮和 URL Encode HTTP 壓縮是指 Web 伺服器和瀏覽器之間壓縮傳輸文字內容的方法。HTTP 採用通用的壓縮演算法，比如用 gzip 來壓縮 HTML、JavaScript、CSS 檔案\nHTTP 內容編碼與壓縮的區別 在 HTTP 協定中，可以對 Body 部分進行編碼，如可以採用 gzip 這樣的編碼，從而達到壓縮的目的；也可以使用其他編碼方式把內容攪亂或加密，以此來防止未被授權的第三方看到文件的內容。所以 HTTP 壓縮其實就是 HTTP 內容編碼的一種\nHTTP 壓縮的過程 瀏覽器發送 HTTP 請求 Header 中帶 Accept-Encoding: gzip,deflate 告訴伺服器瀏覽器支援 gzip 壓縮\nWeb 伺服器接到 HTTP 請求後，先生成原始的 HTTP 回應，包含原始的 Content-Type 與 Content-Length；然後透過 gzip 對 HTTP 回應的 Body 進行編碼，並在編碼後 Header 中的 Content-Type 與 Content-Length 替換為壓縮後的大小，以及加上編碼方式 Content-Encoding: gzip；再把 HTTP 回應發送給瀏覽器\n瀏覽器接到 HTTP 回應後，根據 Content-Encoding: gzip 來對 HTTP 回應進行解碼，獲取到原始 HTTP 回應後顯示出網頁\n註：HTTP 請求也是可以編碼的，但是瀏覽器一般不會對 HTTP 請求編碼\n內容編碼類型 HTTP 定義了一些標準的內容編碼類型，並允許用擴展的形式添加更多的編碼\n在 Header 中的 Content-Encoding 就是使用這些標準化的代號來說明編碼時使用的演算法\n編碼 描述 gzip 表明實體採用 GNU zip 編碼 compress 表明實體採用 UNIX 的檔案壓縮程式 deflate 表明實體是用 zlib 的格式壓縮的 identity 表明沒有對實體進行編碼。當 Header 中沒有 Content-Encoding 時，預設為此情況 gzip、compress 以及 deflate 編碼都是無損壓縮演算法，用於減少傳輸訊息的大小，不會導致資訊缺失。其中 gzip 通常效率最高，使用最為廣泛\n深入理解 Cookie 機制 HTTP 協定是無狀態的，對於瀏覽器的每一次請求，伺服器都會獨立處理，不與之前或之後的請求發生關聯。即使是同一個瀏覽器發送了 3 個請求，伺服器也會獨立處理這 3 個請求，伺服器並不知道這 3 個請求是來自同一個瀏覽器\n工作階段機制與 Cookie 機制 伺服器需要識別瀏覽器請求，就必須弄清楚瀏覽器的請求狀態。既然 HTTP 協定是無狀態的，那就讓伺服器和瀏覽器共同維護一個狀態，這就是工作階段 (Session) 機制\n瀏覽器第一次請求伺服器時，伺服器建立一個工作階段，並將工作階段 ID (Session ID) 作為回應的一部分發送給瀏覽器\n瀏覽器儲存工作階段 ID，並在後續請求中帶上工作階段 ID\n伺服器取得請求中的工作階段 ID 就知道是不是同一個使用者了\n這樣後續請求與第一次請求就產生了關聯，而 Cookie 機制就是一種工作階段機制\n伺服器在記憶體中保存工作階段物件，瀏覽器可以使用 Cookie 機制保存工作階段 ID\nCookie 是什麼 Cookie 是瀏覽器用來儲存少量資料的一種機制，資料以 key=value 形式儲存，多個 Cookie 之間以分號 ; 分隔，瀏覽器發送 HTTP 請求時自動附帶 Cookie 資訊\nCookie 最主要的作用是用來做使用者認證，還可以用於保存使用者的一些其他資訊。也可以用於網際網路精準廣告定向技術，例如使用者瀏覽了某些商品，就可以用 Cookie 記錄下來，然後進行大數據深度分析，實現廣告精準投放\n鑒於此項，目前歐洲的一些國家已經對 Cookie 立法，並規定必須經過使用者的允許才可以保存使用者的 Cookie\nCookie 的屬性 根據網站不同， Cookie 有所不同\nExpires 表示 Cookie 失效的時間，如果不指定則在關閉瀏覽器或頁面時被瀏覽器刪除\nPath 表示 Cookie 所屬的路徑，asp.net 預設為 / 也就是根目錄\n假設在同一個伺服器上的目錄如下：/test/、/test/cd/、/test/dd，Cookie1 的 Path 在 /test/，Cookie2 的在 /test/cd/，那麼 /test/ 下的所有頁面都可以存取到 Cookie1，而 /test/dd/ 的子頁面不能存取 Cookie2。因為 Cookie 只能讓其 Path 路徑下的頁面存取\nHttpOnly 這是個關乎安全方面的屬性，將一個 Cookie 設定為 HttpOnly 後，透過 JavaScript 腳本將無法讀取到 Cookie 資訊，這能有效防止用 XSS 發起攻擊\n一般來說，跟登入相關的 Cookie 必須設定為 HttpOnly\nCookie 的分類與位置 類別 描述 工作階段 Cookie 臨時的 Cookie，記錄了使用者存取站點時的設定與偏好 (例如存取本站時的 Cookie)，關閉瀏覽器後將被刪除 持久 Cookie 儲存在硬碟上，有過期時間。不管退出瀏覽器還是重啟電腦都存在 網站的自動登入就是儲存持久 Cookie，在使用者再次存取相同網站時會先在硬碟中查找相關 Cookie 然後放到 HTTP 請求訊息中發送給伺服器\n那麼持久 Cookie 存在電腦哪裡呢？不同瀏覽器會在各自的獨立空間存放 Cookie，互不干擾\n例如 Linux 下 Firefox 的 Cookie 位置：~/.mozilla/firefox/xxxxxxxx.default-release/cookies.sqlite\nHTTP 基本認證 HTTP 協定是無狀態的，瀏覽器和 Web 伺服器之間可以透過 Cookie 來識別身分。那麼一些桌面應用程式是如何跟 Web 伺服器之間識別身分呢？\n一些網站和 Web 服務使用的是 HTTP 基本認證。有些桌面應用程式也透過 HTTP 協定跟 Web 伺服器互動，桌面應用程式一般不使用 Cookie，而是把使用者名稱+冒號+密碼用 Base64 編碼放在 HTTP 請求 Header 中的 Authorization 發送給服務端，這種方式叫 HTTP 基本認證 (Basic Authentication)\n在基本認證中，Web 伺服器可以拒絕一個事務，要求用戶端提供有效的使用者名稱和密碼，伺服器會傳回 401 狀態碼來初始化認證質詢，並用 WWW-Authenticate 回應首部指定要存取的安全域。瀏覽器收到質詢時，會打開一個對話框請求使用者輸入使用者名稱和密碼，然後將使用者名稱和密碼用 Base64 編碼，再用 Authorization 請求首部發送給伺服器\n一般家用路由器就是使用基本認證， RESTful API 就經常使用基本認證，使用命令 curl -u username:password URI 即可完成基本認證\nHTTP 基本認證的缺點 HTTP 協定是無狀態的，同一個用戶端對伺服器的每個請求都需要認證\nBase64 編碼是可逆的，非常容易破解，所以基本認證相當於以明文的方式傳輸使用者名稱和密碼。所以基本認證一定要用 HTTPS 加密傳輸，稍微安全一點\n使用基本認證登入後，除非關閉瀏覽器或清除歷史記錄，否則無法登出。而 Cookie 機制的話，網站可以提供登出方式以使 Cookie 失效\n無法防止 重送攻擊 摘要認證 摘要認證是針對基本認證存在的諸多問題而進行改良的方案。摘要認證是另一種 HTTP 認證協定，它試圖修復基本認證的嚴重缺陷，進行如下改進\n透過傳遞使用者名稱、密碼等計算出來的摘要來解決以明文方式在網路上發送密碼的問題\n透過伺服器產生隨機數 nonce 的方式防止惡意使用者捕獲並重送認證的握手過程\n透過用戶端產生隨機數 nonce 的方式支援用戶端對伺服器的認證\n透過對內容也加入摘要計算的方式，可以有選擇地防止對訊息內容的篡改\n參考文章 《圖解 HTTP》讀後總結及淺談 - yexca\u0026rsquo;Blog HTTP 狀態碼 - 菜鳥教程 IE/Firefox/Chrome 等瀏覽器保存 Cookie 的位置 - 腳本小娃子 - 博客園 「登錄」還是「登錄」？ - 知乎 重送攻擊 - 維基百科，自由的百科全書 通俗易懂：到底什麼是 REST API？ 表現層狀態轉換 - 維基百科，自由的百科全書 ","date":"2022-09-05T16:03:36+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/64/","title":"HTTP 學習"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 前言 儘管 Fedora 系統本身就內建 Java 環境，不過是 OpenJDK。有時候還是會需要用到 Oracle 的 Java 環境。\n下載 前往官網下載： Java Downloads | Oracle (下載需要登入)\n找到 java8-Linux，下載 x64 Compressed Archive (64位元的壓縮檔版本)\n撰寫本文時，檔案名稱為 jdk-8u341-linux-x64.tar.gz\n移至指定目錄 首先建立一個 Java 的目錄，在 /usr/local 中 1 sudo mkdir -p /usr/local/java 將檔案複製到此目錄 假設下載的檔案在 ~/Downloads，請進入下載目錄\n1 cd Downloads 然後複製到上述目錄\n1 sudo cp -r jdk-8u341-linux-x64.tar.gz /usr/local/java 解壓縮安裝檔 切換到 Java 目錄 1 cd /usr/local/java 解壓縮安裝檔 1 sudo tar xvzf jdk-8u341-linux-x64.tar.gz 設定 $PATH 環境變數 在 /etc/profile 檔案的結尾處加入以下內容 1 2 3 4 JAVA_HOME=/usr/local/java/jdk1.8.0_341 PATH=$PATH:$HOME/bin:$JAVA_HOME/bin export JAVA_HOME export PATH 更新可用的 Java 版本清單 直接執行以下指令 1 sudo update-alternatives --install \u0026#34;/usr/bin/java\u0026#34; \u0026#34;java\u0026#34; \u0026#34;/usr/local/java/jdk1.8.0_341/bin/java\u0026#34; 1 1 sudo update-alternatives --install \u0026#34;/usr/bin/javac\u0026#34; \u0026#34;javac\u0026#34; \u0026#34;/usr/local/java/jdk1.8.0_341/bin/javac\u0026#34; 1 1 sudo update-alternatives --install \u0026#34;/usr/bin/javaws.itweb\u0026#34; \u0026#34;javaws.itweb\u0026#34; \u0026#34;/usr/local/java/jdk1.8.0_341/bin/javaws.itweb\u0026#34; 1 使設定檔生效 首先重新載入系統全域的 PATH 檔案 1 source /etc/profile 重新啟動系統 1 reboot 切換 Java 版本 您可以執行指令來查看 Java 版本\n1 java -version 使用以下指令切換 1 sudo alternatives --config java 目前使用的 Java 版本前方會有「+」符號，找到對應的版本，輸入數字選擇即可。\n參考文章 如何在 Fedora {OpenJDK 和 Oracle JDK} 上安裝 Java？ ","date":"2022-09-02T17:37:51+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/63/","title":"Fedora 安裝 java8(Oracle JDK)"},{"content":" 📢 本文由 Gemini-3-flash 翻譯 該文章由 Hiyoung 編寫\n其文章: https://blog.hiyoung.icu/2022/09/01/906d191f9a59/ Aria2 是 Linux 下的一個下載工具，這裡介紹 Windows 下的安裝與設定，官方 Aria2 沒有 GUI 介面，所以配合 AriaNG 直接在 Web 介面進行操作。\nAriaNg 是一個讓 aria2 更容易使用的現代 Web 前端。AriaNg 使用純 html \u0026amp; javascript 開發，所以它不需要任何編譯器或執行環境。\n下載 Aria2+AriaNG 最新安裝包 首先先在官網下載安裝包\nAria2 的 Github 地址 – Aria2 官方文件 AriaNG 的 Github 地址 – AriaNG 官方文件 Aria2 選擇對應的作業系統下載壓縮檔即可，AriaNG 解壓縮後放在 Aria2 資料夾即可。\nAriaNg 現在提供三種版本：標準版、單檔案版和 AriaNg Native。\n標準版適合在 Web 伺服器中部署，提供資源快取和按需載入的功能。\n單檔案版適合本地使用，您下載後只要在瀏覽器中打開唯一的 html 檔案即可。\nAriaNg Native 同樣適合本地使用，並且不需要使用瀏覽器。\n新增設定檔 將檔案解壓縮至該目錄下後，你需要再新建立 4 個空檔案 (可以先建一個空 txt 檔案然後修改副檔名)：\nAria2.log （日誌檔案） aria2.session （用於記錄下載歷史，以便斷點續傳） aria2.conf （設定檔） HideRun.vbs （隱藏 cmd 視窗執行時用到的） 修改設定檔 打開剛才建立的 aria2.conf 空檔案，將以下內容填入（用記事本打開即可） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 ## \u0026#39;#\u0026#39;開頭為註解內容, 選項都有相應的註解說明, 根據需要修改 ## ## 被註解的選項填寫的是預設值, 建議在需要修改時再取消註解 ## ## 檔案儲存相關 ## # 檔案的儲存路徑(可使用絕對路徑或相對路徑), 預設: 當前啟動位置 dir=E:\\Aria2Download # 日誌檔案的儲存路徑 log=D:\\aria2-1.36.0-win-64bit-build1\\Aria2.log # 啟用磁碟快取, 0為停用快取, 需1.16以上版本, 預設:16M #disk-cache=32M # 檔案預先分配方式, 能有效降低磁碟碎片, 預設:prealloc # 預先分配所需時間: none \u0026lt; falloc ? trunc \u0026lt; prealloc # falloc和trunc則需要檔案系統和核心支援 # NTFS建議使用falloc, EXT3/4建議trunc, MAC 下需要註解此項 #file-allocation=none # 斷點續傳 continue=true ## 下載連線相關 ## # 最大同時下載任務數, 執行時可修改, 預設:5 #max-concurrent-downloads=5 # 同一伺服器連線數, 新增時可指定, 預設:1 max-connection-per-server=5 # 最小檔案分片大小, 新增時可指定, 取值範圍1M -1024M, 預設:20M # 假定size=10M, 檔案為20MiB 則使用兩個來源下載; 檔案為15MiB 則使用一個來源下載 min-split-size=10M # 單個任務最大執行緒數, 新增時可指定, 預設:5 #split=5 # 整體下載速度限制, 執行時可修改, 預設:0 #max-overall-download-limit=0 # 單個任務下載速度限制, 預設:0 #max-download-limit=0 # 整體上傳速度限制, 執行時可修改, 預設:0 #max-overall-upload-limit=0 # 單個任務上傳速度限制, 預設:0 #max-upload-limit=0 # 停用IPv6, 預設:false #disable-ipv6=true # 連線逾時時間, 預設:60 #timeout=60 # 最大重試次數, 設定為0表示不限制重試次數, 預設:5 #max-tries=5 # 設定重試等待的秒數, 預設:0 #retry-wait=0 ## 進度儲存相關 ## # 從工作階段檔案中讀取下載任務 input-file=D:\\aria2-1.36.0-win-64bit-build1\\aria2.session # 在Aria2退出時儲存`錯誤/未完成`的下載任務到工作階段檔案 save-session=D:\\aria2-1.36.0-win-64bit-build1\\aria2.session # 定時儲存工作階段, 0為退出時才儲存, 需1.16.1以上版本, 預設:0 #save-session-interval=60 ## RPC相關設定 ## # 啟用RPC, 預設:false enable-rpc=true # 允許所有來源, 預設:false rpc-allow-origin-all=true # 允許非外部存取, 預設:false rpc-listen-all=true # 事件輪詢方式, 取值:[epoll, kqueue, port, poll, select], 不同系統預設值不同 #event-poll=select # RPC監聽通訊埠, 通訊埠被佔用時可以修改, 預設:6800 #rpc-listen-port=6800 # 設定的RPC授權權杖, v1.18.4新增功能, 取代 --rpc-user 和 --rpc-passwd 選項 #rpc-secret=\u0026lt;TOKEN\u0026gt; # 設定的RPC存取用戶名, 此選項新版已廢棄, 建議改用 --rpc-secret 選項 #rpc-user=\u0026lt;USER\u0026gt; # 設定的RPC存取密碼, 此選項新版已廢棄, 建議改用 --rpc-secret 選項 #rpc-passwd=\u0026lt;PASSWD\u0026gt; # 是否啟用 RPC 服務的 SSL/TLS 加密, # 啟用加密後 RPC 服務需要使用 https 或者 wss 協定連線 #rpc-secure=true # 在 RPC 服務中啟用 SSL/TLS 加密時的憑證檔案, # 使用 PEM 格式時，您必須通過 --rpc-private-key 指定私鑰 #rpc-certificate=/path/to/certificate.pem # 在 RPC 服務中啟用 SSL/TLS 加密時的私鑰檔案 #rpc-private-key=/path/to/certificate.key ## BT/PT下載相關 ## # 當下載的是一個種子(以.torrent結尾)時, 自動開始BT任務, 預設:true #follow-torrent=true # BT監聽通訊埠, 當通訊埠被封鎖時使用, 預設:6881-6999 listen-port=51413 # 單個種子最大連線數, 預設:55 #bt-max-peers=55 # 打開DHT功能, PT需要停用, 預設:true enable-dht=false # 打開IPv6 DHT功能, PT需要停用 #enable-dht6=false # DHT網路監聽通訊埠, 預設:6881-6999 #dht-listen-port=6881-6999 # 本地節點查找, PT需要停用, 預設:false #bt-enable-lpd=false # 種子交換, PT需要停用, 預設:true enable-peer-exchange=false # 每個種子限速, 對少種的PT很有用, 預設:50K #bt-request-peer-speed-limit=50K # 用戶端偽裝, PT需要 peer-id-prefix=-TR2770- user-agent=Transmission/2.77 # 當種子的分享率達到這個數時, 自動停止做種, 0為一直做種, 預設:1.0 seed-ratio=0.7 # 強制儲存工作階段, 即使任務已經完成, 預設:false # 較新的版本開啟後會在任務完成後依然保留.aria2檔案 #force-save=false # BT校驗相關, 預設:true #bt-hash-check-seed=true # 繼續之前的BT任務時, 無需再次校驗, 預設:false bt-seed-unverified=true # 儲存磁力連結元數據為種子檔案(.torrent檔案), 預設:false bt-save-metadata=true 注意：你需要將下面四行的內容修改為你自己對應的檔案位置：\n1 2 3 4 5 6 7 8 # 檔案的儲存路徑(可使用絕對路徑或相對路徑), 預設: 當前啟動位置 dir=E:\\Aria2Download # 日志檔案的儲存路徑 log=D:\\aria2-1.36.0-win-64bit-build1\\Aria2.log # 從工作階段檔案中讀取下載任務 input-file=D:\\aria2-1.36.0-win-64bit-build1\\aria2.session # 在Aria2退出時儲存`錯誤/未完成`的下載任務到工作階段檔案 save-session=D:\\aria2-1.36.0-win-64bit-build1\\aria2.session 最後兩行的內容是儲存下載歷史的，如果有時 Aria2 不能啟動的話，清空裡面的內容就可以了。\n修改 HideRun.vbs 檔案 打開 HideRun.vbs 檔案，向其中新增\n1 CreateObject(\u0026#34;WScript.Shell\u0026#34;).Run \u0026#34;aria2c.exe --conf-path=aria2.conf\u0026#34;,0 接下來點擊執行 HideRun.vbs 檔案，（注意一定是 HideRun.vbs 檔案而不是那個執行檔！！），如果沒有報錯的話可以直接跳過下面這段：\n注意一下，這裡也可以在檔案前新增具體的檔案目錄前綴，但是前綴的檔案目錄中一定不要有空格。\n例如：\n1 CreateObject(\u0026#34;WScript.Shell\u0026#34;).Run \u0026#34;C:\\Users\\he ne\\Downloads\\aria2c.exe --conf-path=aria2.conf\u0026#34;,0 但是由於 he ne 這一資料夾裡面包含空格，就導致了系統不辨識，類似的常見錯誤位置還多見於：D:\\Program Files (x86)，這裡也是存在空格的，解決方式就是將這一前綴去除即可（但需要該 vbs 檔案位於該 aria2 資料夾下）。\n打開 index.html 打開裡面的 index.html 檔案，如果顯示 「已連線」，則表明搭建成功。\n新增開機自啟動 建立 HideRun.vbs 檔案的捷徑，放入 Windows 的開機自啟動目錄即可：\n在執行視窗中輸入：shell:startup\n這裡便會打開自啟動目錄資料夾，然後將該捷徑拖入即可。\n參考文章：\nAria2+AriaNG 配置指南（Win10 篇） AriaNG 文檔 ","date":"2022-09-01T23:06:38+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/62/","title":"Aria2+AriaNG 配置使用"},{"content":"notify: 📢 本文由 gemini-2.5-flash-lite 翻譯 引言 預設情況下 Fiddler 僅能攔截 HTTP 封包，需要進行設定後才能捕獲 HTTPS 流量。目前大部分網站都使用 HTTPS 或 HSTS，因此開啟 HTTPS 封包攔截功能是很有必要的。\nFiddler 設定 在「設定」-「HTTPS」頁面中，勾選「Capture HTTPS traffic」即可。下方的「Ignore server certificate errors(unsafe)」也可以勾選，但可能存在安全風險，之後請儲存設定。\n瀏覽器設定 啟用 HTTPS 攔截後，使用瀏覽器可能會出現憑證錯誤，提示「連線不安全」或「連線不是私密連線」等訊息。此時需要匯入相關憑證。以 Firefox 為例：\n首先下載 Fiddler 憑證。在上一部的設定頁面中，點擊「Export root cerificate to Desktop」即可將憑證匯出至桌面 (~/Desktop/)。\n然後進入 Firefox 的設定，在「隱私與安全性」-「憑證」頁面中匯入剛剛下載的憑證，並在彈出的視窗中全選信任相關選項。\n匯入完成後，即可正常瀏覽網頁，Fiddler 也能正常攔截 HTTPS 的請求與回應。\n","date":"2022-09-01T08:17:32+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/61/","title":"Fiddler 攔截 HTTPS 封包"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 引言 事實上指令檔案放在哪裡都可以自行決定，也就是自己想放哪就放哪，這些目錄不過是約定，但遵守約定會更好，畢竟沒有人會想要自己的電腦一團糟吧，尤其是 Linux。\n優先級 Linux 下的這些 bin 目錄都是存放指令的，如果不同的目錄下有相同名稱的可執行程式，將透過優先級決定先執行哪個目錄的二進位檔案，可以透過使用指令 echo $PATH 查看環境變數以確定指令執行的優先級，例如我的系統輸出如下：\n1 2 [yexca@yexca-PC ~]$ echo $PATH /home/yexca/.local/bin:/home/yexca/bin:/usr/local/bin:/usr/local/sbin:/usr/bin:/usr/sbin 從前到後以 : 分隔，越靠前優先級越高。\n/bin 系統的一些指令。bin 為 binary 的縮寫，主要放置一些系統的必備執行檔，例如：cat、cp、chmod、df、dmesg、gzip、kill、ls、mkdir、more、mount、rm、su、tar 等。\n/usr/bin 系統預裝的可執行程式，會隨著系統升級而改變。\n後續安裝的一些軟體的執行腳本。主要放置一些應用軟體工具的必備執行檔，例如：c++、g++、gcc、chdrv、diff、dig、du、eject、elm、free、gnome*、gzip、htpasswd、kfm、ktop、last、less、locale、m4、make、man、mcopy、ncftp、newaliases、nslookup、passwd、quota、smb*、wget 等。\n/usr/local/bin 提供給使用者放置自訂可執行程式的地方，推薦放在這裡，不會因為系統升級而覆蓋同名檔案。\n/sbin 一般是指超級使用者 (Superuser) 指令。主要放置一些系統管理的必備程式，例如：cfdisk、dhcpcd、dump、e2fsck、fdisk、halt、ifconfig、ifup、ifdown、init、insmod、lilo、lsmod、mke2fs、modprobe、quotacheck、reboot、rmmod、runlevel、shutdown 等。\n/usr/sbin 放置一些使用者安裝的系統管理的必備程式，例如：dhcpd、httpd、imap、in.*d、inetd、lpd、named、netconfig、nmbd、samba、sendmail、squid、swap、tcpd、tcpdump 等。\n參考文章 Linux /usr/bin與/usr/local/bin区别_学亮编程手记的博客-CSDN博客 /bin,/sbin,/usr/sbin,/usr/bin 目录之简单区别_IT农夫的博客-CSDN博客 ","date":"2022-08-31T00:27:09+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/60/","title":"Linux 下 bin 目錄"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 前言 個人在安裝 Fedora 後會安裝的一些應用程式和套件。\n修改終端機快速鍵 開啟「設定」-「鍵盤」，在最下方「檢視及自訂快速鍵」。\n自訂快速鍵\n名稱：Shell 終端機\n命令：gnome-terminal\n快速鍵：自訂\n更新系統 1 sudo dnf update 修改截圖快速鍵 還是習慣 Windows 的快速鍵\n上述「截圖」處「互動式截圖」改為「Win+Shift+S」。\n將使用者目錄改為英文 中文目錄在使用終端機操作時非常不便。\n首先將語系改為英文：\n1 export LANG=en_US 然後更新使用者目錄：\n1 xdg-user-dirs-gtk-update 這時，系統會提示您是否要將使用者目錄下的資料夾改為英文，請選擇「是」。\n然後再將系統語系切換回中文：\n1 export LANG=zh_CN.UTF-8 再次執行更新使用者目錄的指令：\n1 xdg-user-dirs-gtk-update 再次輸入上述指令時，系統會提示您是否要改回中文，請選擇「否」，並勾選「不再提醒」即可。\nVsCode 設定環境\n1 sudo rpm --import https://packages.microsoft.com/keys/microsoft.asc 1 sudo sh -c \u0026#39;echo -e \u0026#34;[code]\\nname=Visual Studio Code\\nbaseurl=https://packages.microsoft.com/yumrepos/vscode\\nenabled=1\\ngpgcheck=1\\ngpgkey=https://packages.microsoft.com/keys/microsoft.asc\u0026#34; \u0026gt; /etc/yum.repos.d/vscode.repo\u0026#39; 重新整理快取\n1 dnf check-update 使用dnf安裝\n1 sudo dnf install code 或者使用yum\n1 2 yum check-update sudo yum install code Edge 瀏覽器 從 Windows 轉移過來還不是特別習慣 Firefox，再加上多裝置同步功能很方便。（不過最安全的還是 IE 瀏覽器）\n下載 Microsoft Edge 網路瀏覽器 | Microsoft 下載.rpm檔案。\nMarkText 支援全平台的 Markdown 編輯器\nGitHub - marktext/marktext: 📝 一款簡潔優雅的 Markdown 編輯器，支援 Linux、macOS 和 Windows。 7-Zip 安裝\n1 yum install -y p7zip p7zip-plugins 壓縮\n1 7z a after.7z before 解壓縮\n1 7z x after.7z FeedReader RSS 閱讀器，我是從 Fedora 內建的「軟體」應用程式搜尋並下載的。\nTelegram 請記得將其放到/opt/Telegram目錄下再執行。\nTelegram Messenger 網易雲音樂 安裝與設定 Flatpak\n1 sudo dnf install flatpak 1 flatpak remote-add --if-not-exists flathub https://flathub.org/repo/flathub.flatpakrepo 安裝 netease.CloudMusic\n1 flatpak install flathub com.netease.CloudMusic 執行／點擊圖示執行\n1 flatpak run com.netease.CloudMusic 解除安裝\n1 flatpak uninstall com.netease.CloudMusic NVIDIA 驅動程式安裝 安裝\n1 sudo dnf install akmod-nvidia 選用\n1 sudo dnf install xorg-x11-drv-nvidia-cuda 安裝完成後重新啟動\n1 reboot note: 如果重新啟動後顯示「Nvidia kernel module missing falling back to Nouveau」\n首先請確保在 BIOS 中停用 Secure Boot\nCheck the version of akmods package installed by running rpm -qa akmods\nRun sudo akmods --force \u0026amp;\u0026amp; sudo dracut --force to build the kernel modules\n此處參考： Fedora 34 NVIDIA kernel module missing. Falling back to nouveau - #4，來自 vk2bea - Ask Fedora 如果上述方法無效，請嘗試使用以下方法：\n解除安裝所有與 NVIDIA 相關的套件：sudo dnf remove \\*nvidia\\*\n安裝驅動程式：sudo dnf install akmod-nvidia\n此處參考： Nvidia kernel module missing falling back to Nouveau (Fedora 36 PR) : Fedora 桌面最佳化 對我的筆記型電腦來說，預設字體有點太小了。\n1 sudo dnf install gnome-tweak-tool 安裝完成後，在應用程式中會有「最佳化」這個軟體。\nQQ/Icalingua++ 這個 Linux 版的 QQ 應該沒人會用吧，應該不會吧\n登入時和其他第三方應用程式一樣會報異常，也太離譜了。\nIcalingua++ 第三方版本： GitHub - Icalingua-plus-plus/Icalingua-plus-plus: A client for QQ and more. GNOME 擴充功能 不知道做什麼用，但感覺好像會派上用場。\n安裝主機連接器\n1 sudo dnf install chrome-gnome-shell gnome-extensions-app 前往 Latest extensions in GNOME Shell Extensions 安裝\nSpeedtest 依序輸入以下指令：\n1 curl -s https://packagecloud.io/install/repositories/ookla/speedtest-cli/script.rpm.sh | sudo bash 1 sudo yum install speedtest Fedora 已安裝 git，gcc，gdb，python，OpenSDK java\nLibreOffice\n參考文章 將 Fedora 下的使用者目錄改為英文 – 騰訊雲開發者社群-騰訊雲 CentOS Fedora 利用 p7zip 壓縮、解壓縮檔案_hkNaruto 的部落格-CSDN 部落格 Running Visual Studio Code on Linux fedora-netease-fedora 網易雲音樂安裝腳本。該腳本用於在 Fedora 上一鍵安裝網易雲音樂，測試於 Fedora KDE 30。 Howto/NVIDIA - RPM Fusion 安裝 Fedora 36 後# 需要做的 8 件事 桌面應用程式 - 如何使用 GNOME Shell 擴充功能 Howto/Secure Boot - RPM Fusion SPEEDTEST CLI: Internet connection measurement for developers ","date":"2022-08-24T12:13:30+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/59/","title":"Fedora 安裝後"},{"content":" 📢 本文由 Gemini-3-flash 翻譯 引言 今天使用 Git 推送時出現提示 fatal: unable to access 'https://github.com/yexca-VRChat/yexca-VRChat.github.io.git/': Failed to connect to 127.0.0.1 port 1081 after 2074 ms: Connection refused，重新啟動電腦也沒用，於是尋找解決方法 (為什麼不讓我存取自己的儲存庫)\n解決過程 經查閱相關資料後得知與代理伺服器（Proxy）有關，但我代理伺服器是設在路由器上啊\n於是我連線到另一個普通路由器再次推送，還是出現同樣的問題\n接著嘗試設定 Git 的代理伺服器也無果\n1 2 git config --global --unset http.proxy git config --global --unset https.proxy 最後想到我 WinXray 貌似、好像、大概開過吧，然後打開一看，果然開啟了 PAC，關閉後再次推送成功\n參考文章 fatal: unable to access \u0026lsquo;https://github.com/fmoraless/e-commerce.git/\u0026rsquo;: Failed to connect to 127.0.0.1 port 56832: Connection refuse · Issue #11981 · desktop/desktop 解決 git 下載出現：Failed to connect to 127.0.0.1 port 1080: Connection refused 拒絕連線錯誤_點亮～黑夜的博客-CSDN博客 git 報錯:解決拒絕存取問題_Huang_milk的博客-CSDN博客 ","date":"2022-08-15T02:44:47+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/58/","title":"GitHub 拒絕存取 Connection refused"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 引言 使用 Git 可以更好地和朋友一起管理程式碼，也方便同步程式碼。由於我比較喜歡靜態網站，因此使用 Git 同步網頁檔案非常實用。\n安裝 Git 登入 ROOT 帳號，依序輸入以下指令\n1 2 yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel perl-devel yum install git 建立使用者 建立一個 Git 使用者群組和使用者，用於執行 Git 服務\n1 2 groupadd git useradd git -g git 公開金鑰獲取 此部分為自己電腦的公開金鑰，以 Windows 為例\n在 %UserProfile%/.ssh/ 目錄下 id_rsa.pub 檔案儲存\n如果沒有此檔案，開啟 cmd 執行 ssh-keygen 指令會自動產生\n匯入公開金鑰 將待匯入的公開金鑰匯入 /home/git/.ssh/authorized_keys 檔案中，一行一個。如果沒有該檔案，則建立一個\n1 2 3 4 5 cd /home/git/ mkdir .ssh chmod 755 .ssh touch .ssh/authorized_keys chmod 644 .ssh/authorized_keys 然後使用 vi 或 vim 指令將公開金鑰匯入，使用參考： vim 文字編輯 初始化 Git 儲存庫 選定一個目錄作為 Git 儲存庫，假設為 /home/gitrepo/repo.git\n1 2 3 4 5 cd /home mkdir gitrepo chown git:git gitrepo cd gitrepo git init --bare repo.git 以上指令 Git 會建立一個空儲存庫，伺服器上的 Git 儲存庫通常都以 .git 結尾。然後，將儲存庫所屬使用者改為 git：\n1 chown -R git:git runoob.git 克隆儲存庫 1 2 3 git clone git@您的IP:倉庫目錄 // 例如 git clone git@127.0.0.1:/home/gitrepo/repo.git 同步目錄 自動同步功能用到的是 Git 的掛鉤 (hook) 功能\n進入儲存庫目錄 /home/gitrepo/repo.git\n1 2 cd /home/gitrepo/repo.git cd hooks 建立並編輯檔案 post-receive\n1 vi post-receive 在該檔案寫入以下內容\n1 2 #!/bin/sh git --work-tree=同步到的目錄 --git-dir=倉庫位置 checkout -f 例如\n1 2 #!/bin/sh git --work-tree=/home/www/hexo --git-dir=/home/gitrepo/repo.git checkout -f 然後設定該檔案讀寫權限\n1 chmod +x post-receive 改變 repo.git 目錄的擁有者為 git 使用者\n1 chown -R git:git /home/gitrepo/repo.git 更新程式碼 如果你能確定什麼都沒有改動過只是更新本地程式碼，直接使用\n1 git pull 正規流程\n1 2 3 4 5 6 7 8 9 // 查看本地分支檔案資訊，確保更新時不產生衝突 git status // 如果檔案有修改，可以還原到最初狀態; 如果檔案需要更新到伺服器上，應該先合併 (merge) 到伺服器，再更新到本地 git checkout – [file name] // 查看目前分支情況 git branch // 如果分支為本地分支，則需切換到伺服器的遠端分支 git checkout remote branch git pull 其他指令 1 2 3 4 git branch // 看看分支 git checkout aaa // 切換分支aaa git branck aaa // 建立aaa分支 git chechout -b aaa // 本地建立 aaa分支，同時切換到aaa分支。只有提交的時候才會在伺服器上建立一個分支 禁用 git 使用者的 shell 登入權限 出於安全考量，我們要讓 git 使用者不能透過 shell 登入。可以編輯 /etc/passwd 來實現\n1 vi /etc/passwd 將\n1 git:x:1004:1004::/home/git:/bin/bash 改為\n1 git:x:1004:1004::/home/git:/usr/bin/git-shell 這樣 git 使用者可以透過 ssh 正常使用 git，但是無法登入 sehll\n參考文章 Linux chown 指令-菜鳥教學 Git 伺服器建置-菜鳥教學 Git - 產生 SSH 公開金鑰 SSH key 的介紹與在 Git 中的使用 - 簡書 Git - 在伺服器上建置 Git git 更新程式碼到本地_ftToday 的部落格-CSDN 部落格 如何在伺服器上建置 hexo 部落格-阿里云開發者社群 Linux 權限詳解（chmod、600、644、700、711、755、777、4755、6755、7755）_林20 的部落格-CSDN 部落格 詳細解析 Linux /etc/passwd 檔案 - Jtianlin - 部落格園 ","date":"2022-08-13T10:28:50+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/57/","title":"建立 Git 伺服器並同步到指定目錄"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 這篇文章由 Hiyoung 撰寫\n其文章: https://blog.hiyoung.icu/2022/08/11/607cac6fe835/ 現在主流串流媒體網站都支援外連嵌入程式碼，但是 B 站 (什麼時候倒閉?) 現在 (2022/8/11) 內建的外連引用預設為 360P，且不能調節解析度，非常地討厭，與 Youtube 相比高下立判，下面重點介紹一下 B 站引用外連的參數和方法。\nBilibili 外連引用 原版引用連結：\n1 \u0026lt;pre class=\u0026#34;language-html\u0026#34; data-info=\u0026#34;HTML\u0026#34; data-role=\u0026#34;codeBlock\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token tag\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token tag\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026lt;\u0026lt;/span\u0026gt;iframe\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token attr-name\u0026#34;\u0026gt;src\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token attr-value\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation attr-equals\u0026#34;\u0026gt;=\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;//player.bilibili.com/player.html?aid=80433022\u0026amp;bvid=BV1GJ411x7h7\u0026amp;cid=137649199\u0026amp;page=1\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token attr-name\u0026#34;\u0026gt;scrolling\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token attr-value\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation attr-equals\u0026#34;\u0026gt;=\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;no\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token attr-name\u0026#34;\u0026gt;border\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token attr-value\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation attr-equals\u0026#34;\u0026gt;=\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;0\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token attr-name\u0026#34;\u0026gt;frameborder\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token attr-value\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation attr-equals\u0026#34;\u0026gt;=\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;no\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token attr-name\u0026#34;\u0026gt;framespacing\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token attr-value\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation attr-equals\u0026#34;\u0026gt;=\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;0\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token attr-name\u0026#34;\u0026gt;allowfullscreen\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token attr-value\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation attr-equals\u0026#34;\u0026gt;=\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;true\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token tag\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token tag\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026lt;/\u0026lt;/span\u0026gt;iframe\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; 修改後引用連結：\n1 \u0026lt;pre class=\u0026#34;language-html\u0026#34; data-info=\u0026#34;HTML\u0026#34; data-role=\u0026#34;codeBlock\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token tag\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token tag\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026lt;\u0026lt;/span\u0026gt;iframe\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token attr-name\u0026#34;\u0026gt;src\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token attr-value\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation attr-equals\u0026#34;\u0026gt;=\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;//player.bilibili.com/player.html?aid=80433022\u0026amp;bvid=BV1GJ411x7h7\u0026amp;cid=137649199\u0026amp;page=1\u0026amp;as_wide=1\u0026amp;high_quality=1\u0026amp;danmaku=1\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token attr-name\u0026#34;\u0026gt;scrolling\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token attr-value\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation attr-equals\u0026#34;\u0026gt;=\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;no\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token attr-name\u0026#34;\u0026gt;border\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token attr-value\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation attr-equals\u0026#34;\u0026gt;=\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;0\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token attr-name\u0026#34;\u0026gt;frameborder\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token attr-value\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation attr-equals\u0026#34;\u0026gt;=\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;no\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token attr-name\u0026#34;\u0026gt;framespacing\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token attr-value\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation attr-equals\u0026#34;\u0026gt;=\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;0\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token attr-name\u0026#34;\u0026gt;allowfullscreen\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token attr-value\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation attr-equals\u0026#34;\u0026gt;=\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;true\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token tag\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token tag\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026lt;/\u0026lt;/span\u0026gt;iframe\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; 嗶哩嗶哩外連 key 說明 key 說明 aid 之前 B 站使用的 AV 號 bvid 目前的 BV 號 page 第幾個影片, 起始下標為 1 (預設值也是 1) 就是 B 站影片選集裡的第幾個影片 as_wide 是否寬螢幕 【1: 寬螢幕, 0: 小螢幕】 high_quality 是否高畫質 【1: 高畫質 (最高 1080p) / 0: 最低影片畫質 (預設)】 danmaku 是否開啟彈幕 【1: 開啟 (預設), 0: 關閉】 vd_source=XXX\u0026amp;t=XXX 可加上精準空降位址 YouTube 外連引用 使用預設的 YouTube 外連即可，更進階功能可自行去 官方教學 學習。\n1 \u0026lt;pre class=\u0026#34;language-html\u0026#34; data-info=\u0026#34;HTML\u0026#34; data-role=\u0026#34;codeBlock\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token tag\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token tag\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026lt;\u0026lt;/span\u0026gt;iframe\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token attr-name\u0026#34;\u0026gt;width\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token attr-value\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation attr-equals\u0026#34;\u0026gt;=\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;560\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token attr-name\u0026#34;\u0026gt;height\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token attr-value\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation attr-equals\u0026#34;\u0026gt;=\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;315\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token attr-name\u0026#34;\u0026gt;src\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token attr-value\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation attr-equals\u0026#34;\u0026gt;=\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;https://www.youtube.com/embed/OgcCOwj7wNY\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token attr-name\u0026#34;\u0026gt;title\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token attr-value\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation attr-equals\u0026#34;\u0026gt;=\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;YouTube video player\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token attr-name\u0026#34;\u0026gt;frameborder\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token attr-value\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation attr-equals\u0026#34;\u0026gt;=\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;0\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token attr-name\u0026#34;\u0026gt;allow\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token attr-value\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation attr-equals\u0026#34;\u0026gt;=\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026#34;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token attr-name\u0026#34;\u0026gt;allowfullscreen\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token tag\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token tag\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026lt;/\u0026lt;/span\u0026gt;iframe\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;token punctuation\u0026#34;\u0026gt;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; 影片演示 請前往 https://blog.hiyoung.icu/2022/08/11/607cac6fe835/ 觀看效果\nYoutube 1 2 3 4 5 6 7 8 9 \u0026lt;iframe allow=\u0026#34;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\u0026#34; allowfullscreen=\u0026#34;\u0026#34; frameborder=\u0026#34;0\u0026#34; height=\u0026#34;315\u0026#34; loading=\u0026#34;lazy\u0026#34; src=\u0026#34;https://www.youtube.com/embed/ucbx9we6EHk\u0026#34; title=\u0026#34;YouTube video player\u0026#34; width=\u0026#34;560\u0026#34;\u0026gt;\u0026lt;/iframe\u0026gt; ### Bilibili (修改前) \u0026lt;iframe allowfullscreen=\u0026#34;true\u0026#34; border=\u0026#34;0\u0026#34; frameborder=\u0026#34;no\u0026#34; framespacing=\u0026#34;0\u0026#34; scrolling=\u0026#34;no\u0026#34; src=\u0026#34;//player.bilibili.com/player.html?aid=499408391\u0026amp;bvid=BV16K411N7qj\u0026amp;cid=230404689\u0026amp;page=1\u0026amp;as_wide=1\u0026#34;\u0026gt; \u0026lt;/iframe\u0026gt; ### Bilibili (修改後) \u0026lt;iframe allowfullscreen=\u0026#34;true\u0026#34; border=\u0026#34;0\u0026#34; frameborder=\u0026#34;no\u0026#34; framespacing=\u0026#34;0\u0026#34; scrolling=\u0026#34;no\u0026#34; src=\u0026#34;//player.bilibili.com/player.html?aid=499408391\u0026amp;bvid=BV16K411N7qj\u0026amp;cid=230404689\u0026amp;page=1\u0026amp;high_quality=1\u0026amp;danmaku=1\u0026#34;\u0026gt; \u0026lt;/iframe\u0026gt; 參考資料： Sanarous 部落格 和 Google 外連 API 教學 ","date":"2022-08-12T00:11:17+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/56/","title":"部落格影片外連引用"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 前言 最早接觸 RSS 還是逛神社的時候，但當我知道有這麼個東西的時候 RSS 就幾乎凋零，不過還有類似於 RSSHub 之類的還在繼續為之奮鬥，不過 RSSHub 時常因網路問題無法連線，慢慢地就放棄了。隨著發現的部落格越來越多，為了能夠即時獲取更新以及記錄自己閱讀過以及未閱讀的文章，我再次使用 RSS\nRSS 簡介 RSS 的全稱是 Really Simple Syndication（簡易資訊聚合），它是一種訊息來源的格式規範，網站可以按照這種格式規範提供文章的標題、摘要、全文等資訊給訂閱使用者，使用者可以透過訂閱不同網站 RSS 連結的方式將不同的資訊來源進行聚合，在一個工具裡閱讀這些內容\n換句話說，與當前主流媒體推薦內容使我們被動獲取資訊不同，RSS 是主動尋找知識的過程，需要我們主動發掘資訊來源，而且只會顯示自己訂閱資訊來源的內容\n為什麼使用 RSS 拿起手機，打開資訊類 App，首頁就是推薦，再加上永遠刷不到底部的設計和基於大數據的喜好推薦，很容易就將一天的時間陷入這些觀點單一、毫無營養的內容。我不喜歡這種時間消逝的感覺，雖然學習之餘需要放鬆刷一下，但我始終堅持放鬆應該要由自己掌控，不應被這種被動式接受，所以使用 RSS 也是我對資訊繭房的一種抵抗吧\n往小了說，可能是為了標記自己未閱讀的文章，獲取自己關注的部落格的文章，也為了不錯過大神的文章吧\n往大了說，在現如今推薦演算法不斷升級、不斷精確的情況下，資訊繭房愈加嚴重，慢慢地失去了主動獲取資訊的能力，從而導致自己視野受限，甚至於失去學習能力\n如何使用 首先需要 RSS 閱讀器，我選擇 QuiteRSS ，是一款開源軟體\n然後需要 RSS 訂閱來源，這個需要自行尋找啦，如果網站不提供可以到 RSSHub 尋找是否有發布相關訂閱來源 (請保持網路環境正常)\n如何尋找 RSS 訂閱來源： 如何尋找要與 Feedzy RSS Feeds 一起使用的 RSS Feed URL 比如說本站的簡體中文 RSS 訂閱來源： https://blog.yexca.net/feed.xml 檢測是否為訂閱來源： Feed Validator for Atom and RSS 複製訂閱來源，打開軟體，建立新訊息來源即可\n後記 唉，本來想著描述得挺好的，但真正寫的時候我發現我無法使用語言來表達自己所要抒發的情感，不是無法使用語言表達，只是可能我深受各種網路資訊毒害，可能……已經不會寫文章了吧……\n寫之前想了很多，但真到寫的時候卻完全不知道怎麼表達，就這樣吧！\n參考文章/推薦閱讀 求問神社的 rss 是啥啊 高效獲取資訊，你需要這份 RSS 入門指南 - 騰訊雲開發者社區 RSS - 維基百科 RSS 凋零——主動獲取資訊到推送時代 什麼是 RSS？ ","date":"2022-08-09T16:08:14+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/55/","title":"RSS"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 前言 昨日玩遊戲時接取第一個任務的記錄，由於是複述，部分細節可能與實際情況不同。\n接取任務 在通過某神秘人的考驗後取得 HackShop 的網站，接到第一個任務。\n任務內容為：「The client wants the login credentials of the user Daronane. The remote ip of the victim is 54.44.37.52. It\u0026rsquo;s important that you access the correct machine behind the public ip. The victim\u0026rsquo;s ip LAN is 172.16.6.7。」\n任務分析 任務要求為 Daronane 的登入憑證，受害者的公開 IP 位址為 54.44.37.52，區域網路 IP 位址為 172.16.6.7。\n初步試探 依照 Grey Hack 單人模式遊戲攻略（1）-MapleGe 文章所述的方法嘗試。\n首先使用 whois 指令取得管理員電子郵件地址為 Eggett@sabmi.net，向該電子郵件寄送 Login issue 郵件以取得 Daronane 的密碼 pierra。\n嘗試使用 SSH 連線 54.44.37.52，輸入指令 ssh Daronane@pierra 54.44.37.52 後發現連線失敗，錯誤訊息為 incorrect user/password。\n我懷疑是我輸入錯誤 (畢竟是手動輸入的帳號密碼)，然後嘗試了幾次，甚至複製貼上也是帳號或密碼錯誤，便停止嘗試。\n我使用瀏覽器存取該 IP 位址，自然是沒什麼線索，只有一行文字 Metlifegroup. Everything you need for your tech company 與一張圖片 (貌似是樹莓派)，猜測該網站可能是一個討論區，而受害者 Daronane 為該討論區的使用者？\n遊戲中文化 想到在存取 HackShop 時彈出的 Exploits 教學有部分我沒看懂，於是尋找該遊戲的中文化，開啟創意工坊，果然找到了該遊戲的繁體中文化 [简体中文](simplified Chinese)，訂閱後重新啟動遊戲，卻發現介面沒有中文化。\n找到創意工坊的下載位址：steam資料夾\\steamapps\\workshop\\content\\605230\\2825584160。透過閱讀 README.md 檔案得知，需要將該資料夾下的內容放至 C:\\Users\\%UserName%\\AppData\\LocalLow\\Loading Home\\Grey Hack\\ 資料夾下。\n事實上，只需要將 custom_lang.json 放入上述資料夾即可。\n重新進入遊戲後，在左側的 language 選擇 Chinese 即可中文化。\n閱讀手冊 閱讀中文化後手冊的 Exploits 部分 (發現跟沒中文化差不多)，還是不大理解這個東西是做什麼的。\n繼續探尋 繼續搜尋相關攻略，卻一無所獲，直到看到文章 Grey Hack: 一個比較簡單的任務 - 嗶哩嗶哩 。\n文章中腳本小子一詞使我了解到這個 Exploits 相當於現實中的攻擊腳本。\n錯誤探索 到 HackShop 下載工具 scanlib 與 scanrouter。\n嘗試執行指令 scanlib 54.44.37.52，提示 Missing metaxploit，看不懂。\n使用指令 nmap 54.44.37.52，得知該伺服器開放兩個連接埠，分別為 22 和 80，各自提供 SSH 與 HTTP 服務。\n使用指令 scanrouter 得知該伺服器有 Kernel_router.so:V1.0.0，然後尋找相關腳本，找到一個腳本描述為 Get access to a shell，沒有要求。\n我將該腳本下載到 /home/yexca/hacktool，然後在終端機進入該資料夾並輸入指令 KernelRouterAccess 54.44.37.52，錯誤提示為 Can't find metaxploit library in the /lib path or the current folder。\n註：一開始沒有重新命名，後來重新命名為 KernelRouterAccess，本文以此名稱為例撰寫，本文其他腳本均為後續重新命名，與商店中原名稱不同\n從錯誤來看是缺少檔案，看到 /lib 難道是對方伺服器沒有相應檔案無法辨識，因此無法進入嗎？\n再次思索 考慮到透過 nmap 指令得知這個伺服器開放 22 和 80 埠，又上述猜測受害者為該討論區使用者，於是到 HackShop 尋找 http 腳本，找到一個腳本描述為 Grant access to the file /etc/passwd and decipher its contents，要求為 Minimum number of 1 users registered in the computer，也就是至少一名使用者，該網站為討論區，估計應該不會直接使用 root 帳號進行開發吧，而且估計是多使用者開發。\n下載腳本後輸入指令 HttpPasswd 54.44.37.52 80，和使用上一個腳本一樣提示 Can't find metaxploit library in the /lib path or the current folder。\n我並沒有感到驚訝，因為透過 scanrouter 指令掃描只發現 Kernel_router.so:V1.0.0，沒有 libhttp.so 之類的函式庫。\n事實上我選擇 HTTP 腳本，也是由於上述文章提到其實只要完成任務就行，不需要遠端連線，你在本機執行腳本也不會留下痕跡。\n然後我想著那就繼續嘗試 SSH 吧，便進入 HackShop 尋找相應腳本，找到一個腳本描述為 Take advantage of a vulnerability in the ssh service to inject a new password to a registered user，要求為 Any user logged in the computer，也就是有使用者登入過，考慮到開發該網站一定需要登入，所以該要求應該可以達到。\n下載腳本後輸入指令 SSHPasswd 54.44.37.52 22，還是提示 Can't find metaxploit library in the /lib path or the current folder。\n這**怎麼玩？？？貴伺服器的 /lib 是什麼都沒有嗎？難道我要每種腳本都試一遍來確定 /lib 有什麼嗎？？？？那我豈不是會破產啊。\n進入正軌 於是我借助搜尋引擎尋找攻略，卻發現沒有。\n再次回想之前看到的錯誤條件 Can't find metaxploit library in the /lib path or the current folder，我只看到了前面的 /lib 以及看不懂的 metaxploit，仔細查看後面有一個 or the current folder，這個 目前資料夾 是指什麼呢？難道是我電腦上該腳本所在的資料夾，那我為了進攻豈不是要把相應的函式庫像 libssh.so 之類的都下載一遍？\n開啟黑市，並沒有像 libssh.so 之類的函式庫，聯想到該遊戲有指令 apt-get，在現實 Linux 中可以下載相關程式，於是在遊戲中輸入指令 apt-get search ssh，果不其然有一個 libssh.so，使用指令 apt-get install libssh.so 安裝 SSH。\n安裝完成後輸入指令 SSHPasswd 54.44.37.52 22，結果還是提示 Can't find metaxploit library in the /lib path or the current folder。\n我真是服了！！！\n再次開啟 HackShop，我把 Tools 下的每個商品都看了一遍，其中 metaxploit.so 引起我的注意，這不就是錯誤訊息中的那個 metaxploit 嘛！再結合錯誤訊息中的 current folder，是不是因為缺少這個東西才報錯啊。\n下載至腳本所在的資料夾 (/home/yexca/hacktool)，考慮到 scanrouter 指令只掃描到 Kernel_router.so，嘗試執行 KernelRouterAccess 54.44.37.52，果然，取得了進入權限！\n取得權限 取得進入權限後，想著先去刪除紀錄檔，輸入指令 FileExplorer.exe，存取 /var/system.log，提示 Permission denied，權限不足。然後發現這個腳本取得的是訪客權限，那我找密碼檔案吧，存取 /etc/passwd，還是提示 Permission denied (事實上我幾乎把該電腦的檔案都看了一遍)。\n啊這，那我買這個腳本有什麼用啊！\n因為 SSH 腳本是更改密碼，風險較高，所以我使用 HTTP 腳本來取得密碼。輸入指令 HttpPasswd 54.44.37.52 80，結果提示 can't read /etc/passwd. Permission denied，看到取得的權限是 guest，我**\n最後還是使用 SSH 腳本，輸入指令 SSHPasswd 54.44.37.52 22，輸入新密碼 114514，成功修改了 Farraze 的密碼。\n輸入指令 ssh Farraze@114514 54.44.37.52，成功進入受害者的機器，輸入指令 cat /etc/passwd，成功取得 root 的密碼加密資訊。\n在本機新建一個檔案 (touch mima.txt)，將 root 密碼資訊複製到裡面，然後解密 decipher mima.txt，成功取得 root 的密碼為 44444 (這密碼也太隨便了吧)。\n輸入指令 exit 中斷連線，接著輸入 ssh root@44444 54.44.37.52，成功以 root 權限登入。\n進入機器 進入後第一件事就是刪除紀錄檔，然後該機器的使用者有 Ralancl 和 Farraze，沒有受害者 Daronane，果然是討論區使用者嗎？但我將這台機器翻了一遍也沒找到相關東西 (順便把這兩個帳戶的錢轉到我的帳戶上啦~)\n回想任務內容，提到了 IP 172.16.6.7。\n輸入指令 ping 172.16.6.7，顯示 Ping successful，使用自己的電腦無法 Ping 通 (這根本是廢話，內部網路的機器怎麼可能 Ping 通)。\n輸入指令 nmap 172.16.6.7 查看開放埠，提示 command not found，指令未找到。\n啊這，那我只好將我電腦的指令檔案放到該電腦的 /bin 目錄下了。\n複製過去後再次輸入指令 nmap 172.16.6.7，可以看到開放了 3306 埠，服務為 employees，這是什麼東西？\n透過搜尋引擎得知 3306 埠一般為資料庫埠，也就是說需要使用 SQL 的腳本。\n取得密碼 進入 HackShop，搜尋相關腳本，找到一個腳本描述為 Take advantage of a vulnerability in the sql service to inject a new password to a registered user，要求為 Any user logged in the computer，也就是有使用者登入過，資料庫的建立必然要有使用者登入過啊。\n下載後輸入指令 SqlChangePasswd 172.16.6.7 3306，提示 Connection refused. Address unreachable，存取被拒。確實，資料庫肯定是白名單的啦。\n將腳本與 metaxploit.so 放到受害者機器 /root 資料夾下，再次輸入指令，修改密碼為 114514，修改使用者為 Osquel。\n那麼現在問題來了，我修改密碼然後呢？這伺服器只開放了 3306 埠，我也進不去啊 XD\n好吧，再次進入 HackShop，搜尋相關腳本，找到一個腳本描述為 Prints the contents of the file /etc/passwd，要求為 Any user logged in the computer，也就是有使用者登入過，和剛剛腳本的要求一樣。\n將腳本放到受害者機器 /root 資料夾下，輸入指令 SqlPrintPasswd 172.16.6.7 3306，得到該機器所有使用者的密碼，其中有受害者 Daronane 的。\n複製到自己的電腦並解密後得到密碼為：pierra。\n？？？我將此密碼傳送給客戶，得到了肯定的答覆？？？\n我**\n精彩！ (來自於 YouTuber 黑鏢客 的梗)\n後記 一開始就透過電子郵件取得了密碼，然後我一番折騰後再次取得了密碼 (這真的讓我超無言的)。\n收入為 200，但我購買腳本花費遠大於 200 (整體來說還是蠻虧的)，不過腳本可以重複使用，而且探索的過程也是很有趣的喔！\n這款遊戲的攻略可以說幾乎沒有啊，如果您正在尋找相關攻略，希望這篇文章能有所幫助。\n","date":"2022-08-03T22:41:06+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/54/","title":"記錄 Grey Hack 第一個任務 (取得密碼)"},{"content":" 📢 本文由 Gemini-3-flash 翻譯 這篇文章由 Hiyoung 撰寫\n其文章: https://blog.hiyoung.icu/2022/08/03/0b5e2db181ab/ 最近經常要使用 GitHub 儲存我學習過程中的程式碼，發現無法直接上傳資料夾，於是在網路上查了一下如何使用 Git 上傳，所以寫篇部落格文章記錄一下。\nGitHub 端操作 1. 複製儲存庫網址 本地端操作 1. 在本地端新建一個空資料夾 我這裡已經 clone 完成\n2. 在資料夾內開啟 Git Bash 視窗 3. Clone 遠端儲存庫 1 2 \u0026lt;pre class=\u0026#34;language-bash\u0026#34; data-info=\u0026#34;bash\u0026#34; data-role=\u0026#34;codeBlock\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token function\u0026#34;\u0026gt;git\u0026lt;/span\u0026gt; clone + 你的儲存庫網址 \u0026lt;span class=\u0026#34;token function\u0026#34;\u0026gt;git\u0026lt;/span\u0026gt; clone https://github.com/hiyoung3937/study_code.git //範例 4. 直接將需要上傳的檔案拖入即可 5. 上傳 1 2 3 4 5 \u0026lt;pre class=\u0026#34;language-bash\u0026#34; data-info=\u0026#34;bash\u0026#34; data-role=\u0026#34;codeBlock\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;token builtin class-name\u0026#34;\u0026gt;cd\u0026lt;/span\u0026gt; study_code.git //根據自己的遠端儲存庫名稱輸入 \u0026lt;span class=\u0026#34;token function\u0026#34;\u0026gt;git\u0026lt;/span\u0026gt; init \u0026lt;span class=\u0026#34;token function\u0026#34;\u0026gt;git\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token function\u0026#34;\u0026gt;add\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token builtin class-name\u0026#34;\u0026gt;.\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;token function\u0026#34;\u0026gt;git\u0026lt;/span\u0026gt; commit -m “你的提交訊息” \u0026lt;span class=\u0026#34;token function\u0026#34;\u0026gt;git\u0026lt;/span\u0026gt; push 指令說明 clone + 儲存庫網址 複製你的儲存庫至本地端 cd + 你的遠端儲存庫名 進入到遠端儲存庫內 (根據自己的儲存庫名稱輸入) git init 初始化 Git git add . 將工作區的檔案新增至暫存區（「.」是目前目錄下的所有檔案，也可只輸入資料夾名稱） git commit -m “你的提交訊息” 將暫存區的檔案新增至本地端儲存庫 git push 推送至遠端儲存庫（可能需要輸入帳號與密碼） ","date":"2022-08-03T12:49:27+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/53/","title":"使用 Git 上傳檔案至 GitHub"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 前言 哪個男孩不想用命令列執行一些東西來耍帥呢？之前我稍微了解過 youtube-dl，但看起來太複雜就沒去用，今天嘗試用過之後發現超級好用啊！\n環境 安裝 Python3.7+ 直接到 Python 官網 下載並安裝即可，安裝時記得勾選Add Python x.x to PATH\n安裝 yt-dlp yt-dlp 是基於 youtube-dl 修改的，實際測試下載速度比較快。\n下載 進入 releases 下載 yt-dlp.exe\n設定 把下載的檔案放到一個固定位置，開啟 我的電腦 的 內容，進入 進階系統設定 -\u0026gt; 環境變數 -\u0026gt; 系統變數，選取 Path，點選編輯，在新視窗點選新增，輸入 yt-dlp.exe 檔案所在的資料夾路徑。\n接著連續點三個 確定 來關閉所有視窗。\n測試 按下 Win+R 輸入 cmd，然後按 Enter 鍵。\n在 cmd 中輸入 yt-dlp，如果出現 Usage: yt-dlp [OPTIONS] URL [URL...] 就代表設定成功。\n更新 在 cmd 中輸入 yt-dlp -U 即可。\n下載影片 直接在 cmd 中輸入 yt-dlp+空白鍵+YouTube 影片連結 即可開始下載。\n預設會下載 720P 的畫質，儲存位置在 C:/Users/%UserName%/\n修改下載儲存位置 在 C:\\Users\\%UserName%\\AppData\\Roaming 建立一個資料夾並命名為 yt-dlp，接著進入剛建立的資料夾內，再建立一個檔案 config.txt。\n在檔案內輸入以下程式碼\n1 -o \u0026#39;C:/Users/%UserName%/Downloads/Video/%(title)s.%(ext)s\u0026#39; 其中 C:/Users/%UserName%/Downloads/Video/ 為下載目錄。\n%(title)s.%(ext)s 為儲存檔案名稱的格式，此處為影片標題.影片副檔名。\n下載 1080P 因為 1080P (含) 以上的影片是音訊和視訊分離的，所以需要先下載 ffmpeg。\nffmpeg 進入 官網 ，左下角選擇系統類型，接著選擇下載。\n我選擇的是 Releases · BtbN/FFmpeg-Builds ，下載 ffmpeg-n5.0-latest-win64-gpl-5.0.zip。\n接著放到一個固定資料夾，並把 bin 檔案目錄放到系統變數裡。\n測試 開啟 cmd，輸入 ffmpeg -version，如果出現版本號就代表設定成功。\n查詢命令 輸入 yt-dlp -D [URL] 即可查看目前影片的所有格式 (僅查詢，不下載)。\n下載命令 輸入 yt-dlp -f [ID] [URL] 來下載指定格式的影片，也可以使用 [ID]+[ID] 組合來下載影片和音訊，也就是 yt-dlp -f [ID]+[ID] [URL]，下載完成後會自動合併。\n註：下載最高畫質與音訊：-f \u0026quot;bv+ba/b\u0026quot;\n呼叫 aria2 在下載命令後加入 --external-downloader aria2c --external-downloader-args \u0026quot;-x 16 -k 1M\u0026quot; 即可。\n下載字幕 1 2 3 4 5 6 7 outube-dl --write-sub [url] // 這樣會下載一個 vtt 格式的英文字幕和 mkv 格式的 1080p 影片下來 youtube-dl --write-sub --skip-download [url] // 下載單獨的 vtt 字幕檔，而不會下載影片 youtube-dl --write-sub --all-subs [url] // 下載所有語言的字幕 (如果有的話) youtube-dl --write-auto-sub [url] // 下載自動產生的字幕 (YouTube only) 下載影片清單 1 2 3 4 5 6 7 youtube-dl -f [format code] [palylist_url] // 這種方式可以下載指定清晰度的 mp4 影片 youtube-dl [playlist_url] // 下載影片清單，這種方式下載的影片可能是 mkv 格式或 webm 格式 youtube-dl -cit [playlist_url] // 下載影片清單，這種方式下載的影片可能是 mkv 格式或 webm 格式 youtube-dl --yes-playlist [url] // 當連結為影片清單時，則下載該清單的影片，跟上面的一樣，可能是 mkv 或 webm 格式 視覺化介面 Releases · jely2002/youtube-dl-gui 參考文章 yt-dlp 的 Github 頁面 【備份】youtube-dl 使用介紹 - 簡書 一篇搞懂 Windows 系統【目錄變數】的相關知識_黑就黑到底的部落格-CSDN部落格_username變數 ","date":"2022-07-25T12:52:27+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/52/","title":"用命令列下載 YouTube 影片"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 前言 近日上網時發現一款覺得還不錯的字型，便找尋更換字型的方法。但實際使用下來並沒有那麼驚艷\n方法一 左下方「管理」-「設定」(或者快速鍵CTRL+,)進入設定介面，找到「Editor:Font Family」\n將預設的 Consolas, 'Courier New', monospace 改為要更換的字型即可\n方法二 Ctrl + Shift + P -\u0026gt; 輸入 settings.json -\u0026gt; 選擇 「Preferences:Open Settings(JSON)」 開啟 settings.json 檔案，然後將 \u0026quot;editor.fontFamily\u0026quot;: \u0026quot;要更改的字型\u0026quot;加入到 {} 中並儲存即可\n中英文字型分開設定 我們可以觀察到 VS Code 的預設字型有三種，以 , 區隔：Consolas, 'Courier New', monospace，若要為中英文設定不同的字型，只需要將第一個和第二個分別設定一個英文字型和一個中文字型（英文字型, 中文字型）即可，例如SF NS Mono, '楷體'\n","date":"2022-07-13T17:47:57+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/51/","title":"VS Code 更換字型"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 似乎沒有解決方法，不過可以將快速存取中自己加入的全部刪除 (恢復預設)\n前往 C:\\\\Users\\\\使用者名稱\\\\AppData\\\\Roaming\\\\Microsoft\\\\Windows\\\\Recent\\\\AutomaticDestinations，將此資料夾目錄下的檔案備份後全部刪除\n參考文章 FTP 位址無法從快速存取中移除，但其他資料夾可以 – Microsoft Community ","date":"2022-06-27T13:31:58+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/50/","title":"Windows 網路位址 (FTP 位址) 取消快速存取"},{"content":" 📢 本文由 Gemini-3-flash 翻譯 引言 今天嘗試了一下之前試過的無線中繼，發現已經忘記怎麼做了，果然實作過的東西還是要寫篇文章記錄一下比較好。\n在本文中，將 OpenWRT 路由器連接的 Wi-Fi 稱為上層路由，OpenWRT 路由器稱為路由器。\n前提 確保路由器與上層路由的 LAN 埠位址（即進入路由器後台的位址）不可與上層路由一致，若一致將無法上網。\n修改路由器 LAN 埠位址 進入路由器後台的「網路」-「介面」，點擊「LAN」的「修改」，更改其「IPv4 位址」即可。\n例如上層路由後台位址為 192.168.1.1，路由器可改為 192.168.5.1。\n修改完成並「儲存並套用」後，在瀏覽器輸入修改後的位址即可訪問路由器後台。\n路由器連接 Wi-Fi 進入「網路」-「無線」，點擊「掃描」，找到要連接的 Wi-Fi，點擊「加入網路」，輸入網路名稱與密碼，點擊「提交」，然後點擊「儲存並套用」即可。\n路由器開啟 Wi-Fi 如果路由器支援 2.4G 與 5G 雙頻段，可以選擇與上一步不同的頻段建立 Wi-Fi，這樣相容性最好。（如果另一個頻段已經有一個 Wi-Fi，可能已經可以使用了）\n如果只有單頻段，則在相同頻段新建一個。必須要新建，且不一定會成功，畢竟有些路由器不支援單網卡同時接收與發送。\n設定 Wi-Fi 與一般流程相同，在「網路」-「無線」處新增，輸入 SSID（即 Wi-Fi 名稱）和密碼，然後「儲存並套用」即可。\n參考文章 OpenWrt 进阶教程之无线中继配置指南 - 爱一枝梅 ","date":"2022-06-23T14:50:21+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/49/","title":"OpenWRT 無線中繼"},{"content":" 此文章由 Hiyoung 編寫\n其文章: https://blog.hiyoung.icu/2022/08/18/5be9517606f2/ notify: 📢 本文由 gemini-2.5-flash 翻譯 使用 PS 自動化腳本批次處理圖片 點擊功能表的「視窗」-\u0026gt;「動作」(快捷鍵 alt+F9) 在分頁底部點擊「新增資料夾」（新增群組），命名為「修改圖片大小」（可自行重新命名） 再點擊旁邊的「建立新動作」，我們可以看到底部圓點變為紅色 點擊「檔案」、「開啟舊檔」，開啟我們要處理的其中一張圖片，修改圖片大小，再點擊「確定」，然後「另存新檔」，取個名稱，儲存。（不要使用匯出，否則無法錄製動作導致陷入無限迴圈） 點擊「檔案」、「自動」、「批次處理」 設定 播放區選擇「群組」和「動作」 來源 選擇需要修改的圖片檔案位址 目標 選擇修改後的圖片儲存位址 勾選 「覆寫動作中的『開啟舊檔』指令」 和 「覆寫動作中的『儲存為』指令」 內容部分參考自網際網路\n","date":"2022-06-10T00:54:44+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/48/","title":"使用 PS 自動化腳本批次處理圖片"},{"content":" 📢 本文由 Gemini-3-flash 翻譯 引言 由於騰訊雲函數從六月開始收費，於是便棄用改在自己的伺服器上架設\n既然六月收費為什麼現在才寫文章呢？因為可能還有三個月的免費試用我米遊社的 Cookie 過期更換，故紀錄一下\n工具 \u0026amp; 原教學 原神簽到小助手 每日福利不用愁 - 銀彈博客 由於原文介紹了多種使用方法，自己的閱讀體驗不是太好，故寫此文\n騰訊雲函數處理 請將騰訊雲函數凍結以確保不會產生費用\n當然，如果沒什麼其他需求可直接註銷帳號，但註銷帳號需要手持身分證照片，請注意\n前提 伺服器可以連接上米哈遊的伺服器 https://mihoyo.com 可在 SSH 命令列視窗輸入 ping mihoyo.com 測試是否可以連線\n我的一個伺服器就連不上，只好換一個，唉\nDocker 安裝 可以直接使用一鍵腳本進行安裝，實測 Debian 10 和 CentOS 7 正常安裝 (請使用 root 帳戶)\n安裝指令如下：\n1 curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun 也可以使用中國大陸 daocloud 一鍵安裝指令：\n1 curl -sSL https://get.daocloud.io/docker | sh 腳本安裝 使用以下指令即可\n1 docker pull yindan/genshinhelper CentOS 錯誤 我使用 CentOS 安裝時出現錯誤 Can't Connect to Docker Daemon\n請確保使用 root 帳戶，然後輸入以下指令\n1 systemctl start docker 簡易使用 Cookie 獲取 獲取米遊社 Cookie 請參考： 原神樹脂查看/推播 – yexca\u0026rsquo;Blog 注意：Cookie 應包含 account_id 和 cookie_token 兩個欄位\n多帳號在不同 Cookie 中間加 # 即可，例如 Cookie1#Cookie2#Cookie3\n簡易配置 1 2 3 4 docker run -d --name=genshinhelper \\ -e COOKIE_MIHOYOBBS=\u0026#34;\u0026lt;COOKIE_MIHOYOBBS\u0026gt;\u0026#34; \\ --restart always \\ yindan/genshinhelper:latest 將自己的 Cookie 替換上述指令的 \u0026lt;COOKIE_MIHOYOBBS\u0026gt; 即可\n重新配置/更新 Cookie 重新配置好像需要解除安裝再重裝，然後再進行配置\n或者使用設定檔只需替換 Cookie 就可以了吧 (沒用過，Cookie 有效期很長的)\n常用指令 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 查看 Docker 所有的容器 docker ps -a # 查看日誌 docker logs -f genshinhelper --tail 100 # 重啟 docker restart genshinhelper # 更新 docker pull yindan/genshinhelper docker rm -f genshinhelper # 之後依據基本使用或進階使用重新部署 # 卸載 docker rm -f genshinhelper docker image rm genshinhelper 進階使用 可下載範例檔案修改\nGithub: config.json Telegram: https://t.me/genshinhelperupdates/5 安裝 假設設定檔位於伺服器的 /etc/genshin/config.json，使用以下指令映射配置\n1 2 3 4 docker run -d --name=genshinhelper \\ -v /etc/genshin:/app/genshincheckinhelper/config \\ --restart always \\ yindan/genshinhelper:latest 配置 設定檔可以只留下需要的參數，把非必須的參數刪除，例如只需要 Cookie\n則設定檔除了保持完整也可以寫成：\n1 2 3 { \u0026#34;COOKIE_MIHOYOBBS\u0026#34;: \u0026#34;\u0026lt;COOKIE_MIHOYOBBS\u0026gt;\u0026#34;, } 設定檔新增 RANDOM_SLEEP_SECS_RANGE：隨機延遲休眠秒數範圍，單位：秒。設置成 \u0026ldquo;0-0\u0026rdquo; 為取消延遲。 CHECK_IN_TIME：每日簽到時間。該時間和執行環境的時間有關，和時區無關。如果是 docker，可以用 TZ=Asia/Shanghai 設置時區。 CHECK_RESIN_SECS：原神原粹樹脂檢測間隔時間，單位：秒。 COOKIE_RESIN_TIMER：需要開啟原粹樹脂檢測帳號的 cookie。 SHOPTOKEN：微信積分商城的 token，透過封包擷取獲取。 ONEPUSH：推播配置。notifier 為推播名稱，params 為所需參數。詳見後文。\nOnePush 推播參數一覽 推播名稱 / notifier: bark\n參數大全 / params:\n{\u0026lsquo;required\u0026rsquo;: [\u0026lsquo;key\u0026rsquo;], \u0026lsquo;optional\u0026rsquo;: [\u0026rsquo;title\u0026rsquo;, \u0026lsquo;content\u0026rsquo;, \u0026lsquo;sound\u0026rsquo;, \u0026lsquo;isarchive\u0026rsquo;, \u0026lsquo;icon\u0026rsquo;, \u0026lsquo;group\u0026rsquo;, \u0026lsquo;url\u0026rsquo;, \u0026lsquo;copy\u0026rsquo;, \u0026lsquo;autocopy\u0026rsquo;]}\n推播名稱 / notifier: custom\n參數大全 / params:\n{\u0026lsquo;required\u0026rsquo;: [\u0026lsquo;url\u0026rsquo;], \u0026lsquo;optional\u0026rsquo;: [\u0026lsquo;method\u0026rsquo;, \u0026lsquo;datatype\u0026rsquo;, \u0026lsquo;data\u0026rsquo;]}\n推播名稱 / notifier: dingtalk\n參數大全 / params:\n{\u0026lsquo;required\u0026rsquo;: [\u0026rsquo;token\u0026rsquo;], \u0026lsquo;optional\u0026rsquo;: [\u0026rsquo;title\u0026rsquo;, \u0026lsquo;content\u0026rsquo;, \u0026lsquo;secret\u0026rsquo;, \u0026lsquo;markdown\u0026rsquo;]}\n推播名稱 / notifier: discord\n參數大全 / params:\n{\u0026lsquo;required\u0026rsquo;: [\u0026lsquo;webhook\u0026rsquo;], \u0026lsquo;optional\u0026rsquo;: [\u0026rsquo;title\u0026rsquo;, \u0026lsquo;content\u0026rsquo;, \u0026lsquo;username\u0026rsquo;, \u0026lsquo;avatar_url\u0026rsquo;, \u0026lsquo;color\u0026rsquo;]}\n推播名稱 / notifier: pushplus\n參數大全 / params:\n{\u0026lsquo;required\u0026rsquo;: [\u0026rsquo;token\u0026rsquo;, \u0026lsquo;content\u0026rsquo;], \u0026lsquo;optional\u0026rsquo;: [\u0026rsquo;title\u0026rsquo;, \u0026rsquo;topic\u0026rsquo;, \u0026lsquo;markdown\u0026rsquo;]}\n推播名稱 / notifier: qmsg\n參數大全 / params:\n{\u0026lsquo;required\u0026rsquo;: [\u0026lsquo;key\u0026rsquo;], \u0026lsquo;optional\u0026rsquo;: [\u0026rsquo;title\u0026rsquo;, \u0026lsquo;content\u0026rsquo;, \u0026lsquo;mode\u0026rsquo;, \u0026lsquo;qq\u0026rsquo;]}\n推播名稱 / notifier: serverchan\n參數大全 / params:\n{\u0026lsquo;required\u0026rsquo;: [\u0026lsquo;sckey\u0026rsquo;, \u0026rsquo;title\u0026rsquo;], \u0026lsquo;optional\u0026rsquo;: [\u0026lsquo;content\u0026rsquo;]}\n推播名稱 / notifier: serverchanturbo\n參數大全 / params:\n{\u0026lsquo;required\u0026rsquo;: [\u0026lsquo;sctkey\u0026rsquo;, \u0026rsquo;title\u0026rsquo;], \u0026lsquo;optional\u0026rsquo;: [\u0026lsquo;content\u0026rsquo;, \u0026lsquo;channel\u0026rsquo;, \u0026lsquo;openid\u0026rsquo;]}\n推播名稱 / notifier: telegram\n參數大全 / params:\n{\u0026lsquo;required\u0026rsquo;: [\u0026rsquo;token\u0026rsquo;, \u0026lsquo;userid\u0026rsquo;], \u0026lsquo;optional\u0026rsquo;: [\u0026rsquo;title\u0026rsquo;, \u0026lsquo;content\u0026rsquo;, \u0026lsquo;api_url\u0026rsquo;]}\n推播名稱 / notifier: wechatworkapp\n參數大全 / params:\n{\u0026lsquo;required\u0026rsquo;: [\u0026lsquo;corpid\u0026rsquo;, \u0026lsquo;corpsecret\u0026rsquo;, \u0026lsquo;agentid\u0026rsquo;], \u0026lsquo;optional\u0026rsquo;: [\u0026rsquo;title\u0026rsquo;, \u0026lsquo;content\u0026rsquo;, \u0026rsquo;touser\u0026rsquo;, \u0026lsquo;markdown\u0026rsquo;]}\n推播名稱 / notifier: wechatworkbot\n參數大全 / params:\n{\u0026lsquo;required\u0026rsquo;: [\u0026lsquo;key\u0026rsquo;], \u0026lsquo;optional\u0026rsquo;: [\u0026rsquo;title\u0026rsquo;, \u0026lsquo;content\u0026rsquo;, \u0026lsquo;markdown\u0026rsquo;]}\n推播例子 1 2 3 4 5 telegram ONEPUSH={\u0026#34;notifier\u0026#34;:\u0026#34;telegram\u0026#34;,\u0026#34;params\u0026#34;:{\u0026#34;markdown\u0026#34;:false,\u0026#34;token\u0026#34;:\u0026#34;xxxx\u0026#34;,\u0026#34;userid\u0026#34;:\u0026#34;xxx\u0026#34;}} discord ONEPUSH={\u0026#34;notifier\u0026#34;:\u0026#34;discord\u0026#34;,\u0026#34;params\u0026#34;:{\u0026#34;markdown\u0026#34;:true,\u0026#34;webhook\u0026#34;:\u0026#34;https://discord.com/api/webhooks/xxxxxx\u0026#34;}} docker 設定檔對應目錄為：/etc/genshin:/app/genshincheckinhelper/config\n","date":"2022-06-09T13:33:42+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/47/","title":"原神自動簽到 (Linux 伺服器 Docker)"},{"content":" 📢 本文由 Gemini-3-flash 翻譯 引言 在學習 Markdown 用法 後，感覺非常好用 (最近的文章都是使用 Markdown 寫的)，又因為程式設計或 GitHub 架站 會與 Markdown 接觸，而我寫程式使用 VS Code (看嘉然)，因此尋找是否可以即時預覽。\n快速鍵 在 Markdown 檔案介面 (.md 檔案)，點擊一下檔案介面 (滑鼠文字游標在檔案內)，然後按下 CTRL+K 後按下 V 即可，注意使用英文輸入法。\n以上是即時預覽，可以按 CTRL+Shift+V 開啟新視窗預覽。\n按鈕 在 Markdown 檔案右上角有個 開啟側邊預覽 按鈕，點擊即可。\n指令面板 按 CTRL+Shift+P 開啟指令面板，然後輸入 markdown 就能看到一些指令。\n參考文章 Visual Studio Code 撰寫並即時預覽 Markdown ","date":"2022-06-09T00:03:34+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/46/","title":"VS Code 即時預覽 Markdown"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 前言 首先我不是嘉心糖，我只是覺得很可愛 (我剛開始甚至都不知道是嘉然)，然後這個 Bug 蠻多，自動啟動不是每次都能觸發，但她太可愛啦\n然後這個擴充套件還可以改背景，但我個人不是太喜歡就沒改\n效果預覽如下 安裝 開啟 VS Code 然後在 擴充套件 搜尋 A-SOUL-live2d 安裝\n擴充套件網址： A-SOUL-live2d - Visual Studio Marketplace 其實可以直接去擴充套件那邊看，有安裝過程，不用看我寫的垃圾文章\n簡易使用 安裝完畢重新啟動 VS Code，然後在資源檢視最下方會有 LIVE2D-A-SOUL，展開 (不能展開就重新啟動 VS Code)\n然後在 補充設定 處 產生 擴充套件依賴檔案，重新啟動 VS Code，點擊 啟動 live2d\n右下角就會出現嘉然囉，可以把滑鼠移上去，拖曳右上角第三個圖示以移動位置，第一個點擊改變大小\n調整完位置，大小後可以在 設定資訊 處開啟 自動啟動，然後點擊 儲存目前設定 就可以開啟 VS Code 就能看見嘉然囉~\n其他 以下複製自擴充套件介紹\n基本操作\n啟動、關閉 live2d： 字面意思，會啟動看板人物，初始預設位置右下角 儲存目前設定： 在調整 live2d 大小縮放和拖曳位置後，可儲存資訊，下次啟動時自動帶入 重設預設位置： 目前位置異常，無法拖曳移動時可重設使用【縮放大小也會重設】 背景圖片 點擊切換： 點擊按鈕為人物右側圖示第二個 儲存背景圖片： 需要目前背景圖片存在才會生效。只能儲存一份，再次點擊會覆蓋舊的 載入背景圖片： 載入儲存的背景圖片 定時切換： 字面意思，可查看 切換按鈕 是否旋轉判斷是否開啟定時功能 背景圖片樣式設定 下載背景圖片 設定資訊\n自動啟動： 字面意思，開啟後。VS Code 啟動，live2d 自動啟動 定位依賴： 人物定位的依賴角 補充設定\n擴充套件依賴檔案： 擴充套件依賴檔案會在初次安裝擴充套件並啟動時自動產生 產生： live2d 無法正常啟動時，可嘗試點擊該按鈕，強制重新產生覆蓋設定資訊 移除： 解除安裝該擴充套件前，請盡可能先執行該操作。可移除擴充套件對 VS Code 檔案的所有修改 人物功能\n目光跟隨滑鼠 【缺點，暫時無法實現整個頁面的跟隨】 點擊互動 A-SOUL 粉絲導航網站入口 切換背景圖片 切換模型 溜冰場 音訊測試 一個魂二創網站入口 模型來源 關於警告 使用時會跳出 Code 損壞警告，原作者指出\n本擴充套件是透過修改 VS Code 的 js 檔案的方式執行 所以會在初次安裝，或者 VS Code 升級的時候，出現以下提示，請選擇 【不再提示】\n音訊支援 目前擴充套件僅一個簡易的語音測試，暫且可以不用考慮該功能\nVS Code 使用的 Electron 版本不包含 ffmpeg ，需替換內建的 ffmpeg 動態連結庫才能正常播放 (每次更新 VS Code 都需重新替換)\nVS Code for Windows 1.31.0 - 1.35.1 不需替換，1.36.0 後無此待遇\nVS Code for macOS 1.43+ 替換後閃退 解決方案 解除安裝 首先將 補充設定 移除，然後在 擴充套件 介面解除安裝擴充套件即可\n","date":"2022-06-01T06:01:00+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/45/","title":"VS Code 右下角嘉然"},{"content":" 📢 本文由 Gemini-3-flash 翻譯 引言 最近基於 GitHub Pages 弄了一個個人頁面 (已經沒了)，記錄一下如何使用 GitHub Pages 建站以及自訂網域。\n本文沒有建站系統等，因為我也就寫了一個 Markdown 檔案。\n建立 GitHub 存放庫 首先需要註冊一個 GitHub 帳號，登入後 建立一個新存放庫 。\n其中 Repository name 為 username.github.io，例如我的 GitHub 使用者名稱為 yexca，則輸入 yexca.github.io。\nGit 環境安裝 Windows 環境直接從 Git 官網直接 下載安裝程式 即可。\n安裝完成後，開啟 Git Bash，在命令列輸入以下程式碼：\n1 2 git config --global user.name \u0026#34;Your Name\u0026#34; git config --global user.email \u0026#34;email@example.com\u0026#34; 其中 Your Name 替換為您的姓名，email@example.com 替換為您的電子郵件。\n例如我的：\n1 2 git config --global user.name \u0026#34;yexca\u0026#34; git config --global user.email \u0026#34;yexca@duck.com\u0026#34; GitHub Desktop 安裝 如果您熟悉 Git 的操作 熟悉 Git 操作怎麼會來看我的文章，這一步可以跳過。\n直接進入 GitHub Desktop 官網 下載安裝即可。\n複製存放庫 開啟 GitHub Desktop 後登入 GitHub 帳號，選擇一個空資料夾將上一步建立的存放庫複製 (Clone) 到本機。\n然後軟體會出現一個存放庫變動介面，右方會有一些快捷操作。\n這裡我使用 VS Code，點擊 Open in Visual Studio Code 在 VS Code 開啟。\n建立網站 這裡直接建立一個 README.md 檔案使用 Markdown 編輯 (這裡順便放一個我寫的 Markdown 筆記)。\n編輯完成並儲存後，在 GitHub Desktop 點擊 Commit to main，然後點擊右方 Push origin 即可。\n至此訪問 username.github.io 即可看到網站內容，如果沒看到請等一段時間。\n自訂網域 GitHub Pages 進入剛剛建立的存放庫頁面，點擊 Settings，左側找到 Pages，在 Custom domain 處輸入自訂網域然後點擊 Save。\n註：在這裡可以進行 Jekyll 建站主題的選擇。\nDNS 在網域的 DNS 解析處新增一個 CNAME 類型解析，將網域指向 username.github.io，其中 username 為您的 GitHub 使用者名稱。\nHTTPS 這裡我用 GitHub 的不知為何沒成功，於是使用 Cloudflare 。\n在 DNS 解析處啟用代理，然後在 SSL/TLS 的 邊緣憑證 處將 一律使用 HTTPS 打開即可。\n其他建站 因無部落格需求，我只是寫一個簡單的檔案，如果是建立部落格之類的可以使用一些建站工具：\nJekyll GitHub 官方支援的建站 VuePress 中文網 Markdown 推薦 Gitbook 適合建立說明文件類網站 LOFFER Gridea 一個靜態部落格寫作客戶端 Hexo 快速、簡潔且高效的部落格框架 Hugo 參考文章 GitHub Pages 快速入門 - GitHub Docs GitHub Pages 部落格：自訂網域，HTTPS，CAA — 浮雲的部落格 GitHub Pages 搭建教程 安裝 Git - 廖雪峰的官方網站 ","date":"2022-05-28T15:30:43+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/44/","title":"GitHub Pages 建站及自訂網域"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 前言 最近因建立 雲端硬碟網站 而了解了一下 Markdown，發現這東西非常好用，於是寫了一份學習筆記。\n可以透過 線上編輯器 邊看邊學，也可以下載一些 編輯器 。\n個人編寫 Markdown 的工具為 Typora 。\n複習可以去看官方的速查表 Markdown 語法速查表 。\n標題 建立標題，只需#+空白+標題文字，總共有六個層級，對應 HTML 的 h1~h6。\n1 2 3 4 5 6 # 這是一級標題 ## 這是二級標題 ### 這是三級標題 #### 這是四級標題 ##### 這是五級標題 ###### 這是六級標題 一般的網頁編寫，第一層標題是網頁標題，第二層開始為內文，用到第四層就差不多了。\n換行 只需在上一行末尾加上兩個以上的空白後 Enter (或換行) 即可，有些編輯器可以直接換行。\n例如以下程式碼：\n1 2 這是第一行 //這裡有兩個空白，後面也有→ 這是第二行 效果如下：\n這是第一行 //這裡有兩個空白，後面也有→\n這是第二行\n斜體 \u0026amp; 粗體 斜體是在文字前後加上一個 *，粗體是在文字前後加上兩個 **。\n例如以下程式碼：\n1 2 3 *這是斜體* **這是粗體** ***這是斜體加粗體*** 效果如下：\n這是斜體\n這是粗體\n這是斜體加粗體\n引用區塊 建立引言區塊只需在段落開頭添加 \u0026gt;+空白+內容。\n例如以下程式碼：\n1 2 3 \u0026gt; 這是一級引言 \u0026gt;\u0026gt; 這是二級引言 \u0026gt;\u0026gt;\u0026gt; 這是三級引言 效果如下：\n這是一級引言\n這是二級引言\n這是三級引言\n清單 可以建立有序清單和無序清單。\n有序清單 在清單項目前添加 數字+.+空白+內容 即可。\n例如以下程式碼：\n1 2 3 1. 第一項 2. 第二項 3. 第三項 效果如下：\n第一項 第二項 第三項 無序清單 使用 +，- 或 *+空白+ 內容 即可，但請不要混用 (為了相容性)。\n子項目可以使用 四個空白 或一個 TAB 然後用父項目格式即可。\n不過為了符合 (markdownlint) 規範，一篇文章中的所有無序清單應盡量使用相同的符號，例如都使用 -。\n例如以下程式碼：\n1 2 3 4 5 6 - 第一項 - 第一項子項目一 - 第一項子項目二 - 第一項子項目二的子項目一 - 第二項 - 第三項 效果如下：\n第一項 第一項子項目一 第一項子項目二 第一項子項目二的子項目一 第二項 第三項 程式碼 單行 將要變成程式碼的內容放在 \u0026ldquo;`\u0026rdquo; 中即可，如果程式碼中有 \u0026ldquo;`\u0026rdquo; ，請使用 \u0026ldquo;``\u0026quot;。\n例如以下程式碼：\n1 2 `將此內容變成程式碼區塊` ``此內容中含有\u0026#39;`\u0026#39;喔~`` 效果如下：\n將此內容變成程式碼區塊\n此內容中含有'`'喔~\n程式碼區塊 可以透過將每一行縮排四個空白或一個 TAB。\n或者上下行 \u0026ldquo;```\u0026rdquo; 包住，若要使用語法高亮，請在上方 \u0026ldquo;```\u0026rdquo; 後寫上語言類型。\n為了符合規範，請盡量使用第二種方式。\n例如以下程式碼：\n1 2 3 4 5 6 7 \\`\\`\\` C include\u0026lt;stdio.h\u0026gt; int main(void) { printf(\u0026#34;Hello World\u0026#34;); } \\`\\`\\` 效果如下：\n1 2 3 4 5 include\u0026lt;stdio.h\u0026gt; int main(void) { printf(\u0026#34;Hello World\u0026#34;); } 分隔線 在單獨一行使用三個及以上的 *，- 或 _ 即可。\n為了規範，請盡量使用三個星號。\n例如以下程式碼：\n1 *** 效果如下：\n連結 簡易連結 直接將連結或電子郵件地址使用 \u0026lt;\u0026gt; 括起來即可。\n例如以下程式碼：\n1 2 \u0026lt;https://yexca.net\u0026gt; \u0026lt;yexca@duck.com\u0026gt; 效果如下：\nhttps://yexca.net yexca@duck.com 自訂文字的連結 [超連結顯示名](超連結地址 \u0026quot;超連結 title\u0026quot;)，其中 \u0026quot;超連結 title\u0026quot; 可以不用填寫。\n例如以下程式碼：\n1 2 [yexca 的部落格](https://blog.yexca.net) [yexca 的部落格](https://blog.yexca.net \u0026#34;其實是yexca和Hiyoung的部落格\u0026#34;) 效果如下：\nyexca 的部落格 yexca 的部落格 參考型連結 例如以下程式碼：\n1 2 3 4 [blog]: https://blog.yexca.net [contact]: \u0026lt;mailto:yexca@duck.com\u0026gt; 這是我的[個人部落格][blog]，有問題可以[聯絡我][contact]。 效果如下：\n這是我的 個人部落格 ，有問題可以 聯絡我 。\n圖片 插入圖片 ![圖片 alt](圖片連結 \u0026quot;圖片 title\u0026quot;)，其中 圖片 alt 為當圖片載入失敗時顯示的內容，圖片 title 為滑鼠移到圖片上顯示的內容。\n請注意：部分 Markdown 編輯器不支援 圖片 title (例如本站這個主題)，為了規範，請至少確保填寫 圖片 alt。\n例如以下程式碼：\n1 ![圖片](https://cdn.statically.io/gh/yexca/picx-images-hosting@master/2023/04-網站背景/blog-background.2p10z489pjc0.webp \u0026#34;這是本站的背景圖片\u0026#34;) 效果如下：\n圖片包含連結 使用連結的語法，將圖片放在 [] 裡面即可。\n例如以下程式碼：\n1 [![圖片](https://cdn.statically.io/gh/yexca/picx-images-hosting@master/2023/04-網站背景/blog-background.2p10z489pjc0.webp)](https://www.pixiv.net/artworks/82542737) 效果如下：\n跳脫字元 如果有不想被 Markdown 格式化的字元，只需要在前方加上 \\ 即可。\n例如以下程式碼：\n1 2 我想打出*但這會變成斜體* 加上跳脫字元\\*後面就不會變成斜體，而且可以顯示 效果如下：\n我想打出但這會變成斜體\n加上跳脫字元*後面就不會變成斜體，而且可以顯示\n內嵌 HTML 直接使用即可，以摺疊標籤為例：\n例如以下程式碼：\n1 2 3 4 5 6 7 \u0026lt;details\u0026gt; \u0026lt;summary\u0026gt; 點我試試看 \u0026lt;/summary\u0026gt; 被發現啦 \u0026lt;/details\u0026gt; 我可以用Markdown**變粗**，也可以同時用HTML\u0026lt;i\u0026gt;變斜\u0026lt;/i\u0026gt; 因為本站主題無法直接解析 H5，所以不提供範例。\n表格 使用三個或多個 - 建立每欄的標題，使用 | 分隔每欄，使用 : 向左、向右或置中對齊 (非必要)。\n例如以下程式碼：\n1 2 3 |標題|內容|備註| |:---|:---:|---:| |靠左對齊|置中|靠右對齊| 效果如下：\n標題 內容 備註 靠左對齊 置中 靠右對齊 請注意：不可以在表格中加入標題、引言、清單、圖片或 HTML 標籤等等。\n刪除線 在要刪除的內容前後加上 ~~。\n例如以下程式碼：\n1 我永遠喜歡 ~~戰爭文學博士~~ Warma 效果如下：\n我永遠喜歡 戰爭文學博士 Warma\n待辦事項清單 使用 -+空白+[ ] 或 [x]+空白+內容。\n例如以下程式碼：\n1 2 - [ ] 這個還沒完成呢 - [x] 這個完成啦 效果如下：\n這個還沒完成呢 這個完成啦 使用 Emoji 表情符號 複製貼上 大部分情況可以直接複製 Emojipedia 上的表情符號直接貼上，請確保網頁編碼為 UTF-8。\n使用表情符號簡碼 這需要 Markdown 應用程式支援，以冒號 : 開頭和結尾。\n可以透過 表情符號簡碼列表 查詢。\n例如以下程式碼：\n1 :blush:,:smiley: 效果如下：\n😊,😃\n註腳 類似於論文參考文獻的註標。\n例如以下程式碼：\n1 2 3 4 5 6 這裡引用了維基百科[^1]，這裡引用了 Github[^2]。 也可以使用英文，但不能使用空白或 TAB[^yexca]。 [^1]: 這裡可以使用文字，然後會顯示在上方相應的位置 [^2]: 或者使用連結 [Github](https://github.com/yexca) [^yexca]: [個人首頁](https://lit.link/yexca) 效果如下，參考的內容在文章最尾端，點擊註標即可查看。\n這裡引用了維基百科1，這裡引用了 Github2。 也可以使用英文，但不能使用空白或 TAB3。\n請注意：部分編輯器不支援。\n參考文章 Markdown 官方教學 Markdown 學習 這裡可以使用文字，然後會顯示在上方相應的位置\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n或者使用連結 Github \u0026#160;\u0026#x21a9;\u0026#xfe0e;\n個人首頁 \u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2022-05-28T00:59:23+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/43/","title":"Markdown 簡述 (學習筆記)"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 引言 本人可以直接連線進入遊戲，但加速器等方式無法進入遊戲，加上每次進入遊戲都要關閉虛擬私人網路較為麻煩，尋找相關資料卻無果，故撰寫此文。（遊戲為 iOS 日服）\n正文 透過查看日誌檔案，確定了進入遊戲時連線的網域名稱。\n將以下網域名稱加入 DIRECT 即可：\n1 sekai.colorfulpalette.org 後記 本想詳細說明的，卻發現遊戲出了國際服和台服，如果要詳細寫估計要花費很長時間並進行校對，懶～\n","date":"2022-05-19T15:01:25+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/42/","title":"プロセカ的 IP 規則"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 該文章由 Hiyoung 編寫\n新增管理員使用者： 1、建立新使用者，這裡建立一個 temp_test 的使用者\nadduser temp\\_test **2、設定新使用者密碼** passwd temp_test\n3、將 sudoers 檔案的權限修改為可編輯\nchmod -v u+w /etc/sudoers\n4、使用 vim 編輯 sudoers 檔案\nvim /etc/sudoers\n5、在 sudoers 檔案中新增以下內容\n找到 root ALL=(ALL) ALL\n然後新增 temp_test ALL=(ALL) ALL\n若需要新使用者在使用 sudo 時無需輸入密碼，將最後一個 ALL 改為 NOPASSWD:ALL 即可。\n6、將 sudoers 檔案的權限修改為不可編輯\nchmod -v u-w /etc/sudoers\n7、刪除使用者\nuserdel temp_test\n","date":"2022-05-16T15:29:21+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/41/","title":"Linux 新增使用者與管理員帳號"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 這篇文章由 Hiyoung 撰寫\nLinux 不會自動建立不存在的資料夾，使用「mv」指令時需要注意資料夾是否存在，否則會將檔案重新命名。 為檔案建立實體連結（Hard Link）實際上是為檔案建立了額外的名稱部分（資料部分未改動），類似於 C 語言中建立了一個指標指向該檔案。 為檔案建立符號連結（Symbolic Link）類似於 Windows 中的捷徑，在使用「ls -li」指令中可以比較直觀地看出區別。實體連結的位元組數和來源檔案一樣，而符號連結的位元組數不同。 使用別名「alias」建立指令：在同一行同時執行多個指令用「;」分開；可以使用「type」查詢指令是否已經在系統中；值得注意的是使用「alias」建立指令在結束 Shell 工作階段時會消失（因為沒有新增到檔案中）；使用「unalias」刪除別名。 使用「\u0026gt;」重新導向會覆寫來源檔案，「\u0026raquo;」重新導向會在來源檔案後方附加。 將錯誤訊息寫入檔案（而不是顯示在螢幕上）可以用「2\u0026gt;」。 重新導向標準輸出和錯誤到同一個檔案有兩種方法：一是，在重新導向的檔案名稱後加上「2\u0026gt;\u0026amp;1」；二是，在重新導向符號前加「\u0026amp;」。 方法一（在舊版本的 Shell 也可使用）\n方法二\n","date":"2022-04-30T04:24:07+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/40/","title":"Linux 隨手筆記"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 該文章由 Hiyoung 撰寫\n其文章: https://blog.hiyoung.xyz/2022/09/03/3256bd2afccc/ 一、虛擬機器設定 在功能表列選擇編輯 → 虛擬網路編輯器，開啟虛擬網路編輯器對話框，選擇 NAT 網路連線方式，隨意設定子網路 IP，點擊 NAT 設定頁面，查看子網路遮罩與預設閘道，後面修改靜態 IP 時會用到。\n在 VMnet8 模式下選擇 NAT 連線，並且取消 DHCP 服務。\n點擊 NAT 設定，記錄下此時的預設閘道。\n在系統的網路設定處，檢查 VMnet8 的網路配置。\n二、Linux 主機設定 在 root 權限下輸入指令 cd /etc/sysconfig/network-scripts 進入該資料夾，輸入指令 ls 瀏覽該資料夾下的檔案，找到 ifcfg-en*** 檔案，如下圖所示：\n使用 vim ifcfg-en*** 開啟檔案。\n將 BOOTPROTO=\u0026ldquo;dhcp\u0026rdquo; 改為 BOOTPROTO=\u0026ldquo;static\u0026rdquo;、ONBOOT=\u0026ldquo;no\u0026rdquo; 改為 ONBOOT=\u0026ldquo;yes\u0026rdquo;。\n並在下方新增：\nIPADDR=your ip（靜態 IP 位址）\nNETMASK=your netmask（子網路遮罩，一般為 255.255.255.0）\nGATEWAY=your gateway（預設閘道位址）\nDNS1=8.8.8.8（國內外公共 DNS 即可）\nDNS2=8.8.4.4\n最後輸入 :wq 儲存並離開即可。\n","date":"2022-04-22T18:13:42+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/39/","title":"在虛擬機器中設定靜態 IP（以 CentOS 為例）"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 這篇文章由 Hiyoung 撰寫\n其文章: https://blog.hiyoung.xyz/2022/08/01/84a03702e5a9/ （參考影片： https://www.bilibili.com/video/BV1WY4y1H7d3?p=1 ）\n一、基礎篇 1.1 Linux 檔案系統目錄結構 來源：菜鳥教程 圖中小箭頭表示該檔案實際位置在別處\n/bin： bin 是 Binaries (二進位檔案) 的縮寫, 這個目錄存放著最經常使用的指令。 /boot：\n這裡存放的是啟動 Linux 時使用的一些核心檔案，包括一些連結檔案以及映像檔。 /dev ：\ndev 是 Device (裝置) 的縮寫, 該目錄下存放的是 Linux 的外部裝置，在 Linux 中存取裝置的方式和存取檔案的方式是相同的。 /etc：\netc 是 Etcetera (等等) 的縮寫, 這個目錄用來存放所有的系統管理所需要的設定檔和子目錄。 /home：\n使用者的家目錄，在 Linux 中，每個使用者都有一個自己的目錄，一般該目錄名是以使用者的帳號命名的，如上圖中的 alice、bob 和 eve。 /lib：\nlib 是 Library (函式庫) 的縮寫，這個目錄裡存放著系統最基本的動態連結共享函式庫，其作用類似於 Windows 裡的 DLL 檔案。幾乎所有的應用程式都需要用到這些共享函式庫。 /lost+found：\n這個目錄一般情況下是空的，當系統非法關機後，這裡就存放了一些檔案。 /media：\nLinux 系統會自動辨識一些裝置，例如 USB 隨身碟、光碟機等等，當辨識後，Linux 會把辨識的裝置掛載到這個目錄下。 /mnt：\n系統提供該目錄是為了讓使用者臨時掛載別的檔案系統的，我們可以將光碟機掛載在 /mnt/ 上，然後進入該目錄就可以檢視光碟機裡的內容了。 /opt：\nopt 是 optional (可選) 的縮寫，這是給主機額外安裝軟體所擺放的目錄。比如你安裝一個 ORACLE 資料庫則就可以放到這個目錄下。預設是空的。 /proc：\nproc 是 Processes (程序) 的縮寫，/proc 是一種偽檔案系統（也即虛擬檔案系統），儲存的是當前核心執行狀態的一系列特殊檔案，這個目錄是一個虛擬的目錄，它是系統記憶體的映射，我們可以透過直接存取這個目錄來獲取系統資訊。\n這個目錄的內容不在硬碟上而在記憶體裡，我們也可以直接修改裡面的某些檔案，比如可以透過下面的指令來阻擋主機的 ping 指令，使別人無法 ping 你的機器：echo 1 \u0026gt; /proc/sys/net/ipv4/icmp_echo_ignore_all /root：\n該目錄為系統管理員，也稱作超級權限者的使用者家目錄。 /sbin：\ns 就是 Super User 的意思，是 Superuser Binaries (超級使用者的二進位檔案) 的縮寫，這裡存放的是系統管理員使用的系統管理程式。 /selinux：\n這個目錄是 Redhat/CentOS 所特有的目錄，Selinux 是一個安全機制，類似於 Windows 的防火牆，但是這套機制比較複雜，這個目錄就是存放 selinux 相關的檔案的。 /srv：\n該目錄存放一些服務啟動之後需要提取的資料。 /sys：這是 Linux 2.6 核心的一個很大的變化。該目錄下安裝了 2.6 核心中新出現的一個檔案系統 sysfs 。sysfs 檔案系統整合了下面 3 種檔案系統的資訊：針對程序資訊的 proc 檔案系統、針對裝置的 devfs 檔案系統以及針對虛擬終端機的 devpts 檔案系統。該檔案系統是核心裝置樹的一個直觀反映。當一個核心物件被建立的時候，對應的檔案和目錄也在核心物件子系統中被建立。 /tmp：\ntmp 是 temporary (臨時) 的縮寫，這個目錄是用來存放一些臨時檔案的。 /usr：\nusr 是 unix shared resources (共享資源) 的縮寫，這是一個非常重要的目錄，使用者的很多應用程式和檔案都放在這個目錄下，類似於 Windows 下的 program files 目錄。 /usr/bin：\n系統使用者使用的應用程式。 /usr/sbin：\n超級使用者使用的比較高級的管理程式和系統守護程序。 /usr/src：\n核心原始碼預設的放置目錄。 /var：\nvar 是 variable (變數) 的縮寫，這個目錄中存放著在不斷擴充著的東西，我們習慣將那些經常被修改的目錄放在這個目錄下。包括各種紀錄檔。 /run：\n是一個臨時檔案系統，儲存系統啟動以來的資訊。當系統重新啟動時，這個目錄下的檔案應該被刪掉或清除。如果你的系統上有 /var/run 目錄，應該讓它指向 run。 1.2 檔案基本屬性 1.2.1 基本屬性 在 Linux 中第一個字元代表這個檔案是目錄、檔案或連結檔案等等。\n當為 d 則是目錄 當為 – 則是檔案； 若是 l 則表示為連結檔案 (link file)； 若是 b 則表示為裝置檔案裡面的可供儲存的介面裝置 (可隨機存取裝置)； 若是 c 則表示為裝置檔案裡面的序列埠裝置，例如鍵盤、滑鼠 (一次性讀取裝置)。 接下來的字元中，以三個為一組，且均為 rwx 的三個參數的組合。其中， r 代表可讀 (read)、 w 代表可寫 (write)、 x 代表可執行 (execute)。 要注意的是，這三個權限的位置不會改變，如果沒有權限，就會出現減號 – 。\n每個檔案的屬性由左邊第一部分的 10 個字元來確定（如下圖）。\n從左至右用 0-9 這些數字來表示。\n第 0 位確定檔案類型，第 1-3 位確定擁有者（該檔案的所有者）擁有該檔案的權限。第 4-6 位確定所屬群組（所有者的同組使用者）擁有該檔案的權限，第 7-9 位確定其他使用者擁有該檔案的權限。\n其中，第 1、4、7 位表示讀權限，如果用 r 字元表示，則有讀權限，如果用 – 字元表示，則沒有讀權限；\n第 2、5、8 位表示寫權限，如果用 w 字元表示，則有寫權限，如果用 – 字元表示沒有寫權限；第 3、6、9 位表示可執行權限，如果用 x 字元表示，則有執行權限，如果用 – 字元表示，則沒有執行權限。\n1.2.2 Linux 檔案擁有者和群組 1、chgrp：更改檔案群組 語法：\n1 chgrp [-R] 群組名 檔案名 參數選項\n-R：遞迴更改檔案群組，就是在更改某個目錄檔案的群組時，如果加上 -R 的參數，那麼該目錄下的所有檔案的群組都會更改。 2、chown：更改檔案擁有者，也可以同時更改檔案群組 語法：\n1 2 chown [–R] 擁有者名 檔案名 chown [-R] 擁有者名：群組名 檔案名 進入 /root 目錄（~）將 install.log 的擁有者改為 bin 這個帳號：\n1 2 3 4 [root@www ~] cd ~ [root@www ~]# chown bin install.log [root@www ~]# ls -l -rw-r--r-- 1 bin users 68495 Jun 25 08:53 install.log 將 install.log 的擁有者與群組改回為 root：\n1 2 3 [root@www ~]# chown root:root install.log [root@www ~]# ls -l -rw-r--r-- 1 root root 68495 Jun 25 08:53 install.log 3、chmod：更改檔案 9 個屬性 Linux 檔案屬性有兩種設定方法，一種是數字，一種是符號。\nLinux 檔案的基本權限就有九個，分別是 owner/group/others (擁有者/群組/其他) 三種身份各有自己的 read/write/execute 權限。\n先複習一下剛剛上面提到的數據：檔案的權限字元為： -rwxrwxrwx ， 這九個權限是三個三個一組的！其中，我們可以使用數字來代表各個權限，各權限的分數對照表如下：\nr:4 w:2 x:1 每種身份 (owner/group/others) 各自的三個權限 (r/w/x) 分數是需要累加的，例如當權限為： -rwxrwx— 分數則是：\nowner = rwx = 4+2+1 = 7 group = rwx = 4+2+1 = 7 others= — = 0+0+0 = 0 所以等一下我們設定權限的變更時，該檔案的權限數字就是 770。變更權限的指令 chmod 的語法是這樣的：\n1 chmod [-R] xyz 檔案或目錄 選項與參數：\nxyz : 就是剛剛提到的數字類型的權限屬性，為 rwx 屬性數值的相加。 -R : 進行遞迴 (recursive) 的持續變更，以及連同次目錄下的所有檔案都會變更 舉例來說，如果要將 .bashrc 這個檔案所有的權限都設定啟用，那麼指令如下：\n1 2 3 4 5 [root@www ~]# ls -al .bashrc -rw-r--r-- 1 root root 395 Jul 4 11:45 .bashrc [root@www ~]# chmod 777 .bashrc [root@www ~]# ls -al .bashrc -rwxrwxrwx 1 root root 395 Jul 4 11:45 .bashrc 那如果要將權限變成 -rwxr-xr– 呢？那麼權限的分數就成為 [4+2+1][4+0+1][4+0+0]=754。\n4、符號類型改變檔案權限 還有一個改變權限的方法，從之前的介紹中我們可以發現，基本上就九個權限分別是：\nuser：使用者 group：群組 others：其他 那麼我們就可以使用 u, g, o 來代表三種身份的權限。\n此外， a 則代表 all，即全部的身份。讀寫的權限可以寫成 r, w, x，也就是可以使用下表的方式來看：\n| chmod | u g o a | +(加入) -(除去) =(設定) | r w x | 檔案或目錄 | |---|---|---|---|---| 如果我們需要將檔案權限設定為 -rwxr-xr– ，可以使用 chmod u=rwx,g=rx,o=r 檔案名 來設定:\n1 2 3 4 5 6 touch test1 // 建立 test1 檔案 ls -al test1 // 檢視 test1 預設權限 #-rw-r--r-- 1 root root 0 Nov 15 10:32 test1 chmod u=rwx,g=rx,o=r test1 // 修改 test1 權限 ls -al test1 -rwxr-xr-- 1 root root 0 Nov 15 10:32 test1 而如果是要將權限去掉而不改變其他已存在的權限呢？例如要拿掉全部人的可執行權限，則：\n1 2 3 chmod a-x test1 ls -al test1 #-rw-r--r-- 1 root root 0 Nov 15 10:32 test1 1.3 vim 文字編輯 1.3.1 vim 的三種模式 基本上 vi/vim 共分為三種模式，分別是命令模式、編輯模式和一般模式\n1.3.2 vim 快捷指令 參考外部網站： https://www.runoob.com/linux/linux-vim.html 1.4 網路配置 1.4.1 VMware 的三種網路連接模式 橋接模式：虛擬機器直接連接外部網路（對外部網路可見），主機起到橋接器的作用，虛擬機器的地位和主機相同，從路由器分配獨立的 IP 位址。\nNAT 模式：主機和虛擬機器建構一個專用網路，使用 NAT 對虛擬機器進行 IP 轉換（虛擬機器對外部網路不可見）。此時虛擬機器單獨組成一個區域網路，此時主機和虛擬機器並不在一個網段，無法進行通訊，所以又虛擬一個網路卡（VMnet8）來連接至虛擬機器所在的區域網路。\n僅主機模式：這種模式僅僅只讓虛擬機器與主機通訊，不連接至 Internet。\n1.4.2 配置靜態 IP 參考站內文章： 在虛擬機器中設置靜態 IP（以 CentOS 為例） 1.4.3 配置主機名稱 1 2 3 4 5 6 7 8 9 hostname #檢視當前主機名稱 vim /etc/hostname #修改主機名稱 #修改後重啟即可顯示新主機名稱 #方法二 hostnamectl set-hostname ... #即時生效 1 2 #修改 hosts 檔案 vim /etc/hosts 1.5 系統管理 1.5.1 service 服務管理 一個正在執行的程式或指令，稱為「程序」(Process)\n啟動後一直存在、常駐記憶體的程序，一般稱為「服務」\n1 2 3 systemctl start|stop|restart|status servicename #基本語法 /usr/lib/systemd/system/ #服務所在目錄 ","date":"2022-04-19T02:53:27+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/38/","title":"系統學習 Linux 筆記"},{"content":" 📢 本文由 Gemini-3-flash 翻譯 前言 2022 年 03 月 22 日，OBS 在 Steam 上架了，雖然方便更新，但每次使用都要開啟 Steam 實在有點麻煩。\n正文 在 Steam 收藏庫介面右鍵點擊 OBS Studio，依序選擇「管理 \u0026gt; 瀏覽本機檔案」。\n在檔案總管中進入路徑 bin/64bit 或 bin/32bit，找到 obs64 或 obs32。\n直接點擊這個檔案就可以啟動 OBS，因此可以將其固定到「開始」畫面或建立捷徑。\n按右鍵選擇「建立捷徑」，將捷徑放到桌面即可。\n","date":"2022-04-11T22:19:48+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/37/","title":"免啟動 Steam 開啟 OBS"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 一、查詢時間戳 開啟網頁 https://member.bilibili.com/x2/creative/h5/calendar/event?ts=0 按下 CTRL+F，輸入 jointime，找到 jointime 後面的數字就是時間戳\n將時間戳複製\n二、轉換時間戳 開啟網站 時間戳 (Unix timestamp) 轉換工具 – 線上工具 在對應位置輸入時間戳，點擊轉換即可\n參考資料 UP主教學如何查看自己的B站註冊時間，精確到秒！bilibili ","date":"2022-04-09T13:47:52+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/36/","title":"查詢B站註冊時間(精確到秒)"},{"content":" 📢 本文由 Gemini-3-flash 翻譯 前言 今日我在撰寫文章時，發現 PicX 圖床無法使用並提示 Bad credentials，於是便尋找解決方法。\n結論 其實就是 GitHub 的 Token 到期了，然後在電子信箱裡會收到一封郵件，標題為 [GitHub] Your personal access token has expired\n郵件有三行，第二行 If this token is still needed 後面有個連結，點擊打開並重新建立即可。\n注意設定 Expiration 即 Token 期限。\n重新建立後需要在 PicX 將圖床設定重置一下。\n具體參考： 使用PicX自建免費圖床 – yexca’Blog ","date":"2022-03-22T16:30:12+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/35/","title":"使用 PicX 圖床上傳圖片提示 \"Bad credentials\""},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 另外我寫了模型修改教學，可以前往： https://vrchat.yexca.net/ 查看\n前言 近日經由好友告知 VRchat 中的鋼琴可以自行彈奏，於是便學習了此功能，並撰寫此篇文章作為記錄。 註：似乎只能在 PC 模式下自動彈奏，當然，您也可以在 VR 環境下投影桌面試試看（doge\n如果未使用 MIDI 檔案 一、準備 為實現鋼琴自動彈奏，需要安裝兩款軟體及一個外掛程式。\n1）loopMIDI 此軟體可直接至官網取得，官網連結： loopMIDI-Tobias Erichsen (tobias-erichsen.de) 檔案直接連結： loopMIDISetup_1_0_16_27.zip （可能因版本更新而失效）\n2）Jazz-Plugin 安裝時請保持預設安裝路徑，否則可能無法正常使用。\nWindows: 點此下載（外掛程式官網連結） （如果官網連結無法下載，亦可 點此下載 ）\nMac OS X: 點擊下載 Linux version: 點擊下載 3）瀏覽器外掛程式 Jazz-MIDI Chrome、Opera 或其他雙核心瀏覽器（例如 360 安全瀏覽器等）： 點擊前往 Chrome 線上應用程式商店安裝 如果無法存取 Chrome 線上應用程式商店 Chrome 73 版之前請下載 Jazz-MIDI-crx2.crx 使用，Chrome 73 版之後請下載 Jazz-MIDI-crx3.crx 使用。\nChrome 進入擴充功能 透過在網址列輸入（或此處直接點擊） chrome://extensions 並按下 Enter 進入擴充功能\n如圖所示\nEdge 進入擴充功能 透過在網址列輸入（或此處直接點擊） edge://extensions/ 並按下 Enter 進入擴充功能\n如圖所示\n如果出現彈跳視窗，點擊 「管理擴充功能」\n開啟擴充功能介面後 首先開啟「開發人員模式」，Chrome 在右上角，Edge 在左中。\n接著直接將下載好的 .crx 檔案拖曳至擴充功能介面即可。\n二、步驟 1）開啟 loopMIDI，建立新專案 建立新專案時，請先在右下角 New port-name 輸入名稱，再點擊左下角 + (加號) 即可。\n完成後，專案將會顯示在上方，這裡以 Hello World 作為專案名稱。\n2）開始播放 \u0026lt;1\u0026gt; 尋找欲播放的歌曲 首先，開啟網站 MidiShow – 領先的 MIDI 音樂交流與下載網站 註冊登入後搜尋想播放的歌曲。\n\u0026lt;2\u0026gt; 進行播放設定 如圖所示，以 Hand in Hand 為例，點擊「播放設定」按鈕。\n設定如圖，MIDI 輸出裝置 請選擇剛才使用 loopMIDI 建立的專案，此處為 Hello World。\n\u0026lt;3\u0026gt; 開始播放 此時進入中文酒吧鋼琴旁，選中板凳坐上去，接著在網頁中點擊播放即可。\n如果使用 MIDI 檔案 首先，請確保 MIDI 檔案為鋼琴譜，多軌檔案可能會發生混亂，請自行編輯。\n一、準備 1）loopMIDI 此軟體可直接至官網取得，官網連結： loopMIDI-Tobias Erichsen (tobias-erichsen.de) 檔案直接連結： loopMIDISetup_1_0_16_27.zip （可能因版本更新而失效）\n2）MidiPiano 此軟體我在某下載軟體網站取得（Google 搜尋結果第一個）。\n網站連結： MidiPiano – Download (softonic.com) 二、步驟 1）在 loopMIDI 中建立新專案 建立新專案時，請先在右下角「New port-name」輸入名稱，再點擊左下角「+」 (加號) 即可。\n完成後，專案將會顯示在上方，這裡以「Hello World」作為專案名稱。\n2）開啟 MidiPiano，進行設定 點擊播放清單，可直接將檔案拖曳進入，點擊選項，將輸出裝置設定為剛才 loopMIDI 建立的專案，此處為 Hello World。\n如果出現彈跳視窗「MIDI 輸入輸出不能為同一個，會當機的！」 請點擊選項中的 MIDI 輸入裝置，將剛才 loopMIDI 建立的專案取消勾選，然後再切換至 MIDI 輸出裝置 並將其開啟。\n3）開始播放 此時進入中文酒吧鋼琴旁，選中板凳坐上去，接著選擇 播放清單 中想播放的歌曲，再點擊 播放 即可。\n參考資料 【VRChat】教你如何在中文酒吧自動彈鋼琴 嗶哩嗶哩 播放器選擇及外掛程式安裝說明 ","date":"2022-03-22T16:11:47+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/34/","title":"VRchat 在中文酒吧自動彈鋼琴"},{"content":" 📢 本文由 Gemini-3-flash 翻譯 引言 這篇文章是我自行蒐集的一些免費圖床，部分圖床曾經使用過。當然，如果您想要使用圖床，我推薦您閱讀 使用 PicX 自建免費圖床 – yexca’Blog 一、路過圖床 官網連結： 路過圖床 – 免費圖片上傳, 專業圖片外鏈, 免費公共圖床 高速穩定，單圖最大 10MB\n二、ImgURL 官網連結： ImgURL 免費圖床 訪客每日限 10 次上傳，單圖最大 5MB\n三、SM.MS 官網連結： Image Upload – SM.MS – Simple Free Image Hosting 老牌圖床，現在訪客禁止上傳，普通使用者單圖最大 5MB， 5GB 儲存空間\n（另外該圖床的圖片直連連結網域是 loli.net）\n四、KinhPicture 官網連結： KinhPicture – 聚合圖床 島主的聚合圖床，支援阿里、百度、AWS S3 等 15 個介面，單圖限制 2~32MB\n五、極兔圖床 官網連結： 極兔圖床 – 免費圖床, 匿名圖床, 免費 CDN 圖床, 圖床 API, 專業的圖片代管商 最大可上傳 10MB 的圖片\n六、Gimhoy 圖床 官網連結： Gimhoy 圖床 - 無限制永久免費圖 七、bayimg 官網連結： bayimg – free uncensored image hosting ","date":"2022-03-20T16:54:36+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/33/","title":"圖床網站總結"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 前言 本文所寫方法僅供一般用途，如有特殊需求請自行查詢。\n一、使用 Win10/Win11 內建功能 1）系統內建截圖軟體 Win10/Win11 內建一個截圖軟體，名稱為「擷取工具」，有兩種使用方式。\n\u0026lt;1\u0026gt; 開啟軟體使用 透過按下 Win 按鍵，開啟所有應用程式，找到「擷取工具」開啟。\n如上圖所示為開啟軟體後的介面，點擊「新增」即可進行截圖。\n\u0026lt;2\u0026gt; 使用快捷鍵 其實上圖中軟體介面已經顯示快捷鍵，為 Win+Shift+S，三個按鍵一起按即可開始截圖。\n完成截圖後儲存 完成截圖後，右下角的通知中心會跳出一個視窗。\n如果想透過聊天軟體傳送，可直接在聊天介面的輸入框中按下 Ctrl+V 即可顯示圖片。\n如果想儲存到本機，可點擊通知中心對應的通知，跳出截圖後按下 Ctrl+S 選擇路徑儲存。 其他功能請自行探索。\n2）使用系統內建的 Xbox Bar 透過按下 Win+G 即可開啟 Xbox Bar，點擊空白處或再次按下 Win+G 即可關閉。\n\u0026lt;1\u0026gt; 透過 Xbox Bar 截圖與錄影 如圖所示，紅框中第一個按鈕為截圖，第三個按鈕為錄影，再次按下即可結束錄影（或按下螢幕上出現的一個懸浮視窗上的結束按鈕）。 如果未出現「擷取」方塊，請按下上圖藍框中按鈕。\n\u0026lt;2\u0026gt; 截圖與錄影檔案位置 如上圖所示，紅框中有「顯示所有擷取」，點擊即可出現使用 Xbox Bar 截圖或錄影的所有檔案，每個檔案下都會出現「開啟檔案位置」，點擊即可開啟檔案所在位置。\n當然，Xbox Bar 所儲存的檔案路徑在 此電腦/視訊/擷取 (即 C:\\Users\\%username%\\Videos\\Captures)，截圖與錄影都在這裡。\n二、使用第三方應用程式 如果是第三方應用程式，會有許多選擇，這裡僅說明兩個，一般情況下系統內建功能就已足夠。\n1）使用 QQ/TIM/WeChat (微信) 進行截圖或錄影 QQ/TIM 的截圖快捷鍵為 Ctrl+Alt+A，錄影快捷鍵為 Ctrl+Alt+S。\nWeChat (微信) 的截圖快捷鍵為 Alt+A，未發現錄影功能。\n兩者皆可在聊天介面輸入框上方的小剪刀圖示右側的小箭頭處進行修改「截圖隱藏目前視窗」。\n2）使用 OBS 進行錄影 OBS 簡介 由於並非本文重點，此處複製官方簡介，進入官方網站下載安裝即可。\nOBS Studio – 免費開放原始碼軟體，用於直播和螢幕錄影。\n官方網站： Open Broadcaster Software-OBS Github： obsproject/obs-studio: OBS Studio 錄製螢幕教學 \u0026lt;1\u0026gt; 使用 OBS 進行錄製 開啟 OBS 介面如上圖所示，左下第二個有「來源視窗」，點擊下方加號。\n如上圖所示，選擇顯示器擷取，然後點兩次確定即可出現顯示器螢幕。\n右方點擊「開始錄製」即可開始錄製目前桌面。\n\u0026lt;2\u0026gt; 檔案儲存位置 點擊左上角「檔案-顯示錄影」即可跳出錄製檔案儲存位置。\n問題：如果未出現螢幕 此問題的解決方法為在「NVIDIA 控制面板」中，將「管理 3D 設定」裡的 OBS「選擇此程式的首選圖形處理器」改為「整合式」。\n如下圖所示，因為我的電腦預設為「整合式」，我便未更改。\n如無法解決，請自行搜尋其他方法。\n","date":"2022-03-19T13:57:39+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/32/","title":"Windows 電腦截圖與錄影"},{"content":" 📢 本文由 gemini-2.5-flash-lite 翻譯 引言 近期購入了 Beat Saber (雖然是透過阿根廷區)，於是便想著新增自訂歌曲。透過 Steam 的評論區得知 WGzeyu 大佬做了相關教學，但由於我的目的比較單純，而教學內容又相當完整，因此特地撰寫這篇文章來總結。\n一、準備工作 註：2022.03.25：今日修改相關內容時發現 1.20.0 版本已有 Mod，請直接參閱第二部分。同時，恢復資料的部分已更新。\n1）降級 由於目前最新版本 1.20.0 並沒有相關 Mod，因此需要先進行降級。待 Mod 更新後，可以再升級回最新版本。\n\u0026lt;1\u0026gt; 下載 1.19.0 或更早的版本 可至 WGzeyu 大佬提供的網盤 下載。選擇想下載的版本後進行下載。\n檔案直連： 1.19.0 Steam 版 \u0026lt;2\u0026gt; 替換 1.20.0 版本 解壓縮下載的檔案，然後透過 Steam 開啟遊戲目錄。返回上一層後，將「Beat Saber」資料夾重新命名為「Beat Saber 1.20.0」，接著將剛剛下載的檔案重新命名為「Beat Saber」並移動到此資料夾。\n\u0026lt;3\u0026gt; 如何恢復資料 \u0026lt;1\u0026gt; 使用 Steam 開啟遊戲目錄，刪除 UserData 資料夾內的 Beat Saber IPA。 \u0026lt;2\u0026gt; 複製以下資料夾 (依需求複製)： * UserData (Mod 設定) * CustomSabers (光劍模型) * CustomPlatforms (場景模型) * CustomAvatars (人物模型) * CustomNotes (方塊模型) \u0026lt;3\u0026gt; 然後進入「Beat Saber 1.20.0」資料夾，貼上複製的這些資料夾。在彈出的提示中，選擇【替換】。 \u0026lt;4\u0026gt; 開啟「Beat Saber」資料夾，進入 Beat Saber_Data 資料夾，剪下 CustomLevels 資料夾。 \u0026lt;5\u0026gt; 進入「Beat Saber 1.20.0」資料夾，進入 Beat Saber_Data 資料夾，貼上剪下的那個資料夾。在彈出的提示中，選擇【替換】。\n最後將「Beat Saber」資料夾刪除，將「Beat Saber 1.20.0」資料夾重新命名為「Beat Saber」。\n2）相關軟體 \u0026lt;1\u0026gt; Mod 管理器 \u0026ldquo;ModAssistant\u0026rdquo; 此軟體有英文版和中文版，請依需求下載。網盤下載： 網盤連結 檔案直連： ModAssistant 中文增強版 Mod 安裝器，支援 PC 不支援 Quest \u0026lt;2\u0026gt; BeatSaber 歌曲路徑管理器 可透過上述網盤連結下載，檔案直連： BeatSaber 歌曲路徑管理器 (5.3 版本，可能因更新而失效)\n\u0026lt;3\u0026gt; Resilio Sync 可透過上述網盤連結下載，官網連結： Resilio Sync 檔案直連： Resilio Sync 64 位元 3）資料夾 上述軟體中，除了 Resilio Sync 外，皆為單一檔案應用程式，可放置於常用軟體資料夾。\n另外，需在您想存放歌曲的位置建立一個資料夾，例如「E:\\games\\Beat Saber Song\\」，位置可自行決定。\n二、步驟 1）開啟 Beat Saber 一次 2）開啟 \u0026ldquo;ModAssistant\u0026rdquo; 點擊同意後即可進入左方的 \u0026ldquo;Mod\u0026rdquo; 介面。左下方可選擇遊戲版本。選擇好後即可安裝 Mod，或直接開始安裝。\n若速度過慢，可在「選項」中將軟體來源改為國內。\n3）開啟 Beat Saber 一次 4）開啟 Resilio Sync 此部分步驟請參考： Beat Saber 曲包資源同步 – Resilio Sync (wgzeyu.com) 反正最後都是需要開啟這個網頁的，既然已有步驟，我就不在此處撰寫了（懶惰）。\n下載資料夾目錄即選擇上一步建立的資料夾。\n5）開啟 BeatSaber 歌曲路徑管理器 初次開啟時，請依照提示進行選擇。然後點擊「新增目錄」，選擇放置歌曲的目錄 (即上一步下載的資料夾目錄)。\n接著點擊「儲存列表」即可。\n三、後續 當然，如果您有其他需求，請參考 WGzeyu 的 教學 。\n","date":"2022-03-18T17:46:00+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/31/","title":"Beat Saber 新增自訂歌曲清單"},{"content":" 📢 此頁面有使用機器翻譯喲 引言 在玩了 Beat Saber 和 VRchat 等 VR 遊戲後突然想到 i 社有部分遊戲支援 VR，本人最喜歡玩戀活，於是試著進行遊玩，但卻遇到相關問題，本文僅作記錄。另 VR 版則無劇情，本人使用原版所以遇到問題較少。\n前提/條件 以下圖片和部分文字來自 Oculus 官網 Support ，部分英文自己進行了翻譯，鑑於本人英文不是太好，請以官方原內容為準，以下列出主要內容，詳情請參考 Oculus Link 的相容性要求 資料線要求 Oculus Link 需使用能夠支援資料和電源連接的優質 USB 資料線。為獲得最佳舒適體驗，您還應確保資料線長度至少為 3 米 (10 英尺)\n電腦要求 配件 推薦配置 CPU Intel i5-4590 / AMD Ryzen 5 1500X 或更高版本 顯卡 請參閱下面的 GPU 表 記憶體 8 GB+ 記憶體 作業系統 Win10 USB 介面 1 個 USB 介面 Oculus Link 支援的 GPU NVIDIA GPU 支援 暫時不支援 NVIDIA Titan Z X NVIDIA Titan X X NVIDIA GeForce GTX 970 X NVIDIA GeForce GTX 1060 Desktop, 3GB X NVIDIA GeForce GTX 1060 Desktop, 6GB X NVIDIA GeForce GTX 1060M X NVIDIA GeForce GTX 1070(all) X NVIDIA GeForce GTX 1080(all) X NVIDIA GeForce GTX 1650 X NVIDIA GeForce GTX 1650 Super X NVIDIA GeForce GTX 1660 X NVIDIA GeForce GTX 1660 TI X NVIDIA GeForce RTX 20-series (all) X NVIDIA GeForce RTX 30-series (all) X AMD GPU 支援 暫時不支援 AMD 200 Series X AMD 300 Series X AMD 400 Series X AMD 500 Series X AMD 5000 Series X AMD 6000 Series X AMD Vega Series X 一、進入遊戲 進入遊戲 VR 版本直接打開 KoikatuVR.exe 即可，由於使用 steam 串流，故可提前進入 steamVR\n進入遊戲前請確保戴上耳機，房門鎖緊等以預防突發情況，如不能做到請注意行為 XD\n問題一：無法進入 steamVR 一、確保安裝相關軟體 1）steamVR 安裝 首先打開 steam，然後按 Win+R，輸入 steam://run/250820，按下回車便會自動安裝 steamVR\n2）Oculus 安裝 訪問 官網下載 ，注意：安裝完成後會下載相關檔案，完成後會要求登錄帳號，請確保網絡環境正常 (台灣應該沒事 XD)\n如要求提供支付方式，可尋找 跳過 按鈕\n如果登入一直在加載，無法成功登入 可通過修改 Hosts 解決，推薦使用火絨打開 hosts 檔案進行修改\n如果不使用火絨，打開 C:\\Windows\\System32\\drivers\\etc，找到 hosts 這個檔案，用記事本打開\n在檔案末尾添加如下內容\n1 2 3 4 157.240.11.49 graph.oculus.com 157.240.11.49 www2.oculus.com 157.240.8.49 scontent.oculuscdn.com 157.240.8.49 securecdn.oculus.com 然後保存即可，如果不是使用火絨，請保存到一個地方然後移回原目錄並將副檔名 .txt 去除\n二、確保 Link 線正常 事實上，連接 Quest2 的時候 Oculus 軟體會有一步選擇是否檢測 Link 線，可通過此進行檢測，如果當時未進行檢測，可選擇 設備 - Quest2 和 Touch-USB 檢測 進行檢測\n三、確保設置正常 1）Quest2 設備設置 使用 USB 連接 PC 和 Quest2 時 Quest 會彈出 允許訪問資料，請選擇拒絕，如果選擇了 允許，請拔下再重新連接選擇 拒絕\n2）Oculus 軟體設置 其實直接打開 steamVR 會有彈窗 是否允許未知來源 此時選擇允許即可\n當然，可以在軟體的 設置 - 通用 - 未知來源 進行打開\n四、還是無法打開？換個姿勢試試 如果以上都沒問題但還是無法打開 steamVR，則可使用下述方式\n1）Quest2 設備 當連接 PC 後一般會有彈窗 啟用 Oculus Link，此時選擇 啟用 即可\n如果上述未選擇 啟用 或沒有彈窗，可在下方任務欄的最左方即 快速設置 中找到 Oculus Link，點擊即可打開\n2）啟動 steamVR 不會有人不知道 steamVR 怎麼啟動吧 (doge)\n如果先連接 VR 設備再打開 steam，那麼 steam 的介面右上方應該有 “VR” 標識，點擊即可打開\n如果無此標識，可在任務欄 (或者說右下托盤) 裡找到 steam 圖標，鼠標右擊，倒數第二個即為 steamVR\n當然，可以在 steam 庫中將 工具 也顯示，這樣可以在 steam 庫中看見 steamVR\n二、開始遊戲 我不知道這裡應該寫什麼，分這個標題是因為問題二與遊戲有關，那就寫其他的吧 (doge)\n點擊 KoikatuVR.exe 會自動打開 steamVR，所以可以在 Quest2 設備打開 Oculus Link 後直接打開 KoikatuVR 即可\n注意：遊戲會在桌面有一個視窗，可透過 Win+D 最小化所有視窗，但當摘下頭顯再次戴上時好像會再次出現，請注意\n問題二：無法開始遊戲/不知如何開始 如果您閱讀其他文章或觀看相關影片可能會得到僅支援部分設備 (支持啥我忘了)，如果和我一樣去測試了 VR kanojo 能否正常運行，也可能會以為是靠注視，其實不然 (我就是想多寫點)\n只需要按下 “搖桿” 即可出現選擇線，按下前 “扳機鍵” 即可選擇 (更多操作請看 三、操作說明)\n問題三：開始遊戲後一直白屏，電腦上 \u0026ldquo;LOADING\u0026rdquo; 一直在一半 可進 コイカツ！ DL 版 ，點擊下方 體験版・無料ダウンロード 中的 コイカツ VR パッチ 進行下載\n檔案直鏈： コイカツ VR パッチ 下載解壓後會有一個可執行檔，運行後會出現 コイカツ！VR_0531 更新版 資料夾，將裡面 setup 資料夾內容移到遊戲根目錄並覆蓋即可\n注意：此方法來源作者指出姿勢會變成只有三個，由於我並未遊玩，所以我沒有姿勢 (本來想著 VR 玩劇情的，但 VR 不能玩劇情)，以下為作者給出解決 (部分內容有修改)\n姿勢是在故事模式裡用過什麼姿勢，在 vr 裡才能用，所以在故事模式裡戰鬥的時候把所有姿勢都點一遍，點完就換就行，然後到晚上存檔，在退出換 vr，然後姿勢就齊了\n原文地址： 兄弟們有沒有玩了 vr 的 三、操作說明 此部分為自行遊玩得出，僅作部分說明，其他操作請自行參考其他文章\n1）開始遊戲 進入遊戲後會有俩選項，分別為\nスタート，即 start，即開始\nエンド，即 End，即結束\n按下 \u0026ldquo;搖桿\u0026rdquo;，會出現一條線，可進行選擇 (前 \u0026ldquo;扳機鍵\u0026rdquo;)\n2）進入本番 左右手手腕部分會出現文字，可通過左右控制器上方按鍵即 Y 和 B 進行切換\n一共有倆個，進入戰鬥後有三個 (多了一個 移動)，分別為\n日文 英文 中文 作用 アクション Action 行動 前 \u0026ldquo;扳機鍵\u0026rdquo; 可進行各種操作 側 \u0026ldquo;扳機鍵\u0026rdquo; 可打開菜單 按下 \u0026ldquo;搖桿\u0026rdquo; 可進行選擇 システム system 系統 前 \u0026ldquo;扳機鍵\u0026rdquo; 可重置位置 移動 Move 移動 前 \u0026ldquo;扳機鍵\u0026rdquo; 按住可改變視角 3）注意 僅可在 \u0026ldquo;アクション\u0026rdquo; 時按下 \u0026ldquo;搖桿\u0026rdquo; 可以進行選擇\n參考文章 Oculus Link 兄弟們有沒有玩了 vr 的 Oculus 用戶端在 Win10 上面無法安裝或登陸的解決方法_國韻的部落格 - CSDN 部落格_oculus 無法連接伺服器 中國移動的日文 (別問我為什麼會參考這個，問就是不會日文)\n","date":"2022-03-18T16:54:23+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/30/","title":"使用 Quest2 VR 玩戀愛活動 (戀活 / koikatu) 遇到的問題及解決"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 本文章由 Hiyoung 編寫\n第一章：了解 Web 及網路基礎 1.1 簡介 為了理解 HTTP，應事先了解一下 TCP/IP 協定家族。我們通常使用的網路（包括網際網路）是在 TCP/IP 協定家族的基礎上運作，而 HTTP 屬於其內部的一個子集。在網際網路上的設備若要相互通訊，雙方就必須遵從相同的規則，我們將這些規則稱為協定。（TCP/IP 是對網際網路相關的各類協定家族的一個總稱，包括但不限於：PPPoE、HTTP、TCP、IP、UDP、IEEE 802.3…）\n在 TCP/IP 協定家族中，按照層次從上到下分為：應用層、傳輸層、網路層、資料鏈結層。\n網際網路協定套件-維基百科 在使用 TCP/IP 協定家族進行通訊時，用戶端會從應用層往下走，伺服端會從資料鏈結層往上走。用戶端在層與層之間傳輸資料時，每經過一層時會為其加上該層的段首資訊。相反地，伺服端會一層一層地消去首部。這種將資料資訊包裝起來的方法叫做封裝。\n1.2 IP、TCP 與 DNS 1.2.1 IP 協定 IP 協定位於網路層，TCP/IP 中的 IP 指的是 IP 協定，與 IP 位址並非同一回事。IP 協定的作用是將各種資料封包傳送給對方。各種 IP 位址可以和 MAC 位址進行配對。IP 位址可變換，但 MAC 位址基本上不會更改。IP 位址指明了節點被分配到的位址，MAC 位址是指網路卡所屬的固定位址。\n1.2.2 MAC 位址 IP 之間的通訊依賴 MAC 位址。通常會使用 ARP 協定 來根據通訊方的 IP 位址反查出對應的 MAC 位址。\n1.2.3 TCP 協定 按層次分，TCP 位於傳輸層，提供位元組流服務（Byte Stream Service）——為了方便傳輸，將大塊資料分割成以報文段（segment）為單位的資料封包進行管理。簡而言之，TCP 協定為了更容易傳送大數據才將資料分割，而且 TCP 協定能夠確認資料最終是否送達對方。\n為了確認資料是否送達對方，TCP 採用了三次握手策略。握手過程中使用了 TCP 的旗標（flag）——SYN（synchronize）和 ACK（acknowledgement）。\n1.2.4 負責網域名稱解析的 DNS 服務 電腦既可以被賦予 IP 位址，也可以被賦予主機名和網域名稱。DNS 協定提供透過網域名稱查找 IP 位址，或逆向從 IP 位址反查網域名稱的服務。\n1.3 URL 與 URI 1.3.1 區別與關係 與 URI（統一資源識別碼）相比，我們更熟悉 URL（Uniform Resource Locator，統一資源定位符）。URL 正是使用網頁瀏覽器等存取網頁時需要輸入的網頁位址。例如 https://www.bilibili.com/ 就是 URL。URI 用字串識別某個網際網路資源，而 URL 表示資源的地點（網際網路上所處的位置）。可見 URL 是 URI 的子集。URI 可被視為定位符（URL）、名稱（URN）或兩者兼具。 統一資源名稱 （URN）如同一個人的名稱，而 統一資源定位符 （URL）代表一個人的住址。換言之，URN 定義某事物的身份，而 URL 提供查找該事物的方法。\n1.3.2 URI 格式 表示指定的 URI，要使用涵蓋所有必要資訊的絕對 URI、絕對 URL 以及相對 URL。\n相對 URL，是指從瀏覽器中基本 URI 處指定的 URL，形如 /image/logo.gif。\n絕對 URI 的格式：\n登入資訊（認證）：指定使用者名稱和密碼作為從伺服端獲取資源時必要的登入資訊（身份認證）。此項是可選項。\n伺服器位址：使用絕對 URI 必須指定待存取的伺服器位址。位址可以是類似 hackr.jp 這種 DNS 可解析的名稱，或是 192.168.1.1 這類 IPv4 位址名稱，還可以是 [0:0:0:0:0:0:0:1] 這樣用方括號括起來的 IPv6 位址名稱。\n伺服器連接埠號：指定伺服器連接的網路連接埠號。此項也是可選項，若使用者省略則自動使用預設連接埠號。\n帶層次的文件路徑：指定伺服器上的檔案路徑來定位特指的資源。這與 UNIX 系統的檔案目錄結構相似。\n查詢字串：針對已指定的檔案路徑內的資源，可以使用查詢字串傳入任意參數。此項為可選項。\n片段識別符：使用片段識別符通常可標記出已獲取資源中的子資源（文件內的某個位置）。但在 RFC 中並沒有明確規定其使用方法。該項也為可選項。\n第二章：簡單的 HTTP 協定 2.1 HTTP 簡介 HTTP 是一種不保存狀態的協定，所謂不保存狀態是指 HTTP 協定本身並不會對每次的請求和回應之間的通訊狀態進行保存。所以引入了 Cookie 技術來保存通訊狀態。（註：這本 HTTP 書籍出版較早，現在使用保存狀態的技術是由 cookie、session 和 token 共同實現的）\n2.2 常用的 HTTP 方法 GET：獲取資源\nGET 方法是用來請求 URL 指定的資源。指定資源經伺服端解析後返回回應內容。\nPOST：傳輸實體主體\nPOST 用於向伺服器傳輸資料，當獲取的資料過大時也會使用 POST 方法。\nGET 與 POST 的區別：\n先下結論，GET 與 POST 方法沒有實質區別，只是報文格式不同。\n請求參數長度限制：GET 請求長度最多 1024kb，POST 對請求資料沒有限制。\n請求參數：GET 請求參數是透過 URL 傳遞的，多個參數以 \u0026amp; 連接，POST 請求放在 request body 中。 請求快取：GET 請求會被快取，而 POST 請求不會，除非手動設定。 安全性：POST 比 GET 安全，GET 請求在瀏覽器回溯時是無害的，而 POST 會再次請求。 歷史紀錄：GET 請求參數會被完整保留在歷史紀錄裡，而 POST 中的參數不會被保留。 編碼方式：GET 請求只能進行 URL 編碼，而 POST 支援多種編碼方式。 對參數的資料類型：GET 只接受 ASCII 字元，而 POST 沒有限制。\n此外， HTTP 還有 PUT、HEAD、DELETE 等方法 在此不細細展開。\n2.3 HTTP 的持久連線（三次握手四次揮手） 持久連線的特點是，只要任意一端沒有明確提出斷開連線，則保持 TCP 連線狀態。\n三次握手：建立 TCP 連線 四次揮手：斷開 TCP 連線\n在持久連線中使用管線化技術，可以不用等待回應即可直接傳送下一個請求。\n2.4 使用 Cookie 的狀態管理 Cookie 會根據從伺服端傳送的回應報文內一個叫做 Set-Cookie 的首部欄位資訊，通知用戶端保存 Cookie。當下次用戶端再往該伺服器傳送請求時，用戶端會自動在請求報文中加入 Cookie 值後傳送出去。\nCookie 資訊是在伺服端產生並傳送給用戶端進行保存的。\n第三章 HTTP 報文資訊 3.1 HTTP 的請求與回應報文結構 用於 HTTP 協定交互的資訊被稱為 HTTP 報文。請求端（用戶端）的 HTTP 報文叫做請求報文，回應端（伺服端）的叫做回應報文。由 8 位元組流組成，透過 HTTP 通訊傳輸。\n請求行：包含用於請求的方法、請求 URI 和 HTTP 版本。\n狀態行：包含表明回應結果的狀態碼、原因短語和 HTTP 版本。\n首部欄位：包含表示請求與回應的各種條件和屬性的各類首部。一般有 4 種首部，分別是：通用首部、請求首部、回應首部和實體首部。\n其他：可能包含 HTTP 的 RFC 裡未定義的首部（Cookie 等）。\n3.2 編碼傳輸與分塊傳輸 HTTP 在傳輸資料過程中，透過編碼提升傳輸速率。\n3.2.1 報文主體與實體主體的差異 實體：作為請求或回應的有效負載資料（補充項）被傳輸，其內容由實體首部和實體主體組成。\nHTTP 報文的主體用於傳輸請求或回應的實體主體。**通常，報文主體等於實體主體。**只有當傳輸中進行編碼操作時，實體主體的內容發生變化，才導致它與報文主體產生差異。\n3.2.2 分割傳送實體主體 在 HTTP 通訊過程中傳輸大容量資料時，透過將資料分割成多塊，能讓瀏覽器逐步顯示頁面。將實體主體分塊的功能稱為分塊傳輸編碼。分塊傳輸編碼會將實體主體分成多個塊。每一塊都會用十六進制來標記塊的大小，而實體主體的最後一塊會使用「0(CR+LF)」來標記。\n所謂的塊也就是常稱的封包。\n第四章 返回結果的 HTTP 狀態碼 4.1 狀態碼的類別 藉助狀態碼，使用者可以知道伺服器是否正常處理了請求，狀態碼種類繁多但常用的大概只有 14 種。\n4.2 2XX 成功 4.2.1 200 OK 表示從用戶端傳來的請求在伺服端被正常處理了。在回應報文內，隨狀態碼一起返回的資訊會因方法的不同而發生改變。\n4.2.2 204 No Content 該狀態碼代表伺服器接收的請求已成功處理，但在返回的回應報文中不含實體的主體部分。\n4.3 3XX 重導向 重點介紹一下 301 重導向與 302 重導向，還有其他狀態碼可自行查看。\n4.3.1 301 Moved Permanently 301 重導向是永久性的重導向。該狀態碼表示請求的資源已被分配了新的 URI，以後應使用資源現在所指的 URI。例如像下方給出的請求 URI，當指定資源路徑的最後忘記添加斜線「/」時，就會產生 301 狀態碼。\nhttp://excample.com/sample\n4.3.2 302 Found 302 重導向是臨時性的重導向。該狀態碼表示請求的資源已被分配了新的 URI，希望使用者（本次）能使用新的 URI 存取。與 301 Moved Permanently 狀態碼相似，但 302 狀態碼代表的資源不是被永久移動，只是臨時性質的。\n4.4 4XX 用戶端錯誤 有 400 Bad Request、401 Unauthorized、403 Forbidden、404 Not Found。重點介紹一下 404 Not Found。\n4.4.1 404 Not Found 該狀態碼表明伺服器上無法找到請求的資源。除此之外，也可以在伺服端拒絕請求且不想說明理由時使用。\n4.5 5XX 伺服端錯誤 5XX 的回應結果表明伺服器本身發生錯誤。\n第五章 Web 伺服器 5.1 通訊資料轉發程式：代理、閘道器、隧道 5.1.1 代理 代理伺服器的基本行為就是接收用戶端傳送的請求後轉發給其他伺服器。代理不改變請求 URI，會直接傳送給前方持有資源的目標伺服器。值得一提的是，代理是指對用戶端的代理（也稱為前向代理），而反向代理是指對伺服器的代理。\n使用代理伺服器可以利用快取技術減少網路頻寬的流量，有時也會為了資訊安全而使用代理。\n快取代理 代理轉發回應時，快取代理（Caching Proxy）會預先將資源的副本（快取）保存在代理伺服器上。當代理再次接收到對相同資源的請求時，就可以不從來源伺服器那裡獲取資源，而是將之前快取的資源作為回應返回。\n反向代理 反向代理的優點有很多：\n對用戶端隱藏伺服器（叢集）的 IP 位址\n安全：作為 應用層防火牆 ，為網站提供對基於 Web 的攻擊行為（例如 DoS / DDoS ）的防護，更容易排除 惡意軟體 等\n為後端伺服器（叢集）統一提供加密和 SSL 加速（如 SSL 終端代理）\n負載平衡 ，若伺服器叢集中有負載較高者，反向代理透過 URL 重寫 ，根據連線請求從負載較低者獲取與所需相同的資源或備援\n對於靜態內容及短時間內有大量存取請求的動態內容提供 快取服務 對一些內容進行 壓縮 ，以節約 頻寬 或為網路頻寬不佳的網路提供服務\n5.1.2 閘道器 閘道器的工作機制與代理十分相似。而閘道器能使通訊線路上的伺服器提供非 HTTP 協定服務。\n","date":"2022-03-16T23:56:48+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/29/","title":"《圖解HTTP》讀後總結與淺談"},{"content":" 📢 本文由 Gemini-3-flash 翻譯 注意 此文章複製自 《unity學習筆記》——將MMD模型匯入unity ，僅用於個人記錄使用，部分內容有修改\n方法 1：利用 Unity 外掛程式直接讀取 FBX 模型 第一步：安裝外掛程式 MMD4Mecanim (Beta) 外掛程式網址： Stereoarts Homepage （應外掛程式作者要求，請勿上傳至 GitHub）\n檔案直連： MMD4Mecanim_Beta_20200105.zip 第二步：開啟 Unity，連按兩次下載好的外掛程式中的 MMD4Mecanim.unitypackage 檔案 第三步：將 MMD 模型（全部）檔案匯入 Unity 選擇自動產生的 .MMD4Mecanim，點擊同意（此時可加入動畫、音樂等）\n此方法的好處是可以最大限度地還原 MMD 原本的渲染效果，而且不需要自行重新設定著色器 (Shader)，並且不需藉助 Unity 以外的其他軟體。\n方法 2：利用 Blender 外掛程式將 MMD 模型轉為 FBX 匯入 第一步：安裝 Blender 外掛程式 GitHub: cats-blender-plugin 此外掛程式可以讓 Blender 辨識 MMD 的 PMX 檔案，然後可以根據需要使用 Blender 匯出成 FBX、STL 等格式（FBX 為 Unity 可辨識的格式）。\n第二步：將匯出的 FBX 模型與原模型的所有材質一起匯入 Unity 在匯入 Unity 時，效果或渲染風格可能與原本的不一致，需要自行設定著色器 (Shader)。\n自行設定著色器的好處是可以在 Unity 中統一不同模型的美術風格，或者如果是為了方便起見，可以在 Unity Asset Store 下載相應風格的模型，將下載模型的著色器套用至匯入的 MMD 模型即可（模型動作也可以套用，顏色可以自行修改）。\n","date":"2022-03-10T13:15:26+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/28/","title":"將 MMD 模型匯入 Unity"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 前言 在日常撰寫文章時，經常會需要插入圖片（雖然我最近的文章都沒有圖片），但是如果使用自己的伺服器，會比較耗費流量，而且載入速度也不是特別快。這時候就需要使用圖床了，然而多數免費圖床會不時地出現圖片遺失、速度緩慢等問題，因此我開始探索如何自建圖床。\n然而，如果特意花錢租用雲端伺服器來託管圖片，又太貴不划算；使用付費圖床則多數有流量或空間限制。於是我無意間發現了一個專案，這是一款基於 GitHub API \u0026amp; jsDelivr 開發，並具備 CDN 加速功能的圖床管理工具。\nPicX 圖床簡介 官方網站： PicX 圖床 專案位址： XPoet/picx: 基於 GitHub API \u0026amp; jsDelivr 開發的具有 CDN 加速功能的圖床管理工具 官方文件： 快速開始-PicX 圖床 特色：只需選擇一個 GitHub 儲存庫作為圖床，然後在 PicX 官網 完成 Token 綁定和相應設定即可使用，免下載與安裝，就這麼簡單。\n快速開始 首先，建立一個 GitHub 儲存庫 點擊連結 Create a New Repository Repository name 輸入一個名稱（例如 image-hosting）\n儲存庫屬性必須選擇 Public\n接著，建立一個具有 repo 權限的 GitHub Token 點擊連結 New personal access token 輸入 Note（即名稱，例如 picx-image-hosting）\n注意：「Expiration」為此 Token 的有效期限，請務必選擇。 如果您過早讀到這篇文章而未進行設定，請參考： 使用 PicX 圖床上傳圖片提示「Bad credentials」– yexca’Blog Select scopes 勾選 repo，然後建立 Token\n注意：新產生的 Token 只會顯示一次，請妥善保管，如有遺失，重新產生即可。\n最後，到官網輸入 Token 設定 開啟 PicX官網 ，進入圖床設定，填入 Token\n然後選擇儲存庫和目錄方式\n建立目錄：需手動輸入一個新目錄。（使用 / 可建立多層目錄，例如：A01/A02 表示建立了二級目錄，最多支援建立三層目錄。） 根目錄：圖片將直接儲存在儲存庫根目錄下。 自動目錄：自動產生日期格式 YYYYMMDD 的目錄。例如：20200909。 好的，圖床已經設定完成，開始使用吧！\n其他設定 設定預設開啟圖片壓縮，可在「我的設定」中進行修改\n","date":"2022-02-17T23:02:13+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/27/","title":"使用 PicX 自建免費圖床"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 前言 由於學校的教務系統查看課表不夠便利，而且第三方課表存在一定的資安疑慮並且廣告很多，於是我便想著把課表匯入日曆，我選擇匯入 Outlook 日曆，這樣可以實現在 iOS、Windows 和 Android 多個裝置上同步。\n準備工作 一台電腦 一支 Android 手機 電腦安裝 Chrome 瀏覽器： 官方網站連結 手機安裝 WakeUp 課表： 官方網站連結 第一步，匯出課表 一、使用 Chrome 開啟教務系統網址，進入課表介面\n二、匯出 HTML 檔案\n首先複製以下程式碼\n1 javascript:void(function(u,s){s=document.body.appendChild(document.createElement(\u0026#39;script\u0026#39;));s.src=u+\u0026#39;?ts=\u0026#39;+Date.now();s.charset=\u0026#39;UTF-8\u0026#39;}(\u0026#39;https://the-red-hat-was-uncovered.gitee.io/supwisdom-course-table/dist.js\u0026#39;)) 接著是加入我的最愛，Windows 下的快速鍵是 Ctrl + D\n按下快速鍵後，可以直接點選「更多」按鈕，來編輯剛才加入的我的最愛，這時候可以修改名稱和 URL（網址），名稱取個好記的（例如「WakeUp 匯出課表」），URL（網址）那邊貼上剛剛複製的程式碼！然後再儲存。\n最後點擊剛剛加入的我的最愛網址（如上所述），此時瀏覽器會自動下載「教務.html」檔案（也就是下一步要用的檔案）\n第二步，匯入 WakeUp 課表 一、將上一步匯出的檔案傳送到手機上\n二、匯入課表至 WakeUp 課表\n手機開啟 WakeUp 課表，匯入新課表（右上方第二個），點選「從 HTML 檔案匯入」\n「選擇學校/教務類型」選擇「樹維教務（簡易匯入）」 ，不用選擇學校，然後選擇檔案後點選右下角\n匯入完成後請注意選擇正確的開學日期或是當前週數\n第三步，匯入日曆 在 WakeUp 課表點選右上方第三個匯出，選擇「匯出為 ICS（日曆用）格式」\n如果是 Android 手機可找到檔案目錄，點擊檔案，用日曆開啟即可\n如果是 iOS 手機可透過寄送電子郵件（帶附件）的方式傳送到手機登入的電子郵件信箱，然後點擊附件匯入\n參考文章 樹維教務簡易匯入 ","date":"2022-02-16T17:53:16+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/26/","title":"將課表匯入日曆（樹維教務）"},{"content":" 📢 本文由 gemini-2.5-flash-lite 翻譯 國內工具 使用站長工具的連接埠掃描，輸入IP位址或網域名稱和連接埠後點擊開始掃描\n如果顯示關閉，則連接埠未開啟或無法連線\n工具連結： 連接埠掃描 – 站長工具 國外工具 使用 you get signal 的 Port Forwarding Tester 進行掃描\n進入後會自動填寫您的IP和 80 連接埠，可修改為想要掃描的IP和連接埠後點擊 Check\n如果出現紅旗並顯示 port ** is closed on ***.***.***.*** 則連接埠未開啟或無法連線\n工具連結： Open Port Check Tool – Test Port Forwarding on Your Router ","date":"2022-02-13T19:46:38+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/25/","title":"查看伺服器連接埠是否開啟"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 引言 由於 QQ 軟體過於臃腫且權限過大，並且經常性卡住無法載入，因此便尋找其他方法。首先是透過 Telegram 收發 QQ 訊息，但設定較為複雜且並不穩定，於是棄用並改用 VS Code。\n插件簡介 名稱: QQ\nID: takayama.vscode-qq\n說明: lite qq for chat in working\n版本: 1.4.2\n發布者: takayama\nVS Marketplace 連結: VS Code QQ Extension GitHub 專案位址： vscode-qq 註：本程式不在本地儲存任何訊息紀錄和圖片。暫不支援臨時對話。\n安裝 首先安裝 VS Code，造訪 官網 點擊 Download 即可下載安裝。\n然後造訪上述 VS Code QQ Extension 連結點擊 Install 即可自動開啟 VS Code 安裝。\n或者打開 VS Code 在左側「延伸模組」(或按 CTRL+SHIFT+X)，然後搜尋 QQ (注意大寫)，點擊第一個安裝。\n功能 按快速鍵「CTRL+SHIFT+P」打開命令面板。\n輸入「QQ Explorer: Login」（或只輸入「login」會顯示對應選項）後按 Enter。\n然後根據提示輸入帳號密碼即可登入成功，此時會顯示相關功能。\n輸入「QQ Explorer: 搜尋好友」即可搜尋好友。\n輸入「QQ Explorer: 搜尋群組」即可搜尋群組。\n設定 在登入成功後控制面板便會有設定，進入設定為 JSON 檔案編輯，內容如下：\n1 2 3 4 5 6 7 8 9 { \u0026#34;account\u0026#34;: ***********, // QQ 號碼 \u0026#34;password\u0026#34;: \u0026#34;********************************\u0026#34;, // QQ 密碼 \u0026#34;platform\u0026#34;: 5, // 登入平台，可更改「1: 手機, 3: 手錶(功能不完整), 4: PC, 5: pad(預設)」 \u0026#34;show_me_add_group_request\u0026#34;: false, \u0026#34;theme\u0026#34;: \u0026#34;default\u0026#34;, // UI 主題，可更改「default(預設) 和 console(控制台風格)」 \u0026#34;theme_css\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;theme_js\u0026#34;: \u0026#34;\u0026#34; } 可自訂主題，詳情參考： 修改/自定義 UI 主題 ","date":"2022-02-11T21:47:56+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/24/","title":"使用 VS Code 收發 QQ 訊息"},{"content":" 📢 本文由 gemini-2.5-flash-lite 翻譯 引言 Potplayer 是非常優秀的影片播放軟體，但最近的版本右下角開始有彈出廣告，非常令人困擾。本文將介紹兩種方法來解決右下角彈窗問題。\n使用無彈窗的舊版本（推薦） 最後一個沒有廣告彈窗的版本是 1.7.18958。\n舊版本的所有 PotPlayer 都可以從以下網址下載：\nPotPlayer 舊版本下載 1.7.18958 版本直接下載連結： 64 位元 | 32 位元 安裝完成後，開啟「設定」（按 F5），在「基本設定」-\u0026gt;「自動更新」中選擇「不使用自動更新」。\n使用綠色版 註：此版本的個人使用體驗感覺不是太好，例如無法靠近吸附視窗、以原始檔案比例開啟等。\n藍奏雲連結 by zdBryan\n一般執行 = 安裝版（包含開始選單捷徑及程式解除安裝捷徑）\n右鍵解壓縮 = 綠色版（本身不提供便攜式軟體，需手動執行綠化處理）\n版本特色\n1、移除驗證，移除右下角空白廣告彈窗！解除安裝時可選擇備份設定。 2、禁止背景網路請求：境外廣告、傳送日誌、檢查升級。 3、整合額外的音訊解碼器及影片解碼器元件。 4、預設配置：一般設定 + 預設啟用自訂解碼器 H.265/HEVC 及硬體加速。 5、刪除 TV 直播列表、登入程式、日誌管理、訊息通知、多語言等不必要的檔案。 參考文章 關於 Potplayer 右下角彈窗解決方案 PotPlayer v1.7.21589 綠色版 ","date":"2022-02-06T21:37:45+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/23/","title":"移除 Potplayer 右下角彈窗"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 前言 (閒聊) 閒暇之餘，於是便想鑽研一下路由器當作網路閘道器（但事後才發現這台路由器的儲存空間太小，無法安裝太多外掛程式，簡直是白忙了一整個下午）\n2022.02.17 更新：無意間發現了一個內建網路閘道器的 FIR300M 韌體，但由於支援的方法過於老舊，若要刷入，請注意辨別。\n原文連結： 更新編譯方法 - FIR300M/FIR302M 的 Openwrt 韌體 免拆機刷 百度網盤： 提取碼: vouv OpenWRT 簡介 OpenWRT 是基於 Linux 的路由器作業系統，擁有許多強大的外掛程式和較佳的擴充性，並且可以透過 SSH 進行連線\n官方網站： OpenWrt Wiki - Welcome to the OpenWrt Project OpenWRT 通用教學： 從零開始學習 OpenWrt: 刷機 + 使用 + 編譯教學 準備工作 一、軟體 HFS 二、適用於 FIR300M 的 OpenWRT 韌體: 百度網盤 三、電腦開啟 Telnet 服務，請參考 win10 如何開啟 telnet 服務 （Win11 也適用，控制台可以在設定中搜尋進入） 簡要步驟 一、登入路由器管理介面 (192.168.1.1) 並登入 二、造訪 http://192.168.1.1/goform/Diagnosis?pingAddr=192.168.1.100|echo\u0026quot;\u0026quot;|telnetd 三、開啟命令提示字元 (cmd)，輸入: telnet 192.168.1.1 四、將韌體傳輸到路由器，等待完成 五、此時進入路由器管理介面即為 OpenWRT (初始無密碼，直接登入即可) 六、點擊 System-Language and Style 可將語系改為中文 詳細步驟 (第四步) 開啟 HFS，將「準備工作」第二步中的韌體重新命名為「1.bin」並拖曳到視窗中\n在命令提示字元 (cmd) 輸入指令「telnet 192.168.1.1」並成功連線後，依序輸入以下指令\n1 2 3 cd /tmp wget http://192.168.1.100/1.bin // 請將「192.168.1.100」替換為您的機器 IP mtd_write -r write 1.bin Kernel // (注意，這裡的 K 是大寫) 執行成功後路由器會自動重新啟動，所以會顯示「連線中斷」\n外掛程式安裝 在 OpenWRT 管理介面點擊「系統-軟體包」即可安裝相應外掛程式\n建議到 Github 尋找相應的外掛程式，當然也可以自行編寫\n因為安裝外掛程式需要網路位址，可以直接複製 Github 相應專案 Release 中的 ipk 檔案連結\n自己編寫要如何安裝？您都已經會自己編寫了，還會不懂這個嗎？ (doge)\n注意事項 外掛程式安裝需要與路由器相容，部分外掛程式可能需要環境依賴，也就是需要先安裝其他外掛程式。\n具體可以透過錯誤訊息進行判斷\n參考文章 FIR300M 免拆機刷 Openwrt 教學 路由器刷韌體——斐訊路由器 FIR300M 刷 OpenWrt 韌體教學 HFS – 超好用的本機檔案分享工具，快速從電腦傳輸檔案到手機等裝置 許迎果 第 215 期 OpenWrt 外掛程式的安裝與移除 ","date":"2022-02-06T20:44:10+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/22/","title":"FIR300M 路由器刷韌體 OpenWRT"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 引言 (廢話) 有時候會有在 Word 文件中插入程式碼的需求，但是直接把程式碼複製過去會不怎麼美觀，而且沒有高亮顯示看著也相當難受。\n工具一 CodeInWord 在 Word 中優雅展現的程式碼/程式碼高亮/Word 中插入程式碼/程式碼格式化 工具二 Syntax Highlight Code In Microsoft Word 使用說明 沒什麼要說明的，把程式碼複製過去，選擇相對應的語言，點擊生成再複製到 Word 中即可。\n附錄 如果以上網站無法使用，可在搜尋引擎搜尋「syntax highlight code in word」。\n參考文章 如何優雅地在 Microsoft Word 中插入程式碼 ","date":"2022-01-20T14:28:52+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/21/","title":"在 Microsoft Word 中插入程式碼（高亮）"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 前言 在玩其他區域的一些小遊戲時，常常會因為亂碼而無法遊玩，或者發生錯誤而不能執行，這時候就需要轉區以匹配正確的文字。\n雖然可以透過修改 Windows 的地區設定來執行，但很多時候這個方法稍微繁瑣，並且需要重新開機。玩完後如果不改回來，則可能導致正常的軟體無法使用，此時便需要相關的轉區軟體。\n軟體取得 軟體官網： Locale Emulator GitHub 專案位址 (releases)： Locale Emulator – GitHub 設定說明 下載並解壓縮後，點擊「LEInstaller」依照需求為目前使用者或所有使用者安裝。\n安裝完成後，點擊「LEGUI」設定轉區環境 (如果玩日本遊戲則不需要，預設會自動設定)。\n使用說明 找到要開啟的遊戲，右鍵點擊執行檔 (.exe)。\n接著選擇 Locale Emulator，然後選擇對應環境執行 (如果是 Win11，請點擊「顯示更多選項」)。\n廢話 僅作為個人記錄，以供自用，官網上就有使用說明。\n","date":"2022-01-14T15:53:40+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/20/","title":"轉區軟體 Locale Emulator"},{"content":" 📢 本文由 gemini-2.5-flash 翻譯 這篇文章由 Hiyoung 編寫\n背景知識：\nLinux 時鐘概述 Linux 系統有兩個時鐘：一個是硬體時鐘，即 BIOS 時間；另一個是系統時鐘，是 Linux 系統 Kernel（核心）時間。 在 Linux 系統上程式執行時讀取的時間都是系統 Kernel（核心）時間。 每次 Linux 開機時，系統 Kernel（核心）會先去讀取硬體時鐘的設定（但是此時的硬體時間不一定準確），然後系統時鐘就會獨立於硬體繼續運作。 綜上所述，所以想要永久修改 Linux 時間並讓時間準確，就需要永久修改硬體時間，不然每次重新開機 Linux 時，系統時間又變回之前的硬體時間。 Linux 時鐘相關指令 系統 Kernel（核心）時鐘的相關指令是 timedatectl 或者 date； 硬體 BIOS 時鐘相關指令是 hwclock 或者 clock。\n1. 在 Linux CLI 介面輸入 date 查看目前 Linux 系統時間 1 date 輸入 hwclock --show 查看硬體時間\n1 hwclock --show 2. 校準 Linux 系統時間（使用 NTP 服務時需要系統連網） CentOS 下安裝配置 NTP 服務的步驟如下： 1 2 # 安裝 NTP 服務的套件 sudo yum install ntp 1 2 # 將 NTP 服務設定為預設啟動 sudo chkconfig ntp on 1 2 # 修改啟動參數，增加 -g -x 參數，允許 NTP 服務在系統時間誤差較大時也能正常運作 sudo vi /etc/sysconfig/ntpd 1 2 # 啟動 NTP 服務 sudo service ntpd restart Ubuntu/Debian 下安裝配置 NTP 服務的步驟如下： 1 2 # 安裝 NTP 服務的套件 sudo apt-get install ntp 1 2 # 修改啟動參數，增加 -g -x 參數，允許 NTP 服務在系統時間誤差較大時也能正常運作 sudo vi /etc/default/ntp 1 2 # 啟動 NTP 服務 sudo service ntp restart 將硬體時鐘調整為與系統時鐘一致 1 hwclock --systohc --localtime (這個好像更有效) 或者\n1 timedatectl set-local-rtc 1 最後將日期寫入 CMOS 永久生效 1 clock -w 或者\n1 hwclock -w 3. 開啟 Google BBR 加速 本文的系統要求為 Debian 9 或更高版本的 Debian Linux，其他作業系統所知不詳，不知是否適合本文的方法。\n注意，本文的配置參數不只啟用 Google BBR，還包括一系列網路參數的優化，直接複製執行使用即可。\nGoogle BBR 一鍵加速 VPS 伺服器很簡單，SSH 登入 VPS 後，分別執行以下 2 個指令即可（滑鼠選取反白後，點滑鼠右鍵複製貼上到 root 帳號的 # 後面，然後按 Enter 鍵）。\n指令 1 1 wget https://raw.githubusercontent.com/bannedbook/fanqiang/master/v2ss/server-cfg/sysctl.conf -O -\u0026gt; /etc/sysctl.con 如果提示 wget: command not found 的錯誤，這是因為你的系統沒有安裝 wget，所以需要先安裝 wget: \u0026lt;strong\u0026gt;apt-get install -y wget\u0026lt;/strong\u0026gt;\n指令 2 1 sysctl -p 執行成功後大致會輸出：（視個人情況而定） fs.file-max = 51200 net.ipv4.conf.lo.accept_redirects = 0 net.ipv4.conf.all.accept_redirects = 0 net.ipv4.conf.default.accept_redirects = 0 net.ipv4.ip_local_port_range = 10000 65000 net.ipv4.tcp_fin_timeout = 15 net.ipv4.tcp_fastopen = 3 net.ipv4.tcp_keepalive_time = 1200 net.ipv4.tcp_rmem = 32768 436600 873200 net.ipv4.tcp_syncookies = 1 net.ipv4.tcp_synack_retries = 2 net.ipv4.tcp_syn_retries = 2 net.ipv4.tcp_timestamps = 0 net.ipv4.tcp_max_tw_buckets = 9000 net.ipv4.tcp_max_syn_backlog = 65536 net.ipv4.tcp_mem = 94500000 91500000 92700000 net.ipv4.tcp_max_orphans = 3276800 net.ipv4.tcp_mtu_probing = 1 net.ipv4.tcp_wmem = 8192 436600 873200 net.core.netdev_max_backlog = 250000 net.core.somaxconn = 32768 net.core.wmem_default = 8388608 net.core.rmem_default = 8388608 net.core.rmem_max = 67108864 net.core.wmem_max = 67108864 net.ipv4.tcp_congestion_control = bbr\n","date":"2022-01-14T01:30:54+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/19/","title":"Linux 伺服器（網路相關）"},{"content":" 📢 本文由 gemini-3-flash-preview 翻譯 注意：此方法為暫時連線，虛擬機重啟或關機後需要重新設定\n虛擬機網路配接器設定 虛擬機的網路配接器共有三種設定：\n橋接模式：指使用本機網路網段 NAT 模式：使用 VMware Network Adapter VMnet8 的網段 Host-only (僅主機模式)：使用 VMware Network Adapter VMnet1 的網段 查看 IP 網段 打開 VMware 左上角的「編輯 - 虛擬網路編輯器」即可看到 VMnet1 和 VMnet8 對應的網段位址 (子網路位址)\n橋接模式的網段需要打開「設定 - 網路和網際網路 - 進階網路設定」，找到相對應的本機連線網路：\n如果使用 WiFi 連線，點擊「WLAN - 查看其他內容」即可看到 IP 位址 如果使用有線連線，點擊「乙太網路 - 查看其他內容」即可看到 IP 位址 注意：如果本機同時連線了乙太網路和 WIFI，則可能需要對 VMware 左上角的「編輯 - 虛擬網路編輯器」進行相關設定。\n需要給予 VMware 管理員權限，如圖所示選擇想要 VMware 連線的網路卡：\n設定虛擬機的 IP 位址 註：我使用的是橋接模式，我的本機 IP 為 192.168.1.116，那麼我可以將虛擬機設定為 192.168.1.0-192.168.1.255 中的任意一個 (除 192.168.1.116)，即前三段相同，最後一段不同即可。\n首先，打開虛擬機並登入 root 使用者，輸入 ifconfig 命令查看網路卡配置：\n如果如圖出現 「ens33」和「lo」或者「其他」和「lo」：\n輸入命令：\n1 2 3 # ifconfig 裝置名稱 (本例為 \u0026#34;ens33\u0026#34;) 要分配的位址 (這裡選擇的是 192.168.1.110) ifconfig ens33 192.168.1.110 如果僅出現「lo」：\n輸入命令：\n1 2 3 # ifconfig 裝置名稱 (一般為 \u0026#34;eth0\u0026#34;) 要分配的位址 (這裡選擇的是 192.168.1.110) ifconfig eth0 192.168.1.110 設定完成後，可再次輸入 ifconfig 命令查看網路卡配置：\n如上圖 IP 成功改為 192.168.1.110。\n可以打開「Windows 終端機」，輸入 ping 192.168.1.110 查看是否生效：\n如圖所示即表示 IP 修改成功且可以連通。\n使用 Xshell 連線 打開 Xshell，點擊「新增」，名稱可自行決定，主機填寫 IP，然後點擊「連線」：\n選擇「接受並儲存」，然後跟隨提示輸入使用者名稱 (root) 和密碼即可：\n","date":"2021-12-26T15:34:59+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/18/","title":"使用 Xshell 連線虛擬機的 CentOS 7 系統"},{"content":" 該文章使用 Google 翻譯處理。\n順序棧 (數組實作) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #include \u0026lt;stdio.h\u0026gt; // 元素 elem 進棧，a 為數組，top 值為目前堆疊的棧頂位置 int push(int* a,int top,int elem) { a[++top]=elem; return top; } // 資料元素出棧 int pop(int * a,int top) { if (top==-1) { printf(\u0026#34;空堆疊\u0026#34;); return -1; } printf(\u0026#34;彈棧元素：%d\\n\u0026#34;,a[top]); top--; return top; } int main(void) { int a[100]; int top=-1; top = push(a, top, 1); top = push(a, top, 2); top = push(a, top, 3); top = push(a, top, 4); top = pop(a, top); top = pop(a, top); top = pop(a, top); top = pop(a, top); top = pop(a, top); return 0; } 輸出結果：\n彈棧元素：4 彈棧元素：3\n彈棧元素：2 彈棧元素：1 空堆疊\n鏈堆疊 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; typedef struct lineStack{ int data; struct lineStack * next; }lineStack; // stack 為目前的鏈棧，a 表示入棧元素 lineStack* push(lineStack * stack,int a) { // 建立儲存新元素的節點 lineStack * line=(lineStack*)malloc(sizeof(lineStack)); line-\u0026gt;data=a; // 新節點與頭節點建立邏輯關係 line-\u0026gt;next=stack; // 更新頭指標的指向 stack=line; return stack; } // 棧頂元素出鏈棧的實作函數 lineStack * pop(lineStack * stack) { if (stack) { // 宣告一個新指標指向棧頂節點 lineStack * p=stack; // 更新頭指針 stack=stack-\u0026gt;next; printf(\u0026#34;出棧元素：%d \u0026#34;,p-\u0026gt;data); if (stack) { printf(\u0026#34;新棧頂元素：%d\\n\u0026#34;,stack-\u0026gt;data); } else { printf(\u0026#34;堆疊已空\\n\u0026#34;); } free(p); } else { printf(\u0026#34;棧內沒有元素\u0026#34;); return stack; } return stack; } int main(void) { lineStack * stack=NULL; stack=push(stack, 1); stack=push(stack, 2); stack=push(stack, 3); stack=push(stack, 4); stack=pop(stack); stack=pop(stack); stack=pop(stack); stack=pop(stack); stack=pop(stack); return 0; } 輸出結果：\n出棧元素：4 新棧頂元素：3 出棧元素：3 新棧頂元素：2\n出棧元素：2 新棧頂元素：1\n出棧元素：1 堆疊已空 棧內沒有元素\n","date":"2021-11-21T22:19:04+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/17/","title":"資料結構 堆疊程式碼"},{"content":" 該文章使用 Google 翻譯處理。\n程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; // malloc()、exit() #define Size 5 // 對 Size 進行巨集定義，表示順序表申請空間的大小 typedef struct Table { int * head; // 宣告了一個名為head的長度不確定的數組，也叫“動態數組” int length; // 記錄當前順序表的長度 int size; // 記錄順序表分配的儲存容量 }table; // 初始化函數 table initTable() { table t; t.head = (int*)malloc(Size * sizeof(int)); // 建構一個空的順序表，動態申請儲存空間 if (!t.head) // 若申請失敗，作出提示並直接退出程序 { printf(\u0026#34;初始化失敗\u0026#34;); exit(0); } t.length = 0; // 空表的長度初始化為 0 t.size = Size; // 空表的初始儲存空間為 Size return t; } // 插入函數，其中，elem 為插入的元素，add 為插入到順序表的位置 table addTable(table t, int elem, int add) { int i; // 判斷插入本身是否有問題（如果插入元素位置比整張表的長度 +1 還大 (如果相等，是尾隨的情況)，或者插入的位置本身不存在，程序作為提示並自動退出) if (add \u0026gt; t.length + 1 || add \u0026lt; 1) { printf(\u0026#34;插入位置有問題\u0026#34;); return t; } // 做插入操作時，首先需要看順序表是否有多餘的儲存空間提供給插入的元素，如果沒有，則需要申請 if (t.length == t.size) { t.head = (int *)realloc(t.head, (t.size + 1) * sizeof(int)); if (!t.head) { printf(\u0026#34;儲存分配失敗\u0026#34;); return t; } t.size += 1; } // 插入操作，需要將從插入位置開始的後續元素，逐個後移 for (i = t.length - 1; i \u0026gt;= add - 1; i--) { t.head[i + 1] = t.head[i]; } // 後移完成後，直接將所需插入元素，新增至順序表的相應位置 t.head[add - 1] = elem; // 由於添加了元素，所以長度 +1 t.length++; return t; } // 刪除函數 table delTable(table t, int add) { int i; if (add \u0026gt; t.length || add \u0026lt; 1) { printf(\u0026#34;被刪除元素的位置有誤\u0026#34;); exit(0); } for (i = add; i \u0026lt; t.length; i++) { t.head[i - 1] = t.head[i]; } t.length--; return t; } // 尋找函數，其中，elem 表示要尋找的資料元素的值 int selectTable(table t, int elem) { int i; for (i = 0; i \u0026lt; t.length; i++) { if (t.head[i] == elem) { return i + 1; } } return -1; } // 更改函數，其中，elem 為要更改的元素，newElem 為新的資料元素 table amendTable(table t, int elem, int newElem) { int add = selectTable(t, elem); t.head[add - 1] = newElem; return t; } // 輸出順序表中元素的函數 void displayTable(table t) { int i; for (i = 0; i \u0026lt; t.length; i++) { printf(\u0026#34;%d \u0026#34;, t.head[i]); } printf(\u0026#34;\\n\u0026#34;); } int main() { int i, add; table t1 = initTable(); // 在順序表中新增元素 for (i = 1; i \u0026lt;= Size; i++) { t1.head[i - 1] = i; t1.length++; } printf(\u0026#34;原順序表：\\n\u0026#34;); displayTable(t1); printf(\u0026#34;刪除元素 1:\\n\u0026#34;); t1 = delTable(t1, 1); displayTable(t1); printf(\u0026#34;在第 2 的位置插入元素 5:\\n\u0026#34;); t1 = addTable(t1, 5, 2); displayTable(t1); printf(\u0026#34;尋找元素 3 的位置:\\n\u0026#34;); add = selectTable(t1, 3); printf(\u0026#34;%d\\n\u0026#34;, add); printf(\u0026#34;將元素 3 改為 6:\\n\u0026#34;); t1 = amendTable(t1, 3, 6); displayTable(t1); return 0; } 結果 程式運行結果為：\n原順序表： 1 2 3 4 5\n刪除元素 1:\n2 3 4 5\n在第 2 的位置插入元素 5:\n2 5 3 4 5\n尋找元素 3 的位置:\n3\n將元素 3 改為 6:\n2 5 6 4 5\n","date":"2021-11-20T23:01:47+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/16/","title":"資料結構 順序表程式碼"},{"content":" 該文章使用 Google 翻譯處理。\n簡單鍊錶 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include \u0026lt;stdio.h\u0026gt; struct student { long num; float score; struct student *next; }; void main() { struct student a, b, c, *head, *p; a.num = 99101; a.score = 89.5; b.num = 99103; b.score = 90; c.num = 99107; c.score = 85; // 對結點的 num 和 score 成員賦值 head = \u0026amp;a; // 將結點 a 的起始位址賦給頭指標 head a.next = \u0026amp;b; // 將結點 b 的起始位址賦給 a 結點的 next 成員 b.next = \u0026amp;c; c.next = NULL; // c 結點的 next 成員不存放其他結點位址 p = head; // 使 p 指標指向 a 結點 do { printf(\u0026#34;%ld %5.1f\\n\u0026#34;, p-\u0026gt;num, p-\u0026gt;score); // 輸出 p 指向的結點的數據 p = p-\u0026gt;next; // 使 p 指向下一個結點 }while(p != NULL); // 輸出完 c 結點後 p 的值為 NULL system(\u0026#34;pause\u0026#34;); } 記憶體分配函數 malloc 函數 1 void *malloc(unsigned int size); 作用是在記憶體的動態儲存區中分配一個長度為 size 的連接空間。有些函數的值（即傳回值）是一個指向分配空間起始位址的指標（基底型別為 void）。如果些函數未能成功地執行（例如記憶體空間不足）則傳回空指標 NULL。\ncalloc 函數 1 void *calloc(unsigned n, unsigned size); 其作用是在記憶體的動態區儲存中分配 n 個長度為 size 的連續空間。函數傳回一個指向分配空間起始位址的指針，如果分配不成功，則傳回 NULL。 用 calloc 函數可以為一維數組開啟動態儲存空間， n 為數組元素個數，每個元素長度為 size。\nfree 函數 1 void free(void *p); 其作用是釋放由 p 指向的記憶體區，使這部分記憶體區能被其它變數使用， p 是最後一次呼叫 calloc 或 malloc 函數時傳回的值。 free 函數無回傳值​​。請注意：以前的C版本提供的 malloc 和 calloc 函數得到的是指向字元型資料的指標。 ANSI C 提供的 malloc 和 calloc 函數規定為 void * 類型。\n動態鍊錶的實現 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #define NULL 0 #define LEN sizeof(struct student) struct student { long num; float score; struct student *next; }; struct student *create() { struct student *p1, *p2, *head; int num; float score; int n = 0; head = NULL; p1 = p2 = (struct student *)malloc(LEN); printf(\u0026#34;please input num and score.\\n\u0026#34;); scanf(\u0026#34;%d,%f\u0026#34;, \u0026amp;p1-\u0026gt;num, \u0026amp;p1-\u0026gt;score); while(p1-\u0026gt;num != 0) { n ++; if(n == 1) head = p1; else p2-\u0026gt;next = p1; p2 = p1; p1 = (struct student *)malloc(sizeof(struct student)); printf(\u0026#34;please input num and score.\\n\u0026#34;); scanf(\u0026#34;%d,%f\u0026#34;, \u0026amp;p1-\u0026gt;num, \u0026amp;p1-\u0026gt;score); } p2-\u0026gt;next = NULL; return head; } void printlist(struct student *head) { struct student *p; p = head; if(head != NULL) { do { printf(\u0026#34;num=%d score=%f\\n\u0026#34;, p-\u0026gt;num, p-\u0026gt;score); p = p-\u0026gt;next; }while(p != NULL); } } void main() { struct student *head; head = create(); printlist(head); system(\u0026#34;pause\u0026#34;); } // 列印鍊錶 void printlist(struct student *head) { struct student *p; p = head; if(head != NULL) { do { printf(\u0026#34;num=%d score=%5.2f\\n\u0026#34;, p-\u0026gt;num, p-\u0026gt;score); p = p-\u0026gt;next; } while (p != NULL); } /* while(p -\u0026gt; next != NULL) { printf(\u0026#34;num=%d score=%f\\n\u0026#34;, p-\u0026gt;num, p-\u0026gt;score); p = p-\u0026gt;next; }*/ } // 刪除節點 struct student *delNode(struct student *head, int num) { printf(\u0026#34;delNode.\\n\u0026#34;); struct student *p1, *p2; if(head == NULL) { printf(\u0026#34;The List is NULL.\\n\u0026#34;); } else { p1 = head; while(p1-\u0026gt;next != NULL \u0026amp;\u0026amp; p1-\u0026gt;num != num) { p2 = p1; p1 = p1-\u0026gt;next; } if(p1-\u0026gt;num == num) { if(p1 == head) head = p1-\u0026gt;next; else p2-\u0026gt;next = p1-\u0026gt;next; } else printf(\u0026#34;Can not find list num.\\n\u0026#34;); } return head; } // 更新節點 struct student *update(struct student *head, int index, int num, float score) { printf(\u0026#34;update.\\n\u0026#34;); struct student *p; if(head == NULL) { printf(\u0026#34;The List is NULL.\\n\u0026#34;); } else { p = head; while(p-\u0026gt;next != NULL \u0026amp;\u0026amp; p-\u0026gt;num != index) { p = p-\u0026gt;next; } if(p-\u0026gt;num == index) { p-\u0026gt;num = num; p-\u0026gt;score = score; } else printf(\u0026#34;Can not find list index.\\n\u0026#34;); } return head; } // 增加節點 struct student *add(struct student *head, int index, int num, float score) { printf(\u0026#34;add.\\n\u0026#34;); struct student *p1, *p2, *p3; if(head == NULL) { printf(\u0026#34;The List is NULL.\\n\u0026#34;); } else { p1 = p2 = head; while(p1-\u0026gt;next != NULL \u0026amp;\u0026amp; p1-\u0026gt;num != index) { p1 = p1-\u0026gt;next; p2 = p1; } if(p1-\u0026gt;num == index) { p3 = (struct student *)malloc(LEN); p3-\u0026gt;num = num; p3-\u0026gt;score = score; if(p2-\u0026gt;next == NULL) { p2-\u0026gt;next = p3; p3-\u0026gt;next = NULL; } else { p3-\u0026gt;next = p2-\u0026gt;next; p2-\u0026gt;next = p3; } } else printf(\u0026#34;Can not find list index.\\n\u0026#34;); } return head; } ","date":"2021-11-17T12:00:49+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/15/","title":"資料結構 鍊錶程式碼"},{"content":" 該文章使用 Google 翻譯處理。\n該文章由 Hiyoung 編寫，翻譯自 yexca\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 //數組堆疊的實現 #include\u0026lt;stdio.h\u0026gt; #define MaxSize 50 typedef struct Stack_Array{ int data[MaxSize]; int top; }Sqstack,*pSqstack; void Initstack(); //初始化 int Isempty(); //判斷棧空 int Push(); //入堆疊 int Pop(); //出堆疊 int Gettop(); //get 堆疊頂元素 int main(void) //測試 { int val; Sqstack s1; pSqstack ps1=\u0026amp;s1; Initstack(\u0026amp;s1); //初始化 if(Isempty(\u0026amp;s1)) //判斷棧空 printf(\u0026#34;棧為空！\\n\u0026#34;); else printf(\u0026#34;棧不為空！\\n\u0026#34;); printf(\u0026#34;輸入壓棧元素的值\u0026#34;); //壓棧 1 scanf(\u0026#34;%d\u0026#34;,\u0026amp;val); Push (ps1,\u0026amp;val); printf(\u0026#34;輸入壓棧元素的值\u0026#34;); //壓棧 2 scanf(\u0026#34;%d\u0026#34;,\u0026amp;val); Push (ps1,\u0026amp;val); if(Isempty(ps1)) //判斷棧空 printf(\u0026#34;棧為空！\\n\u0026#34;); else printf(\u0026#34;棧不為空！\\n\u0026#34;); if(Gettop(ps1,\u0026amp;val)) //get 堆疊頂元素 printf(\u0026#34;棧頂值為%d\\n\u0026#34;,val); else printf(\u0026#34;棧頂元素查找失敗！\\n\u0026#34;); if(Pop(ps1,\u0026amp;val)) //出棧 printf(\u0026#34;出棧成功，出棧元素為%d\\n\u0026#34;,val); else printf(\u0026#34;出棧失敗！\\n\u0026#34;); return 0; } //初始化 void Initstack (pSqstack ps1) { ps1-\u0026gt;top=-1; return; } //判斷棧空 int Isempty(pSqstack ps1) { if(ps1-\u0026gt;top==-1) return 1; else return 0; } //若棧不滿，則進行壓棧 int Push(pSqstack ps1,int *val)//*val:接受一個地址(int *(\u0026amp;val)) { if(ps1-\u0026gt;top==MaxSize) return 0; else { ps1-\u0026gt;top++; ps1-\u0026gt;data[ps1-\u0026gt;top]=*val;//這裡傳遞的是值，這裡的*val是*(\u0026amp;val),\u0026amp;val是由主調函數輸入 //也可写作ps1-\u0026gt;data[++ps1-\u0026gt;top]=*val; 一定是++ps1-\u0026gt;top return 1; } } //若棧不空，則進行出棧，用val返回棧頂元素 int\tPop(pSqstack ps1,int *val) { if(Isempty(ps1)) return 0; else { *val=ps1-\u0026gt;data[ps1-\u0026gt;top--]; return 1; } } //get棧頂元素，用val返回棧頂元素 int Gettop(pSqstack ps1,int *val) { if(Isempty(ps1)) return 0; else { *val=ps1-\u0026gt;data[ps1-\u0026gt;top]; return 1; } } 圖解簡化\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 //棧的鍊式存儲實現 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #define Stack_Init_Size 10 // 初始化堆疊的最大長度 #define StackIncrement 10 // 若堆疊最大空間不夠時，需要增加的長度 typedef int ElemType; typedef int Status; typedef struct { ElemType *base; // 堆疊底部指針 ElemType *top; // 堆疊頂指針 int stack_size; // 堆疊的最大長度 } SqStack; // 初始化堆疊 Status InitStack(SqStack *S) { // 分配初始空間 S-\u0026gt;base = (ElemType *) malloc(Stack_Init_Size * sizeof(ElemType)); if (!S-\u0026gt;base) { exit(0); } S-\u0026gt;top = S-\u0026gt;base; /// 棧頂與棧底相同 S-\u0026gt;stack_size = Stack_Init_Size; // 堆疊的最大長度等於初始長度 return 1; } // 判斷棧是否為空，只需要判斷棧頂指標與棧底指標是否相同即可 Status EmptyStack(SqStack *S) { return S-\u0026gt;base == S-\u0026gt;top; } // 取得棧的實際長度，棧頂減去棧底指標即為棧的長度 Status LengthStack(SqStack *S) { if (S-\u0026gt;top == S-\u0026gt;base) { return 0; } return (Status) (S-\u0026gt;top - S-\u0026gt;base); } // 取得棧頂的元素，參數e用來存放棧頂的元素 Status GetTopStack(SqStack *S, ElemType *e) { if (S-\u0026gt;top == S-\u0026gt;base) { return 0; } *e = *(S-\u0026gt;top - 1); return 1; } // 進棧，參數e是要進棧的元素 Status PushStack(SqStack *S, ElemType e) { // 若棧的最大長度不會夠用時，重新開闢，增大長度 if (S-\u0026gt;top - S-\u0026gt;base \u0026gt;= S-\u0026gt;stack_size) { S-\u0026gt;base = (ElemType *)realloc(S-\u0026gt;base, (S-\u0026gt;stack_size + StackIncrement) * sizeof(ElemType)); if (!S-\u0026gt;base) { return 0; } // 棧頂指標為棧底指標加上堆疊之前的最大長度 S-\u0026gt;top = S-\u0026gt;base + S-\u0026gt;stack_size; // 堆疊目前的最大長度等於堆疊之前的最大長度與增加的長度總和 S-\u0026gt;stack_size += StackIncrement; } *S-\u0026gt;top++ = e; // 先賦值，後棧頂指標上移 return 1; } // 出棧，參數e用來存放出棧的元素 Status PopStack(SqStack *S, ElemType *e) { if (S-\u0026gt;base == S-\u0026gt;top) { return 0; } *e = *--S-\u0026gt;top; // 棧頂指標先下移，後賦值 return 1; } // 銷毀棧，釋放棧空間，棧頂棧底指標置為NULL，長度置為0 Status DestroyStack(SqStack *S) { free(S-\u0026gt;base); S-\u0026gt;base = S-\u0026gt;top = NULL; S-\u0026gt;stack_size = 0; return 1; } // 遍歷棧，依序列印每個元素 Status StackTraverse(SqStack *S) { ElemType *p; if (S-\u0026gt;top == S-\u0026gt;base) { printf(\u0026#34;Stack is NULL.\\n\u0026#34;); return 0; } p = S-\u0026gt;top; // 由棧頂依序向下遍歷 while (p \u0026gt; S-\u0026gt;base) { p--; printf(\u0026#34;%d \u0026#34;, *p); } printf(\u0026#34;\\n\u0026#34;); return 1; } int main() { SqStack q, *S; S = \u0026amp;q; int i, n, e; printf(\u0026#34;Creat a NULL Stack :\\n\u0026#34;); InitStack(S); printf(\u0026#34;input the length of the Stack :\\n\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (i = 1; i \u0026lt;= n; i++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;e); PushStack(S, e); } printf(\u0026#34;Is the stack NULL?\\n\u0026#34;); if (EmptyStack(S)) { printf(\u0026#34;Yes!\\n\u0026#34;); } else { printf(\u0026#34;No!\\n\u0026#34;); } printf(\u0026#34;The length of stack is %d.\\n\u0026#34;, LengthStack(S)); printf(\u0026#34;The stack is :\\n\u0026#34;); StackTraverse(S); e = GetTopStack(S, \u0026amp;e); printf(\u0026#34;The top data is %d.\\n\u0026#34;, e); printf(\u0026#34;input the data to the stack :\\n\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;e); PushStack(S, e); printf(\u0026#34;The new stack is :\\n\u0026#34;); StackTraverse(S); printf(\u0026#34;Delete the top data : \u0026#34;); e = PopStack(S, \u0026amp;e); printf(\u0026#34;%d\\n\u0026#34;, e); printf(\u0026#34;The new stack is :\\n\u0026#34;); StackTraverse(S); printf(\u0026#34;Destroy the stack :\\n\u0026#34;); DestroyStack(S); StackTraverse(S); return 0; } ","date":"2021-11-11T23:03:27+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/14/","title":"C 資料結構程式碼"},{"content":" 該文章由 ctxbb 編寫，因為是圖片，沒翻譯\n","date":"2021-11-11T18:01:33+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/13/","title":"揚州杏雨後"},{"content":" 該文章使用 Google 翻譯處理。\n雖然米忽悠的米遊社提供了原神樹脂的查看，但是使用電腦時每次查看還要打開手機然後打開米遊社著實有億點不方便\n原作者文章： 自己做了一個樹脂記錄軟件 原文軟件鏈接： 提取碼：1w5b 下載完成後打開，會提示輸入 uid 和 cookie，下面是如何抓取米遊社的 cookie\n首先打開 米遊社 並登錄\n然後按 F12 打開開發者工具，這時刷新網頁\n然後點擊“網絡-ys/”，找到請求標頭，然後在 cookie 右擊複製\n注意：需要的 cookie 字段為 account_id=xxx; cookie_token=xxx，請自行修改\n**2022-6-6 修改 ( hiyoung )**\n由於米哈遊修改了 bbs 可以獲取的 Cookie，導致一次獲取的 Cookie 缺失，所以需要增加步驟\n按下鍵盤上的 F12 或右鍵檢查,開啟開發者工具,點選 Console\n輸入\n1 var cookie=document.cookie;var ask=confirm(\u0026#39;Cookie:\u0026#39;+cookie+\u0026#39;\\n\\nDo you want to copy the cookie to the clipboard?\u0026#39;);if(ask==true){copy(cookie);msg=cookie}else{msg=\u0026#39;Cancel\u0026#39;} 回車執行，並在確認無誤後點擊確定。此時 Cookie 已經復製到你的粘貼板上了\n注意：請使用 Chrome，Edge 獲取也是不完整的 ( yexca )\n","date":"2021-11-10T15:21:30+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/12/","title":"原神樹脂查看與推送"},{"content":" 該文章使用 Google 翻譯處理。\n首先我們找到要下載的視頻 (廢話)，複製圖中框選部分的鏈接\n然後打開 視頻下載解析網站 ，輸入複製的鏈接然後點擊解析視頻圖片 (如需驗證根據網站提示進行即可)\n然後點擊下載視頻即可\n// 這篇好水\n","date":"2021-11-10T11:29:51+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/11/","title":"微博影片下載"},{"content":" 該文章使用 Google 翻譯處理。\n多數情況下，我們瀏覽網頁一般使用瀏覽器或系統自帶的返回，但有些系統的交互邏輯及其不好用，這時在網頁添加一個返回上一頁按鈕可以極大改善瀏覽體驗\n首先，在 WordPress 的後台點擊“外觀-自定義”來到可視化編輯頁面\n在左方找到“額外CSS”選項（一般在最後）\n然後在裡面輸入下方代碼\n1 2 3 4 5 6 7 8 .float-button { position: fixed; height: 90px; width: 40px; bottom: 90px; right: 50px; /* 可以自行修改相關描述 */ } 輸入完成後儲存，然後編輯主題相關介面\n如果您不能訪問服務器文件，可以在 WordPress 後台的“外觀-主題編輯器”中找到要添加的界面修改\n如果您可以存取伺服器文件，可以開啟路徑 網站根目錄/wp-content/themes/\u0026lt;您的主題名稱\u0026gt;/ 然後開啟相應頁面修改\n只需在相關頁面文件插入下面代碼並保存即可\n1 2 3 4 \u0026lt;div class=\u0026#34;float-button\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; name=\u0026#34;Submit\u0026#34; value=\u0026#34;返回\u0026#34; onclick=\u0026#34;javascript:history.back(-1);\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- 可以自行修改相關描述 --\u0026gt; 參考文章 網頁上的「返回上一頁」的幾種實作程式碼 div 套路之懸浮的 button ","date":"2021-11-10T11:06:27+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/10/","title":"WordPress 新增返回上一頁按鈕"},{"content":" 該文章使用 Google 翻譯處理。\n該文章由 Hiyoung 編寫，翻譯自 yexca\n準備條件：win11 專業版及以上，將系統地區調至美國\n在設置-\u0026gt;應用 -\u0026gt; 可選功能 -\u0026gt; 更多Windows功能中勾選虛擬機平台，然後重啟系統即可\n然後下載安裝包，鏈接: https://pan.baidu.com/s/1215GlKeDCHcbE0I2SgtWLg 提取碼: frkx\n下載完成後我們可以看到下面兩個文件：倒數第二個是安卓子系統安裝包，倒數第一個是WSA工具箱用於安裝 apk 文件\n最下面兩份文件\n現在我們以管理員身份打開 Windows power shell\n執行指令：add-appxpackage 空格 + 安卓子系統的文件路徑 (切記指令與路徑之間加一個空格)\n!Win11android_4 出現上面這個即說明安裝成功\n然後在開始選單即可看到安裝完成的安卓子系統，點擊運行，勾選上開發者模式\n解壓縮另一個 zip 檔案運行，即可安裝 apk 文件\n至此即安裝完成\n**********以下內容由 yexca 添加**********\n如果工具箱無法安裝或出現下圖情況，請打開子系統設置，打開第一個選項“文件”，再打開工具箱即可 獲取文件路徑 在文件上鼠標右擊選擇“屬性-安全”，第一行對象名稱即為文件路徑\nWSA 工具箱 原發布地址 ","date":"2021-11-09T23:45:42+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/9/","title":"Win11 官方安卓子系統安裝"},{"content":" 該文章使用 Google 翻譯處理。\n該文章由 Hiyoung 編寫，翻譯自 yexca\n1.SQL ORDER BY 關鍵字 ORDER BY 關鍵字用於對結果集按照一個列或者多個列進行排序。\nORDER BY 關鍵字默認按照升序對記錄進行排序。如果需要按照降序對記錄進行排序，您可以使用 DESC 關鍵字\nSQL ORDER BY 語法 1 2 3 SELECT *column\\_name*,*column\\_name* FROM *table\\_name* ORDER BY *column\\_name*1,*column\\_name*2 ASC|DESC; –ASC 表示升序，DESC 表示降序\n–使用 order by 語句時應放在所有語句的最後使用，並且排序多個列時先排 column\\_name1 再 column\\_name2…\n2.刪除所有數據（delete 和 drop table） 您可以在不刪除表的情況下，刪除表中所有的行。這表示表格結構、屬性、索引將保持不變：DELETE FROM table\\_name;\n或\nDELETE * FROM table\\_name;\n**註釋：**在刪除記錄時要格外小心！因為您不能重來！\nDROP TABLE 語句 DROP TABLE 語句用於刪除表。DROP TABLE table\\_name\n**註釋：**與 elete 不同的是 drop table 會刪除表數據和結果，也是不可逆的！\nDROP DATABASE 語句 DROP DATABASE 語句用於刪除數據庫。DROP DATABASE database\\_name\nTRUNCATE TABLE 語句 如果我們僅僅需要刪除表內的數據，但並不刪除表本身，那麼我們該如何做呢？\n請使用 TRUNCATE TABLE 語句：TRUNCATE TABLE table\\_name\n3.SQL join SQL join 用於把來自兩個或多個表的行結合起來。\n下圖展示了 LEFT JOIN、RIGHT JOIN、INNER JOIN、OUTER JOIN 相關的 7 種用法。\nINNER JOIN：如果表中有至少一個匹配，則返回行(INNER JOIN 與 JOIN 是相同的) LEFT JOIN：即使右表中沒有匹配，也從左表返回所有的行 RIGHT JOIN：即使左表中沒有匹配，也從右表返回所有的行 FULL JOIN：只要其中一個表中存在匹配，則返回行 註釋：SQL 中的 join 語句其實對應數據庫理論中的連接概念，left join、right join 和 inner join 對應自然連接，full join 對應笛卡爾積\n4.SQL 約束 (Constraints) 1 2 3 4 5 6 7 CREATE TABLE table_name ( column_name1 data_type(size) constraint_name, column_name2 data_type(size) constraint_name, column_name3 data_type(size) constraint_name, .... ); NOT NULL – 指示某列不能存儲 NULL 值。 UNIQUE – 保證某列的每行必須有唯一的值。（一個表可以有多個 UNIQUE 約束但只能有一個 primary key，primary key 自動包含 unique 約束） PRIMARY KEY – NOT NULL 和 UNIQUE 的結合。確保某列（或兩個列多個列的結合）有唯一標識，有助於更容易更快速地找到表中的一個特定的記錄。（主鍵） FOREIGN KEY – 保證一個表中的數據匹配另一個表中的值的參照完整性。（外鍵） CHECK – 保證列中的值符合指定的條件。 DEFAULT – 規定沒有給列賦值時的默認值。 5.AUTO INCREMENT 字段 我們通常希望在每次插入新記錄時，自動地創建主鍵字段的值。\n我們可以在表中創建一個 auto-increment 字段。\n下面的 SQL 語句把 “Persons” 表中的 “ID” 列定義為 auto-increment 主鍵字段：CREATE TABLE Persons\n1 2 3 4 5 6 7 ( ID int IDENTITY(1,1) PRIMARY KEY, LastName varchar(255) NOT NULL, FirstName varchar(255), Address varchar(255), City varchar(255) ) 在上面的實例中，IDENTITY 的開始值是 1，每條新記錄遞增 1。\n**提示：**要規定 “ID” 列以 10 起始且遞增 5，請把 identity 改為 IDENTITY(10,5)。\n要在 “Persons” 表中插入新記錄，我們不必為 “ID” 列規定值（會自動添加一個唯一的值）：\n1 2 INSERT INTO Persons (FirstName,LastName) VALUES (\u0026#39;Lars\u0026#39;,\u0026#39;Monsen\u0026#39;) 上面的 SQL 語句會在 “Persons” 表中插入一條新記錄。”ID” 列會被賦予一個唯一的值。”FirstName” 列會被設置為 “Lars”，”LastName” 列會被設置為 “Monsen”。\n6.觸發器 參見： SqlServer 基礎之(觸發器) – wangchuang2017 – 博客園 ","date":"2021-11-08T11:51:18+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/8/","title":"SQL 語句的一些語法細節 (SQL SERVER 語句)"},{"content":" 該文章使用 Google 翻譯處理。\n該文章由 Hiyoung 編寫，翻譯自 yexca\n在安裝完 SQL server 和 navicat 後在 navicat 中添加數據庫：\n1.連接名無要求，按照自己需要命名\n2.打開安裝好的 SQL server 配置管理器\n注意 SQL Server（SQLEXPRESS）要保證在運行中，否則 navicat 無法連接\n雙擊開啟後點選服務，可以看到自己的主機名\n3.此時打開 navicat 在主機的地方填上：主機名 \\SQLEXPRESS (格式)\n4.用戶名填 sa (為安裝 SQL server 時的預設用戶名，具體 SQL server 網路教學很多可以自己參考) ，密碼是自己設定的 (同樣在 SQL server 安裝時設定的密碼)\n5.測試連接成功即可使用\n注：僅個人在安裝過程中遇到的問題，具體安裝教程請參考網絡\n附上 navicat 15 及註冊機： https://pan.baidu.com/s/1cJ1EZ9Gyz6Jp6J03VqcDHA 提取碼：3n7g\n","date":"2021-11-07T23:41:46+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/7/","title":"關於在使用 navicat 連接 SQL server 的一些問題"},{"content":" 該文章使用 Google 翻譯處理。\n該文章由 Hiyoung 編寫，翻譯自 yexca\n其文章 (簡體中文): https://blog.hiyoung.icu/2022/12/15/997871bc263d/ 正文 VSC只是一個純文本編輯器，不是 IDE (集成開發環境)，不含編譯器和許多其它功能，所以編譯器要自己裝好\n第一步：在 vscode 官網下載軟件，鏈接： Visual Studio Code – Code Editing. Redefined 第二步：我們需要下載一個編譯器，C 語言使用 gcc，鏈接： MinGW-w64 – for 32 and 64 bit Windows download | SourceForge.net ，選最新版本中的 x86\\_64-posix-seh 即可，網站下載可能較慢，下面給出百度網盤鏈接\n（以下附上百度網盤秒傳鏈接：b48357234368d9ba439fc0db6e86531d#84cbf1dc60abe4fff77d035540ea3132#140697937#mingw64.zip）\n（正常百度網盤鏈接：鏈接: https://pan.baidu.com/s/17FYT\\_Y-s-I2yajFc2MICqw 提取碼: ewis ）\n第三步：將 E:\\mingw64\\bin 添加到系統變量中（盤符根據自己編譯器安裝的位置）\n以 Win11 為例：打開設置-\u0026gt;系統-\u0026gt;關於-\u0026gt;高級系統設置-\u0026gt;環境變量-\u0026gt;系統變量-\u0026gt;點擊Path-\u0026gt;編輯-\u0026gt; 瀏覽-\u0026gt; 把對應文件加入即可\n第四步：\n按 Win+R，運行 cmd（不要跳這一步），輸入 gcc，應該會提示 no input files 而不是“不是內部命令或外部命令”或者“無法將“gcc” 項識別為cmdlet、函數、腳本文件或可運行程序的名稱”。如果是“不是內部命令或外部命令”，說明 gcc 在的文件夾沒有在環境變量的Path中，要加進去才行。如果加了還是這樣，重啟（不要忘記重啟）。如果重啟了還不行，那就是你自己進行的操作有問題。\n輸 gcc -v 可以顯示出 gcc 的版本。如果顯示出來的版本與你剛下的不同/更老，說明 Path 裡原本有老版本的編譯器，可能是安裝其它 IDE 時裝上的。則需要去掉 Path 裡原來的那一個 gcc 的路徑。\n這兩項驗證一定要符合，否則必須修改環境變量。小心別錯刪了。\n第五步：現在打開 vscode，下載相關插件\n第六步：我們需要寫兩個 json 文件，下面依次是 launch.json 和tasks.json（兩個文件名也必須是launch.json 和tasks.json ） 注意看代碼註釋，兩個文件都有幾處地方需要將路徑改為自己編譯器的路徑\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 { // 使用 IntelliSense 了解相關屬性。 // 懸停以查看現有屬性的描述。 // 欲了解更多信息，請訪問: https://go.microsoft.com/fwlink/?linkid=830387 \u0026#34;version\u0026#34;: \u0026#34;0.2.0\u0026#34;, \u0026#34;configurations\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;gcc.exe - 生成和調試活動文件\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;cppdbg\u0026#34;, \u0026#34;request\u0026#34;: \u0026#34;launch\u0026#34;, \u0026#34;program\u0026#34;: \u0026#34;${fileDirname}\\\\bin\\\\$ {fileBasenameNoExtension}.exe\u0026#34;,//這裡意思生成的二進制代碼會放入當前文件的bin文件夾中，我們需要自己新建一個bin文件夾 \u0026#34;args\u0026#34;: [], \u0026#34;stopAtEntry\u0026#34;: false, \u0026#34;cwd\u0026#34;: \u0026#34;${fileDirname}\u0026#34;, \u0026#34;environment\u0026#34;: [], \u0026#34;externalConsole\u0026#34;: false, \u0026#34;MIMode\u0026#34;: \u0026#34;gdb\u0026#34;, \u0026#34;miDebuggerPath\u0026#34;: \u0026#34;E:\\\\mingw64\\\\bin\\\\gdb.exe\u0026#34;, \u0026#34;setupCommands\u0026#34;: [ { \u0026#34;description\u0026#34;: \u0026#34;為 gdb 啟用整齊打印\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;-enable-pretty-printing\u0026#34;, \u0026#34;ignoreFailures\u0026#34;: true } ], \u0026#34;preLaunchTask\u0026#34;: \u0026#34;C/C++: gcc.exe 生成活動文件\u0026#34; } ] } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 { \u0026#34;tasks\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;cppbuild\u0026#34;, \u0026#34;label\u0026#34;: \u0026#34;C/C++: gcc.exe 生成活動文件\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;E:\\\\mingw64\\\\bin\\\\gcc.exe\u0026#34;,//改成自己的檔案路徑 \u0026#34;args\u0026#34;: [ /*\u0026#34;${fileDirname}\\\\*.c\u0026#34;, \u0026#34;-o\u0026#34;, \u0026#34;${fileDirname}\\\\bin\\\\${fileBasenameNoExtension}.exe\u0026#34;, \u0026#34;-g\u0026#34;//多檔編譯*/ \u0026#34;-g\u0026#34;, \u0026#34;${file}\u0026#34;, \u0026#34;-o\u0026#34;, \u0026#34;${fileDirname}\\\\bin\\\\${fileBasenameNoExtension}.exe\u0026#34;//這裡意思產生的二進位程式碼會放入目前檔案的 bin 資料夾中，我們需要自己新建一個 bin 資料夾 ], \u0026#34;options\u0026#34;: { \u0026#34;cwd\u0026#34;: \u0026#34;${fileDirname}\u0026#34; }, \u0026#34;problemMatcher\u0026#34;: [ \u0026#34;$gcc\u0026#34; ], \u0026#34;group\u0026#34;: { \u0026#34;kind\u0026#34;: \u0026#34;build\u0026#34;, \u0026#34;isDefault\u0026#34;: true }, \u0026#34;presentation\u0026#34;: { \u0026#34;echo\u0026#34;: true, \u0026#34;reveal\u0026#34;: \u0026#34;always\u0026#34;, // 執行任務時是否跳到終端面板，可以為 always，silent，never。具體參見 VSC 的文檔 \u0026#34;focus\u0026#34;: true, // 設為 true 後可以使執行 task 時焦點聚集在終端，但對編譯 C/C++ 來說，設為 true 沒有意義 \u0026#34;panel\u0026#34;: \u0026#34;shared\u0026#34; // 不同的檔案的編譯資訊共享一個終端面板 }, \u0026#34;detail\u0026#34;: \u0026#34;調試器生成的任務。\u0026#34; }, { \u0026#34;type\u0026#34;: \u0026#34;cppbuild\u0026#34;, \u0026#34;label\u0026#34;: \u0026#34;(多文件)gcc.exe - 生成和調試活動文件\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;E:\\\\mingw64\\\\bin\\\\gcc.exe\u0026#34;,//改成自己的檔案路徑 \u0026#34;args\u0026#34;: [ \u0026#34;${fileDirname}\\\\*.c\u0026#34;, \u0026#34;-o\u0026#34;, \u0026#34;${fileDirname}\\\\bin\\\\${fileBasenameNoExtension}.exe\u0026#34;,//這裡意思產生的二進位程式碼會放入目前檔案的 bin 資料夾中，我們需要自己新建一個 bin 資料夾 \u0026#34;-g\u0026#34; ], \u0026#34;options\u0026#34;: { \u0026#34;cwd\u0026#34;: \u0026#34;${fileDirname}\u0026#34; }, \u0026#34;problemMatcher\u0026#34;: [ \u0026#34;$gcc\u0026#34; ], \u0026#34;group\u0026#34;: { \u0026#34;kind\u0026#34;: \u0026#34;build\u0026#34;, \u0026#34;isDefault\u0026#34;: true }, \u0026#34;presentation\u0026#34;: { \u0026#34;echo\u0026#34;: true, \u0026#34;reveal\u0026#34;: \u0026#34;always\u0026#34;, // 執行任務時是否跳到終端面板，可以為 always，silent，never。具體參見 VSC 的文檔 \u0026#34;focus\u0026#34;: true, // 設為 true 後可以使執行 task 時焦點聚集在終端，但對編譯 C/C++ 來說，設為 true 沒有意義 \u0026#34;panel\u0026#34;: \u0026#34;shared\u0026#34; // 不同的檔案的編譯資訊共享一個終端面板 }, \u0026#34;detail\u0026#34;: \u0026#34;調試器生成的任務。\u0026#34; } ], \u0026#34;version\u0026#34;: \u0026#34;2.0.0\u0026#34; } 至此設置工作基本結束，vscode 有許多好用的插件可以自己探索，未來也會在寫一篇文章推荐一些好用的插件\n","date":"2021-11-07T23:32:26+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/6/","title":"VsCode 配置 C 語言環境"},{"content":" 該文章使用 Google 翻譯處理。\n正文 安裝完成 VS Code 和 Python 並配置環境變量後\n開啟 VS Code，進入拓展搜尋並下載 Python\n在資源管理器新建一個 Python 原始檔 (.py) 後，資源管理器會在.vscode 資料夾下產生 setting.json 檔案（若沒有自動產生可自行建立）\n開啟 setting.json 文件，並替換為以下程式碼\n1 2 3 4 5 6 { \u0026#34;python.linting.flake8Enabled\u0026#34;: true, \u0026#34;python.linting.flake8Args\u0026#34;: [\u0026#34;--max-line-length=248\u0026#34;], \u0026#34;python.linting.pylintEnabled\u0026#34;: false } 此時回到 python 文件，VS Code 右下會彈出警告，點擊下載\n按 CTRL+SHIFT+P 鍵，輸入 Python: Select Interpreter (即 Python：選擇編譯器)\n然後選擇您下載的編譯器即可\n如果 .vscode 資料夾下有 launch.json 文件，需要在該文件的 configurations 中加入以下程式碼\n1 2 3 4 5 6 7 { \u0026#34;name\u0026#34;: \u0026#34;Python: 目前文件\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;python\u0026#34;, \u0026#34;request\u0026#34;: \u0026#34;launch\u0026#34;, \u0026#34;program\u0026#34;: \u0026#34;${file}\u0026#34;, \u0026#34;console\u0026#34;: \u0026#34;integratedTerminal\u0026#34; } 參考文章 VsCode 配置 Python 環境小白教程 VSCode 配置 Python 教程 ","date":"2021-11-07T11:28:58+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/5/","title":"VsCode 配置 Python 環境"},{"content":" 該文章使用 Google 翻譯處理。\n該文章由 Hiyoung 編寫\nmailto：可以自動調用當前系統默認的郵件客戶端，並自動填充收件人、抄送人、密送人、主題、內容。\n參數說明:\nmailto： 收件人，多個以;分隔\ncc： 抄送人，多個以;分隔\nbcc： 密送人，多以;分隔\nsubject： 主題\nbody： 內容\n各參數間用\u0026amp;連接即可\n例如：\u0026lt;a mailto:***@***.com?subject=this is subject\u0026amp;body=this is body\u0026gt;…\u0026lt;a\u0026gt;\n注：在 elementor 中應在文本編輯器的超鏈接選項中直接填寫 mailto:***@***.com?subject=this is subject\u0026amp;body=this is body 即可\n","date":"2021-11-06T17:05:36+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/4/","title":"如何自動呼叫目前系統預設的郵件用戶端"},{"content":" 該文章使用 Google 翻譯處理。\n正文 首先到待嵌入的視頻將鼠標移到分享按鈕上（不用點擊）\n然後移到嵌入代碼並複制\n（本例代碼如下）\n1 \u0026lt;iframe src=\u0026#34;//player.bilibili.com/player.html?aid=583631611\u0026amp;bvid=BV1Tz4y1X7Bg\u0026amp;cid=206708397\u0026amp;page=1\u0026#34; scrolling=\u0026#34;no\u0026#34; border=\u0026#34;0\u0026#34; frameborder=\u0026#34;no\u0026#34; framespacing=\u0026#34;0\u0026#34; allowfullscreen=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;/iframe\u0026gt; 我們需要這串程式碼中的「aid」和「cid」部分（即 aid=583631611 和 cid=206708397 ）\n然後將 aid 和 cid 填入下方代碼的對應位置\n1 2 3 \u0026lt;div style=\u0026#34;position: relative; padding: 30% 45%;\u0026#34;\u0026gt; \u0026lt;iframe style=\u0026#34;position: absolute; width: 100%; height: 100%; left: 0; top: 0;\u0026#34; src=\u0026#34;https://player.bilibili.com/player.html?cid=206708397\u0026amp;aid=583631611\u0026amp;page=1\u0026amp;as_wide=1\u0026amp;high_quality=1\u0026amp;danmaku=0\u0026#34; frameborder=\u0026#34;no\u0026#34; scrolling=\u0026#34;no\u0026#34;\u0026gt;\u0026lt;/iframe\u0026gt; \u0026lt;/div\u0026gt; （以上代碼中 aid 和 cid 已替換）\n在寫文章的過程若插入影片只需將區塊設為「自訂 HTML」然後把替換好aid和cid的程式碼拷貝過去即可\n如下為示例視頻\n參考文章 關於博客園內嵌入 bilibili 視頻 ","date":"2021-11-06T16:43:20+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/3/","title":"WordPress 嵌入 BiLiBiLi 影片說明"},{"content":" 該文章使用 Google 翻譯處理。\n預設情況下，WordPress 允許作者查看您網站媒體庫中的所有圖像。允許作者查看媒體庫中的所有檔案。 他們還可以查看由管理員 ， 編輯或其他作者上傳的圖像。\n對於許多網站而言，這可能並不重要。 但是，如果您運行一個多作者網站 ，則可能需要更改它。\n首先，進入 網站根目錄/wp-content/themes/您目前使用的主題名稱/\n找到 functions.php 檔案並編輯，在末尾插入如下程式碼即可\n1 2 3 4 5 6 7 8 9 10 11 12 // Limit media library access add_filter( \u0026#39;ajax_query_attachments_args\u0026#39;, \u0026#39;wpb_show_current_user_attachments\u0026#39; ); function wpb_show_current_user_attachments( $query ) { $user_id = get_current_user_id(); if ( $user_id \u0026amp;\u0026amp; !current_user_can(\u0026#39;activate_plugins\u0026#39;) \u0026amp;\u0026amp; !current_user_can(\u0026#39;edit_others_posts \u0026#39;) ) { $query[\u0026#39;author\u0026#39;] = $user_id; } return $query; } 參考文章 如何限制媒體庫對 WordPress 中使用者自己上傳的內容的訪問 ","date":"2021-11-06T14:31:04+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/2/","title":"WordPress 限制使用者存取媒體庫"},{"content":" 該文章使用 Google 翻譯處理。\n歡迎使用 WordPress。這是您的第一篇文章。編輯或刪除它，然後開始寫作吧！\n","date":"2021-11-06T14:15:19+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/1/","title":"Hello World！"}]