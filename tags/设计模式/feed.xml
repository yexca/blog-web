<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>设计模式 on yexca'Blog</title><link>https://blog.yexca.net/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link><description>Recent content in 设计模式 on yexca'Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>yexca</copyright><lastBuildDate>Wed, 27 Dec 2023 16:14:15 +0800</lastBuildDate><atom:link href="https://blog.yexca.net/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/feed.xml" rel="self" type="application/rss+xml"/><item><title>设计模式 Index</title><link>https://blog.yexca.net/archives/140/</link><pubDate>Wed, 27 Dec 2023 16:14:15 +0800</pubDate><guid>https://blog.yexca.net/archives/140/</guid><description>&lt;p>简单介绍设计模式&lt;/p>
&lt;ul>
&lt;li>
&lt;a class="link" href="https://blog.yexca.net/archives/108"
>
设计模式 引
&lt;/a>
&lt;/li>
&lt;/ul>
&lt;p>具体的设计模式&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align: center">&lt;/th>
&lt;th style="text-align: center">创建型&lt;/th>
&lt;th style="text-align: center">结构型&lt;/th>
&lt;th style="text-align: center">行为型&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align: center">类&lt;/td>
&lt;td style="text-align: center">工厂方法模式&lt;/td>
&lt;td style="text-align: center">适配器模式 (类)&lt;/td>
&lt;td style="text-align: center">
&lt;a class="link" href="https://blog.yexca.net/archives/126"
>
解释器模式
&lt;/a>
&lt;br />
&lt;a class="link" href="https://blog.yexca.net/archives/138"
>
模板方法模式
&lt;/a>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: center">对象&lt;/td>
&lt;td style="text-align: center">抽象工厂模式&lt;br />
&lt;a class="link" href="https://blog.yexca.net/archives/112"
>
生成器模式
&lt;/a>
&lt;br />
&lt;a class="link" href="https://blog.yexca.net/archives/113"
>
原型模式
&lt;/a>
&lt;br />
&lt;a class="link" href="https://blog.yexca.net/archives/115"
>
单例模式
&lt;/a>
&lt;/td>
&lt;td style="text-align: center">适配器模式 (对象)&lt;br />
&lt;a class="link" href="https://blog.yexca.net/archives/118"
>
桥接模式
&lt;/a>
&lt;br />
&lt;a class="link" href="https://blog.yexca.net/archives/119"
>
组合模式
&lt;/a>
&lt;br />
&lt;a class="link" href="https://blog.yexca.net/archives/120"
>
装饰器模式
&lt;/a>
&lt;br />
&lt;a class="link" href="https://blog.yexca.net/archives/121"
>
外观模式
&lt;/a>
&lt;br />
&lt;a class="link" href="https://blog.yexca.net/archives/122"
>
享元模式
&lt;/a>
&lt;br />
&lt;a class="link" href="https://blog.yexca.net/archives/123"
>
代理模式
&lt;/a>
&lt;/td>
&lt;td style="text-align: center">
&lt;a class="link" href="https://blog.yexca.net/archives/124"
>
责任链模式
&lt;/a>
&lt;br />
&lt;a class="link" href="https://blog.yexca.net/archives/125"
>
命令模式
&lt;/a>
&lt;br />
&lt;a class="link" href="https://blog.yexca.net/archives/127"
>
迭代器模式
&lt;/a>
&lt;br />
&lt;a class="link" href="https://blog.yexca.net/archives/128"
>
中介者模式
&lt;/a>
&lt;br />
&lt;a class="link" href="https://blog.yexca.net/archives/132"
>
备忘录模式
&lt;/a>
&lt;br />
&lt;a class="link" href="https://blog.yexca.net/archives/134"
>
观察者模式
&lt;/a>
&lt;br />
&lt;a class="link" href="https://blog.yexca.net/archives/136"
>
状态模式
&lt;/a>
&lt;br />
&lt;a class="link" href="https://blog.yexca.net/archives/137"
>
策略模式
&lt;/a>
&lt;br />
&lt;a class="link" href="https://blog.yexca.net/archives/139"
>
访问者模式
&lt;/a>
&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>其中&lt;/p></description></item><item><title>访问者模式</title><link>https://blog.yexca.net/archives/139/</link><pubDate>Tue, 26 Dec 2023 16:09:09 +0800</pubDate><guid>https://blog.yexca.net/archives/139/</guid><description>&lt;p>Visitor Pattern 对象行为型模式&lt;/p>
&lt;h2 id="意图">意图
&lt;/h2>&lt;p>表示一个作用于某对象结构中的各元素的操作。它不允许在不改变各元素的类的前提下定义作用于这些元素的新操作&lt;/p>
&lt;h2 id="结构">结构
&lt;/h2>&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/yexca/picx-images-hosting@master/2023/03-%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f/%e8%ae%bf%e9%97%ae%e8%80%85%e6%a8%a1%e5%bc%8f.5psqrqdq7gs0.webp"
loading="lazy"
alt="访问者模式"
>&lt;/p>
&lt;p>其中：&lt;/p>
&lt;ul>
&lt;li>Visitor (访问者) 为该对象结构中 ConcreteElement 的每一个类声明一个 Visit 操作。该操作的名字和特殊标识了发送 Visit 请求给该访问者的那个类，这使得访问者可以确定正被访问元素的具体的类。这样访问者就可以通过该元素的特定接口直接访问它&lt;/li>
&lt;li>ConcreteVisitor (具体访问者) 实现每个有 Visitor 声明的操作，每个操作实现本算法的一部分，而该算法片段乃是对应于结构中对象的类。ConcreteVisitor 为该算法提供了上下文并存储它的局部状态。这一状态常常在遍历该结构的过程中累积结构&lt;/li>
&lt;li>Element (元素) 定义以一个访问者为参数的 Accept 操作&lt;/li>
&lt;li>ConcreteElement (具体元素) 实现以一个访问者为参数的 Accept 操作&lt;/li>
&lt;li>ObjectStructure (对象结构) 能枚举它的元素；可以提供一个高层的接口以允许该访问者访问它的元素；可以是一个组合或者一个集合，如一个列表或一个无序集合&lt;/li>
&lt;/ul>
&lt;h2 id="适用性">适用性
&lt;/h2>&lt;p>Visitor 模式适用于：&lt;/p></description></item><item><title>模板方法模式</title><link>https://blog.yexca.net/archives/138/</link><pubDate>Mon, 25 Dec 2023 21:06:06 +0800</pubDate><guid>https://blog.yexca.net/archives/138/</guid><description>&lt;p>Template Method Pattern 类行为型模式&lt;/p>
&lt;h2 id="意图">意图
&lt;/h2>&lt;p>定义一个操作中的算法骨架，而将一些步骤延迟到子类中。Template Method 使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤&lt;/p></description></item><item><title>策略模式</title><link>https://blog.yexca.net/archives/137/</link><pubDate>Sun, 24 Dec 2023 18:30:30 +0800</pubDate><guid>https://blog.yexca.net/archives/137/</guid><description>&lt;p>Strategy Pattern 对象行为型模式&lt;/p>
&lt;h2 id="意图">意图
&lt;/h2>&lt;p>定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。此模式使得算法可以独立于使用它们的客户而变化&lt;/p>
&lt;h2 id="结构">结构
&lt;/h2>&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/yexca/picx-images-hosting@master/2023/03-%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f/%e7%ad%96%e7%95%a5%e6%a8%a1%e5%bc%8f.71vxrbauk9s0.webp"
loading="lazy"
alt="策略模式"
>&lt;/p>
&lt;p>其中：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Strategy (策略) 定义所有支持的算法的公共接口。Context 使用这个接口来调用某 ConcreteStrategy 定义的算法&lt;/p></description></item><item><title>状态模式</title><link>https://blog.yexca.net/archives/136/</link><pubDate>Fri, 22 Dec 2023 15:11:16 +0800</pubDate><guid>https://blog.yexca.net/archives/136/</guid><description>&lt;p>State Pattern 对象行为型模式&lt;/p>
&lt;h2 id="意图">意图
&lt;/h2>&lt;p>允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类&lt;/p>
&lt;h2 id="结构">结构
&lt;/h2>&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/yexca/picx-images-hosting@master/2023/03-%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f/%e7%8a%b6%e6%80%81%e6%a8%a1%e5%bc%8f.775ry4zlh4g0.webp"
loading="lazy"
alt="状态模式"
>&lt;/p>
&lt;p>其中：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Context (上下文) 定义客户感兴趣的接口：维护一个 ConcerteState 子类的实例，这个实例定义当前状态&lt;/p></description></item><item><title>观察者模式</title><link>https://blog.yexca.net/archives/134/</link><pubDate>Thu, 21 Dec 2023 01:18:25 +0800</pubDate><guid>https://blog.yexca.net/archives/134/</guid><description>&lt;p>Observer Pattern 对象行为型模式&lt;/p>
&lt;h2 id="意图">意图
&lt;/h2>&lt;p>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变吋，所有依赖于它的对象都得到通知并被自动更新&lt;/p>
&lt;h2 id="结构">结构
&lt;/h2>&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/yexca/picx-images-hosting@master/2023/03-%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f/%e8%a7%82%e5%af%9f%e8%80%85%e6%a8%a1%e5%bc%8f.5x607bf0xvw0.webp"
loading="lazy"
alt="观察者模式"
>&lt;/p>
&lt;p>其中：&lt;/p>
&lt;ul>
&lt;li>Subject (目标) 知道它的观察者，可以有任意多个观察者观察同一个目标；提供注册和删除观察者对象的接口&lt;/li>
&lt;li>Observer (观察者) 为那些在&amp;quot;目标发生改变时需获得通知的对象定义一个更新接口&lt;/li>
&lt;li>ConcreteSubject (具体目标) 将有关状态存入各 ConcreteObserver 对象：当它的状态发生改变时，向它的各个观察者发出通知&lt;/li>
&lt;li>ConcreteObserver (具体观察者) 维护一个指向 ConcreteSubject 对象的引用：存储有关状态，这些状态应与目标的状态保持一致：实现 Observer 的更新接口，以使自身状态与目标的状态保持一致&lt;/li>
&lt;/ul>
&lt;h2 id="适用性">适用性
&lt;/h2>&lt;p>Observer 模式适用于：&lt;/p></description></item><item><title>备忘录模式</title><link>https://blog.yexca.net/archives/132/</link><pubDate>Mon, 27 Nov 2023 14:08:05 +0800</pubDate><guid>https://blog.yexca.net/archives/132/</guid><description>&lt;p>Memento Pattern 对象行为型模式&lt;/p>
&lt;h2 id="意图">意图
&lt;/h2>&lt;p>在不破坏封装性的前提下捕获一个对象的内部状态，并在对象之外保存这个状态。这样以后就可以将对象恢复到原先保存的状态&lt;/p>
&lt;h2 id="结构">结构
&lt;/h2>&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/yexca/picx-images-hosting@master/2023/03-%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f/%e5%a4%87%e5%bf%98%e5%bd%95%e6%a8%a1%e5%bc%8f.5pa8d63vllc0.webp"
loading="lazy"
alt="备忘录模式"
>&lt;/p>
&lt;p>其中：&lt;/p>
&lt;ul>
&lt;li>Memento (备忘录) 存储原发器对象的内部状态，原发器根据需要决定备忘录存储原发器的哪些内部状态；防止原发器以外的其他对象访问备忘录&lt;/li>
&lt;li>Originator (原发器) 创建一个备忘录，用于记录当前时刻它的内部状态；使用备忘录恢复内部状态&lt;/li>
&lt;li>Caretaker (管理者) 负责保存好备忘录；不能对备忘录的内容进行操作或检查&lt;/li>
&lt;/ul>
&lt;h2 id="适用性">适用性
&lt;/h2>&lt;p>Memento 模式适用于：&lt;/p></description></item><item><title>中介者模式</title><link>https://blog.yexca.net/archives/128/</link><pubDate>Sun, 15 Oct 2023 17:14:26 +0800</pubDate><guid>https://blog.yexca.net/archives/128/</guid><description>&lt;p>Mediator Pattern 对象行为型模式&lt;/p>
&lt;h2 id="意图">意图
&lt;/h2>&lt;p>用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间地交互&lt;/p></description></item><item><title>迭代器模式</title><link>https://blog.yexca.net/archives/127/</link><pubDate>Thu, 12 Oct 2023 09:09:24 +0800</pubDate><guid>https://blog.yexca.net/archives/127/</guid><description>&lt;p>Iterator Pattern 对象行为型模式&lt;/p>
&lt;h2 id="意图">意图
&lt;/h2>&lt;p>提供一种方法顺序访问一个聚合对象中的各个元素，且不需要暴露该对象的内部表示&lt;/p>
&lt;h2 id="结构">结构
&lt;/h2>&lt;p>&lt;img src="https://cdn.statically.io/gh/yexca/picx-images-hosting@master/2023/03-%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f/%e8%bf%ad%e4%bb%a3%e5%99%a8%e6%a8%a1%e5%bc%8f.3qxn134hel60.webp"
loading="lazy"
alt="迭代器模式"
>&lt;/p>
&lt;p>其中：&lt;/p>
&lt;ul>
&lt;li>Iterator (迭代器) 定义访问和遍历元素的接口&lt;/li>
&lt;li>ConcreteIterator (具体迭代器) 实现迭代器接口；对该聚合遍历时跟踪当前位置&lt;/li>
&lt;li>Aggregate (聚合) 定义创建相应迭代器对象的接口&lt;/li>
&lt;li>ConcreteAggregate (具体聚合) 实现创建相应迭代器的接口，该操作返回 ConcreteIterator 的一个适当的实例&lt;/li>
&lt;/ul>
&lt;h2 id="适用性">适用性
&lt;/h2>&lt;p>Iterator 模式适用于：&lt;/p></description></item><item><title>解释器模式</title><link>https://blog.yexca.net/archives/126/</link><pubDate>Mon, 09 Oct 2023 17:31:58 +0800</pubDate><guid>https://blog.yexca.net/archives/126/</guid><description>&lt;p>Interpreter Pattern 类行为型模式&lt;/p>
&lt;h2 id="意图">意图
&lt;/h2>&lt;p>给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子&lt;/p>
&lt;h2 id="结构">结构
&lt;/h2>&lt;p>&lt;img src="https://cdn.statically.io/gh/yexca/picx-images-hosting@master/2021/%e8%a7%a3%e9%87%8a%e5%99%a8%e6%a8%a1%e5%bc%8f.67y5fd2xby40.webp"
loading="lazy"
alt="解释器模式"
>&lt;/p>
&lt;p>其中：&lt;/p>
&lt;ul>
&lt;li>AbstractExpression 声明一个程序的解释操作，这个接口为抽象语法树中所有的结点所共享&lt;/li>
&lt;li>TerminalExpression 实现与文法中的终结符相关联的解释操作；一个句子中的每个终结符需要该类的一个实例&lt;/li>
&lt;li>NonterminalExpression 对文法中的每一条规则都需要一个 NonterminalExpression 类；为每个符号都维护一个 AbstractExpression 类型的实例变量；为文法中的非终结符实现解释 (Interpret) 操作&lt;/li>
&lt;li>Context 包含解释器之外的一些全局信息&lt;/li>
&lt;li>Client 构建 (或被给定) 表示该文法定义的语言中一个特定的句子的抽象语法树，该抽象语法树由 NonterminalExpression 和 TerminalExpression 的实例装配而成；调用解释操作&lt;/li>
&lt;/ul>
&lt;h2 id="适用性">适用性
&lt;/h2>&lt;p>Interpreter 模式适用于当有一个语言需要解释执行，并且可将该语言中的句子表示为一个抽象语法树时，以下情况效果最好：&lt;/p></description></item><item><title>命令模式</title><link>https://blog.yexca.net/archives/125/</link><pubDate>Sun, 10 Sep 2023 15:26:55 +0800</pubDate><guid>https://blog.yexca.net/archives/125/</guid><description>&lt;p>Command Pattern 对象行为型模式&lt;/p>
&lt;h2 id="意图">意图
&lt;/h2>&lt;p>将一个请求封装为一个对象，从而使得可以用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作&lt;/p>
&lt;h2 id="结构">结构
&lt;/h2>&lt;p>&lt;img src="https://cdn.statically.io/gh/yexca/picx-images-hosting@master/2023/03-%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f/%e5%91%bd%e4%bb%a4%e6%a8%a1%e5%bc%8f.5urjyaqm2mo0.webp"
loading="lazy"
alt="命令模式"
>&lt;/p>
&lt;p>其中：&lt;/p>
&lt;ul>
&lt;li>Command 声明执行操作的接口&lt;/li>
&lt;li>ConcreteCommand 将一个接收者对象绑定于一个动作；调用接收者相应的操作，以实现 Execute&lt;/li>
&lt;li>Client 创建一个具体命令对象并设定它的接收者&lt;/li>
&lt;li>Invoker 要求该命令执行这个请求&lt;/li>
&lt;li>Receiver 知道如何实施与执行一个请求相关的操作。任何类都可能作为一个接收者&lt;/li>
&lt;/ul>
&lt;h2 id="适用性">适用性
&lt;/h2>&lt;p>Command 模式适用于：&lt;/p></description></item><item><title>责任链模式</title><link>https://blog.yexca.net/archives/124/</link><pubDate>Sat, 09 Sep 2023 07:02:55 +0800</pubDate><guid>https://blog.yexca.net/archives/124/</guid><description>&lt;p>Chain of Responsibility Pattern 对象行为型模式&lt;/p>
&lt;h2 id="意图">意图
&lt;/h2>&lt;p>使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止&lt;/p></description></item><item><title>代理模式</title><link>https://blog.yexca.net/archives/123/</link><pubDate>Fri, 08 Sep 2023 12:15:26 +0800</pubDate><guid>https://blog.yexca.net/archives/123/</guid><description>&lt;p>Proxy Pattern 对象结构型模式&lt;/p>
&lt;h2 id="意图">意图
&lt;/h2>&lt;p>为其他对象提供一种代理以控制对这个对象的访问&lt;/p>
&lt;h2 id="结构">结构
&lt;/h2>&lt;p>&lt;img src="https://cdn.statically.io/gh/yexca/picx-images-hosting@master/2023/03-%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f/%e4%bb%a3%e7%90%86%e6%a8%a1%e5%bc%8f.1lw7cilzkxds.webp"
loading="lazy"
alt="代理模式"
>&lt;/p>
&lt;p>其中：&lt;/p>
&lt;ul>
&lt;li>Proxy 保存一个引用使得代理可以访问实体；提供一个与 Subject 的接口相同的接口，使代理可以用来代替实体；控制对实体的存取，并可能负责创建和删除它&lt;/li>
&lt;li>Subject 定义 RealSubject 和 Proxy 的共用接口，这样就在任何使用 RealSubject 的地方都可以使用 Proxy&lt;/li>
&lt;li>RealSubject 定义 Proxy 所代表的实体&lt;/li>
&lt;/ul>
&lt;h2 id="适用性">适用性
&lt;/h2>&lt;p>Proxy 模式适用于在需要比较通用和复杂的对象指针代替简单的指针的时候，常见的情况有：&lt;/p></description></item><item><title>享元模式</title><link>https://blog.yexca.net/archives/122/</link><pubDate>Thu, 07 Sep 2023 13:54:55 +0800</pubDate><guid>https://blog.yexca.net/archives/122/</guid><description>&lt;p>Flyweight Pattern 对象结构型模式&lt;/p>
&lt;h2 id="意图">意图
&lt;/h2>&lt;p>运用共享技术有效地支持大量细粒度的对象&lt;/p>
&lt;h2 id="结构">结构
&lt;/h2>&lt;p>&lt;img src="https://cdn.statically.io/gh/yexca/picx-images-hosting@master/2023/03-%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f/%e4%ba%ab%e5%85%83%e6%a8%a1%e5%bc%8f.7jg2ravau7o0.webp"
loading="lazy"
alt="享元模式"
>&lt;/p>
&lt;p>其中：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Flyweight 描述一个接口，通过这个接口 Flyweight 可以接受并作用于外部状态&lt;/p>
&lt;/li>
&lt;li>
&lt;p>ConcreteFlyweight 实现 Flyweight 接口，并为内部状态 (如果有) 增加存储空间。ConcreteFlyweight 对象必项是可共享的。它所存储的状态必须是内部的，即它必须独立于 ConcreteFlyweight 对象的场景&lt;/p></description></item><item><title>外观模式</title><link>https://blog.yexca.net/archives/121/</link><pubDate>Wed, 06 Sep 2023 03:02:02 +0800</pubDate><guid>https://blog.yexca.net/archives/121/</guid><description>&lt;p>Facade Pattern 对象结构型模式&lt;/p>
&lt;h2 id="意图">意图
&lt;/h2>&lt;p>为子系统中的一组接口提供一个一致的界面，Facade 模式定义了一个高层接口，这个接口使得这一子系统更加容易使用&lt;/p>
&lt;h2 id="结构">结构
&lt;/h2>&lt;p>&lt;img src="https://cdn.statically.io/gh/yexca/picx-images-hosting@master/2023/03-%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f/%e5%a4%96%e8%a7%82%e6%a8%a1%e5%bc%8f.6awzfhe505c0.webp"
loading="lazy"
alt="外观模式"
>&lt;/p>
&lt;p>其中：&lt;/p>
&lt;ul>
&lt;li>Facade 知道哪些子系统类负责处理请求；将客户的请求代理给适当的子系统对象&lt;/li>
&lt;li>Subsystem classes 实现子系统的功能；处理有 Facade 对象指派的任务；没有 Facade 的任何相关信息，即没有指向 Facade 的指针&lt;/li>
&lt;/ul>
&lt;h2 id="适用性">适用性
&lt;/h2>&lt;p>Facade 模式适用于：&lt;/p></description></item><item><title>装饰器模式</title><link>https://blog.yexca.net/archives/120/</link><pubDate>Tue, 05 Sep 2023 21:45:45 +0800</pubDate><guid>https://blog.yexca.net/archives/120/</guid><description>&lt;p>Decorator Pattern 对象结构型模式&lt;/p>
&lt;h2 id="意图">意图
&lt;/h2>&lt;p>动态地给一个对象添加一些额外的职责。就增加功能而言，Decorator 模式比生成子类更加灵活&lt;/p>
&lt;h2 id="结构">结构
&lt;/h2>&lt;p>&lt;img src="https://cdn.statically.io/gh/yexca/picx-images-hosting@master/2023/03-%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f/%e8%a3%85%e9%a5%b0%e5%99%a8.2xwcg7gcu640.webp"
loading="lazy"
alt="装饰器"
>&lt;/p>
&lt;p>其中：&lt;/p>
&lt;ul>
&lt;li>Component 定义一个对象接口，可以给这些对象动态地添加职责&lt;/li>
&lt;li>ConcreteComponent 定义一个对象，可以给这个对象添加一些职责&lt;/li>
&lt;li>Decorator 维持一个指向 Component 对象的指针，并定义一个与 Component 接口一致的接口&lt;/li>
&lt;li>ConcreteDecorator 向组件添加职责&lt;/li>
&lt;/ul>
&lt;h2 id="适用性">适用性
&lt;/h2>&lt;p>Decorator 模式适用于：&lt;/p></description></item><item><title>组合模式</title><link>https://blog.yexca.net/archives/119/</link><pubDate>Sun, 03 Sep 2023 15:44:45 +0800</pubDate><guid>https://blog.yexca.net/archives/119/</guid><description>&lt;p>Composite Pattern 对象结构型模式&lt;/p>
&lt;h2 id="意图">意图
&lt;/h2>&lt;p>将对象组合成树型结构以表示 &amp;ldquo;部分 - 整体&amp;rdquo; 的层次结构。Composite 使得用户对单个对象和组合对象的使用具有一致性&lt;/p></description></item><item><title>桥接模式</title><link>https://blog.yexca.net/archives/118/</link><pubDate>Sat, 02 Sep 2023 17:34:34 +0800</pubDate><guid>https://blog.yexca.net/archives/118/</guid><description>&lt;p>Bridge Pattern 对象结构型模式&lt;/p>
&lt;h2 id="意图">意图
&lt;/h2>&lt;p>将抽象部分与其实现部分分离，使它们都可以独立地变化&lt;/p>
&lt;h2 id="结构">结构
&lt;/h2>&lt;p>&lt;img src="https://cdn.statically.io/gh/yexca/picx-images-hosting@master/2023/03-%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f/%e6%a1%a5%e6%8e%a5%e6%a8%a1%e5%bc%8f.63qf1btnav80.webp"
loading="lazy"
alt="桥接模式"
>&lt;/p>
&lt;p>其中：&lt;/p>
&lt;ul>
&lt;li>Abstraction 定义抽象类的接口，维护一个指向 Implementor 类型对象的指针&lt;/li>
&lt;li>RefinedAbstraction 扩充由 Abstraction 定义的接口&lt;/li>
&lt;li>Implementor 定义实现类的接口，该接口不一定要与 Abstraction 的接口完全一致；事实上这两个接口可以完全不同
一般来说，Implementor 接口仅提供基本操作，而 Abstraction 定义了基于这些基本操作的较高层次的操作&lt;/li>
&lt;li>ConcreteImplementor 实现 Implementor 接口并定义它的具体实现&lt;/li>
&lt;/ul>
&lt;h2 id="适用性">适用性
&lt;/h2>&lt;p>Bridge 模式适用于：&lt;/p></description></item><item><title>适配器模式</title><link>https://blog.yexca.net/archives/117/</link><pubDate>Fri, 01 Sep 2023 15:03:03 +0800</pubDate><guid>https://blog.yexca.net/archives/117/</guid><description>&lt;p>Adapter Pattern 类结构型模式/对象结构型模式&lt;/p>
&lt;h2 id="意图">意图
&lt;/h2>&lt;p>将一个类的接口转换成客户希望的另外一个接口。Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作&lt;/p></description></item><item><title>单例模式</title><link>https://blog.yexca.net/archives/115/</link><pubDate>Wed, 05 Jul 2023 13:58:25 +0800</pubDate><guid>https://blog.yexca.net/archives/115/</guid><description>&lt;p>Singleton Pattern 对象创建型模式&lt;/p>
&lt;h2 id="意图">意图
&lt;/h2>&lt;p>保证一个类仅有一个实例，并提供一个访问它的全局访问点&lt;/p>
&lt;h2 id="结构">结构
&lt;/h2>&lt;p>&lt;img src="https://cdn.statically.io/gh/yexca/picx-images-hosting@master/2023/03-%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f/%e5%8d%95%e4%be%8b%e6%a8%a1%e5%bc%8f.47bqfvzklxk0.webp"
loading="lazy"
>&lt;/p>
&lt;p>其中：&lt;/p>
&lt;ul>
&lt;li>Singleton 指定一个 Instance 操作，允许客户访问它的唯一实例&lt;/li>
&lt;li>Instance 是一个类操作；可能负责创建它自己的唯一实例&lt;/li>
&lt;/ul>
&lt;h2 id="适用性">适用性
&lt;/h2>&lt;p>Singleton 模式适用于：&lt;/p></description></item><item><title>原型模式</title><link>https://blog.yexca.net/archives/113/</link><pubDate>Fri, 02 Jun 2023 19:31:44 +0800</pubDate><guid>https://blog.yexca.net/archives/113/</guid><description>&lt;p>Prototype Pattern 对象创建型模式&lt;/p>
&lt;h2 id="意图">意图
&lt;/h2>&lt;p>用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象&lt;/p>
&lt;h2 id="结构">结构
&lt;/h2>&lt;p>&lt;img src="https://cdn.statically.io/gh/yexca/image_hosting@master/2023/03-%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f/%e5%8e%9f%e5%9e%8b%e6%a8%a1%e5%bc%8f.550t72mfloo0.webp"
loading="lazy"
>&lt;/p>
&lt;p>其中：&lt;/p>
&lt;ul>
&lt;li>Prototype 声明一个复制自身的接口&lt;/li>
&lt;li>ConcretePrototype 实现一个复制自身的操作&lt;/li>
&lt;li>Client 让一个原型复制自身从而创建一个新的对象&lt;/li>
&lt;/ul>
&lt;h2 id="适用性">适用性
&lt;/h2>&lt;p>Prototype 模式适用于：&lt;/p></description></item><item><title>生成器模式</title><link>https://blog.yexca.net/archives/112/</link><pubDate>Thu, 01 Jun 2023 23:33:17 +0800</pubDate><guid>https://blog.yexca.net/archives/112/</guid><description>&lt;p>Builder Pattern 对象创建型模式&lt;/p>
&lt;h2 id="意图">意图
&lt;/h2>&lt;p>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示&lt;/p>
&lt;h2 id="结构">结构
&lt;/h2>&lt;p>&lt;img src="https://cdn.statically.io/gh/yexca/picx-images-hosting@master/2023/03-%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f/%e7%94%9f%e6%88%90%e5%99%a8%e6%a8%a1%e5%bc%8f.52btnuzz5780.webp"
loading="lazy"
alt="img"
>&lt;/p>
&lt;p>其中：&lt;/p>
&lt;ul>
&lt;li>Builder 为创建一个 Product 对象的各个部件指定抽象接口&lt;/li>
&lt;li>ConcreteBuilder 实现 Builder 的接口以构造和装配该产品的各个部件，定义并明确它所创建的表示，提供一个检索产品的接口&lt;/li>
&lt;li>Director 构造一个使用 Builder 接口的对象&lt;/li>
&lt;li>Product 表示被构建的复杂对象。ConcreteBuilder 创建该产品的内部表示并定义它的装配过程。包含定义组成组件的类，包括将这些组件装配成最终产品的接口&lt;/li>
&lt;/ul>
&lt;h2 id="适用性">适用性
&lt;/h2>&lt;p>Builder 模式适用于：&lt;/p></description></item><item><title>工厂模式</title><link>https://blog.yexca.net/archives/111/</link><pubDate>Sun, 28 May 2023 10:23:46 +0800</pubDate><guid>https://blog.yexca.net/archives/111/</guid><description>&lt;h2 id="简单工厂模式">简单工厂模式
&lt;/h2>&lt;p>简单工厂模式属于创建型模式，但&lt;strong>不属于&lt;/strong> 23 种设计模式之一&lt;/p>
&lt;p>定义：定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类&lt;/p></description></item><item><title>设计模式 引</title><link>https://blog.yexca.net/archives/108/</link><pubDate>Wed, 17 May 2023 22:50:20 +0800</pubDate><guid>https://blog.yexca.net/archives/108/</guid><description>&lt;p>&amp;ldquo;每一个设计模式描述了一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心。这样，你就能一次又一次地使用该方案而不必做重复劳动&amp;rdquo;。设计模式的核心在于提供了相关问题的解决方案，使得人们可以简单方便地复用成功的设计和体系结构&lt;/p></description></item></channel></rss>